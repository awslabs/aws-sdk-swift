// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessLog: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case emitInterval = "EmitInterval"
        case enabled = "Enabled"
        case s3BucketName = "S3BucketName"
        case s3BucketPrefix = "S3BucketPrefix"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let emitInterval = emitInterval {
            try container.encode(emitInterval, forKey: Key("EmitInterval"))
        }
        if enabled != false {
            try container.encode(enabled, forKey: Key("Enabled"))
        }
        if let s3BucketName = s3BucketName {
            try container.encode(s3BucketName, forKey: Key("S3BucketName"))
        }
        if let s3BucketPrefix = s3BucketPrefix {
            try container.encode(s3BucketPrefix, forKey: Key("S3BucketPrefix"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let emitIntervalDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .emitInterval)
        emitInterval = emitIntervalDecoded
        let s3BucketPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketPrefix)
        s3BucketPrefix = s3BucketPrefixDecoded
    }
}

extension AccessLog: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessLog(emitInterval: \(String(describing: emitInterval)), enabled: \(String(describing: enabled)), s3BucketName: \(String(describing: s3BucketName)), s3BucketPrefix: \(String(describing: s3BucketPrefix)))"}
}

/// <p>Information about the <code>AccessLog</code> attribute.</p>
public struct AccessLog: Equatable {
    /// <p>The interval for publishing the access logs. You can specify an interval of either 5 minutes or 60 minutes.</p>
    ///         <p>Default: 60 minutes</p>
    public let emitInterval: Int?
    /// <p>Specifies whether access logs are enabled for the load balancer.</p>
    public let enabled: Bool
    /// <p>The name of the Amazon S3 bucket where the access logs are stored.</p>
    public let s3BucketName: String?
    /// <p>The logical hierarchy you created for your Amazon S3 bucket, for example <code>my-bucket-prefix/prod</code>.
    ///             If the prefix is not provided, the log is placed at the root level of the bucket.</p>
    public let s3BucketPrefix: String?

    public init (
        emitInterval: Int? = nil,
        enabled: Bool = false,
        s3BucketName: String? = nil,
        s3BucketPrefix: String? = nil
    )
    {
        self.emitInterval = emitInterval
        self.enabled = enabled
        self.s3BucketName = s3BucketName
        self.s3BucketPrefix = s3BucketPrefix
    }
}

extension AccessPointNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessPointNotFoundException(message: \(String(describing: message)))"}
}

extension AccessPointNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<AccessPointNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified load balancer does not exist.</p>
public struct AccessPointNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessPointNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension AccessPointNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AddTagsInputBodyMiddleware: Middleware {
    public let id: String = "AddTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsInput>
    public typealias MOutput = OperationOutput<AddTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsOutputError>
}

extension AddTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsInput(loadBalancerNames: \(String(describing: loadBalancerNames)), tags: \(String(describing: tags)))"}
}

extension AddTagsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancerNames = loadBalancerNames {
            var loadBalancerNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("LoadBalancerNames"))
            for (index0, accesspointname0) in loadBalancerNames.enumerated() {
                try loadBalancerNamesContainer.encode(accesspointname0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("AddTags", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct AddTagsInputHeadersMiddleware: Middleware {
    public let id: String = "AddTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsInput>
    public typealias MOutput = OperationOutput<AddTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsOutputError>
}

public struct AddTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "AddTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsInput>
    public typealias MOutput = OperationOutput<AddTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsOutputError>
}

/// <p>Contains the parameters for AddTags.</p>
public struct AddTagsInput: Equatable {
    /// <p>The name of the load balancer. You can specify one load balancer only.</p>
    public let loadBalancerNames: [String]?
    /// <p>The tags.</p>
    public let tags: [Tag]?

    public init (
        loadBalancerNames: [String]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.loadBalancerNames = loadBalancerNames
        self.tags = tags
    }
}

extension AddTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsOutputResponse()"}
}

extension AddTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Contains the output of AddTags.</p>
public struct AddTagsOutputResponse: Equatable {

    public init() {}
}

struct AddTagsOutputResponseBody: Equatable {
}

extension AddTagsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AdditionalAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let key = key {
            try container.encode(key, forKey: Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("Value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AdditionalAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdditionalAttribute(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Information about additional load balancer attributes.</p>
public struct AdditionalAttribute: Equatable {
    /// <p>The name of the attribute.</p>
    ///         <p>The following attribute is supported.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>elb.http.desyncmitigationmode</code> - Determines how the load balancer handles requests that
    ///                     might pose a security risk to your application. The possible values are <code>monitor</code>,
    ///                     <code>defensive</code>, and <code>strictest</code>. The default is <code>defensive</code>.</p>
    ///             </li>
    ///          </ul>
    public let key: String?
    /// <p>This value of the attribute.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension AppCookieStickinessPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cookieName = "CookieName"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let cookieName = cookieName {
            try container.encode(cookieName, forKey: Key("CookieName"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let cookieNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cookieName)
        cookieName = cookieNameDecoded
    }
}

extension AppCookieStickinessPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AppCookieStickinessPolicy(cookieName: \(String(describing: cookieName)), policyName: \(String(describing: policyName)))"}
}

/// <p>Information about a policy for application-controlled session stickiness.</p>
public struct AppCookieStickinessPolicy: Equatable {
    /// <p>The name of the application cookie used for stickiness.</p>
    public let cookieName: String?
    /// <p>The mnemonic name for the policy being created. The name must be unique within a set of policies for this load balancer.</p>
    public let policyName: String?

    public init (
        cookieName: String? = nil,
        policyName: String? = nil
    )
    {
        self.cookieName = cookieName
        self.policyName = policyName
    }
}

public struct ApplySecurityGroupsToLoadBalancerInputBodyMiddleware: Middleware {
    public let id: String = "ApplySecurityGroupsToLoadBalancerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApplySecurityGroupsToLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<ApplySecurityGroupsToLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApplySecurityGroupsToLoadBalancerInput>
    public typealias MOutput = OperationOutput<ApplySecurityGroupsToLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApplySecurityGroupsToLoadBalancerOutputError>
}

extension ApplySecurityGroupsToLoadBalancerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplySecurityGroupsToLoadBalancerInput(loadBalancerName: \(String(describing: loadBalancerName)), securityGroups: \(String(describing: securityGroups)))"}
}

extension ApplySecurityGroupsToLoadBalancerInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SecurityGroups"))
            for (index0, securitygroupid0) in securityGroups.enumerated() {
                try securityGroupsContainer.encode(securitygroupid0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ApplySecurityGroupsToLoadBalancer", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct ApplySecurityGroupsToLoadBalancerInputHeadersMiddleware: Middleware {
    public let id: String = "ApplySecurityGroupsToLoadBalancerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApplySecurityGroupsToLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<ApplySecurityGroupsToLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApplySecurityGroupsToLoadBalancerInput>
    public typealias MOutput = OperationOutput<ApplySecurityGroupsToLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApplySecurityGroupsToLoadBalancerOutputError>
}

public struct ApplySecurityGroupsToLoadBalancerInputQueryItemMiddleware: Middleware {
    public let id: String = "ApplySecurityGroupsToLoadBalancerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApplySecurityGroupsToLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<ApplySecurityGroupsToLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApplySecurityGroupsToLoadBalancerInput>
    public typealias MOutput = OperationOutput<ApplySecurityGroupsToLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApplySecurityGroupsToLoadBalancerOutputError>
}

/// <p>Contains the parameters for ApplySecurityGroupsToLoadBalancer.</p>
public struct ApplySecurityGroupsToLoadBalancerInput: Equatable {
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?
    /// <p>The IDs of the security groups to associate with the load balancer. Note that you cannot specify the name of the security group.</p>
    public let securityGroups: [String]?

    public init (
        loadBalancerName: String? = nil,
        securityGroups: [String]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.securityGroups = securityGroups
    }
}

extension ApplySecurityGroupsToLoadBalancerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ApplySecurityGroupsToLoadBalancerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurityGroupException" : self = .invalidSecurityGroupException(try InvalidSecurityGroupException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ApplySecurityGroupsToLoadBalancerOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case invalidSecurityGroupException(InvalidSecurityGroupException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ApplySecurityGroupsToLoadBalancerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplySecurityGroupsToLoadBalancerOutputResponse(securityGroups: \(String(describing: securityGroups)))"}
}

extension ApplySecurityGroupsToLoadBalancerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ApplySecurityGroupsToLoadBalancerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.securityGroups = output.securityGroups
        } else {
            self.securityGroups = nil
        }
    }
}

/// <p>Contains the output of ApplySecurityGroupsToLoadBalancer.</p>
public struct ApplySecurityGroupsToLoadBalancerOutputResponse: Equatable {
    /// <p>The IDs of the security groups associated with the load balancer.</p>
    public let securityGroups: [String]?

    public init (
        securityGroups: [String]? = nil
    )
    {
        self.securityGroups = securityGroups
    }
}

struct ApplySecurityGroupsToLoadBalancerOutputResponseBody: Equatable {
    public let securityGroups: [String]?
}

extension ApplySecurityGroupsToLoadBalancerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case securityGroups = "SecurityGroups"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ApplySecurityGroupsToLoadBalancerResult"))
        if containerValues.contains(.securityGroups) {
            struct KeyVal0{struct member{}}
            let securityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .securityGroups)
            if let securityGroupsWrappedContainer = securityGroupsWrappedContainer {
                let securityGroupsContainer = try securityGroupsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var securityGroupsBuffer:[String]? = nil
                if let securityGroupsContainer = securityGroupsContainer {
                    securityGroupsBuffer = [String]()
                    for stringContainer0 in securityGroupsContainer {
                        securityGroupsBuffer?.append(stringContainer0)
                    }
                }
                securityGroups = securityGroupsBuffer
            } else {
                securityGroups = []
            }
        } else {
            securityGroups = nil
        }
    }
}

public struct AttachLoadBalancerToSubnetsInputBodyMiddleware: Middleware {
    public let id: String = "AttachLoadBalancerToSubnetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachLoadBalancerToSubnetsInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachLoadBalancerToSubnetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachLoadBalancerToSubnetsInput>
    public typealias MOutput = OperationOutput<AttachLoadBalancerToSubnetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachLoadBalancerToSubnetsOutputError>
}

extension AttachLoadBalancerToSubnetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachLoadBalancerToSubnetsInput(loadBalancerName: \(String(describing: loadBalancerName)), subnets: \(String(describing: subnets)))"}
}

extension AttachLoadBalancerToSubnetsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        if let subnets = subnets {
            var subnetsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Subnets"))
            for (index0, subnetid0) in subnets.enumerated() {
                try subnetsContainer.encode(subnetid0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("AttachLoadBalancerToSubnets", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct AttachLoadBalancerToSubnetsInputHeadersMiddleware: Middleware {
    public let id: String = "AttachLoadBalancerToSubnetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachLoadBalancerToSubnetsInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachLoadBalancerToSubnetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachLoadBalancerToSubnetsInput>
    public typealias MOutput = OperationOutput<AttachLoadBalancerToSubnetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachLoadBalancerToSubnetsOutputError>
}

public struct AttachLoadBalancerToSubnetsInputQueryItemMiddleware: Middleware {
    public let id: String = "AttachLoadBalancerToSubnetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachLoadBalancerToSubnetsInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachLoadBalancerToSubnetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachLoadBalancerToSubnetsInput>
    public typealias MOutput = OperationOutput<AttachLoadBalancerToSubnetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachLoadBalancerToSubnetsOutputError>
}

/// <p>Contains the parameters for AttachLoaBalancerToSubnets.</p>
public struct AttachLoadBalancerToSubnetsInput: Equatable {
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?
    /// <p>The IDs of the subnets to add. You can add only one subnet per Availability Zone.</p>
    public let subnets: [String]?

    public init (
        loadBalancerName: String? = nil,
        subnets: [String]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.subnets = subnets
    }
}

extension AttachLoadBalancerToSubnetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AttachLoadBalancerToSubnetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnetException" : self = .invalidSubnetException(try InvalidSubnetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetNotFoundException" : self = .subnetNotFoundException(try SubnetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AttachLoadBalancerToSubnetsOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case invalidSubnetException(InvalidSubnetException)
    case subnetNotFoundException(SubnetNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachLoadBalancerToSubnetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachLoadBalancerToSubnetsOutputResponse(subnets: \(String(describing: subnets)))"}
}

extension AttachLoadBalancerToSubnetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AttachLoadBalancerToSubnetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.subnets = output.subnets
        } else {
            self.subnets = nil
        }
    }
}

/// <p>Contains the output of AttachLoadBalancerToSubnets.</p>
public struct AttachLoadBalancerToSubnetsOutputResponse: Equatable {
    /// <p>The IDs of the subnets attached to the load balancer.</p>
    public let subnets: [String]?

    public init (
        subnets: [String]? = nil
    )
    {
        self.subnets = subnets
    }
}

struct AttachLoadBalancerToSubnetsOutputResponseBody: Equatable {
    public let subnets: [String]?
}

extension AttachLoadBalancerToSubnetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case subnets = "Subnets"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("AttachLoadBalancerToSubnetsResult"))
        if containerValues.contains(.subnets) {
            struct KeyVal0{struct member{}}
            let subnetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .subnets)
            if let subnetsWrappedContainer = subnetsWrappedContainer {
                let subnetsContainer = try subnetsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var subnetsBuffer:[String]? = nil
                if let subnetsContainer = subnetsContainer {
                    subnetsBuffer = [String]()
                    for stringContainer0 in subnetsContainer {
                        subnetsBuffer?.append(stringContainer0)
                    }
                }
                subnets = subnetsBuffer
            } else {
                subnets = []
            }
        } else {
            subnets = nil
        }
    }
}

extension BackendServerDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instancePort = "InstancePort"
        case policyNames = "PolicyNames"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if instancePort != 0 {
            try container.encode(instancePort, forKey: Key("InstancePort"))
        }
        if let policyNames = policyNames {
            var policyNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PolicyNames"))
            for (index0, policyname0) in policyNames.enumerated() {
                try policyNamesContainer.encode(policyname0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancePortDecoded = try containerValues.decode(Int.self, forKey: .instancePort)
        instancePort = instancePortDecoded
        if containerValues.contains(.policyNames) {
            struct KeyVal0{struct member{}}
            let policyNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyNames)
            if let policyNamesWrappedContainer = policyNamesWrappedContainer {
                let policyNamesContainer = try policyNamesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var policyNamesBuffer:[String]? = nil
                if let policyNamesContainer = policyNamesContainer {
                    policyNamesBuffer = [String]()
                    for stringContainer0 in policyNamesContainer {
                        policyNamesBuffer?.append(stringContainer0)
                    }
                }
                policyNames = policyNamesBuffer
            } else {
                policyNames = []
            }
        } else {
            policyNames = nil
        }
    }
}

extension BackendServerDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackendServerDescription(instancePort: \(String(describing: instancePort)), policyNames: \(String(describing: policyNames)))"}
}

/// <p>Information about the configuration of an EC2 instance.</p>
public struct BackendServerDescription: Equatable {
    /// <p>The port on which the EC2 instance is listening.</p>
    public let instancePort: Int
    /// <p>The names of the policies enabled for the EC2 instance.</p>
    public let policyNames: [String]?

    public init (
        instancePort: Int = 0,
        policyNames: [String]? = nil
    )
    {
        self.instancePort = instancePort
        self.policyNames = policyNames
    }
}

extension CertificateNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CertificateNotFoundException(message: \(String(describing: message)))"}
}

extension CertificateNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CertificateNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified ARN does not refer to a valid SSL certificate in AWS Identity and Access Management (IAM)
///             or AWS Certificate Manager (ACM). Note that if you recently uploaded the certificate to IAM, this error might
///             indicate that the certificate is not fully available yet.</p>
public struct CertificateNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CertificateNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension CertificateNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ConfigureHealthCheckInputBodyMiddleware: Middleware {
    public let id: String = "ConfigureHealthCheckInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfigureHealthCheckInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfigureHealthCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfigureHealthCheckInput>
    public typealias MOutput = OperationOutput<ConfigureHealthCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfigureHealthCheckOutputError>
}

extension ConfigureHealthCheckInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigureHealthCheckInput(healthCheck: \(String(describing: healthCheck)), loadBalancerName: \(String(describing: loadBalancerName)))"}
}

extension ConfigureHealthCheckInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let healthCheck = healthCheck {
            try container.encode(healthCheck, forKey: Key("HealthCheck"))
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        try container.encode("ConfigureHealthCheck", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct ConfigureHealthCheckInputHeadersMiddleware: Middleware {
    public let id: String = "ConfigureHealthCheckInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfigureHealthCheckInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfigureHealthCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfigureHealthCheckInput>
    public typealias MOutput = OperationOutput<ConfigureHealthCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfigureHealthCheckOutputError>
}

public struct ConfigureHealthCheckInputQueryItemMiddleware: Middleware {
    public let id: String = "ConfigureHealthCheckInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfigureHealthCheckInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfigureHealthCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfigureHealthCheckInput>
    public typealias MOutput = OperationOutput<ConfigureHealthCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfigureHealthCheckOutputError>
}

/// <p>Contains the parameters for ConfigureHealthCheck.</p>
public struct ConfigureHealthCheckInput: Equatable {
    /// <p>The configuration information.</p>
    public let healthCheck: HealthCheck?
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?

    public init (
        healthCheck: HealthCheck? = nil,
        loadBalancerName: String? = nil
    )
    {
        self.healthCheck = healthCheck
        self.loadBalancerName = loadBalancerName
    }
}

extension ConfigureHealthCheckOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ConfigureHealthCheckOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ConfigureHealthCheckOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfigureHealthCheckOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigureHealthCheckOutputResponse(healthCheck: \(String(describing: healthCheck)))"}
}

extension ConfigureHealthCheckOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConfigureHealthCheckOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.healthCheck = output.healthCheck
        } else {
            self.healthCheck = nil
        }
    }
}

/// <p>Contains the output of ConfigureHealthCheck.</p>
public struct ConfigureHealthCheckOutputResponse: Equatable {
    /// <p>The updated health check.</p>
    public let healthCheck: HealthCheck?

    public init (
        healthCheck: HealthCheck? = nil
    )
    {
        self.healthCheck = healthCheck
    }
}

struct ConfigureHealthCheckOutputResponseBody: Equatable {
    public let healthCheck: HealthCheck?
}

extension ConfigureHealthCheckOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case healthCheck = "HealthCheck"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ConfigureHealthCheckResult"))
        let healthCheckDecoded = try containerValues.decodeIfPresent(HealthCheck.self, forKey: .healthCheck)
        healthCheck = healthCheckDecoded
    }
}

extension ConnectionDraining: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case timeout = "Timeout"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if enabled != false {
            try container.encode(enabled, forKey: Key("Enabled"))
        }
        if let timeout = timeout {
            try container.encode(timeout, forKey: Key("Timeout"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
    }
}

extension ConnectionDraining: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionDraining(enabled: \(String(describing: enabled)), timeout: \(String(describing: timeout)))"}
}

/// <p>Information about the <code>ConnectionDraining</code> attribute.</p>
public struct ConnectionDraining: Equatable {
    /// <p>Specifies whether connection draining is enabled for the load balancer.</p>
    public let enabled: Bool
    /// <p>The maximum time, in seconds, to keep the existing connections open before deregistering the instances.</p>
    public let timeout: Int?

    public init (
        enabled: Bool = false,
        timeout: Int? = nil
    )
    {
        self.enabled = enabled
        self.timeout = timeout
    }
}

extension ConnectionSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case idleTimeout = "IdleTimeout"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let idleTimeout = idleTimeout {
            try container.encode(idleTimeout, forKey: Key("IdleTimeout"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idleTimeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .idleTimeout)
        idleTimeout = idleTimeoutDecoded
    }
}

extension ConnectionSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionSettings(idleTimeout: \(String(describing: idleTimeout)))"}
}

/// <p>Information about the <code>ConnectionSettings</code> attribute.</p>
public struct ConnectionSettings: Equatable {
    /// <p>The time, in seconds, that the connection is allowed to be idle (no data has been sent over the connection) before it is closed by the load balancer.</p>
    public let idleTimeout: Int?

    public init (
        idleTimeout: Int? = nil
    )
    {
        self.idleTimeout = idleTimeout
    }
}

public struct CreateAppCookieStickinessPolicyInputBodyMiddleware: Middleware {
    public let id: String = "CreateAppCookieStickinessPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAppCookieStickinessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAppCookieStickinessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAppCookieStickinessPolicyInput>
    public typealias MOutput = OperationOutput<CreateAppCookieStickinessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAppCookieStickinessPolicyOutputError>
}

extension CreateAppCookieStickinessPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAppCookieStickinessPolicyInput(cookieName: \(String(describing: cookieName)), loadBalancerName: \(String(describing: loadBalancerName)), policyName: \(String(describing: policyName)))"}
}

extension CreateAppCookieStickinessPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let cookieName = cookieName {
            try container.encode(cookieName, forKey: Key("CookieName"))
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
        try container.encode("CreateAppCookieStickinessPolicy", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct CreateAppCookieStickinessPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAppCookieStickinessPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAppCookieStickinessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAppCookieStickinessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAppCookieStickinessPolicyInput>
    public typealias MOutput = OperationOutput<CreateAppCookieStickinessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAppCookieStickinessPolicyOutputError>
}

public struct CreateAppCookieStickinessPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAppCookieStickinessPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAppCookieStickinessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAppCookieStickinessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAppCookieStickinessPolicyInput>
    public typealias MOutput = OperationOutput<CreateAppCookieStickinessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAppCookieStickinessPolicyOutputError>
}

/// <p>Contains the parameters for CreateAppCookieStickinessPolicy.</p>
public struct CreateAppCookieStickinessPolicyInput: Equatable {
    /// <p>The name of the application cookie used for stickiness.</p>
    public let cookieName: String?
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?
    /// <p>The name of the policy being created. Policy names must consist of alphanumeric characters and dashes (-). This name must be unique within the set of policies for this load balancer.</p>
    public let policyName: String?

    public init (
        cookieName: String? = nil,
        loadBalancerName: String? = nil,
        policyName: String? = nil
    )
    {
        self.cookieName = cookieName
        self.loadBalancerName = loadBalancerName
        self.policyName = policyName
    }
}

extension CreateAppCookieStickinessPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateAppCookieStickinessPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicatePolicyNameException" : self = .duplicatePolicyNameException(try DuplicatePolicyNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyPoliciesException" : self = .tooManyPoliciesException(try TooManyPoliciesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAppCookieStickinessPolicyOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case duplicatePolicyNameException(DuplicatePolicyNameException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case tooManyPoliciesException(TooManyPoliciesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAppCookieStickinessPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAppCookieStickinessPolicyOutputResponse()"}
}

extension CreateAppCookieStickinessPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Contains the output for CreateAppCookieStickinessPolicy.</p>
public struct CreateAppCookieStickinessPolicyOutputResponse: Equatable {

    public init() {}
}

struct CreateAppCookieStickinessPolicyOutputResponseBody: Equatable {
}

extension CreateAppCookieStickinessPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateLBCookieStickinessPolicyInputBodyMiddleware: Middleware {
    public let id: String = "CreateLBCookieStickinessPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLBCookieStickinessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLBCookieStickinessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLBCookieStickinessPolicyInput>
    public typealias MOutput = OperationOutput<CreateLBCookieStickinessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLBCookieStickinessPolicyOutputError>
}

extension CreateLBCookieStickinessPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLBCookieStickinessPolicyInput(cookieExpirationPeriod: \(String(describing: cookieExpirationPeriod)), loadBalancerName: \(String(describing: loadBalancerName)), policyName: \(String(describing: policyName)))"}
}

extension CreateLBCookieStickinessPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let cookieExpirationPeriod = cookieExpirationPeriod {
            try container.encode(cookieExpirationPeriod, forKey: Key("CookieExpirationPeriod"))
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
        try container.encode("CreateLBCookieStickinessPolicy", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct CreateLBCookieStickinessPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLBCookieStickinessPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLBCookieStickinessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLBCookieStickinessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLBCookieStickinessPolicyInput>
    public typealias MOutput = OperationOutput<CreateLBCookieStickinessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLBCookieStickinessPolicyOutputError>
}

public struct CreateLBCookieStickinessPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLBCookieStickinessPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLBCookieStickinessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLBCookieStickinessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLBCookieStickinessPolicyInput>
    public typealias MOutput = OperationOutput<CreateLBCookieStickinessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLBCookieStickinessPolicyOutputError>
}

/// <p>Contains the parameters for CreateLBCookieStickinessPolicy.</p>
public struct CreateLBCookieStickinessPolicyInput: Equatable {
    /// <p>The time period, in seconds, after which the cookie should be considered stale. If you do not specify this parameter, the default value is 0, which indicates that the sticky session should last for the duration of the browser session.</p>
    public let cookieExpirationPeriod: Int?
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?
    /// <p>The name of the policy being created. Policy names must consist of alphanumeric characters and dashes (-). This name must be unique within the set of policies for this load balancer.</p>
    public let policyName: String?

    public init (
        cookieExpirationPeriod: Int? = nil,
        loadBalancerName: String? = nil,
        policyName: String? = nil
    )
    {
        self.cookieExpirationPeriod = cookieExpirationPeriod
        self.loadBalancerName = loadBalancerName
        self.policyName = policyName
    }
}

extension CreateLBCookieStickinessPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateLBCookieStickinessPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicatePolicyNameException" : self = .duplicatePolicyNameException(try DuplicatePolicyNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyPoliciesException" : self = .tooManyPoliciesException(try TooManyPoliciesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLBCookieStickinessPolicyOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case duplicatePolicyNameException(DuplicatePolicyNameException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case tooManyPoliciesException(TooManyPoliciesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLBCookieStickinessPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLBCookieStickinessPolicyOutputResponse()"}
}

extension CreateLBCookieStickinessPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Contains the output for CreateLBCookieStickinessPolicy.</p>
public struct CreateLBCookieStickinessPolicyOutputResponse: Equatable {

    public init() {}
}

struct CreateLBCookieStickinessPolicyOutputResponseBody: Equatable {
}

extension CreateLBCookieStickinessPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateLoadBalancerInputBodyMiddleware: Middleware {
    public let id: String = "CreateLoadBalancerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLoadBalancerInput>
    public typealias MOutput = OperationOutput<CreateLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLoadBalancerOutputError>
}

extension CreateLoadBalancerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLoadBalancerInput(availabilityZones: \(String(describing: availabilityZones)), listeners: \(String(describing: listeners)), loadBalancerName: \(String(describing: loadBalancerName)), scheme: \(String(describing: scheme)), securityGroups: \(String(describing: securityGroups)), subnets: \(String(describing: subnets)), tags: \(String(describing: tags)))"}
}

extension CreateLoadBalancerInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZones"))
            for (index0, availabilityzone0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(availabilityzone0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let listeners = listeners {
            var listenersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Listeners"))
            for (index0, listener0) in listeners.enumerated() {
                try listenersContainer.encode(listener0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        if let scheme = scheme {
            try container.encode(scheme, forKey: Key("Scheme"))
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SecurityGroups"))
            for (index0, securitygroupid0) in securityGroups.enumerated() {
                try securityGroupsContainer.encode(securitygroupid0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let subnets = subnets {
            var subnetsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Subnets"))
            for (index0, subnetid0) in subnets.enumerated() {
                try subnetsContainer.encode(subnetid0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateLoadBalancer", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct CreateLoadBalancerInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLoadBalancerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLoadBalancerInput>
    public typealias MOutput = OperationOutput<CreateLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLoadBalancerOutputError>
}

public struct CreateLoadBalancerInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLoadBalancerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLoadBalancerInput>
    public typealias MOutput = OperationOutput<CreateLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLoadBalancerOutputError>
}

/// <p>Contains the parameters for CreateLoadBalancer.</p>
public struct CreateLoadBalancerInput: Equatable {
    /// <p>One or more Availability Zones from the same region as the load balancer.</p>
    ///         <p>You must specify at least one Availability Zone.</p>
    ///         <p>You can add more Availability Zones after you create the load balancer using
    ///             <a>EnableAvailabilityZonesForLoadBalancer</a>.</p>
    public let availabilityZones: [String]?
    /// <p>The listeners.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html">Listeners for Your Classic Load Balancer</a>
    ///             in the <i>Classic Load Balancers Guide</i>.</p>
    public let listeners: [Listener]?
    /// <p>The name of the load balancer.</p>
    ///         <p>This name must be unique within your set of load balancers for the region, must have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and cannot begin or end with a hyphen.</p>
    public let loadBalancerName: String?
    /// <p>The type of a load balancer. Valid only for load balancers in a VPC.</p>
    ///         <p>By default, Elastic Load Balancing creates an Internet-facing load balancer with a DNS name that resolves to public IP addresses.
    ///             For more information about Internet-facing and Internal load balancers, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/userguide/how-elastic-load-balancing-works.html#load-balancer-scheme">Load Balancer Scheme</a>
    ///             in the <i>Elastic Load Balancing User Guide</i>.</p>
    ///         <p>Specify <code>internal</code> to create a load balancer with a DNS name that resolves to private IP addresses.</p>
    public let scheme: String?
    /// <p>The IDs of the security groups to assign to the load balancer.</p>
    public let securityGroups: [String]?
    /// <p>The IDs of the subnets in your VPC to attach to the load balancer.
    ///             Specify one subnet per Availability Zone specified in <code>AvailabilityZones</code>.</p>
    public let subnets: [String]?
    /// <p>A list of tags to assign to the load balancer.</p>
    ///         <p>For more information about tagging your load balancer, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/add-remove-tags.html">Tag Your Classic Load Balancer</a>
    ///             in the <i>Classic Load Balancers Guide</i>.</p>
    public let tags: [Tag]?

    public init (
        availabilityZones: [String]? = nil,
        listeners: [Listener]? = nil,
        loadBalancerName: String? = nil,
        scheme: String? = nil,
        securityGroups: [String]? = nil,
        subnets: [String]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.listeners = listeners
        self.loadBalancerName = loadBalancerName
        self.scheme = scheme
        self.securityGroups = securityGroups
        self.subnets = subnets
        self.tags = tags
    }
}

public struct CreateLoadBalancerListenersInputBodyMiddleware: Middleware {
    public let id: String = "CreateLoadBalancerListenersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLoadBalancerListenersInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLoadBalancerListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLoadBalancerListenersInput>
    public typealias MOutput = OperationOutput<CreateLoadBalancerListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLoadBalancerListenersOutputError>
}

extension CreateLoadBalancerListenersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLoadBalancerListenersInput(listeners: \(String(describing: listeners)), loadBalancerName: \(String(describing: loadBalancerName)))"}
}

extension CreateLoadBalancerListenersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let listeners = listeners {
            var listenersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Listeners"))
            for (index0, listener0) in listeners.enumerated() {
                try listenersContainer.encode(listener0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        try container.encode("CreateLoadBalancerListeners", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct CreateLoadBalancerListenersInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLoadBalancerListenersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLoadBalancerListenersInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLoadBalancerListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLoadBalancerListenersInput>
    public typealias MOutput = OperationOutput<CreateLoadBalancerListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLoadBalancerListenersOutputError>
}

public struct CreateLoadBalancerListenersInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLoadBalancerListenersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLoadBalancerListenersInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLoadBalancerListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLoadBalancerListenersInput>
    public typealias MOutput = OperationOutput<CreateLoadBalancerListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLoadBalancerListenersOutputError>
}

/// <p>Contains the parameters for CreateLoadBalancerListeners.</p>
public struct CreateLoadBalancerListenersInput: Equatable {
    /// <p>The listeners.</p>
    public let listeners: [Listener]?
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?

    public init (
        listeners: [Listener]? = nil,
        loadBalancerName: String? = nil
    )
    {
        self.listeners = listeners
        self.loadBalancerName = loadBalancerName
    }
}

extension CreateLoadBalancerListenersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateLoadBalancerListenersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CertificateNotFoundException" : self = .certificateNotFoundException(try CertificateNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateListenerException" : self = .duplicateListenerException(try DuplicateListenerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedProtocolException" : self = .unsupportedProtocolException(try UnsupportedProtocolException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLoadBalancerListenersOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case certificateNotFoundException(CertificateNotFoundException)
    case duplicateListenerException(DuplicateListenerException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case unsupportedProtocolException(UnsupportedProtocolException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLoadBalancerListenersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLoadBalancerListenersOutputResponse()"}
}

extension CreateLoadBalancerListenersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Contains the parameters for CreateLoadBalancerListener.</p>
public struct CreateLoadBalancerListenersOutputResponse: Equatable {

    public init() {}
}

struct CreateLoadBalancerListenersOutputResponseBody: Equatable {
}

extension CreateLoadBalancerListenersOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CreateLoadBalancerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateLoadBalancerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CertificateNotFoundException" : self = .certificateNotFoundException(try CertificateNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateAccessPointNameException" : self = .duplicateAccessPointNameException(try DuplicateAccessPointNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSchemeException" : self = .invalidSchemeException(try InvalidSchemeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurityGroupException" : self = .invalidSecurityGroupException(try InvalidSecurityGroupException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnetException" : self = .invalidSubnetException(try InvalidSubnetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetNotFoundException" : self = .subnetNotFoundException(try SubnetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyAccessPointsException" : self = .tooManyAccessPointsException(try TooManyAccessPointsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedProtocolException" : self = .unsupportedProtocolException(try UnsupportedProtocolException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLoadBalancerOutputError: Equatable {
    case certificateNotFoundException(CertificateNotFoundException)
    case duplicateAccessPointNameException(DuplicateAccessPointNameException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case invalidSchemeException(InvalidSchemeException)
    case invalidSecurityGroupException(InvalidSecurityGroupException)
    case invalidSubnetException(InvalidSubnetException)
    case operationNotPermittedException(OperationNotPermittedException)
    case subnetNotFoundException(SubnetNotFoundException)
    case tooManyAccessPointsException(TooManyAccessPointsException)
    case tooManyTagsException(TooManyTagsException)
    case unsupportedProtocolException(UnsupportedProtocolException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLoadBalancerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLoadBalancerOutputResponse(dNSName: \(String(describing: dNSName)))"}
}

extension CreateLoadBalancerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateLoadBalancerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dNSName = output.dNSName
        } else {
            self.dNSName = nil
        }
    }
}

/// <p>Contains the output for CreateLoadBalancer.</p>
public struct CreateLoadBalancerOutputResponse: Equatable {
    /// <p>The DNS name of the load balancer.</p>
    public let dNSName: String?

    public init (
        dNSName: String? = nil
    )
    {
        self.dNSName = dNSName
    }
}

struct CreateLoadBalancerOutputResponseBody: Equatable {
    public let dNSName: String?
}

extension CreateLoadBalancerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dNSName = "DNSName"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateLoadBalancerResult"))
        let dNSNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dNSName)
        dNSName = dNSNameDecoded
    }
}

public struct CreateLoadBalancerPolicyInputBodyMiddleware: Middleware {
    public let id: String = "CreateLoadBalancerPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLoadBalancerPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLoadBalancerPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLoadBalancerPolicyInput>
    public typealias MOutput = OperationOutput<CreateLoadBalancerPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLoadBalancerPolicyOutputError>
}

extension CreateLoadBalancerPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLoadBalancerPolicyInput(loadBalancerName: \(String(describing: loadBalancerName)), policyAttributes: \(String(describing: policyAttributes)), policyName: \(String(describing: policyName)), policyTypeName: \(String(describing: policyTypeName)))"}
}

extension CreateLoadBalancerPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        if let policyAttributes = policyAttributes {
            var policyAttributesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PolicyAttributes"))
            for (index0, policyattribute0) in policyAttributes.enumerated() {
                try policyAttributesContainer.encode(policyattribute0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
        if let policyTypeName = policyTypeName {
            try container.encode(policyTypeName, forKey: Key("PolicyTypeName"))
        }
        try container.encode("CreateLoadBalancerPolicy", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct CreateLoadBalancerPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLoadBalancerPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLoadBalancerPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLoadBalancerPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLoadBalancerPolicyInput>
    public typealias MOutput = OperationOutput<CreateLoadBalancerPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLoadBalancerPolicyOutputError>
}

public struct CreateLoadBalancerPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLoadBalancerPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLoadBalancerPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLoadBalancerPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLoadBalancerPolicyInput>
    public typealias MOutput = OperationOutput<CreateLoadBalancerPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLoadBalancerPolicyOutputError>
}

/// <p>Contains the parameters for CreateLoadBalancerPolicy.</p>
public struct CreateLoadBalancerPolicyInput: Equatable {
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?
    /// <p>The policy attributes.</p>
    public let policyAttributes: [PolicyAttribute]?
    /// <p>The name of the load balancer policy to be created. This name must be unique within the set of policies for this load balancer.</p>
    public let policyName: String?
    /// <p>The name of the base policy type.
    ///    	   To get the list of policy types, use <a>DescribeLoadBalancerPolicyTypes</a>.</p>
    public let policyTypeName: String?

    public init (
        loadBalancerName: String? = nil,
        policyAttributes: [PolicyAttribute]? = nil,
        policyName: String? = nil,
        policyTypeName: String? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.policyAttributes = policyAttributes
        self.policyName = policyName
        self.policyTypeName = policyTypeName
    }
}

extension CreateLoadBalancerPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateLoadBalancerPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicatePolicyNameException" : self = .duplicatePolicyNameException(try DuplicatePolicyNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyTypeNotFoundException" : self = .policyTypeNotFoundException(try PolicyTypeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyPoliciesException" : self = .tooManyPoliciesException(try TooManyPoliciesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLoadBalancerPolicyOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case duplicatePolicyNameException(DuplicatePolicyNameException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case policyTypeNotFoundException(PolicyTypeNotFoundException)
    case tooManyPoliciesException(TooManyPoliciesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLoadBalancerPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLoadBalancerPolicyOutputResponse()"}
}

extension CreateLoadBalancerPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Contains the output of CreateLoadBalancerPolicy.</p>
public struct CreateLoadBalancerPolicyOutputResponse: Equatable {

    public init() {}
}

struct CreateLoadBalancerPolicyOutputResponseBody: Equatable {
}

extension CreateLoadBalancerPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CrossZoneLoadBalancing: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if enabled != false {
            try container.encode(enabled, forKey: Key("Enabled"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension CrossZoneLoadBalancing: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CrossZoneLoadBalancing(enabled: \(String(describing: enabled)))"}
}

/// <p>Information about the <code>CrossZoneLoadBalancing</code> attribute.</p>
public struct CrossZoneLoadBalancing: Equatable {
    /// <p>Specifies whether cross-zone load balancing is enabled for the load balancer.</p>
    public let enabled: Bool

    public init (
        enabled: Bool = false
    )
    {
        self.enabled = enabled
    }
}

public struct DeleteLoadBalancerInputBodyMiddleware: Middleware {
    public let id: String = "DeleteLoadBalancerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLoadBalancerInput>
    public typealias MOutput = OperationOutput<DeleteLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLoadBalancerOutputError>
}

extension DeleteLoadBalancerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLoadBalancerInput(loadBalancerName: \(String(describing: loadBalancerName)))"}
}

extension DeleteLoadBalancerInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        try container.encode("DeleteLoadBalancer", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct DeleteLoadBalancerInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLoadBalancerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLoadBalancerInput>
    public typealias MOutput = OperationOutput<DeleteLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLoadBalancerOutputError>
}

public struct DeleteLoadBalancerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLoadBalancerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLoadBalancerInput>
    public typealias MOutput = OperationOutput<DeleteLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLoadBalancerOutputError>
}

/// <p>Contains the parameters for DeleteLoadBalancer.</p>
public struct DeleteLoadBalancerInput: Equatable {
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?

    public init (
        loadBalancerName: String? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
    }
}

public struct DeleteLoadBalancerListenersInputBodyMiddleware: Middleware {
    public let id: String = "DeleteLoadBalancerListenersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLoadBalancerListenersInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLoadBalancerListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLoadBalancerListenersInput>
    public typealias MOutput = OperationOutput<DeleteLoadBalancerListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLoadBalancerListenersOutputError>
}

extension DeleteLoadBalancerListenersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLoadBalancerListenersInput(loadBalancerName: \(String(describing: loadBalancerName)), loadBalancerPorts: \(String(describing: loadBalancerPorts)))"}
}

extension DeleteLoadBalancerListenersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        if let loadBalancerPorts = loadBalancerPorts {
            var loadBalancerPortsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("LoadBalancerPorts"))
            for (index0, accesspointport0) in loadBalancerPorts.enumerated() {
                try loadBalancerPortsContainer.encode(accesspointport0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DeleteLoadBalancerListeners", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct DeleteLoadBalancerListenersInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLoadBalancerListenersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLoadBalancerListenersInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLoadBalancerListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLoadBalancerListenersInput>
    public typealias MOutput = OperationOutput<DeleteLoadBalancerListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLoadBalancerListenersOutputError>
}

public struct DeleteLoadBalancerListenersInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLoadBalancerListenersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLoadBalancerListenersInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLoadBalancerListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLoadBalancerListenersInput>
    public typealias MOutput = OperationOutput<DeleteLoadBalancerListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLoadBalancerListenersOutputError>
}

/// <p>Contains the parameters for DeleteLoadBalancerListeners.</p>
public struct DeleteLoadBalancerListenersInput: Equatable {
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?
    /// <p>The client port numbers of the listeners.</p>
    public let loadBalancerPorts: [Int]?

    public init (
        loadBalancerName: String? = nil,
        loadBalancerPorts: [Int]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.loadBalancerPorts = loadBalancerPorts
    }
}

extension DeleteLoadBalancerListenersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteLoadBalancerListenersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLoadBalancerListenersOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLoadBalancerListenersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLoadBalancerListenersOutputResponse()"}
}

extension DeleteLoadBalancerListenersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Contains the output of DeleteLoadBalancerListeners.</p>
public struct DeleteLoadBalancerListenersOutputResponse: Equatable {

    public init() {}
}

struct DeleteLoadBalancerListenersOutputResponseBody: Equatable {
}

extension DeleteLoadBalancerListenersOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteLoadBalancerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteLoadBalancerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLoadBalancerOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLoadBalancerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLoadBalancerOutputResponse()"}
}

extension DeleteLoadBalancerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Contains the output of DeleteLoadBalancer.</p>
public struct DeleteLoadBalancerOutputResponse: Equatable {

    public init() {}
}

struct DeleteLoadBalancerOutputResponseBody: Equatable {
}

extension DeleteLoadBalancerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteLoadBalancerPolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteLoadBalancerPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLoadBalancerPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLoadBalancerPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLoadBalancerPolicyInput>
    public typealias MOutput = OperationOutput<DeleteLoadBalancerPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLoadBalancerPolicyOutputError>
}

extension DeleteLoadBalancerPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLoadBalancerPolicyInput(loadBalancerName: \(String(describing: loadBalancerName)), policyName: \(String(describing: policyName)))"}
}

extension DeleteLoadBalancerPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
        try container.encode("DeleteLoadBalancerPolicy", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct DeleteLoadBalancerPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLoadBalancerPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLoadBalancerPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLoadBalancerPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLoadBalancerPolicyInput>
    public typealias MOutput = OperationOutput<DeleteLoadBalancerPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLoadBalancerPolicyOutputError>
}

public struct DeleteLoadBalancerPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLoadBalancerPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLoadBalancerPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLoadBalancerPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLoadBalancerPolicyInput>
    public typealias MOutput = OperationOutput<DeleteLoadBalancerPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLoadBalancerPolicyOutputError>
}

/// <p>Contains the parameters for DeleteLoadBalancerPolicy.</p>
public struct DeleteLoadBalancerPolicyInput: Equatable {
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?
    /// <p>The name of the policy.</p>
    public let policyName: String?

    public init (
        loadBalancerName: String? = nil,
        policyName: String? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.policyName = policyName
    }
}

extension DeleteLoadBalancerPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteLoadBalancerPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLoadBalancerPolicyOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLoadBalancerPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLoadBalancerPolicyOutputResponse()"}
}

extension DeleteLoadBalancerPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Contains the output of DeleteLoadBalancerPolicy.</p>
public struct DeleteLoadBalancerPolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteLoadBalancerPolicyOutputResponseBody: Equatable {
}

extension DeleteLoadBalancerPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DependencyThrottleException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DependencyThrottleException(message: \(String(describing: message)))"}
}

extension DependencyThrottleException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DependencyThrottleExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A request made by Elastic Load Balancing to another service exceeds the maximum request rate permitted for your account.</p>
public struct DependencyThrottleException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DependencyThrottleExceptionBody: Equatable {
    public let message: String?
}

extension DependencyThrottleExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DeregisterInstancesFromLoadBalancerInputBodyMiddleware: Middleware {
    public let id: String = "DeregisterInstancesFromLoadBalancerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterInstancesFromLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterInstancesFromLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterInstancesFromLoadBalancerInput>
    public typealias MOutput = OperationOutput<DeregisterInstancesFromLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterInstancesFromLoadBalancerOutputError>
}

extension DeregisterInstancesFromLoadBalancerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterInstancesFromLoadBalancerInput(instances: \(String(describing: instances)), loadBalancerName: \(String(describing: loadBalancerName)))"}
}

extension DeregisterInstancesFromLoadBalancerInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let instances = instances {
            var instancesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Instances"))
            for (index0, instance0) in instances.enumerated() {
                try instancesContainer.encode(instance0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        try container.encode("DeregisterInstancesFromLoadBalancer", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct DeregisterInstancesFromLoadBalancerInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterInstancesFromLoadBalancerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterInstancesFromLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterInstancesFromLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterInstancesFromLoadBalancerInput>
    public typealias MOutput = OperationOutput<DeregisterInstancesFromLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterInstancesFromLoadBalancerOutputError>
}

public struct DeregisterInstancesFromLoadBalancerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterInstancesFromLoadBalancerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterInstancesFromLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterInstancesFromLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterInstancesFromLoadBalancerInput>
    public typealias MOutput = OperationOutput<DeregisterInstancesFromLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterInstancesFromLoadBalancerOutputError>
}

/// <p>Contains the parameters for DeregisterInstancesFromLoadBalancer.</p>
public struct DeregisterInstancesFromLoadBalancerInput: Equatable {
    /// <p>The IDs of the instances.</p>
    public let instances: [Instance]?
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?

    public init (
        instances: [Instance]? = nil,
        loadBalancerName: String? = nil
    )
    {
        self.instances = instances
        self.loadBalancerName = loadBalancerName
    }
}

extension DeregisterInstancesFromLoadBalancerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeregisterInstancesFromLoadBalancerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndPointException" : self = .invalidEndPointException(try InvalidEndPointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterInstancesFromLoadBalancerOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case invalidEndPointException(InvalidEndPointException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterInstancesFromLoadBalancerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterInstancesFromLoadBalancerOutputResponse(instances: \(String(describing: instances)))"}
}

extension DeregisterInstancesFromLoadBalancerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeregisterInstancesFromLoadBalancerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instances = output.instances
        } else {
            self.instances = nil
        }
    }
}

/// <p>Contains the output of DeregisterInstancesFromLoadBalancer.</p>
public struct DeregisterInstancesFromLoadBalancerOutputResponse: Equatable {
    /// <p>The remaining instances registered with the load balancer.</p>
    public let instances: [Instance]?

    public init (
        instances: [Instance]? = nil
    )
    {
        self.instances = instances
    }
}

struct DeregisterInstancesFromLoadBalancerOutputResponseBody: Equatable {
    public let instances: [Instance]?
}

extension DeregisterInstancesFromLoadBalancerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instances = "Instances"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeregisterInstancesFromLoadBalancerResult"))
        if containerValues.contains(.instances) {
            struct KeyVal0{struct member{}}
            let instancesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instances)
            if let instancesWrappedContainer = instancesWrappedContainer {
                let instancesContainer = try instancesWrappedContainer.decodeIfPresent([Instance].self, forKey: .member)
                var instancesBuffer:[Instance]? = nil
                if let instancesContainer = instancesContainer {
                    instancesBuffer = [Instance]()
                    for structureContainer0 in instancesContainer {
                        instancesBuffer?.append(structureContainer0)
                    }
                }
                instances = instancesBuffer
            } else {
                instances = []
            }
        } else {
            instances = nil
        }
    }
}

public struct DescribeAccountLimitsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAccountLimitsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountLimitsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountLimitsInput>
    public typealias MOutput = OperationOutput<DescribeAccountLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountLimitsOutputError>
}

extension DescribeAccountLimitsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountLimitsInput(marker: \(String(describing: marker)), pageSize: \(String(describing: pageSize)))"}
}

extension DescribeAccountLimitsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let pageSize = pageSize {
            try container.encode(pageSize, forKey: Key("PageSize"))
        }
        try container.encode("DescribeAccountLimits", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct DescribeAccountLimitsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAccountLimitsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountLimitsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountLimitsInput>
    public typealias MOutput = OperationOutput<DescribeAccountLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountLimitsOutputError>
}

public struct DescribeAccountLimitsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAccountLimitsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountLimitsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountLimitsInput>
    public typealias MOutput = OperationOutput<DescribeAccountLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountLimitsOutputError>
}

public struct DescribeAccountLimitsInput: Equatable {
    /// <p>The marker for the next set of results. (You received this marker from a previous call.)</p>
    public let marker: String?
    /// <p>The maximum number of results to return with this call.</p>
    public let pageSize: Int?

    public init (
        marker: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.marker = marker
        self.pageSize = pageSize
    }
}

extension DescribeAccountLimitsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeAccountLimitsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountLimitsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountLimitsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountLimitsOutputResponse(limits: \(String(describing: limits)), nextMarker: \(String(describing: nextMarker)))"}
}

extension DescribeAccountLimitsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAccountLimitsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.limits = output.limits
            self.nextMarker = output.nextMarker
        } else {
            self.limits = nil
            self.nextMarker = nil
        }
    }
}

public struct DescribeAccountLimitsOutputResponse: Equatable {
    /// <p>Information about the limits.</p>
    public let limits: [Limit]?
    /// <p>The marker to use when requesting the next set of results. If there are no additional results, the string is empty.</p>
    public let nextMarker: String?

    public init (
        limits: [Limit]? = nil,
        nextMarker: String? = nil
    )
    {
        self.limits = limits
        self.nextMarker = nextMarker
    }
}

struct DescribeAccountLimitsOutputResponseBody: Equatable {
    public let limits: [Limit]?
    public let nextMarker: String?
}

extension DescribeAccountLimitsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limits = "Limits"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeAccountLimitsResult"))
        if containerValues.contains(.limits) {
            struct KeyVal0{struct member{}}
            let limitsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .limits)
            if let limitsWrappedContainer = limitsWrappedContainer {
                let limitsContainer = try limitsWrappedContainer.decodeIfPresent([Limit].self, forKey: .member)
                var limitsBuffer:[Limit]? = nil
                if let limitsContainer = limitsContainer {
                    limitsBuffer = [Limit]()
                    for structureContainer0 in limitsContainer {
                        limitsBuffer?.append(structureContainer0)
                    }
                }
                limits = limitsBuffer
            } else {
                limits = []
            }
        } else {
            limits = nil
        }
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

public struct DescribeInstanceHealthInputBodyMiddleware: Middleware {
    public let id: String = "DescribeInstanceHealthInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstanceHealthInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstanceHealthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstanceHealthInput>
    public typealias MOutput = OperationOutput<DescribeInstanceHealthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstanceHealthOutputError>
}

extension DescribeInstanceHealthInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstanceHealthInput(instances: \(String(describing: instances)), loadBalancerName: \(String(describing: loadBalancerName)))"}
}

extension DescribeInstanceHealthInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let instances = instances {
            var instancesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Instances"))
            for (index0, instance0) in instances.enumerated() {
                try instancesContainer.encode(instance0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        try container.encode("DescribeInstanceHealth", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct DescribeInstanceHealthInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeInstanceHealthInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstanceHealthInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstanceHealthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstanceHealthInput>
    public typealias MOutput = OperationOutput<DescribeInstanceHealthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstanceHealthOutputError>
}

public struct DescribeInstanceHealthInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeInstanceHealthInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstanceHealthInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstanceHealthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstanceHealthInput>
    public typealias MOutput = OperationOutput<DescribeInstanceHealthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstanceHealthOutputError>
}

/// <p>Contains the parameters for DescribeInstanceHealth.</p>
public struct DescribeInstanceHealthInput: Equatable {
    /// <p>The IDs of the instances.</p>
    public let instances: [Instance]?
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?

    public init (
        instances: [Instance]? = nil,
        loadBalancerName: String? = nil
    )
    {
        self.instances = instances
        self.loadBalancerName = loadBalancerName
    }
}

extension DescribeInstanceHealthOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeInstanceHealthOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndPointException" : self = .invalidEndPointException(try InvalidEndPointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstanceHealthOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case invalidEndPointException(InvalidEndPointException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstanceHealthOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstanceHealthOutputResponse(instanceStates: \(String(describing: instanceStates)))"}
}

extension DescribeInstanceHealthOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeInstanceHealthOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instanceStates = output.instanceStates
        } else {
            self.instanceStates = nil
        }
    }
}

/// <p>Contains the output for DescribeInstanceHealth.</p>
public struct DescribeInstanceHealthOutputResponse: Equatable {
    /// <p>Information about the health of the instances.</p>
    public let instanceStates: [InstanceState]?

    public init (
        instanceStates: [InstanceState]? = nil
    )
    {
        self.instanceStates = instanceStates
    }
}

struct DescribeInstanceHealthOutputResponseBody: Equatable {
    public let instanceStates: [InstanceState]?
}

extension DescribeInstanceHealthOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceStates = "InstanceStates"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeInstanceHealthResult"))
        if containerValues.contains(.instanceStates) {
            struct KeyVal0{struct member{}}
            let instanceStatesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instanceStates)
            if let instanceStatesWrappedContainer = instanceStatesWrappedContainer {
                let instanceStatesContainer = try instanceStatesWrappedContainer.decodeIfPresent([InstanceState].self, forKey: .member)
                var instanceStatesBuffer:[InstanceState]? = nil
                if let instanceStatesContainer = instanceStatesContainer {
                    instanceStatesBuffer = [InstanceState]()
                    for structureContainer0 in instanceStatesContainer {
                        instanceStatesBuffer?.append(structureContainer0)
                    }
                }
                instanceStates = instanceStatesBuffer
            } else {
                instanceStates = []
            }
        } else {
            instanceStates = nil
        }
    }
}

public struct DescribeLoadBalancerAttributesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeLoadBalancerAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoadBalancerAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoadBalancerAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoadBalancerAttributesInput>
    public typealias MOutput = OperationOutput<DescribeLoadBalancerAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoadBalancerAttributesOutputError>
}

extension DescribeLoadBalancerAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoadBalancerAttributesInput(loadBalancerName: \(String(describing: loadBalancerName)))"}
}

extension DescribeLoadBalancerAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        try container.encode("DescribeLoadBalancerAttributes", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct DescribeLoadBalancerAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLoadBalancerAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoadBalancerAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoadBalancerAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoadBalancerAttributesInput>
    public typealias MOutput = OperationOutput<DescribeLoadBalancerAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoadBalancerAttributesOutputError>
}

public struct DescribeLoadBalancerAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLoadBalancerAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoadBalancerAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoadBalancerAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoadBalancerAttributesInput>
    public typealias MOutput = OperationOutput<DescribeLoadBalancerAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoadBalancerAttributesOutputError>
}

/// <p>Contains the parameters for DescribeLoadBalancerAttributes.</p>
public struct DescribeLoadBalancerAttributesInput: Equatable {
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?

    public init (
        loadBalancerName: String? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
    }
}

extension DescribeLoadBalancerAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeLoadBalancerAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoadBalancerAttributeNotFoundException" : self = .loadBalancerAttributeNotFoundException(try LoadBalancerAttributeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLoadBalancerAttributesOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case loadBalancerAttributeNotFoundException(LoadBalancerAttributeNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoadBalancerAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoadBalancerAttributesOutputResponse(loadBalancerAttributes: \(String(describing: loadBalancerAttributes)))"}
}

extension DescribeLoadBalancerAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeLoadBalancerAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.loadBalancerAttributes = output.loadBalancerAttributes
        } else {
            self.loadBalancerAttributes = nil
        }
    }
}

/// <p>Contains the output of DescribeLoadBalancerAttributes.</p>
public struct DescribeLoadBalancerAttributesOutputResponse: Equatable {
    /// <p>Information about the load balancer attributes.</p>
    public let loadBalancerAttributes: LoadBalancerAttributes?

    public init (
        loadBalancerAttributes: LoadBalancerAttributes? = nil
    )
    {
        self.loadBalancerAttributes = loadBalancerAttributes
    }
}

struct DescribeLoadBalancerAttributesOutputResponseBody: Equatable {
    public let loadBalancerAttributes: LoadBalancerAttributes?
}

extension DescribeLoadBalancerAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loadBalancerAttributes = "LoadBalancerAttributes"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeLoadBalancerAttributesResult"))
        let loadBalancerAttributesDecoded = try containerValues.decodeIfPresent(LoadBalancerAttributes.self, forKey: .loadBalancerAttributes)
        loadBalancerAttributes = loadBalancerAttributesDecoded
    }
}

public struct DescribeLoadBalancerPoliciesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeLoadBalancerPoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoadBalancerPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoadBalancerPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoadBalancerPoliciesInput>
    public typealias MOutput = OperationOutput<DescribeLoadBalancerPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoadBalancerPoliciesOutputError>
}

extension DescribeLoadBalancerPoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoadBalancerPoliciesInput(loadBalancerName: \(String(describing: loadBalancerName)), policyNames: \(String(describing: policyNames)))"}
}

extension DescribeLoadBalancerPoliciesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        if let policyNames = policyNames {
            var policyNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PolicyNames"))
            for (index0, policyname0) in policyNames.enumerated() {
                try policyNamesContainer.encode(policyname0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeLoadBalancerPolicies", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct DescribeLoadBalancerPoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLoadBalancerPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoadBalancerPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoadBalancerPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoadBalancerPoliciesInput>
    public typealias MOutput = OperationOutput<DescribeLoadBalancerPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoadBalancerPoliciesOutputError>
}

public struct DescribeLoadBalancerPoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLoadBalancerPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoadBalancerPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoadBalancerPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoadBalancerPoliciesInput>
    public typealias MOutput = OperationOutput<DescribeLoadBalancerPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoadBalancerPoliciesOutputError>
}

/// <p>Contains the parameters for DescribeLoadBalancerPolicies.</p>
public struct DescribeLoadBalancerPoliciesInput: Equatable {
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?
    /// <p>The names of the policies.</p>
    public let policyNames: [String]?

    public init (
        loadBalancerName: String? = nil,
        policyNames: [String]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.policyNames = policyNames
    }
}

extension DescribeLoadBalancerPoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeLoadBalancerPoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotFoundException" : self = .policyNotFoundException(try PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLoadBalancerPoliciesOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case policyNotFoundException(PolicyNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoadBalancerPoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoadBalancerPoliciesOutputResponse(policyDescriptions: \(String(describing: policyDescriptions)))"}
}

extension DescribeLoadBalancerPoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeLoadBalancerPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyDescriptions = output.policyDescriptions
        } else {
            self.policyDescriptions = nil
        }
    }
}

/// <p>Contains the output of DescribeLoadBalancerPolicies.</p>
public struct DescribeLoadBalancerPoliciesOutputResponse: Equatable {
    /// <p>Information about the policies.</p>
    public let policyDescriptions: [PolicyDescription]?

    public init (
        policyDescriptions: [PolicyDescription]? = nil
    )
    {
        self.policyDescriptions = policyDescriptions
    }
}

struct DescribeLoadBalancerPoliciesOutputResponseBody: Equatable {
    public let policyDescriptions: [PolicyDescription]?
}

extension DescribeLoadBalancerPoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyDescriptions = "PolicyDescriptions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeLoadBalancerPoliciesResult"))
        if containerValues.contains(.policyDescriptions) {
            struct KeyVal0{struct member{}}
            let policyDescriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyDescriptions)
            if let policyDescriptionsWrappedContainer = policyDescriptionsWrappedContainer {
                let policyDescriptionsContainer = try policyDescriptionsWrappedContainer.decodeIfPresent([PolicyDescription].self, forKey: .member)
                var policyDescriptionsBuffer:[PolicyDescription]? = nil
                if let policyDescriptionsContainer = policyDescriptionsContainer {
                    policyDescriptionsBuffer = [PolicyDescription]()
                    for structureContainer0 in policyDescriptionsContainer {
                        policyDescriptionsBuffer?.append(structureContainer0)
                    }
                }
                policyDescriptions = policyDescriptionsBuffer
            } else {
                policyDescriptions = []
            }
        } else {
            policyDescriptions = nil
        }
    }
}

public struct DescribeLoadBalancerPolicyTypesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeLoadBalancerPolicyTypesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoadBalancerPolicyTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoadBalancerPolicyTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoadBalancerPolicyTypesInput>
    public typealias MOutput = OperationOutput<DescribeLoadBalancerPolicyTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoadBalancerPolicyTypesOutputError>
}

extension DescribeLoadBalancerPolicyTypesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoadBalancerPolicyTypesInput(policyTypeNames: \(String(describing: policyTypeNames)))"}
}

extension DescribeLoadBalancerPolicyTypesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyTypeNames = policyTypeNames {
            var policyTypeNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PolicyTypeNames"))
            for (index0, policytypename0) in policyTypeNames.enumerated() {
                try policyTypeNamesContainer.encode(policytypename0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeLoadBalancerPolicyTypes", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct DescribeLoadBalancerPolicyTypesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLoadBalancerPolicyTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoadBalancerPolicyTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoadBalancerPolicyTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoadBalancerPolicyTypesInput>
    public typealias MOutput = OperationOutput<DescribeLoadBalancerPolicyTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoadBalancerPolicyTypesOutputError>
}

public struct DescribeLoadBalancerPolicyTypesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLoadBalancerPolicyTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoadBalancerPolicyTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoadBalancerPolicyTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoadBalancerPolicyTypesInput>
    public typealias MOutput = OperationOutput<DescribeLoadBalancerPolicyTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoadBalancerPolicyTypesOutputError>
}

/// <p>Contains the parameters for DescribeLoadBalancerPolicyTypes.</p>
public struct DescribeLoadBalancerPolicyTypesInput: Equatable {
    /// <p>The names of the policy types. If no names are specified, describes all policy types defined by Elastic Load Balancing.</p>
    public let policyTypeNames: [String]?

    public init (
        policyTypeNames: [String]? = nil
    )
    {
        self.policyTypeNames = policyTypeNames
    }
}

extension DescribeLoadBalancerPolicyTypesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeLoadBalancerPolicyTypesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "PolicyTypeNotFoundException" : self = .policyTypeNotFoundException(try PolicyTypeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLoadBalancerPolicyTypesOutputError: Equatable {
    case policyTypeNotFoundException(PolicyTypeNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoadBalancerPolicyTypesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoadBalancerPolicyTypesOutputResponse(policyTypeDescriptions: \(String(describing: policyTypeDescriptions)))"}
}

extension DescribeLoadBalancerPolicyTypesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeLoadBalancerPolicyTypesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyTypeDescriptions = output.policyTypeDescriptions
        } else {
            self.policyTypeDescriptions = nil
        }
    }
}

/// <p>Contains the output of DescribeLoadBalancerPolicyTypes.</p>
public struct DescribeLoadBalancerPolicyTypesOutputResponse: Equatable {
    /// <p>Information about the policy types.</p>
    public let policyTypeDescriptions: [PolicyTypeDescription]?

    public init (
        policyTypeDescriptions: [PolicyTypeDescription]? = nil
    )
    {
        self.policyTypeDescriptions = policyTypeDescriptions
    }
}

struct DescribeLoadBalancerPolicyTypesOutputResponseBody: Equatable {
    public let policyTypeDescriptions: [PolicyTypeDescription]?
}

extension DescribeLoadBalancerPolicyTypesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyTypeDescriptions = "PolicyTypeDescriptions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeLoadBalancerPolicyTypesResult"))
        if containerValues.contains(.policyTypeDescriptions) {
            struct KeyVal0{struct member{}}
            let policyTypeDescriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyTypeDescriptions)
            if let policyTypeDescriptionsWrappedContainer = policyTypeDescriptionsWrappedContainer {
                let policyTypeDescriptionsContainer = try policyTypeDescriptionsWrappedContainer.decodeIfPresent([PolicyTypeDescription].self, forKey: .member)
                var policyTypeDescriptionsBuffer:[PolicyTypeDescription]? = nil
                if let policyTypeDescriptionsContainer = policyTypeDescriptionsContainer {
                    policyTypeDescriptionsBuffer = [PolicyTypeDescription]()
                    for structureContainer0 in policyTypeDescriptionsContainer {
                        policyTypeDescriptionsBuffer?.append(structureContainer0)
                    }
                }
                policyTypeDescriptions = policyTypeDescriptionsBuffer
            } else {
                policyTypeDescriptions = []
            }
        } else {
            policyTypeDescriptions = nil
        }
    }
}

public struct DescribeLoadBalancersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeLoadBalancersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoadBalancersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoadBalancersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoadBalancersInput>
    public typealias MOutput = OperationOutput<DescribeLoadBalancersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoadBalancersOutputError>
}

extension DescribeLoadBalancersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoadBalancersInput(loadBalancerNames: \(String(describing: loadBalancerNames)), marker: \(String(describing: marker)), pageSize: \(String(describing: pageSize)))"}
}

extension DescribeLoadBalancersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancerNames = loadBalancerNames {
            var loadBalancerNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("LoadBalancerNames"))
            for (index0, accesspointname0) in loadBalancerNames.enumerated() {
                try loadBalancerNamesContainer.encode(accesspointname0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let pageSize = pageSize {
            try container.encode(pageSize, forKey: Key("PageSize"))
        }
        try container.encode("DescribeLoadBalancers", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct DescribeLoadBalancersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLoadBalancersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoadBalancersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoadBalancersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoadBalancersInput>
    public typealias MOutput = OperationOutput<DescribeLoadBalancersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoadBalancersOutputError>
}

public struct DescribeLoadBalancersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLoadBalancersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoadBalancersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoadBalancersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoadBalancersInput>
    public typealias MOutput = OperationOutput<DescribeLoadBalancersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoadBalancersOutputError>
}

/// <p>Contains the parameters for DescribeLoadBalancers.</p>
public struct DescribeLoadBalancersInput: Equatable {
    /// <p>The names of the load balancers.</p>
    public let loadBalancerNames: [String]?
    /// <p>The marker for the next set of results. (You received this marker from a previous call.)</p>
    public let marker: String?
    /// <p>The maximum number of results to return with this call (a number from 1 to 400). The default is 400.</p>
    public let pageSize: Int?

    public init (
        loadBalancerNames: [String]? = nil,
        marker: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.loadBalancerNames = loadBalancerNames
        self.marker = marker
        self.pageSize = pageSize
    }
}

extension DescribeLoadBalancersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeLoadBalancersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyThrottleException" : self = .dependencyThrottleException(try DependencyThrottleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLoadBalancersOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case dependencyThrottleException(DependencyThrottleException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoadBalancersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoadBalancersOutputResponse(loadBalancerDescriptions: \(String(describing: loadBalancerDescriptions)), nextMarker: \(String(describing: nextMarker)))"}
}

extension DescribeLoadBalancersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeLoadBalancersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.loadBalancerDescriptions = output.loadBalancerDescriptions
            self.nextMarker = output.nextMarker
        } else {
            self.loadBalancerDescriptions = nil
            self.nextMarker = nil
        }
    }
}

/// <p>Contains the parameters for DescribeLoadBalancers.</p>
public struct DescribeLoadBalancersOutputResponse: Equatable {
    /// <p>Information about the load balancers.</p>
    public let loadBalancerDescriptions: [LoadBalancerDescription]?
    /// <p>The marker to use when requesting the next set of results. If there are no additional results, the string is empty.</p>
    public let nextMarker: String?

    public init (
        loadBalancerDescriptions: [LoadBalancerDescription]? = nil,
        nextMarker: String? = nil
    )
    {
        self.loadBalancerDescriptions = loadBalancerDescriptions
        self.nextMarker = nextMarker
    }
}

struct DescribeLoadBalancersOutputResponseBody: Equatable {
    public let loadBalancerDescriptions: [LoadBalancerDescription]?
    public let nextMarker: String?
}

extension DescribeLoadBalancersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loadBalancerDescriptions = "LoadBalancerDescriptions"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeLoadBalancersResult"))
        if containerValues.contains(.loadBalancerDescriptions) {
            struct KeyVal0{struct member{}}
            let loadBalancerDescriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .loadBalancerDescriptions)
            if let loadBalancerDescriptionsWrappedContainer = loadBalancerDescriptionsWrappedContainer {
                let loadBalancerDescriptionsContainer = try loadBalancerDescriptionsWrappedContainer.decodeIfPresent([LoadBalancerDescription].self, forKey: .member)
                var loadBalancerDescriptionsBuffer:[LoadBalancerDescription]? = nil
                if let loadBalancerDescriptionsContainer = loadBalancerDescriptionsContainer {
                    loadBalancerDescriptionsBuffer = [LoadBalancerDescription]()
                    for structureContainer0 in loadBalancerDescriptionsContainer {
                        loadBalancerDescriptionsBuffer?.append(structureContainer0)
                    }
                }
                loadBalancerDescriptions = loadBalancerDescriptionsBuffer
            } else {
                loadBalancerDescriptions = []
            }
        } else {
            loadBalancerDescriptions = nil
        }
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

public struct DescribeTagsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTagsOutputError>
}

extension DescribeTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTagsInput(loadBalancerNames: \(String(describing: loadBalancerNames)))"}
}

extension DescribeTagsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancerNames = loadBalancerNames {
            var loadBalancerNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("LoadBalancerNames"))
            for (index0, accesspointname0) in loadBalancerNames.enumerated() {
                try loadBalancerNamesContainer.encode(accesspointname0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeTags", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct DescribeTagsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTagsOutputError>
}

public struct DescribeTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTagsOutputError>
}

/// <p>Contains the parameters for DescribeTags.</p>
public struct DescribeTagsInput: Equatable {
    /// <p>The names of the load balancers.</p>
    public let loadBalancerNames: [String]?

    public init (
        loadBalancerNames: [String]? = nil
    )
    {
        self.loadBalancerNames = loadBalancerNames
    }
}

extension DescribeTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTagsOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTagsOutputResponse(tagDescriptions: \(String(describing: tagDescriptions)))"}
}

extension DescribeTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tagDescriptions = output.tagDescriptions
        } else {
            self.tagDescriptions = nil
        }
    }
}

/// <p>Contains the output for DescribeTags.</p>
public struct DescribeTagsOutputResponse: Equatable {
    /// <p>Information about the tags.</p>
    public let tagDescriptions: [TagDescription]?

    public init (
        tagDescriptions: [TagDescription]? = nil
    )
    {
        self.tagDescriptions = tagDescriptions
    }
}

struct DescribeTagsOutputResponseBody: Equatable {
    public let tagDescriptions: [TagDescription]?
}

extension DescribeTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagDescriptions = "TagDescriptions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeTagsResult"))
        if containerValues.contains(.tagDescriptions) {
            struct KeyVal0{struct member{}}
            let tagDescriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagDescriptions)
            if let tagDescriptionsWrappedContainer = tagDescriptionsWrappedContainer {
                let tagDescriptionsContainer = try tagDescriptionsWrappedContainer.decodeIfPresent([TagDescription].self, forKey: .member)
                var tagDescriptionsBuffer:[TagDescription]? = nil
                if let tagDescriptionsContainer = tagDescriptionsContainer {
                    tagDescriptionsBuffer = [TagDescription]()
                    for structureContainer0 in tagDescriptionsContainer {
                        tagDescriptionsBuffer?.append(structureContainer0)
                    }
                }
                tagDescriptions = tagDescriptionsBuffer
            } else {
                tagDescriptions = []
            }
        } else {
            tagDescriptions = nil
        }
    }
}

public struct DetachLoadBalancerFromSubnetsInputBodyMiddleware: Middleware {
    public let id: String = "DetachLoadBalancerFromSubnetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachLoadBalancerFromSubnetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachLoadBalancerFromSubnetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachLoadBalancerFromSubnetsInput>
    public typealias MOutput = OperationOutput<DetachLoadBalancerFromSubnetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachLoadBalancerFromSubnetsOutputError>
}

extension DetachLoadBalancerFromSubnetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachLoadBalancerFromSubnetsInput(loadBalancerName: \(String(describing: loadBalancerName)), subnets: \(String(describing: subnets)))"}
}

extension DetachLoadBalancerFromSubnetsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        if let subnets = subnets {
            var subnetsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Subnets"))
            for (index0, subnetid0) in subnets.enumerated() {
                try subnetsContainer.encode(subnetid0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DetachLoadBalancerFromSubnets", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct DetachLoadBalancerFromSubnetsInputHeadersMiddleware: Middleware {
    public let id: String = "DetachLoadBalancerFromSubnetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachLoadBalancerFromSubnetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachLoadBalancerFromSubnetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachLoadBalancerFromSubnetsInput>
    public typealias MOutput = OperationOutput<DetachLoadBalancerFromSubnetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachLoadBalancerFromSubnetsOutputError>
}

public struct DetachLoadBalancerFromSubnetsInputQueryItemMiddleware: Middleware {
    public let id: String = "DetachLoadBalancerFromSubnetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachLoadBalancerFromSubnetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachLoadBalancerFromSubnetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachLoadBalancerFromSubnetsInput>
    public typealias MOutput = OperationOutput<DetachLoadBalancerFromSubnetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachLoadBalancerFromSubnetsOutputError>
}

/// <p>Contains the parameters for DetachLoadBalancerFromSubnets.</p>
public struct DetachLoadBalancerFromSubnetsInput: Equatable {
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?
    /// <p>The IDs of the subnets.</p>
    public let subnets: [String]?

    public init (
        loadBalancerName: String? = nil,
        subnets: [String]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.subnets = subnets
    }
}

extension DetachLoadBalancerFromSubnetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DetachLoadBalancerFromSubnetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetachLoadBalancerFromSubnetsOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachLoadBalancerFromSubnetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachLoadBalancerFromSubnetsOutputResponse(subnets: \(String(describing: subnets)))"}
}

extension DetachLoadBalancerFromSubnetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DetachLoadBalancerFromSubnetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.subnets = output.subnets
        } else {
            self.subnets = nil
        }
    }
}

/// <p>Contains the output of DetachLoadBalancerFromSubnets.</p>
public struct DetachLoadBalancerFromSubnetsOutputResponse: Equatable {
    /// <p>The IDs of the remaining subnets for the load balancer.</p>
    public let subnets: [String]?

    public init (
        subnets: [String]? = nil
    )
    {
        self.subnets = subnets
    }
}

struct DetachLoadBalancerFromSubnetsOutputResponseBody: Equatable {
    public let subnets: [String]?
}

extension DetachLoadBalancerFromSubnetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case subnets = "Subnets"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DetachLoadBalancerFromSubnetsResult"))
        if containerValues.contains(.subnets) {
            struct KeyVal0{struct member{}}
            let subnetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .subnets)
            if let subnetsWrappedContainer = subnetsWrappedContainer {
                let subnetsContainer = try subnetsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var subnetsBuffer:[String]? = nil
                if let subnetsContainer = subnetsContainer {
                    subnetsBuffer = [String]()
                    for stringContainer0 in subnetsContainer {
                        subnetsBuffer?.append(stringContainer0)
                    }
                }
                subnets = subnetsBuffer
            } else {
                subnets = []
            }
        } else {
            subnets = nil
        }
    }
}

public struct DisableAvailabilityZonesForLoadBalancerInputBodyMiddleware: Middleware {
    public let id: String = "DisableAvailabilityZonesForLoadBalancerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableAvailabilityZonesForLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableAvailabilityZonesForLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableAvailabilityZonesForLoadBalancerInput>
    public typealias MOutput = OperationOutput<DisableAvailabilityZonesForLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableAvailabilityZonesForLoadBalancerOutputError>
}

extension DisableAvailabilityZonesForLoadBalancerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableAvailabilityZonesForLoadBalancerInput(availabilityZones: \(String(describing: availabilityZones)), loadBalancerName: \(String(describing: loadBalancerName)))"}
}

extension DisableAvailabilityZonesForLoadBalancerInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZones"))
            for (index0, availabilityzone0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(availabilityzone0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        try container.encode("DisableAvailabilityZonesForLoadBalancer", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct DisableAvailabilityZonesForLoadBalancerInputHeadersMiddleware: Middleware {
    public let id: String = "DisableAvailabilityZonesForLoadBalancerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableAvailabilityZonesForLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableAvailabilityZonesForLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableAvailabilityZonesForLoadBalancerInput>
    public typealias MOutput = OperationOutput<DisableAvailabilityZonesForLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableAvailabilityZonesForLoadBalancerOutputError>
}

public struct DisableAvailabilityZonesForLoadBalancerInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableAvailabilityZonesForLoadBalancerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableAvailabilityZonesForLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableAvailabilityZonesForLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableAvailabilityZonesForLoadBalancerInput>
    public typealias MOutput = OperationOutput<DisableAvailabilityZonesForLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableAvailabilityZonesForLoadBalancerOutputError>
}

/// <p>Contains the parameters for DisableAvailabilityZonesForLoadBalancer.</p>
public struct DisableAvailabilityZonesForLoadBalancerInput: Equatable {
    /// <p>The Availability Zones.</p>
    public let availabilityZones: [String]?
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?

    public init (
        availabilityZones: [String]? = nil,
        loadBalancerName: String? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.loadBalancerName = loadBalancerName
    }
}

extension DisableAvailabilityZonesForLoadBalancerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DisableAvailabilityZonesForLoadBalancerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableAvailabilityZonesForLoadBalancerOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableAvailabilityZonesForLoadBalancerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableAvailabilityZonesForLoadBalancerOutputResponse(availabilityZones: \(String(describing: availabilityZones)))"}
}

extension DisableAvailabilityZonesForLoadBalancerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisableAvailabilityZonesForLoadBalancerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.availabilityZones = output.availabilityZones
        } else {
            self.availabilityZones = nil
        }
    }
}

/// <p>Contains the output for DisableAvailabilityZonesForLoadBalancer.</p>
public struct DisableAvailabilityZonesForLoadBalancerOutputResponse: Equatable {
    /// <p>The remaining Availability Zones for the load balancer.</p>
    public let availabilityZones: [String]?

    public init (
        availabilityZones: [String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
    }
}

struct DisableAvailabilityZonesForLoadBalancerOutputResponseBody: Equatable {
    public let availabilityZones: [String]?
}

extension DisableAvailabilityZonesForLoadBalancerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZones"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DisableAvailabilityZonesForLoadBalancerResult"))
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct member{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var availabilityZonesBuffer:[String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
    }
}

extension DuplicateAccessPointNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicateAccessPointNameException(message: \(String(describing: message)))"}
}

extension DuplicateAccessPointNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DuplicateAccessPointNameExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified load balancer name already exists for this account.</p>
public struct DuplicateAccessPointNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateAccessPointNameExceptionBody: Equatable {
    public let message: String?
}

extension DuplicateAccessPointNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateListenerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicateListenerException(message: \(String(describing: message)))"}
}

extension DuplicateListenerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DuplicateListenerExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A listener already exists for the specified load balancer name and port, but with a different instance port, protocol, or SSL certificate.</p>
public struct DuplicateListenerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateListenerExceptionBody: Equatable {
    public let message: String?
}

extension DuplicateListenerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicatePolicyNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicatePolicyNameException(message: \(String(describing: message)))"}
}

extension DuplicatePolicyNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DuplicatePolicyNameExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A policy with the specified name already exists for this load balancer.</p>
public struct DuplicatePolicyNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicatePolicyNameExceptionBody: Equatable {
    public let message: String?
}

extension DuplicatePolicyNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateTagKeysException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicateTagKeysException(message: \(String(describing: message)))"}
}

extension DuplicateTagKeysException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DuplicateTagKeysExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A tag key was specified more than once.</p>
public struct DuplicateTagKeysException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateTagKeysExceptionBody: Equatable {
    public let message: String?
}

extension DuplicateTagKeysExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct EnableAvailabilityZonesForLoadBalancerInputBodyMiddleware: Middleware {
    public let id: String = "EnableAvailabilityZonesForLoadBalancerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableAvailabilityZonesForLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableAvailabilityZonesForLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableAvailabilityZonesForLoadBalancerInput>
    public typealias MOutput = OperationOutput<EnableAvailabilityZonesForLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableAvailabilityZonesForLoadBalancerOutputError>
}

extension EnableAvailabilityZonesForLoadBalancerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableAvailabilityZonesForLoadBalancerInput(availabilityZones: \(String(describing: availabilityZones)), loadBalancerName: \(String(describing: loadBalancerName)))"}
}

extension EnableAvailabilityZonesForLoadBalancerInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZones"))
            for (index0, availabilityzone0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(availabilityzone0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        try container.encode("EnableAvailabilityZonesForLoadBalancer", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct EnableAvailabilityZonesForLoadBalancerInputHeadersMiddleware: Middleware {
    public let id: String = "EnableAvailabilityZonesForLoadBalancerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableAvailabilityZonesForLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableAvailabilityZonesForLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableAvailabilityZonesForLoadBalancerInput>
    public typealias MOutput = OperationOutput<EnableAvailabilityZonesForLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableAvailabilityZonesForLoadBalancerOutputError>
}

public struct EnableAvailabilityZonesForLoadBalancerInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableAvailabilityZonesForLoadBalancerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableAvailabilityZonesForLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableAvailabilityZonesForLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableAvailabilityZonesForLoadBalancerInput>
    public typealias MOutput = OperationOutput<EnableAvailabilityZonesForLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableAvailabilityZonesForLoadBalancerOutputError>
}

/// <p>Contains the parameters for EnableAvailabilityZonesForLoadBalancer.</p>
public struct EnableAvailabilityZonesForLoadBalancerInput: Equatable {
    /// <p>The Availability Zones. These must be in the same region as the load balancer.</p>
    public let availabilityZones: [String]?
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?

    public init (
        availabilityZones: [String]? = nil,
        loadBalancerName: String? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.loadBalancerName = loadBalancerName
    }
}

extension EnableAvailabilityZonesForLoadBalancerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension EnableAvailabilityZonesForLoadBalancerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableAvailabilityZonesForLoadBalancerOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableAvailabilityZonesForLoadBalancerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableAvailabilityZonesForLoadBalancerOutputResponse(availabilityZones: \(String(describing: availabilityZones)))"}
}

extension EnableAvailabilityZonesForLoadBalancerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EnableAvailabilityZonesForLoadBalancerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.availabilityZones = output.availabilityZones
        } else {
            self.availabilityZones = nil
        }
    }
}

/// <p>Contains the output of EnableAvailabilityZonesForLoadBalancer.</p>
public struct EnableAvailabilityZonesForLoadBalancerOutputResponse: Equatable {
    /// <p>The updated list of Availability Zones for the load balancer.</p>
    public let availabilityZones: [String]?

    public init (
        availabilityZones: [String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
    }
}

struct EnableAvailabilityZonesForLoadBalancerOutputResponseBody: Equatable {
    public let availabilityZones: [String]?
}

extension EnableAvailabilityZonesForLoadBalancerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZones"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("EnableAvailabilityZonesForLoadBalancerResult"))
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct member{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var availabilityZonesBuffer:[String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
    }
}

extension HealthCheck: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case healthyThreshold = "HealthyThreshold"
        case interval = "Interval"
        case target = "Target"
        case timeout = "Timeout"
        case unhealthyThreshold = "UnhealthyThreshold"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if healthyThreshold != 0 {
            try container.encode(healthyThreshold, forKey: Key("HealthyThreshold"))
        }
        if interval != 0 {
            try container.encode(interval, forKey: Key("Interval"))
        }
        if let target = target {
            try container.encode(target, forKey: Key("Target"))
        }
        if timeout != 0 {
            try container.encode(timeout, forKey: Key("Timeout"))
        }
        if unhealthyThreshold != 0 {
            try container.encode(unhealthyThreshold, forKey: Key("UnhealthyThreshold"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
        let intervalDecoded = try containerValues.decode(Int.self, forKey: .interval)
        interval = intervalDecoded
        let timeoutDecoded = try containerValues.decode(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let unhealthyThresholdDecoded = try containerValues.decode(Int.self, forKey: .unhealthyThreshold)
        unhealthyThreshold = unhealthyThresholdDecoded
        let healthyThresholdDecoded = try containerValues.decode(Int.self, forKey: .healthyThreshold)
        healthyThreshold = healthyThresholdDecoded
    }
}

extension HealthCheck: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HealthCheck(healthyThreshold: \(String(describing: healthyThreshold)), interval: \(String(describing: interval)), target: \(String(describing: target)), timeout: \(String(describing: timeout)), unhealthyThreshold: \(String(describing: unhealthyThreshold)))"}
}

/// <p>Information about a health check.</p>
public struct HealthCheck: Equatable {
    /// <p>The number of consecutive health checks successes required before moving the instance to the <code>Healthy</code> state.</p>
    public let healthyThreshold: Int
    /// <p>The approximate interval, in seconds, between health checks of an individual instance.</p>
    public let interval: Int
    /// <p>The instance being checked. The protocol is either TCP, HTTP, HTTPS, or SSL. The range of valid ports is one (1) through 65535.</p>
    ///         <p>TCP is the default, specified as a TCP: port pair, for example "TCP:5000". In this case, a health check simply attempts to open a TCP connection to the instance on the specified port. Failure to connect within the configured timeout is considered unhealthy.</p>
    ///         <p>SSL is also specified as SSL: port pair, for example, SSL:5000.</p>
    ///         <p>For HTTP/HTTPS, you must include a ping path in the string. HTTP is specified as a HTTP:port;/;PathToPing; grouping, for example "HTTP:80/weather/us/wa/seattle". In this case, a HTTP GET request is issued to the instance on the given port and path. Any answer other than "200 OK" within the timeout period is considered unhealthy.</p>
    ///          <p>The total length of the HTTP ping target must be 1024 16-bit Unicode characters or less.</p>
    public let target: String?
    /// <p>The amount of time, in seconds, during which no response means a failed health check.</p>
    ///         <p>This value must be less than the <code>Interval</code> value.</p>
    public let timeout: Int
    /// <p>The number of consecutive health check failures required before moving the instance to the <code>Unhealthy</code> state.</p>
    public let unhealthyThreshold: Int

    public init (
        healthyThreshold: Int = 0,
        interval: Int = 0,
        target: String? = nil,
        timeout: Int = 0,
        unhealthyThreshold: Int = 0
    )
    {
        self.healthyThreshold = healthyThreshold
        self.interval = interval
        self.target = target
        self.timeout = timeout
        self.unhealthyThreshold = unhealthyThreshold
    }
}

extension Instance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let instanceId = instanceId {
            try container.encode(instanceId, forKey: Key("InstanceId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension Instance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Instance(instanceId: \(String(describing: instanceId)))"}
}

/// <p>The ID of an EC2 instance.</p>
public struct Instance: Equatable {
    /// <p>The instance ID.</p>
    public let instanceId: String?

    public init (
        instanceId: String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

extension InstanceState: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case instanceId = "InstanceId"
        case reasonCode = "ReasonCode"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let instanceId = instanceId {
            try container.encode(instanceId, forKey: Key("InstanceId"))
        }
        if let reasonCode = reasonCode {
            try container.encode(reasonCode, forKey: Key("ReasonCode"))
        }
        if let state = state {
            try container.encode(state, forKey: Key("State"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
        let reasonCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reasonCode)
        reasonCode = reasonCodeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension InstanceState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceState(description: \(String(describing: description)), instanceId: \(String(describing: instanceId)), reasonCode: \(String(describing: reasonCode)), state: \(String(describing: state)))"}
}

/// <p>Information about the state of an EC2 instance.</p>
public struct InstanceState: Equatable {
    /// <p>A description of the instance state. This string can contain one or more of the following messages.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>N/A</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>A transient error occurred. Please try again later.</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Instance has failed at least the UnhealthyThreshold number of health checks consecutively.</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Instance has not passed the configured HealthyThreshold number of health checks consecutively.</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Instance registration is still in progress.</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Instance is in the EC2 Availability Zone for which LoadBalancer is not configured to route traffic to.</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Instance is not currently registered with the LoadBalancer.</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Instance deregistration currently in progress.</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Disable Availability Zone is currently in progress.</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Instance is in pending state.</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Instance is in stopped state.</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Instance is in terminated state.</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let description: String?
    /// <p>The ID of the instance.</p>
    public let instanceId: String?
    /// <p>Information about the cause of <code>OutOfService</code> instances.
    ///          Specifically, whether the cause is Elastic Load Balancing or the instance.</p>
    ///         <p>Valid values: <code>ELB</code> | <code>Instance</code> | <code>N/A</code>
    ///          </p>
    public let reasonCode: String?
    /// <p>The current state of the instance.</p>
    ///         <p>Valid values: <code>InService</code> | <code>OutOfService</code> | <code>Unknown</code>
    ///          </p>
    public let state: String?

    public init (
        description: String? = nil,
        instanceId: String? = nil,
        reasonCode: String? = nil,
        state: String? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.reasonCode = reasonCode
        self.state = state
    }
}

extension InvalidConfigurationRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidConfigurationRequestException(message: \(String(describing: message)))"}
}

extension InvalidConfigurationRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidConfigurationRequestExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested configuration change is not valid.</p>
public struct InvalidConfigurationRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidConfigurationRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidConfigurationRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEndPointException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidEndPointException(message: \(String(describing: message)))"}
}

extension InvalidEndPointException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidEndPointExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified endpoint is not valid.</p>
public struct InvalidEndPointException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEndPointExceptionBody: Equatable {
    public let message: String?
}

extension InvalidEndPointExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSchemeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSchemeException(message: \(String(describing: message)))"}
}

extension InvalidSchemeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidSchemeExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified value for the schema is not valid. You can only specify a scheme for load balancers in a VPC.</p>
public struct InvalidSchemeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSchemeExceptionBody: Equatable {
    public let message: String?
}

extension InvalidSchemeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSecurityGroupException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSecurityGroupException(message: \(String(describing: message)))"}
}

extension InvalidSecurityGroupException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidSecurityGroupExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more of the specified security groups do not exist.</p>
public struct InvalidSecurityGroupException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSecurityGroupExceptionBody: Equatable {
    public let message: String?
}

extension InvalidSecurityGroupExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnetException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSubnetException(message: \(String(describing: message)))"}
}

extension InvalidSubnetException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidSubnetExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified VPC has no associated Internet gateway.</p>
public struct InvalidSubnetException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSubnetExceptionBody: Equatable {
    public let message: String?
}

extension InvalidSubnetExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LBCookieStickinessPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cookieExpirationPeriod = "CookieExpirationPeriod"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let cookieExpirationPeriod = cookieExpirationPeriod {
            try container.encode(cookieExpirationPeriod, forKey: Key("CookieExpirationPeriod"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let cookieExpirationPeriodDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .cookieExpirationPeriod)
        cookieExpirationPeriod = cookieExpirationPeriodDecoded
    }
}

extension LBCookieStickinessPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LBCookieStickinessPolicy(cookieExpirationPeriod: \(String(describing: cookieExpirationPeriod)), policyName: \(String(describing: policyName)))"}
}

/// <p>Information about a policy for duration-based session stickiness.</p>
public struct LBCookieStickinessPolicy: Equatable {
    /// <p>The time period, in seconds, after which the cookie should be considered stale. If this parameter is not specified, the stickiness session lasts for the duration of the browser session.</p>
    public let cookieExpirationPeriod: Int?
    /// <p>The name of the policy. This name must be unique within the set of policies for this load balancer.</p>
    public let policyName: String?

    public init (
        cookieExpirationPeriod: Int? = nil,
        policyName: String? = nil
    )
    {
        self.cookieExpirationPeriod = cookieExpirationPeriod
        self.policyName = policyName
    }
}

extension Limit: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case max = "Max"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let max = max {
            try container.encode(max, forKey: Key("Max"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let maxDecoded = try containerValues.decodeIfPresent(String.self, forKey: .max)
        max = maxDecoded
    }
}

extension Limit: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Limit(max: \(String(describing: max)), name: \(String(describing: name)))"}
}

/// <p>Information about an Elastic Load Balancing resource limit for your AWS account.</p>
public struct Limit: Equatable {
    /// <p>The maximum value of the limit.</p>
    public let max: String?
    /// <p>The name of the limit. The possible values are:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>classic-listeners</p>
    ///             </li>
    ///             <li>
    ///                 <p>classic-load-balancers</p>
    ///             </li>
    ///             <li>
    ///                 <p>classic-registered-instances</p>
    ///             </li>
    ///          </ul>
    public let name: String?

    public init (
        max: String? = nil,
        name: String? = nil
    )
    {
        self.max = max
        self.name = name
    }
}

extension Listener: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instancePort = "InstancePort"
        case instanceProtocol = "InstanceProtocol"
        case loadBalancerPort = "LoadBalancerPort"
        case `protocol` = "Protocol"
        case sSLCertificateId = "SSLCertificateId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if instancePort != 0 {
            try container.encode(instancePort, forKey: Key("InstancePort"))
        }
        if let instanceProtocol = instanceProtocol {
            try container.encode(instanceProtocol, forKey: Key("InstanceProtocol"))
        }
        if loadBalancerPort != 0 {
            try container.encode(loadBalancerPort, forKey: Key("LoadBalancerPort"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: Key("Protocol"))
        }
        if let sSLCertificateId = sSLCertificateId {
            try container.encode(sSLCertificateId, forKey: Key("SSLCertificateId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let loadBalancerPortDecoded = try containerValues.decode(Int.self, forKey: .loadBalancerPort)
        loadBalancerPort = loadBalancerPortDecoded
        let instanceProtocolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceProtocol)
        instanceProtocol = instanceProtocolDecoded
        let instancePortDecoded = try containerValues.decode(Int.self, forKey: .instancePort)
        instancePort = instancePortDecoded
        let sSLCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sSLCertificateId)
        sSLCertificateId = sSLCertificateIdDecoded
    }
}

extension Listener: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Listener(instancePort: \(String(describing: instancePort)), instanceProtocol: \(String(describing: instanceProtocol)), loadBalancerPort: \(String(describing: loadBalancerPort)), protocol: \(String(describing: `protocol`)), sSLCertificateId: \(String(describing: sSLCertificateId)))"}
}

/// <p>Information about a listener.</p>
///         <p>For information about the protocols and the ports supported by Elastic Load Balancing, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html">Listeners for Your Classic Load Balancer</a>
///             in the <i>Classic Load Balancers Guide</i>.</p>
public struct Listener: Equatable {
    /// <p>The load balancer transport protocol to use for routing: HTTP, HTTPS, TCP, or SSL.</p>
    public let `protocol`: String?
    /// <p>The port on which the instance is listening.</p>
    public let instancePort: Int
    /// <p>The protocol to use for routing traffic to instances: HTTP, HTTPS, TCP, or SSL.</p>
    ///          <p>If the front-end protocol is TCP or SSL, the back-end protocol must be TCP or SSL.
    ///            If the front-end protocol is HTTP or HTTPS, the back-end protocol must be HTTP or HTTPS.</p>
    ///          <p>If there is another listener with the same <code>InstancePort</code> whose <code>InstanceProtocol</code> is secure,
    ///           (HTTPS or SSL), the listener's <code>InstanceProtocol</code> must also be secure.</p>
    ///         <p>If there is another listener with the same <code>InstancePort</code> whose <code>InstanceProtocol</code> is HTTP or TCP,
    ///            the listener's <code>InstanceProtocol</code> must be HTTP or TCP.</p>
    public let instanceProtocol: String?
    /// <p>The port on which the load balancer is listening. On EC2-VPC, you can specify any port from the range 1-65535. On EC2-Classic, you can specify any port from the following list: 25, 80, 443, 465, 587, 1024-65535.</p>
    public let loadBalancerPort: Int
    /// <p>The Amazon Resource Name (ARN) of the server certificate.</p>
    public let sSLCertificateId: String?

    public init (
        `protocol`: String? = nil,
        instancePort: Int = 0,
        instanceProtocol: String? = nil,
        loadBalancerPort: Int = 0,
        sSLCertificateId: String? = nil
    )
    {
        self.`protocol` = `protocol`
        self.instancePort = instancePort
        self.instanceProtocol = instanceProtocol
        self.loadBalancerPort = loadBalancerPort
        self.sSLCertificateId = sSLCertificateId
    }
}

extension ListenerDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case listener = "Listener"
        case policyNames = "PolicyNames"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let listener = listener {
            try container.encode(listener, forKey: Key("Listener"))
        }
        if let policyNames = policyNames {
            var policyNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PolicyNames"))
            for (index0, policyname0) in policyNames.enumerated() {
                try policyNamesContainer.encode(policyname0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(Listener.self, forKey: .listener)
        listener = listenerDecoded
        if containerValues.contains(.policyNames) {
            struct KeyVal0{struct member{}}
            let policyNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyNames)
            if let policyNamesWrappedContainer = policyNamesWrappedContainer {
                let policyNamesContainer = try policyNamesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var policyNamesBuffer:[String]? = nil
                if let policyNamesContainer = policyNamesContainer {
                    policyNamesBuffer = [String]()
                    for stringContainer0 in policyNamesContainer {
                        policyNamesBuffer?.append(stringContainer0)
                    }
                }
                policyNames = policyNamesBuffer
            } else {
                policyNames = []
            }
        } else {
            policyNames = nil
        }
    }
}

extension ListenerDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListenerDescription(listener: \(String(describing: listener)), policyNames: \(String(describing: policyNames)))"}
}

/// <p>The policies enabled for a listener.</p>
public struct ListenerDescription: Equatable {
    /// <p>The listener.</p>
    public let listener: Listener?
    /// <p>The policies. If there are no policies enabled, the list is empty.</p>
    public let policyNames: [String]?

    public init (
        listener: Listener? = nil,
        policyNames: [String]? = nil
    )
    {
        self.listener = listener
        self.policyNames = policyNames
    }
}

extension ListenerNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListenerNotFoundException(message: \(String(describing: message)))"}
}

extension ListenerNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ListenerNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The load balancer does not have a listener configured at the specified port.</p>
public struct ListenerNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ListenerNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ListenerNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LoadBalancerAttributeNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoadBalancerAttributeNotFoundException(message: \(String(describing: message)))"}
}

extension LoadBalancerAttributeNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<LoadBalancerAttributeNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified load balancer attribute does not exist.</p>
public struct LoadBalancerAttributeNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LoadBalancerAttributeNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension LoadBalancerAttributeNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LoadBalancerAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessLog = "AccessLog"
        case additionalAttributes = "AdditionalAttributes"
        case connectionDraining = "ConnectionDraining"
        case connectionSettings = "ConnectionSettings"
        case crossZoneLoadBalancing = "CrossZoneLoadBalancing"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accessLog = accessLog {
            try container.encode(accessLog, forKey: Key("AccessLog"))
        }
        if let additionalAttributes = additionalAttributes {
            var additionalAttributesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AdditionalAttributes"))
            for (index0, additionalattribute0) in additionalAttributes.enumerated() {
                try additionalAttributesContainer.encode(additionalattribute0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let connectionDraining = connectionDraining {
            try container.encode(connectionDraining, forKey: Key("ConnectionDraining"))
        }
        if let connectionSettings = connectionSettings {
            try container.encode(connectionSettings, forKey: Key("ConnectionSettings"))
        }
        if let crossZoneLoadBalancing = crossZoneLoadBalancing {
            try container.encode(crossZoneLoadBalancing, forKey: Key("CrossZoneLoadBalancing"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crossZoneLoadBalancingDecoded = try containerValues.decodeIfPresent(CrossZoneLoadBalancing.self, forKey: .crossZoneLoadBalancing)
        crossZoneLoadBalancing = crossZoneLoadBalancingDecoded
        let accessLogDecoded = try containerValues.decodeIfPresent(AccessLog.self, forKey: .accessLog)
        accessLog = accessLogDecoded
        let connectionDrainingDecoded = try containerValues.decodeIfPresent(ConnectionDraining.self, forKey: .connectionDraining)
        connectionDraining = connectionDrainingDecoded
        let connectionSettingsDecoded = try containerValues.decodeIfPresent(ConnectionSettings.self, forKey: .connectionSettings)
        connectionSettings = connectionSettingsDecoded
        if containerValues.contains(.additionalAttributes) {
            struct KeyVal0{struct member{}}
            let additionalAttributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .additionalAttributes)
            if let additionalAttributesWrappedContainer = additionalAttributesWrappedContainer {
                let additionalAttributesContainer = try additionalAttributesWrappedContainer.decodeIfPresent([AdditionalAttribute].self, forKey: .member)
                var additionalAttributesBuffer:[AdditionalAttribute]? = nil
                if let additionalAttributesContainer = additionalAttributesContainer {
                    additionalAttributesBuffer = [AdditionalAttribute]()
                    for structureContainer0 in additionalAttributesContainer {
                        additionalAttributesBuffer?.append(structureContainer0)
                    }
                }
                additionalAttributes = additionalAttributesBuffer
            } else {
                additionalAttributes = []
            }
        } else {
            additionalAttributes = nil
        }
    }
}

extension LoadBalancerAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoadBalancerAttributes(accessLog: \(String(describing: accessLog)), additionalAttributes: \(String(describing: additionalAttributes)), connectionDraining: \(String(describing: connectionDraining)), connectionSettings: \(String(describing: connectionSettings)), crossZoneLoadBalancing: \(String(describing: crossZoneLoadBalancing)))"}
}

/// <p>The attributes for a load balancer.</p>
public struct LoadBalancerAttributes: Equatable {
    /// <p>If enabled, the load balancer captures detailed information of all requests and delivers the information to the Amazon S3 bucket that you specify.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/enable-access-logs.html">Enable Access Logs</a>
    ///             in the <i>Classic Load Balancers Guide</i>.</p>
    public let accessLog: AccessLog?
    /// <p>Any additional attributes.</p>
    public let additionalAttributes: [AdditionalAttribute]?
    /// <p>If enabled, the load balancer allows existing requests to complete before the load balancer shifts traffic away from a deregistered or unhealthy instance.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/config-conn-drain.html">Configure Connection Draining</a>
    ///             in the <i>Classic Load Balancers Guide</i>.</p>
    public let connectionDraining: ConnectionDraining?
    /// <p>If enabled, the load balancer allows the connections to remain idle (no data is sent over the connection) for the specified duration.</p>
    ///         <p>By default, Elastic Load Balancing maintains a 60-second idle connection timeout for both front-end and back-end connections of your load balancer.
    ///             For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/config-idle-timeout.html">Configure Idle Connection Timeout</a>
    ///             in the <i>Classic Load Balancers Guide</i>.</p>
    public let connectionSettings: ConnectionSettings?
    /// <p>If enabled, the load balancer routes the request traffic evenly across all instances regardless of the Availability Zones.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/enable-disable-crosszone-lb.html">Configure Cross-Zone Load Balancing</a>
    ///             in the <i>Classic Load Balancers Guide</i>.</p>
    public let crossZoneLoadBalancing: CrossZoneLoadBalancing?

    public init (
        accessLog: AccessLog? = nil,
        additionalAttributes: [AdditionalAttribute]? = nil,
        connectionDraining: ConnectionDraining? = nil,
        connectionSettings: ConnectionSettings? = nil,
        crossZoneLoadBalancing: CrossZoneLoadBalancing? = nil
    )
    {
        self.accessLog = accessLog
        self.additionalAttributes = additionalAttributes
        self.connectionDraining = connectionDraining
        self.connectionSettings = connectionSettings
        self.crossZoneLoadBalancing = crossZoneLoadBalancing
    }
}

extension LoadBalancerDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZones"
        case backendServerDescriptions = "BackendServerDescriptions"
        case canonicalHostedZoneName = "CanonicalHostedZoneName"
        case canonicalHostedZoneNameID = "CanonicalHostedZoneNameID"
        case createdTime = "CreatedTime"
        case dNSName = "DNSName"
        case healthCheck = "HealthCheck"
        case instances = "Instances"
        case listenerDescriptions = "ListenerDescriptions"
        case loadBalancerName = "LoadBalancerName"
        case policies = "Policies"
        case scheme = "Scheme"
        case securityGroups = "SecurityGroups"
        case sourceSecurityGroup = "SourceSecurityGroup"
        case subnets = "Subnets"
        case vPCId = "VPCId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZones"))
            for (index0, availabilityzone0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(availabilityzone0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let backendServerDescriptions = backendServerDescriptions {
            var backendServerDescriptionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("BackendServerDescriptions"))
            for (index0, backendserverdescription0) in backendServerDescriptions.enumerated() {
                try backendServerDescriptionsContainer.encode(backendserverdescription0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let canonicalHostedZoneName = canonicalHostedZoneName {
            try container.encode(canonicalHostedZoneName, forKey: Key("CanonicalHostedZoneName"))
        }
        if let canonicalHostedZoneNameID = canonicalHostedZoneNameID {
            try container.encode(canonicalHostedZoneNameID, forKey: Key("CanonicalHostedZoneNameID"))
        }
        if let createdTime = createdTime {
            try container.encode(TimestampWrapper(createdTime, format: .dateTime), forKey: Key("createdTime"))
        }
        if let dNSName = dNSName {
            try container.encode(dNSName, forKey: Key("DNSName"))
        }
        if let healthCheck = healthCheck {
            try container.encode(healthCheck, forKey: Key("HealthCheck"))
        }
        if let instances = instances {
            var instancesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Instances"))
            for (index0, instance0) in instances.enumerated() {
                try instancesContainer.encode(instance0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let listenerDescriptions = listenerDescriptions {
            var listenerDescriptionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ListenerDescriptions"))
            for (index0, listenerdescription0) in listenerDescriptions.enumerated() {
                try listenerDescriptionsContainer.encode(listenerdescription0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        if let policies = policies {
            try container.encode(policies, forKey: Key("Policies"))
        }
        if let scheme = scheme {
            try container.encode(scheme, forKey: Key("Scheme"))
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SecurityGroups"))
            for (index0, securitygroupid0) in securityGroups.enumerated() {
                try securityGroupsContainer.encode(securitygroupid0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceSecurityGroup = sourceSecurityGroup {
            try container.encode(sourceSecurityGroup, forKey: Key("SourceSecurityGroup"))
        }
        if let subnets = subnets {
            var subnetsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Subnets"))
            for (index0, subnetid0) in subnets.enumerated() {
                try subnetsContainer.encode(subnetid0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let vPCId = vPCId {
            try container.encode(vPCId, forKey: Key("VPCId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        let dNSNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dNSName)
        dNSName = dNSNameDecoded
        let canonicalHostedZoneNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .canonicalHostedZoneName)
        canonicalHostedZoneName = canonicalHostedZoneNameDecoded
        let canonicalHostedZoneNameIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .canonicalHostedZoneNameID)
        canonicalHostedZoneNameID = canonicalHostedZoneNameIDDecoded
        if containerValues.contains(.listenerDescriptions) {
            struct KeyVal0{struct member{}}
            let listenerDescriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .listenerDescriptions)
            if let listenerDescriptionsWrappedContainer = listenerDescriptionsWrappedContainer {
                let listenerDescriptionsContainer = try listenerDescriptionsWrappedContainer.decodeIfPresent([ListenerDescription].self, forKey: .member)
                var listenerDescriptionsBuffer:[ListenerDescription]? = nil
                if let listenerDescriptionsContainer = listenerDescriptionsContainer {
                    listenerDescriptionsBuffer = [ListenerDescription]()
                    for structureContainer0 in listenerDescriptionsContainer {
                        listenerDescriptionsBuffer?.append(structureContainer0)
                    }
                }
                listenerDescriptions = listenerDescriptionsBuffer
            } else {
                listenerDescriptions = []
            }
        } else {
            listenerDescriptions = nil
        }
        let policiesDecoded = try containerValues.decodeIfPresent(Policies.self, forKey: .policies)
        policies = policiesDecoded
        if containerValues.contains(.backendServerDescriptions) {
            struct KeyVal0{struct member{}}
            let backendServerDescriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .backendServerDescriptions)
            if let backendServerDescriptionsWrappedContainer = backendServerDescriptionsWrappedContainer {
                let backendServerDescriptionsContainer = try backendServerDescriptionsWrappedContainer.decodeIfPresent([BackendServerDescription].self, forKey: .member)
                var backendServerDescriptionsBuffer:[BackendServerDescription]? = nil
                if let backendServerDescriptionsContainer = backendServerDescriptionsContainer {
                    backendServerDescriptionsBuffer = [BackendServerDescription]()
                    for structureContainer0 in backendServerDescriptionsContainer {
                        backendServerDescriptionsBuffer?.append(structureContainer0)
                    }
                }
                backendServerDescriptions = backendServerDescriptionsBuffer
            } else {
                backendServerDescriptions = []
            }
        } else {
            backendServerDescriptions = nil
        }
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct member{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var availabilityZonesBuffer:[String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        if containerValues.contains(.subnets) {
            struct KeyVal0{struct member{}}
            let subnetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .subnets)
            if let subnetsWrappedContainer = subnetsWrappedContainer {
                let subnetsContainer = try subnetsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var subnetsBuffer:[String]? = nil
                if let subnetsContainer = subnetsContainer {
                    subnetsBuffer = [String]()
                    for stringContainer0 in subnetsContainer {
                        subnetsBuffer?.append(stringContainer0)
                    }
                }
                subnets = subnetsBuffer
            } else {
                subnets = []
            }
        } else {
            subnets = nil
        }
        let vPCIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vPCId)
        vPCId = vPCIdDecoded
        if containerValues.contains(.instances) {
            struct KeyVal0{struct member{}}
            let instancesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instances)
            if let instancesWrappedContainer = instancesWrappedContainer {
                let instancesContainer = try instancesWrappedContainer.decodeIfPresent([Instance].self, forKey: .member)
                var instancesBuffer:[Instance]? = nil
                if let instancesContainer = instancesContainer {
                    instancesBuffer = [Instance]()
                    for structureContainer0 in instancesContainer {
                        instancesBuffer?.append(structureContainer0)
                    }
                }
                instances = instancesBuffer
            } else {
                instances = []
            }
        } else {
            instances = nil
        }
        let healthCheckDecoded = try containerValues.decodeIfPresent(HealthCheck.self, forKey: .healthCheck)
        healthCheck = healthCheckDecoded
        let sourceSecurityGroupDecoded = try containerValues.decodeIfPresent(SourceSecurityGroup.self, forKey: .sourceSecurityGroup)
        sourceSecurityGroup = sourceSecurityGroupDecoded
        if containerValues.contains(.securityGroups) {
            struct KeyVal0{struct member{}}
            let securityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .securityGroups)
            if let securityGroupsWrappedContainer = securityGroupsWrappedContainer {
                let securityGroupsContainer = try securityGroupsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var securityGroupsBuffer:[String]? = nil
                if let securityGroupsContainer = securityGroupsContainer {
                    securityGroupsBuffer = [String]()
                    for stringContainer0 in securityGroupsContainer {
                        securityGroupsBuffer?.append(stringContainer0)
                    }
                }
                securityGroups = securityGroupsBuffer
            } else {
                securityGroups = []
            }
        } else {
            securityGroups = nil
        }
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        var createdTimeBuffer:Date? = nil
        if let createdTimeDecoded = createdTimeDecoded {
            createdTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(createdTimeDecoded, format: .dateTime)
        }
        createdTime = createdTimeBuffer
        let schemeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheme)
        scheme = schemeDecoded
    }
}

extension LoadBalancerDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoadBalancerDescription(availabilityZones: \(String(describing: availabilityZones)), backendServerDescriptions: \(String(describing: backendServerDescriptions)), canonicalHostedZoneName: \(String(describing: canonicalHostedZoneName)), canonicalHostedZoneNameID: \(String(describing: canonicalHostedZoneNameID)), createdTime: \(String(describing: createdTime)), dNSName: \(String(describing: dNSName)), healthCheck: \(String(describing: healthCheck)), instances: \(String(describing: instances)), listenerDescriptions: \(String(describing: listenerDescriptions)), loadBalancerName: \(String(describing: loadBalancerName)), policies: \(String(describing: policies)), scheme: \(String(describing: scheme)), securityGroups: \(String(describing: securityGroups)), sourceSecurityGroup: \(String(describing: sourceSecurityGroup)), subnets: \(String(describing: subnets)), vPCId: \(String(describing: vPCId)))"}
}

/// <p>Information about a load balancer.</p>
public struct LoadBalancerDescription: Equatable {
    /// <p>The Availability Zones for the load balancer.</p>
    public let availabilityZones: [String]?
    /// <p>Information about your EC2 instances.</p>
    public let backendServerDescriptions: [BackendServerDescription]?
    /// <p>The DNS name of the load balancer.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/using-domain-names-with-elb.html">Configure a Custom Domain Name</a>
    ///             in the <i>Classic Load Balancers Guide</i>.</p>
    public let canonicalHostedZoneName: String?
    /// <p>The ID of the Amazon Route 53 hosted zone for the load balancer.</p>
    public let canonicalHostedZoneNameID: String?
    /// <p>The date and time the load balancer was created.</p>
    public let createdTime: Date?
    /// <p>The DNS name of the load balancer.</p>
    public let dNSName: String?
    /// <p>Information about the health checks conducted on the load balancer.</p>
    public let healthCheck: HealthCheck?
    /// <p>The IDs of the instances for the load balancer.</p>
    public let instances: [Instance]?
    /// <p>The listeners for the load balancer.</p>
    public let listenerDescriptions: [ListenerDescription]?
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?
    /// <p>The policies defined for the load balancer.</p>
    public let policies: Policies?
    /// <p>The type of load balancer. Valid only for load balancers in a VPC.</p>
    ///          <p>If <code>Scheme</code> is <code>internet-facing</code>, the load balancer
    ///            has a public DNS name that resolves to a public IP address.</p>
    ///         <p>If <code>Scheme</code> is <code>internal</code>, the load balancer has a public
    ///            DNS name that resolves to a private IP address.</p>
    public let scheme: String?
    /// <p>The security groups for the load balancer. Valid only for load balancers in a VPC.</p>
    public let securityGroups: [String]?
    /// <p>The security group for the load balancer, which you can use as part of your inbound rules for your registered instances.
    ///             To only allow traffic from load balancers, add a security group rule that specifies this source security group as the inbound source.</p>
    public let sourceSecurityGroup: SourceSecurityGroup?
    /// <p>The IDs of the subnets for the load balancer.</p>
    public let subnets: [String]?
    /// <p>The ID of the VPC for the load balancer.</p>
    public let vPCId: String?

    public init (
        availabilityZones: [String]? = nil,
        backendServerDescriptions: [BackendServerDescription]? = nil,
        canonicalHostedZoneName: String? = nil,
        canonicalHostedZoneNameID: String? = nil,
        createdTime: Date? = nil,
        dNSName: String? = nil,
        healthCheck: HealthCheck? = nil,
        instances: [Instance]? = nil,
        listenerDescriptions: [ListenerDescription]? = nil,
        loadBalancerName: String? = nil,
        policies: Policies? = nil,
        scheme: String? = nil,
        securityGroups: [String]? = nil,
        sourceSecurityGroup: SourceSecurityGroup? = nil,
        subnets: [String]? = nil,
        vPCId: String? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.backendServerDescriptions = backendServerDescriptions
        self.canonicalHostedZoneName = canonicalHostedZoneName
        self.canonicalHostedZoneNameID = canonicalHostedZoneNameID
        self.createdTime = createdTime
        self.dNSName = dNSName
        self.healthCheck = healthCheck
        self.instances = instances
        self.listenerDescriptions = listenerDescriptions
        self.loadBalancerName = loadBalancerName
        self.policies = policies
        self.scheme = scheme
        self.securityGroups = securityGroups
        self.sourceSecurityGroup = sourceSecurityGroup
        self.subnets = subnets
        self.vPCId = vPCId
    }
}

public struct ModifyLoadBalancerAttributesInputBodyMiddleware: Middleware {
    public let id: String = "ModifyLoadBalancerAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyLoadBalancerAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyLoadBalancerAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyLoadBalancerAttributesInput>
    public typealias MOutput = OperationOutput<ModifyLoadBalancerAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyLoadBalancerAttributesOutputError>
}

extension ModifyLoadBalancerAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyLoadBalancerAttributesInput(loadBalancerAttributes: \(String(describing: loadBalancerAttributes)), loadBalancerName: \(String(describing: loadBalancerName)))"}
}

extension ModifyLoadBalancerAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancerAttributes = loadBalancerAttributes {
            try container.encode(loadBalancerAttributes, forKey: Key("LoadBalancerAttributes"))
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        try container.encode("ModifyLoadBalancerAttributes", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct ModifyLoadBalancerAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyLoadBalancerAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyLoadBalancerAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyLoadBalancerAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyLoadBalancerAttributesInput>
    public typealias MOutput = OperationOutput<ModifyLoadBalancerAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyLoadBalancerAttributesOutputError>
}

public struct ModifyLoadBalancerAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyLoadBalancerAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyLoadBalancerAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyLoadBalancerAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyLoadBalancerAttributesInput>
    public typealias MOutput = OperationOutput<ModifyLoadBalancerAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyLoadBalancerAttributesOutputError>
}

/// <p>Contains the parameters for ModifyLoadBalancerAttributes.</p>
public struct ModifyLoadBalancerAttributesInput: Equatable {
    /// <p>The attributes for the load balancer.</p>
    public let loadBalancerAttributes: LoadBalancerAttributes?
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?

    public init (
        loadBalancerAttributes: LoadBalancerAttributes? = nil,
        loadBalancerName: String? = nil
    )
    {
        self.loadBalancerAttributes = loadBalancerAttributes
        self.loadBalancerName = loadBalancerName
    }
}

extension ModifyLoadBalancerAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyLoadBalancerAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoadBalancerAttributeNotFoundException" : self = .loadBalancerAttributeNotFoundException(try LoadBalancerAttributeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyLoadBalancerAttributesOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case loadBalancerAttributeNotFoundException(LoadBalancerAttributeNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyLoadBalancerAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyLoadBalancerAttributesOutputResponse(loadBalancerAttributes: \(String(describing: loadBalancerAttributes)), loadBalancerName: \(String(describing: loadBalancerName)))"}
}

extension ModifyLoadBalancerAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyLoadBalancerAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.loadBalancerAttributes = output.loadBalancerAttributes
            self.loadBalancerName = output.loadBalancerName
        } else {
            self.loadBalancerAttributes = nil
            self.loadBalancerName = nil
        }
    }
}

/// <p>Contains the output of ModifyLoadBalancerAttributes.</p>
public struct ModifyLoadBalancerAttributesOutputResponse: Equatable {
    /// <p>Information about the load balancer attributes.</p>
    public let loadBalancerAttributes: LoadBalancerAttributes?
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?

    public init (
        loadBalancerAttributes: LoadBalancerAttributes? = nil,
        loadBalancerName: String? = nil
    )
    {
        self.loadBalancerAttributes = loadBalancerAttributes
        self.loadBalancerName = loadBalancerName
    }
}

struct ModifyLoadBalancerAttributesOutputResponseBody: Equatable {
    public let loadBalancerName: String?
    public let loadBalancerAttributes: LoadBalancerAttributes?
}

extension ModifyLoadBalancerAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loadBalancerAttributes = "LoadBalancerAttributes"
        case loadBalancerName = "LoadBalancerName"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyLoadBalancerAttributesResult"))
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        let loadBalancerAttributesDecoded = try containerValues.decodeIfPresent(LoadBalancerAttributes.self, forKey: .loadBalancerAttributes)
        loadBalancerAttributes = loadBalancerAttributesDecoded
    }
}

extension OperationNotPermittedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationNotPermittedException(message: \(String(describing: message)))"}
}

extension OperationNotPermittedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<OperationNotPermittedExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This operation is not allowed.</p>
public struct OperationNotPermittedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotPermittedExceptionBody: Equatable {
    public let message: String?
}

extension OperationNotPermittedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Policies: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appCookieStickinessPolicies = "AppCookieStickinessPolicies"
        case lBCookieStickinessPolicies = "LBCookieStickinessPolicies"
        case otherPolicies = "OtherPolicies"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let appCookieStickinessPolicies = appCookieStickinessPolicies {
            var appCookieStickinessPoliciesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AppCookieStickinessPolicies"))
            for (index0, appcookiestickinesspolicy0) in appCookieStickinessPolicies.enumerated() {
                try appCookieStickinessPoliciesContainer.encode(appcookiestickinesspolicy0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let lBCookieStickinessPolicies = lBCookieStickinessPolicies {
            var lBCookieStickinessPoliciesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("LBCookieStickinessPolicies"))
            for (index0, lbcookiestickinesspolicy0) in lBCookieStickinessPolicies.enumerated() {
                try lBCookieStickinessPoliciesContainer.encode(lbcookiestickinesspolicy0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let otherPolicies = otherPolicies {
            var otherPoliciesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OtherPolicies"))
            for (index0, policyname0) in otherPolicies.enumerated() {
                try otherPoliciesContainer.encode(policyname0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.appCookieStickinessPolicies) {
            struct KeyVal0{struct member{}}
            let appCookieStickinessPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .appCookieStickinessPolicies)
            if let appCookieStickinessPoliciesWrappedContainer = appCookieStickinessPoliciesWrappedContainer {
                let appCookieStickinessPoliciesContainer = try appCookieStickinessPoliciesWrappedContainer.decodeIfPresent([AppCookieStickinessPolicy].self, forKey: .member)
                var appCookieStickinessPoliciesBuffer:[AppCookieStickinessPolicy]? = nil
                if let appCookieStickinessPoliciesContainer = appCookieStickinessPoliciesContainer {
                    appCookieStickinessPoliciesBuffer = [AppCookieStickinessPolicy]()
                    for structureContainer0 in appCookieStickinessPoliciesContainer {
                        appCookieStickinessPoliciesBuffer?.append(structureContainer0)
                    }
                }
                appCookieStickinessPolicies = appCookieStickinessPoliciesBuffer
            } else {
                appCookieStickinessPolicies = []
            }
        } else {
            appCookieStickinessPolicies = nil
        }
        if containerValues.contains(.lBCookieStickinessPolicies) {
            struct KeyVal0{struct member{}}
            let lBCookieStickinessPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .lBCookieStickinessPolicies)
            if let lBCookieStickinessPoliciesWrappedContainer = lBCookieStickinessPoliciesWrappedContainer {
                let lBCookieStickinessPoliciesContainer = try lBCookieStickinessPoliciesWrappedContainer.decodeIfPresent([LBCookieStickinessPolicy].self, forKey: .member)
                var lBCookieStickinessPoliciesBuffer:[LBCookieStickinessPolicy]? = nil
                if let lBCookieStickinessPoliciesContainer = lBCookieStickinessPoliciesContainer {
                    lBCookieStickinessPoliciesBuffer = [LBCookieStickinessPolicy]()
                    for structureContainer0 in lBCookieStickinessPoliciesContainer {
                        lBCookieStickinessPoliciesBuffer?.append(structureContainer0)
                    }
                }
                lBCookieStickinessPolicies = lBCookieStickinessPoliciesBuffer
            } else {
                lBCookieStickinessPolicies = []
            }
        } else {
            lBCookieStickinessPolicies = nil
        }
        if containerValues.contains(.otherPolicies) {
            struct KeyVal0{struct member{}}
            let otherPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .otherPolicies)
            if let otherPoliciesWrappedContainer = otherPoliciesWrappedContainer {
                let otherPoliciesContainer = try otherPoliciesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var otherPoliciesBuffer:[String]? = nil
                if let otherPoliciesContainer = otherPoliciesContainer {
                    otherPoliciesBuffer = [String]()
                    for stringContainer0 in otherPoliciesContainer {
                        otherPoliciesBuffer?.append(stringContainer0)
                    }
                }
                otherPolicies = otherPoliciesBuffer
            } else {
                otherPolicies = []
            }
        } else {
            otherPolicies = nil
        }
    }
}

extension Policies: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Policies(appCookieStickinessPolicies: \(String(describing: appCookieStickinessPolicies)), lBCookieStickinessPolicies: \(String(describing: lBCookieStickinessPolicies)), otherPolicies: \(String(describing: otherPolicies)))"}
}

/// <p>The policies for a load balancer.</p>
public struct Policies: Equatable {
    /// <p>The stickiness policies created using <a>CreateAppCookieStickinessPolicy</a>.</p>
    public let appCookieStickinessPolicies: [AppCookieStickinessPolicy]?
    /// <p>The stickiness policies created using <a>CreateLBCookieStickinessPolicy</a>.</p>
    public let lBCookieStickinessPolicies: [LBCookieStickinessPolicy]?
    /// <p>The policies other than the stickiness policies.</p>
    public let otherPolicies: [String]?

    public init (
        appCookieStickinessPolicies: [AppCookieStickinessPolicy]? = nil,
        lBCookieStickinessPolicies: [LBCookieStickinessPolicy]? = nil,
        otherPolicies: [String]? = nil
    )
    {
        self.appCookieStickinessPolicies = appCookieStickinessPolicies
        self.lBCookieStickinessPolicies = lBCookieStickinessPolicies
        self.otherPolicies = otherPolicies
    }
}

extension PolicyAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "AttributeName"
        case attributeValue = "AttributeValue"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: Key("AttributeName"))
        }
        if let attributeValue = attributeValue {
            try container.encode(attributeValue, forKey: Key("AttributeValue"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let attributeValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
    }
}

extension PolicyAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyAttribute(attributeName: \(String(describing: attributeName)), attributeValue: \(String(describing: attributeValue)))"}
}

/// <p>Information about a policy attribute.</p>
public struct PolicyAttribute: Equatable {
    /// <p>The name of the attribute.</p>
    public let attributeName: String?
    /// <p>The value of the attribute.</p>
    public let attributeValue: String?

    public init (
        attributeName: String? = nil,
        attributeValue: String? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeValue = attributeValue
    }
}

extension PolicyAttributeDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "AttributeName"
        case attributeValue = "AttributeValue"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: Key("AttributeName"))
        }
        if let attributeValue = attributeValue {
            try container.encode(attributeValue, forKey: Key("AttributeValue"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let attributeValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
    }
}

extension PolicyAttributeDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyAttributeDescription(attributeName: \(String(describing: attributeName)), attributeValue: \(String(describing: attributeValue)))"}
}

/// <p>Information about a policy attribute.</p>
public struct PolicyAttributeDescription: Equatable {
    /// <p>The name of the attribute.</p>
    public let attributeName: String?
    /// <p>The value of the attribute.</p>
    public let attributeValue: String?

    public init (
        attributeName: String? = nil,
        attributeValue: String? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeValue = attributeValue
    }
}

extension PolicyAttributeTypeDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "AttributeName"
        case attributeType = "AttributeType"
        case cardinality = "Cardinality"
        case defaultValue = "DefaultValue"
        case description = "Description"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: Key("AttributeName"))
        }
        if let attributeType = attributeType {
            try container.encode(attributeType, forKey: Key("AttributeType"))
        }
        if let cardinality = cardinality {
            try container.encode(cardinality, forKey: Key("Cardinality"))
        }
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: Key("DefaultValue"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let attributeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeType)
        attributeType = attributeTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let cardinalityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cardinality)
        cardinality = cardinalityDecoded
    }
}

extension PolicyAttributeTypeDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyAttributeTypeDescription(attributeName: \(String(describing: attributeName)), attributeType: \(String(describing: attributeType)), cardinality: \(String(describing: cardinality)), defaultValue: \(String(describing: defaultValue)), description: \(String(describing: description)))"}
}

/// <p>Information about a policy attribute type.</p>
public struct PolicyAttributeTypeDescription: Equatable {
    /// <p>The name of the attribute.</p>
    public let attributeName: String?
    /// <p>The type of the attribute. For example, <code>Boolean</code> or <code>Integer</code>.</p>
    public let attributeType: String?
    /// <p>The cardinality of the attribute.</p>
    ///         <p>Valid values:</p>
    ///             <ul>
    ///             <li>
    ///                <p>ONE(1) : Single value required</p>
    ///             </li>
    ///             <li>
    ///                <p>ZERO_OR_ONE(0..1) : Up to one value is allowed</p>
    ///             </li>
    ///             <li>
    ///                <p>ZERO_OR_MORE(0..*) : Optional. Multiple values are allowed</p>
    ///             </li>
    ///             <li>
    ///                <p>ONE_OR_MORE(1..*0) : Required. Multiple values are allowed</p>
    ///             </li>
    ///          </ul>
    public let cardinality: String?
    /// <p>The default value of the attribute, if applicable.</p>
    public let defaultValue: String?
    /// <p>A description of the attribute.</p>
    public let description: String?

    public init (
        attributeName: String? = nil,
        attributeType: String? = nil,
        cardinality: String? = nil,
        defaultValue: String? = nil,
        description: String? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeType = attributeType
        self.cardinality = cardinality
        self.defaultValue = defaultValue
        self.description = description
    }
}

extension PolicyDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policyAttributeDescriptions = "PolicyAttributeDescriptions"
        case policyName = "PolicyName"
        case policyTypeName = "PolicyTypeName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let policyAttributeDescriptions = policyAttributeDescriptions {
            var policyAttributeDescriptionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PolicyAttributeDescriptions"))
            for (index0, policyattributedescription0) in policyAttributeDescriptions.enumerated() {
                try policyAttributeDescriptionsContainer.encode(policyattributedescription0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
        if let policyTypeName = policyTypeName {
            try container.encode(policyTypeName, forKey: Key("PolicyTypeName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyTypeName)
        policyTypeName = policyTypeNameDecoded
        if containerValues.contains(.policyAttributeDescriptions) {
            struct KeyVal0{struct member{}}
            let policyAttributeDescriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyAttributeDescriptions)
            if let policyAttributeDescriptionsWrappedContainer = policyAttributeDescriptionsWrappedContainer {
                let policyAttributeDescriptionsContainer = try policyAttributeDescriptionsWrappedContainer.decodeIfPresent([PolicyAttributeDescription].self, forKey: .member)
                var policyAttributeDescriptionsBuffer:[PolicyAttributeDescription]? = nil
                if let policyAttributeDescriptionsContainer = policyAttributeDescriptionsContainer {
                    policyAttributeDescriptionsBuffer = [PolicyAttributeDescription]()
                    for structureContainer0 in policyAttributeDescriptionsContainer {
                        policyAttributeDescriptionsBuffer?.append(structureContainer0)
                    }
                }
                policyAttributeDescriptions = policyAttributeDescriptionsBuffer
            } else {
                policyAttributeDescriptions = []
            }
        } else {
            policyAttributeDescriptions = nil
        }
    }
}

extension PolicyDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyDescription(policyAttributeDescriptions: \(String(describing: policyAttributeDescriptions)), policyName: \(String(describing: policyName)), policyTypeName: \(String(describing: policyTypeName)))"}
}

/// <p>Information about a policy.</p>
public struct PolicyDescription: Equatable {
    /// <p>The policy attributes.</p>
    public let policyAttributeDescriptions: [PolicyAttributeDescription]?
    /// <p>The name of the policy.</p>
    public let policyName: String?
    /// <p>The name of the policy type.</p>
    public let policyTypeName: String?

    public init (
        policyAttributeDescriptions: [PolicyAttributeDescription]? = nil,
        policyName: String? = nil,
        policyTypeName: String? = nil
    )
    {
        self.policyAttributeDescriptions = policyAttributeDescriptions
        self.policyName = policyName
        self.policyTypeName = policyTypeName
    }
}

extension PolicyNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyNotFoundException(message: \(String(describing: message)))"}
}

extension PolicyNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<PolicyNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more of the specified policies do not exist.</p>
public struct PolicyNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PolicyNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension PolicyNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PolicyTypeDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case policyAttributeTypeDescriptions = "PolicyAttributeTypeDescriptions"
        case policyTypeName = "PolicyTypeName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let policyAttributeTypeDescriptions = policyAttributeTypeDescriptions {
            var policyAttributeTypeDescriptionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PolicyAttributeTypeDescriptions"))
            for (index0, policyattributetypedescription0) in policyAttributeTypeDescriptions.enumerated() {
                try policyAttributeTypeDescriptionsContainer.encode(policyattributetypedescription0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let policyTypeName = policyTypeName {
            try container.encode(policyTypeName, forKey: Key("PolicyTypeName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyTypeName)
        policyTypeName = policyTypeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        if containerValues.contains(.policyAttributeTypeDescriptions) {
            struct KeyVal0{struct member{}}
            let policyAttributeTypeDescriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyAttributeTypeDescriptions)
            if let policyAttributeTypeDescriptionsWrappedContainer = policyAttributeTypeDescriptionsWrappedContainer {
                let policyAttributeTypeDescriptionsContainer = try policyAttributeTypeDescriptionsWrappedContainer.decodeIfPresent([PolicyAttributeTypeDescription].self, forKey: .member)
                var policyAttributeTypeDescriptionsBuffer:[PolicyAttributeTypeDescription]? = nil
                if let policyAttributeTypeDescriptionsContainer = policyAttributeTypeDescriptionsContainer {
                    policyAttributeTypeDescriptionsBuffer = [PolicyAttributeTypeDescription]()
                    for structureContainer0 in policyAttributeTypeDescriptionsContainer {
                        policyAttributeTypeDescriptionsBuffer?.append(structureContainer0)
                    }
                }
                policyAttributeTypeDescriptions = policyAttributeTypeDescriptionsBuffer
            } else {
                policyAttributeTypeDescriptions = []
            }
        } else {
            policyAttributeTypeDescriptions = nil
        }
    }
}

extension PolicyTypeDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyTypeDescription(description: \(String(describing: description)), policyAttributeTypeDescriptions: \(String(describing: policyAttributeTypeDescriptions)), policyTypeName: \(String(describing: policyTypeName)))"}
}

/// <p>Information about a policy type.</p>
public struct PolicyTypeDescription: Equatable {
    /// <p>A description of the policy type.</p>
    public let description: String?
    /// <p>The description of the policy attributes associated with the policies defined by Elastic Load Balancing.</p>
    public let policyAttributeTypeDescriptions: [PolicyAttributeTypeDescription]?
    /// <p>The name of the policy type.</p>
    public let policyTypeName: String?

    public init (
        description: String? = nil,
        policyAttributeTypeDescriptions: [PolicyAttributeTypeDescription]? = nil,
        policyTypeName: String? = nil
    )
    {
        self.description = description
        self.policyAttributeTypeDescriptions = policyAttributeTypeDescriptions
        self.policyTypeName = policyTypeName
    }
}

extension PolicyTypeNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyTypeNotFoundException(message: \(String(describing: message)))"}
}

extension PolicyTypeNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<PolicyTypeNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more of the specified policy types do not exist.</p>
public struct PolicyTypeNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PolicyTypeNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension PolicyTypeNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct RegisterInstancesWithLoadBalancerInputBodyMiddleware: Middleware {
    public let id: String = "RegisterInstancesWithLoadBalancerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterInstancesWithLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterInstancesWithLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterInstancesWithLoadBalancerInput>
    public typealias MOutput = OperationOutput<RegisterInstancesWithLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterInstancesWithLoadBalancerOutputError>
}

extension RegisterInstancesWithLoadBalancerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterInstancesWithLoadBalancerInput(instances: \(String(describing: instances)), loadBalancerName: \(String(describing: loadBalancerName)))"}
}

extension RegisterInstancesWithLoadBalancerInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let instances = instances {
            var instancesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Instances"))
            for (index0, instance0) in instances.enumerated() {
                try instancesContainer.encode(instance0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        try container.encode("RegisterInstancesWithLoadBalancer", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct RegisterInstancesWithLoadBalancerInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterInstancesWithLoadBalancerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterInstancesWithLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterInstancesWithLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterInstancesWithLoadBalancerInput>
    public typealias MOutput = OperationOutput<RegisterInstancesWithLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterInstancesWithLoadBalancerOutputError>
}

public struct RegisterInstancesWithLoadBalancerInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterInstancesWithLoadBalancerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterInstancesWithLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterInstancesWithLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterInstancesWithLoadBalancerInput>
    public typealias MOutput = OperationOutput<RegisterInstancesWithLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterInstancesWithLoadBalancerOutputError>
}

/// <p>Contains the parameters for RegisterInstancesWithLoadBalancer.</p>
public struct RegisterInstancesWithLoadBalancerInput: Equatable {
    /// <p>The IDs of the instances.</p>
    public let instances: [Instance]?
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?

    public init (
        instances: [Instance]? = nil,
        loadBalancerName: String? = nil
    )
    {
        self.instances = instances
        self.loadBalancerName = loadBalancerName
    }
}

extension RegisterInstancesWithLoadBalancerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RegisterInstancesWithLoadBalancerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndPointException" : self = .invalidEndPointException(try InvalidEndPointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterInstancesWithLoadBalancerOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case invalidEndPointException(InvalidEndPointException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterInstancesWithLoadBalancerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterInstancesWithLoadBalancerOutputResponse(instances: \(String(describing: instances)))"}
}

extension RegisterInstancesWithLoadBalancerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterInstancesWithLoadBalancerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instances = output.instances
        } else {
            self.instances = nil
        }
    }
}

/// <p>Contains the output of RegisterInstancesWithLoadBalancer.</p>
public struct RegisterInstancesWithLoadBalancerOutputResponse: Equatable {
    /// <p>The updated list of instances for the load balancer.</p>
    public let instances: [Instance]?

    public init (
        instances: [Instance]? = nil
    )
    {
        self.instances = instances
    }
}

struct RegisterInstancesWithLoadBalancerOutputResponseBody: Equatable {
    public let instances: [Instance]?
}

extension RegisterInstancesWithLoadBalancerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instances = "Instances"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RegisterInstancesWithLoadBalancerResult"))
        if containerValues.contains(.instances) {
            struct KeyVal0{struct member{}}
            let instancesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instances)
            if let instancesWrappedContainer = instancesWrappedContainer {
                let instancesContainer = try instancesWrappedContainer.decodeIfPresent([Instance].self, forKey: .member)
                var instancesBuffer:[Instance]? = nil
                if let instancesContainer = instancesContainer {
                    instancesBuffer = [Instance]()
                    for structureContainer0 in instancesContainer {
                        instancesBuffer?.append(structureContainer0)
                    }
                }
                instances = instancesBuffer
            } else {
                instances = []
            }
        } else {
            instances = nil
        }
    }
}

public struct RemoveTagsInputBodyMiddleware: Middleware {
    public let id: String = "RemoveTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsInput>
    public typealias MOutput = OperationOutput<RemoveTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsOutputError>
}

extension RemoveTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsInput(loadBalancerNames: \(String(describing: loadBalancerNames)), tags: \(String(describing: tags)))"}
}

extension RemoveTagsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancerNames = loadBalancerNames {
            var loadBalancerNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("LoadBalancerNames"))
            for (index0, accesspointname0) in loadBalancerNames.enumerated() {
                try loadBalancerNamesContainer.encode(accesspointname0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tagkeyonly0) in tags.enumerated() {
                try tagsContainer.encode(tagkeyonly0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RemoveTags", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct RemoveTagsInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsInput>
    public typealias MOutput = OperationOutput<RemoveTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsOutputError>
}

public struct RemoveTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsInput>
    public typealias MOutput = OperationOutput<RemoveTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsOutputError>
}

/// <p>Contains the parameters for RemoveTags.</p>
public struct RemoveTagsInput: Equatable {
    /// <p>The name of the load balancer. You can specify a maximum of one load balancer name.</p>
    public let loadBalancerNames: [String]?
    /// <p>The list of tag keys to remove.</p>
    public let tags: [TagKeyOnly]?

    public init (
        loadBalancerNames: [String]? = nil,
        tags: [TagKeyOnly]? = nil
    )
    {
        self.loadBalancerNames = loadBalancerNames
        self.tags = tags
    }
}

extension RemoveTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsOutputResponse()"}
}

extension RemoveTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Contains the output of RemoveTags.</p>
public struct RemoveTagsOutputResponse: Equatable {

    public init() {}
}

struct RemoveTagsOutputResponseBody: Equatable {
}

extension RemoveTagsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetLoadBalancerListenerSSLCertificateInputBodyMiddleware: Middleware {
    public let id: String = "SetLoadBalancerListenerSSLCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetLoadBalancerListenerSSLCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<SetLoadBalancerListenerSSLCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetLoadBalancerListenerSSLCertificateInput>
    public typealias MOutput = OperationOutput<SetLoadBalancerListenerSSLCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetLoadBalancerListenerSSLCertificateOutputError>
}

extension SetLoadBalancerListenerSSLCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetLoadBalancerListenerSSLCertificateInput(loadBalancerName: \(String(describing: loadBalancerName)), loadBalancerPort: \(String(describing: loadBalancerPort)), sSLCertificateId: \(String(describing: sSLCertificateId)))"}
}

extension SetLoadBalancerListenerSSLCertificateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        if loadBalancerPort != 0 {
            try container.encode(loadBalancerPort, forKey: Key("LoadBalancerPort"))
        }
        if let sSLCertificateId = sSLCertificateId {
            try container.encode(sSLCertificateId, forKey: Key("SSLCertificateId"))
        }
        try container.encode("SetLoadBalancerListenerSSLCertificate", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct SetLoadBalancerListenerSSLCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "SetLoadBalancerListenerSSLCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetLoadBalancerListenerSSLCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<SetLoadBalancerListenerSSLCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetLoadBalancerListenerSSLCertificateInput>
    public typealias MOutput = OperationOutput<SetLoadBalancerListenerSSLCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetLoadBalancerListenerSSLCertificateOutputError>
}

public struct SetLoadBalancerListenerSSLCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "SetLoadBalancerListenerSSLCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetLoadBalancerListenerSSLCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<SetLoadBalancerListenerSSLCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetLoadBalancerListenerSSLCertificateInput>
    public typealias MOutput = OperationOutput<SetLoadBalancerListenerSSLCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetLoadBalancerListenerSSLCertificateOutputError>
}

/// <p>Contains the parameters for SetLoadBalancerListenerSSLCertificate.</p>
public struct SetLoadBalancerListenerSSLCertificateInput: Equatable {
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?
    /// <p>The port that uses the specified SSL certificate.</p>
    public let loadBalancerPort: Int
    /// <p>The Amazon Resource Name (ARN) of the SSL certificate.</p>
    public let sSLCertificateId: String?

    public init (
        loadBalancerName: String? = nil,
        loadBalancerPort: Int = 0,
        sSLCertificateId: String? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.loadBalancerPort = loadBalancerPort
        self.sSLCertificateId = sSLCertificateId
    }
}

extension SetLoadBalancerListenerSSLCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetLoadBalancerListenerSSLCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CertificateNotFoundException" : self = .certificateNotFoundException(try CertificateNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedProtocolException" : self = .unsupportedProtocolException(try UnsupportedProtocolException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetLoadBalancerListenerSSLCertificateOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case certificateNotFoundException(CertificateNotFoundException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unsupportedProtocolException(UnsupportedProtocolException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetLoadBalancerListenerSSLCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetLoadBalancerListenerSSLCertificateOutputResponse()"}
}

extension SetLoadBalancerListenerSSLCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Contains the output of SetLoadBalancerListenerSSLCertificate.</p>
public struct SetLoadBalancerListenerSSLCertificateOutputResponse: Equatable {

    public init() {}
}

struct SetLoadBalancerListenerSSLCertificateOutputResponseBody: Equatable {
}

extension SetLoadBalancerListenerSSLCertificateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetLoadBalancerPoliciesForBackendServerInputBodyMiddleware: Middleware {
    public let id: String = "SetLoadBalancerPoliciesForBackendServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetLoadBalancerPoliciesForBackendServerInput>,
                  next: H) -> Swift.Result<OperationOutput<SetLoadBalancerPoliciesForBackendServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetLoadBalancerPoliciesForBackendServerInput>
    public typealias MOutput = OperationOutput<SetLoadBalancerPoliciesForBackendServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetLoadBalancerPoliciesForBackendServerOutputError>
}

extension SetLoadBalancerPoliciesForBackendServerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetLoadBalancerPoliciesForBackendServerInput(instancePort: \(String(describing: instancePort)), loadBalancerName: \(String(describing: loadBalancerName)), policyNames: \(String(describing: policyNames)))"}
}

extension SetLoadBalancerPoliciesForBackendServerInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let instancePort = instancePort {
            try container.encode(instancePort, forKey: Key("InstancePort"))
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        if let policyNames = policyNames {
            var policyNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PolicyNames"))
            for (index0, policyname0) in policyNames.enumerated() {
                try policyNamesContainer.encode(policyname0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("SetLoadBalancerPoliciesForBackendServer", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct SetLoadBalancerPoliciesForBackendServerInputHeadersMiddleware: Middleware {
    public let id: String = "SetLoadBalancerPoliciesForBackendServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetLoadBalancerPoliciesForBackendServerInput>,
                  next: H) -> Swift.Result<OperationOutput<SetLoadBalancerPoliciesForBackendServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetLoadBalancerPoliciesForBackendServerInput>
    public typealias MOutput = OperationOutput<SetLoadBalancerPoliciesForBackendServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetLoadBalancerPoliciesForBackendServerOutputError>
}

public struct SetLoadBalancerPoliciesForBackendServerInputQueryItemMiddleware: Middleware {
    public let id: String = "SetLoadBalancerPoliciesForBackendServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetLoadBalancerPoliciesForBackendServerInput>,
                  next: H) -> Swift.Result<OperationOutput<SetLoadBalancerPoliciesForBackendServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetLoadBalancerPoliciesForBackendServerInput>
    public typealias MOutput = OperationOutput<SetLoadBalancerPoliciesForBackendServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetLoadBalancerPoliciesForBackendServerOutputError>
}

/// <p>Contains the parameters for SetLoadBalancerPoliciesForBackendServer.</p>
public struct SetLoadBalancerPoliciesForBackendServerInput: Equatable {
    /// <p>The port number associated with the EC2 instance.</p>
    public let instancePort: Int?
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?
    /// <p>The names of the policies. If the list is empty, then all current polices are removed from the EC2 instance.</p>
    public let policyNames: [String]?

    public init (
        instancePort: Int? = nil,
        loadBalancerName: String? = nil,
        policyNames: [String]? = nil
    )
    {
        self.instancePort = instancePort
        self.loadBalancerName = loadBalancerName
        self.policyNames = policyNames
    }
}

extension SetLoadBalancerPoliciesForBackendServerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetLoadBalancerPoliciesForBackendServerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotFoundException" : self = .policyNotFoundException(try PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetLoadBalancerPoliciesForBackendServerOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case policyNotFoundException(PolicyNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetLoadBalancerPoliciesForBackendServerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetLoadBalancerPoliciesForBackendServerOutputResponse()"}
}

extension SetLoadBalancerPoliciesForBackendServerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Contains the output of SetLoadBalancerPoliciesForBackendServer.</p>
public struct SetLoadBalancerPoliciesForBackendServerOutputResponse: Equatable {

    public init() {}
}

struct SetLoadBalancerPoliciesForBackendServerOutputResponseBody: Equatable {
}

extension SetLoadBalancerPoliciesForBackendServerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetLoadBalancerPoliciesOfListenerInputBodyMiddleware: Middleware {
    public let id: String = "SetLoadBalancerPoliciesOfListenerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetLoadBalancerPoliciesOfListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<SetLoadBalancerPoliciesOfListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetLoadBalancerPoliciesOfListenerInput>
    public typealias MOutput = OperationOutput<SetLoadBalancerPoliciesOfListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetLoadBalancerPoliciesOfListenerOutputError>
}

extension SetLoadBalancerPoliciesOfListenerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetLoadBalancerPoliciesOfListenerInput(loadBalancerName: \(String(describing: loadBalancerName)), loadBalancerPort: \(String(describing: loadBalancerPort)), policyNames: \(String(describing: policyNames)))"}
}

extension SetLoadBalancerPoliciesOfListenerInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        if loadBalancerPort != 0 {
            try container.encode(loadBalancerPort, forKey: Key("LoadBalancerPort"))
        }
        if let policyNames = policyNames {
            var policyNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PolicyNames"))
            for (index0, policyname0) in policyNames.enumerated() {
                try policyNamesContainer.encode(policyname0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("SetLoadBalancerPoliciesOfListener", forKey:Key("Action"))
        try container.encode("2012-06-01", forKey:Key("Version"))
    }
}

public struct SetLoadBalancerPoliciesOfListenerInputHeadersMiddleware: Middleware {
    public let id: String = "SetLoadBalancerPoliciesOfListenerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetLoadBalancerPoliciesOfListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<SetLoadBalancerPoliciesOfListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetLoadBalancerPoliciesOfListenerInput>
    public typealias MOutput = OperationOutput<SetLoadBalancerPoliciesOfListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetLoadBalancerPoliciesOfListenerOutputError>
}

public struct SetLoadBalancerPoliciesOfListenerInputQueryItemMiddleware: Middleware {
    public let id: String = "SetLoadBalancerPoliciesOfListenerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetLoadBalancerPoliciesOfListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<SetLoadBalancerPoliciesOfListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetLoadBalancerPoliciesOfListenerInput>
    public typealias MOutput = OperationOutput<SetLoadBalancerPoliciesOfListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetLoadBalancerPoliciesOfListenerOutputError>
}

/// <p>Contains the parameters for SetLoadBalancePoliciesOfListener.</p>
public struct SetLoadBalancerPoliciesOfListenerInput: Equatable {
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?
    /// <p>The external port of the load balancer.</p>
    public let loadBalancerPort: Int
    /// <p>The names of the policies. This list must include all policies to be enabled. If you omit a policy that is currently enabled, it is disabled. If the list is empty, all current policies are disabled.</p>
    public let policyNames: [String]?

    public init (
        loadBalancerName: String? = nil,
        loadBalancerPort: Int = 0,
        policyNames: [String]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.loadBalancerPort = loadBalancerPort
        self.policyNames = policyNames
    }
}

extension SetLoadBalancerPoliciesOfListenerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetLoadBalancerPoliciesOfListenerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFoundException" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotFoundException" : self = .policyNotFoundException(try PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetLoadBalancerPoliciesOfListenerOutputError: Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case listenerNotFoundException(ListenerNotFoundException)
    case policyNotFoundException(PolicyNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetLoadBalancerPoliciesOfListenerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetLoadBalancerPoliciesOfListenerOutputResponse()"}
}

extension SetLoadBalancerPoliciesOfListenerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Contains the output of SetLoadBalancePoliciesOfListener.</p>
public struct SetLoadBalancerPoliciesOfListenerOutputResponse: Equatable {

    public init() {}
}

struct SetLoadBalancerPoliciesOfListenerOutputResponseBody: Equatable {
}

extension SetLoadBalancerPoliciesOfListenerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension SourceSecurityGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupName = "GroupName"
        case ownerAlias = "OwnerAlias"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: Key("GroupName"))
        }
        if let ownerAlias = ownerAlias {
            try container.encode(ownerAlias, forKey: Key("OwnerAlias"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAlias)
        ownerAlias = ownerAliasDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
    }
}

extension SourceSecurityGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceSecurityGroup(groupName: \(String(describing: groupName)), ownerAlias: \(String(describing: ownerAlias)))"}
}

/// <p>Information about a source security group.</p>
public struct SourceSecurityGroup: Equatable {
    /// <p>The name of the security group.</p>
    public let groupName: String?
    /// <p>The owner of the security group.</p>
    public let ownerAlias: String?

    public init (
        groupName: String? = nil,
        ownerAlias: String? = nil
    )
    {
        self.groupName = groupName
        self.ownerAlias = ownerAlias
    }
}

extension SubnetNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubnetNotFoundException(message: \(String(describing: message)))"}
}

extension SubnetNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SubnetNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more of the specified subnets do not exist.</p>
public struct SubnetNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension SubnetNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let key = key {
            try container.encode(key, forKey: Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("Value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Information about a tag.</p>
public struct Tag: Equatable {
    /// <p>The key of the tag.</p>
    public let key: String?
    /// <p>The value of the tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TagDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case loadBalancerName = "LoadBalancerName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension TagDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagDescription(loadBalancerName: \(String(describing: loadBalancerName)), tags: \(String(describing: tags)))"}
}

/// <p>The tags associated with a load balancer.</p>
public struct TagDescription: Equatable {
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?
    /// <p>The tags.</p>
    public let tags: [Tag]?

    public init (
        loadBalancerName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.tags = tags
    }
}

extension TagKeyOnly: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let key = key {
            try container.encode(key, forKey: Key("Key"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
    }
}

extension TagKeyOnly: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagKeyOnly(key: \(String(describing: key)))"}
}

/// <p>The key of a tag.</p>
public struct TagKeyOnly: Equatable {
    /// <p>The name of the key.</p>
    public let key: String?

    public init (
        key: String? = nil
    )
    {
        self.key = key
    }
}

extension TooManyAccessPointsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyAccessPointsException(message: \(String(describing: message)))"}
}

extension TooManyAccessPointsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyAccessPointsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The quota for the number of load balancers has been reached.</p>
public struct TooManyAccessPointsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyAccessPointsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyAccessPointsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyPoliciesException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyPoliciesException(message: \(String(describing: message)))"}
}

extension TooManyPoliciesException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyPoliciesExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The quota for the number of policies for this load balancer has been reached.</p>
public struct TooManyPoliciesException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyPoliciesExceptionBody: Equatable {
    public let message: String?
}

extension TooManyPoliciesExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsException(message: \(String(describing: message)))"}
}

extension TooManyTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyTagsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The quota for the number of tags that can be assigned to a load balancer has been reached.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedProtocolException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedProtocolException(message: \(String(describing: message)))"}
}

extension UnsupportedProtocolException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<UnsupportedProtocolExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified protocol or signature version is not supported.</p>
public struct UnsupportedProtocolException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedProtocolExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedProtocolExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
