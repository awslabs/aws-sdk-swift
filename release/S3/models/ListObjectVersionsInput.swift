// Code generated by smithy-swift-codegen. DO NOT EDIT!



public struct ListObjectVersionsInput: Equatable {
    /// <p>The bucket name that contains the objects. </p>
    public let bucket: String?
    /// <p>A delimiter is a character that you specify to group keys. All keys that contain the
    ///          same string between the <code>prefix</code> and the first occurrence of the delimiter are
    ///          grouped under a single result element in CommonPrefixes. These groups are counted as one
    ///          result against the max-keys limitation. These keys are not returned elsewhere in the
    ///          response.</p>
    public let delimiter: String?
    /// <p>Requests Amazon S3 to encode the object keys in the response and specifies the encoding
    ///          method to use. An object key may contain any Unicode character; however, XML 1.0 parser
    ///          cannot parse some characters, such as characters with an ASCII value from 0 to 10. For
    ///          characters that are not supported in XML 1.0, you can add this parameter to request that
    ///          Amazon S3 encode the keys in the response.</p>
    public let encodingType: EncodingType?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>Specifies the key to start with when listing objects in a bucket.</p>
    public let keyMarker: String?
    /// <p>Sets the maximum number of keys returned in the response. By default the action returns up
    ///          to 1,000 key names. The response might contain fewer keys but will never contain more. If
    ///          additional keys satisfy the search criteria, but were not returned because max-keys was
    ///          exceeded, the response contains <isTruncated>true</isTruncated>. To return the
    ///          additional keys, see key-marker and version-id-marker.</p>
    public let maxKeys: Int
    /// <p>Use this parameter to select only those keys that begin with the specified prefix. You
    ///          can use prefixes to separate a bucket into different groupings of keys. (You can think of
    ///          using prefix to make groups in the same way you'd use a folder in a file system.) You can
    ///          use prefix with delimiter to roll up numerous objects into a single result under
    ///          CommonPrefixes. </p>
    public let prefix: String?
    /// <p>Specifies the object version you want to start listing from.</p>
    public let versionIdMarker: String?

    public init (
        bucket: String? = nil,
        delimiter: String? = nil,
        encodingType: EncodingType? = nil,
        expectedBucketOwner: String? = nil,
        keyMarker: String? = nil,
        maxKeys: Int = 0,
        prefix: String? = nil,
        versionIdMarker: String? = nil
    )
    {
        self.bucket = bucket
        self.delimiter = delimiter
        self.encodingType = encodingType
        self.expectedBucketOwner = expectedBucketOwner
        self.keyMarker = keyMarker
        self.maxKeys = maxKeys
        self.prefix = prefix
        self.versionIdMarker = versionIdMarker
    }
}

extension ListObjectVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListObjectVersionsInput(bucket: \(String(describing: bucket)), delimiter: \(String(describing: delimiter)), encodingType: \(String(describing: encodingType)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), keyMarker: \(String(describing: keyMarker)), maxKeys: \(String(describing: maxKeys)), prefix: \(String(describing: prefix)), versionIdMarker: \(String(describing: versionIdMarker)))"}
}
