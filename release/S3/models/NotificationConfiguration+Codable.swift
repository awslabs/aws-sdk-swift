// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension NotificationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lambdaFunctionConfigurations = "CloudFunctionConfiguration"
        case queueConfigurations = "QueueConfiguration"
        case topicConfigurations = "TopicConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let lambdaFunctionConfigurations = lambdaFunctionConfigurations {
            if lambdaFunctionConfigurations.isEmpty {
                var lambdaFunctionConfigurationsContainer = container.nestedUnkeyedContainer(forKey: Key("CloudFunctionConfiguration"))
                try lambdaFunctionConfigurationsContainer.encodeNil()
            } else {
                for lambdafunctionconfiguration0 in lambdaFunctionConfigurations {
                    var lambdaFunctionConfigurationsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("CloudFunctionConfiguration"))
                    try lambdaFunctionConfigurationsContainer0.encode(lambdafunctionconfiguration0, forKey: Key(""))
                }
            }
        }
        if let queueConfigurations = queueConfigurations {
            if queueConfigurations.isEmpty {
                var queueConfigurationsContainer = container.nestedUnkeyedContainer(forKey: Key("QueueConfiguration"))
                try queueConfigurationsContainer.encodeNil()
            } else {
                for queueconfiguration0 in queueConfigurations {
                    var queueConfigurationsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("QueueConfiguration"))
                    try queueConfigurationsContainer0.encode(queueconfiguration0, forKey: Key(""))
                }
            }
        }
        if let topicConfigurations = topicConfigurations {
            if topicConfigurations.isEmpty {
                var topicConfigurationsContainer = container.nestedUnkeyedContainer(forKey: Key("TopicConfiguration"))
                try topicConfigurationsContainer.encodeNil()
            } else {
                for topicconfiguration0 in topicConfigurations {
                    var topicConfigurationsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("TopicConfiguration"))
                    try topicConfigurationsContainer0.encode(topicconfiguration0, forKey: Key(""))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.topicConfigurations) {
            let topicConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .topicConfigurations)
            if topicConfigurationsWrappedContainer != nil {
                let topicConfigurationsContainer = try containerValues.decodeIfPresent([TopicConfiguration].self, forKey: .topicConfigurations)
                var topicConfigurationsBuffer:[TopicConfiguration]? = nil
                if let topicConfigurationsContainer = topicConfigurationsContainer {
                    topicConfigurationsBuffer = [TopicConfiguration]()
                    for structureContainer0 in topicConfigurationsContainer {
                        topicConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                topicConfigurations = topicConfigurationsBuffer
            } else {
                topicConfigurations = []
            }
        } else {
            topicConfigurations = nil
        }
        if containerValues.contains(.queueConfigurations) {
            let queueConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .queueConfigurations)
            if queueConfigurationsWrappedContainer != nil {
                let queueConfigurationsContainer = try containerValues.decodeIfPresent([QueueConfiguration].self, forKey: .queueConfigurations)
                var queueConfigurationsBuffer:[QueueConfiguration]? = nil
                if let queueConfigurationsContainer = queueConfigurationsContainer {
                    queueConfigurationsBuffer = [QueueConfiguration]()
                    for structureContainer0 in queueConfigurationsContainer {
                        queueConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                queueConfigurations = queueConfigurationsBuffer
            } else {
                queueConfigurations = []
            }
        } else {
            queueConfigurations = nil
        }
        if containerValues.contains(.lambdaFunctionConfigurations) {
            let lambdaFunctionConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .lambdaFunctionConfigurations)
            if lambdaFunctionConfigurationsWrappedContainer != nil {
                let lambdaFunctionConfigurationsContainer = try containerValues.decodeIfPresent([LambdaFunctionConfiguration].self, forKey: .lambdaFunctionConfigurations)
                var lambdaFunctionConfigurationsBuffer:[LambdaFunctionConfiguration]? = nil
                if let lambdaFunctionConfigurationsContainer = lambdaFunctionConfigurationsContainer {
                    lambdaFunctionConfigurationsBuffer = [LambdaFunctionConfiguration]()
                    for structureContainer0 in lambdaFunctionConfigurationsContainer {
                        lambdaFunctionConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                lambdaFunctionConfigurations = lambdaFunctionConfigurationsBuffer
            } else {
                lambdaFunctionConfigurations = []
            }
        } else {
            lambdaFunctionConfigurations = nil
        }
    }
}
