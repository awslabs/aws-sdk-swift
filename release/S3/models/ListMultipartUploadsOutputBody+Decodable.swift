// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct ListMultipartUploadsOutputBody: Equatable {
    public let bucket: String?
    public let keyMarker: String?
    public let uploadIdMarker: String?
    public let nextKeyMarker: String?
    public let prefix: String?
    public let delimiter: String?
    public let nextUploadIdMarker: String?
    public let maxUploads: Int
    public let isTruncated: Bool
    public let uploads: [MultipartUpload]?
    public let commonPrefixes: [CommonPrefix]?
    public let encodingType: EncodingType?
}

extension ListMultipartUploadsOutputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case commonPrefixes = "CommonPrefixes"
        case delimiter = "Delimiter"
        case encodingType = "EncodingType"
        case isTruncated = "IsTruncated"
        case keyMarker = "KeyMarker"
        case maxUploads = "MaxUploads"
        case nextKeyMarker = "NextKeyMarker"
        case nextUploadIdMarker = "NextUploadIdMarker"
        case prefix = "Prefix"
        case uploadIdMarker = "UploadIdMarker"
        case uploads = "Upload"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyMarker)
        keyMarker = keyMarkerDecoded
        let uploadIdMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadIdMarker)
        uploadIdMarker = uploadIdMarkerDecoded
        let nextKeyMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextKeyMarker)
        nextKeyMarker = nextKeyMarkerDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let nextUploadIdMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextUploadIdMarker)
        nextUploadIdMarker = nextUploadIdMarkerDecoded
        let maxUploadsDecoded = try containerValues.decode(Int.self, forKey: .maxUploads)
        maxUploads = maxUploadsDecoded
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        if containerValues.contains(.uploads) {
            let uploadsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .uploads)
            if uploadsWrappedContainer != nil {
                let uploadsContainer = try containerValues.decodeIfPresent([MultipartUpload].self, forKey: .uploads)
                var uploadsBuffer:[MultipartUpload]? = nil
                if let uploadsContainer = uploadsContainer {
                    uploadsBuffer = [MultipartUpload]()
                    for structureContainer0 in uploadsContainer {
                        uploadsBuffer?.append(structureContainer0)
                    }
                }
                uploads = uploadsBuffer
            } else {
                uploads = []
            }
        } else {
            uploads = nil
        }
        if containerValues.contains(.commonPrefixes) {
            let commonPrefixesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .commonPrefixes)
            if commonPrefixesWrappedContainer != nil {
                let commonPrefixesContainer = try containerValues.decodeIfPresent([CommonPrefix].self, forKey: .commonPrefixes)
                var commonPrefixesBuffer:[CommonPrefix]? = nil
                if let commonPrefixesContainer = commonPrefixesContainer {
                    commonPrefixesBuffer = [CommonPrefix]()
                    for structureContainer0 in commonPrefixesContainer {
                        commonPrefixesBuffer?.append(structureContainer0)
                    }
                }
                commonPrefixes = commonPrefixesBuffer
            } else {
                commonPrefixes = []
            }
        } else {
            commonPrefixes = nil
        }
        let encodingTypeDecoded = try containerValues.decodeIfPresent(EncodingType.self, forKey: .encodingType)
        encodingType = encodingTypeDecoded
    }
}
