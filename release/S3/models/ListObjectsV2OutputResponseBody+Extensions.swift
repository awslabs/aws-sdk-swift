// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct ListObjectsV2OutputResponseBody: Equatable {
    public let isTruncated: Bool
    public let contents: [Object]?
    public let name: String?
    public let prefix: String?
    public let delimiter: String?
    public let maxKeys: Int
    public let commonPrefixes: [CommonPrefix]?
    public let encodingType: EncodingType?
    public let keyCount: Int
    public let continuationToken: String?
    public let nextContinuationToken: String?
    public let startAfter: String?
}

extension ListObjectsV2OutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commonPrefixes = "CommonPrefixes"
        case contents = "Contents"
        case continuationToken = "ContinuationToken"
        case delimiter = "Delimiter"
        case encodingType = "EncodingType"
        case isTruncated = "IsTruncated"
        case keyCount = "KeyCount"
        case maxKeys = "MaxKeys"
        case name = "Name"
        case nextContinuationToken = "NextContinuationToken"
        case prefix = "Prefix"
        case startAfter = "StartAfter"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        if containerValues.contains(.contents) {
            let contentsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .contents)
            if contentsWrappedContainer != nil {
                let contentsContainer = try containerValues.decodeIfPresent([Object].self, forKey: .contents)
                var contentsBuffer:[Object]? = nil
                if let contentsContainer = contentsContainer {
                    contentsBuffer = [Object]()
                    for structureContainer0 in contentsContainer {
                        contentsBuffer?.append(structureContainer0)
                    }
                }
                contents = contentsBuffer
            } else {
                contents = []
            }
        } else {
            contents = nil
        }
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let maxKeysDecoded = try containerValues.decode(Int.self, forKey: .maxKeys)
        maxKeys = maxKeysDecoded
        if containerValues.contains(.commonPrefixes) {
            let commonPrefixesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .commonPrefixes)
            if commonPrefixesWrappedContainer != nil {
                let commonPrefixesContainer = try containerValues.decodeIfPresent([CommonPrefix].self, forKey: .commonPrefixes)
                var commonPrefixesBuffer:[CommonPrefix]? = nil
                if let commonPrefixesContainer = commonPrefixesContainer {
                    commonPrefixesBuffer = [CommonPrefix]()
                    for structureContainer0 in commonPrefixesContainer {
                        commonPrefixesBuffer?.append(structureContainer0)
                    }
                }
                commonPrefixes = commonPrefixesBuffer
            } else {
                commonPrefixes = []
            }
        } else {
            commonPrefixes = nil
        }
        let encodingTypeDecoded = try containerValues.decodeIfPresent(EncodingType.self, forKey: .encodingType)
        encodingType = encodingTypeDecoded
        let keyCountDecoded = try containerValues.decode(Int.self, forKey: .keyCount)
        keyCount = keyCountDecoded
        let continuationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .continuationToken)
        continuationToken = continuationTokenDecoded
        let nextContinuationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextContinuationToken)
        nextContinuationToken = nextContinuationTokenDecoded
        let startAfterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startAfter)
        startAfter = startAfterDecoded
    }
}
