// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AbortIncompleteMultipartUpload: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case daysAfterInitiation = "DaysAfterInitiation"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if daysAfterInitiation != 0 {
            try container.encode(daysAfterInitiation, forKey: Key("daysAfterInitiation"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let daysAfterInitiationDecoded = try containerValues.decode(Int.self, forKey: .daysAfterInitiation)
        daysAfterInitiation = daysAfterInitiationDecoded
    }
}

extension AbortIncompleteMultipartUpload: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AbortIncompleteMultipartUpload(daysAfterInitiation: \(String(describing: daysAfterInitiation)))"}
}

extension AbortIncompleteMultipartUpload: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will
///          wait before permanently removing all parts of the upload. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config">
///             Aborting Incomplete Multipart Uploads Using a Bucket Lifecycle Policy</a> in the
///             <i>Amazon S3 User Guide</i>.</p>
public struct AbortIncompleteMultipartUpload: Equatable {
    /// <p>Specifies the number of days after which Amazon S3 aborts an incomplete multipart
    ///          upload.</p>
    public let daysAfterInitiation: Int

    public init (
        daysAfterInitiation: Int = 0
    )
    {
        self.daysAfterInitiation = daysAfterInitiation
    }
}

extension AbortMultipartUploadInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AbortMultipartUploadInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), key: \(String(describing: key)), requestPayer: \(String(describing: requestPayer)), uploadId: \(String(describing: uploadId)))"}
}

extension AbortMultipartUploadInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct AbortMultipartUploadInputHeadersMiddleware: Middleware {
    public let id: String = "AbortMultipartUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AbortMultipartUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<AbortMultipartUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AbortMultipartUploadInput>
    public typealias MOutput = OperationOutput<AbortMultipartUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AbortMultipartUploadOutputError>
}

public struct AbortMultipartUploadInputQueryItemMiddleware: Middleware {
    public let id: String = "AbortMultipartUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AbortMultipartUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<AbortMultipartUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "x-id", value: "AbortMultipartUpload"))
        if let uploadId = input.operationInput.uploadId {
            let uploadIdQueryItem = URLQueryItem(name: "uploadId".urlPercentEncoding(), value: String(uploadId).urlPercentEncoding())
            input.builder.withQueryItem(uploadIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AbortMultipartUploadInput>
    public typealias MOutput = OperationOutput<AbortMultipartUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AbortMultipartUploadOutputError>
}

public struct AbortMultipartUploadInput: Equatable {
    /// <p>The bucket name to which the upload was taking place. </p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>Key of the object for which the multipart upload was initiated.</p>
    public let key: String?
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    ///          owners need not specify this parameter in their requests. For information about downloading
    ///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    ///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let requestPayer: RequestPayer?
    /// <p>Upload ID that identifies the multipart upload.</p>
    public let uploadId: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        key: String? = nil,
        requestPayer: RequestPayer? = nil,
        uploadId: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.requestPayer = requestPayer
        self.uploadId = uploadId
    }
}

struct AbortMultipartUploadInputBody: Equatable {
}

extension AbortMultipartUploadInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AbortMultipartUploadOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AbortMultipartUploadOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchUpload" : self = .noSuchUpload(try NoSuchUpload(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AbortMultipartUploadOutputError: Equatable {
    case noSuchUpload(NoSuchUpload)
    case unknown(UnknownAWSHttpServiceError)
}

extension AbortMultipartUploadOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AbortMultipartUploadOutputResponse(requestCharged: \(String(describing: requestCharged)))"}
}

extension AbortMultipartUploadOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
    }
}

public struct AbortMultipartUploadOutputResponse: Equatable {
    /// <p>If present, indicates that the requester was successfully charged for the
    ///          request.</p>
    public let requestCharged: RequestCharged?

    public init (
        requestCharged: RequestCharged? = nil
    )
    {
        self.requestCharged = requestCharged
    }
}

struct AbortMultipartUploadOutputResponseBody: Equatable {
}

extension AbortMultipartUploadOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AccelerateConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(BucketAccelerateStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AccelerateConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccelerateConfiguration(status: \(String(describing: status)))"}
}

extension AccelerateConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Configures the transfer acceleration state for an Amazon S3 bucket. For more information, see
///             <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/transfer-acceleration.html">Amazon S3
///             Transfer Acceleration</a> in the <i>Amazon S3 User Guide</i>.</p>
public struct AccelerateConfiguration: Equatable {
    /// <p>Specifies the transfer acceleration status of the bucket.</p>
    public let status: BucketAccelerateStatus?

    public init (
        status: BucketAccelerateStatus? = nil
    )
    {
        self.status = status
    }
}

extension AccessControlPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grants = "AccessControlList"
        case owner = "Owner"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let grants = grants {
            var grantsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AccessControlList"))
            for grant0 in grants {
                try grantsContainer.encode(grant0, forKey: Key("Grant"))
            }
        }
        if let owner = owner {
            try container.encode(owner, forKey: Key("owner"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.grants) {
            struct KeyVal0{struct Grant{}}
            let grantsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Grant>.CodingKeys.self, forKey: .grants)
            if let grantsWrappedContainer = grantsWrappedContainer {
                let grantsContainer = try grantsWrappedContainer.decodeIfPresent([Grant].self, forKey: .member)
                var grantsBuffer:[Grant]? = nil
                if let grantsContainer = grantsContainer {
                    grantsBuffer = [Grant]()
                    for structureContainer0 in grantsContainer {
                        grantsBuffer?.append(structureContainer0)
                    }
                }
                grants = grantsBuffer
            } else {
                grants = []
            }
        } else {
            grants = nil
        }
        let ownerDecoded = try containerValues.decodeIfPresent(Owner.self, forKey: .owner)
        owner = ownerDecoded
    }
}

extension AccessControlPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessControlPolicy(grants: \(String(describing: grants)), owner: \(String(describing: owner)))"}
}

extension AccessControlPolicy: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains the elements that set the ACL permissions for an object per grantee.</p>
public struct AccessControlPolicy: Equatable {
    /// <p>A list of grants.</p>
    public let grants: [Grant]?
    /// <p>Container for the bucket owner's display name and ID.</p>
    public let owner: Owner?

    public init (
        grants: [Grant]? = nil,
        owner: Owner? = nil
    )
    {
        self.grants = grants
        self.owner = owner
    }
}

extension AccessControlTranslation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case owner = "Owner"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let owner = owner {
            try container.encode(owner, forKey: Key("owner"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(OwnerOverride.self, forKey: .owner)
        owner = ownerDecoded
    }
}

extension AccessControlTranslation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessControlTranslation(owner: \(String(describing: owner)))"}
}

extension AccessControlTranslation: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container for information about access control for replicas.</p>
public struct AccessControlTranslation: Equatable {
    /// <p>Specifies the replica ownership. For default and valid values, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html">PUT bucket
    ///             replication</a> in the <i>Amazon S3 API Reference</i>.</p>
    public let owner: OwnerOverride?

    public init (
        owner: OwnerOverride? = nil
    )
    {
        self.owner = owner
    }
}

extension AnalyticsAndOperator: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case prefix = "Prefix"
        case tags = "Tag"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let prefix = prefix {
            try container.encode(prefix, forKey: Key("prefix"))
        }
        if let tags = tags {
            if tags.isEmpty {
                var tagsContainer = container.nestedUnkeyedContainer(forKey: Key("Tag"))
                try tagsContainer.encodeNil()
            } else {
                for tag0 in tags {
                    var tagsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tag"))
                    try tagsContainer0.encode(tag0, forKey: Key(""))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        if containerValues.contains(.tags) {
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .tags)
            if tagsWrappedContainer != nil {
                let tagsContainer = try containerValues.decodeIfPresent([Tag].self, forKey: .tags)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension AnalyticsAndOperator: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnalyticsAndOperator(prefix: \(String(describing: prefix)), tags: \(String(describing: tags)))"}
}

extension AnalyticsAndOperator: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A conjunction (logical AND) of predicates, which is used in evaluating a metrics filter.
///          The operator must have at least two predicates in any combination, and an object must match
///          all of the predicates for the filter to apply.</p>
public struct AnalyticsAndOperator: Equatable {
    /// <p>The prefix to use when evaluating an AND predicate: The prefix that an object must have
    ///          to be included in the metrics results.</p>
    public let prefix: String?
    /// <p>The list of tags to use when evaluating an AND predicate.</p>
    public let tags: [Tag]?

    public init (
        prefix: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.prefix = prefix
        self.tags = tags
    }
}

extension AnalyticsConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case id = "Id"
        case storageClassAnalysis = "StorageClassAnalysis"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let filter = filter {
            try container.encode(filter, forKey: Key("filter"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let storageClassAnalysis = storageClassAnalysis {
            try container.encode(storageClassAnalysis, forKey: Key("storageClassAnalysis"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let filterDecoded = try containerValues.decodeIfPresent(AnalyticsFilter.self, forKey: .filter)
        filter = filterDecoded
        let storageClassAnalysisDecoded = try containerValues.decodeIfPresent(StorageClassAnalysis.self, forKey: .storageClassAnalysis)
        storageClassAnalysis = storageClassAnalysisDecoded
    }
}

extension AnalyticsConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnalyticsConfiguration(filter: \(String(describing: filter)), id: \(String(describing: id)), storageClassAnalysis: \(String(describing: storageClassAnalysis)))"}
}

extension AnalyticsConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies the configuration and any analyses for the analytics filter of an Amazon S3 bucket.</p>
public struct AnalyticsConfiguration: Equatable {
    /// <p>The filter used to describe a set of objects for analyses. A filter must have exactly
    ///          one prefix, one tag, or one conjunction (AnalyticsAndOperator). If no filter is provided,
    ///          all objects will be considered in any analysis.</p>
    public let filter: AnalyticsFilter?
    /// <p>The ID that identifies the analytics configuration.</p>
    public let id: String?
    /// <p> Contains data related to access patterns to be collected and made available to analyze
    ///          the tradeoffs between different storage classes. </p>
    public let storageClassAnalysis: StorageClassAnalysis?

    public init (
        filter: AnalyticsFilter? = nil,
        id: String? = nil,
        storageClassAnalysis: StorageClassAnalysis? = nil
    )
    {
        self.filter = filter
        self.id = id
        self.storageClassAnalysis = storageClassAnalysis
    }
}

extension AnalyticsExportDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3BucketDestination = "S3BucketDestination"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let s3BucketDestination = s3BucketDestination {
            try container.encode(s3BucketDestination, forKey: Key("s3BucketDestination"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDestinationDecoded = try containerValues.decodeIfPresent(AnalyticsS3BucketDestination.self, forKey: .s3BucketDestination)
        s3BucketDestination = s3BucketDestinationDecoded
    }
}

extension AnalyticsExportDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnalyticsExportDestination(s3BucketDestination: \(String(describing: s3BucketDestination)))"}
}

extension AnalyticsExportDestination: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Where to publish the analytics results.</p>
public struct AnalyticsExportDestination: Equatable {
    /// <p>A destination signifying output to an S3 bucket.</p>
    public let s3BucketDestination: AnalyticsS3BucketDestination?

    public init (
        s3BucketDestination: AnalyticsS3BucketDestination? = nil
    )
    {
        self.s3BucketDestination = s3BucketDestination
    }
}

extension AnalyticsFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case and = "And"
        case prefix = "Prefix"
        case tag = "Tag"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        switch self {
            case let .and(and):
                if let and = and {
                    try container.encode(and, forKey: Key("and"))
                }
            case let .prefix(prefix):
                if let prefix = prefix {
                    try container.encode(prefix, forKey: Key("prefix"))
                }
            case let .tag(tag):
                if let tag = tag {
                    try container.encode(tag, forKey: Key("tag"))
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: Key("sdkUnknown"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        if let prefix = prefixDecoded {
            self = .prefix(prefix)
            return
        }
        let tagDecoded = try containerValues.decodeIfPresent(Tag.self, forKey: .tag)
        if let tag = tagDecoded {
            self = .tag(tag)
            return
        }
        let andDecoded = try containerValues.decodeIfPresent(AnalyticsAndOperator.self, forKey: .and)
        if let and = andDecoded {
            self = .and(and)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>The filter used to describe a set of objects for analyses. A filter must have exactly
///          one prefix, one tag, or one conjunction (AnalyticsAndOperator). If no filter is provided,
///          all objects will be considered in any analysis.</p>
public enum AnalyticsFilter: Equatable {
    /// <p>The prefix to use when evaluating an analytics filter.</p>
    case prefix(String?)
    /// <p>The tag to use when evaluating an analytics filter.</p>
    case tag(Tag?)
    /// <p>A conjunction (logical AND) of predicates, which is used in evaluating an analytics
    ///          filter. The operator must have at least two predicates.</p>
    case and(AnalyticsAndOperator?)
    case sdkUnknown(String?)
}

extension AnalyticsS3BucketDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case bucketAccountId = "BucketAccountId"
        case format = "Format"
        case prefix = "Prefix"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: Key("bucket"))
        }
        if let bucketAccountId = bucketAccountId {
            try container.encode(bucketAccountId, forKey: Key("bucketAccountId"))
        }
        if let format = format {
            try container.encode(format, forKey: Key("format"))
        }
        if let prefix = prefix {
            try container.encode(prefix, forKey: Key("prefix"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(AnalyticsS3ExportFileFormat.self, forKey: .format)
        format = formatDecoded
        let bucketAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketAccountId)
        bucketAccountId = bucketAccountIdDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension AnalyticsS3BucketDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnalyticsS3BucketDestination(bucket: \(String(describing: bucket)), bucketAccountId: \(String(describing: bucketAccountId)), format: \(String(describing: format)), prefix: \(String(describing: prefix)))"}
}

extension AnalyticsS3BucketDestination: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains information about where to publish the analytics results.</p>
public struct AnalyticsS3BucketDestination: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the bucket to which data is exported.</p>
    public let bucket: String?
    /// <p>The account ID that owns the destination S3 bucket. If no account ID is provided, the
    ///          owner is not validated before exporting data.</p>
    ///          <note>
    ///             <p> Although this value is optional, we strongly recommend that you set it to help
    ///             prevent problems if the destination bucket ownership changes. </p>
    ///          </note>
    public let bucketAccountId: String?
    /// <p>Specifies the file format used when exporting data to Amazon S3.</p>
    public let format: AnalyticsS3ExportFileFormat?
    /// <p>The prefix to use when exporting data. The prefix is prepended to all results.</p>
    public let prefix: String?

    public init (
        bucket: String? = nil,
        bucketAccountId: String? = nil,
        format: AnalyticsS3ExportFileFormat? = nil,
        prefix: String? = nil
    )
    {
        self.bucket = bucket
        self.bucketAccountId = bucketAccountId
        self.format = format
        self.prefix = prefix
    }
}

public enum AnalyticsS3ExportFileFormat {
    case csv
    case sdkUnknown(String)
}

extension AnalyticsS3ExportFileFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AnalyticsS3ExportFileFormat] {
        return [
            .csv,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csv: return "CSV"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AnalyticsS3ExportFileFormat(rawValue: rawValue) ?? AnalyticsS3ExportFileFormat.sdkUnknown(rawValue)
    }
}

public enum ArchiveStatus {
    case archiveAccess
    case deepArchiveAccess
    case sdkUnknown(String)
}

extension ArchiveStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ArchiveStatus] {
        return [
            .archiveAccess,
            .deepArchiveAccess,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .archiveAccess: return "ARCHIVE_ACCESS"
        case .deepArchiveAccess: return "DEEP_ARCHIVE_ACCESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ArchiveStatus(rawValue: rawValue) ?? ArchiveStatus.sdkUnknown(rawValue)
    }
}

extension Bucket: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate = "CreationDate"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let creationDate = creationDate {
            try container.encode(TimestampWrapper(creationDate, format: .dateTime), forKey: Key("creationDate"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("name"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        var creationDateBuffer:Date? = nil
        if let creationDateDecoded = creationDateDecoded {
            creationDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(creationDateDecoded, format: .dateTime)
        }
        creationDate = creationDateBuffer
    }
}

extension Bucket: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Bucket(creationDate: \(String(describing: creationDate)), name: \(String(describing: name)))"}
}

extension Bucket: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p> In terms of implementation, a Bucket is a resource. An Amazon S3 bucket name is globally
///          unique, and the namespace is shared by all AWS accounts. </p>
public struct Bucket: Equatable {
    /// <p>Date the bucket was created. This date can change when making changes to your bucket, such as editing its bucket policy.</p>
    public let creationDate: Date?
    /// <p>The name of the bucket.</p>
    public let name: String?

    public init (
        creationDate: Date? = nil,
        name: String? = nil
    )
    {
        self.creationDate = creationDate
        self.name = name
    }
}

public enum BucketAccelerateStatus {
    case enabled
    case suspended
    case sdkUnknown(String)
}

extension BucketAccelerateStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BucketAccelerateStatus] {
        return [
            .enabled,
            .suspended,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .enabled: return "Enabled"
        case .suspended: return "Suspended"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BucketAccelerateStatus(rawValue: rawValue) ?? BucketAccelerateStatus.sdkUnknown(rawValue)
    }
}

extension BucketAlreadyExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BucketAlreadyExists()"}
}

extension BucketAlreadyExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested bucket name is not available. The bucket namespace is shared by all users
///          of the system. Select a different name and try again.</p>
public struct BucketAlreadyExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

extension BucketAlreadyOwnedByYou: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BucketAlreadyOwnedByYou()"}
}

extension BucketAlreadyOwnedByYou: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The bucket you tried to create already exists, and you own it. Amazon S3 returns this error
///          in all AWS Regions except in the North Virginia Region. For legacy compatibility, if you
///          re-create an existing bucket that you already own in the North Virginia Region, Amazon S3
///          returns 200 OK and resets the bucket access control lists (ACLs).</p>
public struct BucketAlreadyOwnedByYou: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

public enum BucketCannedACL {
    case authenticatedRead
    case `private`
    case publicRead
    case publicReadWrite
    case sdkUnknown(String)
}

extension BucketCannedACL : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BucketCannedACL] {
        return [
            .authenticatedRead,
            .private,
            .publicRead,
            .publicReadWrite,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .authenticatedRead: return "authenticated-read"
        case .private: return "private"
        case .publicRead: return "public-read"
        case .publicReadWrite: return "public-read-write"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BucketCannedACL(rawValue: rawValue) ?? BucketCannedACL.sdkUnknown(rawValue)
    }
}

extension BucketLifecycleConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case rules = "Rule"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let rules = rules {
            if rules.isEmpty {
                var rulesContainer = container.nestedUnkeyedContainer(forKey: Key("Rule"))
                try rulesContainer.encodeNil()
            } else {
                for lifecyclerule0 in rules {
                    var rulesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Rule"))
                    try rulesContainer0.encode(lifecyclerule0, forKey: Key(""))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.rules) {
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .rules)
            if rulesWrappedContainer != nil {
                let rulesContainer = try containerValues.decodeIfPresent([LifecycleRule].self, forKey: .rules)
                var rulesBuffer:[LifecycleRule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [LifecycleRule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

extension BucketLifecycleConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BucketLifecycleConfiguration(rules: \(String(describing: rules)))"}
}

extension BucketLifecycleConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies the lifecycle configuration for objects in an Amazon S3 bucket. For more
///          information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lifecycle-mgmt.html">Object Lifecycle Management</a>
///          in the <i>Amazon S3 User Guide</i>.</p>
public struct BucketLifecycleConfiguration: Equatable {
    /// <p>A lifecycle rule for individual objects in an Amazon S3 bucket.</p>
    public let rules: [LifecycleRule]?

    public init (
        rules: [LifecycleRule]? = nil
    )
    {
        self.rules = rules
    }
}

public enum BucketLocationConstraint {
    case eu
    case afSouth1
    case apEast1
    case apNortheast1
    case apNortheast2
    case apNortheast3
    case apSouth1
    case apSoutheast1
    case apSoutheast2
    case caCentral1
    case cnNorth1
    case cnNorthwest1
    case euCentral1
    case euNorth1
    case euSouth1
    case euWest1
    case euWest2
    case euWest3
    case meSouth1
    case saEast1
    case usEast2
    case usGovEast1
    case usGovWest1
    case usWest1
    case usWest2
    case sdkUnknown(String)
}

extension BucketLocationConstraint : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BucketLocationConstraint] {
        return [
            .eu,
            .afSouth1,
            .apEast1,
            .apNortheast1,
            .apNortheast2,
            .apNortheast3,
            .apSouth1,
            .apSoutheast1,
            .apSoutheast2,
            .caCentral1,
            .cnNorth1,
            .cnNorthwest1,
            .euCentral1,
            .euNorth1,
            .euSouth1,
            .euWest1,
            .euWest2,
            .euWest3,
            .meSouth1,
            .saEast1,
            .usEast2,
            .usGovEast1,
            .usGovWest1,
            .usWest1,
            .usWest2,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .eu: return "EU"
        case .afSouth1: return "af-south-1"
        case .apEast1: return "ap-east-1"
        case .apNortheast1: return "ap-northeast-1"
        case .apNortheast2: return "ap-northeast-2"
        case .apNortheast3: return "ap-northeast-3"
        case .apSouth1: return "ap-south-1"
        case .apSoutheast1: return "ap-southeast-1"
        case .apSoutheast2: return "ap-southeast-2"
        case .caCentral1: return "ca-central-1"
        case .cnNorth1: return "cn-north-1"
        case .cnNorthwest1: return "cn-northwest-1"
        case .euCentral1: return "eu-central-1"
        case .euNorth1: return "eu-north-1"
        case .euSouth1: return "eu-south-1"
        case .euWest1: return "eu-west-1"
        case .euWest2: return "eu-west-2"
        case .euWest3: return "eu-west-3"
        case .meSouth1: return "me-south-1"
        case .saEast1: return "sa-east-1"
        case .usEast2: return "us-east-2"
        case .usGovEast1: return "us-gov-east-1"
        case .usGovWest1: return "us-gov-west-1"
        case .usWest1: return "us-west-1"
        case .usWest2: return "us-west-2"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BucketLocationConstraint(rawValue: rawValue) ?? BucketLocationConstraint.sdkUnknown(rawValue)
    }
}

extension BucketLoggingStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case loggingEnabled = "LoggingEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let loggingEnabled = loggingEnabled {
            try container.encode(loggingEnabled, forKey: Key("loggingEnabled"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingEnabledDecoded = try containerValues.decodeIfPresent(LoggingEnabled.self, forKey: .loggingEnabled)
        loggingEnabled = loggingEnabledDecoded
    }
}

extension BucketLoggingStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BucketLoggingStatus(loggingEnabled: \(String(describing: loggingEnabled)))"}
}

extension BucketLoggingStatus: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container for logging status information.</p>
public struct BucketLoggingStatus: Equatable {
    /// <p>Describes where logs are stored and the prefix that Amazon S3 assigns to all log object keys
    ///          for a bucket. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTlogging.html">PUT Bucket logging</a> in the
    ///             <i>Amazon S3 API Reference</i>.</p>
    public let loggingEnabled: LoggingEnabled?

    public init (
        loggingEnabled: LoggingEnabled? = nil
    )
    {
        self.loggingEnabled = loggingEnabled
    }
}

public enum BucketLogsPermission {
    case fullControl
    case read
    case write
    case sdkUnknown(String)
}

extension BucketLogsPermission : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BucketLogsPermission] {
        return [
            .fullControl,
            .read,
            .write,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fullControl: return "FULL_CONTROL"
        case .read: return "READ"
        case .write: return "WRITE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BucketLogsPermission(rawValue: rawValue) ?? BucketLogsPermission.sdkUnknown(rawValue)
    }
}

public enum BucketVersioningStatus {
    case enabled
    case suspended
    case sdkUnknown(String)
}

extension BucketVersioningStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BucketVersioningStatus] {
        return [
            .enabled,
            .suspended,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .enabled: return "Enabled"
        case .suspended: return "Suspended"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BucketVersioningStatus(rawValue: rawValue) ?? BucketVersioningStatus.sdkUnknown(rawValue)
    }
}

extension CORSConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cORSRules = "CORSRule"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let cORSRules = cORSRules {
            if cORSRules.isEmpty {
                var cORSRulesContainer = container.nestedUnkeyedContainer(forKey: Key("CORSRule"))
                try cORSRulesContainer.encodeNil()
            } else {
                for corsrule0 in cORSRules {
                    var cORSRulesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("CORSRule"))
                    try cORSRulesContainer0.encode(corsrule0, forKey: Key(""))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.cORSRules) {
            let cORSRulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .cORSRules)
            if cORSRulesWrappedContainer != nil {
                let cORSRulesContainer = try containerValues.decodeIfPresent([CORSRule].self, forKey: .cORSRules)
                var cORSRulesBuffer:[CORSRule]? = nil
                if let cORSRulesContainer = cORSRulesContainer {
                    cORSRulesBuffer = [CORSRule]()
                    for structureContainer0 in cORSRulesContainer {
                        cORSRulesBuffer?.append(structureContainer0)
                    }
                }
                cORSRules = cORSRulesBuffer
            } else {
                cORSRules = []
            }
        } else {
            cORSRules = nil
        }
    }
}

extension CORSConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CORSConfiguration(cORSRules: \(String(describing: cORSRules)))"}
}

extension CORSConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Describes the cross-origin access configuration for objects in an Amazon S3 bucket. For more
///          information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html">Enabling
///             Cross-Origin Resource Sharing</a> in the <i>Amazon S3 User Guide</i>.</p>
public struct CORSConfiguration: Equatable {
    /// <p>A set of origins and methods (cross-origin access that you want to allow). You can add
    ///          up to 100 rules to the configuration.</p>
    public let cORSRules: [CORSRule]?

    public init (
        cORSRules: [CORSRule]? = nil
    )
    {
        self.cORSRules = cORSRules
    }
}

extension CORSRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedHeaders = "AllowedHeader"
        case allowedMethods = "AllowedMethod"
        case allowedOrigins = "AllowedOrigin"
        case exposeHeaders = "ExposeHeader"
        case iD = "ID"
        case maxAgeSeconds = "MaxAgeSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let allowedHeaders = allowedHeaders {
            if allowedHeaders.isEmpty {
                var allowedHeadersContainer = container.nestedUnkeyedContainer(forKey: Key("AllowedHeader"))
                try allowedHeadersContainer.encodeNil()
            } else {
                for allowedheader0 in allowedHeaders {
                    var allowedHeadersContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("AllowedHeader"))
                    try allowedHeadersContainer0.encode(allowedheader0, forKey: Key(""))
                }
            }
        }
        if let allowedMethods = allowedMethods {
            if allowedMethods.isEmpty {
                var allowedMethodsContainer = container.nestedUnkeyedContainer(forKey: Key("AllowedMethod"))
                try allowedMethodsContainer.encodeNil()
            } else {
                for allowedmethod0 in allowedMethods {
                    var allowedMethodsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("AllowedMethod"))
                    try allowedMethodsContainer0.encode(allowedmethod0, forKey: Key(""))
                }
            }
        }
        if let allowedOrigins = allowedOrigins {
            if allowedOrigins.isEmpty {
                var allowedOriginsContainer = container.nestedUnkeyedContainer(forKey: Key("AllowedOrigin"))
                try allowedOriginsContainer.encodeNil()
            } else {
                for allowedorigin0 in allowedOrigins {
                    var allowedOriginsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("AllowedOrigin"))
                    try allowedOriginsContainer0.encode(allowedorigin0, forKey: Key(""))
                }
            }
        }
        if let exposeHeaders = exposeHeaders {
            if exposeHeaders.isEmpty {
                var exposeHeadersContainer = container.nestedUnkeyedContainer(forKey: Key("ExposeHeader"))
                try exposeHeadersContainer.encodeNil()
            } else {
                for exposeheader0 in exposeHeaders {
                    var exposeHeadersContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("ExposeHeader"))
                    try exposeHeadersContainer0.encode(exposeheader0, forKey: Key(""))
                }
            }
        }
        if let iD = iD {
            try container.encode(iD, forKey: Key("iD"))
        }
        if maxAgeSeconds != 0 {
            try container.encode(maxAgeSeconds, forKey: Key("maxAgeSeconds"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iD)
        iD = iDDecoded
        if containerValues.contains(.allowedHeaders) {
            let allowedHeadersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .allowedHeaders)
            if allowedHeadersWrappedContainer != nil {
                let allowedHeadersContainer = try containerValues.decodeIfPresent([String].self, forKey: .allowedHeaders)
                var allowedHeadersBuffer:[String]? = nil
                if let allowedHeadersContainer = allowedHeadersContainer {
                    allowedHeadersBuffer = [String]()
                    for stringContainer0 in allowedHeadersContainer {
                        allowedHeadersBuffer?.append(stringContainer0)
                    }
                }
                allowedHeaders = allowedHeadersBuffer
            } else {
                allowedHeaders = []
            }
        } else {
            allowedHeaders = nil
        }
        if containerValues.contains(.allowedMethods) {
            let allowedMethodsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .allowedMethods)
            if allowedMethodsWrappedContainer != nil {
                let allowedMethodsContainer = try containerValues.decodeIfPresent([String].self, forKey: .allowedMethods)
                var allowedMethodsBuffer:[String]? = nil
                if let allowedMethodsContainer = allowedMethodsContainer {
                    allowedMethodsBuffer = [String]()
                    for stringContainer0 in allowedMethodsContainer {
                        allowedMethodsBuffer?.append(stringContainer0)
                    }
                }
                allowedMethods = allowedMethodsBuffer
            } else {
                allowedMethods = []
            }
        } else {
            allowedMethods = nil
        }
        if containerValues.contains(.allowedOrigins) {
            let allowedOriginsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .allowedOrigins)
            if allowedOriginsWrappedContainer != nil {
                let allowedOriginsContainer = try containerValues.decodeIfPresent([String].self, forKey: .allowedOrigins)
                var allowedOriginsBuffer:[String]? = nil
                if let allowedOriginsContainer = allowedOriginsContainer {
                    allowedOriginsBuffer = [String]()
                    for stringContainer0 in allowedOriginsContainer {
                        allowedOriginsBuffer?.append(stringContainer0)
                    }
                }
                allowedOrigins = allowedOriginsBuffer
            } else {
                allowedOrigins = []
            }
        } else {
            allowedOrigins = nil
        }
        if containerValues.contains(.exposeHeaders) {
            let exposeHeadersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .exposeHeaders)
            if exposeHeadersWrappedContainer != nil {
                let exposeHeadersContainer = try containerValues.decodeIfPresent([String].self, forKey: .exposeHeaders)
                var exposeHeadersBuffer:[String]? = nil
                if let exposeHeadersContainer = exposeHeadersContainer {
                    exposeHeadersBuffer = [String]()
                    for stringContainer0 in exposeHeadersContainer {
                        exposeHeadersBuffer?.append(stringContainer0)
                    }
                }
                exposeHeaders = exposeHeadersBuffer
            } else {
                exposeHeaders = []
            }
        } else {
            exposeHeaders = nil
        }
        let maxAgeSecondsDecoded = try containerValues.decode(Int.self, forKey: .maxAgeSeconds)
        maxAgeSeconds = maxAgeSecondsDecoded
    }
}

extension CORSRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CORSRule(allowedHeaders: \(String(describing: allowedHeaders)), allowedMethods: \(String(describing: allowedMethods)), allowedOrigins: \(String(describing: allowedOrigins)), exposeHeaders: \(String(describing: exposeHeaders)), iD: \(String(describing: iD)), maxAgeSeconds: \(String(describing: maxAgeSeconds)))"}
}

extension CORSRule: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies a cross-origin access rule for an Amazon S3 bucket.</p>
public struct CORSRule: Equatable {
    /// <p>Headers that are specified in the <code>Access-Control-Request-Headers</code> header.
    ///          These headers are allowed in a preflight OPTIONS request. In response to any preflight
    ///          OPTIONS request, Amazon S3 returns any requested headers that are allowed.</p>
    public let allowedHeaders: [String]?
    /// <p>An HTTP method that you allow the origin to execute. Valid values are <code>GET</code>,
    ///             <code>PUT</code>, <code>HEAD</code>, <code>POST</code>, and <code>DELETE</code>.</p>
    public let allowedMethods: [String]?
    /// <p>One or more origins you want customers to be able to access the bucket from.</p>
    public let allowedOrigins: [String]?
    /// <p>One or more headers in the response that you want customers to be able to access from
    ///          their applications (for example, from a JavaScript <code>XMLHttpRequest</code>
    ///          object).</p>
    public let exposeHeaders: [String]?
    /// <p>Unique identifier for the rule. The value cannot be longer than 255 characters.</p>
    public let iD: String?
    /// <p>The time in seconds that your browser is to cache the preflight response for the
    ///          specified resource.</p>
    public let maxAgeSeconds: Int

    public init (
        allowedHeaders: [String]? = nil,
        allowedMethods: [String]? = nil,
        allowedOrigins: [String]? = nil,
        exposeHeaders: [String]? = nil,
        iD: String? = nil,
        maxAgeSeconds: Int = 0
    )
    {
        self.allowedHeaders = allowedHeaders
        self.allowedMethods = allowedMethods
        self.allowedOrigins = allowedOrigins
        self.exposeHeaders = exposeHeaders
        self.iD = iD
        self.maxAgeSeconds = maxAgeSeconds
    }
}

extension CSVInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowQuotedRecordDelimiter = "AllowQuotedRecordDelimiter"
        case comments = "Comments"
        case fieldDelimiter = "FieldDelimiter"
        case fileHeaderInfo = "FileHeaderInfo"
        case quoteCharacter = "QuoteCharacter"
        case quoteEscapeCharacter = "QuoteEscapeCharacter"
        case recordDelimiter = "RecordDelimiter"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if allowQuotedRecordDelimiter != false {
            try container.encode(allowQuotedRecordDelimiter, forKey: Key("allowQuotedRecordDelimiter"))
        }
        if let comments = comments {
            try container.encode(comments, forKey: Key("comments"))
        }
        if let fieldDelimiter = fieldDelimiter {
            try container.encode(fieldDelimiter, forKey: Key("fieldDelimiter"))
        }
        if let fileHeaderInfo = fileHeaderInfo {
            try container.encode(fileHeaderInfo, forKey: Key("fileHeaderInfo"))
        }
        if let quoteCharacter = quoteCharacter {
            try container.encode(quoteCharacter, forKey: Key("quoteCharacter"))
        }
        if let quoteEscapeCharacter = quoteEscapeCharacter {
            try container.encode(quoteEscapeCharacter, forKey: Key("quoteEscapeCharacter"))
        }
        if let recordDelimiter = recordDelimiter {
            try container.encode(recordDelimiter, forKey: Key("recordDelimiter"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileHeaderInfoDecoded = try containerValues.decodeIfPresent(FileHeaderInfo.self, forKey: .fileHeaderInfo)
        fileHeaderInfo = fileHeaderInfoDecoded
        let commentsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comments)
        comments = commentsDecoded
        let quoteEscapeCharacterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quoteEscapeCharacter)
        quoteEscapeCharacter = quoteEscapeCharacterDecoded
        let recordDelimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recordDelimiter)
        recordDelimiter = recordDelimiterDecoded
        let fieldDelimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fieldDelimiter)
        fieldDelimiter = fieldDelimiterDecoded
        let quoteCharacterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quoteCharacter)
        quoteCharacter = quoteCharacterDecoded
        let allowQuotedRecordDelimiterDecoded = try containerValues.decode(Bool.self, forKey: .allowQuotedRecordDelimiter)
        allowQuotedRecordDelimiter = allowQuotedRecordDelimiterDecoded
    }
}

extension CSVInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CSVInput(allowQuotedRecordDelimiter: \(String(describing: allowQuotedRecordDelimiter)), comments: \(String(describing: comments)), fieldDelimiter: \(String(describing: fieldDelimiter)), fileHeaderInfo: \(String(describing: fileHeaderInfo)), quoteCharacter: \(String(describing: quoteCharacter)), quoteEscapeCharacter: \(String(describing: quoteEscapeCharacter)), recordDelimiter: \(String(describing: recordDelimiter)))"}
}

extension CSVInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Describes how an uncompressed comma-separated values (CSV)-formatted input object is
///          formatted.</p>
public struct CSVInput: Equatable {
    /// <p>Specifies that CSV field values may contain quoted record delimiters and such records
    ///          should be allowed. Default value is FALSE. Setting this value to TRUE may lower
    ///          performance.</p>
    public let allowQuotedRecordDelimiter: Bool
    /// <p>A single character used to indicate that a row should be ignored when the character is
    ///          present at the start of that row. You can specify any character to indicate a comment
    ///          line.</p>
    public let comments: String?
    /// <p>A single character used to separate individual fields in a record. You can specify an
    ///          arbitrary delimiter.</p>
    public let fieldDelimiter: String?
    /// <p>Describes the first line of input. Valid values are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>NONE</code>: First line is not a header.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IGNORE</code>: First line is a header, but you can't use the header values
    ///                to indicate the column in an expression. You can use column position (such as _1, _2,
    ///                ) to indicate the column (<code>SELECT s._1 FROM OBJECT s</code>).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Use</code>: First line is a header, and you can use the header value to
    ///                identify a column in an expression (<code>SELECT "name" FROM OBJECT</code>). </p>
    ///             </li>
    ///          </ul>
    public let fileHeaderInfo: FileHeaderInfo?
    /// <p>A single character used for escaping when the field delimiter is part of the value. For
    ///          example, if the value is <code>a, b</code>, Amazon S3 wraps this field value in quotation marks,
    ///          as follows: <code>" a , b "</code>.</p>
    ///          <p>Type: String</p>
    ///          <p>Default: <code>"</code>
    ///          </p>
    ///          <p>Ancestors: <code>CSV</code>
    ///          </p>
    public let quoteCharacter: String?
    /// <p>A single character used for escaping the quotation mark character inside an already
    ///          escaped value. For example, the value """ a , b """ is parsed as " a , b ".</p>
    public let quoteEscapeCharacter: String?
    /// <p>A single character used to separate individual records in the input. Instead of the
    ///          default value, you can specify an arbitrary delimiter.</p>
    public let recordDelimiter: String?

    public init (
        allowQuotedRecordDelimiter: Bool = false,
        comments: String? = nil,
        fieldDelimiter: String? = nil,
        fileHeaderInfo: FileHeaderInfo? = nil,
        quoteCharacter: String? = nil,
        quoteEscapeCharacter: String? = nil,
        recordDelimiter: String? = nil
    )
    {
        self.allowQuotedRecordDelimiter = allowQuotedRecordDelimiter
        self.comments = comments
        self.fieldDelimiter = fieldDelimiter
        self.fileHeaderInfo = fileHeaderInfo
        self.quoteCharacter = quoteCharacter
        self.quoteEscapeCharacter = quoteEscapeCharacter
        self.recordDelimiter = recordDelimiter
    }
}

extension CSVOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldDelimiter = "FieldDelimiter"
        case quoteCharacter = "QuoteCharacter"
        case quoteEscapeCharacter = "QuoteEscapeCharacter"
        case quoteFields = "QuoteFields"
        case recordDelimiter = "RecordDelimiter"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let fieldDelimiter = fieldDelimiter {
            try container.encode(fieldDelimiter, forKey: Key("fieldDelimiter"))
        }
        if let quoteCharacter = quoteCharacter {
            try container.encode(quoteCharacter, forKey: Key("quoteCharacter"))
        }
        if let quoteEscapeCharacter = quoteEscapeCharacter {
            try container.encode(quoteEscapeCharacter, forKey: Key("quoteEscapeCharacter"))
        }
        if let quoteFields = quoteFields {
            try container.encode(quoteFields, forKey: Key("quoteFields"))
        }
        if let recordDelimiter = recordDelimiter {
            try container.encode(recordDelimiter, forKey: Key("recordDelimiter"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quoteFieldsDecoded = try containerValues.decodeIfPresent(QuoteFields.self, forKey: .quoteFields)
        quoteFields = quoteFieldsDecoded
        let quoteEscapeCharacterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quoteEscapeCharacter)
        quoteEscapeCharacter = quoteEscapeCharacterDecoded
        let recordDelimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recordDelimiter)
        recordDelimiter = recordDelimiterDecoded
        let fieldDelimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fieldDelimiter)
        fieldDelimiter = fieldDelimiterDecoded
        let quoteCharacterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quoteCharacter)
        quoteCharacter = quoteCharacterDecoded
    }
}

extension CSVOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CSVOutput(fieldDelimiter: \(String(describing: fieldDelimiter)), quoteCharacter: \(String(describing: quoteCharacter)), quoteEscapeCharacter: \(String(describing: quoteEscapeCharacter)), quoteFields: \(String(describing: quoteFields)), recordDelimiter: \(String(describing: recordDelimiter)))"}
}

extension CSVOutput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Describes how uncompressed comma-separated values (CSV)-formatted results are
///          formatted.</p>
public struct CSVOutput: Equatable {
    /// <p>The value used to separate individual fields in a record. You can specify an arbitrary
    ///          delimiter.</p>
    public let fieldDelimiter: String?
    /// <p>A single character used for escaping when the field delimiter is part of the value. For
    ///          example, if the value is <code>a, b</code>, Amazon S3 wraps this field value in quotation marks,
    ///          as follows: <code>" a , b "</code>.</p>
    public let quoteCharacter: String?
    /// <p>The single character used for escaping the quote character inside an already escaped
    ///          value.</p>
    public let quoteEscapeCharacter: String?
    /// <p>Indicates whether to use quotation marks around output fields. </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ALWAYS</code>: Always use quotation marks for output fields.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ASNEEDED</code>: Use quotation marks for output fields when needed.</p>
    ///             </li>
    ///          </ul>
    public let quoteFields: QuoteFields?
    /// <p>A single character used to separate individual records in the output. Instead of the
    ///          default value, you can specify an arbitrary delimiter.</p>
    public let recordDelimiter: String?

    public init (
        fieldDelimiter: String? = nil,
        quoteCharacter: String? = nil,
        quoteEscapeCharacter: String? = nil,
        quoteFields: QuoteFields? = nil,
        recordDelimiter: String? = nil
    )
    {
        self.fieldDelimiter = fieldDelimiter
        self.quoteCharacter = quoteCharacter
        self.quoteEscapeCharacter = quoteEscapeCharacter
        self.quoteFields = quoteFields
        self.recordDelimiter = recordDelimiter
    }
}

extension CommonPrefix: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case prefix = "Prefix"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let prefix = prefix {
            try container.encode(prefix, forKey: Key("prefix"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension CommonPrefix: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommonPrefix(prefix: \(String(describing: prefix)))"}
}

extension CommonPrefix: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container for all (if there are any) keys between Prefix and the next occurrence of the
///          string specified by a delimiter. CommonPrefixes lists keys that act like subdirectories in
///          the directory specified by Prefix. For example, if the prefix is notes/ and the delimiter
///          is a slash (/) as in notes/summer/july, the common prefix is notes/summer/. </p>
public struct CommonPrefix: Equatable {
    /// <p>Container for the specified common prefix.</p>
    public let prefix: String?

    public init (
        prefix: String? = nil
    )
    {
        self.prefix = prefix
    }
}

public struct CompleteMultipartUploadInputBodyMiddleware: Middleware {
    public let id: String = "CompleteMultipartUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CompleteMultipartUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<CompleteMultipartUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let multipartUpload = input.operationInput.multipartUpload {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(multipartUpload)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CompleteMultipartUploadInput>
    public typealias MOutput = OperationOutput<CompleteMultipartUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CompleteMultipartUploadOutputError>
}

extension CompleteMultipartUploadInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CompleteMultipartUploadInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), key: \(String(describing: key)), multipartUpload: \(String(describing: multipartUpload)), requestPayer: \(String(describing: requestPayer)), uploadId: \(String(describing: uploadId)))"}
}

extension CompleteMultipartUploadInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CompleteMultipartUploadInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case multipartUpload = "CompleteMultipartUpload"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let multipartUpload = multipartUpload {
            try container.encode(multipartUpload, forKey: Key("CompleteMultipartUpload"))
        }
    }
}

public struct CompleteMultipartUploadInputHeadersMiddleware: Middleware {
    public let id: String = "CompleteMultipartUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CompleteMultipartUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<CompleteMultipartUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CompleteMultipartUploadInput>
    public typealias MOutput = OperationOutput<CompleteMultipartUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CompleteMultipartUploadOutputError>
}

public struct CompleteMultipartUploadInputQueryItemMiddleware: Middleware {
    public let id: String = "CompleteMultipartUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CompleteMultipartUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<CompleteMultipartUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "x-id", value: "CompleteMultipartUpload"))
        if let uploadId = input.operationInput.uploadId {
            let uploadIdQueryItem = URLQueryItem(name: "uploadId".urlPercentEncoding(), value: String(uploadId).urlPercentEncoding())
            input.builder.withQueryItem(uploadIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CompleteMultipartUploadInput>
    public typealias MOutput = OperationOutput<CompleteMultipartUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CompleteMultipartUploadOutputError>
}

public struct CompleteMultipartUploadInput: Equatable {
    /// <p>Name of the bucket to which the multipart upload was initiated.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>Object key for which the multipart upload was initiated.</p>
    public let key: String?
    /// <p>The container for the multipart upload request information.</p>
    public let multipartUpload: CompletedMultipartUpload?
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    ///          owners need not specify this parameter in their requests. For information about downloading
    ///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    ///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let requestPayer: RequestPayer?
    /// <p>ID for the initiated multipart upload.</p>
    public let uploadId: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        key: String? = nil,
        multipartUpload: CompletedMultipartUpload? = nil,
        requestPayer: RequestPayer? = nil,
        uploadId: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.multipartUpload = multipartUpload
        self.requestPayer = requestPayer
        self.uploadId = uploadId
    }
}

struct CompleteMultipartUploadInputBody: Equatable {
    public let multipartUpload: CompletedMultipartUpload?
}

extension CompleteMultipartUploadInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case multipartUpload = "CompleteMultipartUpload"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let multipartUploadDecoded = try containerValues.decodeIfPresent(CompletedMultipartUpload.self, forKey: .multipartUpload)
        multipartUpload = multipartUploadDecoded
    }
}

extension CompleteMultipartUploadOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CompleteMultipartUploadOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CompleteMultipartUploadOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CompleteMultipartUploadOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CompleteMultipartUploadOutputResponse(bucket: \(String(describing: bucket)), bucketKeyEnabled: \(String(describing: bucketKeyEnabled)), eTag: \(String(describing: eTag)), expiration: \(String(describing: expiration)), key: \(String(describing: key)), location: \(String(describing: location)), requestCharged: \(String(describing: requestCharged)), sSEKMSKeyId: \(String(describing: sSEKMSKeyId)), serverSideEncryption: \(String(describing: serverSideEncryption)), versionId: \(String(describing: versionId)))"}
}

extension CompleteMultipartUploadOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let bucketKeyEnabledHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-bucket-key-enabled") {
            self.bucketKeyEnabled = Bool(bucketKeyEnabledHeaderValue) ?? false
        } else {
            self.bucketKeyEnabled = false
        }
        if let expirationHeaderValue = httpResponse.headers.value(for: "x-amz-expiration") {
            self.expiration = expirationHeaderValue
        } else {
            self.expiration = nil
        }
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if let sSEKMSKeyIdHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-aws-kms-key-id") {
            self.sSEKMSKeyId = sSEKMSKeyIdHeaderValue
        } else {
            self.sSEKMSKeyId = nil
        }
        if let serverSideEncryptionHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption") {
            self.serverSideEncryption = ServerSideEncryption(rawValue: serverSideEncryptionHeaderValue)
        } else {
            self.serverSideEncryption = nil
        }
        if let versionIdHeaderValue = httpResponse.headers.value(for: "x-amz-version-id") {
            self.versionId = versionIdHeaderValue
        } else {
            self.versionId = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CompleteMultipartUploadOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.bucket = output.bucket
            self.eTag = output.eTag
            self.key = output.key
            self.location = output.location
        } else {
            self.bucket = nil
            self.eTag = nil
            self.key = nil
            self.location = nil
        }
    }
}

public struct CompleteMultipartUploadOutputResponse: Equatable {
    /// <p>The name of the bucket that contains the newly created object.</p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>Indicates whether the multipart upload uses an S3 Bucket Key for server-side encryption with AWS KMS (SSE-KMS).</p>
    public let bucketKeyEnabled: Bool
    /// <p>Entity tag that identifies the newly created object's data. Objects with different
    ///          object data will have different entity tags. The entity tag is an opaque string. The entity
    ///          tag may or may not be an MD5 digest of the object data. If the entity tag is not an MD5
    ///          digest of the object data, it will contain one or more nonhexadecimal characters and/or
    ///          will consist of less than 32 or more than 32 hexadecimal digits.</p>
    public let eTag: String?
    /// <p>If the object expiration is configured, this will contain the expiration date
    ///          (expiry-date) and rule ID (rule-id). The value of rule-id is URL encoded.</p>
    public let expiration: String?
    /// <p>The object key of the newly created object.</p>
    public let key: String?
    /// <p>The URI that identifies the newly created object.</p>
    public let location: String?
    /// <p>If present, indicates that the requester was successfully charged for the
    ///          request.</p>
    public let requestCharged: RequestCharged?
    /// <p>If present, specifies the ID of the AWS Key Management Service (AWS KMS) symmetric
    ///          customer managed customer master key (CMK) that was used for the object.</p>
    public let sSEKMSKeyId: String?
    /// <p>If you specified server-side encryption either with an Amazon S3-managed encryption key or an
    ///          AWS KMS customer master key (CMK) in your initiate multipart upload request, the response
    ///          includes this header. It confirms the encryption algorithm that Amazon S3 used to encrypt the
    ///          object.</p>
    public let serverSideEncryption: ServerSideEncryption?
    /// <p>Version ID of the newly created object, in case the bucket has versioning turned
    ///          on.</p>
    public let versionId: String?

    public init (
        bucket: String? = nil,
        bucketKeyEnabled: Bool = false,
        eTag: String? = nil,
        expiration: String? = nil,
        key: String? = nil,
        location: String? = nil,
        requestCharged: RequestCharged? = nil,
        sSEKMSKeyId: String? = nil,
        serverSideEncryption: ServerSideEncryption? = nil,
        versionId: String? = nil
    )
    {
        self.bucket = bucket
        self.bucketKeyEnabled = bucketKeyEnabled
        self.eTag = eTag
        self.expiration = expiration
        self.key = key
        self.location = location
        self.requestCharged = requestCharged
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
        self.versionId = versionId
    }
}

struct CompleteMultipartUploadOutputResponseBody: Equatable {
    public let location: String?
    public let bucket: String?
    public let key: String?
    public let eTag: String?
}

extension CompleteMultipartUploadOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case eTag = "ETag"
        case key = "Key"
        case location = "Location"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let eTagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eTag)
        eTag = eTagDecoded
    }
}

extension CompletedMultipartUpload: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parts = "Part"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let parts = parts {
            if parts.isEmpty {
                var partsContainer = container.nestedUnkeyedContainer(forKey: Key("Part"))
                try partsContainer.encodeNil()
            } else {
                for completedpart0 in parts {
                    var partsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Part"))
                    try partsContainer0.encode(completedpart0, forKey: Key(""))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.parts) {
            let partsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .parts)
            if partsWrappedContainer != nil {
                let partsContainer = try containerValues.decodeIfPresent([CompletedPart].self, forKey: .parts)
                var partsBuffer:[CompletedPart]? = nil
                if let partsContainer = partsContainer {
                    partsBuffer = [CompletedPart]()
                    for structureContainer0 in partsContainer {
                        partsBuffer?.append(structureContainer0)
                    }
                }
                parts = partsBuffer
            } else {
                parts = []
            }
        } else {
            parts = nil
        }
    }
}

extension CompletedMultipartUpload: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CompletedMultipartUpload(parts: \(String(describing: parts)))"}
}

extension CompletedMultipartUpload: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The container for the completed multipart upload details.</p>
public struct CompletedMultipartUpload: Equatable {
    /// <p>Array of CompletedPart data types.</p>
    public let parts: [CompletedPart]?

    public init (
        parts: [CompletedPart]? = nil
    )
    {
        self.parts = parts
    }
}

extension CompletedPart: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eTag = "ETag"
        case partNumber = "PartNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let eTag = eTag {
            try container.encode(eTag, forKey: Key("eTag"))
        }
        if partNumber != 0 {
            try container.encode(partNumber, forKey: Key("partNumber"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eTagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eTag)
        eTag = eTagDecoded
        let partNumberDecoded = try containerValues.decode(Int.self, forKey: .partNumber)
        partNumber = partNumberDecoded
    }
}

extension CompletedPart: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CompletedPart(eTag: \(String(describing: eTag)), partNumber: \(String(describing: partNumber)))"}
}

extension CompletedPart: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Details of the parts that were uploaded.</p>
public struct CompletedPart: Equatable {
    /// <p>Entity tag returned when the part was uploaded.</p>
    public let eTag: String?
    /// <p>Part number that identifies the part. This is a positive integer between 1 and
    ///          10,000.</p>
    public let partNumber: Int

    public init (
        eTag: String? = nil,
        partNumber: Int = 0
    )
    {
        self.eTag = eTag
        self.partNumber = partNumber
    }
}

public enum CompressionType {
    case bzip2
    case gzip
    case `none`
    case sdkUnknown(String)
}

extension CompressionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CompressionType] {
        return [
            .bzip2,
            .gzip,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bzip2: return "BZIP2"
        case .gzip: return "GZIP"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CompressionType(rawValue: rawValue) ?? CompressionType.sdkUnknown(rawValue)
    }
}

extension Condition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case httpErrorCodeReturnedEquals = "HttpErrorCodeReturnedEquals"
        case keyPrefixEquals = "KeyPrefixEquals"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let httpErrorCodeReturnedEquals = httpErrorCodeReturnedEquals {
            try container.encode(httpErrorCodeReturnedEquals, forKey: Key("httpErrorCodeReturnedEquals"))
        }
        if let keyPrefixEquals = keyPrefixEquals {
            try container.encode(keyPrefixEquals, forKey: Key("keyPrefixEquals"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpErrorCodeReturnedEqualsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .httpErrorCodeReturnedEquals)
        httpErrorCodeReturnedEquals = httpErrorCodeReturnedEqualsDecoded
        let keyPrefixEqualsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyPrefixEquals)
        keyPrefixEquals = keyPrefixEqualsDecoded
    }
}

extension Condition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Condition(httpErrorCodeReturnedEquals: \(String(describing: httpErrorCodeReturnedEquals)), keyPrefixEquals: \(String(describing: keyPrefixEquals)))"}
}

extension Condition: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container for describing a condition that must be met for the specified redirect to
///          apply. For example, 1. If request is for pages in the <code>/docs</code> folder, redirect
///          to the <code>/documents</code> folder. 2. If request results in HTTP error 4xx, redirect
///          request to another host where you might process the error.</p>
public struct Condition: Equatable {
    /// <p>The HTTP error code when the redirect is applied. In the event of an error, if the error
    ///          code equals this value, then the specified redirect is applied. Required when parent
    ///          element <code>Condition</code> is specified and sibling <code>KeyPrefixEquals</code> is not
    ///          specified. If both are specified, then both must be true for the redirect to be
    ///          applied.</p>
    public let httpErrorCodeReturnedEquals: String?
    /// <p>The object key name prefix when the redirect is applied. For example, to redirect
    ///          requests for <code>ExamplePage.html</code>, the key prefix will be
    ///             <code>ExamplePage.html</code>. To redirect request for all pages with the prefix
    ///             <code>docs/</code>, the key prefix will be <code>/docs</code>, which identifies all
    ///          objects in the <code>docs/</code> folder. Required when the parent element
    ///             <code>Condition</code> is specified and sibling <code>HttpErrorCodeReturnedEquals</code>
    ///          is not specified. If both conditions are specified, both must be true for the redirect to
    ///          be applied.</p>
    ///          <important>
    ///             <p>Replacement must be made for object keys containing special characters (such as carriage returns) when using
    ///          XML requests. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints">
    ///             XML related object key constraints</a>.</p>
    ///          </important>
    public let keyPrefixEquals: String?

    public init (
        httpErrorCodeReturnedEquals: String? = nil,
        keyPrefixEquals: String? = nil
    )
    {
        self.httpErrorCodeReturnedEquals = httpErrorCodeReturnedEquals
        self.keyPrefixEquals = keyPrefixEquals
    }
}

extension ContinuationEvent: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension ContinuationEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContinuationEvent()"}
}

/// <p></p>
public struct ContinuationEvent: Equatable {

    public init() {}
}

extension CopyObjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyObjectInput(aCL: \(String(describing: aCL)), bucket: \(String(describing: bucket)), bucketKeyEnabled: \(String(describing: bucketKeyEnabled)), cacheControl: \(String(describing: cacheControl)), contentDisposition: \(String(describing: contentDisposition)), contentEncoding: \(String(describing: contentEncoding)), contentLanguage: \(String(describing: contentLanguage)), contentType: \(String(describing: contentType)), copySource: \(String(describing: copySource)), copySourceIfMatch: \(String(describing: copySourceIfMatch)), copySourceIfModifiedSince: \(String(describing: copySourceIfModifiedSince)), copySourceIfNoneMatch: \(String(describing: copySourceIfNoneMatch)), copySourceIfUnmodifiedSince: \(String(describing: copySourceIfUnmodifiedSince)), copySourceSSECustomerAlgorithm: \(String(describing: copySourceSSECustomerAlgorithm)), copySourceSSECustomerKey: \(String(describing: copySourceSSECustomerKey)), copySourceSSECustomerKeyMD5: \(String(describing: copySourceSSECustomerKeyMD5)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), expectedSourceBucketOwner: \(String(describing: expectedSourceBucketOwner)), expires: \(String(describing: expires)), grantFullControl: \(String(describing: grantFullControl)), grantRead: \(String(describing: grantRead)), grantReadACP: \(String(describing: grantReadACP)), grantWriteACP: \(String(describing: grantWriteACP)), key: \(String(describing: key)), metadata: \(String(describing: metadata)), metadataDirective: \(String(describing: metadataDirective)), objectLockLegalHoldStatus: \(String(describing: objectLockLegalHoldStatus)), objectLockMode: \(String(describing: objectLockMode)), objectLockRetainUntilDate: \(String(describing: objectLockRetainUntilDate)), requestPayer: \(String(describing: requestPayer)), sSECustomerAlgorithm: \(String(describing: sSECustomerAlgorithm)), sSECustomerKey: \(String(describing: sSECustomerKey)), sSECustomerKeyMD5: \(String(describing: sSECustomerKeyMD5)), sSEKMSEncryptionContext: \(String(describing: sSEKMSEncryptionContext)), sSEKMSKeyId: \(String(describing: sSEKMSKeyId)), serverSideEncryption: \(String(describing: serverSideEncryption)), storageClass: \(String(describing: storageClass)), tagging: \(String(describing: tagging)), taggingDirective: \(String(describing: taggingDirective)), websiteRedirectLocation: \(String(describing: websiteRedirectLocation)))"}
}

extension CopyObjectInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CopyObjectInputHeadersMiddleware: Middleware {
    public let id: String = "CopyObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let aCL = input.operationInput.aCL {
            input.builder.withHeader(name: "x-amz-acl", value: String(aCL.rawValue))
        }
        input.builder.withHeader(name: "x-amz-server-side-encryption-bucket-key-enabled", value: String(input.operationInput.bucketKeyEnabled))
        if let cacheControl = input.operationInput.cacheControl {
            input.builder.withHeader(name: "Cache-Control", value: String(cacheControl))
        }
        if let contentDisposition = input.operationInput.contentDisposition {
            input.builder.withHeader(name: "Content-Disposition", value: String(contentDisposition))
        }
        if let contentEncoding = input.operationInput.contentEncoding {
            input.builder.withHeader(name: "Content-Encoding", value: String(contentEncoding))
        }
        if let contentLanguage = input.operationInput.contentLanguage {
            input.builder.withHeader(name: "Content-Language", value: String(contentLanguage))
        }
        if let contentType = input.operationInput.contentType {
            input.builder.withHeader(name: "Content-Type", value: String(contentType))
        }
        if let copySource = input.operationInput.copySource {
            input.builder.withHeader(name: "x-amz-copy-source", value: String(copySource))
        }
        if let copySourceIfMatch = input.operationInput.copySourceIfMatch {
            input.builder.withHeader(name: "x-amz-copy-source-if-match", value: String(copySourceIfMatch))
        }
        if let copySourceIfModifiedSince = input.operationInput.copySourceIfModifiedSince {
            input.builder.withHeader(name: "x-amz-copy-source-if-modified-since", value: String(copySourceIfModifiedSince.rfc5322()))
        }
        if let copySourceIfNoneMatch = input.operationInput.copySourceIfNoneMatch {
            input.builder.withHeader(name: "x-amz-copy-source-if-none-match", value: String(copySourceIfNoneMatch))
        }
        if let copySourceIfUnmodifiedSince = input.operationInput.copySourceIfUnmodifiedSince {
            input.builder.withHeader(name: "x-amz-copy-source-if-unmodified-since", value: String(copySourceIfUnmodifiedSince.rfc5322()))
        }
        if let copySourceSSECustomerAlgorithm = input.operationInput.copySourceSSECustomerAlgorithm {
            input.builder.withHeader(name: "x-amz-copy-source-server-side-encryption-customer-algorithm", value: String(copySourceSSECustomerAlgorithm))
        }
        if let copySourceSSECustomerKey = input.operationInput.copySourceSSECustomerKey {
            input.builder.withHeader(name: "x-amz-copy-source-server-side-encryption-customer-key", value: String(copySourceSSECustomerKey))
        }
        if let copySourceSSECustomerKeyMD5 = input.operationInput.copySourceSSECustomerKeyMD5 {
            input.builder.withHeader(name: "x-amz-copy-source-server-side-encryption-customer-key-MD5", value: String(copySourceSSECustomerKeyMD5))
        }
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let expectedSourceBucketOwner = input.operationInput.expectedSourceBucketOwner {
            input.builder.withHeader(name: "x-amz-source-expected-bucket-owner", value: String(expectedSourceBucketOwner))
        }
        if let expires = input.operationInput.expires {
            input.builder.withHeader(name: "Expires", value: String(expires.rfc5322()))
        }
        if let grantFullControl = input.operationInput.grantFullControl {
            input.builder.withHeader(name: "x-amz-grant-full-control", value: String(grantFullControl))
        }
        if let grantRead = input.operationInput.grantRead {
            input.builder.withHeader(name: "x-amz-grant-read", value: String(grantRead))
        }
        if let grantReadACP = input.operationInput.grantReadACP {
            input.builder.withHeader(name: "x-amz-grant-read-acp", value: String(grantReadACP))
        }
        if let grantWriteACP = input.operationInput.grantWriteACP {
            input.builder.withHeader(name: "x-amz-grant-write-acp", value: String(grantWriteACP))
        }
        if let metadataDirective = input.operationInput.metadataDirective {
            input.builder.withHeader(name: "x-amz-metadata-directive", value: String(metadataDirective.rawValue))
        }
        if let objectLockLegalHoldStatus = input.operationInput.objectLockLegalHoldStatus {
            input.builder.withHeader(name: "x-amz-object-lock-legal-hold", value: String(objectLockLegalHoldStatus.rawValue))
        }
        if let objectLockMode = input.operationInput.objectLockMode {
            input.builder.withHeader(name: "x-amz-object-lock-mode", value: String(objectLockMode.rawValue))
        }
        if let objectLockRetainUntilDate = input.operationInput.objectLockRetainUntilDate {
            input.builder.withHeader(name: "x-amz-object-lock-retain-until-date", value: String(objectLockRetainUntilDate.iso8601WithoutFractionalSeconds()))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        if let sSECustomerAlgorithm = input.operationInput.sSECustomerAlgorithm {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-algorithm", value: String(sSECustomerAlgorithm))
        }
        if let sSECustomerKey = input.operationInput.sSECustomerKey {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-key", value: String(sSECustomerKey))
        }
        if let sSECustomerKeyMD5 = input.operationInput.sSECustomerKeyMD5 {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-key-MD5", value: String(sSECustomerKeyMD5))
        }
        if let sSEKMSEncryptionContext = input.operationInput.sSEKMSEncryptionContext {
            input.builder.withHeader(name: "x-amz-server-side-encryption-context", value: String(sSEKMSEncryptionContext))
        }
        if let sSEKMSKeyId = input.operationInput.sSEKMSKeyId {
            input.builder.withHeader(name: "x-amz-server-side-encryption-aws-kms-key-id", value: String(sSEKMSKeyId))
        }
        if let serverSideEncryption = input.operationInput.serverSideEncryption {
            input.builder.withHeader(name: "x-amz-server-side-encryption", value: String(serverSideEncryption.rawValue))
        }
        if let storageClass = input.operationInput.storageClass {
            input.builder.withHeader(name: "x-amz-storage-class", value: String(storageClass.rawValue))
        }
        if let tagging = input.operationInput.tagging {
            input.builder.withHeader(name: "x-amz-tagging", value: String(tagging))
        }
        if let taggingDirective = input.operationInput.taggingDirective {
            input.builder.withHeader(name: "x-amz-tagging-directive", value: String(taggingDirective.rawValue))
        }
        if let websiteRedirectLocation = input.operationInput.websiteRedirectLocation {
            input.builder.withHeader(name: "x-amz-website-redirect-location", value: String(websiteRedirectLocation))
        }
        if let metadata = input.operationInput.metadata {
            for (prefixHeaderMapKey, prefixHeaderMapValue) in metadata {
                input.builder.withHeader(name: "x-amz-meta-\(prefixHeaderMapKey)", value: String(prefixHeaderMapValue))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyObjectInput>
    public typealias MOutput = OperationOutput<CopyObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyObjectOutputError>
}

public struct CopyObjectInputQueryItemMiddleware: Middleware {
    public let id: String = "CopyObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "x-id", value: "CopyObject"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyObjectInput>
    public typealias MOutput = OperationOutput<CopyObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyObjectOutputError>
}

public struct CopyObjectInput: Equatable {
    /// <p>The canned ACL to apply to the object.</p>
    ///          <p>This action is not supported by Amazon S3 on Outposts.</p>
    public let aCL: ObjectCannedACL?
    /// <p>The name of the destination bucket.</p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to <code>true</code> causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS. </p>
    ///          <p>Specifying this header with a COPY action doesnt affect bucket-level settings for S3 Bucket Key.</p>
    public let bucketKeyEnabled: Bool
    /// <p>Specifies caching behavior along the request/reply chain.</p>
    public let cacheControl: String?
    /// <p>Specifies presentational information for the object.</p>
    public let contentDisposition: String?
    /// <p>Specifies what content encodings have been applied to the object and thus what decoding
    ///          mechanisms must be applied to obtain the media-type referenced by the Content-Type header
    ///          field.</p>
    public let contentEncoding: String?
    /// <p>The language the content is in.</p>
    public let contentLanguage: String?
    /// <p>A standard MIME type describing the format of the object data.</p>
    public let contentType: String?
    /// <p>Specifies the source object for the copy operation. You specify the value in one of two
    ///          formats, depending on whether you want to access the source object through an <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points.html">access point</a>:</p>
    ///          <ul>
    ///             <li>
    ///                <p>For objects not accessed through an access point, specify the name of the source
    ///                bucket and the key of the source object, separated by a slash (/). For example, to
    ///                copy the object <code>reports/january.pdf</code> from the bucket
    ///                   <code>awsexamplebucket</code>, use
    ///                   <code>awsexamplebucket/reports/january.pdf</code>. The value must be URL
    ///                encoded.</p>
    ///             </li>
    ///             <li>
    ///                <p>For objects accessed through access points, specify the Amazon Resource Name (ARN) of the object as accessed through the access point, in the format <code>arn:aws:s3:<Region>:<account-id>:accesspoint/<access-point-name>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through access point <code>my-access-point</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3:us-west-2:123456789012:accesspoint/my-access-point/object/reports/january.pdf</code>. The value must be URL encoded.</p>
    ///                <note>
    ///                   <p>Amazon S3 supports copy operations using access points only when the source and destination buckets are in the same AWS Region.</p>
    ///                </note>
    ///                <p>Alternatively, for objects accessed through Amazon S3 on Outposts, specify the ARN of the object as accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/object/reports/january.pdf</code>. The value must be URL encoded.  </p>
    ///             </li>
    ///          </ul>
    ///          <p>To copy a specific version of an object, append <code>?versionId=<version-id></code>
    ///          to the value (for example,
    ///             <code>awsexamplebucket/reports/january.pdf?versionId=QUpfdndhfd8438MNFDN93jdnJFkdmqnh893</code>).
    ///          If you don't specify a version ID, Amazon S3 copies the latest version of the source
    ///          object.</p>
    public let copySource: String?
    /// <p>Copies the object if its entity tag (ETag) matches the specified tag.</p>
    public let copySourceIfMatch: String?
    /// <p>Copies the object if it has been modified since the specified time.</p>
    public let copySourceIfModifiedSince: Date?
    /// <p>Copies the object if its entity tag (ETag) is different than the specified ETag.</p>
    public let copySourceIfNoneMatch: String?
    /// <p>Copies the object if it hasn't been modified since the specified time.</p>
    public let copySourceIfUnmodifiedSince: Date?
    /// <p>Specifies the algorithm to use when decrypting the source object (for example,
    ///          AES256).</p>
    public let copySourceSSECustomerAlgorithm: String?
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use to decrypt the source
    ///          object. The encryption key provided in this header must be one that was used when the
    ///          source object was created.</p>
    public let copySourceSSECustomerKey: String?
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    ///          this header for a message integrity check to ensure that the encryption key was transmitted
    ///          without error.</p>
    public let copySourceSSECustomerKeyMD5: String?
    /// <p>The account ID of the expected destination bucket owner. If the destination bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The account ID of the expected source bucket owner. If the source bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedSourceBucketOwner: String?
    /// <p>The date and time at which the object is no longer cacheable.</p>
    public let expires: Date?
    /// <p>Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the
    ///       object.</p>
    ///          <p>This action is not supported by Amazon S3 on Outposts.</p>
    public let grantFullControl: String?
    /// <p>Allows grantee to read the object data and its
    ///       metadata.</p>
    ///          <p>This action is not supported by Amazon S3 on Outposts.</p>
    public let grantRead: String?
    /// <p>Allows grantee to read the object ACL.</p>
    ///          <p>This action is not supported by Amazon S3 on Outposts.</p>
    public let grantReadACP: String?
    /// <p>Allows grantee to write the ACL for the applicable
    ///       object.</p>
    ///          <p>This action is not supported by Amazon S3 on Outposts.</p>
    public let grantWriteACP: String?
    /// <p>The key of the destination object.</p>
    public let key: String?
    /// <p>A map of metadata to store with the object in S3.</p>
    public let metadata: [String:String]?
    /// <p>Specifies whether the metadata is copied from the source object or replaced with
    ///          metadata provided in the request.</p>
    public let metadataDirective: MetadataDirective?
    /// <p>Specifies whether you want to apply a Legal Hold to the copied object.</p>
    public let objectLockLegalHoldStatus: ObjectLockLegalHoldStatus?
    /// <p>The Object Lock mode that you want to apply to the copied object.</p>
    public let objectLockMode: ObjectLockMode?
    /// <p>The date and time when you want the copied object's Object Lock to expire.</p>
    public let objectLockRetainUntilDate: Date?
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    ///          owners need not specify this parameter in their requests. For information about downloading
    ///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    ///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let requestPayer: RequestPayer?
    /// <p>Specifies the algorithm to use to when encrypting the object (for example,
    ///          AES256).</p>
    public let sSECustomerAlgorithm: String?
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
    ///          value is used to store the object and then it is discarded; Amazon S3 does not store the
    ///          encryption key. The key must be appropriate for use with the algorithm specified in the
    ///             <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
    public let sSECustomerKey: String?
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    ///          this header for a message integrity check to ensure that the encryption key was transmitted
    ///          without error.</p>
    public let sSECustomerKeyMD5: String?
    /// <p>Specifies the AWS KMS Encryption Context to use for object encryption. The value of this
    ///          header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value
    ///          pairs.</p>
    public let sSEKMSEncryptionContext: String?
    /// <p>Specifies the AWS KMS key ID to use for object encryption. All GET and PUT requests for
    ///          an object protected by AWS KMS will fail if not made via SSL or using SigV4. For
    ///          information about configuring using any of the officially supported AWS SDKs and AWS CLI,
    ///          see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version">Specifying the
    ///             Signature Version in Request Authentication</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let sSEKMSKeyId: String?
    /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
    ///          AES256, aws:kms).</p>
    public let serverSideEncryption: ServerSideEncryption?
    /// <p>By default, Amazon S3 uses the STANDARD Storage Class to store newly created objects. The
    ///          STANDARD storage class provides high durability and high availability. Depending on
    ///          performance needs, you can specify a different Storage Class. Amazon S3 on Outposts only uses
    ///          the OUTPOSTS Storage Class. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html">Storage Classes</a> in the
    ///          <i>Amazon S3 User Guide</i>.</p>
    public let storageClass: StorageClass?
    /// <p>The tag-set for the object destination object this value must be used in conjunction
    ///          with the <code>TaggingDirective</code>. The tag-set must be encoded as URL Query
    ///          parameters.</p>
    public let tagging: String?
    /// <p>Specifies whether the object tag-set are copied from the source object or replaced with
    ///          tag-set provided in the request.</p>
    public let taggingDirective: TaggingDirective?
    /// <p>If the bucket is configured as a website, redirects requests for this object to another
    ///          object in the same bucket or to an external URL. Amazon S3 stores the value of this header in
    ///          the object metadata.</p>
    public let websiteRedirectLocation: String?

    public init (
        aCL: ObjectCannedACL? = nil,
        bucket: String? = nil,
        bucketKeyEnabled: Bool = false,
        cacheControl: String? = nil,
        contentDisposition: String? = nil,
        contentEncoding: String? = nil,
        contentLanguage: String? = nil,
        contentType: String? = nil,
        copySource: String? = nil,
        copySourceIfMatch: String? = nil,
        copySourceIfModifiedSince: Date? = nil,
        copySourceIfNoneMatch: String? = nil,
        copySourceIfUnmodifiedSince: Date? = nil,
        copySourceSSECustomerAlgorithm: String? = nil,
        copySourceSSECustomerKey: String? = nil,
        copySourceSSECustomerKeyMD5: String? = nil,
        expectedBucketOwner: String? = nil,
        expectedSourceBucketOwner: String? = nil,
        expires: Date? = nil,
        grantFullControl: String? = nil,
        grantRead: String? = nil,
        grantReadACP: String? = nil,
        grantWriteACP: String? = nil,
        key: String? = nil,
        metadata: [String:String]? = nil,
        metadataDirective: MetadataDirective? = nil,
        objectLockLegalHoldStatus: ObjectLockLegalHoldStatus? = nil,
        objectLockMode: ObjectLockMode? = nil,
        objectLockRetainUntilDate: Date? = nil,
        requestPayer: RequestPayer? = nil,
        sSECustomerAlgorithm: String? = nil,
        sSECustomerKey: String? = nil,
        sSECustomerKeyMD5: String? = nil,
        sSEKMSEncryptionContext: String? = nil,
        sSEKMSKeyId: String? = nil,
        serverSideEncryption: ServerSideEncryption? = nil,
        storageClass: StorageClass? = nil,
        tagging: String? = nil,
        taggingDirective: TaggingDirective? = nil,
        websiteRedirectLocation: String? = nil
    )
    {
        self.aCL = aCL
        self.bucket = bucket
        self.bucketKeyEnabled = bucketKeyEnabled
        self.cacheControl = cacheControl
        self.contentDisposition = contentDisposition
        self.contentEncoding = contentEncoding
        self.contentLanguage = contentLanguage
        self.contentType = contentType
        self.copySource = copySource
        self.copySourceIfMatch = copySourceIfMatch
        self.copySourceIfModifiedSince = copySourceIfModifiedSince
        self.copySourceIfNoneMatch = copySourceIfNoneMatch
        self.copySourceIfUnmodifiedSince = copySourceIfUnmodifiedSince
        self.copySourceSSECustomerAlgorithm = copySourceSSECustomerAlgorithm
        self.copySourceSSECustomerKey = copySourceSSECustomerKey
        self.copySourceSSECustomerKeyMD5 = copySourceSSECustomerKeyMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.expectedSourceBucketOwner = expectedSourceBucketOwner
        self.expires = expires
        self.grantFullControl = grantFullControl
        self.grantRead = grantRead
        self.grantReadACP = grantReadACP
        self.grantWriteACP = grantWriteACP
        self.key = key
        self.metadata = metadata
        self.metadataDirective = metadataDirective
        self.objectLockLegalHoldStatus = objectLockLegalHoldStatus
        self.objectLockMode = objectLockMode
        self.objectLockRetainUntilDate = objectLockRetainUntilDate
        self.requestPayer = requestPayer
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKey = sSECustomerKey
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.sSEKMSEncryptionContext = sSEKMSEncryptionContext
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
        self.storageClass = storageClass
        self.tagging = tagging
        self.taggingDirective = taggingDirective
        self.websiteRedirectLocation = websiteRedirectLocation
    }
}

struct CopyObjectInputBody: Equatable {
}

extension CopyObjectInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CopyObjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyObjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ObjectNotInActiveTierError" : self = .objectNotInActiveTierError(try ObjectNotInActiveTierError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyObjectOutputError: Equatable {
    case objectNotInActiveTierError(ObjectNotInActiveTierError)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyObjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyObjectOutputResponse(bucketKeyEnabled: \(String(describing: bucketKeyEnabled)), copyObjectResult: \(String(describing: copyObjectResult)), copySourceVersionId: \(String(describing: copySourceVersionId)), expiration: \(String(describing: expiration)), requestCharged: \(String(describing: requestCharged)), sSECustomerAlgorithm: \(String(describing: sSECustomerAlgorithm)), sSECustomerKeyMD5: \(String(describing: sSECustomerKeyMD5)), sSEKMSEncryptionContext: \(String(describing: sSEKMSEncryptionContext)), sSEKMSKeyId: \(String(describing: sSEKMSKeyId)), serverSideEncryption: \(String(describing: serverSideEncryption)), versionId: \(String(describing: versionId)))"}
}

extension CopyObjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let bucketKeyEnabledHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-bucket-key-enabled") {
            self.bucketKeyEnabled = Bool(bucketKeyEnabledHeaderValue) ?? false
        } else {
            self.bucketKeyEnabled = false
        }
        if let copySourceVersionIdHeaderValue = httpResponse.headers.value(for: "x-amz-copy-source-version-id") {
            self.copySourceVersionId = copySourceVersionIdHeaderValue
        } else {
            self.copySourceVersionId = nil
        }
        if let expirationHeaderValue = httpResponse.headers.value(for: "x-amz-expiration") {
            self.expiration = expirationHeaderValue
        } else {
            self.expiration = nil
        }
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if let sSECustomerAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-algorithm") {
            self.sSECustomerAlgorithm = sSECustomerAlgorithmHeaderValue
        } else {
            self.sSECustomerAlgorithm = nil
        }
        if let sSECustomerKeyMD5HeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-key-MD5") {
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5HeaderValue
        } else {
            self.sSECustomerKeyMD5 = nil
        }
        if let sSEKMSEncryptionContextHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-context") {
            self.sSEKMSEncryptionContext = sSEKMSEncryptionContextHeaderValue
        } else {
            self.sSEKMSEncryptionContext = nil
        }
        if let sSEKMSKeyIdHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-aws-kms-key-id") {
            self.sSEKMSKeyId = sSEKMSKeyIdHeaderValue
        } else {
            self.sSEKMSKeyId = nil
        }
        if let serverSideEncryptionHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption") {
            self.serverSideEncryption = ServerSideEncryption(rawValue: serverSideEncryptionHeaderValue)
        } else {
            self.serverSideEncryption = nil
        }
        if let versionIdHeaderValue = httpResponse.headers.value(for: "x-amz-version-id") {
            self.versionId = versionIdHeaderValue
        } else {
            self.versionId = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CopyObjectResult = try responseDecoder.decode(responseBody: unwrappedData)
                self.copyObjectResult = output
            } else {
                self.copyObjectResult = nil
            }
        } else {
            self.copyObjectResult = nil
        }
    }
}

public struct CopyObjectOutputResponse: Equatable {
    /// <p>Indicates whether the copied object uses an S3 Bucket Key for server-side encryption with AWS KMS (SSE-KMS).</p>
    public let bucketKeyEnabled: Bool
    /// <p>Container for all response elements.</p>
    public let copyObjectResult: CopyObjectResult?
    /// <p>Version of the copied object in the destination bucket.</p>
    public let copySourceVersionId: String?
    /// <p>If the object expiration is configured, the response includes this header.</p>
    public let expiration: String?
    /// <p>If present, indicates that the requester was successfully charged for the
    ///          request.</p>
    public let requestCharged: RequestCharged?
    /// <p>If server-side encryption with a customer-provided encryption key was requested, the
    ///          response will include this header confirming the encryption algorithm used.</p>
    public let sSECustomerAlgorithm: String?
    /// <p>If server-side encryption with a customer-provided encryption key was requested, the
    ///          response will include this header to provide round-trip message integrity verification of
    ///          the customer-provided encryption key.</p>
    public let sSECustomerKeyMD5: String?
    /// <p>If present, specifies the AWS KMS Encryption Context to use for object encryption. The
    ///          value of this header is a base64-encoded UTF-8 string holding JSON with the encryption
    ///          context key-value pairs.</p>
    public let sSEKMSEncryptionContext: String?
    /// <p>If present, specifies the ID of the AWS Key Management Service (AWS KMS) symmetric
    ///          customer managed customer master key (CMK) that was used for the object.</p>
    public let sSEKMSKeyId: String?
    /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
    ///          AES256, aws:kms).</p>
    public let serverSideEncryption: ServerSideEncryption?
    /// <p>Version ID of the newly created copy.</p>
    public let versionId: String?

    public init (
        bucketKeyEnabled: Bool = false,
        copyObjectResult: CopyObjectResult? = nil,
        copySourceVersionId: String? = nil,
        expiration: String? = nil,
        requestCharged: RequestCharged? = nil,
        sSECustomerAlgorithm: String? = nil,
        sSECustomerKeyMD5: String? = nil,
        sSEKMSEncryptionContext: String? = nil,
        sSEKMSKeyId: String? = nil,
        serverSideEncryption: ServerSideEncryption? = nil,
        versionId: String? = nil
    )
    {
        self.bucketKeyEnabled = bucketKeyEnabled
        self.copyObjectResult = copyObjectResult
        self.copySourceVersionId = copySourceVersionId
        self.expiration = expiration
        self.requestCharged = requestCharged
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.sSEKMSEncryptionContext = sSEKMSEncryptionContext
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
        self.versionId = versionId
    }
}

struct CopyObjectOutputResponseBody: Equatable {
    public let copyObjectResult: CopyObjectResult?
}

extension CopyObjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case copyObjectResult = "CopyObjectResult"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyObjectResultDecoded = try containerValues.decodeIfPresent(CopyObjectResult.self, forKey: .copyObjectResult)
        copyObjectResult = copyObjectResultDecoded
    }
}

extension CopyObjectResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eTag = "ETag"
        case lastModified = "LastModified"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let eTag = eTag {
            try container.encode(eTag, forKey: Key("eTag"))
        }
        if let lastModified = lastModified {
            try container.encode(TimestampWrapper(lastModified, format: .dateTime), forKey: Key("lastModified"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eTagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eTag)
        eTag = eTagDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModified)
        var lastModifiedBuffer:Date? = nil
        if let lastModifiedDecoded = lastModifiedDecoded {
            lastModifiedBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastModifiedDecoded, format: .dateTime)
        }
        lastModified = lastModifiedBuffer
    }
}

extension CopyObjectResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyObjectResult(eTag: \(String(describing: eTag)), lastModified: \(String(describing: lastModified)))"}
}

extension CopyObjectResult: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container for all response elements.</p>
public struct CopyObjectResult: Equatable {
    /// <p>Returns the ETag of the new object. The ETag reflects only changes to the contents of an
    ///          object, not its metadata. The source and destination ETag is identical for a successfully
    ///          copied non-multipart object.</p>
    public let eTag: String?
    /// <p>Creation date of the object.</p>
    public let lastModified: Date?

    public init (
        eTag: String? = nil,
        lastModified: Date? = nil
    )
    {
        self.eTag = eTag
        self.lastModified = lastModified
    }
}

extension CopyPartResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eTag = "ETag"
        case lastModified = "LastModified"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let eTag = eTag {
            try container.encode(eTag, forKey: Key("eTag"))
        }
        if let lastModified = lastModified {
            try container.encode(TimestampWrapper(lastModified, format: .dateTime), forKey: Key("lastModified"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eTagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eTag)
        eTag = eTagDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModified)
        var lastModifiedBuffer:Date? = nil
        if let lastModifiedDecoded = lastModifiedDecoded {
            lastModifiedBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastModifiedDecoded, format: .dateTime)
        }
        lastModified = lastModifiedBuffer
    }
}

extension CopyPartResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyPartResult(eTag: \(String(describing: eTag)), lastModified: \(String(describing: lastModified)))"}
}

extension CopyPartResult: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container for all response elements.</p>
public struct CopyPartResult: Equatable {
    /// <p>Entity tag of the object.</p>
    public let eTag: String?
    /// <p>Date and time at which the object was uploaded.</p>
    public let lastModified: Date?

    public init (
        eTag: String? = nil,
        lastModified: Date? = nil
    )
    {
        self.eTag = eTag
        self.lastModified = lastModified
    }
}

extension CreateBucketConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case locationConstraint = "LocationConstraint"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let locationConstraint = locationConstraint {
            try container.encode(locationConstraint, forKey: Key("locationConstraint"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationConstraintDecoded = try containerValues.decodeIfPresent(BucketLocationConstraint.self, forKey: .locationConstraint)
        locationConstraint = locationConstraintDecoded
    }
}

extension CreateBucketConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBucketConfiguration(locationConstraint: \(String(describing: locationConstraint)))"}
}

extension CreateBucketConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The configuration information for the bucket.</p>
public struct CreateBucketConfiguration: Equatable {
    /// <p>Specifies the Region where the bucket will be created. If you don't specify a Region,
    ///          the bucket is created in the US East (N. Virginia) Region (us-east-1).</p>
    public let locationConstraint: BucketLocationConstraint?

    public init (
        locationConstraint: BucketLocationConstraint? = nil
    )
    {
        self.locationConstraint = locationConstraint
    }
}

public struct CreateBucketInputBodyMiddleware: Middleware {
    public let id: String = "CreateBucketInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBucketInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBucketOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let createBucketConfiguration = input.operationInput.createBucketConfiguration {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(createBucketConfiguration)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBucketInput>
    public typealias MOutput = OperationOutput<CreateBucketOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBucketOutputError>
}

extension CreateBucketInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBucketInput(aCL: \(String(describing: aCL)), bucket: \(String(describing: bucket)), createBucketConfiguration: \(String(describing: createBucketConfiguration)), grantFullControl: \(String(describing: grantFullControl)), grantRead: \(String(describing: grantRead)), grantReadACP: \(String(describing: grantReadACP)), grantWrite: \(String(describing: grantWrite)), grantWriteACP: \(String(describing: grantWriteACP)), objectLockEnabledForBucket: \(String(describing: objectLockEnabledForBucket)))"}
}

extension CreateBucketInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateBucketInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createBucketConfiguration = "CreateBucketConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let createBucketConfiguration = createBucketConfiguration {
            try container.encode(createBucketConfiguration, forKey: Key("CreateBucketConfiguration"))
        }
    }
}

public struct CreateBucketInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBucketInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBucketInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBucketOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let aCL = input.operationInput.aCL {
            input.builder.withHeader(name: "x-amz-acl", value: String(aCL.rawValue))
        }
        if let grantFullControl = input.operationInput.grantFullControl {
            input.builder.withHeader(name: "x-amz-grant-full-control", value: String(grantFullControl))
        }
        if let grantRead = input.operationInput.grantRead {
            input.builder.withHeader(name: "x-amz-grant-read", value: String(grantRead))
        }
        if let grantReadACP = input.operationInput.grantReadACP {
            input.builder.withHeader(name: "x-amz-grant-read-acp", value: String(grantReadACP))
        }
        if let grantWrite = input.operationInput.grantWrite {
            input.builder.withHeader(name: "x-amz-grant-write", value: String(grantWrite))
        }
        if let grantWriteACP = input.operationInput.grantWriteACP {
            input.builder.withHeader(name: "x-amz-grant-write-acp", value: String(grantWriteACP))
        }
        input.builder.withHeader(name: "x-amz-bucket-object-lock-enabled", value: String(input.operationInput.objectLockEnabledForBucket))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBucketInput>
    public typealias MOutput = OperationOutput<CreateBucketOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBucketOutputError>
}

public struct CreateBucketInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBucketInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBucketInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBucketOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBucketInput>
    public typealias MOutput = OperationOutput<CreateBucketOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBucketOutputError>
}

public struct CreateBucketInput: Equatable {
    /// <p>The canned ACL to apply to the bucket.</p>
    public let aCL: BucketCannedACL?
    /// <p>The name of the bucket to create.</p>
    public let bucket: String?
    /// <p>The configuration information for the bucket.</p>
    public let createBucketConfiguration: CreateBucketConfiguration?
    /// <p>Allows grantee the read, write, read ACP, and write ACP permissions on the
    ///          bucket.</p>
    public let grantFullControl: String?
    /// <p>Allows grantee to list the objects in the bucket.</p>
    public let grantRead: String?
    /// <p>Allows grantee to read the bucket ACL.</p>
    public let grantReadACP: String?
    /// <p>Allows grantee to create new objects in the bucket.</p>
    ///          <p>For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects.</p>
    public let grantWrite: String?
    /// <p>Allows grantee to write the ACL for the applicable bucket.</p>
    public let grantWriteACP: String?
    /// <p>Specifies whether you want S3 Object Lock to be enabled for the new bucket.</p>
    public let objectLockEnabledForBucket: Bool

    public init (
        aCL: BucketCannedACL? = nil,
        bucket: String? = nil,
        createBucketConfiguration: CreateBucketConfiguration? = nil,
        grantFullControl: String? = nil,
        grantRead: String? = nil,
        grantReadACP: String? = nil,
        grantWrite: String? = nil,
        grantWriteACP: String? = nil,
        objectLockEnabledForBucket: Bool = false
    )
    {
        self.aCL = aCL
        self.bucket = bucket
        self.createBucketConfiguration = createBucketConfiguration
        self.grantFullControl = grantFullControl
        self.grantRead = grantRead
        self.grantReadACP = grantReadACP
        self.grantWrite = grantWrite
        self.grantWriteACP = grantWriteACP
        self.objectLockEnabledForBucket = objectLockEnabledForBucket
    }
}

struct CreateBucketInputBody: Equatable {
    public let createBucketConfiguration: CreateBucketConfiguration?
}

extension CreateBucketInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createBucketConfiguration = "CreateBucketConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createBucketConfigurationDecoded = try containerValues.decodeIfPresent(CreateBucketConfiguration.self, forKey: .createBucketConfiguration)
        createBucketConfiguration = createBucketConfigurationDecoded
    }
}

extension CreateBucketOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateBucketOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BucketAlreadyExists" : self = .bucketAlreadyExists(try BucketAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BucketAlreadyOwnedByYou" : self = .bucketAlreadyOwnedByYou(try BucketAlreadyOwnedByYou(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBucketOutputError: Equatable {
    case bucketAlreadyExists(BucketAlreadyExists)
    case bucketAlreadyOwnedByYou(BucketAlreadyOwnedByYou)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBucketOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBucketOutputResponse(location: \(String(describing: location)))"}
}

extension CreateBucketOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
    }
}

public struct CreateBucketOutputResponse: Equatable {
    /// <p>Specifies the Region where the bucket will be created. If you are creating a bucket on
    ///          the US East (N. Virginia) Region (us-east-1), you do not need to specify the
    ///          location.</p>
    public let location: String?

    public init (
        location: String? = nil
    )
    {
        self.location = location
    }
}

struct CreateBucketOutputResponseBody: Equatable {
}

extension CreateBucketOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CreateMultipartUploadInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMultipartUploadInput(aCL: \(String(describing: aCL)), bucket: \(String(describing: bucket)), bucketKeyEnabled: \(String(describing: bucketKeyEnabled)), cacheControl: \(String(describing: cacheControl)), contentDisposition: \(String(describing: contentDisposition)), contentEncoding: \(String(describing: contentEncoding)), contentLanguage: \(String(describing: contentLanguage)), contentType: \(String(describing: contentType)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), expires: \(String(describing: expires)), grantFullControl: \(String(describing: grantFullControl)), grantRead: \(String(describing: grantRead)), grantReadACP: \(String(describing: grantReadACP)), grantWriteACP: \(String(describing: grantWriteACP)), key: \(String(describing: key)), metadata: \(String(describing: metadata)), objectLockLegalHoldStatus: \(String(describing: objectLockLegalHoldStatus)), objectLockMode: \(String(describing: objectLockMode)), objectLockRetainUntilDate: \(String(describing: objectLockRetainUntilDate)), requestPayer: \(String(describing: requestPayer)), sSECustomerAlgorithm: \(String(describing: sSECustomerAlgorithm)), sSECustomerKey: \(String(describing: sSECustomerKey)), sSECustomerKeyMD5: \(String(describing: sSECustomerKeyMD5)), sSEKMSEncryptionContext: \(String(describing: sSEKMSEncryptionContext)), sSEKMSKeyId: \(String(describing: sSEKMSKeyId)), serverSideEncryption: \(String(describing: serverSideEncryption)), storageClass: \(String(describing: storageClass)), tagging: \(String(describing: tagging)), websiteRedirectLocation: \(String(describing: websiteRedirectLocation)))"}
}

extension CreateMultipartUploadInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CreateMultipartUploadInputHeadersMiddleware: Middleware {
    public let id: String = "CreateMultipartUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMultipartUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMultipartUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let aCL = input.operationInput.aCL {
            input.builder.withHeader(name: "x-amz-acl", value: String(aCL.rawValue))
        }
        input.builder.withHeader(name: "x-amz-server-side-encryption-bucket-key-enabled", value: String(input.operationInput.bucketKeyEnabled))
        if let cacheControl = input.operationInput.cacheControl {
            input.builder.withHeader(name: "Cache-Control", value: String(cacheControl))
        }
        if let contentDisposition = input.operationInput.contentDisposition {
            input.builder.withHeader(name: "Content-Disposition", value: String(contentDisposition))
        }
        if let contentEncoding = input.operationInput.contentEncoding {
            input.builder.withHeader(name: "Content-Encoding", value: String(contentEncoding))
        }
        if let contentLanguage = input.operationInput.contentLanguage {
            input.builder.withHeader(name: "Content-Language", value: String(contentLanguage))
        }
        if let contentType = input.operationInput.contentType {
            input.builder.withHeader(name: "Content-Type", value: String(contentType))
        }
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let expires = input.operationInput.expires {
            input.builder.withHeader(name: "Expires", value: String(expires.rfc5322()))
        }
        if let grantFullControl = input.operationInput.grantFullControl {
            input.builder.withHeader(name: "x-amz-grant-full-control", value: String(grantFullControl))
        }
        if let grantRead = input.operationInput.grantRead {
            input.builder.withHeader(name: "x-amz-grant-read", value: String(grantRead))
        }
        if let grantReadACP = input.operationInput.grantReadACP {
            input.builder.withHeader(name: "x-amz-grant-read-acp", value: String(grantReadACP))
        }
        if let grantWriteACP = input.operationInput.grantWriteACP {
            input.builder.withHeader(name: "x-amz-grant-write-acp", value: String(grantWriteACP))
        }
        if let objectLockLegalHoldStatus = input.operationInput.objectLockLegalHoldStatus {
            input.builder.withHeader(name: "x-amz-object-lock-legal-hold", value: String(objectLockLegalHoldStatus.rawValue))
        }
        if let objectLockMode = input.operationInput.objectLockMode {
            input.builder.withHeader(name: "x-amz-object-lock-mode", value: String(objectLockMode.rawValue))
        }
        if let objectLockRetainUntilDate = input.operationInput.objectLockRetainUntilDate {
            input.builder.withHeader(name: "x-amz-object-lock-retain-until-date", value: String(objectLockRetainUntilDate.iso8601WithoutFractionalSeconds()))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        if let sSECustomerAlgorithm = input.operationInput.sSECustomerAlgorithm {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-algorithm", value: String(sSECustomerAlgorithm))
        }
        if let sSECustomerKey = input.operationInput.sSECustomerKey {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-key", value: String(sSECustomerKey))
        }
        if let sSECustomerKeyMD5 = input.operationInput.sSECustomerKeyMD5 {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-key-MD5", value: String(sSECustomerKeyMD5))
        }
        if let sSEKMSEncryptionContext = input.operationInput.sSEKMSEncryptionContext {
            input.builder.withHeader(name: "x-amz-server-side-encryption-context", value: String(sSEKMSEncryptionContext))
        }
        if let sSEKMSKeyId = input.operationInput.sSEKMSKeyId {
            input.builder.withHeader(name: "x-amz-server-side-encryption-aws-kms-key-id", value: String(sSEKMSKeyId))
        }
        if let serverSideEncryption = input.operationInput.serverSideEncryption {
            input.builder.withHeader(name: "x-amz-server-side-encryption", value: String(serverSideEncryption.rawValue))
        }
        if let storageClass = input.operationInput.storageClass {
            input.builder.withHeader(name: "x-amz-storage-class", value: String(storageClass.rawValue))
        }
        if let tagging = input.operationInput.tagging {
            input.builder.withHeader(name: "x-amz-tagging", value: String(tagging))
        }
        if let websiteRedirectLocation = input.operationInput.websiteRedirectLocation {
            input.builder.withHeader(name: "x-amz-website-redirect-location", value: String(websiteRedirectLocation))
        }
        if let metadata = input.operationInput.metadata {
            for (prefixHeaderMapKey, prefixHeaderMapValue) in metadata {
                input.builder.withHeader(name: "x-amz-meta-\(prefixHeaderMapKey)", value: String(prefixHeaderMapValue))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMultipartUploadInput>
    public typealias MOutput = OperationOutput<CreateMultipartUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMultipartUploadOutputError>
}

public struct CreateMultipartUploadInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateMultipartUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMultipartUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMultipartUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "uploads", value: nil))
        input.builder.withQueryItem(URLQueryItem(name: "x-id", value: "CreateMultipartUpload"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMultipartUploadInput>
    public typealias MOutput = OperationOutput<CreateMultipartUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMultipartUploadOutputError>
}

public struct CreateMultipartUploadInput: Equatable {
    /// <p>The canned ACL to apply to the object.</p>
    ///          <p>This action is not supported by Amazon S3 on Outposts.</p>
    public let aCL: ObjectCannedACL?
    /// <p>The name of the bucket to which to initiate the upload</p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to <code>true</code> causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS.</p>
    ///          <p>Specifying this header with an object action doesnt affect bucket-level settings for S3 Bucket Key.</p>
    public let bucketKeyEnabled: Bool
    /// <p>Specifies caching behavior along the request/reply chain.</p>
    public let cacheControl: String?
    /// <p>Specifies presentational information for the object.</p>
    public let contentDisposition: String?
    /// <p>Specifies what content encodings have been applied to the object and thus what decoding
    ///          mechanisms must be applied to obtain the media-type referenced by the Content-Type header
    ///          field.</p>
    public let contentEncoding: String?
    /// <p>The language the content is in.</p>
    public let contentLanguage: String?
    /// <p>A standard MIME type describing the format of the object data.</p>
    public let contentType: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The date and time at which the object is no longer cacheable.</p>
    public let expires: Date?
    /// <p>Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the
    ///       object.</p>
    ///          <p>This action is not supported by Amazon S3 on Outposts.</p>
    public let grantFullControl: String?
    /// <p>Allows grantee to read the object data and its
    ///       metadata.</p>
    ///          <p>This action is not supported by Amazon S3 on Outposts.</p>
    public let grantRead: String?
    /// <p>Allows grantee to read the object ACL.</p>
    ///          <p>This action is not supported by Amazon S3 on Outposts.</p>
    public let grantReadACP: String?
    /// <p>Allows grantee to write the ACL for the applicable
    ///       object.</p>
    ///          <p>This action is not supported by Amazon S3 on Outposts.</p>
    public let grantWriteACP: String?
    /// <p>Object key for which the multipart upload is to be initiated.</p>
    public let key: String?
    /// <p>A map of metadata to store with the object in S3.</p>
    public let metadata: [String:String]?
    /// <p>Specifies whether you want to apply a Legal Hold to the uploaded object.</p>
    public let objectLockLegalHoldStatus: ObjectLockLegalHoldStatus?
    /// <p>Specifies the Object Lock mode that you want to apply to the uploaded object.</p>
    public let objectLockMode: ObjectLockMode?
    /// <p>Specifies the date and time when you want the Object Lock to expire.</p>
    public let objectLockRetainUntilDate: Date?
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    ///          owners need not specify this parameter in their requests. For information about downloading
    ///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    ///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let requestPayer: RequestPayer?
    /// <p>Specifies the algorithm to use to when encrypting the object (for example,
    ///          AES256).</p>
    public let sSECustomerAlgorithm: String?
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
    ///          value is used to store the object and then it is discarded; Amazon S3 does not store the
    ///          encryption key. The key must be appropriate for use with the algorithm specified in the
    ///             <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
    public let sSECustomerKey: String?
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    ///          this header for a message integrity check to ensure that the encryption key was transmitted
    ///          without error.</p>
    public let sSECustomerKeyMD5: String?
    /// <p>Specifies the AWS KMS Encryption Context to use for object encryption. The value of this
    ///          header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value
    ///          pairs.</p>
    public let sSEKMSEncryptionContext: String?
    /// <p>Specifies the ID of the symmetric customer managed AWS KMS CMK to use for object
    ///          encryption. All GET and PUT requests for an object protected by AWS KMS will fail if not
    ///          made via SSL or using SigV4. For information about configuring using any of the officially
    ///          supported AWS SDKs and AWS CLI, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version">Specifying the Signature Version in Request Authentication</a>
    ///          in the <i>Amazon S3 User Guide</i>.</p>
    public let sSEKMSKeyId: String?
    /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
    ///          AES256, aws:kms).</p>
    public let serverSideEncryption: ServerSideEncryption?
    /// <p>By default, Amazon S3 uses the STANDARD Storage Class to store newly created objects. The
    ///          STANDARD storage class provides high durability and high availability. Depending on
    ///          performance needs, you can specify a different Storage Class. Amazon S3 on Outposts only uses
    ///          the OUTPOSTS Storage Class. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html">Storage Classes</a> in the
    ///          <i>Amazon S3 User Guide</i>.</p>
    public let storageClass: StorageClass?
    /// <p>The tag-set for the object. The tag-set must be encoded as URL Query parameters.</p>
    public let tagging: String?
    /// <p>If the bucket is configured as a website, redirects requests for this object to another
    ///          object in the same bucket or to an external URL. Amazon S3 stores the value of this header in
    ///          the object metadata.</p>
    public let websiteRedirectLocation: String?

    public init (
        aCL: ObjectCannedACL? = nil,
        bucket: String? = nil,
        bucketKeyEnabled: Bool = false,
        cacheControl: String? = nil,
        contentDisposition: String? = nil,
        contentEncoding: String? = nil,
        contentLanguage: String? = nil,
        contentType: String? = nil,
        expectedBucketOwner: String? = nil,
        expires: Date? = nil,
        grantFullControl: String? = nil,
        grantRead: String? = nil,
        grantReadACP: String? = nil,
        grantWriteACP: String? = nil,
        key: String? = nil,
        metadata: [String:String]? = nil,
        objectLockLegalHoldStatus: ObjectLockLegalHoldStatus? = nil,
        objectLockMode: ObjectLockMode? = nil,
        objectLockRetainUntilDate: Date? = nil,
        requestPayer: RequestPayer? = nil,
        sSECustomerAlgorithm: String? = nil,
        sSECustomerKey: String? = nil,
        sSECustomerKeyMD5: String? = nil,
        sSEKMSEncryptionContext: String? = nil,
        sSEKMSKeyId: String? = nil,
        serverSideEncryption: ServerSideEncryption? = nil,
        storageClass: StorageClass? = nil,
        tagging: String? = nil,
        websiteRedirectLocation: String? = nil
    )
    {
        self.aCL = aCL
        self.bucket = bucket
        self.bucketKeyEnabled = bucketKeyEnabled
        self.cacheControl = cacheControl
        self.contentDisposition = contentDisposition
        self.contentEncoding = contentEncoding
        self.contentLanguage = contentLanguage
        self.contentType = contentType
        self.expectedBucketOwner = expectedBucketOwner
        self.expires = expires
        self.grantFullControl = grantFullControl
        self.grantRead = grantRead
        self.grantReadACP = grantReadACP
        self.grantWriteACP = grantWriteACP
        self.key = key
        self.metadata = metadata
        self.objectLockLegalHoldStatus = objectLockLegalHoldStatus
        self.objectLockMode = objectLockMode
        self.objectLockRetainUntilDate = objectLockRetainUntilDate
        self.requestPayer = requestPayer
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKey = sSECustomerKey
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.sSEKMSEncryptionContext = sSEKMSEncryptionContext
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
        self.storageClass = storageClass
        self.tagging = tagging
        self.websiteRedirectLocation = websiteRedirectLocation
    }
}

struct CreateMultipartUploadInputBody: Equatable {
}

extension CreateMultipartUploadInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CreateMultipartUploadOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateMultipartUploadOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMultipartUploadOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMultipartUploadOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMultipartUploadOutputResponse(abortDate: \(String(describing: abortDate)), abortRuleId: \(String(describing: abortRuleId)), bucket: \(String(describing: bucket)), bucketKeyEnabled: \(String(describing: bucketKeyEnabled)), key: \(String(describing: key)), requestCharged: \(String(describing: requestCharged)), sSECustomerAlgorithm: \(String(describing: sSECustomerAlgorithm)), sSECustomerKeyMD5: \(String(describing: sSECustomerKeyMD5)), sSEKMSEncryptionContext: \(String(describing: sSEKMSEncryptionContext)), sSEKMSKeyId: \(String(describing: sSEKMSKeyId)), serverSideEncryption: \(String(describing: serverSideEncryption)), uploadId: \(String(describing: uploadId)))"}
}

extension CreateMultipartUploadOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let abortDateHeaderValue = httpResponse.headers.value(for: "x-amz-abort-date") {
            self.abortDate = DateFormatter.rfc5322DateFormatter.date(from: abortDateHeaderValue)
        } else {
            self.abortDate = nil
        }
        if let abortRuleIdHeaderValue = httpResponse.headers.value(for: "x-amz-abort-rule-id") {
            self.abortRuleId = abortRuleIdHeaderValue
        } else {
            self.abortRuleId = nil
        }
        if let bucketKeyEnabledHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-bucket-key-enabled") {
            self.bucketKeyEnabled = Bool(bucketKeyEnabledHeaderValue) ?? false
        } else {
            self.bucketKeyEnabled = false
        }
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if let sSECustomerAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-algorithm") {
            self.sSECustomerAlgorithm = sSECustomerAlgorithmHeaderValue
        } else {
            self.sSECustomerAlgorithm = nil
        }
        if let sSECustomerKeyMD5HeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-key-MD5") {
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5HeaderValue
        } else {
            self.sSECustomerKeyMD5 = nil
        }
        if let sSEKMSEncryptionContextHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-context") {
            self.sSEKMSEncryptionContext = sSEKMSEncryptionContextHeaderValue
        } else {
            self.sSEKMSEncryptionContext = nil
        }
        if let sSEKMSKeyIdHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-aws-kms-key-id") {
            self.sSEKMSKeyId = sSEKMSKeyIdHeaderValue
        } else {
            self.sSEKMSKeyId = nil
        }
        if let serverSideEncryptionHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption") {
            self.serverSideEncryption = ServerSideEncryption(rawValue: serverSideEncryptionHeaderValue)
        } else {
            self.serverSideEncryption = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateMultipartUploadOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.bucket = output.bucket
            self.key = output.key
            self.uploadId = output.uploadId
        } else {
            self.bucket = nil
            self.key = nil
            self.uploadId = nil
        }
    }
}

public struct CreateMultipartUploadOutputResponse: Equatable {
    /// <p>If the bucket has a lifecycle rule configured with an action to abort incomplete
    ///          multipart uploads and the prefix in the lifecycle rule matches the object name in the
    ///          request, the response includes this header. The header indicates when the initiated
    ///          multipart upload becomes eligible for an abort operation. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config">
    ///             Aborting Incomplete Multipart Uploads Using a Bucket Lifecycle Policy</a>.</p>
    ///
    ///          <p>The response also includes the <code>x-amz-abort-rule-id</code> header that provides the
    ///          ID of the lifecycle configuration rule that defines this action.</p>
    public let abortDate: Date?
    /// <p>This header is returned along with the <code>x-amz-abort-date</code> header. It
    ///          identifies the applicable lifecycle configuration rule that defines the action to abort
    ///          incomplete multipart uploads.</p>
    public let abortRuleId: String?
    /// <p>The name of the bucket to which the multipart upload was initiated. </p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>Indicates whether the multipart upload uses an S3 Bucket Key for server-side encryption with AWS KMS (SSE-KMS).</p>
    public let bucketKeyEnabled: Bool
    /// <p>Object key for which the multipart upload was initiated.</p>
    public let key: String?
    /// <p>If present, indicates that the requester was successfully charged for the
    ///          request.</p>
    public let requestCharged: RequestCharged?
    /// <p>If server-side encryption with a customer-provided encryption key was requested, the
    ///          response will include this header confirming the encryption algorithm used.</p>
    public let sSECustomerAlgorithm: String?
    /// <p>If server-side encryption with a customer-provided encryption key was requested, the
    ///          response will include this header to provide round-trip message integrity verification of
    ///          the customer-provided encryption key.</p>
    public let sSECustomerKeyMD5: String?
    /// <p>If present, specifies the AWS KMS Encryption Context to use for object encryption. The
    ///          value of this header is a base64-encoded UTF-8 string holding JSON with the encryption
    ///          context key-value pairs.</p>
    public let sSEKMSEncryptionContext: String?
    /// <p>If present, specifies the ID of the AWS Key Management Service (AWS KMS) symmetric
    ///          customer managed customer master key (CMK) that was used for the object.</p>
    public let sSEKMSKeyId: String?
    /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
    ///          AES256, aws:kms).</p>
    public let serverSideEncryption: ServerSideEncryption?
    /// <p>ID for the initiated multipart upload.</p>
    public let uploadId: String?

    public init (
        abortDate: Date? = nil,
        abortRuleId: String? = nil,
        bucket: String? = nil,
        bucketKeyEnabled: Bool = false,
        key: String? = nil,
        requestCharged: RequestCharged? = nil,
        sSECustomerAlgorithm: String? = nil,
        sSECustomerKeyMD5: String? = nil,
        sSEKMSEncryptionContext: String? = nil,
        sSEKMSKeyId: String? = nil,
        serverSideEncryption: ServerSideEncryption? = nil,
        uploadId: String? = nil
    )
    {
        self.abortDate = abortDate
        self.abortRuleId = abortRuleId
        self.bucket = bucket
        self.bucketKeyEnabled = bucketKeyEnabled
        self.key = key
        self.requestCharged = requestCharged
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.sSEKMSEncryptionContext = sSEKMSEncryptionContext
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
        self.uploadId = uploadId
    }
}

struct CreateMultipartUploadOutputResponseBody: Equatable {
    public let bucket: String?
    public let key: String?
    public let uploadId: String?
}

extension CreateMultipartUploadOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case key = "Key"
        case uploadId = "UploadId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
    }
}

extension DefaultRetention: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case days = "Days"
        case mode = "Mode"
        case years = "Years"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if days != 0 {
            try container.encode(days, forKey: Key("days"))
        }
        if let mode = mode {
            try container.encode(mode, forKey: Key("mode"))
        }
        if years != 0 {
            try container.encode(years, forKey: Key("years"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(ObjectLockRetentionMode.self, forKey: .mode)
        mode = modeDecoded
        let daysDecoded = try containerValues.decode(Int.self, forKey: .days)
        days = daysDecoded
        let yearsDecoded = try containerValues.decode(Int.self, forKey: .years)
        years = yearsDecoded
    }
}

extension DefaultRetention: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefaultRetention(days: \(String(describing: days)), mode: \(String(describing: mode)), years: \(String(describing: years)))"}
}

extension DefaultRetention: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The container element for specifying the default Object Lock retention settings for new
///          objects placed in the specified bucket.</p>
///          <note>
///             <ul>
///                <li>
///                   <p>The <code>DefaultRetention</code> settings require both a mode and a
///                period.</p>
///                </li>
///                <li>
///                   <p>The <code>DefaultRetention</code> period can be either <code>Days</code>
///                or <code>Years</code> but you must select one. You cannot specify <code>Days</code>
///                and <code>Years</code> at the same time.</p>
///                </li>
///             </ul>
///          </note>
public struct DefaultRetention: Equatable {
    /// <p>The number of days that you want to specify for the default retention period. Must be
    ///          used with <code>Mode</code>.</p>
    public let days: Int
    /// <p>The default Object Lock retention mode you want to apply to new objects placed in the
    ///          specified bucket. Must be used with either <code>Days</code> or <code>Years</code>.</p>
    public let mode: ObjectLockRetentionMode?
    /// <p>The number of years that you want to specify for the default retention period. Must be
    ///          used with <code>Mode</code>.</p>
    public let years: Int

    public init (
        days: Int = 0,
        mode: ObjectLockRetentionMode? = nil,
        years: Int = 0
    )
    {
        self.days = days
        self.mode = mode
        self.years = years
    }
}

extension Delete: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objects = "Object"
        case quiet = "Quiet"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let objects = objects {
            if objects.isEmpty {
                var objectsContainer = container.nestedUnkeyedContainer(forKey: Key("Object"))
                try objectsContainer.encodeNil()
            } else {
                for objectidentifier0 in objects {
                    var objectsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Object"))
                    try objectsContainer0.encode(objectidentifier0, forKey: Key(""))
                }
            }
        }
        if quiet != false {
            try container.encode(quiet, forKey: Key("quiet"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.objects) {
            let objectsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .objects)
            if objectsWrappedContainer != nil {
                let objectsContainer = try containerValues.decodeIfPresent([ObjectIdentifier].self, forKey: .objects)
                var objectsBuffer:[ObjectIdentifier]? = nil
                if let objectsContainer = objectsContainer {
                    objectsBuffer = [ObjectIdentifier]()
                    for structureContainer0 in objectsContainer {
                        objectsBuffer?.append(structureContainer0)
                    }
                }
                objects = objectsBuffer
            } else {
                objects = []
            }
        } else {
            objects = nil
        }
        let quietDecoded = try containerValues.decode(Bool.self, forKey: .quiet)
        quiet = quietDecoded
    }
}

extension Delete: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Delete(objects: \(String(describing: objects)), quiet: \(String(describing: quiet)))"}
}

extension Delete: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container for the objects to delete.</p>
public struct Delete: Equatable {
    /// <p>The objects to delete.</p>
    public let objects: [ObjectIdentifier]?
    /// <p>Element to enable quiet mode for the request. When you add this element, you must set
    ///          its value to true.</p>
    public let quiet: Bool

    public init (
        objects: [ObjectIdentifier]? = nil,
        quiet: Bool = false
    )
    {
        self.objects = objects
        self.quiet = quiet
    }
}

extension DeleteBucketAnalyticsConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketAnalyticsConfigurationInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), id: \(String(describing: id)))"}
}

extension DeleteBucketAnalyticsConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBucketAnalyticsConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBucketAnalyticsConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketAnalyticsConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketAnalyticsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketAnalyticsConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteBucketAnalyticsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketAnalyticsConfigurationOutputError>
}

public struct DeleteBucketAnalyticsConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBucketAnalyticsConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketAnalyticsConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketAnalyticsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "analytics", value: nil))
        if let id = input.operationInput.id {
            let idQueryItem = URLQueryItem(name: "id".urlPercentEncoding(), value: String(id).urlPercentEncoding())
            input.builder.withQueryItem(idQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketAnalyticsConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteBucketAnalyticsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketAnalyticsConfigurationOutputError>
}

public struct DeleteBucketAnalyticsConfigurationInput: Equatable {
    /// <p>The name of the bucket from which an analytics configuration is deleted.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The ID that identifies the analytics configuration.</p>
    public let id: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        id: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.id = id
    }
}

struct DeleteBucketAnalyticsConfigurationInputBody: Equatable {
}

extension DeleteBucketAnalyticsConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketAnalyticsConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteBucketAnalyticsConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBucketAnalyticsConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketAnalyticsConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketAnalyticsConfigurationOutputResponse()"}
}

extension DeleteBucketAnalyticsConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketAnalyticsConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteBucketAnalyticsConfigurationOutputResponseBody: Equatable {
}

extension DeleteBucketAnalyticsConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketCorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketCorsInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension DeleteBucketCorsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBucketCorsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBucketCorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketCorsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketCorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketCorsInput>
    public typealias MOutput = OperationOutput<DeleteBucketCorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketCorsOutputError>
}

public struct DeleteBucketCorsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBucketCorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketCorsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketCorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "cors", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketCorsInput>
    public typealias MOutput = OperationOutput<DeleteBucketCorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketCorsOutputError>
}

public struct DeleteBucketCorsInput: Equatable {
    /// <p>Specifies the bucket whose <code>cors</code> configuration is being deleted.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct DeleteBucketCorsInputBody: Equatable {
}

extension DeleteBucketCorsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketCorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteBucketCorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBucketCorsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketCorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketCorsOutputResponse()"}
}

extension DeleteBucketCorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketCorsOutputResponse: Equatable {

    public init() {}
}

struct DeleteBucketCorsOutputResponseBody: Equatable {
}

extension DeleteBucketCorsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketEncryptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketEncryptionInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension DeleteBucketEncryptionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBucketEncryptionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBucketEncryptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketEncryptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketEncryptionInput>
    public typealias MOutput = OperationOutput<DeleteBucketEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketEncryptionOutputError>
}

public struct DeleteBucketEncryptionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBucketEncryptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketEncryptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "encryption", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketEncryptionInput>
    public typealias MOutput = OperationOutput<DeleteBucketEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketEncryptionOutputError>
}

public struct DeleteBucketEncryptionInput: Equatable {
    /// <p>The name of the bucket containing the server-side encryption configuration to
    ///          delete.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct DeleteBucketEncryptionInputBody: Equatable {
}

extension DeleteBucketEncryptionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketEncryptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteBucketEncryptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBucketEncryptionOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketEncryptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketEncryptionOutputResponse()"}
}

extension DeleteBucketEncryptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketEncryptionOutputResponse: Equatable {

    public init() {}
}

struct DeleteBucketEncryptionOutputResponseBody: Equatable {
}

extension DeleteBucketEncryptionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension DeleteBucketInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBucketInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBucketInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketInput>
    public typealias MOutput = OperationOutput<DeleteBucketOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketOutputError>
}

public struct DeleteBucketInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBucketInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketInput>
    public typealias MOutput = OperationOutput<DeleteBucketOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketOutputError>
}

public struct DeleteBucketInput: Equatable {
    /// <p>Specifies the bucket being deleted.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct DeleteBucketInputBody: Equatable {
}

extension DeleteBucketInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketIntelligentTieringConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketIntelligentTieringConfigurationInput(bucket: \(String(describing: bucket)), id: \(String(describing: id)))"}
}

extension DeleteBucketIntelligentTieringConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBucketIntelligentTieringConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBucketIntelligentTieringConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketIntelligentTieringConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketIntelligentTieringConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketIntelligentTieringConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteBucketIntelligentTieringConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketIntelligentTieringConfigurationOutputError>
}

public struct DeleteBucketIntelligentTieringConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBucketIntelligentTieringConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketIntelligentTieringConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketIntelligentTieringConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "intelligent-tiering", value: nil))
        if let id = input.operationInput.id {
            let idQueryItem = URLQueryItem(name: "id".urlPercentEncoding(), value: String(id).urlPercentEncoding())
            input.builder.withQueryItem(idQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketIntelligentTieringConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteBucketIntelligentTieringConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketIntelligentTieringConfigurationOutputError>
}

public struct DeleteBucketIntelligentTieringConfigurationInput: Equatable {
    /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
    public let bucket: String?
    /// <p>The ID used to identify the S3 Intelligent-Tiering configuration.</p>
    public let id: String?

    public init (
        bucket: String? = nil,
        id: String? = nil
    )
    {
        self.bucket = bucket
        self.id = id
    }
}

struct DeleteBucketIntelligentTieringConfigurationInputBody: Equatable {
}

extension DeleteBucketIntelligentTieringConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketIntelligentTieringConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteBucketIntelligentTieringConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBucketIntelligentTieringConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketIntelligentTieringConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketIntelligentTieringConfigurationOutputResponse()"}
}

extension DeleteBucketIntelligentTieringConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketIntelligentTieringConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteBucketIntelligentTieringConfigurationOutputResponseBody: Equatable {
}

extension DeleteBucketIntelligentTieringConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketInventoryConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketInventoryConfigurationInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), id: \(String(describing: id)))"}
}

extension DeleteBucketInventoryConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBucketInventoryConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBucketInventoryConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketInventoryConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketInventoryConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketInventoryConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteBucketInventoryConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketInventoryConfigurationOutputError>
}

public struct DeleteBucketInventoryConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBucketInventoryConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketInventoryConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketInventoryConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "inventory", value: nil))
        if let id = input.operationInput.id {
            let idQueryItem = URLQueryItem(name: "id".urlPercentEncoding(), value: String(id).urlPercentEncoding())
            input.builder.withQueryItem(idQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketInventoryConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteBucketInventoryConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketInventoryConfigurationOutputError>
}

public struct DeleteBucketInventoryConfigurationInput: Equatable {
    /// <p>The name of the bucket containing the inventory configuration to delete.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The ID used to identify the inventory configuration.</p>
    public let id: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        id: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.id = id
    }
}

struct DeleteBucketInventoryConfigurationInputBody: Equatable {
}

extension DeleteBucketInventoryConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketInventoryConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteBucketInventoryConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBucketInventoryConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketInventoryConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketInventoryConfigurationOutputResponse()"}
}

extension DeleteBucketInventoryConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketInventoryConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteBucketInventoryConfigurationOutputResponseBody: Equatable {
}

extension DeleteBucketInventoryConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketLifecycleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketLifecycleInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension DeleteBucketLifecycleInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBucketLifecycleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBucketLifecycleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketLifecycleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketLifecycleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketLifecycleInput>
    public typealias MOutput = OperationOutput<DeleteBucketLifecycleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketLifecycleOutputError>
}

public struct DeleteBucketLifecycleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBucketLifecycleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketLifecycleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketLifecycleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "lifecycle", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketLifecycleInput>
    public typealias MOutput = OperationOutput<DeleteBucketLifecycleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketLifecycleOutputError>
}

public struct DeleteBucketLifecycleInput: Equatable {
    /// <p>The bucket name of the lifecycle to delete.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct DeleteBucketLifecycleInputBody: Equatable {
}

extension DeleteBucketLifecycleInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketLifecycleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteBucketLifecycleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBucketLifecycleOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketLifecycleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketLifecycleOutputResponse()"}
}

extension DeleteBucketLifecycleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketLifecycleOutputResponse: Equatable {

    public init() {}
}

struct DeleteBucketLifecycleOutputResponseBody: Equatable {
}

extension DeleteBucketLifecycleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketMetricsConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketMetricsConfigurationInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), id: \(String(describing: id)))"}
}

extension DeleteBucketMetricsConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBucketMetricsConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBucketMetricsConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketMetricsConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketMetricsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketMetricsConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteBucketMetricsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketMetricsConfigurationOutputError>
}

public struct DeleteBucketMetricsConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBucketMetricsConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketMetricsConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketMetricsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "metrics", value: nil))
        if let id = input.operationInput.id {
            let idQueryItem = URLQueryItem(name: "id".urlPercentEncoding(), value: String(id).urlPercentEncoding())
            input.builder.withQueryItem(idQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketMetricsConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteBucketMetricsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketMetricsConfigurationOutputError>
}

public struct DeleteBucketMetricsConfigurationInput: Equatable {
    /// <p>The name of the bucket containing the metrics configuration to delete.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The ID used to identify the metrics configuration.</p>
    public let id: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        id: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.id = id
    }
}

struct DeleteBucketMetricsConfigurationInputBody: Equatable {
}

extension DeleteBucketMetricsConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketMetricsConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteBucketMetricsConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBucketMetricsConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketMetricsConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketMetricsConfigurationOutputResponse()"}
}

extension DeleteBucketMetricsConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketMetricsConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteBucketMetricsConfigurationOutputResponseBody: Equatable {
}

extension DeleteBucketMetricsConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteBucketOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBucketOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketOutputResponse()"}
}

extension DeleteBucketOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketOutputResponse: Equatable {

    public init() {}
}

struct DeleteBucketOutputResponseBody: Equatable {
}

extension DeleteBucketOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketOwnershipControlsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketOwnershipControlsInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension DeleteBucketOwnershipControlsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBucketOwnershipControlsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBucketOwnershipControlsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketOwnershipControlsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketOwnershipControlsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketOwnershipControlsInput>
    public typealias MOutput = OperationOutput<DeleteBucketOwnershipControlsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketOwnershipControlsOutputError>
}

public struct DeleteBucketOwnershipControlsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBucketOwnershipControlsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketOwnershipControlsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketOwnershipControlsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "ownershipControls", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketOwnershipControlsInput>
    public typealias MOutput = OperationOutput<DeleteBucketOwnershipControlsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketOwnershipControlsOutputError>
}

public struct DeleteBucketOwnershipControlsInput: Equatable {
    /// <p>The Amazon S3 bucket whose <code>OwnershipControls</code> you want to delete. </p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct DeleteBucketOwnershipControlsInputBody: Equatable {
}

extension DeleteBucketOwnershipControlsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketOwnershipControlsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteBucketOwnershipControlsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBucketOwnershipControlsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketOwnershipControlsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketOwnershipControlsOutputResponse()"}
}

extension DeleteBucketOwnershipControlsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketOwnershipControlsOutputResponse: Equatable {

    public init() {}
}

struct DeleteBucketOwnershipControlsOutputResponseBody: Equatable {
}

extension DeleteBucketOwnershipControlsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketPolicyInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension DeleteBucketPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBucketPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBucketPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketPolicyInput>
    public typealias MOutput = OperationOutput<DeleteBucketPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketPolicyOutputError>
}

public struct DeleteBucketPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBucketPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "policy", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketPolicyInput>
    public typealias MOutput = OperationOutput<DeleteBucketPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketPolicyOutputError>
}

public struct DeleteBucketPolicyInput: Equatable {
    /// <p>The bucket name.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct DeleteBucketPolicyInputBody: Equatable {
}

extension DeleteBucketPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteBucketPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBucketPolicyOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketPolicyOutputResponse()"}
}

extension DeleteBucketPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketPolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteBucketPolicyOutputResponseBody: Equatable {
}

extension DeleteBucketPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketReplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketReplicationInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension DeleteBucketReplicationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBucketReplicationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBucketReplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketReplicationInput>
    public typealias MOutput = OperationOutput<DeleteBucketReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketReplicationOutputError>
}

public struct DeleteBucketReplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBucketReplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "replication", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketReplicationInput>
    public typealias MOutput = OperationOutput<DeleteBucketReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketReplicationOutputError>
}

public struct DeleteBucketReplicationInput: Equatable {
    /// <p> The bucket name. </p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct DeleteBucketReplicationInputBody: Equatable {
}

extension DeleteBucketReplicationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketReplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteBucketReplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBucketReplicationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketReplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketReplicationOutputResponse()"}
}

extension DeleteBucketReplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketReplicationOutputResponse: Equatable {

    public init() {}
}

struct DeleteBucketReplicationOutputResponseBody: Equatable {
}

extension DeleteBucketReplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketTaggingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketTaggingInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension DeleteBucketTaggingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBucketTaggingInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBucketTaggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketTaggingInput>
    public typealias MOutput = OperationOutput<DeleteBucketTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketTaggingOutputError>
}

public struct DeleteBucketTaggingInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBucketTaggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "tagging", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketTaggingInput>
    public typealias MOutput = OperationOutput<DeleteBucketTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketTaggingOutputError>
}

public struct DeleteBucketTaggingInput: Equatable {
    /// <p>The bucket that has the tag set to be removed.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct DeleteBucketTaggingInputBody: Equatable {
}

extension DeleteBucketTaggingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketTaggingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteBucketTaggingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBucketTaggingOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketTaggingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketTaggingOutputResponse()"}
}

extension DeleteBucketTaggingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketTaggingOutputResponse: Equatable {

    public init() {}
}

struct DeleteBucketTaggingOutputResponseBody: Equatable {
}

extension DeleteBucketTaggingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketWebsiteInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketWebsiteInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension DeleteBucketWebsiteInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBucketWebsiteInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBucketWebsiteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketWebsiteInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketWebsiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketWebsiteInput>
    public typealias MOutput = OperationOutput<DeleteBucketWebsiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketWebsiteOutputError>
}

public struct DeleteBucketWebsiteInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBucketWebsiteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketWebsiteInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketWebsiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "website", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketWebsiteInput>
    public typealias MOutput = OperationOutput<DeleteBucketWebsiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketWebsiteOutputError>
}

public struct DeleteBucketWebsiteInput: Equatable {
    /// <p>The bucket name for which you want to remove the website configuration. </p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct DeleteBucketWebsiteInputBody: Equatable {
}

extension DeleteBucketWebsiteInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketWebsiteOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteBucketWebsiteOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBucketWebsiteOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketWebsiteOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketWebsiteOutputResponse()"}
}

extension DeleteBucketWebsiteOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketWebsiteOutputResponse: Equatable {

    public init() {}
}

struct DeleteBucketWebsiteOutputResponseBody: Equatable {
}

extension DeleteBucketWebsiteOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteMarkerEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isLatest = "IsLatest"
        case key = "Key"
        case lastModified = "LastModified"
        case owner = "Owner"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if isLatest != false {
            try container.encode(isLatest, forKey: Key("isLatest"))
        }
        if let key = key {
            try container.encode(key, forKey: Key("key"))
        }
        if let lastModified = lastModified {
            try container.encode(TimestampWrapper(lastModified, format: .dateTime), forKey: Key("lastModified"))
        }
        if let owner = owner {
            try container.encode(owner, forKey: Key("owner"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: Key("versionId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(Owner.self, forKey: .owner)
        owner = ownerDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let isLatestDecoded = try containerValues.decode(Bool.self, forKey: .isLatest)
        isLatest = isLatestDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModified)
        var lastModifiedBuffer:Date? = nil
        if let lastModifiedDecoded = lastModifiedDecoded {
            lastModifiedBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastModifiedDecoded, format: .dateTime)
        }
        lastModified = lastModifiedBuffer
    }
}

extension DeleteMarkerEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMarkerEntry(isLatest: \(String(describing: isLatest)), key: \(String(describing: key)), lastModified: \(String(describing: lastModified)), owner: \(String(describing: owner)), versionId: \(String(describing: versionId)))"}
}

extension DeleteMarkerEntry: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Information about the delete marker.</p>
public struct DeleteMarkerEntry: Equatable {
    /// <p>Specifies whether the object is (true) or is not (false) the latest version of an
    ///          object.</p>
    public let isLatest: Bool
    /// <p>The object key.</p>
    public let key: String?
    /// <p>Date and time the object was last modified.</p>
    public let lastModified: Date?
    /// <p>The account that created the delete marker.></p>
    public let owner: Owner?
    /// <p>Version ID of an object.</p>
    public let versionId: String?

    public init (
        isLatest: Bool = false,
        key: String? = nil,
        lastModified: Date? = nil,
        owner: Owner? = nil,
        versionId: String? = nil
    )
    {
        self.isLatest = isLatest
        self.key = key
        self.lastModified = lastModified
        self.owner = owner
        self.versionId = versionId
    }
}

extension DeleteMarkerReplication: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(DeleteMarkerReplicationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteMarkerReplication: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMarkerReplication(status: \(String(describing: status)))"}
}

extension DeleteMarkerReplication: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies whether Amazon S3 replicates delete markers. If you specify a <code>Filter</code>
///          in your replication configuration, you must also include a
///             <code>DeleteMarkerReplication</code> element. If your <code>Filter</code> includes a
///             <code>Tag</code> element, the <code>DeleteMarkerReplication</code>
///             <code>Status</code> must be set to Disabled, because Amazon S3 does not support replicating
///          delete markers for tag-based rules. For an example configuration, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-config-min-rule-config">Basic Rule Configuration</a>. </p>
///          <p>For more information about delete marker replication, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/delete-marker-replication.html">Basic Rule
///             Configuration</a>. </p>
///          <note>
///             <p>If you are using an earlier version of the replication configuration, Amazon S3 handles
///             replication of delete markers differently. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-backward-compat-considerations">Backward Compatibility</a>.</p>
///          </note>
public struct DeleteMarkerReplication: Equatable {
    /// <p>Indicates whether to replicate delete markers.</p>
    ///          <note>
    ///             <p>Indicates whether to replicate delete markers.</p>
    ///          </note>
    public let status: DeleteMarkerReplicationStatus?

    public init (
        status: DeleteMarkerReplicationStatus? = nil
    )
    {
        self.status = status
    }
}

public enum DeleteMarkerReplicationStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension DeleteMarkerReplicationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeleteMarkerReplicationStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "Disabled"
        case .enabled: return "Enabled"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeleteMarkerReplicationStatus(rawValue: rawValue) ?? DeleteMarkerReplicationStatus.sdkUnknown(rawValue)
    }
}

extension DeleteObjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteObjectInput(bucket: \(String(describing: bucket)), bypassGovernanceRetention: \(String(describing: bypassGovernanceRetention)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), key: \(String(describing: key)), mFA: \(String(describing: mFA)), requestPayer: \(String(describing: requestPayer)), versionId: \(String(describing: versionId)))"}
}

extension DeleteObjectInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteObjectInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withHeader(name: "x-amz-bypass-governance-retention", value: String(input.operationInput.bypassGovernanceRetention))
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let mFA = input.operationInput.mFA {
            input.builder.withHeader(name: "x-amz-mfa", value: String(mFA))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteObjectInput>
    public typealias MOutput = OperationOutput<DeleteObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteObjectOutputError>
}

public struct DeleteObjectInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "x-id", value: "DeleteObject"))
        if let versionId = input.operationInput.versionId {
            let versionIdQueryItem = URLQueryItem(name: "versionId".urlPercentEncoding(), value: String(versionId).urlPercentEncoding())
            input.builder.withQueryItem(versionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteObjectInput>
    public typealias MOutput = OperationOutput<DeleteObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteObjectOutputError>
}

public struct DeleteObjectInput: Equatable {
    /// <p>The bucket name of the bucket containing the object. </p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>Indicates whether S3 Object Lock should bypass Governance-mode restrictions to process
    ///          this operation.</p>
    public let bypassGovernanceRetention: Bool
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>Key name of the object to delete.</p>
    public let key: String?
    /// <p>The concatenation of the authentication device's serial number, a space, and the value
    ///          that is displayed on your authentication device. Required to permanently delete a versioned
    ///          object if versioning is configured with MFA delete enabled.</p>
    public let mFA: String?
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    ///          owners need not specify this parameter in their requests. For information about downloading
    ///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    ///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let requestPayer: RequestPayer?
    /// <p>VersionId used to reference a specific version of the object.</p>
    public let versionId: String?

    public init (
        bucket: String? = nil,
        bypassGovernanceRetention: Bool = false,
        expectedBucketOwner: String? = nil,
        key: String? = nil,
        mFA: String? = nil,
        requestPayer: RequestPayer? = nil,
        versionId: String? = nil
    )
    {
        self.bucket = bucket
        self.bypassGovernanceRetention = bypassGovernanceRetention
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.mFA = mFA
        self.requestPayer = requestPayer
        self.versionId = versionId
    }
}

struct DeleteObjectInputBody: Equatable {
}

extension DeleteObjectInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteObjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteObjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteObjectOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteObjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteObjectOutputResponse(deleteMarker: \(String(describing: deleteMarker)), requestCharged: \(String(describing: requestCharged)), versionId: \(String(describing: versionId)))"}
}

extension DeleteObjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let deleteMarkerHeaderValue = httpResponse.headers.value(for: "x-amz-delete-marker") {
            self.deleteMarker = Bool(deleteMarkerHeaderValue) ?? false
        } else {
            self.deleteMarker = false
        }
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if let versionIdHeaderValue = httpResponse.headers.value(for: "x-amz-version-id") {
            self.versionId = versionIdHeaderValue
        } else {
            self.versionId = nil
        }
    }
}

public struct DeleteObjectOutputResponse: Equatable {
    /// <p>Specifies whether the versioned object that was permanently deleted was (true) or was
    ///          not (false) a delete marker.</p>
    public let deleteMarker: Bool
    /// <p>If present, indicates that the requester was successfully charged for the
    ///          request.</p>
    public let requestCharged: RequestCharged?
    /// <p>Returns the version ID of the delete marker created as a result of the DELETE
    ///          operation.</p>
    public let versionId: String?

    public init (
        deleteMarker: Bool = false,
        requestCharged: RequestCharged? = nil,
        versionId: String? = nil
    )
    {
        self.deleteMarker = deleteMarker
        self.requestCharged = requestCharged
        self.versionId = versionId
    }
}

struct DeleteObjectOutputResponseBody: Equatable {
}

extension DeleteObjectOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteObjectTaggingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteObjectTaggingInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), key: \(String(describing: key)), versionId: \(String(describing: versionId)))"}
}

extension DeleteObjectTaggingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteObjectTaggingInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteObjectTaggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteObjectTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteObjectTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteObjectTaggingInput>
    public typealias MOutput = OperationOutput<DeleteObjectTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteObjectTaggingOutputError>
}

public struct DeleteObjectTaggingInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteObjectTaggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteObjectTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteObjectTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "tagging", value: nil))
        if let versionId = input.operationInput.versionId {
            let versionIdQueryItem = URLQueryItem(name: "versionId".urlPercentEncoding(), value: String(versionId).urlPercentEncoding())
            input.builder.withQueryItem(versionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteObjectTaggingInput>
    public typealias MOutput = OperationOutput<DeleteObjectTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteObjectTaggingOutputError>
}

public struct DeleteObjectTaggingInput: Equatable {
    /// <p>The bucket name containing the objects from which to remove the tags. </p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The key that identifies the object in the bucket from which to remove all tags.</p>
    public let key: String?
    /// <p>The versionId of the object that the tag-set will be removed from.</p>
    public let versionId: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        key: String? = nil,
        versionId: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.versionId = versionId
    }
}

struct DeleteObjectTaggingInputBody: Equatable {
}

extension DeleteObjectTaggingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteObjectTaggingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteObjectTaggingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteObjectTaggingOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteObjectTaggingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteObjectTaggingOutputResponse(versionId: \(String(describing: versionId)))"}
}

extension DeleteObjectTaggingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let versionIdHeaderValue = httpResponse.headers.value(for: "x-amz-version-id") {
            self.versionId = versionIdHeaderValue
        } else {
            self.versionId = nil
        }
    }
}

public struct DeleteObjectTaggingOutputResponse: Equatable {
    /// <p>The versionId of the object the tag-set was removed from.</p>
    public let versionId: String?

    public init (
        versionId: String? = nil
    )
    {
        self.versionId = versionId
    }
}

struct DeleteObjectTaggingOutputResponseBody: Equatable {
}

extension DeleteObjectTaggingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteObjectsInputBodyMiddleware: Middleware {
    public let id: String = "DeleteObjectsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteObjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteObjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let delete = input.operationInput.delete {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(delete)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteObjectsInput>
    public typealias MOutput = OperationOutput<DeleteObjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteObjectsOutputError>
}

extension DeleteObjectsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteObjectsInput(bucket: \(String(describing: bucket)), bypassGovernanceRetention: \(String(describing: bypassGovernanceRetention)), delete: \(String(describing: delete)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), mFA: \(String(describing: mFA)), requestPayer: \(String(describing: requestPayer)))"}
}

extension DeleteObjectsInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension DeleteObjectsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case delete = "Delete"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let delete = delete {
            try container.encode(delete, forKey: Key("Delete"))
        }
    }
}

public struct DeleteObjectsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteObjectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteObjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteObjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withHeader(name: "x-amz-bypass-governance-retention", value: String(input.operationInput.bypassGovernanceRetention))
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let mFA = input.operationInput.mFA {
            input.builder.withHeader(name: "x-amz-mfa", value: String(mFA))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteObjectsInput>
    public typealias MOutput = OperationOutput<DeleteObjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteObjectsOutputError>
}

public struct DeleteObjectsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteObjectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteObjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteObjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "delete", value: nil))
        input.builder.withQueryItem(URLQueryItem(name: "x-id", value: "DeleteObjects"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteObjectsInput>
    public typealias MOutput = OperationOutput<DeleteObjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteObjectsOutputError>
}

public struct DeleteObjectsInput: Equatable {
    /// <p>The bucket name containing the objects to delete. </p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>Specifies whether you want to delete this object even if it has a Governance-type Object
    ///          Lock in place. You must have sufficient permissions to perform this operation.</p>
    public let bypassGovernanceRetention: Bool
    /// <p>Container for the request.</p>
    public let delete: Delete?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The concatenation of the authentication device's serial number, a space, and the value
    ///          that is displayed on your authentication device. Required to permanently delete a versioned
    ///          object if versioning is configured with MFA delete enabled.</p>
    public let mFA: String?
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    ///          owners need not specify this parameter in their requests. For information about downloading
    ///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    ///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let requestPayer: RequestPayer?

    public init (
        bucket: String? = nil,
        bypassGovernanceRetention: Bool = false,
        delete: Delete? = nil,
        expectedBucketOwner: String? = nil,
        mFA: String? = nil,
        requestPayer: RequestPayer? = nil
    )
    {
        self.bucket = bucket
        self.bypassGovernanceRetention = bypassGovernanceRetention
        self.delete = delete
        self.expectedBucketOwner = expectedBucketOwner
        self.mFA = mFA
        self.requestPayer = requestPayer
    }
}

struct DeleteObjectsInputBody: Equatable {
    public let delete: Delete?
}

extension DeleteObjectsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case delete = "Delete"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deleteDecoded = try containerValues.decodeIfPresent(Delete.self, forKey: .delete)
        delete = deleteDecoded
    }
}

extension DeleteObjectsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteObjectsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteObjectsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteObjectsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteObjectsOutputResponse(deleted: \(String(describing: deleted)), errors: \(String(describing: errors)), requestCharged: \(String(describing: requestCharged)))"}
}

extension DeleteObjectsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteObjectsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deleted = output.deleted
            self.errors = output.errors
        } else {
            self.deleted = nil
            self.errors = nil
        }
    }
}

public struct DeleteObjectsOutputResponse: Equatable {
    /// <p>Container element for a successful delete. It identifies the object that was
    ///          successfully deleted.</p>
    public let deleted: [DeletedObject]?
    /// <p>Container for a failed delete action that describes the object that Amazon S3 attempted to
    ///          delete and the error it encountered.</p>
    public let errors: [Error]?
    /// <p>If present, indicates that the requester was successfully charged for the
    ///          request.</p>
    public let requestCharged: RequestCharged?

    public init (
        deleted: [DeletedObject]? = nil,
        errors: [Error]? = nil,
        requestCharged: RequestCharged? = nil
    )
    {
        self.deleted = deleted
        self.errors = errors
        self.requestCharged = requestCharged
    }
}

struct DeleteObjectsOutputResponseBody: Equatable {
    public let deleted: [DeletedObject]?
    public let errors: [Error]?
}

extension DeleteObjectsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deleted = "Deleted"
        case errors = "Error"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.deleted) {
            let deletedWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .deleted)
            if deletedWrappedContainer != nil {
                let deletedContainer = try containerValues.decodeIfPresent([DeletedObject].self, forKey: .deleted)
                var deletedBuffer:[DeletedObject]? = nil
                if let deletedContainer = deletedContainer {
                    deletedBuffer = [DeletedObject]()
                    for structureContainer0 in deletedContainer {
                        deletedBuffer?.append(structureContainer0)
                    }
                }
                deleted = deletedBuffer
            } else {
                deleted = []
            }
        } else {
            deleted = nil
        }
        if containerValues.contains(.errors) {
            let errorsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .errors)
            if errorsWrappedContainer != nil {
                let errorsContainer = try containerValues.decodeIfPresent([Error].self, forKey: .errors)
                var errorsBuffer:[Error]? = nil
                if let errorsContainer = errorsContainer {
                    errorsBuffer = [Error]()
                    for structureContainer0 in errorsContainer {
                        errorsBuffer?.append(structureContainer0)
                    }
                }
                errors = errorsBuffer
            } else {
                errors = []
            }
        } else {
            errors = nil
        }
    }
}

extension DeletePublicAccessBlockInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePublicAccessBlockInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension DeletePublicAccessBlockInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeletePublicAccessBlockInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePublicAccessBlockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePublicAccessBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePublicAccessBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePublicAccessBlockInput>
    public typealias MOutput = OperationOutput<DeletePublicAccessBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePublicAccessBlockOutputError>
}

public struct DeletePublicAccessBlockInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePublicAccessBlockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePublicAccessBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePublicAccessBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "publicAccessBlock", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePublicAccessBlockInput>
    public typealias MOutput = OperationOutput<DeletePublicAccessBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePublicAccessBlockOutputError>
}

public struct DeletePublicAccessBlockInput: Equatable {
    /// <p>The Amazon S3 bucket whose <code>PublicAccessBlock</code> configuration you want to delete.
    ///       </p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct DeletePublicAccessBlockInputBody: Equatable {
}

extension DeletePublicAccessBlockInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePublicAccessBlockOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeletePublicAccessBlockOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePublicAccessBlockOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePublicAccessBlockOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePublicAccessBlockOutputResponse()"}
}

extension DeletePublicAccessBlockOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePublicAccessBlockOutputResponse: Equatable {

    public init() {}
}

struct DeletePublicAccessBlockOutputResponseBody: Equatable {
}

extension DeletePublicAccessBlockOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletedObject: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deleteMarker = "DeleteMarker"
        case deleteMarkerVersionId = "DeleteMarkerVersionId"
        case key = "Key"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if deleteMarker != false {
            try container.encode(deleteMarker, forKey: Key("deleteMarker"))
        }
        if let deleteMarkerVersionId = deleteMarkerVersionId {
            try container.encode(deleteMarkerVersionId, forKey: Key("deleteMarkerVersionId"))
        }
        if let key = key {
            try container.encode(key, forKey: Key("key"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: Key("versionId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let deleteMarkerDecoded = try containerValues.decode(Bool.self, forKey: .deleteMarker)
        deleteMarker = deleteMarkerDecoded
        let deleteMarkerVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deleteMarkerVersionId)
        deleteMarkerVersionId = deleteMarkerVersionIdDecoded
    }
}

extension DeletedObject: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletedObject(deleteMarker: \(String(describing: deleteMarker)), deleteMarkerVersionId: \(String(describing: deleteMarkerVersionId)), key: \(String(describing: key)), versionId: \(String(describing: versionId)))"}
}

extension DeletedObject: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Information about the deleted object.</p>
public struct DeletedObject: Equatable {
    /// <p>Specifies whether the versioned object that was permanently deleted was (true) or was
    ///          not (false) a delete marker. In a simple DELETE, this header indicates whether (true) or
    ///          not (false) a delete marker was created.</p>
    public let deleteMarker: Bool
    /// <p>The version ID of the delete marker created as a result of the DELETE operation. If you
    ///          delete a specific object version, the value returned by this header is the version ID of
    ///          the object version deleted.</p>
    public let deleteMarkerVersionId: String?
    /// <p>The name of the deleted object.</p>
    public let key: String?
    /// <p>The version ID of the deleted object.</p>
    public let versionId: String?

    public init (
        deleteMarker: Bool = false,
        deleteMarkerVersionId: String? = nil,
        key: String? = nil,
        versionId: String? = nil
    )
    {
        self.deleteMarker = deleteMarker
        self.deleteMarkerVersionId = deleteMarkerVersionId
        self.key = key
        self.versionId = versionId
    }
}

extension Destination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessControlTranslation = "AccessControlTranslation"
        case account = "Account"
        case bucket = "Bucket"
        case encryptionConfiguration = "EncryptionConfiguration"
        case metrics = "Metrics"
        case replicationTime = "ReplicationTime"
        case storageClass = "StorageClass"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let accessControlTranslation = accessControlTranslation {
            try container.encode(accessControlTranslation, forKey: Key("accessControlTranslation"))
        }
        if let account = account {
            try container.encode(account, forKey: Key("account"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: Key("bucket"))
        }
        if let encryptionConfiguration = encryptionConfiguration {
            try container.encode(encryptionConfiguration, forKey: Key("encryptionConfiguration"))
        }
        if let metrics = metrics {
            try container.encode(metrics, forKey: Key("metrics"))
        }
        if let replicationTime = replicationTime {
            try container.encode(replicationTime, forKey: Key("replicationTime"))
        }
        if let storageClass = storageClass {
            try container.encode(storageClass, forKey: Key("storageClass"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let accountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .account)
        account = accountDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let accessControlTranslationDecoded = try containerValues.decodeIfPresent(AccessControlTranslation.self, forKey: .accessControlTranslation)
        accessControlTranslation = accessControlTranslationDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let replicationTimeDecoded = try containerValues.decodeIfPresent(ReplicationTime.self, forKey: .replicationTime)
        replicationTime = replicationTimeDecoded
        let metricsDecoded = try containerValues.decodeIfPresent(Metrics.self, forKey: .metrics)
        metrics = metricsDecoded
    }
}

extension Destination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Destination(accessControlTranslation: \(String(describing: accessControlTranslation)), account: \(String(describing: account)), bucket: \(String(describing: bucket)), encryptionConfiguration: \(String(describing: encryptionConfiguration)), metrics: \(String(describing: metrics)), replicationTime: \(String(describing: replicationTime)), storageClass: \(String(describing: storageClass)))"}
}

extension Destination: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies information about where to publish analysis or configuration results for an
///          Amazon S3 bucket and S3 Replication Time Control (S3 RTC).</p>
public struct Destination: Equatable {
    /// <p>Specify this only in a cross-account scenario (where source and destination bucket
    ///          owners are not the same), and you want to change replica ownership to the AWS account that
    ///          owns the destination bucket. If this is not specified in the replication configuration, the
    ///          replicas are owned by same AWS account that owns the source object.</p>
    public let accessControlTranslation: AccessControlTranslation?
    /// <p>Destination bucket owner account ID. In a cross-account scenario, if you direct Amazon S3 to
    ///          change replica ownership to the AWS account that owns the destination bucket by specifying
    ///          the <code>AccessControlTranslation</code> property, this is the account ID of the
    ///          destination bucket owner. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-change-owner.html">Replication Additional
    ///             Configuration: Changing the Replica Owner</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let account: String?
    /// <p> The Amazon Resource Name (ARN) of the bucket where you want Amazon S3 to store the results.</p>
    public let bucket: String?
    /// <p>A container that provides information about encryption. If
    ///             <code>SourceSelectionCriteria</code> is specified, you must specify this element.</p>
    public let encryptionConfiguration: EncryptionConfiguration?
    /// <p> A container specifying replication metrics-related settings enabling replication
    ///          metrics and events. </p>
    public let metrics: Metrics?
    /// <p> A container specifying S3 Replication Time Control (S3 RTC), including whether S3 RTC is enabled and the time
    ///          when all objects and operations on objects must be replicated. Must be specified together
    ///          with a <code>Metrics</code> block. </p>
    public let replicationTime: ReplicationTime?
    /// <p> The storage class to use when replicating objects, such as S3 Standard or reduced
    ///          redundancy. By default, Amazon S3 uses the storage class of the source object to create the
    ///          object replica. </p>
    ///          <p>For valid values, see the <code>StorageClass</code> element of the <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html">PUT Bucket
    ///             replication</a> action in the <i>Amazon S3 API Reference</i>.</p>
    public let storageClass: StorageClass?

    public init (
        accessControlTranslation: AccessControlTranslation? = nil,
        account: String? = nil,
        bucket: String? = nil,
        encryptionConfiguration: EncryptionConfiguration? = nil,
        metrics: Metrics? = nil,
        replicationTime: ReplicationTime? = nil,
        storageClass: StorageClass? = nil
    )
    {
        self.accessControlTranslation = accessControlTranslation
        self.account = account
        self.bucket = bucket
        self.encryptionConfiguration = encryptionConfiguration
        self.metrics = metrics
        self.replicationTime = replicationTime
        self.storageClass = storageClass
    }
}

/// <p>Requests Amazon S3 to encode the object keys in the response and specifies the encoding
///          method to use. An object key may contain any Unicode character; however, XML 1.0 parser
///          cannot parse some characters, such as characters with an ASCII value from 0 to 10. For
///          characters that are not supported in XML 1.0, you can add this parameter to request that
///          Amazon S3 encode the keys in the response.</p>
public enum EncodingType {
    case url
    case sdkUnknown(String)
}

extension EncodingType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncodingType] {
        return [
            .url,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .url: return "url"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncodingType(rawValue: rawValue) ?? EncodingType.sdkUnknown(rawValue)
    }
}

extension Encryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionType = "EncryptionType"
        case kMSContext = "KMSContext"
        case kMSKeyId = "KMSKeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let encryptionType = encryptionType {
            try container.encode(encryptionType, forKey: Key("encryptionType"))
        }
        if let kMSContext = kMSContext {
            try container.encode(kMSContext, forKey: Key("kMSContext"))
        }
        if let kMSKeyId = kMSKeyId {
            try container.encode(kMSKeyId, forKey: Key("kMSKeyId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(ServerSideEncryption.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kMSKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKeyId)
        kMSKeyId = kMSKeyIdDecoded
        let kMSContextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSContext)
        kMSContext = kMSContextDecoded
    }
}

extension Encryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Encryption(encryptionType: \(String(describing: encryptionType)), kMSContext: \(String(describing: kMSContext)), kMSKeyId: \(String(describing: kMSKeyId)))"}
}

extension Encryption: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains the type of server-side encryption used.</p>
public struct Encryption: Equatable {
    /// <p>The server-side encryption algorithm used when storing job results in Amazon S3 (for example,
    ///          AES256, aws:kms).</p>
    public let encryptionType: ServerSideEncryption?
    /// <p>If the encryption type is <code>aws:kms</code>, this optional value can be used to
    ///          specify the encryption context for the restore results.</p>
    public let kMSContext: String?
    /// <p>If the encryption type is <code>aws:kms</code>, this optional value specifies the ID of
    ///          the symmetric customer managed AWS KMS CMK to use for encryption of job results. Amazon S3 only
    ///          supports symmetric CMKs. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using symmetric and
    ///             asymmetric keys</a> in the <i>AWS Key Management Service Developer Guide</i>.</p>
    public let kMSKeyId: String?

    public init (
        encryptionType: ServerSideEncryption? = nil,
        kMSContext: String? = nil,
        kMSKeyId: String? = nil
    )
    {
        self.encryptionType = encryptionType
        self.kMSContext = kMSContext
        self.kMSKeyId = kMSKeyId
    }
}

extension EncryptionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replicaKmsKeyID = "ReplicaKmsKeyID"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let replicaKmsKeyID = replicaKmsKeyID {
            try container.encode(replicaKmsKeyID, forKey: Key("replicaKmsKeyID"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicaKmsKeyIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicaKmsKeyID)
        replicaKmsKeyID = replicaKmsKeyIDDecoded
    }
}

extension EncryptionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionConfiguration(replicaKmsKeyID: \(String(describing: replicaKmsKeyID)))"}
}

extension EncryptionConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies encryption-related information for an Amazon S3 bucket that is a destination for
///          replicated objects.</p>
public struct EncryptionConfiguration: Equatable {
    /// <p>Specifies the ID (Key ARN or Alias ARN) of the customer managed AWS KMS key
    ///          stored in AWS Key Management Service (KMS) for the destination bucket. Amazon S3 uses
    ///          this key to encrypt replica objects. Amazon S3 only supports symmetric, customer managed KMS keys.
    ///          For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using symmetric and
    ///             asymmetric keys</a> in the <i>AWS Key Management Service Developer Guide</i>.</p>
    public let replicaKmsKeyID: String?

    public init (
        replicaKmsKeyID: String? = nil
    )
    {
        self.replicaKmsKeyID = replicaKmsKeyID
    }
}

extension EndEvent: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension EndEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndEvent()"}
}

/// <p>A message that indicates the request is complete and no more messages will be sent. You
///          should not assume that the request is complete until the client receives an
///             <code>EndEvent</code>.</p>
public struct EndEvent: Equatable {

    public init() {}
}

extension Error: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case key = "Key"
        case message = "Message"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let code = code {
            try container.encode(code, forKey: Key("code"))
        }
        if let key = key {
            try container.encode(key, forKey: Key("key"))
        }
        if let message = message {
            try container.encode(message, forKey: Key("message"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: Key("versionId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Error: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Error(code: \(String(describing: code)), key: \(String(describing: key)), message: \(String(describing: message)), versionId: \(String(describing: versionId)))"}
}

extension Error: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container for all error elements.</p>
public struct Error: Equatable {
    /// <p>The error code is a string that uniquely identifies an error condition. It is meant to
    ///          be read and understood by programs that detect and handle errors by type. </p>
    ///          <p class="title">
    ///             <b>Amazon S3 error codes</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> AccessDenied </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Access Denied</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 403 Forbidden</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> AccountProblem</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> There is a problem with your AWS account
    ///                      that prevents the action from completing successfully. Contact AWS Support
    ///                      for further assistance.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 403 Forbidden</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> AllAccessDisabled</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> All access to this Amazon S3 resource has been
    ///                      disabled. Contact AWS Support for further assistance.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 403 Forbidden</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> AmbiguousGrantByEmailAddress</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The email address you provided is
    ///                      associated with more than one account.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> AuthorizationHeaderMalformed</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The authorization header you provided is
    ///                      invalid.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> N/A</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> BadDigest</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The Content-MD5 you specified did not
    ///                      match what we received.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> BucketAlreadyExists</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The requested bucket name is not
    ///                      available. The bucket namespace is shared by all users of the system. Please
    ///                      select a different name and try again.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 409 Conflict</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> BucketAlreadyOwnedByYou</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The bucket you tried to create already
    ///                      exists, and you own it. Amazon S3 returns this error in all AWS Regions except in
    ///                      the North Virginia Region. For legacy compatibility, if you re-create an
    ///                      existing bucket that you already own in the North Virginia Region, Amazon S3 returns
    ///                      200 OK and resets the bucket access control lists (ACLs).</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> 409 Conflict (in all Regions except the North
    ///                      Virginia Region) </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> BucketNotEmpty</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The bucket you tried to delete is not
    ///                      empty.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 409 Conflict</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> CredentialsNotSupported</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> This request does not support
    ///                      credentials.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> CrossLocationLoggingProhibited</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Cross-location logging not allowed.
    ///                      Buckets in one geographic location cannot log information to a bucket in
    ///                      another location.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 403 Forbidden</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> EntityTooSmall</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Your proposed upload is smaller than the
    ///                      minimum allowed object size.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> EntityTooLarge</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Your proposed upload exceeds the maximum
    ///                      allowed object size.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> ExpiredToken</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The provided token has expired.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> IllegalVersioningConfigurationException </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Indicates that the versioning
    ///                      configuration specified in the request is invalid.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> IncompleteBody</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> You did not provide the number of bytes
    ///                      specified by the Content-Length HTTP header</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> IncorrectNumberOfFilesInPostRequest</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> POST requires exactly one file upload per
    ///                      request.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InlineDataTooLarge</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Inline data exceeds the maximum allowed
    ///                      size.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InternalError</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> We encountered an internal error. Please
    ///                      try again.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 500 Internal Server Error</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Server</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidAccessKeyId</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The AWS access key ID you provided does
    ///                      not exist in our records.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 403 Forbidden</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidAddressingHeader</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> You must specify the Anonymous
    ///                      role.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> N/A</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidArgument</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Invalid Argument</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidBucketName</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The specified bucket is not valid.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidBucketState</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The request is not valid with the current
    ///                      state of the bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 409 Conflict</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidDigest</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The Content-MD5 you specified is not
    ///                      valid.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidEncryptionAlgorithmError</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The encryption request you specified is
    ///                      not valid. The valid value is AES256.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidLocationConstraint</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The specified location constraint is not
    ///                      valid. For more information about Regions, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingBucket.html#access-bucket-intro">How to Select a
    ///                         Region for Your Buckets</a>. </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidObjectState</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The action is not valid for the current
    ///                      state of the object.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 403 Forbidden</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidPart</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> One or more of the specified parts could
    ///                      not be found. The part might not have been uploaded, or the specified entity
    ///                      tag might not have matched the part's entity tag.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidPartOrder</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The list of parts was not in ascending
    ///                      order. Parts list must be specified in order by part number.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidPayer</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> All access to this object has been
    ///                      disabled. Please contact AWS Support for further assistance.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 403 Forbidden</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidPolicyDocument</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The content of the form does not meet the
    ///                      conditions specified in the policy document.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidRange</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The requested range cannot be
    ///                      satisfied.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 416 Requested Range Not
    ///                      Satisfiable</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidRequest</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Please use AWS4-HMAC-SHA256.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> N/A</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidRequest</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> SOAP requests must be made over an HTTPS
    ///                      connection.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidRequest</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Amazon S3 Transfer Acceleration is not
    ///                      supported for buckets with non-DNS compliant names.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> N/A</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidRequest</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Amazon S3 Transfer Acceleration is not
    ///                      supported for buckets with periods (.) in their names.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> N/A</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidRequest</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Amazon S3 Transfer Accelerate endpoint only
    ///                      supports virtual style requests.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> N/A</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidRequest</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Amazon S3 Transfer Accelerate is not configured
    ///                      on this bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> N/A</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidRequest</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Amazon S3 Transfer Accelerate is disabled on
    ///                      this bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> N/A</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidRequest</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Amazon S3 Transfer Acceleration is not
    ///                      supported on this bucket. Contact AWS Support for more information.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> N/A</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidRequest</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Amazon S3 Transfer Acceleration cannot be
    ///                      enabled on this bucket. Contact AWS Support for more information.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> N/A</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidSecurity</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The provided security credentials are not
    ///                      valid.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 403 Forbidden</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidSOAPRequest</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The SOAP request body is invalid.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidStorageClass</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The storage class you specified is not
    ///                      valid.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidTargetBucketForLogging</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The target bucket for logging does not
    ///                      exist, is not owned by you, or does not have the appropriate grants for the
    ///                      log-delivery group. </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidToken</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The provided token is malformed or
    ///                      otherwise invalid.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> InvalidURI</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Couldn't parse the specified URI.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> KeyTooLongError</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Your key is too long.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> MalformedACLError</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The XML you provided was not well-formed
    ///                      or did not validate against our published schema.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> MalformedPOSTRequest </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The body of your POST request is not
    ///                      well-formed multipart/form-data.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> MalformedXML</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> This happens when the user sends malformed
    ///                      XML (XML that doesn't conform to the published XSD) for the configuration. The
    ///                      error message is, "The XML you provided was not well-formed or did not validate
    ///                      against our published schema." </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> MaxMessageLengthExceeded</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Your request was too big.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> MaxPostPreDataLengthExceededError</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Your POST request fields preceding the
    ///                      upload file were too large.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> MetadataTooLarge</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Your metadata headers exceed the maximum
    ///                      allowed metadata size.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> MethodNotAllowed</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The specified method is not allowed
    ///                      against this resource.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 405 Method Not Allowed</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> MissingAttachment</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> A SOAP attachment was expected, but none
    ///                      were found.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> N/A</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> MissingContentLength</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> You must provide the Content-Length HTTP
    ///                      header.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 411 Length Required</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> MissingRequestBodyError</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> This happens when the user sends an empty
    ///                      XML document as a request. The error message is, "Request body is empty."
    ///                   </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> MissingSecurityElement</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The SOAP 1.1 request is missing a security
    ///                      element.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> MissingSecurityHeader</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Your request is missing a required
    ///                      header.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> NoLoggingStatusForKey</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> There is no such thing as a logging status
    ///                      subresource for a key.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> NoSuchBucket</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The specified bucket does not
    ///                      exist.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 404 Not Found</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> NoSuchBucketPolicy</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The specified bucket does not have a
    ///                      bucket policy.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 404 Not Found</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> NoSuchKey</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The specified key does not exist.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 404 Not Found</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> NoSuchLifecycleConfiguration</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The lifecycle configuration does not
    ///                      exist. </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 404 Not Found</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> NoSuchUpload</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The specified multipart upload does not
    ///                      exist. The upload ID might be invalid, or the multipart upload might have been
    ///                      aborted or completed.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 404 Not Found</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> NoSuchVersion </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Indicates that the version ID specified in
    ///                      the request does not match an existing version.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 404 Not Found</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> NotImplemented</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> A header you provided implies
    ///                      functionality that is not implemented.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 501 Not Implemented</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Server</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> NotSignedUp</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Your account is not signed up for the Amazon S3
    ///                      service. You must sign up before you can use Amazon S3. You can sign up at the
    ///                      following URL: https://aws.amazon.com/s3</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 403 Forbidden</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> OperationAborted</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> A conflicting conditional action is
    ///                      currently in progress against this resource. Try again.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 409 Conflict</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> PermanentRedirect</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The bucket you are attempting to access
    ///                      must be addressed using the specified endpoint. Send all future requests to
    ///                      this endpoint.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 301 Moved Permanently</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> PreconditionFailed</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> At least one of the preconditions you
    ///                      specified did not hold.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 412 Precondition Failed</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> Redirect</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Temporary redirect.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 307 Moved Temporarily</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> RestoreAlreadyInProgress</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Object restore is already in
    ///                      progress.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 409 Conflict</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> RequestIsNotMultiPartContent</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Bucket POST must be of the enclosure-type
    ///                      multipart/form-data.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> RequestTimeout</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Your socket connection to the server was
    ///                      not read from or written to within the timeout period.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> RequestTimeTooSkewed</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The difference between the request time
    ///                      and the server's time is too large.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 403 Forbidden</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> RequestTorrentOfBucketError</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Requesting the torrent file of a bucket is
    ///                      not permitted.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> SignatureDoesNotMatch</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The request signature we calculated does
    ///                      not match the signature you provided. Check your AWS secret access key and
    ///                      signing method. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html">REST Authentication</a> and
    ///                         <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/SOAPAuthentication.html">SOAP Authentication</a>
    ///                      for details.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 403 Forbidden</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> ServiceUnavailable</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Reduce your request rate.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 503 Service Unavailable</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Server</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> SlowDown</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> Reduce your request rate.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 503 Slow Down</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Server</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> TemporaryRedirect</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> You are being redirected to the bucket
    ///                      while DNS updates.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 307 Moved Temporarily</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> TokenRefreshRequired</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The provided token must be
    ///                      refreshed.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> TooManyBuckets</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> You have attempted to create more buckets
    ///                      than allowed.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> UnexpectedContent</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> This request does not support
    ///                      content.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> UnresolvableGrantByEmailAddress</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The email address you provided does not
    ///                      match any account on record.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <i>Code:</i> UserKeyMustBeSpecified</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>Description:</i> The bucket POST must contain the specified
    ///                      field name. If it is specified, check the order of the fields.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>HTTP Status Code:</i> 400 Bad Request</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <i>SOAP Fault Code Prefix:</i> Client</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    ///          <p></p>
    public let code: String?
    /// <p>The error key.</p>
    public let key: String?
    /// <p>The error message contains a generic description of the error condition in English. It
    ///          is intended for a human audience. Simple programs display the message directly to the end
    ///          user if they encounter an error condition they don't know how or don't care to handle.
    ///          Sophisticated programs with more exhaustive error handling and proper internationalization
    ///          are more likely to ignore the error message.</p>
    public let message: String?
    /// <p>The version ID of the error.</p>
    public let versionId: String?

    public init (
        code: String? = nil,
        key: String? = nil,
        message: String? = nil,
        versionId: String? = nil
    )
    {
        self.code = code
        self.key = key
        self.message = message
        self.versionId = versionId
    }
}

extension ErrorDocument: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let key = key {
            try container.encode(key, forKey: Key("key"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
    }
}

extension ErrorDocument: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ErrorDocument(key: \(String(describing: key)))"}
}

extension ErrorDocument: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The error information.</p>
public struct ErrorDocument: Equatable {
    /// <p>The object key name to use when a 4XX class error occurs.</p>
    ///          <important>
    ///             <p>Replacement must be made for object keys containing special characters (such as carriage returns) when using
    ///          XML requests. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints">
    ///             XML related object key constraints</a>.</p>
    ///          </important>
    public let key: String?

    public init (
        key: String? = nil
    )
    {
        self.key = key
    }
}

/// <p>The bucket event for which to send notifications.</p>
public enum Event {
    case s3objectcreated
    case s3objectcreatedcompletemultipartupload
    case s3objectcreatedcopy
    case s3objectcreatedpost
    case s3objectcreatedput
    case s3objectremoved
    case s3objectremoveddelete
    case s3objectremoveddeletemarkercreated
    case s3objectrestore
    case s3objectrestorecompleted
    case s3objectrestorepost
    case s3reducedredundancylostobject
    case s3replication
    case s3replicationoperationfailedreplication
    case s3replicationoperationmissedthreshold
    case s3replicationoperationnottracked
    case s3replicationoperationreplicatedafterthreshold
    case sdkUnknown(String)
}

extension Event : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Event] {
        return [
            .s3objectcreated,
            .s3objectcreatedcompletemultipartupload,
            .s3objectcreatedcopy,
            .s3objectcreatedpost,
            .s3objectcreatedput,
            .s3objectremoved,
            .s3objectremoveddelete,
            .s3objectremoveddeletemarkercreated,
            .s3objectrestore,
            .s3objectrestorecompleted,
            .s3objectrestorepost,
            .s3reducedredundancylostobject,
            .s3replication,
            .s3replicationoperationfailedreplication,
            .s3replicationoperationmissedthreshold,
            .s3replicationoperationnottracked,
            .s3replicationoperationreplicatedafterthreshold,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .s3objectcreated: return "s3:ObjectCreated:*"
        case .s3objectcreatedcompletemultipartupload: return "s3:ObjectCreated:CompleteMultipartUpload"
        case .s3objectcreatedcopy: return "s3:ObjectCreated:Copy"
        case .s3objectcreatedpost: return "s3:ObjectCreated:Post"
        case .s3objectcreatedput: return "s3:ObjectCreated:Put"
        case .s3objectremoved: return "s3:ObjectRemoved:*"
        case .s3objectremoveddelete: return "s3:ObjectRemoved:Delete"
        case .s3objectremoveddeletemarkercreated: return "s3:ObjectRemoved:DeleteMarkerCreated"
        case .s3objectrestore: return "s3:ObjectRestore:*"
        case .s3objectrestorecompleted: return "s3:ObjectRestore:Completed"
        case .s3objectrestorepost: return "s3:ObjectRestore:Post"
        case .s3reducedredundancylostobject: return "s3:ReducedRedundancyLostObject"
        case .s3replication: return "s3:Replication:*"
        case .s3replicationoperationfailedreplication: return "s3:Replication:OperationFailedReplication"
        case .s3replicationoperationmissedthreshold: return "s3:Replication:OperationMissedThreshold"
        case .s3replicationoperationnottracked: return "s3:Replication:OperationNotTracked"
        case .s3replicationoperationreplicatedafterthreshold: return "s3:Replication:OperationReplicatedAfterThreshold"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Event(rawValue: rawValue) ?? Event.sdkUnknown(rawValue)
    }
}

extension ExistingObjectReplication: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ExistingObjectReplicationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ExistingObjectReplication: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExistingObjectReplication(status: \(String(describing: status)))"}
}

extension ExistingObjectReplication: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Optional configuration to replicate existing source bucket objects. For more
///          information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-what-is-isnot-replicated.html#existing-object-replication">Replicating Existing Objects</a> in the <i>Amazon S3 User Guide</i>.
///       </p>
public struct ExistingObjectReplication: Equatable {
    /// <p></p>
    public let status: ExistingObjectReplicationStatus?

    public init (
        status: ExistingObjectReplicationStatus? = nil
    )
    {
        self.status = status
    }
}

public enum ExistingObjectReplicationStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension ExistingObjectReplicationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExistingObjectReplicationStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "Disabled"
        case .enabled: return "Enabled"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExistingObjectReplicationStatus(rawValue: rawValue) ?? ExistingObjectReplicationStatus.sdkUnknown(rawValue)
    }
}

public enum ExpirationStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension ExpirationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExpirationStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "Disabled"
        case .enabled: return "Enabled"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExpirationStatus(rawValue: rawValue) ?? ExpirationStatus.sdkUnknown(rawValue)
    }
}

public enum ExpressionType {
    case sql
    case sdkUnknown(String)
}

extension ExpressionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExpressionType] {
        return [
            .sql,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .sql: return "SQL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExpressionType(rawValue: rawValue) ?? ExpressionType.sdkUnknown(rawValue)
    }
}

public enum FileHeaderInfo {
    case ignore
    case `none`
    case use
    case sdkUnknown(String)
}

extension FileHeaderInfo : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FileHeaderInfo] {
        return [
            .ignore,
            .none,
            .use,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ignore: return "IGNORE"
        case .none: return "NONE"
        case .use: return "USE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FileHeaderInfo(rawValue: rawValue) ?? FileHeaderInfo.sdkUnknown(rawValue)
    }
}

extension FilterRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("name"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(FilterRuleName.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension FilterRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FilterRule(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

extension FilterRule: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies the Amazon S3 object key name to filter on and whether to filter on the suffix or
///          prefix of the key name.</p>
public struct FilterRule: Equatable {
    /// <p>The object key name prefix or suffix identifying one or more objects to which the
    ///          filtering rule applies. The maximum length is 1,024 characters. Overlapping prefixes and
    ///          suffixes are not supported. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html">Configuring Event Notifications</a>
    ///          in the <i>Amazon S3 User Guide</i>.</p>
    public let name: FilterRuleName?
    /// <p>The value that the filter searches for in object key names.</p>
    public let value: String?

    public init (
        name: FilterRuleName? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

public enum FilterRuleName {
    case prefix
    case suffix
    case sdkUnknown(String)
}

extension FilterRuleName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FilterRuleName] {
        return [
            .prefix,
            .suffix,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .prefix: return "prefix"
        case .suffix: return "suffix"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FilterRuleName(rawValue: rawValue) ?? FilterRuleName.sdkUnknown(rawValue)
    }
}

extension GetBucketAccelerateConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketAccelerateConfigurationInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension GetBucketAccelerateConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketAccelerateConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketAccelerateConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketAccelerateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketAccelerateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketAccelerateConfigurationInput>
    public typealias MOutput = OperationOutput<GetBucketAccelerateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketAccelerateConfigurationOutputError>
}

public struct GetBucketAccelerateConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketAccelerateConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketAccelerateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketAccelerateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "accelerate", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketAccelerateConfigurationInput>
    public typealias MOutput = OperationOutput<GetBucketAccelerateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketAccelerateConfigurationOutputError>
}

public struct GetBucketAccelerateConfigurationInput: Equatable {
    /// <p>The name of the bucket for which the accelerate configuration is retrieved.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketAccelerateConfigurationInputBody: Equatable {
}

extension GetBucketAccelerateConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketAccelerateConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketAccelerateConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketAccelerateConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketAccelerateConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketAccelerateConfigurationOutputResponse(status: \(String(describing: status)))"}
}

extension GetBucketAccelerateConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBucketAccelerateConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct GetBucketAccelerateConfigurationOutputResponse: Equatable {
    /// <p>The accelerate configuration of the bucket.</p>
    public let status: BucketAccelerateStatus?

    public init (
        status: BucketAccelerateStatus? = nil
    )
    {
        self.status = status
    }
}

struct GetBucketAccelerateConfigurationOutputResponseBody: Equatable {
    public let status: BucketAccelerateStatus?
}

extension GetBucketAccelerateConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(BucketAccelerateStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GetBucketAclInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketAclInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension GetBucketAclInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketAclInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketAclInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketAclInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketAclOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketAclInput>
    public typealias MOutput = OperationOutput<GetBucketAclOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketAclOutputError>
}

public struct GetBucketAclInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketAclInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketAclInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketAclOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "acl", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketAclInput>
    public typealias MOutput = OperationOutput<GetBucketAclOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketAclOutputError>
}

public struct GetBucketAclInput: Equatable {
    /// <p>Specifies the S3 bucket whose ACL is being requested.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketAclInputBody: Equatable {
}

extension GetBucketAclInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketAclOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketAclOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketAclOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketAclOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketAclOutputResponse(grants: \(String(describing: grants)), owner: \(String(describing: owner)))"}
}

extension GetBucketAclOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBucketAclOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.grants = output.grants
            self.owner = output.owner
        } else {
            self.grants = nil
            self.owner = nil
        }
    }
}

public struct GetBucketAclOutputResponse: Equatable {
    /// <p>A list of grants.</p>
    public let grants: [Grant]?
    /// <p>Container for the bucket owner's display name and ID.</p>
    public let owner: Owner?

    public init (
        grants: [Grant]? = nil,
        owner: Owner? = nil
    )
    {
        self.grants = grants
        self.owner = owner
    }
}

struct GetBucketAclOutputResponseBody: Equatable {
    public let owner: Owner?
    public let grants: [Grant]?
}

extension GetBucketAclOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grants = "AccessControlList"
        case owner = "Owner"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(Owner.self, forKey: .owner)
        owner = ownerDecoded
        if containerValues.contains(.grants) {
            struct KeyVal0{struct Grant{}}
            let grantsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Grant>.CodingKeys.self, forKey: .grants)
            if let grantsWrappedContainer = grantsWrappedContainer {
                let grantsContainer = try grantsWrappedContainer.decodeIfPresent([Grant].self, forKey: .member)
                var grantsBuffer:[Grant]? = nil
                if let grantsContainer = grantsContainer {
                    grantsBuffer = [Grant]()
                    for structureContainer0 in grantsContainer {
                        grantsBuffer?.append(structureContainer0)
                    }
                }
                grants = grantsBuffer
            } else {
                grants = []
            }
        } else {
            grants = nil
        }
    }
}

extension GetBucketAnalyticsConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketAnalyticsConfigurationInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), id: \(String(describing: id)))"}
}

extension GetBucketAnalyticsConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketAnalyticsConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketAnalyticsConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketAnalyticsConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketAnalyticsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketAnalyticsConfigurationInput>
    public typealias MOutput = OperationOutput<GetBucketAnalyticsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketAnalyticsConfigurationOutputError>
}

public struct GetBucketAnalyticsConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketAnalyticsConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketAnalyticsConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketAnalyticsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "analytics", value: nil))
        input.builder.withQueryItem(URLQueryItem(name: "x-id", value: "GetBucketAnalyticsConfiguration"))
        if let id = input.operationInput.id {
            let idQueryItem = URLQueryItem(name: "id".urlPercentEncoding(), value: String(id).urlPercentEncoding())
            input.builder.withQueryItem(idQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketAnalyticsConfigurationInput>
    public typealias MOutput = OperationOutput<GetBucketAnalyticsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketAnalyticsConfigurationOutputError>
}

public struct GetBucketAnalyticsConfigurationInput: Equatable {
    /// <p>The name of the bucket from which an analytics configuration is retrieved.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The ID that identifies the analytics configuration.</p>
    public let id: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        id: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.id = id
    }
}

struct GetBucketAnalyticsConfigurationInputBody: Equatable {
}

extension GetBucketAnalyticsConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketAnalyticsConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketAnalyticsConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketAnalyticsConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketAnalyticsConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketAnalyticsConfigurationOutputResponse(analyticsConfiguration: \(String(describing: analyticsConfiguration)))"}
}

extension GetBucketAnalyticsConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: AnalyticsConfiguration = try responseDecoder.decode(responseBody: unwrappedData)
                self.analyticsConfiguration = output
            } else {
                self.analyticsConfiguration = nil
            }
        } else {
            self.analyticsConfiguration = nil
        }
    }
}

public struct GetBucketAnalyticsConfigurationOutputResponse: Equatable {
    /// <p>The configuration and any analyses for the analytics filter.</p>
    public let analyticsConfiguration: AnalyticsConfiguration?

    public init (
        analyticsConfiguration: AnalyticsConfiguration? = nil
    )
    {
        self.analyticsConfiguration = analyticsConfiguration
    }
}

struct GetBucketAnalyticsConfigurationOutputResponseBody: Equatable {
    public let analyticsConfiguration: AnalyticsConfiguration?
}

extension GetBucketAnalyticsConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyticsConfiguration = "AnalyticsConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyticsConfigurationDecoded = try containerValues.decodeIfPresent(AnalyticsConfiguration.self, forKey: .analyticsConfiguration)
        analyticsConfiguration = analyticsConfigurationDecoded
    }
}

extension GetBucketCorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketCorsInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension GetBucketCorsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketCorsInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketCorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketCorsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketCorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketCorsInput>
    public typealias MOutput = OperationOutput<GetBucketCorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketCorsOutputError>
}

public struct GetBucketCorsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketCorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketCorsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketCorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "cors", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketCorsInput>
    public typealias MOutput = OperationOutput<GetBucketCorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketCorsOutputError>
}

public struct GetBucketCorsInput: Equatable {
    /// <p>The bucket name for which to get the cors configuration.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketCorsInputBody: Equatable {
}

extension GetBucketCorsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketCorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketCorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketCorsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketCorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketCorsOutputResponse(cORSRules: \(String(describing: cORSRules)))"}
}

extension GetBucketCorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBucketCorsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cORSRules = output.cORSRules
        } else {
            self.cORSRules = nil
        }
    }
}

public struct GetBucketCorsOutputResponse: Equatable {
    /// <p>A set of origins and methods (cross-origin access that you want to allow). You can add
    ///          up to 100 rules to the configuration.</p>
    public let cORSRules: [CORSRule]?

    public init (
        cORSRules: [CORSRule]? = nil
    )
    {
        self.cORSRules = cORSRules
    }
}

struct GetBucketCorsOutputResponseBody: Equatable {
    public let cORSRules: [CORSRule]?
}

extension GetBucketCorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cORSRules = "CORSRule"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.cORSRules) {
            let cORSRulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .cORSRules)
            if cORSRulesWrappedContainer != nil {
                let cORSRulesContainer = try containerValues.decodeIfPresent([CORSRule].self, forKey: .cORSRules)
                var cORSRulesBuffer:[CORSRule]? = nil
                if let cORSRulesContainer = cORSRulesContainer {
                    cORSRulesBuffer = [CORSRule]()
                    for structureContainer0 in cORSRulesContainer {
                        cORSRulesBuffer?.append(structureContainer0)
                    }
                }
                cORSRules = cORSRulesBuffer
            } else {
                cORSRules = []
            }
        } else {
            cORSRules = nil
        }
    }
}

extension GetBucketEncryptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketEncryptionInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension GetBucketEncryptionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketEncryptionInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketEncryptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketEncryptionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketEncryptionInput>
    public typealias MOutput = OperationOutput<GetBucketEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketEncryptionOutputError>
}

public struct GetBucketEncryptionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketEncryptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketEncryptionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "encryption", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketEncryptionInput>
    public typealias MOutput = OperationOutput<GetBucketEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketEncryptionOutputError>
}

public struct GetBucketEncryptionInput: Equatable {
    /// <p>The name of the bucket from which the server-side encryption configuration is
    ///          retrieved.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketEncryptionInputBody: Equatable {
}

extension GetBucketEncryptionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketEncryptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketEncryptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketEncryptionOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketEncryptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketEncryptionOutputResponse(serverSideEncryptionConfiguration: \(String(describing: serverSideEncryptionConfiguration)))"}
}

extension GetBucketEncryptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ServerSideEncryptionConfiguration = try responseDecoder.decode(responseBody: unwrappedData)
                self.serverSideEncryptionConfiguration = output
            } else {
                self.serverSideEncryptionConfiguration = nil
            }
        } else {
            self.serverSideEncryptionConfiguration = nil
        }
    }
}

public struct GetBucketEncryptionOutputResponse: Equatable {
    /// <p>Specifies the default server-side-encryption configuration.</p>
    public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?

    public init (
        serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil
    )
    {
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
    }
}

struct GetBucketEncryptionOutputResponseBody: Equatable {
    public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
}

extension GetBucketEncryptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
    }
}

extension GetBucketIntelligentTieringConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketIntelligentTieringConfigurationInput(bucket: \(String(describing: bucket)), id: \(String(describing: id)))"}
}

extension GetBucketIntelligentTieringConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketIntelligentTieringConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketIntelligentTieringConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketIntelligentTieringConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketIntelligentTieringConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketIntelligentTieringConfigurationInput>
    public typealias MOutput = OperationOutput<GetBucketIntelligentTieringConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketIntelligentTieringConfigurationOutputError>
}

public struct GetBucketIntelligentTieringConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketIntelligentTieringConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketIntelligentTieringConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketIntelligentTieringConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "intelligent-tiering", value: nil))
        input.builder.withQueryItem(URLQueryItem(name: "x-id", value: "GetBucketIntelligentTieringConfiguration"))
        if let id = input.operationInput.id {
            let idQueryItem = URLQueryItem(name: "id".urlPercentEncoding(), value: String(id).urlPercentEncoding())
            input.builder.withQueryItem(idQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketIntelligentTieringConfigurationInput>
    public typealias MOutput = OperationOutput<GetBucketIntelligentTieringConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketIntelligentTieringConfigurationOutputError>
}

public struct GetBucketIntelligentTieringConfigurationInput: Equatable {
    /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
    public let bucket: String?
    /// <p>The ID used to identify the S3 Intelligent-Tiering configuration.</p>
    public let id: String?

    public init (
        bucket: String? = nil,
        id: String? = nil
    )
    {
        self.bucket = bucket
        self.id = id
    }
}

struct GetBucketIntelligentTieringConfigurationInputBody: Equatable {
}

extension GetBucketIntelligentTieringConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketIntelligentTieringConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketIntelligentTieringConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketIntelligentTieringConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketIntelligentTieringConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketIntelligentTieringConfigurationOutputResponse(intelligentTieringConfiguration: \(String(describing: intelligentTieringConfiguration)))"}
}

extension GetBucketIntelligentTieringConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: IntelligentTieringConfiguration = try responseDecoder.decode(responseBody: unwrappedData)
                self.intelligentTieringConfiguration = output
            } else {
                self.intelligentTieringConfiguration = nil
            }
        } else {
            self.intelligentTieringConfiguration = nil
        }
    }
}

public struct GetBucketIntelligentTieringConfigurationOutputResponse: Equatable {
    /// <p>Container for S3 Intelligent-Tiering configuration.</p>
    public let intelligentTieringConfiguration: IntelligentTieringConfiguration?

    public init (
        intelligentTieringConfiguration: IntelligentTieringConfiguration? = nil
    )
    {
        self.intelligentTieringConfiguration = intelligentTieringConfiguration
    }
}

struct GetBucketIntelligentTieringConfigurationOutputResponseBody: Equatable {
    public let intelligentTieringConfiguration: IntelligentTieringConfiguration?
}

extension GetBucketIntelligentTieringConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case intelligentTieringConfiguration = "IntelligentTieringConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intelligentTieringConfigurationDecoded = try containerValues.decodeIfPresent(IntelligentTieringConfiguration.self, forKey: .intelligentTieringConfiguration)
        intelligentTieringConfiguration = intelligentTieringConfigurationDecoded
    }
}

extension GetBucketInventoryConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketInventoryConfigurationInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), id: \(String(describing: id)))"}
}

extension GetBucketInventoryConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketInventoryConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketInventoryConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketInventoryConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketInventoryConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketInventoryConfigurationInput>
    public typealias MOutput = OperationOutput<GetBucketInventoryConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketInventoryConfigurationOutputError>
}

public struct GetBucketInventoryConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketInventoryConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketInventoryConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketInventoryConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "inventory", value: nil))
        input.builder.withQueryItem(URLQueryItem(name: "x-id", value: "GetBucketInventoryConfiguration"))
        if let id = input.operationInput.id {
            let idQueryItem = URLQueryItem(name: "id".urlPercentEncoding(), value: String(id).urlPercentEncoding())
            input.builder.withQueryItem(idQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketInventoryConfigurationInput>
    public typealias MOutput = OperationOutput<GetBucketInventoryConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketInventoryConfigurationOutputError>
}

public struct GetBucketInventoryConfigurationInput: Equatable {
    /// <p>The name of the bucket containing the inventory configuration to retrieve.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The ID used to identify the inventory configuration.</p>
    public let id: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        id: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.id = id
    }
}

struct GetBucketInventoryConfigurationInputBody: Equatable {
}

extension GetBucketInventoryConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketInventoryConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketInventoryConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketInventoryConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketInventoryConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketInventoryConfigurationOutputResponse(inventoryConfiguration: \(String(describing: inventoryConfiguration)))"}
}

extension GetBucketInventoryConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: InventoryConfiguration = try responseDecoder.decode(responseBody: unwrappedData)
                self.inventoryConfiguration = output
            } else {
                self.inventoryConfiguration = nil
            }
        } else {
            self.inventoryConfiguration = nil
        }
    }
}

public struct GetBucketInventoryConfigurationOutputResponse: Equatable {
    /// <p>Specifies the inventory configuration.</p>
    public let inventoryConfiguration: InventoryConfiguration?

    public init (
        inventoryConfiguration: InventoryConfiguration? = nil
    )
    {
        self.inventoryConfiguration = inventoryConfiguration
    }
}

struct GetBucketInventoryConfigurationOutputResponseBody: Equatable {
    public let inventoryConfiguration: InventoryConfiguration?
}

extension GetBucketInventoryConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inventoryConfiguration = "InventoryConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inventoryConfigurationDecoded = try containerValues.decodeIfPresent(InventoryConfiguration.self, forKey: .inventoryConfiguration)
        inventoryConfiguration = inventoryConfigurationDecoded
    }
}

extension GetBucketLifecycleConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketLifecycleConfigurationInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension GetBucketLifecycleConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketLifecycleConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketLifecycleConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketLifecycleConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketLifecycleConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketLifecycleConfigurationInput>
    public typealias MOutput = OperationOutput<GetBucketLifecycleConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketLifecycleConfigurationOutputError>
}

public struct GetBucketLifecycleConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketLifecycleConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketLifecycleConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketLifecycleConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "lifecycle", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketLifecycleConfigurationInput>
    public typealias MOutput = OperationOutput<GetBucketLifecycleConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketLifecycleConfigurationOutputError>
}

public struct GetBucketLifecycleConfigurationInput: Equatable {
    /// <p>The name of the bucket for which to get the lifecycle information.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketLifecycleConfigurationInputBody: Equatable {
}

extension GetBucketLifecycleConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketLifecycleConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketLifecycleConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketLifecycleConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketLifecycleConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketLifecycleConfigurationOutputResponse(rules: \(String(describing: rules)))"}
}

extension GetBucketLifecycleConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBucketLifecycleConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.rules = output.rules
        } else {
            self.rules = nil
        }
    }
}

public struct GetBucketLifecycleConfigurationOutputResponse: Equatable {
    /// <p>Container for a lifecycle rule.</p>
    public let rules: [LifecycleRule]?

    public init (
        rules: [LifecycleRule]? = nil
    )
    {
        self.rules = rules
    }
}

struct GetBucketLifecycleConfigurationOutputResponseBody: Equatable {
    public let rules: [LifecycleRule]?
}

extension GetBucketLifecycleConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case rules = "Rule"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.rules) {
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .rules)
            if rulesWrappedContainer != nil {
                let rulesContainer = try containerValues.decodeIfPresent([LifecycleRule].self, forKey: .rules)
                var rulesBuffer:[LifecycleRule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [LifecycleRule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

extension GetBucketLocationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketLocationInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension GetBucketLocationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketLocationInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketLocationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketLocationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketLocationInput>
    public typealias MOutput = OperationOutput<GetBucketLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketLocationOutputError>
}

public struct GetBucketLocationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketLocationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketLocationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "location", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketLocationInput>
    public typealias MOutput = OperationOutput<GetBucketLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketLocationOutputError>
}

public struct GetBucketLocationInput: Equatable {
    /// <p>The name of the bucket for which to get the location.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketLocationInputBody: Equatable {
}

extension GetBucketLocationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketLocationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketLocationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketLocationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketLocationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketLocationOutputResponse(locationConstraint: \(String(describing: locationConstraint)))"}
}

extension GetBucketLocationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBucketLocationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.locationConstraint = output.locationConstraint
        } else {
            self.locationConstraint = nil
        }
    }
}

public struct GetBucketLocationOutputResponse: Equatable {
    /// <p>Specifies the Region where the bucket resides. For a list of all the Amazon S3 supported
    ///          location constraints by Region, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region">Regions and Endpoints</a>.
    ///          Buckets in Region <code>us-east-1</code> have a LocationConstraint of
    ///          <code>null</code>.</p>
    public let locationConstraint: BucketLocationConstraint?

    public init (
        locationConstraint: BucketLocationConstraint? = nil
    )
    {
        self.locationConstraint = locationConstraint
    }
}

struct GetBucketLocationOutputResponseBody: Equatable {
    public let locationConstraint: BucketLocationConstraint?
}

extension GetBucketLocationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case locationConstraint = "LocationConstraint"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationConstraintDecoded = try containerValues.decodeIfPresent(BucketLocationConstraint.self, forKey: .locationConstraint)
        locationConstraint = locationConstraintDecoded
    }
}

extension GetBucketLoggingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketLoggingInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension GetBucketLoggingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketLoggingInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketLoggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketLoggingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketLoggingInput>
    public typealias MOutput = OperationOutput<GetBucketLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketLoggingOutputError>
}

public struct GetBucketLoggingInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketLoggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketLoggingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "logging", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketLoggingInput>
    public typealias MOutput = OperationOutput<GetBucketLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketLoggingOutputError>
}

public struct GetBucketLoggingInput: Equatable {
    /// <p>The bucket name for which to get the logging information.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketLoggingInputBody: Equatable {
}

extension GetBucketLoggingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketLoggingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketLoggingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketLoggingOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketLoggingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketLoggingOutputResponse(loggingEnabled: \(String(describing: loggingEnabled)))"}
}

extension GetBucketLoggingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBucketLoggingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.loggingEnabled = output.loggingEnabled
        } else {
            self.loggingEnabled = nil
        }
    }
}

public struct GetBucketLoggingOutputResponse: Equatable {
    /// <p>Describes where logs are stored and the prefix that Amazon S3 assigns to all log object keys
    ///          for a bucket. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTlogging.html">PUT Bucket logging</a> in the
    ///             <i>Amazon S3 API Reference</i>.</p>
    public let loggingEnabled: LoggingEnabled?

    public init (
        loggingEnabled: LoggingEnabled? = nil
    )
    {
        self.loggingEnabled = loggingEnabled
    }
}

struct GetBucketLoggingOutputResponseBody: Equatable {
    public let loggingEnabled: LoggingEnabled?
}

extension GetBucketLoggingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loggingEnabled = "LoggingEnabled"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingEnabledDecoded = try containerValues.decodeIfPresent(LoggingEnabled.self, forKey: .loggingEnabled)
        loggingEnabled = loggingEnabledDecoded
    }
}

extension GetBucketMetricsConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketMetricsConfigurationInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), id: \(String(describing: id)))"}
}

extension GetBucketMetricsConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketMetricsConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketMetricsConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketMetricsConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketMetricsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketMetricsConfigurationInput>
    public typealias MOutput = OperationOutput<GetBucketMetricsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketMetricsConfigurationOutputError>
}

public struct GetBucketMetricsConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketMetricsConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketMetricsConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketMetricsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "metrics", value: nil))
        input.builder.withQueryItem(URLQueryItem(name: "x-id", value: "GetBucketMetricsConfiguration"))
        if let id = input.operationInput.id {
            let idQueryItem = URLQueryItem(name: "id".urlPercentEncoding(), value: String(id).urlPercentEncoding())
            input.builder.withQueryItem(idQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketMetricsConfigurationInput>
    public typealias MOutput = OperationOutput<GetBucketMetricsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketMetricsConfigurationOutputError>
}

public struct GetBucketMetricsConfigurationInput: Equatable {
    /// <p>The name of the bucket containing the metrics configuration to retrieve.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The ID used to identify the metrics configuration.</p>
    public let id: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        id: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.id = id
    }
}

struct GetBucketMetricsConfigurationInputBody: Equatable {
}

extension GetBucketMetricsConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketMetricsConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketMetricsConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketMetricsConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketMetricsConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketMetricsConfigurationOutputResponse(metricsConfiguration: \(String(describing: metricsConfiguration)))"}
}

extension GetBucketMetricsConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: MetricsConfiguration = try responseDecoder.decode(responseBody: unwrappedData)
                self.metricsConfiguration = output
            } else {
                self.metricsConfiguration = nil
            }
        } else {
            self.metricsConfiguration = nil
        }
    }
}

public struct GetBucketMetricsConfigurationOutputResponse: Equatable {
    /// <p>Specifies the metrics configuration.</p>
    public let metricsConfiguration: MetricsConfiguration?

    public init (
        metricsConfiguration: MetricsConfiguration? = nil
    )
    {
        self.metricsConfiguration = metricsConfiguration
    }
}

struct GetBucketMetricsConfigurationOutputResponseBody: Equatable {
    public let metricsConfiguration: MetricsConfiguration?
}

extension GetBucketMetricsConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metricsConfiguration = "MetricsConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricsConfigurationDecoded = try containerValues.decodeIfPresent(MetricsConfiguration.self, forKey: .metricsConfiguration)
        metricsConfiguration = metricsConfigurationDecoded
    }
}

extension GetBucketNotificationConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketNotificationConfigurationInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension GetBucketNotificationConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketNotificationConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketNotificationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketNotificationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketNotificationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketNotificationConfigurationInput>
    public typealias MOutput = OperationOutput<GetBucketNotificationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketNotificationConfigurationOutputError>
}

public struct GetBucketNotificationConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketNotificationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketNotificationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketNotificationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "notification", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketNotificationConfigurationInput>
    public typealias MOutput = OperationOutput<GetBucketNotificationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketNotificationConfigurationOutputError>
}

public struct GetBucketNotificationConfigurationInput: Equatable {
    /// <p>The name of the bucket for which to get the notification configuration.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketNotificationConfigurationInputBody: Equatable {
}

extension GetBucketNotificationConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketNotificationConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketNotificationConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketNotificationConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketNotificationConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketNotificationConfigurationOutputResponse(lambdaFunctionConfigurations: \(String(describing: lambdaFunctionConfigurations)), queueConfigurations: \(String(describing: queueConfigurations)), topicConfigurations: \(String(describing: topicConfigurations)))"}
}

extension GetBucketNotificationConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBucketNotificationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lambdaFunctionConfigurations = output.lambdaFunctionConfigurations
            self.queueConfigurations = output.queueConfigurations
            self.topicConfigurations = output.topicConfigurations
        } else {
            self.lambdaFunctionConfigurations = nil
            self.queueConfigurations = nil
            self.topicConfigurations = nil
        }
    }
}

/// <p>A container for specifying the notification configuration of the bucket. If this element
///          is empty, notifications are turned off for the bucket.</p>
public struct GetBucketNotificationConfigurationOutputResponse: Equatable {
    /// <p>Describes the AWS Lambda functions to invoke and the events for which to invoke
    ///          them.</p>
    public let lambdaFunctionConfigurations: [LambdaFunctionConfiguration]?
    /// <p>The Amazon Simple Queue Service queues to publish messages to and the events for which
    ///          to publish messages.</p>
    public let queueConfigurations: [QueueConfiguration]?
    /// <p>The topic to which notifications are sent and the events for which notifications are
    ///          generated.</p>
    public let topicConfigurations: [TopicConfiguration]?

    public init (
        lambdaFunctionConfigurations: [LambdaFunctionConfiguration]? = nil,
        queueConfigurations: [QueueConfiguration]? = nil,
        topicConfigurations: [TopicConfiguration]? = nil
    )
    {
        self.lambdaFunctionConfigurations = lambdaFunctionConfigurations
        self.queueConfigurations = queueConfigurations
        self.topicConfigurations = topicConfigurations
    }
}

struct GetBucketNotificationConfigurationOutputResponseBody: Equatable {
    public let topicConfigurations: [TopicConfiguration]?
    public let queueConfigurations: [QueueConfiguration]?
    public let lambdaFunctionConfigurations: [LambdaFunctionConfiguration]?
}

extension GetBucketNotificationConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lambdaFunctionConfigurations = "CloudFunctionConfiguration"
        case queueConfigurations = "QueueConfiguration"
        case topicConfigurations = "TopicConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.topicConfigurations) {
            let topicConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .topicConfigurations)
            if topicConfigurationsWrappedContainer != nil {
                let topicConfigurationsContainer = try containerValues.decodeIfPresent([TopicConfiguration].self, forKey: .topicConfigurations)
                var topicConfigurationsBuffer:[TopicConfiguration]? = nil
                if let topicConfigurationsContainer = topicConfigurationsContainer {
                    topicConfigurationsBuffer = [TopicConfiguration]()
                    for structureContainer0 in topicConfigurationsContainer {
                        topicConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                topicConfigurations = topicConfigurationsBuffer
            } else {
                topicConfigurations = []
            }
        } else {
            topicConfigurations = nil
        }
        if containerValues.contains(.queueConfigurations) {
            let queueConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .queueConfigurations)
            if queueConfigurationsWrappedContainer != nil {
                let queueConfigurationsContainer = try containerValues.decodeIfPresent([QueueConfiguration].self, forKey: .queueConfigurations)
                var queueConfigurationsBuffer:[QueueConfiguration]? = nil
                if let queueConfigurationsContainer = queueConfigurationsContainer {
                    queueConfigurationsBuffer = [QueueConfiguration]()
                    for structureContainer0 in queueConfigurationsContainer {
                        queueConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                queueConfigurations = queueConfigurationsBuffer
            } else {
                queueConfigurations = []
            }
        } else {
            queueConfigurations = nil
        }
        if containerValues.contains(.lambdaFunctionConfigurations) {
            let lambdaFunctionConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .lambdaFunctionConfigurations)
            if lambdaFunctionConfigurationsWrappedContainer != nil {
                let lambdaFunctionConfigurationsContainer = try containerValues.decodeIfPresent([LambdaFunctionConfiguration].self, forKey: .lambdaFunctionConfigurations)
                var lambdaFunctionConfigurationsBuffer:[LambdaFunctionConfiguration]? = nil
                if let lambdaFunctionConfigurationsContainer = lambdaFunctionConfigurationsContainer {
                    lambdaFunctionConfigurationsBuffer = [LambdaFunctionConfiguration]()
                    for structureContainer0 in lambdaFunctionConfigurationsContainer {
                        lambdaFunctionConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                lambdaFunctionConfigurations = lambdaFunctionConfigurationsBuffer
            } else {
                lambdaFunctionConfigurations = []
            }
        } else {
            lambdaFunctionConfigurations = nil
        }
    }
}

extension GetBucketOwnershipControlsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketOwnershipControlsInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension GetBucketOwnershipControlsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketOwnershipControlsInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketOwnershipControlsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketOwnershipControlsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketOwnershipControlsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketOwnershipControlsInput>
    public typealias MOutput = OperationOutput<GetBucketOwnershipControlsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketOwnershipControlsOutputError>
}

public struct GetBucketOwnershipControlsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketOwnershipControlsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketOwnershipControlsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketOwnershipControlsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "ownershipControls", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketOwnershipControlsInput>
    public typealias MOutput = OperationOutput<GetBucketOwnershipControlsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketOwnershipControlsOutputError>
}

public struct GetBucketOwnershipControlsInput: Equatable {
    /// <p>The name of the Amazon S3 bucket whose <code>OwnershipControls</code> you want to retrieve.
    ///       </p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketOwnershipControlsInputBody: Equatable {
}

extension GetBucketOwnershipControlsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketOwnershipControlsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketOwnershipControlsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketOwnershipControlsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketOwnershipControlsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketOwnershipControlsOutputResponse(ownershipControls: \(String(describing: ownershipControls)))"}
}

extension GetBucketOwnershipControlsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: OwnershipControls = try responseDecoder.decode(responseBody: unwrappedData)
                self.ownershipControls = output
            } else {
                self.ownershipControls = nil
            }
        } else {
            self.ownershipControls = nil
        }
    }
}

public struct GetBucketOwnershipControlsOutputResponse: Equatable {
    /// <p>The <code>OwnershipControls</code> (BucketOwnerPreferred or ObjectWriter) currently in
    ///          effect for this Amazon S3 bucket.</p>
    public let ownershipControls: OwnershipControls?

    public init (
        ownershipControls: OwnershipControls? = nil
    )
    {
        self.ownershipControls = ownershipControls
    }
}

struct GetBucketOwnershipControlsOutputResponseBody: Equatable {
    public let ownershipControls: OwnershipControls?
}

extension GetBucketOwnershipControlsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ownershipControls = "OwnershipControls"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownershipControlsDecoded = try containerValues.decodeIfPresent(OwnershipControls.self, forKey: .ownershipControls)
        ownershipControls = ownershipControlsDecoded
    }
}

extension GetBucketPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketPolicyInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension GetBucketPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketPolicyInput>
    public typealias MOutput = OperationOutput<GetBucketPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketPolicyOutputError>
}

public struct GetBucketPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "policy", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketPolicyInput>
    public typealias MOutput = OperationOutput<GetBucketPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketPolicyOutputError>
}

public struct GetBucketPolicyInput: Equatable {
    /// <p>The bucket name for which to get the bucket policy.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketPolicyInputBody: Equatable {
}

extension GetBucketPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketPolicyOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketPolicyOutputResponse(policy: \(String(describing: policy)))"}
}

extension GetBucketPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let output = String(data: unwrappedData, encoding: .utf8) {
                self.policy = output
            } else {
                self.policy = nil
            }
        } else {
            self.policy = nil
        }
    }
}

public struct GetBucketPolicyOutputResponse: Equatable {
    /// <p>The bucket policy as a JSON document.</p>
    public let policy: String?

    public init (
        policy: String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetBucketPolicyOutputResponseBody: Equatable {
    public let policy: String?
}

extension GetBucketPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetBucketPolicyStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketPolicyStatusInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension GetBucketPolicyStatusInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketPolicyStatusInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketPolicyStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketPolicyStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketPolicyStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketPolicyStatusInput>
    public typealias MOutput = OperationOutput<GetBucketPolicyStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketPolicyStatusOutputError>
}

public struct GetBucketPolicyStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketPolicyStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketPolicyStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketPolicyStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "policyStatus", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketPolicyStatusInput>
    public typealias MOutput = OperationOutput<GetBucketPolicyStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketPolicyStatusOutputError>
}

public struct GetBucketPolicyStatusInput: Equatable {
    /// <p>The name of the Amazon S3 bucket whose policy status you want to retrieve.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketPolicyStatusInputBody: Equatable {
}

extension GetBucketPolicyStatusInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketPolicyStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketPolicyStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketPolicyStatusOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketPolicyStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketPolicyStatusOutputResponse(policyStatus: \(String(describing: policyStatus)))"}
}

extension GetBucketPolicyStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: PolicyStatus = try responseDecoder.decode(responseBody: unwrappedData)
                self.policyStatus = output
            } else {
                self.policyStatus = nil
            }
        } else {
            self.policyStatus = nil
        }
    }
}

public struct GetBucketPolicyStatusOutputResponse: Equatable {
    /// <p>The policy status for the specified bucket.</p>
    public let policyStatus: PolicyStatus?

    public init (
        policyStatus: PolicyStatus? = nil
    )
    {
        self.policyStatus = policyStatus
    }
}

struct GetBucketPolicyStatusOutputResponseBody: Equatable {
    public let policyStatus: PolicyStatus?
}

extension GetBucketPolicyStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyStatus = "PolicyStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStatusDecoded = try containerValues.decodeIfPresent(PolicyStatus.self, forKey: .policyStatus)
        policyStatus = policyStatusDecoded
    }
}

extension GetBucketReplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketReplicationInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension GetBucketReplicationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketReplicationInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketReplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketReplicationInput>
    public typealias MOutput = OperationOutput<GetBucketReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketReplicationOutputError>
}

public struct GetBucketReplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketReplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "replication", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketReplicationInput>
    public typealias MOutput = OperationOutput<GetBucketReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketReplicationOutputError>
}

public struct GetBucketReplicationInput: Equatable {
    /// <p>The bucket name for which to get the replication information.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketReplicationInputBody: Equatable {
}

extension GetBucketReplicationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketReplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketReplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketReplicationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketReplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketReplicationOutputResponse(replicationConfiguration: \(String(describing: replicationConfiguration)))"}
}

extension GetBucketReplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ReplicationConfiguration = try responseDecoder.decode(responseBody: unwrappedData)
                self.replicationConfiguration = output
            } else {
                self.replicationConfiguration = nil
            }
        } else {
            self.replicationConfiguration = nil
        }
    }
}

public struct GetBucketReplicationOutputResponse: Equatable {
    /// <p>A container for replication rules. You can add up to 1,000 rules. The maximum size of a
    ///          replication configuration is 2 MB.</p>
    public let replicationConfiguration: ReplicationConfiguration?

    public init (
        replicationConfiguration: ReplicationConfiguration? = nil
    )
    {
        self.replicationConfiguration = replicationConfiguration
    }
}

struct GetBucketReplicationOutputResponseBody: Equatable {
    public let replicationConfiguration: ReplicationConfiguration?
}

extension GetBucketReplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationConfiguration = "ReplicationConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationDecoded = try containerValues.decodeIfPresent(ReplicationConfiguration.self, forKey: .replicationConfiguration)
        replicationConfiguration = replicationConfigurationDecoded
    }
}

extension GetBucketRequestPaymentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketRequestPaymentInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension GetBucketRequestPaymentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketRequestPaymentInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketRequestPaymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketRequestPaymentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketRequestPaymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketRequestPaymentInput>
    public typealias MOutput = OperationOutput<GetBucketRequestPaymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketRequestPaymentOutputError>
}

public struct GetBucketRequestPaymentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketRequestPaymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketRequestPaymentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketRequestPaymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "requestPayment", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketRequestPaymentInput>
    public typealias MOutput = OperationOutput<GetBucketRequestPaymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketRequestPaymentOutputError>
}

public struct GetBucketRequestPaymentInput: Equatable {
    /// <p>The name of the bucket for which to get the payment request configuration</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketRequestPaymentInputBody: Equatable {
}

extension GetBucketRequestPaymentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketRequestPaymentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketRequestPaymentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketRequestPaymentOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketRequestPaymentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketRequestPaymentOutputResponse(payer: \(String(describing: payer)))"}
}

extension GetBucketRequestPaymentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBucketRequestPaymentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.payer = output.payer
        } else {
            self.payer = nil
        }
    }
}

public struct GetBucketRequestPaymentOutputResponse: Equatable {
    /// <p>Specifies who pays for the download and request fees.</p>
    public let payer: Payer?

    public init (
        payer: Payer? = nil
    )
    {
        self.payer = payer
    }
}

struct GetBucketRequestPaymentOutputResponseBody: Equatable {
    public let payer: Payer?
}

extension GetBucketRequestPaymentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case payer = "Payer"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payerDecoded = try containerValues.decodeIfPresent(Payer.self, forKey: .payer)
        payer = payerDecoded
    }
}

extension GetBucketTaggingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketTaggingInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension GetBucketTaggingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketTaggingInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketTaggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketTaggingInput>
    public typealias MOutput = OperationOutput<GetBucketTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketTaggingOutputError>
}

public struct GetBucketTaggingInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketTaggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "tagging", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketTaggingInput>
    public typealias MOutput = OperationOutput<GetBucketTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketTaggingOutputError>
}

public struct GetBucketTaggingInput: Equatable {
    /// <p>The name of the bucket for which to get the tagging information.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketTaggingInputBody: Equatable {
}

extension GetBucketTaggingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketTaggingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketTaggingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketTaggingOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketTaggingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketTaggingOutputResponse(tagSet: \(String(describing: tagSet)))"}
}

extension GetBucketTaggingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBucketTaggingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tagSet = output.tagSet
        } else {
            self.tagSet = nil
        }
    }
}

public struct GetBucketTaggingOutputResponse: Equatable {
    /// <p>Contains the tag set.</p>
    public let tagSet: [Tag]?

    public init (
        tagSet: [Tag]? = nil
    )
    {
        self.tagSet = tagSet
    }
}

struct GetBucketTaggingOutputResponseBody: Equatable {
    public let tagSet: [Tag]?
}

extension GetBucketTaggingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagSet = "TagSet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tagSet) {
            struct KeyVal0{struct Tag{}}
            let tagSetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagSet)
            if let tagSetWrappedContainer = tagSetWrappedContainer {
                let tagSetContainer = try tagSetWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagSetBuffer:[Tag]? = nil
                if let tagSetContainer = tagSetContainer {
                    tagSetBuffer = [Tag]()
                    for structureContainer0 in tagSetContainer {
                        tagSetBuffer?.append(structureContainer0)
                    }
                }
                tagSet = tagSetBuffer
            } else {
                tagSet = []
            }
        } else {
            tagSet = nil
        }
    }
}

extension GetBucketVersioningInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketVersioningInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension GetBucketVersioningInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketVersioningInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketVersioningInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketVersioningInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketVersioningOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketVersioningInput>
    public typealias MOutput = OperationOutput<GetBucketVersioningOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketVersioningOutputError>
}

public struct GetBucketVersioningInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketVersioningInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketVersioningInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketVersioningOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "versioning", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketVersioningInput>
    public typealias MOutput = OperationOutput<GetBucketVersioningOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketVersioningOutputError>
}

public struct GetBucketVersioningInput: Equatable {
    /// <p>The name of the bucket for which to get the versioning information.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketVersioningInputBody: Equatable {
}

extension GetBucketVersioningInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketVersioningOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketVersioningOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketVersioningOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketVersioningOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketVersioningOutputResponse(mFADelete: \(String(describing: mFADelete)), status: \(String(describing: status)))"}
}

extension GetBucketVersioningOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBucketVersioningOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.mFADelete = output.mFADelete
            self.status = output.status
        } else {
            self.mFADelete = nil
            self.status = nil
        }
    }
}

public struct GetBucketVersioningOutputResponse: Equatable {
    /// <p>Specifies whether MFA delete is enabled in the bucket versioning configuration. This
    ///          element is only returned if the bucket has been configured with MFA delete. If the bucket
    ///          has never been so configured, this element is not returned.</p>
    public let mFADelete: MFADeleteStatus?
    /// <p>The versioning state of the bucket.</p>
    public let status: BucketVersioningStatus?

    public init (
        mFADelete: MFADeleteStatus? = nil,
        status: BucketVersioningStatus? = nil
    )
    {
        self.mFADelete = mFADelete
        self.status = status
    }
}

struct GetBucketVersioningOutputResponseBody: Equatable {
    public let status: BucketVersioningStatus?
    public let mFADelete: MFADeleteStatus?
}

extension GetBucketVersioningOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case mFADelete = "MfaDelete"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(BucketVersioningStatus.self, forKey: .status)
        status = statusDecoded
        let mFADeleteDecoded = try containerValues.decodeIfPresent(MFADeleteStatus.self, forKey: .mFADelete)
        mFADelete = mFADeleteDecoded
    }
}

extension GetBucketWebsiteInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketWebsiteInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension GetBucketWebsiteInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketWebsiteInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketWebsiteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketWebsiteInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketWebsiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketWebsiteInput>
    public typealias MOutput = OperationOutput<GetBucketWebsiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketWebsiteOutputError>
}

public struct GetBucketWebsiteInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketWebsiteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketWebsiteInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketWebsiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "website", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketWebsiteInput>
    public typealias MOutput = OperationOutput<GetBucketWebsiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketWebsiteOutputError>
}

public struct GetBucketWebsiteInput: Equatable {
    /// <p>The bucket name for which to get the website configuration.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetBucketWebsiteInputBody: Equatable {
}

extension GetBucketWebsiteInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketWebsiteOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketWebsiteOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketWebsiteOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketWebsiteOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketWebsiteOutputResponse(errorDocument: \(String(describing: errorDocument)), indexDocument: \(String(describing: indexDocument)), redirectAllRequestsTo: \(String(describing: redirectAllRequestsTo)), routingRules: \(String(describing: routingRules)))"}
}

extension GetBucketWebsiteOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBucketWebsiteOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorDocument = output.errorDocument
            self.indexDocument = output.indexDocument
            self.redirectAllRequestsTo = output.redirectAllRequestsTo
            self.routingRules = output.routingRules
        } else {
            self.errorDocument = nil
            self.indexDocument = nil
            self.redirectAllRequestsTo = nil
            self.routingRules = nil
        }
    }
}

public struct GetBucketWebsiteOutputResponse: Equatable {
    /// <p>The object key name of the website error document to use for 4XX class errors.</p>
    public let errorDocument: ErrorDocument?
    /// <p>The name of the index document for the website (for example
    ///          <code>index.html</code>).</p>
    public let indexDocument: IndexDocument?
    /// <p>Specifies the redirect behavior of all requests to a website endpoint of an Amazon S3
    ///          bucket.</p>
    public let redirectAllRequestsTo: RedirectAllRequestsTo?
    /// <p>Rules that define when a redirect is applied and the redirect behavior.</p>
    public let routingRules: [RoutingRule]?

    public init (
        errorDocument: ErrorDocument? = nil,
        indexDocument: IndexDocument? = nil,
        redirectAllRequestsTo: RedirectAllRequestsTo? = nil,
        routingRules: [RoutingRule]? = nil
    )
    {
        self.errorDocument = errorDocument
        self.indexDocument = indexDocument
        self.redirectAllRequestsTo = redirectAllRequestsTo
        self.routingRules = routingRules
    }
}

struct GetBucketWebsiteOutputResponseBody: Equatable {
    public let redirectAllRequestsTo: RedirectAllRequestsTo?
    public let indexDocument: IndexDocument?
    public let errorDocument: ErrorDocument?
    public let routingRules: [RoutingRule]?
}

extension GetBucketWebsiteOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorDocument = "ErrorDocument"
        case indexDocument = "IndexDocument"
        case redirectAllRequestsTo = "RedirectAllRequestsTo"
        case routingRules = "RoutingRules"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let redirectAllRequestsToDecoded = try containerValues.decodeIfPresent(RedirectAllRequestsTo.self, forKey: .redirectAllRequestsTo)
        redirectAllRequestsTo = redirectAllRequestsToDecoded
        let indexDocumentDecoded = try containerValues.decodeIfPresent(IndexDocument.self, forKey: .indexDocument)
        indexDocument = indexDocumentDecoded
        let errorDocumentDecoded = try containerValues.decodeIfPresent(ErrorDocument.self, forKey: .errorDocument)
        errorDocument = errorDocumentDecoded
        if containerValues.contains(.routingRules) {
            struct KeyVal0{struct RoutingRule{}}
            let routingRulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.RoutingRule>.CodingKeys.self, forKey: .routingRules)
            if let routingRulesWrappedContainer = routingRulesWrappedContainer {
                let routingRulesContainer = try routingRulesWrappedContainer.decodeIfPresent([RoutingRule].self, forKey: .member)
                var routingRulesBuffer:[RoutingRule]? = nil
                if let routingRulesContainer = routingRulesContainer {
                    routingRulesBuffer = [RoutingRule]()
                    for structureContainer0 in routingRulesContainer {
                        routingRulesBuffer?.append(structureContainer0)
                    }
                }
                routingRules = routingRulesBuffer
            } else {
                routingRules = []
            }
        } else {
            routingRules = nil
        }
    }
}

extension GetObjectAclInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetObjectAclInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), key: \(String(describing: key)), requestPayer: \(String(describing: requestPayer)), versionId: \(String(describing: versionId)))"}
}

extension GetObjectAclInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetObjectAclInputHeadersMiddleware: Middleware {
    public let id: String = "GetObjectAclInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetObjectAclInput>,
                  next: H) -> Swift.Result<OperationOutput<GetObjectAclOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetObjectAclInput>
    public typealias MOutput = OperationOutput<GetObjectAclOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetObjectAclOutputError>
}

public struct GetObjectAclInputQueryItemMiddleware: Middleware {
    public let id: String = "GetObjectAclInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetObjectAclInput>,
                  next: H) -> Swift.Result<OperationOutput<GetObjectAclOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "acl", value: nil))
        if let versionId = input.operationInput.versionId {
            let versionIdQueryItem = URLQueryItem(name: "versionId".urlPercentEncoding(), value: String(versionId).urlPercentEncoding())
            input.builder.withQueryItem(versionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetObjectAclInput>
    public typealias MOutput = OperationOutput<GetObjectAclOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetObjectAclOutputError>
}

public struct GetObjectAclInput: Equatable {
    /// <p>The bucket name that contains the object for which to get the ACL information. </p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The key of the object for which to get the ACL information.</p>
    public let key: String?
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    ///          owners need not specify this parameter in their requests. For information about downloading
    ///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    ///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let requestPayer: RequestPayer?
    /// <p>VersionId used to reference a specific version of the object.</p>
    public let versionId: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        key: String? = nil,
        requestPayer: RequestPayer? = nil,
        versionId: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.requestPayer = requestPayer
        self.versionId = versionId
    }
}

struct GetObjectAclInputBody: Equatable {
}

extension GetObjectAclInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetObjectAclOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetObjectAclOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchKey" : self = .noSuchKey(try NoSuchKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetObjectAclOutputError: Equatable {
    case noSuchKey(NoSuchKey)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetObjectAclOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetObjectAclOutputResponse(grants: \(String(describing: grants)), owner: \(String(describing: owner)), requestCharged: \(String(describing: requestCharged)))"}
}

extension GetObjectAclOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetObjectAclOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.grants = output.grants
            self.owner = output.owner
        } else {
            self.grants = nil
            self.owner = nil
        }
    }
}

public struct GetObjectAclOutputResponse: Equatable {
    /// <p>A list of grants.</p>
    public let grants: [Grant]?
    /// <p> Container for the bucket owner's display name and ID.</p>
    public let owner: Owner?
    /// <p>If present, indicates that the requester was successfully charged for the
    ///          request.</p>
    public let requestCharged: RequestCharged?

    public init (
        grants: [Grant]? = nil,
        owner: Owner? = nil,
        requestCharged: RequestCharged? = nil
    )
    {
        self.grants = grants
        self.owner = owner
        self.requestCharged = requestCharged
    }
}

struct GetObjectAclOutputResponseBody: Equatable {
    public let owner: Owner?
    public let grants: [Grant]?
}

extension GetObjectAclOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grants = "AccessControlList"
        case owner = "Owner"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(Owner.self, forKey: .owner)
        owner = ownerDecoded
        if containerValues.contains(.grants) {
            struct KeyVal0{struct Grant{}}
            let grantsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Grant>.CodingKeys.self, forKey: .grants)
            if let grantsWrappedContainer = grantsWrappedContainer {
                let grantsContainer = try grantsWrappedContainer.decodeIfPresent([Grant].self, forKey: .member)
                var grantsBuffer:[Grant]? = nil
                if let grantsContainer = grantsContainer {
                    grantsBuffer = [Grant]()
                    for structureContainer0 in grantsContainer {
                        grantsBuffer?.append(structureContainer0)
                    }
                }
                grants = grantsBuffer
            } else {
                grants = []
            }
        } else {
            grants = nil
        }
    }
}

extension GetObjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetObjectInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), ifMatch: \(String(describing: ifMatch)), ifModifiedSince: \(String(describing: ifModifiedSince)), ifNoneMatch: \(String(describing: ifNoneMatch)), ifUnmodifiedSince: \(String(describing: ifUnmodifiedSince)), key: \(String(describing: key)), partNumber: \(String(describing: partNumber)), range: \(String(describing: range)), requestPayer: \(String(describing: requestPayer)), responseCacheControl: \(String(describing: responseCacheControl)), responseContentDisposition: \(String(describing: responseContentDisposition)), responseContentEncoding: \(String(describing: responseContentEncoding)), responseContentLanguage: \(String(describing: responseContentLanguage)), responseContentType: \(String(describing: responseContentType)), responseExpires: \(String(describing: responseExpires)), sSECustomerAlgorithm: \(String(describing: sSECustomerAlgorithm)), sSECustomerKey: \(String(describing: sSECustomerKey)), sSECustomerKeyMD5: \(String(describing: sSECustomerKeyMD5)), versionId: \(String(describing: versionId)))"}
}

extension GetObjectInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetObjectInputHeadersMiddleware: Middleware {
    public let id: String = "GetObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<GetObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        if let ifModifiedSince = input.operationInput.ifModifiedSince {
            input.builder.withHeader(name: "If-Modified-Since", value: String(ifModifiedSince.rfc5322()))
        }
        if let ifNoneMatch = input.operationInput.ifNoneMatch {
            input.builder.withHeader(name: "If-None-Match", value: String(ifNoneMatch))
        }
        if let ifUnmodifiedSince = input.operationInput.ifUnmodifiedSince {
            input.builder.withHeader(name: "If-Unmodified-Since", value: String(ifUnmodifiedSince.rfc5322()))
        }
        if let range = input.operationInput.range {
            input.builder.withHeader(name: "Range", value: String(range))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        if let sSECustomerAlgorithm = input.operationInput.sSECustomerAlgorithm {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-algorithm", value: String(sSECustomerAlgorithm))
        }
        if let sSECustomerKey = input.operationInput.sSECustomerKey {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-key", value: String(sSECustomerKey))
        }
        if let sSECustomerKeyMD5 = input.operationInput.sSECustomerKeyMD5 {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-key-MD5", value: String(sSECustomerKeyMD5))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetObjectInput>
    public typealias MOutput = OperationOutput<GetObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetObjectOutputError>
}

public struct GetObjectInputQueryItemMiddleware: Middleware {
    public let id: String = "GetObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<GetObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "x-id", value: "GetObject"))
        if let versionId = input.operationInput.versionId {
            let versionIdQueryItem = URLQueryItem(name: "versionId".urlPercentEncoding(), value: String(versionId).urlPercentEncoding())
            input.builder.withQueryItem(versionIdQueryItem)
        }
        if let responseContentDisposition = input.operationInput.responseContentDisposition {
            let responseContentDispositionQueryItem = URLQueryItem(name: "response-content-disposition".urlPercentEncoding(), value: String(responseContentDisposition).urlPercentEncoding())
            input.builder.withQueryItem(responseContentDispositionQueryItem)
        }
        let partNumberQueryItem = URLQueryItem(name: "partNumber".urlPercentEncoding(), value: String(input.operationInput.partNumber).urlPercentEncoding())
        input.builder.withQueryItem(partNumberQueryItem)
        if let responseContentType = input.operationInput.responseContentType {
            let responseContentTypeQueryItem = URLQueryItem(name: "response-content-type".urlPercentEncoding(), value: String(responseContentType).urlPercentEncoding())
            input.builder.withQueryItem(responseContentTypeQueryItem)
        }
        if let responseExpires = input.operationInput.responseExpires {
            let responseExpiresQueryItem = URLQueryItem(name: "response-expires".urlPercentEncoding(), value: String(responseExpires.rfc5322()).urlPercentEncoding())
            input.builder.withQueryItem(responseExpiresQueryItem)
        }
        if let responseContentEncoding = input.operationInput.responseContentEncoding {
            let responseContentEncodingQueryItem = URLQueryItem(name: "response-content-encoding".urlPercentEncoding(), value: String(responseContentEncoding).urlPercentEncoding())
            input.builder.withQueryItem(responseContentEncodingQueryItem)
        }
        if let responseCacheControl = input.operationInput.responseCacheControl {
            let responseCacheControlQueryItem = URLQueryItem(name: "response-cache-control".urlPercentEncoding(), value: String(responseCacheControl).urlPercentEncoding())
            input.builder.withQueryItem(responseCacheControlQueryItem)
        }
        if let responseContentLanguage = input.operationInput.responseContentLanguage {
            let responseContentLanguageQueryItem = URLQueryItem(name: "response-content-language".urlPercentEncoding(), value: String(responseContentLanguage).urlPercentEncoding())
            input.builder.withQueryItem(responseContentLanguageQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetObjectInput>
    public typealias MOutput = OperationOutput<GetObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetObjectOutputError>
}

public struct GetObjectInput: Equatable {
    /// <p>The bucket name containing the object. </p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>Return the object only if its entity tag (ETag) is the same as the one specified,
    ///          otherwise return a 412 (precondition failed).</p>
    public let ifMatch: String?
    /// <p>Return the object only if it has been modified since the specified time, otherwise
    ///          return a 304 (not modified).</p>
    public let ifModifiedSince: Date?
    /// <p>Return the object only if its entity tag (ETag) is different from the one specified,
    ///          otherwise return a 304 (not modified).</p>
    public let ifNoneMatch: String?
    /// <p>Return the object only if it has not been modified since the specified time, otherwise
    ///          return a 412 (precondition failed).</p>
    public let ifUnmodifiedSince: Date?
    /// <p>Key of the object to get.</p>
    public let key: String?
    /// <p>Part number of the object being read. This is a positive integer between 1 and 10,000.
    ///          Effectively performs a 'ranged' GET request for the part specified. Useful for downloading
    ///          just a part of an object.</p>
    public let partNumber: Int
    /// <p>Downloads the specified range bytes of an object. For more information about the HTTP
    ///          Range header, see <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35">https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35</a>.</p>
    ///          <note>
    ///             <p>Amazon S3 doesn't support retrieving multiple ranges of data per <code>GET</code>
    ///             request.</p>
    ///          </note>
    public let range: String?
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    ///          owners need not specify this parameter in their requests. For information about downloading
    ///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    ///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let requestPayer: RequestPayer?
    /// <p>Sets the <code>Cache-Control</code> header of the response.</p>
    public let responseCacheControl: String?
    /// <p>Sets the <code>Content-Disposition</code> header of the response</p>
    public let responseContentDisposition: String?
    /// <p>Sets the <code>Content-Encoding</code> header of the response.</p>
    public let responseContentEncoding: String?
    /// <p>Sets the <code>Content-Language</code> header of the response.</p>
    public let responseContentLanguage: String?
    /// <p>Sets the <code>Content-Type</code> header of the response.</p>
    public let responseContentType: String?
    /// <p>Sets the <code>Expires</code> header of the response.</p>
    public let responseExpires: Date?
    /// <p>Specifies the algorithm to use to when decrypting the object (for example,
    ///          AES256).</p>
    public let sSECustomerAlgorithm: String?
    /// <p>Specifies the customer-provided encryption key for Amazon S3 used to encrypt the data. This
    ///          value is used to decrypt the object when recovering it and must match the one used when
    ///          storing the data. The key must be appropriate for use with the algorithm specified in the
    ///             <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
    public let sSECustomerKey: String?
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    ///          this header for a message integrity check to ensure that the encryption key was transmitted
    ///          without error.</p>
    public let sSECustomerKeyMD5: String?
    /// <p>VersionId used to reference a specific version of the object.</p>
    public let versionId: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        ifMatch: String? = nil,
        ifModifiedSince: Date? = nil,
        ifNoneMatch: String? = nil,
        ifUnmodifiedSince: Date? = nil,
        key: String? = nil,
        partNumber: Int = 0,
        range: String? = nil,
        requestPayer: RequestPayer? = nil,
        responseCacheControl: String? = nil,
        responseContentDisposition: String? = nil,
        responseContentEncoding: String? = nil,
        responseContentLanguage: String? = nil,
        responseContentType: String? = nil,
        responseExpires: Date? = nil,
        sSECustomerAlgorithm: String? = nil,
        sSECustomerKey: String? = nil,
        sSECustomerKeyMD5: String? = nil,
        versionId: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.ifMatch = ifMatch
        self.ifModifiedSince = ifModifiedSince
        self.ifNoneMatch = ifNoneMatch
        self.ifUnmodifiedSince = ifUnmodifiedSince
        self.key = key
        self.partNumber = partNumber
        self.range = range
        self.requestPayer = requestPayer
        self.responseCacheControl = responseCacheControl
        self.responseContentDisposition = responseContentDisposition
        self.responseContentEncoding = responseContentEncoding
        self.responseContentLanguage = responseContentLanguage
        self.responseContentType = responseContentType
        self.responseExpires = responseExpires
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKey = sSECustomerKey
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.versionId = versionId
    }
}

struct GetObjectInputBody: Equatable {
}

extension GetObjectInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetObjectLegalHoldInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetObjectLegalHoldInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), key: \(String(describing: key)), requestPayer: \(String(describing: requestPayer)), versionId: \(String(describing: versionId)))"}
}

extension GetObjectLegalHoldInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetObjectLegalHoldInputHeadersMiddleware: Middleware {
    public let id: String = "GetObjectLegalHoldInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetObjectLegalHoldInput>,
                  next: H) -> Swift.Result<OperationOutput<GetObjectLegalHoldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetObjectLegalHoldInput>
    public typealias MOutput = OperationOutput<GetObjectLegalHoldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetObjectLegalHoldOutputError>
}

public struct GetObjectLegalHoldInputQueryItemMiddleware: Middleware {
    public let id: String = "GetObjectLegalHoldInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetObjectLegalHoldInput>,
                  next: H) -> Swift.Result<OperationOutput<GetObjectLegalHoldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "legal-hold", value: nil))
        if let versionId = input.operationInput.versionId {
            let versionIdQueryItem = URLQueryItem(name: "versionId".urlPercentEncoding(), value: String(versionId).urlPercentEncoding())
            input.builder.withQueryItem(versionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetObjectLegalHoldInput>
    public typealias MOutput = OperationOutput<GetObjectLegalHoldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetObjectLegalHoldOutputError>
}

public struct GetObjectLegalHoldInput: Equatable {
    /// <p>The bucket name containing the object whose Legal Hold status you want to retrieve. </p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The key name for the object whose Legal Hold status you want to retrieve.</p>
    public let key: String?
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    ///          owners need not specify this parameter in their requests. For information about downloading
    ///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    ///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let requestPayer: RequestPayer?
    /// <p>The version ID of the object whose Legal Hold status you want to retrieve.</p>
    public let versionId: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        key: String? = nil,
        requestPayer: RequestPayer? = nil,
        versionId: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.requestPayer = requestPayer
        self.versionId = versionId
    }
}

struct GetObjectLegalHoldInputBody: Equatable {
}

extension GetObjectLegalHoldInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetObjectLegalHoldOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetObjectLegalHoldOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetObjectLegalHoldOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetObjectLegalHoldOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetObjectLegalHoldOutputResponse(legalHold: \(String(describing: legalHold)))"}
}

extension GetObjectLegalHoldOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ObjectLockLegalHold = try responseDecoder.decode(responseBody: unwrappedData)
                self.legalHold = output
            } else {
                self.legalHold = nil
            }
        } else {
            self.legalHold = nil
        }
    }
}

public struct GetObjectLegalHoldOutputResponse: Equatable {
    /// <p>The current Legal Hold status for the specified object.</p>
    public let legalHold: ObjectLockLegalHold?

    public init (
        legalHold: ObjectLockLegalHold? = nil
    )
    {
        self.legalHold = legalHold
    }
}

struct GetObjectLegalHoldOutputResponseBody: Equatable {
    public let legalHold: ObjectLockLegalHold?
}

extension GetObjectLegalHoldOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case legalHold = "LegalHold"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let legalHoldDecoded = try containerValues.decodeIfPresent(ObjectLockLegalHold.self, forKey: .legalHold)
        legalHold = legalHoldDecoded
    }
}

extension GetObjectLockConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetObjectLockConfigurationInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension GetObjectLockConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetObjectLockConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetObjectLockConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetObjectLockConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetObjectLockConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetObjectLockConfigurationInput>
    public typealias MOutput = OperationOutput<GetObjectLockConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetObjectLockConfigurationOutputError>
}

public struct GetObjectLockConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetObjectLockConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetObjectLockConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetObjectLockConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "object-lock", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetObjectLockConfigurationInput>
    public typealias MOutput = OperationOutput<GetObjectLockConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetObjectLockConfigurationOutputError>
}

public struct GetObjectLockConfigurationInput: Equatable {
    /// <p>The bucket whose Object Lock configuration you want to retrieve.</p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetObjectLockConfigurationInputBody: Equatable {
}

extension GetObjectLockConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetObjectLockConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetObjectLockConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetObjectLockConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetObjectLockConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetObjectLockConfigurationOutputResponse(objectLockConfiguration: \(String(describing: objectLockConfiguration)))"}
}

extension GetObjectLockConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ObjectLockConfiguration = try responseDecoder.decode(responseBody: unwrappedData)
                self.objectLockConfiguration = output
            } else {
                self.objectLockConfiguration = nil
            }
        } else {
            self.objectLockConfiguration = nil
        }
    }
}

public struct GetObjectLockConfigurationOutputResponse: Equatable {
    /// <p>The specified bucket's Object Lock configuration.</p>
    public let objectLockConfiguration: ObjectLockConfiguration?

    public init (
        objectLockConfiguration: ObjectLockConfiguration? = nil
    )
    {
        self.objectLockConfiguration = objectLockConfiguration
    }
}

struct GetObjectLockConfigurationOutputResponseBody: Equatable {
    public let objectLockConfiguration: ObjectLockConfiguration?
}

extension GetObjectLockConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case objectLockConfiguration = "ObjectLockConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectLockConfigurationDecoded = try containerValues.decodeIfPresent(ObjectLockConfiguration.self, forKey: .objectLockConfiguration)
        objectLockConfiguration = objectLockConfigurationDecoded
    }
}

extension GetObjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetObjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidObjectState" : self = .invalidObjectState(try InvalidObjectState(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchKey" : self = .noSuchKey(try NoSuchKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetObjectOutputError: Equatable {
    case invalidObjectState(InvalidObjectState)
    case noSuchKey(NoSuchKey)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetObjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetObjectOutputResponse(acceptRanges: \(String(describing: acceptRanges)), body: \(String(describing: body)), bucketKeyEnabled: \(String(describing: bucketKeyEnabled)), cacheControl: \(String(describing: cacheControl)), contentDisposition: \(String(describing: contentDisposition)), contentEncoding: \(String(describing: contentEncoding)), contentLanguage: \(String(describing: contentLanguage)), contentLength: \(String(describing: contentLength)), contentRange: \(String(describing: contentRange)), contentType: \(String(describing: contentType)), deleteMarker: \(String(describing: deleteMarker)), eTag: \(String(describing: eTag)), expiration: \(String(describing: expiration)), expires: \(String(describing: expires)), lastModified: \(String(describing: lastModified)), metadata: \(String(describing: metadata)), missingMeta: \(String(describing: missingMeta)), objectLockLegalHoldStatus: \(String(describing: objectLockLegalHoldStatus)), objectLockMode: \(String(describing: objectLockMode)), objectLockRetainUntilDate: \(String(describing: objectLockRetainUntilDate)), partsCount: \(String(describing: partsCount)), replicationStatus: \(String(describing: replicationStatus)), requestCharged: \(String(describing: requestCharged)), restore: \(String(describing: restore)), sSECustomerAlgorithm: \(String(describing: sSECustomerAlgorithm)), sSECustomerKeyMD5: \(String(describing: sSECustomerKeyMD5)), sSEKMSKeyId: \(String(describing: sSEKMSKeyId)), serverSideEncryption: \(String(describing: serverSideEncryption)), storageClass: \(String(describing: storageClass)), tagCount: \(String(describing: tagCount)), versionId: \(String(describing: versionId)), websiteRedirectLocation: \(String(describing: websiteRedirectLocation)))"}
}

extension GetObjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let acceptRangesHeaderValue = httpResponse.headers.value(for: "accept-ranges") {
            self.acceptRanges = acceptRangesHeaderValue
        } else {
            self.acceptRanges = nil
        }
        if let bucketKeyEnabledHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-bucket-key-enabled") {
            self.bucketKeyEnabled = Bool(bucketKeyEnabledHeaderValue) ?? false
        } else {
            self.bucketKeyEnabled = false
        }
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            self.cacheControl = cacheControlHeaderValue
        } else {
            self.cacheControl = nil
        }
        if let contentDispositionHeaderValue = httpResponse.headers.value(for: "Content-Disposition") {
            self.contentDisposition = contentDispositionHeaderValue
        } else {
            self.contentDisposition = nil
        }
        if let contentEncodingHeaderValue = httpResponse.headers.value(for: "Content-Encoding") {
            self.contentEncoding = contentEncodingHeaderValue
        } else {
            self.contentEncoding = nil
        }
        if let contentLanguageHeaderValue = httpResponse.headers.value(for: "Content-Language") {
            self.contentLanguage = contentLanguageHeaderValue
        } else {
            self.contentLanguage = nil
        }
        if let contentLengthHeaderValue = httpResponse.headers.value(for: "Content-Length") {
            self.contentLength = Int(contentLengthHeaderValue) ?? 0
        } else {
            self.contentLength = 0
        }
        if let contentRangeHeaderValue = httpResponse.headers.value(for: "Content-Range") {
            self.contentRange = contentRangeHeaderValue
        } else {
            self.contentRange = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let deleteMarkerHeaderValue = httpResponse.headers.value(for: "x-amz-delete-marker") {
            self.deleteMarker = Bool(deleteMarkerHeaderValue) ?? false
        } else {
            self.deleteMarker = false
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let expirationHeaderValue = httpResponse.headers.value(for: "x-amz-expiration") {
            self.expiration = expirationHeaderValue
        } else {
            self.expiration = nil
        }
        if let expiresHeaderValue = httpResponse.headers.value(for: "Expires") {
            self.expires = DateFormatter.rfc5322DateFormatter.date(from: expiresHeaderValue)
        } else {
            self.expires = nil
        }
        if let lastModifiedHeaderValue = httpResponse.headers.value(for: "Last-Modified") {
            self.lastModified = DateFormatter.rfc5322DateFormatter.date(from: lastModifiedHeaderValue)
        } else {
            self.lastModified = nil
        }
        if let missingMetaHeaderValue = httpResponse.headers.value(for: "x-amz-missing-meta") {
            self.missingMeta = Int(missingMetaHeaderValue) ?? 0
        } else {
            self.missingMeta = 0
        }
        if let objectLockLegalHoldStatusHeaderValue = httpResponse.headers.value(for: "x-amz-object-lock-legal-hold") {
            self.objectLockLegalHoldStatus = ObjectLockLegalHoldStatus(rawValue: objectLockLegalHoldStatusHeaderValue)
        } else {
            self.objectLockLegalHoldStatus = nil
        }
        if let objectLockModeHeaderValue = httpResponse.headers.value(for: "x-amz-object-lock-mode") {
            self.objectLockMode = ObjectLockMode(rawValue: objectLockModeHeaderValue)
        } else {
            self.objectLockMode = nil
        }
        if let objectLockRetainUntilDateHeaderValue = httpResponse.headers.value(for: "x-amz-object-lock-retain-until-date") {
            self.objectLockRetainUntilDate = DateFormatter.iso8601DateFormatterWithoutFractionalSeconds.date(from: objectLockRetainUntilDateHeaderValue)
        } else {
            self.objectLockRetainUntilDate = nil
        }
        if let partsCountHeaderValue = httpResponse.headers.value(for: "x-amz-mp-parts-count") {
            self.partsCount = Int(partsCountHeaderValue) ?? 0
        } else {
            self.partsCount = 0
        }
        if let replicationStatusHeaderValue = httpResponse.headers.value(for: "x-amz-replication-status") {
            self.replicationStatus = ReplicationStatus(rawValue: replicationStatusHeaderValue)
        } else {
            self.replicationStatus = nil
        }
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if let restoreHeaderValue = httpResponse.headers.value(for: "x-amz-restore") {
            self.restore = restoreHeaderValue
        } else {
            self.restore = nil
        }
        if let sSECustomerAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-algorithm") {
            self.sSECustomerAlgorithm = sSECustomerAlgorithmHeaderValue
        } else {
            self.sSECustomerAlgorithm = nil
        }
        if let sSECustomerKeyMD5HeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-key-MD5") {
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5HeaderValue
        } else {
            self.sSECustomerKeyMD5 = nil
        }
        if let sSEKMSKeyIdHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-aws-kms-key-id") {
            self.sSEKMSKeyId = sSEKMSKeyIdHeaderValue
        } else {
            self.sSEKMSKeyId = nil
        }
        if let serverSideEncryptionHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption") {
            self.serverSideEncryption = ServerSideEncryption(rawValue: serverSideEncryptionHeaderValue)
        } else {
            self.serverSideEncryption = nil
        }
        if let storageClassHeaderValue = httpResponse.headers.value(for: "x-amz-storage-class") {
            self.storageClass = StorageClass(rawValue: storageClassHeaderValue)
        } else {
            self.storageClass = nil
        }
        if let tagCountHeaderValue = httpResponse.headers.value(for: "x-amz-tagging-count") {
            self.tagCount = Int(tagCountHeaderValue) ?? 0
        } else {
            self.tagCount = 0
        }
        if let versionIdHeaderValue = httpResponse.headers.value(for: "x-amz-version-id") {
            self.versionId = versionIdHeaderValue
        } else {
            self.versionId = nil
        }
        if let websiteRedirectLocationHeaderValue = httpResponse.headers.value(for: "x-amz-website-redirect-location") {
            self.websiteRedirectLocation = websiteRedirectLocationHeaderValue
        } else {
            self.websiteRedirectLocation = nil
        }
        let keysForMetadata = httpResponse.headers.dictionary.keys.filter({ $0.starts(with: "x-amz-meta-") })
        if (!keysForMetadata.isEmpty) {
            var mapMember = [String: String]()
            for headerKey in keysForMetadata {
                let mapMemberValue = httpResponse.headers.dictionary[headerKey]?[0]
                let mapMemberKey = headerKey.removePrefix("x-amz-meta-")
                mapMember[mapMemberKey] = mapMemberValue
            }
            self.metadata = mapMember
        } else {
            self.metadata = [:]
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            self.body = unwrappedData
        } else {
            self.body = nil
        }
    }
}

public struct GetObjectOutputResponse: Equatable {
    /// <p>Indicates that a range of bytes was specified.</p>
    public let acceptRanges: String?
    /// <p>Object data.</p>
    public let body: Data?
    /// <p>Indicates whether the object uses an S3 Bucket Key for server-side encryption with AWS KMS (SSE-KMS).</p>
    public let bucketKeyEnabled: Bool
    /// <p>Specifies caching behavior along the request/reply chain.</p>
    public let cacheControl: String?
    /// <p>Specifies presentational information for the object.</p>
    public let contentDisposition: String?
    /// <p>Specifies what content encodings have been applied to the object and thus what decoding
    ///          mechanisms must be applied to obtain the media-type referenced by the Content-Type header
    ///          field.</p>
    public let contentEncoding: String?
    /// <p>The language the content is in.</p>
    public let contentLanguage: String?
    /// <p>Size of the body in bytes.</p>
    public let contentLength: Int
    /// <p>The portion of the object returned in the response.</p>
    public let contentRange: String?
    /// <p>A standard MIME type describing the format of the object data.</p>
    public let contentType: String?
    /// <p>Specifies whether the object retrieved was (true) or was not (false) a Delete Marker. If
    ///          false, this response header does not appear in the response.</p>
    public let deleteMarker: Bool
    /// <p>An ETag is an opaque identifier assigned by a web server to a specific version of a
    ///          resource found at a URL.</p>
    public let eTag: String?
    /// <p>If the object expiration is configured (see PUT Bucket lifecycle), the response includes
    ///          this header. It includes the expiry-date and rule-id key-value pairs providing object
    ///          expiration information. The value of the rule-id is URL encoded.</p>
    public let expiration: String?
    /// <p>The date and time at which the object is no longer cacheable.</p>
    public let expires: Date?
    /// <p>Creation date of the object.</p>
    public let lastModified: Date?
    /// <p>A map of metadata to store with the object in S3.</p>
    public let metadata: [String:String]?
    /// <p>This is set to the number of metadata entries not returned in <code>x-amz-meta</code>
    ///          headers. This can happen if you create metadata using an API like SOAP that supports more
    ///          flexible metadata than the REST API. For example, using SOAP, you can create metadata whose
    ///          values are not legal HTTP headers.</p>
    public let missingMeta: Int
    /// <p>Indicates whether this object has an active legal hold. This field is only returned if
    ///          you have permission to view an object's legal hold status. </p>
    public let objectLockLegalHoldStatus: ObjectLockLegalHoldStatus?
    /// <p>The Object Lock mode currently in place for this object.</p>
    public let objectLockMode: ObjectLockMode?
    /// <p>The date and time when this object's Object Lock will expire.</p>
    public let objectLockRetainUntilDate: Date?
    /// <p>The count of parts this object has.</p>
    public let partsCount: Int
    /// <p>Amazon S3 can return this if your request involves a bucket that is either a source or
    ///          destination in a replication rule.</p>
    public let replicationStatus: ReplicationStatus?
    /// <p>If present, indicates that the requester was successfully charged for the
    ///          request.</p>
    public let requestCharged: RequestCharged?
    /// <p>Provides information about object restoration action and expiration time of the
    ///          restored object copy.</p>
    public let restore: String?
    /// <p>If server-side encryption with a customer-provided encryption key was requested, the
    ///          response will include this header confirming the encryption algorithm used.</p>
    public let sSECustomerAlgorithm: String?
    /// <p>If server-side encryption with a customer-provided encryption key was requested, the
    ///          response will include this header to provide round-trip message integrity verification of
    ///          the customer-provided encryption key.</p>
    public let sSECustomerKeyMD5: String?
    /// <p>If present, specifies the ID of the AWS Key Management Service (AWS KMS) symmetric
    ///          customer managed customer master key (CMK) that was used for the object.</p>
    public let sSEKMSKeyId: String?
    /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
    ///          AES256, aws:kms).</p>
    public let serverSideEncryption: ServerSideEncryption?
    /// <p>Provides storage class information of the object. Amazon S3 returns this header for all
    ///          objects except for S3 Standard storage class objects.</p>
    public let storageClass: StorageClass?
    /// <p>The number of tags, if any, on the object.</p>
    public let tagCount: Int
    /// <p>Version of the object.</p>
    public let versionId: String?
    /// <p>If the bucket is configured as a website, redirects requests for this object to another
    ///          object in the same bucket or to an external URL. Amazon S3 stores the value of this header in
    ///          the object metadata.</p>
    public let websiteRedirectLocation: String?

    public init (
        acceptRanges: String? = nil,
        body: Data? = nil,
        bucketKeyEnabled: Bool = false,
        cacheControl: String? = nil,
        contentDisposition: String? = nil,
        contentEncoding: String? = nil,
        contentLanguage: String? = nil,
        contentLength: Int = 0,
        contentRange: String? = nil,
        contentType: String? = nil,
        deleteMarker: Bool = false,
        eTag: String? = nil,
        expiration: String? = nil,
        expires: Date? = nil,
        lastModified: Date? = nil,
        metadata: [String:String]? = nil,
        missingMeta: Int = 0,
        objectLockLegalHoldStatus: ObjectLockLegalHoldStatus? = nil,
        objectLockMode: ObjectLockMode? = nil,
        objectLockRetainUntilDate: Date? = nil,
        partsCount: Int = 0,
        replicationStatus: ReplicationStatus? = nil,
        requestCharged: RequestCharged? = nil,
        restore: String? = nil,
        sSECustomerAlgorithm: String? = nil,
        sSECustomerKeyMD5: String? = nil,
        sSEKMSKeyId: String? = nil,
        serverSideEncryption: ServerSideEncryption? = nil,
        storageClass: StorageClass? = nil,
        tagCount: Int = 0,
        versionId: String? = nil,
        websiteRedirectLocation: String? = nil
    )
    {
        self.acceptRanges = acceptRanges
        self.body = body
        self.bucketKeyEnabled = bucketKeyEnabled
        self.cacheControl = cacheControl
        self.contentDisposition = contentDisposition
        self.contentEncoding = contentEncoding
        self.contentLanguage = contentLanguage
        self.contentLength = contentLength
        self.contentRange = contentRange
        self.contentType = contentType
        self.deleteMarker = deleteMarker
        self.eTag = eTag
        self.expiration = expiration
        self.expires = expires
        self.lastModified = lastModified
        self.metadata = metadata
        self.missingMeta = missingMeta
        self.objectLockLegalHoldStatus = objectLockLegalHoldStatus
        self.objectLockMode = objectLockMode
        self.objectLockRetainUntilDate = objectLockRetainUntilDate
        self.partsCount = partsCount
        self.replicationStatus = replicationStatus
        self.requestCharged = requestCharged
        self.restore = restore
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
        self.storageClass = storageClass
        self.tagCount = tagCount
        self.versionId = versionId
        self.websiteRedirectLocation = websiteRedirectLocation
    }
}

struct GetObjectOutputResponseBody: Equatable {
    public let body: Data?
}

extension GetObjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.body) {
            do {
                let bodyDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .body)
                body = bodyDecoded
            } catch {
                body = "".data(using: .utf8)
            }
        } else {
            body = nil
        }
    }
}

extension GetObjectRetentionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetObjectRetentionInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), key: \(String(describing: key)), requestPayer: \(String(describing: requestPayer)), versionId: \(String(describing: versionId)))"}
}

extension GetObjectRetentionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetObjectRetentionInputHeadersMiddleware: Middleware {
    public let id: String = "GetObjectRetentionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetObjectRetentionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetObjectRetentionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetObjectRetentionInput>
    public typealias MOutput = OperationOutput<GetObjectRetentionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetObjectRetentionOutputError>
}

public struct GetObjectRetentionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetObjectRetentionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetObjectRetentionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetObjectRetentionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "retention", value: nil))
        if let versionId = input.operationInput.versionId {
            let versionIdQueryItem = URLQueryItem(name: "versionId".urlPercentEncoding(), value: String(versionId).urlPercentEncoding())
            input.builder.withQueryItem(versionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetObjectRetentionInput>
    public typealias MOutput = OperationOutput<GetObjectRetentionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetObjectRetentionOutputError>
}

public struct GetObjectRetentionInput: Equatable {
    /// <p>The bucket name containing the object whose retention settings you want to retrieve. </p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The key name for the object whose retention settings you want to retrieve.</p>
    public let key: String?
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    ///          owners need not specify this parameter in their requests. For information about downloading
    ///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    ///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let requestPayer: RequestPayer?
    /// <p>The version ID for the object whose retention settings you want to retrieve.</p>
    public let versionId: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        key: String? = nil,
        requestPayer: RequestPayer? = nil,
        versionId: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.requestPayer = requestPayer
        self.versionId = versionId
    }
}

struct GetObjectRetentionInputBody: Equatable {
}

extension GetObjectRetentionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetObjectRetentionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetObjectRetentionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetObjectRetentionOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetObjectRetentionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetObjectRetentionOutputResponse(retention: \(String(describing: retention)))"}
}

extension GetObjectRetentionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ObjectLockRetention = try responseDecoder.decode(responseBody: unwrappedData)
                self.retention = output
            } else {
                self.retention = nil
            }
        } else {
            self.retention = nil
        }
    }
}

public struct GetObjectRetentionOutputResponse: Equatable {
    /// <p>The container element for an object's retention settings.</p>
    public let retention: ObjectLockRetention?

    public init (
        retention: ObjectLockRetention? = nil
    )
    {
        self.retention = retention
    }
}

struct GetObjectRetentionOutputResponseBody: Equatable {
    public let retention: ObjectLockRetention?
}

extension GetObjectRetentionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case retention = "Retention"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionDecoded = try containerValues.decodeIfPresent(ObjectLockRetention.self, forKey: .retention)
        retention = retentionDecoded
    }
}

extension GetObjectTaggingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetObjectTaggingInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), key: \(String(describing: key)), requestPayer: \(String(describing: requestPayer)), versionId: \(String(describing: versionId)))"}
}

extension GetObjectTaggingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetObjectTaggingInputHeadersMiddleware: Middleware {
    public let id: String = "GetObjectTaggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetObjectTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetObjectTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetObjectTaggingInput>
    public typealias MOutput = OperationOutput<GetObjectTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetObjectTaggingOutputError>
}

public struct GetObjectTaggingInputQueryItemMiddleware: Middleware {
    public let id: String = "GetObjectTaggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetObjectTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetObjectTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "tagging", value: nil))
        if let versionId = input.operationInput.versionId {
            let versionIdQueryItem = URLQueryItem(name: "versionId".urlPercentEncoding(), value: String(versionId).urlPercentEncoding())
            input.builder.withQueryItem(versionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetObjectTaggingInput>
    public typealias MOutput = OperationOutput<GetObjectTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetObjectTaggingOutputError>
}

public struct GetObjectTaggingInput: Equatable {
    /// <p>The bucket name containing the object for which to get the tagging information. </p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>Object key for which to get the tagging information.</p>
    public let key: String?
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    ///          owners need not specify this parameter in their requests. For information about downloading
    ///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    ///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let requestPayer: RequestPayer?
    /// <p>The versionId of the object for which to get the tagging information.</p>
    public let versionId: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        key: String? = nil,
        requestPayer: RequestPayer? = nil,
        versionId: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.requestPayer = requestPayer
        self.versionId = versionId
    }
}

struct GetObjectTaggingInputBody: Equatable {
}

extension GetObjectTaggingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetObjectTaggingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetObjectTaggingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetObjectTaggingOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetObjectTaggingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetObjectTaggingOutputResponse(tagSet: \(String(describing: tagSet)), versionId: \(String(describing: versionId)))"}
}

extension GetObjectTaggingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let versionIdHeaderValue = httpResponse.headers.value(for: "x-amz-version-id") {
            self.versionId = versionIdHeaderValue
        } else {
            self.versionId = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetObjectTaggingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tagSet = output.tagSet
        } else {
            self.tagSet = nil
        }
    }
}

public struct GetObjectTaggingOutputResponse: Equatable {
    /// <p>Contains the tag set.</p>
    public let tagSet: [Tag]?
    /// <p>The versionId of the object for which you got the tagging information.</p>
    public let versionId: String?

    public init (
        tagSet: [Tag]? = nil,
        versionId: String? = nil
    )
    {
        self.tagSet = tagSet
        self.versionId = versionId
    }
}

struct GetObjectTaggingOutputResponseBody: Equatable {
    public let tagSet: [Tag]?
}

extension GetObjectTaggingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagSet = "TagSet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tagSet) {
            struct KeyVal0{struct Tag{}}
            let tagSetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagSet)
            if let tagSetWrappedContainer = tagSetWrappedContainer {
                let tagSetContainer = try tagSetWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagSetBuffer:[Tag]? = nil
                if let tagSetContainer = tagSetContainer {
                    tagSetBuffer = [Tag]()
                    for structureContainer0 in tagSetContainer {
                        tagSetBuffer?.append(structureContainer0)
                    }
                }
                tagSet = tagSetBuffer
            } else {
                tagSet = []
            }
        } else {
            tagSet = nil
        }
    }
}

extension GetObjectTorrentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetObjectTorrentInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), key: \(String(describing: key)), requestPayer: \(String(describing: requestPayer)))"}
}

extension GetObjectTorrentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetObjectTorrentInputHeadersMiddleware: Middleware {
    public let id: String = "GetObjectTorrentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetObjectTorrentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetObjectTorrentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetObjectTorrentInput>
    public typealias MOutput = OperationOutput<GetObjectTorrentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetObjectTorrentOutputError>
}

public struct GetObjectTorrentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetObjectTorrentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetObjectTorrentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetObjectTorrentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "torrent", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetObjectTorrentInput>
    public typealias MOutput = OperationOutput<GetObjectTorrentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetObjectTorrentOutputError>
}

public struct GetObjectTorrentInput: Equatable {
    /// <p>The name of the bucket containing the object for which to get the torrent files.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The object key for which to get the information.</p>
    public let key: String?
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    ///          owners need not specify this parameter in their requests. For information about downloading
    ///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    ///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let requestPayer: RequestPayer?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        key: String? = nil,
        requestPayer: RequestPayer? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.requestPayer = requestPayer
    }
}

struct GetObjectTorrentInputBody: Equatable {
}

extension GetObjectTorrentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetObjectTorrentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetObjectTorrentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetObjectTorrentOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetObjectTorrentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetObjectTorrentOutputResponse(body: \(String(describing: body)), requestCharged: \(String(describing: requestCharged)))"}
}

extension GetObjectTorrentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            self.body = unwrappedData
        } else {
            self.body = nil
        }
    }
}

public struct GetObjectTorrentOutputResponse: Equatable {
    /// <p>A Bencoded dictionary as defined by the BitTorrent specification</p>
    public let body: Data?
    /// <p>If present, indicates that the requester was successfully charged for the
    ///          request.</p>
    public let requestCharged: RequestCharged?

    public init (
        body: Data? = nil,
        requestCharged: RequestCharged? = nil
    )
    {
        self.body = body
        self.requestCharged = requestCharged
    }
}

struct GetObjectTorrentOutputResponseBody: Equatable {
    public let body: Data?
}

extension GetObjectTorrentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.body) {
            do {
                let bodyDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .body)
                body = bodyDecoded
            } catch {
                body = "".data(using: .utf8)
            }
        } else {
            body = nil
        }
    }
}

extension GetPublicAccessBlockInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPublicAccessBlockInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension GetPublicAccessBlockInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetPublicAccessBlockInputHeadersMiddleware: Middleware {
    public let id: String = "GetPublicAccessBlockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPublicAccessBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPublicAccessBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPublicAccessBlockInput>
    public typealias MOutput = OperationOutput<GetPublicAccessBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPublicAccessBlockOutputError>
}

public struct GetPublicAccessBlockInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPublicAccessBlockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPublicAccessBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPublicAccessBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "publicAccessBlock", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPublicAccessBlockInput>
    public typealias MOutput = OperationOutput<GetPublicAccessBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPublicAccessBlockOutputError>
}

public struct GetPublicAccessBlockInput: Equatable {
    /// <p>The name of the Amazon S3 bucket whose <code>PublicAccessBlock</code> configuration you want
    ///          to retrieve. </p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct GetPublicAccessBlockInputBody: Equatable {
}

extension GetPublicAccessBlockInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetPublicAccessBlockOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetPublicAccessBlockOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPublicAccessBlockOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPublicAccessBlockOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPublicAccessBlockOutputResponse(publicAccessBlockConfiguration: \(String(describing: publicAccessBlockConfiguration)))"}
}

extension GetPublicAccessBlockOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: PublicAccessBlockConfiguration = try responseDecoder.decode(responseBody: unwrappedData)
                self.publicAccessBlockConfiguration = output
            } else {
                self.publicAccessBlockConfiguration = nil
            }
        } else {
            self.publicAccessBlockConfiguration = nil
        }
    }
}

public struct GetPublicAccessBlockOutputResponse: Equatable {
    /// <p>The <code>PublicAccessBlock</code> configuration currently in effect for this Amazon S3
    ///          bucket.</p>
    public let publicAccessBlockConfiguration: PublicAccessBlockConfiguration?

    public init (
        publicAccessBlockConfiguration: PublicAccessBlockConfiguration? = nil
    )
    {
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
    }
}

struct GetPublicAccessBlockOutputResponseBody: Equatable {
    public let publicAccessBlockConfiguration: PublicAccessBlockConfiguration?
}

extension GetPublicAccessBlockOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicAccessBlockConfigurationDecoded = try containerValues.decodeIfPresent(PublicAccessBlockConfiguration.self, forKey: .publicAccessBlockConfiguration)
        publicAccessBlockConfiguration = publicAccessBlockConfigurationDecoded
    }
}

extension GlacierJobParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tier = "Tier"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let tier = tier {
            try container.encode(tier, forKey: Key("tier"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tierDecoded = try containerValues.decodeIfPresent(Tier.self, forKey: .tier)
        tier = tierDecoded
    }
}

extension GlacierJobParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GlacierJobParameters(tier: \(String(describing: tier)))"}
}

extension GlacierJobParameters: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container for S3 Glacier job parameters.</p>
public struct GlacierJobParameters: Equatable {
    /// <p>Retrieval tier at which the restore will be processed.</p>
    public let tier: Tier?

    public init (
        tier: Tier? = nil
    )
    {
        self.tier = tier
    }
}

extension Grant: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantee = "Grantee"
        case permission = "Permission"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let grantee = grantee {
            var granteeContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("grantee"))
            try granteeContainer.encode(grantee, forKey: Key(""))
            try granteeContainer.encode("http://www.w3.org/2001/XMLSchema-instance", forKey: Key("xmlns:xsi"))
        }
        if let permission = permission {
            try container.encode(permission, forKey: Key("permission"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let granteeDecoded = try containerValues.decodeIfPresent(Grantee.self, forKey: .grantee)
        grantee = granteeDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(Permission.self, forKey: .permission)
        permission = permissionDecoded
    }
}

extension Grant: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Grant(grantee: \(String(describing: grantee)), permission: \(String(describing: permission)))"}
}

extension Grant: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns",
            "xmlns:xsi"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container for grant information.</p>
public struct Grant: Equatable {
    /// <p>The person being granted permissions.</p>
    public let grantee: Grantee?
    /// <p>Specifies the permission given to the grantee.</p>
    public let permission: Permission?

    public init (
        grantee: Grantee? = nil,
        permission: Permission? = nil
    )
    {
        self.grantee = grantee
        self.permission = permission
    }
}

extension Grantee: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case displayName = "DisplayName"
        case emailAddress = "EmailAddress"
        case iD = "ID"
        case type = "xsi:type"
        case uRI = "URI"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let displayName = displayName {
            try container.encode(displayName, forKey: Key("displayName"))
        }
        if let emailAddress = emailAddress {
            try container.encode(emailAddress, forKey: Key("emailAddress"))
        }
        if let iD = iD {
            try container.encode(iD, forKey: Key("iD"))
        }
        if let type = type {
            try container.encode(type, forKey: Key("xsi:type"))
        }
        if let uRI = uRI {
            try container.encode(uRI, forKey: Key("uRI"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let iDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iD)
        iD = iDDecoded
        let uRIDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uRI)
        uRI = uRIDecoded
        let typeDecoded = try containerValues.decodeIfPresent(`Type`.self, forKey: .type)
        type = typeDecoded
    }
}

extension Grantee: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Grantee(displayName: \(String(describing: displayName)), emailAddress: \(String(describing: emailAddress)), iD: \(String(describing: iD)), type: \(String(describing: type)), uRI: \(String(describing: uRI)))"}
}

extension Grantee: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        let codingKeys = [
            "xsi:type"
        ]
        if let key = key as? Key {
            if codingKeys.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container for the person being granted permissions.</p>
public struct Grantee: Equatable {
    /// <p>Screen name of the grantee.</p>
    public let displayName: String?
    /// <p>Email address of the grantee.</p>
    ///          <note>
    ///             <p>Using email addresses to specify a grantee is only supported in the following AWS Regions: </p>
    ///             <ul>
    ///                <li>
    ///                   <p>US East (N. Virginia)</p>
    ///                </li>
    ///                <li>
    ///                   <p>US West (N. California)</p>
    ///                </li>
    ///                <li>
    ///                   <p> US West (Oregon)</p>
    ///                </li>
    ///                <li>
    ///                   <p> Asia Pacific (Singapore)</p>
    ///                </li>
    ///                <li>
    ///                   <p>Asia Pacific (Sydney)</p>
    ///                </li>
    ///                <li>
    ///                   <p>Asia Pacific (Tokyo)</p>
    ///                </li>
    ///                <li>
    ///                   <p>Europe (Ireland)</p>
    ///                </li>
    ///                <li>
    ///                   <p>South America (So Paulo)</p>
    ///                </li>
    ///             </ul>
    ///             <p>For a list of all the Amazon S3 supported Regions and endpoints, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region">Regions and Endpoints</a> in the AWS General Reference.</p>
    ///          </note>
    public let emailAddress: String?
    /// <p>The canonical user ID of the grantee.</p>
    public let iD: String?
    /// <p>Type of grantee</p>
    public let type: `Type`?
    /// <p>URI of the grantee group.</p>
    public let uRI: String?

    public init (
        displayName: String? = nil,
        emailAddress: String? = nil,
        iD: String? = nil,
        type: `Type`? = nil,
        uRI: String? = nil
    )
    {
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.iD = iD
        self.type = type
        self.uRI = uRI
    }
}

extension HeadBucketInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HeadBucketInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension HeadBucketInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct HeadBucketInputHeadersMiddleware: Middleware {
    public let id: String = "HeadBucketInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<HeadBucketInput>,
                  next: H) -> Swift.Result<OperationOutput<HeadBucketOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<HeadBucketInput>
    public typealias MOutput = OperationOutput<HeadBucketOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<HeadBucketOutputError>
}

public struct HeadBucketInputQueryItemMiddleware: Middleware {
    public let id: String = "HeadBucketInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<HeadBucketInput>,
                  next: H) -> Swift.Result<OperationOutput<HeadBucketOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<HeadBucketInput>
    public typealias MOutput = OperationOutput<HeadBucketOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<HeadBucketOutputError>
}

public struct HeadBucketInput: Equatable {
    /// <p>The bucket name.</p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct HeadBucketInputBody: Equatable {
}

extension HeadBucketInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension HeadBucketOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension HeadBucketOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFound" : self = .notFound(try NotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum HeadBucketOutputError: Equatable {
    case notFound(NotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension HeadBucketOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HeadBucketOutputResponse()"}
}

extension HeadBucketOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct HeadBucketOutputResponse: Equatable {

    public init() {}
}

struct HeadBucketOutputResponseBody: Equatable {
}

extension HeadBucketOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension HeadObjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HeadObjectInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), ifMatch: \(String(describing: ifMatch)), ifModifiedSince: \(String(describing: ifModifiedSince)), ifNoneMatch: \(String(describing: ifNoneMatch)), ifUnmodifiedSince: \(String(describing: ifUnmodifiedSince)), key: \(String(describing: key)), partNumber: \(String(describing: partNumber)), range: \(String(describing: range)), requestPayer: \(String(describing: requestPayer)), sSECustomerAlgorithm: \(String(describing: sSECustomerAlgorithm)), sSECustomerKey: \(String(describing: sSECustomerKey)), sSECustomerKeyMD5: \(String(describing: sSECustomerKeyMD5)), versionId: \(String(describing: versionId)))"}
}

extension HeadObjectInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct HeadObjectInputHeadersMiddleware: Middleware {
    public let id: String = "HeadObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<HeadObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<HeadObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        if let ifModifiedSince = input.operationInput.ifModifiedSince {
            input.builder.withHeader(name: "If-Modified-Since", value: String(ifModifiedSince.rfc5322()))
        }
        if let ifNoneMatch = input.operationInput.ifNoneMatch {
            input.builder.withHeader(name: "If-None-Match", value: String(ifNoneMatch))
        }
        if let ifUnmodifiedSince = input.operationInput.ifUnmodifiedSince {
            input.builder.withHeader(name: "If-Unmodified-Since", value: String(ifUnmodifiedSince.rfc5322()))
        }
        if let range = input.operationInput.range {
            input.builder.withHeader(name: "Range", value: String(range))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        if let sSECustomerAlgorithm = input.operationInput.sSECustomerAlgorithm {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-algorithm", value: String(sSECustomerAlgorithm))
        }
        if let sSECustomerKey = input.operationInput.sSECustomerKey {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-key", value: String(sSECustomerKey))
        }
        if let sSECustomerKeyMD5 = input.operationInput.sSECustomerKeyMD5 {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-key-MD5", value: String(sSECustomerKeyMD5))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<HeadObjectInput>
    public typealias MOutput = OperationOutput<HeadObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<HeadObjectOutputError>
}

public struct HeadObjectInputQueryItemMiddleware: Middleware {
    public let id: String = "HeadObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<HeadObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<HeadObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let versionId = input.operationInput.versionId {
            let versionIdQueryItem = URLQueryItem(name: "versionId".urlPercentEncoding(), value: String(versionId).urlPercentEncoding())
            input.builder.withQueryItem(versionIdQueryItem)
        }
        let partNumberQueryItem = URLQueryItem(name: "partNumber".urlPercentEncoding(), value: String(input.operationInput.partNumber).urlPercentEncoding())
        input.builder.withQueryItem(partNumberQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<HeadObjectInput>
    public typealias MOutput = OperationOutput<HeadObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<HeadObjectOutputError>
}

public struct HeadObjectInput: Equatable {
    /// <p>The name of the bucket containing the object.</p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>Return the object only if its entity tag (ETag) is the same as the one specified,
    ///          otherwise return a 412 (precondition failed).</p>
    public let ifMatch: String?
    /// <p>Return the object only if it has been modified since the specified time, otherwise
    ///          return a 304 (not modified).</p>
    public let ifModifiedSince: Date?
    /// <p>Return the object only if its entity tag (ETag) is different from the one specified,
    ///          otherwise return a 304 (not modified).</p>
    public let ifNoneMatch: String?
    /// <p>Return the object only if it has not been modified since the specified time, otherwise
    ///          return a 412 (precondition failed).</p>
    public let ifUnmodifiedSince: Date?
    /// <p>The object key.</p>
    public let key: String?
    /// <p>Part number of the object being read. This is a positive integer between 1 and 10,000.
    ///          Effectively performs a 'ranged' HEAD request for the part specified. Useful querying about
    ///          the size of the part and the number of parts in this object.</p>
    public let partNumber: Int
    /// <p>Downloads the specified range bytes of an object. For more information about the HTTP
    ///          Range header, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35</a>.</p>
    ///          <note>
    ///             <p>Amazon S3 doesn't support retrieving multiple ranges of data per <code>GET</code>
    ///             request.</p>
    ///          </note>
    public let range: String?
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    ///          owners need not specify this parameter in their requests. For information about downloading
    ///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    ///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let requestPayer: RequestPayer?
    /// <p>Specifies the algorithm to use to when encrypting the object (for example,
    ///          AES256).</p>
    public let sSECustomerAlgorithm: String?
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
    ///          value is used to store the object and then it is discarded; Amazon S3 does not store the
    ///          encryption key. The key must be appropriate for use with the algorithm specified in the
    ///             <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
    public let sSECustomerKey: String?
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    ///          this header for a message integrity check to ensure that the encryption key was transmitted
    ///          without error.</p>
    public let sSECustomerKeyMD5: String?
    /// <p>VersionId used to reference a specific version of the object.</p>
    public let versionId: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        ifMatch: String? = nil,
        ifModifiedSince: Date? = nil,
        ifNoneMatch: String? = nil,
        ifUnmodifiedSince: Date? = nil,
        key: String? = nil,
        partNumber: Int = 0,
        range: String? = nil,
        requestPayer: RequestPayer? = nil,
        sSECustomerAlgorithm: String? = nil,
        sSECustomerKey: String? = nil,
        sSECustomerKeyMD5: String? = nil,
        versionId: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.ifMatch = ifMatch
        self.ifModifiedSince = ifModifiedSince
        self.ifNoneMatch = ifNoneMatch
        self.ifUnmodifiedSince = ifUnmodifiedSince
        self.key = key
        self.partNumber = partNumber
        self.range = range
        self.requestPayer = requestPayer
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKey = sSECustomerKey
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.versionId = versionId
    }
}

struct HeadObjectInputBody: Equatable {
}

extension HeadObjectInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension HeadObjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension HeadObjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFound" : self = .notFound(try NotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum HeadObjectOutputError: Equatable {
    case notFound(NotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension HeadObjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HeadObjectOutputResponse(acceptRanges: \(String(describing: acceptRanges)), archiveStatus: \(String(describing: archiveStatus)), bucketKeyEnabled: \(String(describing: bucketKeyEnabled)), cacheControl: \(String(describing: cacheControl)), contentDisposition: \(String(describing: contentDisposition)), contentEncoding: \(String(describing: contentEncoding)), contentLanguage: \(String(describing: contentLanguage)), contentLength: \(String(describing: contentLength)), contentType: \(String(describing: contentType)), deleteMarker: \(String(describing: deleteMarker)), eTag: \(String(describing: eTag)), expiration: \(String(describing: expiration)), expires: \(String(describing: expires)), lastModified: \(String(describing: lastModified)), metadata: \(String(describing: metadata)), missingMeta: \(String(describing: missingMeta)), objectLockLegalHoldStatus: \(String(describing: objectLockLegalHoldStatus)), objectLockMode: \(String(describing: objectLockMode)), objectLockRetainUntilDate: \(String(describing: objectLockRetainUntilDate)), partsCount: \(String(describing: partsCount)), replicationStatus: \(String(describing: replicationStatus)), requestCharged: \(String(describing: requestCharged)), restore: \(String(describing: restore)), sSECustomerAlgorithm: \(String(describing: sSECustomerAlgorithm)), sSECustomerKeyMD5: \(String(describing: sSECustomerKeyMD5)), sSEKMSKeyId: \(String(describing: sSEKMSKeyId)), serverSideEncryption: \(String(describing: serverSideEncryption)), storageClass: \(String(describing: storageClass)), versionId: \(String(describing: versionId)), websiteRedirectLocation: \(String(describing: websiteRedirectLocation)))"}
}

extension HeadObjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let acceptRangesHeaderValue = httpResponse.headers.value(for: "accept-ranges") {
            self.acceptRanges = acceptRangesHeaderValue
        } else {
            self.acceptRanges = nil
        }
        if let archiveStatusHeaderValue = httpResponse.headers.value(for: "x-amz-archive-status") {
            self.archiveStatus = ArchiveStatus(rawValue: archiveStatusHeaderValue)
        } else {
            self.archiveStatus = nil
        }
        if let bucketKeyEnabledHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-bucket-key-enabled") {
            self.bucketKeyEnabled = Bool(bucketKeyEnabledHeaderValue) ?? false
        } else {
            self.bucketKeyEnabled = false
        }
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            self.cacheControl = cacheControlHeaderValue
        } else {
            self.cacheControl = nil
        }
        if let contentDispositionHeaderValue = httpResponse.headers.value(for: "Content-Disposition") {
            self.contentDisposition = contentDispositionHeaderValue
        } else {
            self.contentDisposition = nil
        }
        if let contentEncodingHeaderValue = httpResponse.headers.value(for: "Content-Encoding") {
            self.contentEncoding = contentEncodingHeaderValue
        } else {
            self.contentEncoding = nil
        }
        if let contentLanguageHeaderValue = httpResponse.headers.value(for: "Content-Language") {
            self.contentLanguage = contentLanguageHeaderValue
        } else {
            self.contentLanguage = nil
        }
        if let contentLengthHeaderValue = httpResponse.headers.value(for: "Content-Length") {
            self.contentLength = Int(contentLengthHeaderValue) ?? 0
        } else {
            self.contentLength = 0
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let deleteMarkerHeaderValue = httpResponse.headers.value(for: "x-amz-delete-marker") {
            self.deleteMarker = Bool(deleteMarkerHeaderValue) ?? false
        } else {
            self.deleteMarker = false
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let expirationHeaderValue = httpResponse.headers.value(for: "x-amz-expiration") {
            self.expiration = expirationHeaderValue
        } else {
            self.expiration = nil
        }
        if let expiresHeaderValue = httpResponse.headers.value(for: "Expires") {
            self.expires = DateFormatter.rfc5322DateFormatter.date(from: expiresHeaderValue)
        } else {
            self.expires = nil
        }
        if let lastModifiedHeaderValue = httpResponse.headers.value(for: "Last-Modified") {
            self.lastModified = DateFormatter.rfc5322DateFormatter.date(from: lastModifiedHeaderValue)
        } else {
            self.lastModified = nil
        }
        if let missingMetaHeaderValue = httpResponse.headers.value(for: "x-amz-missing-meta") {
            self.missingMeta = Int(missingMetaHeaderValue) ?? 0
        } else {
            self.missingMeta = 0
        }
        if let objectLockLegalHoldStatusHeaderValue = httpResponse.headers.value(for: "x-amz-object-lock-legal-hold") {
            self.objectLockLegalHoldStatus = ObjectLockLegalHoldStatus(rawValue: objectLockLegalHoldStatusHeaderValue)
        } else {
            self.objectLockLegalHoldStatus = nil
        }
        if let objectLockModeHeaderValue = httpResponse.headers.value(for: "x-amz-object-lock-mode") {
            self.objectLockMode = ObjectLockMode(rawValue: objectLockModeHeaderValue)
        } else {
            self.objectLockMode = nil
        }
        if let objectLockRetainUntilDateHeaderValue = httpResponse.headers.value(for: "x-amz-object-lock-retain-until-date") {
            self.objectLockRetainUntilDate = DateFormatter.iso8601DateFormatterWithoutFractionalSeconds.date(from: objectLockRetainUntilDateHeaderValue)
        } else {
            self.objectLockRetainUntilDate = nil
        }
        if let partsCountHeaderValue = httpResponse.headers.value(for: "x-amz-mp-parts-count") {
            self.partsCount = Int(partsCountHeaderValue) ?? 0
        } else {
            self.partsCount = 0
        }
        if let replicationStatusHeaderValue = httpResponse.headers.value(for: "x-amz-replication-status") {
            self.replicationStatus = ReplicationStatus(rawValue: replicationStatusHeaderValue)
        } else {
            self.replicationStatus = nil
        }
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if let restoreHeaderValue = httpResponse.headers.value(for: "x-amz-restore") {
            self.restore = restoreHeaderValue
        } else {
            self.restore = nil
        }
        if let sSECustomerAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-algorithm") {
            self.sSECustomerAlgorithm = sSECustomerAlgorithmHeaderValue
        } else {
            self.sSECustomerAlgorithm = nil
        }
        if let sSECustomerKeyMD5HeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-key-MD5") {
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5HeaderValue
        } else {
            self.sSECustomerKeyMD5 = nil
        }
        if let sSEKMSKeyIdHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-aws-kms-key-id") {
            self.sSEKMSKeyId = sSEKMSKeyIdHeaderValue
        } else {
            self.sSEKMSKeyId = nil
        }
        if let serverSideEncryptionHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption") {
            self.serverSideEncryption = ServerSideEncryption(rawValue: serverSideEncryptionHeaderValue)
        } else {
            self.serverSideEncryption = nil
        }
        if let storageClassHeaderValue = httpResponse.headers.value(for: "x-amz-storage-class") {
            self.storageClass = StorageClass(rawValue: storageClassHeaderValue)
        } else {
            self.storageClass = nil
        }
        if let versionIdHeaderValue = httpResponse.headers.value(for: "x-amz-version-id") {
            self.versionId = versionIdHeaderValue
        } else {
            self.versionId = nil
        }
        if let websiteRedirectLocationHeaderValue = httpResponse.headers.value(for: "x-amz-website-redirect-location") {
            self.websiteRedirectLocation = websiteRedirectLocationHeaderValue
        } else {
            self.websiteRedirectLocation = nil
        }
        let keysForMetadata = httpResponse.headers.dictionary.keys.filter({ $0.starts(with: "x-amz-meta-") })
        if (!keysForMetadata.isEmpty) {
            var mapMember = [String: String]()
            for headerKey in keysForMetadata {
                let mapMemberValue = httpResponse.headers.dictionary[headerKey]?[0]
                let mapMemberKey = headerKey.removePrefix("x-amz-meta-")
                mapMember[mapMemberKey] = mapMemberValue
            }
            self.metadata = mapMember
        } else {
            self.metadata = [:]
        }
    }
}

public struct HeadObjectOutputResponse: Equatable {
    /// <p>Indicates that a range of bytes was specified.</p>
    public let acceptRanges: String?
    /// <p>The archive state of the head object.</p>
    public let archiveStatus: ArchiveStatus?
    /// <p>Indicates whether the object uses an S3 Bucket Key for server-side encryption with AWS KMS (SSE-KMS).</p>
    public let bucketKeyEnabled: Bool
    /// <p>Specifies caching behavior along the request/reply chain.</p>
    public let cacheControl: String?
    /// <p>Specifies presentational information for the object.</p>
    public let contentDisposition: String?
    /// <p>Specifies what content encodings have been applied to the object and thus what decoding
    ///          mechanisms must be applied to obtain the media-type referenced by the Content-Type header
    ///          field.</p>
    public let contentEncoding: String?
    /// <p>The language the content is in.</p>
    public let contentLanguage: String?
    /// <p>Size of the body in bytes.</p>
    public let contentLength: Int
    /// <p>A standard MIME type describing the format of the object data.</p>
    public let contentType: String?
    /// <p>Specifies whether the object retrieved was (true) or was not (false) a Delete Marker. If
    ///          false, this response header does not appear in the response.</p>
    public let deleteMarker: Bool
    /// <p>An ETag is an opaque identifier assigned by a web server to a specific version of a
    ///          resource found at a URL.</p>
    public let eTag: String?
    /// <p>If the object expiration is configured (see PUT Bucket lifecycle), the response includes
    ///          this header. It includes the expiry-date and rule-id key-value pairs providing object
    ///          expiration information. The value of the rule-id is URL encoded.</p>
    public let expiration: String?
    /// <p>The date and time at which the object is no longer cacheable.</p>
    public let expires: Date?
    /// <p>Creation date of the object.</p>
    public let lastModified: Date?
    /// <p>A map of metadata to store with the object in S3.</p>
    public let metadata: [String:String]?
    /// <p>This is set to the number of metadata entries not returned in <code>x-amz-meta</code>
    ///          headers. This can happen if you create metadata using an API like SOAP that supports more
    ///          flexible metadata than the REST API. For example, using SOAP, you can create metadata whose
    ///          values are not legal HTTP headers.</p>
    public let missingMeta: Int
    /// <p>Specifies whether a legal hold is in effect for this object. This header is only
    ///          returned if the requester has the <code>s3:GetObjectLegalHold</code> permission. This
    ///          header is not returned if the specified version of this object has never had a legal hold
    ///          applied. For more information about S3 Object Lock, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock.html">Object Lock</a>.</p>
    public let objectLockLegalHoldStatus: ObjectLockLegalHoldStatus?
    /// <p>The Object Lock mode, if any, that's in effect for this object. This header is only
    ///          returned if the requester has the <code>s3:GetObjectRetention</code> permission. For more
    ///          information about S3 Object Lock, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock.html">Object
    ///             Lock</a>. </p>
    public let objectLockMode: ObjectLockMode?
    /// <p>The date and time when the Object Lock retention period expires. This header is only
    ///          returned if the requester has the <code>s3:GetObjectRetention</code> permission.</p>
    public let objectLockRetainUntilDate: Date?
    /// <p>The count of parts this object has.</p>
    public let partsCount: Int
    /// <p>Amazon S3 can return this header if your request involves a bucket that is either a source or
    ///          a destination in a replication rule.</p>
    ///
    ///          <p>In replication, you have a source bucket on which you configure replication and
    ///          destination bucket or buckets where Amazon S3 stores object replicas. When you request an object
    ///             (<code>GetObject</code>) or object metadata (<code>HeadObject</code>) from these
    ///          buckets, Amazon S3 will return the <code>x-amz-replication-status</code> header in the response
    ///          as follows:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If requesting an object from the source bucket  Amazon S3 will return the
    ///                   <code>x-amz-replication-status</code> header if the object in your request is
    ///                eligible for replication.</p>
    ///                <p> For example, suppose that in your replication configuration, you specify object
    ///                prefix <code>TaxDocs</code> requesting Amazon S3 to replicate objects with key prefix
    ///                   <code>TaxDocs</code>. Any objects you upload with this key name prefix, for
    ///                example <code>TaxDocs/document1.pdf</code>, are eligible for replication. For any
    ///                object request with this key name prefix, Amazon S3 will return the
    ///                   <code>x-amz-replication-status</code> header with value PENDING, COMPLETED or
    ///                FAILED indicating object replication status.</p>
    ///             </li>
    ///             <li>
    ///                <p>If requesting an object from a destination bucket  Amazon S3 will return the
    ///                   <code>x-amz-replication-status</code> header with value REPLICA if the object in
    ///                your request is a replica that Amazon S3 created and there is no replica modification
    ///                replication in progress.</p>
    ///             </li>
    ///             <li>
    ///                <p>When replicating objects to multiple destination buckets the
    ///                   <code>x-amz-replication-status</code> header acts differently. The header of the
    ///                source object will only return a value of COMPLETED when replication is successful to
    ///                all destinations. The header will remain at value PENDING until replication has
    ///                completed for all destinations. If one or more destinations fails replication the
    ///                header will return FAILED. </p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html">Replication</a>.</p>
    public let replicationStatus: ReplicationStatus?
    /// <p>If present, indicates that the requester was successfully charged for the
    ///          request.</p>
    public let requestCharged: RequestCharged?
    /// <p>If the object is an archived object (an object whose storage class is GLACIER), the
    ///          response includes this header if either the archive restoration is in progress (see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_RestoreObject.html">RestoreObject</a> or an archive copy is already restored.</p>
    ///
    ///          <p> If an archive copy is already restored, the header value indicates when Amazon S3 is
    ///          scheduled to delete the object copy. For example:</p>
    ///
    ///          <p>
    ///             <code>x-amz-restore: ongoing-request="false", expiry-date="Fri, 21 Dec 2012 00:00:00
    ///             GMT"</code>
    ///          </p>
    ///
    ///          <p>If the object restoration is in progress, the header returns the value
    ///             <code>ongoing-request="true"</code>.</p>
    ///
    ///          <p>For more information about archiving objects, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lifecycle-mgmt.html#lifecycle-transition-general-considerations">Transitioning Objects: General Considerations</a>.</p>
    public let restore: String?
    /// <p>If server-side encryption with a customer-provided encryption key was requested, the
    ///          response will include this header confirming the encryption algorithm used.</p>
    public let sSECustomerAlgorithm: String?
    /// <p>If server-side encryption with a customer-provided encryption key was requested, the
    ///          response will include this header to provide round-trip message integrity verification of
    ///          the customer-provided encryption key.</p>
    public let sSECustomerKeyMD5: String?
    /// <p>If present, specifies the ID of the AWS Key Management Service (AWS KMS) symmetric
    ///          customer managed customer master key (CMK) that was used for the object.</p>
    public let sSEKMSKeyId: String?
    /// <p>If the object is stored using server-side encryption either with an AWS KMS customer
    ///          master key (CMK) or an Amazon S3-managed encryption key, the response includes this header with
    ///          the value of the server-side encryption algorithm used when storing this object in Amazon
    ///          S3 (for example, AES256, aws:kms).</p>
    public let serverSideEncryption: ServerSideEncryption?
    /// <p>Provides storage class information of the object. Amazon S3 returns this header for all
    ///          objects except for S3 Standard storage class objects.</p>
    ///
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html">Storage
    ///             Classes</a>.</p>
    public let storageClass: StorageClass?
    /// <p>Version of the object.</p>
    public let versionId: String?
    /// <p>If the bucket is configured as a website, redirects requests for this object to another
    ///          object in the same bucket or to an external URL. Amazon S3 stores the value of this header in
    ///          the object metadata.</p>
    public let websiteRedirectLocation: String?

    public init (
        acceptRanges: String? = nil,
        archiveStatus: ArchiveStatus? = nil,
        bucketKeyEnabled: Bool = false,
        cacheControl: String? = nil,
        contentDisposition: String? = nil,
        contentEncoding: String? = nil,
        contentLanguage: String? = nil,
        contentLength: Int = 0,
        contentType: String? = nil,
        deleteMarker: Bool = false,
        eTag: String? = nil,
        expiration: String? = nil,
        expires: Date? = nil,
        lastModified: Date? = nil,
        metadata: [String:String]? = nil,
        missingMeta: Int = 0,
        objectLockLegalHoldStatus: ObjectLockLegalHoldStatus? = nil,
        objectLockMode: ObjectLockMode? = nil,
        objectLockRetainUntilDate: Date? = nil,
        partsCount: Int = 0,
        replicationStatus: ReplicationStatus? = nil,
        requestCharged: RequestCharged? = nil,
        restore: String? = nil,
        sSECustomerAlgorithm: String? = nil,
        sSECustomerKeyMD5: String? = nil,
        sSEKMSKeyId: String? = nil,
        serverSideEncryption: ServerSideEncryption? = nil,
        storageClass: StorageClass? = nil,
        versionId: String? = nil,
        websiteRedirectLocation: String? = nil
    )
    {
        self.acceptRanges = acceptRanges
        self.archiveStatus = archiveStatus
        self.bucketKeyEnabled = bucketKeyEnabled
        self.cacheControl = cacheControl
        self.contentDisposition = contentDisposition
        self.contentEncoding = contentEncoding
        self.contentLanguage = contentLanguage
        self.contentLength = contentLength
        self.contentType = contentType
        self.deleteMarker = deleteMarker
        self.eTag = eTag
        self.expiration = expiration
        self.expires = expires
        self.lastModified = lastModified
        self.metadata = metadata
        self.missingMeta = missingMeta
        self.objectLockLegalHoldStatus = objectLockLegalHoldStatus
        self.objectLockMode = objectLockMode
        self.objectLockRetainUntilDate = objectLockRetainUntilDate
        self.partsCount = partsCount
        self.replicationStatus = replicationStatus
        self.requestCharged = requestCharged
        self.restore = restore
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
        self.storageClass = storageClass
        self.versionId = versionId
        self.websiteRedirectLocation = websiteRedirectLocation
    }
}

struct HeadObjectOutputResponseBody: Equatable {
}

extension HeadObjectOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension IndexDocument: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case suffix = "Suffix"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let suffix = suffix {
            try container.encode(suffix, forKey: Key("suffix"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suffixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suffix)
        suffix = suffixDecoded
    }
}

extension IndexDocument: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IndexDocument(suffix: \(String(describing: suffix)))"}
}

extension IndexDocument: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container for the <code>Suffix</code> element.</p>
public struct IndexDocument: Equatable {
    /// <p>A suffix that is appended to a request that is for a directory on the website endpoint
    ///          (for example,if the suffix is index.html and you make a request to samplebucket/images/ the
    ///          data that is returned will be for the object with the key name images/index.html) The
    ///          suffix must not be empty and must not include a slash character.</p>
    ///          <important>
    ///             <p>Replacement must be made for object keys containing special characters (such as carriage returns) when using
    ///          XML requests. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints">
    ///             XML related object key constraints</a>.</p>
    ///          </important>
    public let suffix: String?

    public init (
        suffix: String? = nil
    )
    {
        self.suffix = suffix
    }
}

extension Initiator: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case displayName = "DisplayName"
        case iD = "ID"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let displayName = displayName {
            try container.encode(displayName, forKey: Key("displayName"))
        }
        if let iD = iD {
            try container.encode(iD, forKey: Key("iD"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iD)
        iD = iDDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension Initiator: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Initiator(displayName: \(String(describing: displayName)), iD: \(String(describing: iD)))"}
}

extension Initiator: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container element that identifies who initiated the multipart upload. </p>
public struct Initiator: Equatable {
    /// <p>Name of the Principal.</p>
    public let displayName: String?
    /// <p>If the principal is an AWS account, it provides the Canonical User ID. If the principal
    ///          is an IAM User, it provides a user ARN value.</p>
    public let iD: String?

    public init (
        displayName: String? = nil,
        iD: String? = nil
    )
    {
        self.displayName = displayName
        self.iD = iD
    }
}

extension InputSerialization: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cSV = "CSV"
        case compressionType = "CompressionType"
        case jSON = "JSON"
        case parquet = "Parquet"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let cSV = cSV {
            try container.encode(cSV, forKey: Key("cSV"))
        }
        if let compressionType = compressionType {
            try container.encode(compressionType, forKey: Key("compressionType"))
        }
        if let jSON = jSON {
            try container.encode(jSON, forKey: Key("jSON"))
        }
        if let parquet = parquet {
            try container.encode(parquet, forKey: Key("parquet"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cSVDecoded = try containerValues.decodeIfPresent(CSVInput.self, forKey: .cSV)
        cSV = cSVDecoded
        let compressionTypeDecoded = try containerValues.decodeIfPresent(CompressionType.self, forKey: .compressionType)
        compressionType = compressionTypeDecoded
        let jSONDecoded = try containerValues.decodeIfPresent(JSONInput.self, forKey: .jSON)
        jSON = jSONDecoded
        let parquetDecoded = try containerValues.decodeIfPresent(ParquetInput.self, forKey: .parquet)
        parquet = parquetDecoded
    }
}

extension InputSerialization: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputSerialization(cSV: \(String(describing: cSV)), compressionType: \(String(describing: compressionType)), jSON: \(String(describing: jSON)), parquet: \(String(describing: parquet)))"}
}

extension InputSerialization: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Describes the serialization format of the object.</p>
public struct InputSerialization: Equatable {
    /// <p>Describes the serialization of a CSV-encoded object.</p>
    public let cSV: CSVInput?
    /// <p>Specifies object's compression format. Valid values: NONE, GZIP, BZIP2. Default Value:
    ///          NONE.</p>
    public let compressionType: CompressionType?
    /// <p>Specifies JSON as object's input serialization format.</p>
    public let jSON: JSONInput?
    /// <p>Specifies Parquet as object's input serialization format.</p>
    public let parquet: ParquetInput?

    public init (
        cSV: CSVInput? = nil,
        compressionType: CompressionType? = nil,
        jSON: JSONInput? = nil,
        parquet: ParquetInput? = nil
    )
    {
        self.cSV = cSV
        self.compressionType = compressionType
        self.jSON = jSON
        self.parquet = parquet
    }
}

public enum IntelligentTieringAccessTier {
    case archiveAccess
    case deepArchiveAccess
    case sdkUnknown(String)
}

extension IntelligentTieringAccessTier : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IntelligentTieringAccessTier] {
        return [
            .archiveAccess,
            .deepArchiveAccess,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .archiveAccess: return "ARCHIVE_ACCESS"
        case .deepArchiveAccess: return "DEEP_ARCHIVE_ACCESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IntelligentTieringAccessTier(rawValue: rawValue) ?? IntelligentTieringAccessTier.sdkUnknown(rawValue)
    }
}

extension IntelligentTieringAndOperator: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case prefix = "Prefix"
        case tags = "Tag"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let prefix = prefix {
            try container.encode(prefix, forKey: Key("prefix"))
        }
        if let tags = tags {
            if tags.isEmpty {
                var tagsContainer = container.nestedUnkeyedContainer(forKey: Key("Tag"))
                try tagsContainer.encodeNil()
            } else {
                for tag0 in tags {
                    var tagsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tag"))
                    try tagsContainer0.encode(tag0, forKey: Key(""))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        if containerValues.contains(.tags) {
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .tags)
            if tagsWrappedContainer != nil {
                let tagsContainer = try containerValues.decodeIfPresent([Tag].self, forKey: .tags)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension IntelligentTieringAndOperator: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IntelligentTieringAndOperator(prefix: \(String(describing: prefix)), tags: \(String(describing: tags)))"}
}

extension IntelligentTieringAndOperator: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container for specifying S3 Intelligent-Tiering filters. The filters determine the
///          subset of objects to which the rule applies.</p>
public struct IntelligentTieringAndOperator: Equatable {
    /// <p>An object key name prefix that identifies the subset of objects to which the
    ///          configuration applies.</p>
    public let prefix: String?
    /// <p>All of these tags must exist in the object's tag set in order for the configuration to
    ///          apply.</p>
    public let tags: [Tag]?

    public init (
        prefix: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.prefix = prefix
        self.tags = tags
    }
}

extension IntelligentTieringConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case id = "Id"
        case status = "Status"
        case tierings = "Tiering"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let filter = filter {
            try container.encode(filter, forKey: Key("filter"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
        if let tierings = tierings {
            if tierings.isEmpty {
                var tieringsContainer = container.nestedUnkeyedContainer(forKey: Key("Tiering"))
                try tieringsContainer.encodeNil()
            } else {
                for tiering0 in tierings {
                    var tieringsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tiering"))
                    try tieringsContainer0.encode(tiering0, forKey: Key(""))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let filterDecoded = try containerValues.decodeIfPresent(IntelligentTieringFilter.self, forKey: .filter)
        filter = filterDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IntelligentTieringStatus.self, forKey: .status)
        status = statusDecoded
        if containerValues.contains(.tierings) {
            let tieringsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .tierings)
            if tieringsWrappedContainer != nil {
                let tieringsContainer = try containerValues.decodeIfPresent([Tiering].self, forKey: .tierings)
                var tieringsBuffer:[Tiering]? = nil
                if let tieringsContainer = tieringsContainer {
                    tieringsBuffer = [Tiering]()
                    for structureContainer0 in tieringsContainer {
                        tieringsBuffer?.append(structureContainer0)
                    }
                }
                tierings = tieringsBuffer
            } else {
                tierings = []
            }
        } else {
            tierings = nil
        }
    }
}

extension IntelligentTieringConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IntelligentTieringConfiguration(filter: \(String(describing: filter)), id: \(String(describing: id)), status: \(String(describing: status)), tierings: \(String(describing: tierings)))"}
}

extension IntelligentTieringConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies the S3 Intelligent-Tiering configuration for an Amazon S3 bucket.</p>
///          <p>For information about the S3 Intelligent-Tiering storage class, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html#sc-dynamic-data-access">Storage class for
///             automatically optimizing frequently and infrequently accessed objects</a>.</p>
public struct IntelligentTieringConfiguration: Equatable {
    /// <p>Specifies a bucket filter. The configuration only includes objects that meet the
    ///          filter's criteria.</p>
    public let filter: IntelligentTieringFilter?
    /// <p>The ID used to identify the S3 Intelligent-Tiering configuration.</p>
    public let id: String?
    /// <p>Specifies the status of the configuration.</p>
    public let status: IntelligentTieringStatus?
    /// <p>Specifies the S3 Intelligent-Tiering storage class tier of the configuration.</p>
    public let tierings: [Tiering]?

    public init (
        filter: IntelligentTieringFilter? = nil,
        id: String? = nil,
        status: IntelligentTieringStatus? = nil,
        tierings: [Tiering]? = nil
    )
    {
        self.filter = filter
        self.id = id
        self.status = status
        self.tierings = tierings
    }
}

extension IntelligentTieringFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case and = "And"
        case prefix = "Prefix"
        case tag = "Tag"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let and = and {
            try container.encode(and, forKey: Key("and"))
        }
        if let prefix = prefix {
            try container.encode(prefix, forKey: Key("prefix"))
        }
        if let tag = tag {
            try container.encode(tag, forKey: Key("tag"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        let tagDecoded = try containerValues.decodeIfPresent(Tag.self, forKey: .tag)
        tag = tagDecoded
        let andDecoded = try containerValues.decodeIfPresent(IntelligentTieringAndOperator.self, forKey: .and)
        and = andDecoded
    }
}

extension IntelligentTieringFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IntelligentTieringFilter(and: \(String(describing: and)), prefix: \(String(describing: prefix)), tag: \(String(describing: tag)))"}
}

extension IntelligentTieringFilter: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The <code>Filter</code> is used to identify objects that the S3 Intelligent-Tiering
///          configuration applies to.</p>
public struct IntelligentTieringFilter: Equatable {
    /// <p>A conjunction (logical AND) of predicates, which is used in evaluating a metrics filter.
    ///          The operator must have at least two predicates, and an object must match all of the
    ///          predicates in order for the filter to apply.</p>
    public let and: IntelligentTieringAndOperator?
    /// <p>An object key name prefix that identifies the subset of objects to which the rule
    ///          applies.</p>
    ///          <important>
    ///             <p>Replacement must be made for object keys containing special characters (such as carriage returns) when using
    ///          XML requests. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints">
    ///             XML related object key constraints</a>.</p>
    ///          </important>
    public let prefix: String?
    /// <p>A container of a key value name pair.</p>
    public let tag: Tag?

    public init (
        and: IntelligentTieringAndOperator? = nil,
        prefix: String? = nil,
        tag: Tag? = nil
    )
    {
        self.and = and
        self.prefix = prefix
        self.tag = tag
    }
}

public enum IntelligentTieringStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension IntelligentTieringStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IntelligentTieringStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "Disabled"
        case .enabled: return "Enabled"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IntelligentTieringStatus(rawValue: rawValue) ?? IntelligentTieringStatus.sdkUnknown(rawValue)
    }
}

extension InvalidObjectState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidObjectState(accessTier: \(String(describing: accessTier)), storageClass: \(String(describing: storageClass)))"}
}

extension InvalidObjectState: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidObjectStateBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessTier = output.accessTier
            self.storageClass = output.storageClass
        } else {
            self.accessTier = nil
            self.storageClass = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Object is archived and inaccessible until restored.</p>
public struct InvalidObjectState: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var accessTier: IntelligentTieringAccessTier?
    public var storageClass: StorageClass?

    public init (
        accessTier: IntelligentTieringAccessTier? = nil,
        storageClass: StorageClass? = nil
    )
    {
        self.accessTier = accessTier
        self.storageClass = storageClass
    }
}

struct InvalidObjectStateBody: Equatable {
    public let storageClass: StorageClass?
    public let accessTier: IntelligentTieringAccessTier?
}

extension InvalidObjectStateBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessTier = "AccessTier"
        case storageClass = "StorageClass"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageClassDecoded = try containerValues.decodeIfPresent(StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let accessTierDecoded = try containerValues.decodeIfPresent(IntelligentTieringAccessTier.self, forKey: .accessTier)
        accessTier = accessTierDecoded
    }
}

extension InventoryConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destination = "Destination"
        case filter = "Filter"
        case id = "Id"
        case includedObjectVersions = "IncludedObjectVersions"
        case isEnabled = "IsEnabled"
        case optionalFields = "OptionalFields"
        case schedule = "Schedule"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let destination = destination {
            try container.encode(destination, forKey: Key("destination"))
        }
        if let filter = filter {
            try container.encode(filter, forKey: Key("filter"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let includedObjectVersions = includedObjectVersions {
            try container.encode(includedObjectVersions, forKey: Key("includedObjectVersions"))
        }
        if isEnabled != false {
            try container.encode(isEnabled, forKey: Key("isEnabled"))
        }
        if let optionalFields = optionalFields {
            var optionalFieldsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("optionalFields"))
            for inventoryoptionalfield0 in optionalFields {
                try optionalFieldsContainer.encode(inventoryoptionalfield0, forKey: Key("Field"))
            }
        }
        if let schedule = schedule {
            try container.encode(schedule, forKey: Key("schedule"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(InventoryDestination.self, forKey: .destination)
        destination = destinationDecoded
        let isEnabledDecoded = try containerValues.decode(Bool.self, forKey: .isEnabled)
        isEnabled = isEnabledDecoded
        let filterDecoded = try containerValues.decodeIfPresent(InventoryFilter.self, forKey: .filter)
        filter = filterDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let includedObjectVersionsDecoded = try containerValues.decodeIfPresent(InventoryIncludedObjectVersions.self, forKey: .includedObjectVersions)
        includedObjectVersions = includedObjectVersionsDecoded
        if containerValues.contains(.optionalFields) {
            struct KeyVal0{struct Field{}}
            let optionalFieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Field>.CodingKeys.self, forKey: .optionalFields)
            if let optionalFieldsWrappedContainer = optionalFieldsWrappedContainer {
                let optionalFieldsContainer = try optionalFieldsWrappedContainer.decodeIfPresent([InventoryOptionalField].self, forKey: .member)
                var optionalFieldsBuffer:[InventoryOptionalField]? = nil
                if let optionalFieldsContainer = optionalFieldsContainer {
                    optionalFieldsBuffer = [InventoryOptionalField]()
                    for stringContainer0 in optionalFieldsContainer {
                        optionalFieldsBuffer?.append(stringContainer0)
                    }
                }
                optionalFields = optionalFieldsBuffer
            } else {
                optionalFields = []
            }
        } else {
            optionalFields = nil
        }
        let scheduleDecoded = try containerValues.decodeIfPresent(InventorySchedule.self, forKey: .schedule)
        schedule = scheduleDecoded
    }
}

extension InventoryConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InventoryConfiguration(destination: \(String(describing: destination)), filter: \(String(describing: filter)), id: \(String(describing: id)), includedObjectVersions: \(String(describing: includedObjectVersions)), isEnabled: \(String(describing: isEnabled)), optionalFields: \(String(describing: optionalFields)), schedule: \(String(describing: schedule)))"}
}

extension InventoryConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies the inventory configuration for an Amazon S3 bucket. For more information, see
///             <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketGETInventoryConfig.html">GET Bucket inventory</a> in the <i>Amazon S3 API Reference</i>.
///       </p>
public struct InventoryConfiguration: Equatable {
    /// <p>Contains information about where to publish the inventory results.</p>
    public let destination: InventoryDestination?
    /// <p>Specifies an inventory filter. The inventory only includes objects that meet the
    ///          filter's criteria.</p>
    public let filter: InventoryFilter?
    /// <p>The ID used to identify the inventory configuration.</p>
    public let id: String?
    /// <p>Object versions to include in the inventory list. If set to <code>All</code>, the list
    ///          includes all the object versions, which adds the version-related fields
    ///             <code>VersionId</code>, <code>IsLatest</code>, and <code>DeleteMarker</code> to the
    ///          list. If set to <code>Current</code>, the list does not contain these version-related
    ///          fields.</p>
    public let includedObjectVersions: InventoryIncludedObjectVersions?
    /// <p>Specifies whether the inventory is enabled or disabled. If set to <code>True</code>, an
    ///          inventory list is generated. If set to <code>False</code>, no inventory list is
    ///          generated.</p>
    public let isEnabled: Bool
    /// <p>Contains the optional fields that are included in the inventory results.</p>
    public let optionalFields: [InventoryOptionalField]?
    /// <p>Specifies the schedule for generating inventory results.</p>
    public let schedule: InventorySchedule?

    public init (
        destination: InventoryDestination? = nil,
        filter: InventoryFilter? = nil,
        id: String? = nil,
        includedObjectVersions: InventoryIncludedObjectVersions? = nil,
        isEnabled: Bool = false,
        optionalFields: [InventoryOptionalField]? = nil,
        schedule: InventorySchedule? = nil
    )
    {
        self.destination = destination
        self.filter = filter
        self.id = id
        self.includedObjectVersions = includedObjectVersions
        self.isEnabled = isEnabled
        self.optionalFields = optionalFields
        self.schedule = schedule
    }
}

extension InventoryDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3BucketDestination = "S3BucketDestination"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let s3BucketDestination = s3BucketDestination {
            try container.encode(s3BucketDestination, forKey: Key("s3BucketDestination"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDestinationDecoded = try containerValues.decodeIfPresent(InventoryS3BucketDestination.self, forKey: .s3BucketDestination)
        s3BucketDestination = s3BucketDestinationDecoded
    }
}

extension InventoryDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InventoryDestination(s3BucketDestination: \(String(describing: s3BucketDestination)))"}
}

extension InventoryDestination: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies the inventory configuration for an Amazon S3 bucket.</p>
public struct InventoryDestination: Equatable {
    /// <p>Contains the bucket name, file format, bucket owner (optional), and prefix (optional)
    ///          where inventory results are published.</p>
    public let s3BucketDestination: InventoryS3BucketDestination?

    public init (
        s3BucketDestination: InventoryS3BucketDestination? = nil
    )
    {
        self.s3BucketDestination = s3BucketDestination
    }
}

extension InventoryEncryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sSEKMS = "SSE-KMS"
        case sSES3 = "SSE-S3"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let sSEKMS = sSEKMS {
            try container.encode(sSEKMS, forKey: Key("SSE-KMS"))
        }
        if let sSES3 = sSES3 {
            try container.encode(sSES3, forKey: Key("SSE-S3"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sSES3Decoded = try containerValues.decodeIfPresent(SSES3.self, forKey: .sSES3)
        sSES3 = sSES3Decoded
        let sSEKMSDecoded = try containerValues.decodeIfPresent(SSEKMS.self, forKey: .sSEKMS)
        sSEKMS = sSEKMSDecoded
    }
}

extension InventoryEncryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InventoryEncryption(sSEKMS: \(String(describing: sSEKMS)), sSES3: \(String(describing: sSES3)))"}
}

extension InventoryEncryption: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains the type of server-side encryption used to encrypt the inventory
///          results.</p>
public struct InventoryEncryption: Equatable {
    /// <p>Specifies the use of SSE-KMS to encrypt delivered inventory reports.</p>
    public let sSEKMS: SSEKMS?
    /// <p>Specifies the use of SSE-S3 to encrypt delivered inventory reports.</p>
    public let sSES3: SSES3?

    public init (
        sSEKMS: SSEKMS? = nil,
        sSES3: SSES3? = nil
    )
    {
        self.sSEKMS = sSEKMS
        self.sSES3 = sSES3
    }
}

extension InventoryFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case prefix = "Prefix"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let prefix = prefix {
            try container.encode(prefix, forKey: Key("prefix"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension InventoryFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InventoryFilter(prefix: \(String(describing: prefix)))"}
}

extension InventoryFilter: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies an inventory filter. The inventory only includes objects that meet the
///          filter's criteria.</p>
public struct InventoryFilter: Equatable {
    /// <p>The prefix that an object must have to be included in the inventory results.</p>
    public let prefix: String?

    public init (
        prefix: String? = nil
    )
    {
        self.prefix = prefix
    }
}

public enum InventoryFormat {
    case csv
    case orc
    case parquet
    case sdkUnknown(String)
}

extension InventoryFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InventoryFormat] {
        return [
            .csv,
            .orc,
            .parquet,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csv: return "CSV"
        case .orc: return "ORC"
        case .parquet: return "Parquet"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InventoryFormat(rawValue: rawValue) ?? InventoryFormat.sdkUnknown(rawValue)
    }
}

public enum InventoryFrequency {
    case daily
    case weekly
    case sdkUnknown(String)
}

extension InventoryFrequency : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InventoryFrequency] {
        return [
            .daily,
            .weekly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .daily: return "Daily"
        case .weekly: return "Weekly"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InventoryFrequency(rawValue: rawValue) ?? InventoryFrequency.sdkUnknown(rawValue)
    }
}

public enum InventoryIncludedObjectVersions {
    case all
    case current
    case sdkUnknown(String)
}

extension InventoryIncludedObjectVersions : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InventoryIncludedObjectVersions] {
        return [
            .all,
            .current,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "All"
        case .current: return "Current"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InventoryIncludedObjectVersions(rawValue: rawValue) ?? InventoryIncludedObjectVersions.sdkUnknown(rawValue)
    }
}

public enum InventoryOptionalField {
    case bucketkeystatus
    case etag
    case encryptionstatus
    case intelligenttieringaccesstier
    case ismultipartuploaded
    case lastmodifieddate
    case objectlocklegalholdstatus
    case objectlockmode
    case objectlockretainuntildate
    case replicationstatus
    case size
    case storageclass
    case sdkUnknown(String)
}

extension InventoryOptionalField : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InventoryOptionalField] {
        return [
            .bucketkeystatus,
            .etag,
            .encryptionstatus,
            .intelligenttieringaccesstier,
            .ismultipartuploaded,
            .lastmodifieddate,
            .objectlocklegalholdstatus,
            .objectlockmode,
            .objectlockretainuntildate,
            .replicationstatus,
            .size,
            .storageclass,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bucketkeystatus: return "BucketKeyStatus"
        case .etag: return "ETag"
        case .encryptionstatus: return "EncryptionStatus"
        case .intelligenttieringaccesstier: return "IntelligentTieringAccessTier"
        case .ismultipartuploaded: return "IsMultipartUploaded"
        case .lastmodifieddate: return "LastModifiedDate"
        case .objectlocklegalholdstatus: return "ObjectLockLegalHoldStatus"
        case .objectlockmode: return "ObjectLockMode"
        case .objectlockretainuntildate: return "ObjectLockRetainUntilDate"
        case .replicationstatus: return "ReplicationStatus"
        case .size: return "Size"
        case .storageclass: return "StorageClass"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InventoryOptionalField(rawValue: rawValue) ?? InventoryOptionalField.sdkUnknown(rawValue)
    }
}

extension InventoryS3BucketDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case bucket = "Bucket"
        case encryption = "Encryption"
        case format = "Format"
        case prefix = "Prefix"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let accountId = accountId {
            try container.encode(accountId, forKey: Key("accountId"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: Key("bucket"))
        }
        if let encryption = encryption {
            try container.encode(encryption, forKey: Key("encryption"))
        }
        if let format = format {
            try container.encode(format, forKey: Key("format"))
        }
        if let prefix = prefix {
            try container.encode(prefix, forKey: Key("prefix"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let formatDecoded = try containerValues.decodeIfPresent(InventoryFormat.self, forKey: .format)
        format = formatDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(InventoryEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
    }
}

extension InventoryS3BucketDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InventoryS3BucketDestination(accountId: \(String(describing: accountId)), bucket: \(String(describing: bucket)), encryption: \(String(describing: encryption)), format: \(String(describing: format)), prefix: \(String(describing: prefix)))"}
}

extension InventoryS3BucketDestination: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains the bucket name, file format, bucket owner (optional), and prefix (optional)
///          where inventory results are published.</p>
public struct InventoryS3BucketDestination: Equatable {
    /// <p>The account ID that owns the destination S3 bucket. If no account ID is provided, the
    ///          owner is not validated before exporting data. </p>
    ///          <note>
    ///             <p> Although this value is optional, we strongly recommend that you set it to help
    ///             prevent problems if the destination bucket ownership changes. </p>
    ///          </note>
    public let accountId: String?
    /// <p>The Amazon Resource Name (ARN) of the bucket where inventory results will be
    ///          published.</p>
    public let bucket: String?
    /// <p>Contains the type of server-side encryption used to encrypt the inventory
    ///          results.</p>
    public let encryption: InventoryEncryption?
    /// <p>Specifies the output format of the inventory results.</p>
    public let format: InventoryFormat?
    /// <p>The prefix that is prepended to all inventory results.</p>
    public let prefix: String?

    public init (
        accountId: String? = nil,
        bucket: String? = nil,
        encryption: InventoryEncryption? = nil,
        format: InventoryFormat? = nil,
        prefix: String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.encryption = encryption
        self.format = format
        self.prefix = prefix
    }
}

extension InventorySchedule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case frequency = "Frequency"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let frequency = frequency {
            try container.encode(frequency, forKey: Key("frequency"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frequencyDecoded = try containerValues.decodeIfPresent(InventoryFrequency.self, forKey: .frequency)
        frequency = frequencyDecoded
    }
}

extension InventorySchedule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InventorySchedule(frequency: \(String(describing: frequency)))"}
}

extension InventorySchedule: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies the schedule for generating inventory results.</p>
public struct InventorySchedule: Equatable {
    /// <p>Specifies how frequently inventory results are produced.</p>
    public let frequency: InventoryFrequency?

    public init (
        frequency: InventoryFrequency? = nil
    )
    {
        self.frequency = frequency
    }
}

extension JSONInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let type = type {
            try container.encode(type, forKey: Key("type"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(JSONType.self, forKey: .type)
        type = typeDecoded
    }
}

extension JSONInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JSONInput(type: \(String(describing: type)))"}
}

extension JSONInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies JSON as object's input serialization format.</p>
public struct JSONInput: Equatable {
    /// <p>The type of JSON. Valid values: Document, Lines.</p>
    public let type: JSONType?

    public init (
        type: JSONType? = nil
    )
    {
        self.type = type
    }
}

extension JSONOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recordDelimiter = "RecordDelimiter"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let recordDelimiter = recordDelimiter {
            try container.encode(recordDelimiter, forKey: Key("recordDelimiter"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDelimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recordDelimiter)
        recordDelimiter = recordDelimiterDecoded
    }
}

extension JSONOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JSONOutput(recordDelimiter: \(String(describing: recordDelimiter)))"}
}

extension JSONOutput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies JSON as request's output serialization format.</p>
public struct JSONOutput: Equatable {
    /// <p>The value used to separate individual records in the output. If no value is specified,
    ///          Amazon S3 uses a newline character ('\n').</p>
    public let recordDelimiter: String?

    public init (
        recordDelimiter: String? = nil
    )
    {
        self.recordDelimiter = recordDelimiter
    }
}

public enum JSONType {
    case document
    case lines
    case sdkUnknown(String)
}

extension JSONType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JSONType] {
        return [
            .document,
            .lines,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .document: return "DOCUMENT"
        case .lines: return "LINES"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JSONType(rawValue: rawValue) ?? JSONType.sdkUnknown(rawValue)
    }
}

extension LambdaFunctionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case events = "Event"
        case filter = "Filter"
        case id = "Id"
        case lambdaFunctionArn = "CloudFunction"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let events = events {
            if events.isEmpty {
                var eventsContainer = container.nestedUnkeyedContainer(forKey: Key("Event"))
                try eventsContainer.encodeNil()
            } else {
                for event0 in events {
                    var eventsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Event"))
                    try eventsContainer0.encode(event0, forKey: Key(""))
                }
            }
        }
        if let filter = filter {
            try container.encode(filter, forKey: Key("filter"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let lambdaFunctionArn = lambdaFunctionArn {
            try container.encode(lambdaFunctionArn, forKey: Key("CloudFunction"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lambdaFunctionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lambdaFunctionArn)
        lambdaFunctionArn = lambdaFunctionArnDecoded
        if containerValues.contains(.events) {
            let eventsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .events)
            if eventsWrappedContainer != nil {
                let eventsContainer = try containerValues.decodeIfPresent([Event].self, forKey: .events)
                var eventsBuffer:[Event]? = nil
                if let eventsContainer = eventsContainer {
                    eventsBuffer = [Event]()
                    for stringContainer0 in eventsContainer {
                        eventsBuffer?.append(stringContainer0)
                    }
                }
                events = eventsBuffer
            } else {
                events = []
            }
        } else {
            events = nil
        }
        let filterDecoded = try containerValues.decodeIfPresent(NotificationConfigurationFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension LambdaFunctionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaFunctionConfiguration(events: \(String(describing: events)), filter: \(String(describing: filter)), id: \(String(describing: id)), lambdaFunctionArn: \(String(describing: lambdaFunctionArn)))"}
}

extension LambdaFunctionConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container for specifying the configuration for AWS Lambda notifications.</p>
public struct LambdaFunctionConfiguration: Equatable {
    /// <p>The Amazon S3 bucket event for which to invoke the AWS Lambda function. For more information,
    ///          see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html">Supported
    ///             Event Types</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let events: [Event]?
    /// <p>Specifies object key name filtering rules. For information about key name filtering, see
    ///             <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html">Configuring
    ///             Event Notifications</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let filter: NotificationConfigurationFilter?
    /// <p>An optional unique identifier for configurations in a notification configuration. If you
    ///          don't provide one, Amazon S3 will assign an ID.</p>
    public let id: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Lambda function that Amazon S3 invokes when the
    ///          specified event type occurs.</p>
    public let lambdaFunctionArn: String?

    public init (
        events: [Event]? = nil,
        filter: NotificationConfigurationFilter? = nil,
        id: String? = nil,
        lambdaFunctionArn: String? = nil
    )
    {
        self.events = events
        self.filter = filter
        self.id = id
        self.lambdaFunctionArn = lambdaFunctionArn
    }
}

extension LifecycleExpiration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case date = "Date"
        case days = "Days"
        case expiredObjectDeleteMarker = "ExpiredObjectDeleteMarker"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let date = date {
            try container.encode(TimestampWrapper(date, format: .dateTime), forKey: Key("date"))
        }
        if days != 0 {
            try container.encode(days, forKey: Key("days"))
        }
        if expiredObjectDeleteMarker != false {
            try container.encode(expiredObjectDeleteMarker, forKey: Key("expiredObjectDeleteMarker"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .date)
        var dateBuffer:Date? = nil
        if let dateDecoded = dateDecoded {
            dateBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateDecoded, format: .dateTime)
        }
        date = dateBuffer
        let daysDecoded = try containerValues.decode(Int.self, forKey: .days)
        days = daysDecoded
        let expiredObjectDeleteMarkerDecoded = try containerValues.decode(Bool.self, forKey: .expiredObjectDeleteMarker)
        expiredObjectDeleteMarker = expiredObjectDeleteMarkerDecoded
    }
}

extension LifecycleExpiration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifecycleExpiration(date: \(String(describing: date)), days: \(String(describing: days)), expiredObjectDeleteMarker: \(String(describing: expiredObjectDeleteMarker)))"}
}

extension LifecycleExpiration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container for the expiration for the lifecycle of the object.</p>
public struct LifecycleExpiration: Equatable {
    /// <p>Indicates at what date the object is to be moved or deleted. Should be in GMT ISO 8601
    ///          Format.</p>
    public let date: Date?
    /// <p>Indicates the lifetime, in days, of the objects that are subject to the rule. The value
    ///          must be a non-zero positive integer.</p>
    public let days: Int
    /// <p>Indicates whether Amazon S3 will remove a delete marker with no noncurrent versions. If set
    ///          to true, the delete marker will be expired; if set to false the policy takes no action.
    ///          This cannot be specified with Days or Date in a Lifecycle Expiration Policy.</p>
    public let expiredObjectDeleteMarker: Bool

    public init (
        date: Date? = nil,
        days: Int = 0,
        expiredObjectDeleteMarker: Bool = false
    )
    {
        self.date = date
        self.days = days
        self.expiredObjectDeleteMarker = expiredObjectDeleteMarker
    }
}

extension LifecycleRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case abortIncompleteMultipartUpload = "AbortIncompleteMultipartUpload"
        case expiration = "Expiration"
        case filter = "Filter"
        case iD = "ID"
        case noncurrentVersionExpiration = "NoncurrentVersionExpiration"
        case noncurrentVersionTransitions = "NoncurrentVersionTransition"
        case prefix = "Prefix"
        case status = "Status"
        case transitions = "Transition"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let abortIncompleteMultipartUpload = abortIncompleteMultipartUpload {
            try container.encode(abortIncompleteMultipartUpload, forKey: Key("abortIncompleteMultipartUpload"))
        }
        if let expiration = expiration {
            try container.encode(expiration, forKey: Key("expiration"))
        }
        if let filter = filter {
            try container.encode(filter, forKey: Key("filter"))
        }
        if let iD = iD {
            try container.encode(iD, forKey: Key("iD"))
        }
        if let noncurrentVersionExpiration = noncurrentVersionExpiration {
            try container.encode(noncurrentVersionExpiration, forKey: Key("noncurrentVersionExpiration"))
        }
        if let noncurrentVersionTransitions = noncurrentVersionTransitions {
            if noncurrentVersionTransitions.isEmpty {
                var noncurrentVersionTransitionsContainer = container.nestedUnkeyedContainer(forKey: Key("NoncurrentVersionTransition"))
                try noncurrentVersionTransitionsContainer.encodeNil()
            } else {
                for noncurrentversiontransition0 in noncurrentVersionTransitions {
                    var noncurrentVersionTransitionsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("NoncurrentVersionTransition"))
                    try noncurrentVersionTransitionsContainer0.encode(noncurrentversiontransition0, forKey: Key(""))
                }
            }
        }
        if let prefix = prefix {
            try container.encode(prefix, forKey: Key("prefix"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
        if let transitions = transitions {
            if transitions.isEmpty {
                var transitionsContainer = container.nestedUnkeyedContainer(forKey: Key("Transition"))
                try transitionsContainer.encodeNil()
            } else {
                for transition0 in transitions {
                    var transitionsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Transition"))
                    try transitionsContainer0.encode(transition0, forKey: Key(""))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expirationDecoded = try containerValues.decodeIfPresent(LifecycleExpiration.self, forKey: .expiration)
        expiration = expirationDecoded
        let iDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iD)
        iD = iDDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        let filterDecoded = try containerValues.decodeIfPresent(LifecycleRuleFilter.self, forKey: .filter)
        filter = filterDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ExpirationStatus.self, forKey: .status)
        status = statusDecoded
        if containerValues.contains(.transitions) {
            let transitionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .transitions)
            if transitionsWrappedContainer != nil {
                let transitionsContainer = try containerValues.decodeIfPresent([Transition].self, forKey: .transitions)
                var transitionsBuffer:[Transition]? = nil
                if let transitionsContainer = transitionsContainer {
                    transitionsBuffer = [Transition]()
                    for structureContainer0 in transitionsContainer {
                        transitionsBuffer?.append(structureContainer0)
                    }
                }
                transitions = transitionsBuffer
            } else {
                transitions = []
            }
        } else {
            transitions = nil
        }
        if containerValues.contains(.noncurrentVersionTransitions) {
            let noncurrentVersionTransitionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .noncurrentVersionTransitions)
            if noncurrentVersionTransitionsWrappedContainer != nil {
                let noncurrentVersionTransitionsContainer = try containerValues.decodeIfPresent([NoncurrentVersionTransition].self, forKey: .noncurrentVersionTransitions)
                var noncurrentVersionTransitionsBuffer:[NoncurrentVersionTransition]? = nil
                if let noncurrentVersionTransitionsContainer = noncurrentVersionTransitionsContainer {
                    noncurrentVersionTransitionsBuffer = [NoncurrentVersionTransition]()
                    for structureContainer0 in noncurrentVersionTransitionsContainer {
                        noncurrentVersionTransitionsBuffer?.append(structureContainer0)
                    }
                }
                noncurrentVersionTransitions = noncurrentVersionTransitionsBuffer
            } else {
                noncurrentVersionTransitions = []
            }
        } else {
            noncurrentVersionTransitions = nil
        }
        let noncurrentVersionExpirationDecoded = try containerValues.decodeIfPresent(NoncurrentVersionExpiration.self, forKey: .noncurrentVersionExpiration)
        noncurrentVersionExpiration = noncurrentVersionExpirationDecoded
        let abortIncompleteMultipartUploadDecoded = try containerValues.decodeIfPresent(AbortIncompleteMultipartUpload.self, forKey: .abortIncompleteMultipartUpload)
        abortIncompleteMultipartUpload = abortIncompleteMultipartUploadDecoded
    }
}

extension LifecycleRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifecycleRule(abortIncompleteMultipartUpload: \(String(describing: abortIncompleteMultipartUpload)), expiration: \(String(describing: expiration)), filter: \(String(describing: filter)), iD: \(String(describing: iD)), noncurrentVersionExpiration: \(String(describing: noncurrentVersionExpiration)), noncurrentVersionTransitions: \(String(describing: noncurrentVersionTransitions)), prefix: \(String(describing: prefix)), status: \(String(describing: status)), transitions: \(String(describing: transitions)))"}
}

extension LifecycleRule: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A lifecycle rule for individual objects in an Amazon S3 bucket.</p>
public struct LifecycleRule: Equatable {
    /// <p>Specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will
    ///          wait before permanently removing all parts of the upload. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config">
    ///             Aborting Incomplete Multipart Uploads Using a Bucket Lifecycle Policy</a> in the
    ///             <i>Amazon S3 User Guide</i>.</p>
    public let abortIncompleteMultipartUpload: AbortIncompleteMultipartUpload?
    /// <p>Specifies the expiration for the lifecycle of the object in the form of date, days and,
    ///          whether the object has a delete marker.</p>
    public let expiration: LifecycleExpiration?
    /// <p>The <code>Filter</code> is used to identify objects that a Lifecycle Rule applies to. A
    ///          <code>Filter</code> must have exactly one of <code>Prefix</code>, <code>Tag</code>, or
    ///          <code>And</code> specified. <code>Filter</code> is required if the <code>LifecycleRule</code>
    ///          does not containt a <code>Prefix</code> element.</p>
    public let filter: LifecycleRuleFilter?
    /// <p>Unique identifier for the rule. The value cannot be longer than 255 characters.</p>
    public let iD: String?
    /// <p>Specifies when noncurrent object versions expire. Upon expiration, Amazon S3 permanently
    ///          deletes the noncurrent object versions. You set this lifecycle configuration action on a
    ///          bucket that has versioning enabled (or suspended) to request that Amazon S3 delete noncurrent
    ///          object versions at a specific period in the object's lifetime.</p>
    public let noncurrentVersionExpiration: NoncurrentVersionExpiration?
    /// <p> Specifies the transition rule for the lifecycle rule that describes when noncurrent
    ///          objects transition to a specific storage class. If your bucket is versioning-enabled (or
    ///          versioning is suspended), you can set this action to request that Amazon S3 transition
    ///          noncurrent object versions to a specific storage class at a set period in the object's
    ///          lifetime. </p>
    public let noncurrentVersionTransitions: [NoncurrentVersionTransition]?
    /// <p>Prefix identifying one or more objects to which the rule applies. This is
    ///          no longer used; use <code>Filter</code> instead.</p>
    ///          <important>
    ///             <p>Replacement must be made for object keys containing special characters (such as carriage returns) when using
    ///          XML requests. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints">
    ///             XML related object key constraints</a>.</p>
    ///          </important>
    @available(*, deprecated)
    public let prefix: String?
    /// <p>If 'Enabled', the rule is currently being applied. If 'Disabled', the rule is not
    ///          currently being applied.</p>
    public let status: ExpirationStatus?
    /// <p>Specifies when an Amazon S3 object transitions to a specified storage class.</p>
    public let transitions: [Transition]?

    public init (
        abortIncompleteMultipartUpload: AbortIncompleteMultipartUpload? = nil,
        expiration: LifecycleExpiration? = nil,
        filter: LifecycleRuleFilter? = nil,
        iD: String? = nil,
        noncurrentVersionExpiration: NoncurrentVersionExpiration? = nil,
        noncurrentVersionTransitions: [NoncurrentVersionTransition]? = nil,
        prefix: String? = nil,
        status: ExpirationStatus? = nil,
        transitions: [Transition]? = nil
    )
    {
        self.abortIncompleteMultipartUpload = abortIncompleteMultipartUpload
        self.expiration = expiration
        self.filter = filter
        self.iD = iD
        self.noncurrentVersionExpiration = noncurrentVersionExpiration
        self.noncurrentVersionTransitions = noncurrentVersionTransitions
        self.prefix = prefix
        self.status = status
        self.transitions = transitions
    }
}

extension LifecycleRuleAndOperator: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case prefix = "Prefix"
        case tags = "Tag"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let prefix = prefix {
            try container.encode(prefix, forKey: Key("prefix"))
        }
        if let tags = tags {
            if tags.isEmpty {
                var tagsContainer = container.nestedUnkeyedContainer(forKey: Key("Tag"))
                try tagsContainer.encodeNil()
            } else {
                for tag0 in tags {
                    var tagsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tag"))
                    try tagsContainer0.encode(tag0, forKey: Key(""))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        if containerValues.contains(.tags) {
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .tags)
            if tagsWrappedContainer != nil {
                let tagsContainer = try containerValues.decodeIfPresent([Tag].self, forKey: .tags)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension LifecycleRuleAndOperator: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifecycleRuleAndOperator(prefix: \(String(describing: prefix)), tags: \(String(describing: tags)))"}
}

extension LifecycleRuleAndOperator: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>This is used in a Lifecycle Rule Filter to apply a logical AND to two or more
///          predicates. The Lifecycle Rule will apply to any object matching all of the predicates
///          configured inside the And operator.</p>
public struct LifecycleRuleAndOperator: Equatable {
    /// <p>Prefix identifying one or more objects to which the rule applies.</p>
    public let prefix: String?
    /// <p>All of these tags must exist in the object's tag set in order for the rule to
    ///          apply.</p>
    public let tags: [Tag]?

    public init (
        prefix: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.prefix = prefix
        self.tags = tags
    }
}

extension LifecycleRuleFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case and = "And"
        case prefix = "Prefix"
        case tag = "Tag"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        switch self {
            case let .and(and):
                if let and = and {
                    try container.encode(and, forKey: Key("and"))
                }
            case let .prefix(prefix):
                if let prefix = prefix {
                    try container.encode(prefix, forKey: Key("prefix"))
                }
            case let .tag(tag):
                if let tag = tag {
                    try container.encode(tag, forKey: Key("tag"))
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: Key("sdkUnknown"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        if let prefix = prefixDecoded {
            self = .prefix(prefix)
            return
        }
        let tagDecoded = try containerValues.decodeIfPresent(Tag.self, forKey: .tag)
        if let tag = tagDecoded {
            self = .tag(tag)
            return
        }
        let andDecoded = try containerValues.decodeIfPresent(LifecycleRuleAndOperator.self, forKey: .and)
        if let and = andDecoded {
            self = .and(and)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>The <code>Filter</code> is used to identify objects that a Lifecycle Rule applies to. A
///             <code>Filter</code> must have exactly one of <code>Prefix</code>, <code>Tag</code>, or
///             <code>And</code> specified.</p>
public enum LifecycleRuleFilter: Equatable {
    /// <p>Prefix identifying one or more objects to which the rule applies.</p>
    ///          <important>
    ///             <p>Replacement must be made for object keys containing special characters (such as carriage returns) when using
    ///          XML requests. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints">
    ///             XML related object key constraints</a>.</p>
    ///          </important>
    case prefix(String?)
    /// <p>This tag must exist in the object's tag set in order for the rule to apply.</p>
    case tag(Tag?)
    /// <p>This is used in a Lifecycle Rule Filter to apply a logical AND to two or more
    ///          predicates. The Lifecycle Rule will apply to any object matching all of the predicates
    ///          configured inside the And operator.</p>
    case and(LifecycleRuleAndOperator?)
    case sdkUnknown(String?)
}

extension ListBucketAnalyticsConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBucketAnalyticsConfigurationsInput(bucket: \(String(describing: bucket)), continuationToken: \(String(describing: continuationToken)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension ListBucketAnalyticsConfigurationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListBucketAnalyticsConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListBucketAnalyticsConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBucketAnalyticsConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBucketAnalyticsConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBucketAnalyticsConfigurationsInput>
    public typealias MOutput = OperationOutput<ListBucketAnalyticsConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBucketAnalyticsConfigurationsOutputError>
}

public struct ListBucketAnalyticsConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBucketAnalyticsConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBucketAnalyticsConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBucketAnalyticsConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "analytics", value: nil))
        input.builder.withQueryItem(URLQueryItem(name: "x-id", value: "ListBucketAnalyticsConfigurations"))
        if let continuationToken = input.operationInput.continuationToken {
            let continuationTokenQueryItem = URLQueryItem(name: "continuation-token".urlPercentEncoding(), value: String(continuationToken).urlPercentEncoding())
            input.builder.withQueryItem(continuationTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBucketAnalyticsConfigurationsInput>
    public typealias MOutput = OperationOutput<ListBucketAnalyticsConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBucketAnalyticsConfigurationsOutputError>
}

public struct ListBucketAnalyticsConfigurationsInput: Equatable {
    /// <p>The name of the bucket from which analytics configurations are retrieved.</p>
    public let bucket: String?
    /// <p>The ContinuationToken that represents a placeholder from where this request should
    ///          begin.</p>
    public let continuationToken: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        continuationToken: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.continuationToken = continuationToken
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct ListBucketAnalyticsConfigurationsInputBody: Equatable {
}

extension ListBucketAnalyticsConfigurationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListBucketAnalyticsConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListBucketAnalyticsConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBucketAnalyticsConfigurationsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBucketAnalyticsConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBucketAnalyticsConfigurationsOutputResponse(analyticsConfigurationList: \(String(describing: analyticsConfigurationList)), continuationToken: \(String(describing: continuationToken)), isTruncated: \(String(describing: isTruncated)), nextContinuationToken: \(String(describing: nextContinuationToken)))"}
}

extension ListBucketAnalyticsConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBucketAnalyticsConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.analyticsConfigurationList = output.analyticsConfigurationList
            self.continuationToken = output.continuationToken
            self.isTruncated = output.isTruncated
            self.nextContinuationToken = output.nextContinuationToken
        } else {
            self.analyticsConfigurationList = nil
            self.continuationToken = nil
            self.isTruncated = false
            self.nextContinuationToken = nil
        }
    }
}

public struct ListBucketAnalyticsConfigurationsOutputResponse: Equatable {
    /// <p>The list of analytics configurations for a bucket.</p>
    public let analyticsConfigurationList: [AnalyticsConfiguration]?
    /// <p>The marker that is used as a starting point for this analytics configuration list
    ///          response. This value is present if it was sent in the request.</p>
    public let continuationToken: String?
    /// <p>Indicates whether the returned list of analytics configurations is complete. A value of
    ///          true indicates that the list is not complete and the NextContinuationToken will be provided
    ///          for a subsequent request.</p>
    public let isTruncated: Bool
    /// <p>
    ///             <code>NextContinuationToken</code> is sent when <code>isTruncated</code> is true, which
    ///          indicates that there are more analytics configurations to list. The next request must
    ///          include this <code>NextContinuationToken</code>. The token is obfuscated and is not a
    ///          usable value.</p>
    public let nextContinuationToken: String?

    public init (
        analyticsConfigurationList: [AnalyticsConfiguration]? = nil,
        continuationToken: String? = nil,
        isTruncated: Bool = false,
        nextContinuationToken: String? = nil
    )
    {
        self.analyticsConfigurationList = analyticsConfigurationList
        self.continuationToken = continuationToken
        self.isTruncated = isTruncated
        self.nextContinuationToken = nextContinuationToken
    }
}

struct ListBucketAnalyticsConfigurationsOutputResponseBody: Equatable {
    public let isTruncated: Bool
    public let continuationToken: String?
    public let nextContinuationToken: String?
    public let analyticsConfigurationList: [AnalyticsConfiguration]?
}

extension ListBucketAnalyticsConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyticsConfigurationList = "AnalyticsConfiguration"
        case continuationToken = "ContinuationToken"
        case isTruncated = "IsTruncated"
        case nextContinuationToken = "NextContinuationToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let continuationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .continuationToken)
        continuationToken = continuationTokenDecoded
        let nextContinuationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextContinuationToken)
        nextContinuationToken = nextContinuationTokenDecoded
        if containerValues.contains(.analyticsConfigurationList) {
            let analyticsConfigurationListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .analyticsConfigurationList)
            if analyticsConfigurationListWrappedContainer != nil {
                let analyticsConfigurationListContainer = try containerValues.decodeIfPresent([AnalyticsConfiguration].self, forKey: .analyticsConfigurationList)
                var analyticsConfigurationListBuffer:[AnalyticsConfiguration]? = nil
                if let analyticsConfigurationListContainer = analyticsConfigurationListContainer {
                    analyticsConfigurationListBuffer = [AnalyticsConfiguration]()
                    for structureContainer0 in analyticsConfigurationListContainer {
                        analyticsConfigurationListBuffer?.append(structureContainer0)
                    }
                }
                analyticsConfigurationList = analyticsConfigurationListBuffer
            } else {
                analyticsConfigurationList = []
            }
        } else {
            analyticsConfigurationList = nil
        }
    }
}

extension ListBucketIntelligentTieringConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBucketIntelligentTieringConfigurationsInput(bucket: \(String(describing: bucket)), continuationToken: \(String(describing: continuationToken)))"}
}

extension ListBucketIntelligentTieringConfigurationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListBucketIntelligentTieringConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListBucketIntelligentTieringConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBucketIntelligentTieringConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBucketIntelligentTieringConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBucketIntelligentTieringConfigurationsInput>
    public typealias MOutput = OperationOutput<ListBucketIntelligentTieringConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBucketIntelligentTieringConfigurationsOutputError>
}

public struct ListBucketIntelligentTieringConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBucketIntelligentTieringConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBucketIntelligentTieringConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBucketIntelligentTieringConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "intelligent-tiering", value: nil))
        input.builder.withQueryItem(URLQueryItem(name: "x-id", value: "ListBucketIntelligentTieringConfigurations"))
        if let continuationToken = input.operationInput.continuationToken {
            let continuationTokenQueryItem = URLQueryItem(name: "continuation-token".urlPercentEncoding(), value: String(continuationToken).urlPercentEncoding())
            input.builder.withQueryItem(continuationTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBucketIntelligentTieringConfigurationsInput>
    public typealias MOutput = OperationOutput<ListBucketIntelligentTieringConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBucketIntelligentTieringConfigurationsOutputError>
}

public struct ListBucketIntelligentTieringConfigurationsInput: Equatable {
    /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
    public let bucket: String?
    /// <p>The ContinuationToken that represents a placeholder from where this request should
    ///          begin.</p>
    public let continuationToken: String?

    public init (
        bucket: String? = nil,
        continuationToken: String? = nil
    )
    {
        self.bucket = bucket
        self.continuationToken = continuationToken
    }
}

struct ListBucketIntelligentTieringConfigurationsInputBody: Equatable {
}

extension ListBucketIntelligentTieringConfigurationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListBucketIntelligentTieringConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListBucketIntelligentTieringConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBucketIntelligentTieringConfigurationsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBucketIntelligentTieringConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBucketIntelligentTieringConfigurationsOutputResponse(continuationToken: \(String(describing: continuationToken)), intelligentTieringConfigurationList: \(String(describing: intelligentTieringConfigurationList)), isTruncated: \(String(describing: isTruncated)), nextContinuationToken: \(String(describing: nextContinuationToken)))"}
}

extension ListBucketIntelligentTieringConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBucketIntelligentTieringConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.continuationToken = output.continuationToken
            self.intelligentTieringConfigurationList = output.intelligentTieringConfigurationList
            self.isTruncated = output.isTruncated
            self.nextContinuationToken = output.nextContinuationToken
        } else {
            self.continuationToken = nil
            self.intelligentTieringConfigurationList = nil
            self.isTruncated = false
            self.nextContinuationToken = nil
        }
    }
}

public struct ListBucketIntelligentTieringConfigurationsOutputResponse: Equatable {
    /// <p>The ContinuationToken that represents a placeholder from where this request should
    ///          begin.</p>
    public let continuationToken: String?
    /// <p>The list of S3 Intelligent-Tiering configurations for a bucket.</p>
    public let intelligentTieringConfigurationList: [IntelligentTieringConfiguration]?
    /// <p>Indicates whether the returned list of analytics configurations is complete. A value of
    ///          true indicates that the list is not complete and the NextContinuationToken will be provided
    ///          for a subsequent request.</p>
    public let isTruncated: Bool
    /// <p>The marker used to continue this inventory configuration listing. Use the
    ///             <code>NextContinuationToken</code> from this response to continue the listing in a
    ///          subsequent request. The continuation token is an opaque value that Amazon S3 understands.</p>
    public let nextContinuationToken: String?

    public init (
        continuationToken: String? = nil,
        intelligentTieringConfigurationList: [IntelligentTieringConfiguration]? = nil,
        isTruncated: Bool = false,
        nextContinuationToken: String? = nil
    )
    {
        self.continuationToken = continuationToken
        self.intelligentTieringConfigurationList = intelligentTieringConfigurationList
        self.isTruncated = isTruncated
        self.nextContinuationToken = nextContinuationToken
    }
}

struct ListBucketIntelligentTieringConfigurationsOutputResponseBody: Equatable {
    public let isTruncated: Bool
    public let continuationToken: String?
    public let nextContinuationToken: String?
    public let intelligentTieringConfigurationList: [IntelligentTieringConfiguration]?
}

extension ListBucketIntelligentTieringConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case continuationToken = "ContinuationToken"
        case intelligentTieringConfigurationList = "IntelligentTieringConfiguration"
        case isTruncated = "IsTruncated"
        case nextContinuationToken = "NextContinuationToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let continuationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .continuationToken)
        continuationToken = continuationTokenDecoded
        let nextContinuationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextContinuationToken)
        nextContinuationToken = nextContinuationTokenDecoded
        if containerValues.contains(.intelligentTieringConfigurationList) {
            let intelligentTieringConfigurationListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .intelligentTieringConfigurationList)
            if intelligentTieringConfigurationListWrappedContainer != nil {
                let intelligentTieringConfigurationListContainer = try containerValues.decodeIfPresent([IntelligentTieringConfiguration].self, forKey: .intelligentTieringConfigurationList)
                var intelligentTieringConfigurationListBuffer:[IntelligentTieringConfiguration]? = nil
                if let intelligentTieringConfigurationListContainer = intelligentTieringConfigurationListContainer {
                    intelligentTieringConfigurationListBuffer = [IntelligentTieringConfiguration]()
                    for structureContainer0 in intelligentTieringConfigurationListContainer {
                        intelligentTieringConfigurationListBuffer?.append(structureContainer0)
                    }
                }
                intelligentTieringConfigurationList = intelligentTieringConfigurationListBuffer
            } else {
                intelligentTieringConfigurationList = []
            }
        } else {
            intelligentTieringConfigurationList = nil
        }
    }
}

extension ListBucketInventoryConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBucketInventoryConfigurationsInput(bucket: \(String(describing: bucket)), continuationToken: \(String(describing: continuationToken)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension ListBucketInventoryConfigurationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListBucketInventoryConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListBucketInventoryConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBucketInventoryConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBucketInventoryConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBucketInventoryConfigurationsInput>
    public typealias MOutput = OperationOutput<ListBucketInventoryConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBucketInventoryConfigurationsOutputError>
}

public struct ListBucketInventoryConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBucketInventoryConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBucketInventoryConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBucketInventoryConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "inventory", value: nil))
        input.builder.withQueryItem(URLQueryItem(name: "x-id", value: "ListBucketInventoryConfigurations"))
        if let continuationToken = input.operationInput.continuationToken {
            let continuationTokenQueryItem = URLQueryItem(name: "continuation-token".urlPercentEncoding(), value: String(continuationToken).urlPercentEncoding())
            input.builder.withQueryItem(continuationTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBucketInventoryConfigurationsInput>
    public typealias MOutput = OperationOutput<ListBucketInventoryConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBucketInventoryConfigurationsOutputError>
}

public struct ListBucketInventoryConfigurationsInput: Equatable {
    /// <p>The name of the bucket containing the inventory configurations to retrieve.</p>
    public let bucket: String?
    /// <p>The marker used to continue an inventory configuration listing that has been truncated.
    ///          Use the NextContinuationToken from a previously truncated list response to continue the
    ///          listing. The continuation token is an opaque value that Amazon S3 understands.</p>
    public let continuationToken: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        continuationToken: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.continuationToken = continuationToken
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct ListBucketInventoryConfigurationsInputBody: Equatable {
}

extension ListBucketInventoryConfigurationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListBucketInventoryConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListBucketInventoryConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBucketInventoryConfigurationsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBucketInventoryConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBucketInventoryConfigurationsOutputResponse(continuationToken: \(String(describing: continuationToken)), inventoryConfigurationList: \(String(describing: inventoryConfigurationList)), isTruncated: \(String(describing: isTruncated)), nextContinuationToken: \(String(describing: nextContinuationToken)))"}
}

extension ListBucketInventoryConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBucketInventoryConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.continuationToken = output.continuationToken
            self.inventoryConfigurationList = output.inventoryConfigurationList
            self.isTruncated = output.isTruncated
            self.nextContinuationToken = output.nextContinuationToken
        } else {
            self.continuationToken = nil
            self.inventoryConfigurationList = nil
            self.isTruncated = false
            self.nextContinuationToken = nil
        }
    }
}

public struct ListBucketInventoryConfigurationsOutputResponse: Equatable {
    /// <p>If sent in the request, the marker that is used as a starting point for this inventory
    ///          configuration list response.</p>
    public let continuationToken: String?
    /// <p>The list of inventory configurations for a bucket.</p>
    public let inventoryConfigurationList: [InventoryConfiguration]?
    /// <p>Tells whether the returned list of inventory configurations is complete. A value of true
    ///          indicates that the list is not complete and the NextContinuationToken is provided for a
    ///          subsequent request.</p>
    public let isTruncated: Bool
    /// <p>The marker used to continue this inventory configuration listing. Use the
    ///             <code>NextContinuationToken</code> from this response to continue the listing in a
    ///          subsequent request. The continuation token is an opaque value that Amazon S3 understands.</p>
    public let nextContinuationToken: String?

    public init (
        continuationToken: String? = nil,
        inventoryConfigurationList: [InventoryConfiguration]? = nil,
        isTruncated: Bool = false,
        nextContinuationToken: String? = nil
    )
    {
        self.continuationToken = continuationToken
        self.inventoryConfigurationList = inventoryConfigurationList
        self.isTruncated = isTruncated
        self.nextContinuationToken = nextContinuationToken
    }
}

struct ListBucketInventoryConfigurationsOutputResponseBody: Equatable {
    public let continuationToken: String?
    public let inventoryConfigurationList: [InventoryConfiguration]?
    public let isTruncated: Bool
    public let nextContinuationToken: String?
}

extension ListBucketInventoryConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case continuationToken = "ContinuationToken"
        case inventoryConfigurationList = "InventoryConfiguration"
        case isTruncated = "IsTruncated"
        case nextContinuationToken = "NextContinuationToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let continuationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .continuationToken)
        continuationToken = continuationTokenDecoded
        if containerValues.contains(.inventoryConfigurationList) {
            let inventoryConfigurationListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .inventoryConfigurationList)
            if inventoryConfigurationListWrappedContainer != nil {
                let inventoryConfigurationListContainer = try containerValues.decodeIfPresent([InventoryConfiguration].self, forKey: .inventoryConfigurationList)
                var inventoryConfigurationListBuffer:[InventoryConfiguration]? = nil
                if let inventoryConfigurationListContainer = inventoryConfigurationListContainer {
                    inventoryConfigurationListBuffer = [InventoryConfiguration]()
                    for structureContainer0 in inventoryConfigurationListContainer {
                        inventoryConfigurationListBuffer?.append(structureContainer0)
                    }
                }
                inventoryConfigurationList = inventoryConfigurationListBuffer
            } else {
                inventoryConfigurationList = []
            }
        } else {
            inventoryConfigurationList = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let nextContinuationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextContinuationToken)
        nextContinuationToken = nextContinuationTokenDecoded
    }
}

extension ListBucketMetricsConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBucketMetricsConfigurationsInput(bucket: \(String(describing: bucket)), continuationToken: \(String(describing: continuationToken)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension ListBucketMetricsConfigurationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListBucketMetricsConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListBucketMetricsConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBucketMetricsConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBucketMetricsConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBucketMetricsConfigurationsInput>
    public typealias MOutput = OperationOutput<ListBucketMetricsConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBucketMetricsConfigurationsOutputError>
}

public struct ListBucketMetricsConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBucketMetricsConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBucketMetricsConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBucketMetricsConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "metrics", value: nil))
        input.builder.withQueryItem(URLQueryItem(name: "x-id", value: "ListBucketMetricsConfigurations"))
        if let continuationToken = input.operationInput.continuationToken {
            let continuationTokenQueryItem = URLQueryItem(name: "continuation-token".urlPercentEncoding(), value: String(continuationToken).urlPercentEncoding())
            input.builder.withQueryItem(continuationTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBucketMetricsConfigurationsInput>
    public typealias MOutput = OperationOutput<ListBucketMetricsConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBucketMetricsConfigurationsOutputError>
}

public struct ListBucketMetricsConfigurationsInput: Equatable {
    /// <p>The name of the bucket containing the metrics configurations to retrieve.</p>
    public let bucket: String?
    /// <p>The marker that is used to continue a metrics configuration listing that has been
    ///          truncated. Use the NextContinuationToken from a previously truncated list response to
    ///          continue the listing. The continuation token is an opaque value that Amazon S3
    ///          understands.</p>
    public let continuationToken: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        continuationToken: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.continuationToken = continuationToken
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct ListBucketMetricsConfigurationsInputBody: Equatable {
}

extension ListBucketMetricsConfigurationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListBucketMetricsConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListBucketMetricsConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBucketMetricsConfigurationsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBucketMetricsConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBucketMetricsConfigurationsOutputResponse(continuationToken: \(String(describing: continuationToken)), isTruncated: \(String(describing: isTruncated)), metricsConfigurationList: \(String(describing: metricsConfigurationList)), nextContinuationToken: \(String(describing: nextContinuationToken)))"}
}

extension ListBucketMetricsConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBucketMetricsConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.continuationToken = output.continuationToken
            self.isTruncated = output.isTruncated
            self.metricsConfigurationList = output.metricsConfigurationList
            self.nextContinuationToken = output.nextContinuationToken
        } else {
            self.continuationToken = nil
            self.isTruncated = false
            self.metricsConfigurationList = nil
            self.nextContinuationToken = nil
        }
    }
}

public struct ListBucketMetricsConfigurationsOutputResponse: Equatable {
    /// <p>The marker that is used as a starting point for this metrics configuration list
    ///          response. This value is present if it was sent in the request.</p>
    public let continuationToken: String?
    /// <p>Indicates whether the returned list of metrics configurations is complete. A value of
    ///          true indicates that the list is not complete and the NextContinuationToken will be provided
    ///          for a subsequent request.</p>
    public let isTruncated: Bool
    /// <p>The list of metrics configurations for a bucket.</p>
    public let metricsConfigurationList: [MetricsConfiguration]?
    /// <p>The marker used to continue a metrics configuration listing that has been truncated. Use
    ///          the <code>NextContinuationToken</code> from a previously truncated list response to
    ///          continue the listing. The continuation token is an opaque value that Amazon S3
    ///          understands.</p>
    public let nextContinuationToken: String?

    public init (
        continuationToken: String? = nil,
        isTruncated: Bool = false,
        metricsConfigurationList: [MetricsConfiguration]? = nil,
        nextContinuationToken: String? = nil
    )
    {
        self.continuationToken = continuationToken
        self.isTruncated = isTruncated
        self.metricsConfigurationList = metricsConfigurationList
        self.nextContinuationToken = nextContinuationToken
    }
}

struct ListBucketMetricsConfigurationsOutputResponseBody: Equatable {
    public let isTruncated: Bool
    public let continuationToken: String?
    public let nextContinuationToken: String?
    public let metricsConfigurationList: [MetricsConfiguration]?
}

extension ListBucketMetricsConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case continuationToken = "ContinuationToken"
        case isTruncated = "IsTruncated"
        case metricsConfigurationList = "MetricsConfiguration"
        case nextContinuationToken = "NextContinuationToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let continuationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .continuationToken)
        continuationToken = continuationTokenDecoded
        let nextContinuationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextContinuationToken)
        nextContinuationToken = nextContinuationTokenDecoded
        if containerValues.contains(.metricsConfigurationList) {
            let metricsConfigurationListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .metricsConfigurationList)
            if metricsConfigurationListWrappedContainer != nil {
                let metricsConfigurationListContainer = try containerValues.decodeIfPresent([MetricsConfiguration].self, forKey: .metricsConfigurationList)
                var metricsConfigurationListBuffer:[MetricsConfiguration]? = nil
                if let metricsConfigurationListContainer = metricsConfigurationListContainer {
                    metricsConfigurationListBuffer = [MetricsConfiguration]()
                    for structureContainer0 in metricsConfigurationListContainer {
                        metricsConfigurationListBuffer?.append(structureContainer0)
                    }
                }
                metricsConfigurationList = metricsConfigurationListBuffer
            } else {
                metricsConfigurationList = []
            }
        } else {
            metricsConfigurationList = nil
        }
    }
}

extension ListBucketsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBucketsInput()"}
}

extension ListBucketsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListBucketsInputHeadersMiddleware: Middleware {
    public let id: String = "ListBucketsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBucketsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBucketsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBucketsInput>
    public typealias MOutput = OperationOutput<ListBucketsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBucketsOutputError>
}

public struct ListBucketsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBucketsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBucketsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBucketsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBucketsInput>
    public typealias MOutput = OperationOutput<ListBucketsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBucketsOutputError>
}

public struct ListBucketsInput: Equatable {

    public init() {}
}

struct ListBucketsInputBody: Equatable {
}

extension ListBucketsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListBucketsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListBucketsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBucketsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBucketsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBucketsOutputResponse(buckets: \(String(describing: buckets)), owner: \(String(describing: owner)))"}
}

extension ListBucketsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBucketsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.buckets = output.buckets
            self.owner = output.owner
        } else {
            self.buckets = nil
            self.owner = nil
        }
    }
}

public struct ListBucketsOutputResponse: Equatable {
    /// <p>The list of buckets owned by the requestor.</p>
    public let buckets: [Bucket]?
    /// <p>The owner of the buckets listed.</p>
    public let owner: Owner?

    public init (
        buckets: [Bucket]? = nil,
        owner: Owner? = nil
    )
    {
        self.buckets = buckets
        self.owner = owner
    }
}

struct ListBucketsOutputResponseBody: Equatable {
    public let buckets: [Bucket]?
    public let owner: Owner?
}

extension ListBucketsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case buckets = "Buckets"
        case owner = "Owner"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.buckets) {
            struct KeyVal0{struct Bucket{}}
            let bucketsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Bucket>.CodingKeys.self, forKey: .buckets)
            if let bucketsWrappedContainer = bucketsWrappedContainer {
                let bucketsContainer = try bucketsWrappedContainer.decodeIfPresent([Bucket].self, forKey: .member)
                var bucketsBuffer:[Bucket]? = nil
                if let bucketsContainer = bucketsContainer {
                    bucketsBuffer = [Bucket]()
                    for structureContainer0 in bucketsContainer {
                        bucketsBuffer?.append(structureContainer0)
                    }
                }
                buckets = bucketsBuffer
            } else {
                buckets = []
            }
        } else {
            buckets = nil
        }
        let ownerDecoded = try containerValues.decodeIfPresent(Owner.self, forKey: .owner)
        owner = ownerDecoded
    }
}

extension ListMultipartUploadsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMultipartUploadsInput(bucket: \(String(describing: bucket)), delimiter: \(String(describing: delimiter)), encodingType: \(String(describing: encodingType)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), keyMarker: \(String(describing: keyMarker)), maxUploads: \(String(describing: maxUploads)), prefix: \(String(describing: prefix)), uploadIdMarker: \(String(describing: uploadIdMarker)))"}
}

extension ListMultipartUploadsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListMultipartUploadsInputHeadersMiddleware: Middleware {
    public let id: String = "ListMultipartUploadsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMultipartUploadsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMultipartUploadsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMultipartUploadsInput>
    public typealias MOutput = OperationOutput<ListMultipartUploadsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMultipartUploadsOutputError>
}

public struct ListMultipartUploadsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListMultipartUploadsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMultipartUploadsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMultipartUploadsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "uploads", value: nil))
        if let uploadIdMarker = input.operationInput.uploadIdMarker {
            let uploadIdMarkerQueryItem = URLQueryItem(name: "upload-id-marker".urlPercentEncoding(), value: String(uploadIdMarker).urlPercentEncoding())
            input.builder.withQueryItem(uploadIdMarkerQueryItem)
        }
        if let delimiter = input.operationInput.delimiter {
            let delimiterQueryItem = URLQueryItem(name: "delimiter".urlPercentEncoding(), value: String(delimiter).urlPercentEncoding())
            input.builder.withQueryItem(delimiterQueryItem)
        }
        let maxUploadsQueryItem = URLQueryItem(name: "max-uploads".urlPercentEncoding(), value: String(input.operationInput.maxUploads).urlPercentEncoding())
        input.builder.withQueryItem(maxUploadsQueryItem)
        if let encodingType = input.operationInput.encodingType {
            let encodingTypeQueryItem = URLQueryItem(name: "encoding-type".urlPercentEncoding(), value: String(encodingType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(encodingTypeQueryItem)
        }
        if let prefix = input.operationInput.prefix {
            let prefixQueryItem = URLQueryItem(name: "prefix".urlPercentEncoding(), value: String(prefix).urlPercentEncoding())
            input.builder.withQueryItem(prefixQueryItem)
        }
        if let keyMarker = input.operationInput.keyMarker {
            let keyMarkerQueryItem = URLQueryItem(name: "key-marker".urlPercentEncoding(), value: String(keyMarker).urlPercentEncoding())
            input.builder.withQueryItem(keyMarkerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMultipartUploadsInput>
    public typealias MOutput = OperationOutput<ListMultipartUploadsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMultipartUploadsOutputError>
}

public struct ListMultipartUploadsInput: Equatable {
    /// <p>The name of the bucket to which the multipart upload was initiated. </p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>Character you use to group keys.</p>
    ///          <p>All keys that contain the same string between the prefix, if specified, and the first
    ///          occurrence of the delimiter after the prefix are grouped under a single result element,
    ///             <code>CommonPrefixes</code>. If you don't specify the prefix parameter, then the
    ///          substring starts at the beginning of the key. The keys that are grouped under
    ///             <code>CommonPrefixes</code> result element are not returned elsewhere in the
    ///          response.</p>
    public let delimiter: String?
    /// <p>Requests Amazon S3 to encode the object keys in the response and specifies the encoding
    ///          method to use. An object key may contain any Unicode character; however, XML 1.0 parser
    ///          cannot parse some characters, such as characters with an ASCII value from 0 to 10. For
    ///          characters that are not supported in XML 1.0, you can add this parameter to request that
    ///          Amazon S3 encode the keys in the response.</p>
    public let encodingType: EncodingType?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>Together with upload-id-marker, this parameter specifies the multipart upload after
    ///          which listing should begin.</p>
    ///          <p>If <code>upload-id-marker</code> is not specified, only the keys lexicographically
    ///          greater than the specified <code>key-marker</code> will be included in the list.</p>
    ///
    ///          <p>If <code>upload-id-marker</code> is specified, any multipart uploads for a key equal to
    ///          the <code>key-marker</code> might also be included, provided those multipart uploads have
    ///          upload IDs lexicographically greater than the specified
    ///          <code>upload-id-marker</code>.</p>
    public let keyMarker: String?
    /// <p>Sets the maximum number of multipart uploads, from 1 to 1,000, to return in the response
    ///          body. 1,000 is the maximum number of uploads that can be returned in a response.</p>
    public let maxUploads: Int
    /// <p>Lists in-progress uploads only for those keys that begin with the specified prefix. You
    ///          can use prefixes to separate a bucket into different grouping of keys. (You can think of
    ///          using prefix to make groups in the same way you'd use a folder in a file system.)</p>
    public let prefix: String?
    /// <p>Together with key-marker, specifies the multipart upload after which listing should
    ///          begin. If key-marker is not specified, the upload-id-marker parameter is ignored.
    ///          Otherwise, any multipart uploads for a key equal to the key-marker might be included in the
    ///          list only if they have an upload ID lexicographically greater than the specified
    ///             <code>upload-id-marker</code>.</p>
    public let uploadIdMarker: String?

    public init (
        bucket: String? = nil,
        delimiter: String? = nil,
        encodingType: EncodingType? = nil,
        expectedBucketOwner: String? = nil,
        keyMarker: String? = nil,
        maxUploads: Int = 0,
        prefix: String? = nil,
        uploadIdMarker: String? = nil
    )
    {
        self.bucket = bucket
        self.delimiter = delimiter
        self.encodingType = encodingType
        self.expectedBucketOwner = expectedBucketOwner
        self.keyMarker = keyMarker
        self.maxUploads = maxUploads
        self.prefix = prefix
        self.uploadIdMarker = uploadIdMarker
    }
}

struct ListMultipartUploadsInputBody: Equatable {
}

extension ListMultipartUploadsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListMultipartUploadsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListMultipartUploadsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMultipartUploadsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMultipartUploadsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMultipartUploadsOutputResponse(bucket: \(String(describing: bucket)), commonPrefixes: \(String(describing: commonPrefixes)), delimiter: \(String(describing: delimiter)), encodingType: \(String(describing: encodingType)), isTruncated: \(String(describing: isTruncated)), keyMarker: \(String(describing: keyMarker)), maxUploads: \(String(describing: maxUploads)), nextKeyMarker: \(String(describing: nextKeyMarker)), nextUploadIdMarker: \(String(describing: nextUploadIdMarker)), prefix: \(String(describing: prefix)), uploadIdMarker: \(String(describing: uploadIdMarker)), uploads: \(String(describing: uploads)))"}
}

extension ListMultipartUploadsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListMultipartUploadsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.bucket = output.bucket
            self.commonPrefixes = output.commonPrefixes
            self.delimiter = output.delimiter
            self.encodingType = output.encodingType
            self.isTruncated = output.isTruncated
            self.keyMarker = output.keyMarker
            self.maxUploads = output.maxUploads
            self.nextKeyMarker = output.nextKeyMarker
            self.nextUploadIdMarker = output.nextUploadIdMarker
            self.prefix = output.prefix
            self.uploadIdMarker = output.uploadIdMarker
            self.uploads = output.uploads
        } else {
            self.bucket = nil
            self.commonPrefixes = nil
            self.delimiter = nil
            self.encodingType = nil
            self.isTruncated = false
            self.keyMarker = nil
            self.maxUploads = 0
            self.nextKeyMarker = nil
            self.nextUploadIdMarker = nil
            self.prefix = nil
            self.uploadIdMarker = nil
            self.uploads = nil
        }
    }
}

public struct ListMultipartUploadsOutputResponse: Equatable {
    /// <p>The name of the bucket to which the multipart upload was initiated.</p>
    public let bucket: String?
    /// <p>If you specify a delimiter in the request, then the result returns each distinct key
    ///          prefix containing the delimiter in a <code>CommonPrefixes</code> element. The distinct key
    ///          prefixes are returned in the <code>Prefix</code> child element.</p>
    public let commonPrefixes: [CommonPrefix]?
    /// <p>Contains the delimiter you specified in the request. If you don't specify a delimiter in
    ///          your request, this element is absent from the response.</p>
    public let delimiter: String?
    /// <p>Encoding type used by Amazon S3 to encode object keys in the response.</p>
    ///          <p>If you specify <code>encoding-type</code> request parameter, Amazon S3 includes this element
    ///          in the response, and returns encoded key name values in the following response
    ///          elements:</p>
    ///
    ///          <p>
    ///             <code>Delimiter</code>, <code>KeyMarker</code>, <code>Prefix</code>,
    ///             <code>NextKeyMarker</code>, <code>Key</code>.</p>
    public let encodingType: EncodingType?
    /// <p>Indicates whether the returned list of multipart uploads is truncated. A value of true
    ///          indicates that the list was truncated. The list can be truncated if the number of multipart
    ///          uploads exceeds the limit allowed or specified by max uploads.</p>
    public let isTruncated: Bool
    /// <p>The key at or after which the listing began.</p>
    public let keyMarker: String?
    /// <p>Maximum number of multipart uploads that could have been included in the
    ///          response.</p>
    public let maxUploads: Int
    /// <p>When a list is truncated, this element specifies the value that should be used for the
    ///          key-marker request parameter in a subsequent request.</p>
    public let nextKeyMarker: String?
    /// <p>When a list is truncated, this element specifies the value that should be used for the
    ///             <code>upload-id-marker</code> request parameter in a subsequent request.</p>
    public let nextUploadIdMarker: String?
    /// <p>When a prefix is provided in the request, this field contains the specified prefix. The
    ///          result contains only keys starting with the specified prefix.</p>
    public let prefix: String?
    /// <p>Upload ID after which listing began.</p>
    public let uploadIdMarker: String?
    /// <p>Container for elements related to a particular multipart upload. A response can contain
    ///          zero or more <code>Upload</code> elements.</p>
    public let uploads: [MultipartUpload]?

    public init (
        bucket: String? = nil,
        commonPrefixes: [CommonPrefix]? = nil,
        delimiter: String? = nil,
        encodingType: EncodingType? = nil,
        isTruncated: Bool = false,
        keyMarker: String? = nil,
        maxUploads: Int = 0,
        nextKeyMarker: String? = nil,
        nextUploadIdMarker: String? = nil,
        prefix: String? = nil,
        uploadIdMarker: String? = nil,
        uploads: [MultipartUpload]? = nil
    )
    {
        self.bucket = bucket
        self.commonPrefixes = commonPrefixes
        self.delimiter = delimiter
        self.encodingType = encodingType
        self.isTruncated = isTruncated
        self.keyMarker = keyMarker
        self.maxUploads = maxUploads
        self.nextKeyMarker = nextKeyMarker
        self.nextUploadIdMarker = nextUploadIdMarker
        self.prefix = prefix
        self.uploadIdMarker = uploadIdMarker
        self.uploads = uploads
    }
}

struct ListMultipartUploadsOutputResponseBody: Equatable {
    public let bucket: String?
    public let keyMarker: String?
    public let uploadIdMarker: String?
    public let nextKeyMarker: String?
    public let prefix: String?
    public let delimiter: String?
    public let nextUploadIdMarker: String?
    public let maxUploads: Int
    public let isTruncated: Bool
    public let uploads: [MultipartUpload]?
    public let commonPrefixes: [CommonPrefix]?
    public let encodingType: EncodingType?
}

extension ListMultipartUploadsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case commonPrefixes = "CommonPrefixes"
        case delimiter = "Delimiter"
        case encodingType = "EncodingType"
        case isTruncated = "IsTruncated"
        case keyMarker = "KeyMarker"
        case maxUploads = "MaxUploads"
        case nextKeyMarker = "NextKeyMarker"
        case nextUploadIdMarker = "NextUploadIdMarker"
        case prefix = "Prefix"
        case uploadIdMarker = "UploadIdMarker"
        case uploads = "Upload"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyMarker)
        keyMarker = keyMarkerDecoded
        let uploadIdMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadIdMarker)
        uploadIdMarker = uploadIdMarkerDecoded
        let nextKeyMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextKeyMarker)
        nextKeyMarker = nextKeyMarkerDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let nextUploadIdMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextUploadIdMarker)
        nextUploadIdMarker = nextUploadIdMarkerDecoded
        let maxUploadsDecoded = try containerValues.decode(Int.self, forKey: .maxUploads)
        maxUploads = maxUploadsDecoded
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        if containerValues.contains(.uploads) {
            let uploadsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .uploads)
            if uploadsWrappedContainer != nil {
                let uploadsContainer = try containerValues.decodeIfPresent([MultipartUpload].self, forKey: .uploads)
                var uploadsBuffer:[MultipartUpload]? = nil
                if let uploadsContainer = uploadsContainer {
                    uploadsBuffer = [MultipartUpload]()
                    for structureContainer0 in uploadsContainer {
                        uploadsBuffer?.append(structureContainer0)
                    }
                }
                uploads = uploadsBuffer
            } else {
                uploads = []
            }
        } else {
            uploads = nil
        }
        if containerValues.contains(.commonPrefixes) {
            let commonPrefixesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .commonPrefixes)
            if commonPrefixesWrappedContainer != nil {
                let commonPrefixesContainer = try containerValues.decodeIfPresent([CommonPrefix].self, forKey: .commonPrefixes)
                var commonPrefixesBuffer:[CommonPrefix]? = nil
                if let commonPrefixesContainer = commonPrefixesContainer {
                    commonPrefixesBuffer = [CommonPrefix]()
                    for structureContainer0 in commonPrefixesContainer {
                        commonPrefixesBuffer?.append(structureContainer0)
                    }
                }
                commonPrefixes = commonPrefixesBuffer
            } else {
                commonPrefixes = []
            }
        } else {
            commonPrefixes = nil
        }
        let encodingTypeDecoded = try containerValues.decodeIfPresent(EncodingType.self, forKey: .encodingType)
        encodingType = encodingTypeDecoded
    }
}

extension ListObjectVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListObjectVersionsInput(bucket: \(String(describing: bucket)), delimiter: \(String(describing: delimiter)), encodingType: \(String(describing: encodingType)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), keyMarker: \(String(describing: keyMarker)), maxKeys: \(String(describing: maxKeys)), prefix: \(String(describing: prefix)), versionIdMarker: \(String(describing: versionIdMarker)))"}
}

extension ListObjectVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListObjectVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListObjectVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListObjectVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListObjectVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListObjectVersionsInput>
    public typealias MOutput = OperationOutput<ListObjectVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListObjectVersionsOutputError>
}

public struct ListObjectVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListObjectVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListObjectVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListObjectVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "versions", value: nil))
        if let versionIdMarker = input.operationInput.versionIdMarker {
            let versionIdMarkerQueryItem = URLQueryItem(name: "version-id-marker".urlPercentEncoding(), value: String(versionIdMarker).urlPercentEncoding())
            input.builder.withQueryItem(versionIdMarkerQueryItem)
        }
        if let delimiter = input.operationInput.delimiter {
            let delimiterQueryItem = URLQueryItem(name: "delimiter".urlPercentEncoding(), value: String(delimiter).urlPercentEncoding())
            input.builder.withQueryItem(delimiterQueryItem)
        }
        if let encodingType = input.operationInput.encodingType {
            let encodingTypeQueryItem = URLQueryItem(name: "encoding-type".urlPercentEncoding(), value: String(encodingType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(encodingTypeQueryItem)
        }
        if let prefix = input.operationInput.prefix {
            let prefixQueryItem = URLQueryItem(name: "prefix".urlPercentEncoding(), value: String(prefix).urlPercentEncoding())
            input.builder.withQueryItem(prefixQueryItem)
        }
        let maxKeysQueryItem = URLQueryItem(name: "max-keys".urlPercentEncoding(), value: String(input.operationInput.maxKeys).urlPercentEncoding())
        input.builder.withQueryItem(maxKeysQueryItem)
        if let keyMarker = input.operationInput.keyMarker {
            let keyMarkerQueryItem = URLQueryItem(name: "key-marker".urlPercentEncoding(), value: String(keyMarker).urlPercentEncoding())
            input.builder.withQueryItem(keyMarkerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListObjectVersionsInput>
    public typealias MOutput = OperationOutput<ListObjectVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListObjectVersionsOutputError>
}

public struct ListObjectVersionsInput: Equatable {
    /// <p>The bucket name that contains the objects. </p>
    public let bucket: String?
    /// <p>A delimiter is a character that you specify to group keys. All keys that contain the
    ///          same string between the <code>prefix</code> and the first occurrence of the delimiter are
    ///          grouped under a single result element in CommonPrefixes. These groups are counted as one
    ///          result against the max-keys limitation. These keys are not returned elsewhere in the
    ///          response.</p>
    public let delimiter: String?
    /// <p>Requests Amazon S3 to encode the object keys in the response and specifies the encoding
    ///          method to use. An object key may contain any Unicode character; however, XML 1.0 parser
    ///          cannot parse some characters, such as characters with an ASCII value from 0 to 10. For
    ///          characters that are not supported in XML 1.0, you can add this parameter to request that
    ///          Amazon S3 encode the keys in the response.</p>
    public let encodingType: EncodingType?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>Specifies the key to start with when listing objects in a bucket.</p>
    public let keyMarker: String?
    /// <p>Sets the maximum number of keys returned in the response. By default the action returns up
    ///          to 1,000 key names. The response might contain fewer keys but will never contain more. If
    ///          additional keys satisfy the search criteria, but were not returned because max-keys was
    ///          exceeded, the response contains <isTruncated>true</isTruncated>. To return the
    ///          additional keys, see key-marker and version-id-marker.</p>
    public let maxKeys: Int
    /// <p>Use this parameter to select only those keys that begin with the specified prefix. You
    ///          can use prefixes to separate a bucket into different groupings of keys. (You can think of
    ///          using prefix to make groups in the same way you'd use a folder in a file system.) You can
    ///          use prefix with delimiter to roll up numerous objects into a single result under
    ///          CommonPrefixes. </p>
    public let prefix: String?
    /// <p>Specifies the object version you want to start listing from.</p>
    public let versionIdMarker: String?

    public init (
        bucket: String? = nil,
        delimiter: String? = nil,
        encodingType: EncodingType? = nil,
        expectedBucketOwner: String? = nil,
        keyMarker: String? = nil,
        maxKeys: Int = 0,
        prefix: String? = nil,
        versionIdMarker: String? = nil
    )
    {
        self.bucket = bucket
        self.delimiter = delimiter
        self.encodingType = encodingType
        self.expectedBucketOwner = expectedBucketOwner
        self.keyMarker = keyMarker
        self.maxKeys = maxKeys
        self.prefix = prefix
        self.versionIdMarker = versionIdMarker
    }
}

struct ListObjectVersionsInputBody: Equatable {
}

extension ListObjectVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListObjectVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListObjectVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListObjectVersionsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListObjectVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListObjectVersionsOutputResponse(commonPrefixes: \(String(describing: commonPrefixes)), deleteMarkers: \(String(describing: deleteMarkers)), delimiter: \(String(describing: delimiter)), encodingType: \(String(describing: encodingType)), isTruncated: \(String(describing: isTruncated)), keyMarker: \(String(describing: keyMarker)), maxKeys: \(String(describing: maxKeys)), name: \(String(describing: name)), nextKeyMarker: \(String(describing: nextKeyMarker)), nextVersionIdMarker: \(String(describing: nextVersionIdMarker)), prefix: \(String(describing: prefix)), versionIdMarker: \(String(describing: versionIdMarker)), versions: \(String(describing: versions)))"}
}

extension ListObjectVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListObjectVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.commonPrefixes = output.commonPrefixes
            self.deleteMarkers = output.deleteMarkers
            self.delimiter = output.delimiter
            self.encodingType = output.encodingType
            self.isTruncated = output.isTruncated
            self.keyMarker = output.keyMarker
            self.maxKeys = output.maxKeys
            self.name = output.name
            self.nextKeyMarker = output.nextKeyMarker
            self.nextVersionIdMarker = output.nextVersionIdMarker
            self.prefix = output.prefix
            self.versionIdMarker = output.versionIdMarker
            self.versions = output.versions
        } else {
            self.commonPrefixes = nil
            self.deleteMarkers = nil
            self.delimiter = nil
            self.encodingType = nil
            self.isTruncated = false
            self.keyMarker = nil
            self.maxKeys = 0
            self.name = nil
            self.nextKeyMarker = nil
            self.nextVersionIdMarker = nil
            self.prefix = nil
            self.versionIdMarker = nil
            self.versions = nil
        }
    }
}

public struct ListObjectVersionsOutputResponse: Equatable {
    /// <p>All of the keys rolled up into a common prefix count as a single return when calculating
    ///          the number of returns.</p>
    public let commonPrefixes: [CommonPrefix]?
    /// <p>Container for an object that is a delete marker.</p>
    public let deleteMarkers: [DeleteMarkerEntry]?
    /// <p>The delimiter grouping the included keys. A delimiter is a character that you specify to
    ///          group keys. All keys that contain the same string between the prefix and the first
    ///          occurrence of the delimiter are grouped under a single result element in
    ///             <code>CommonPrefixes</code>. These groups are counted as one result against the max-keys
    ///          limitation. These keys are not returned elsewhere in the response.</p>
    public let delimiter: String?
    /// <p> Encoding type used by Amazon S3 to encode object key names in the XML response.</p>
    ///
    ///          <p>If you specify encoding-type request parameter, Amazon S3 includes this element in the
    ///          response, and returns encoded key name values in the following response elements:</p>
    ///
    ///          <p>
    ///             <code>KeyMarker, NextKeyMarker, Prefix, Key</code>, and <code>Delimiter</code>.</p>
    public let encodingType: EncodingType?
    /// <p>A flag that indicates whether Amazon S3 returned all of the results that satisfied the search
    ///          criteria. If your results were truncated, you can make a follow-up paginated request using
    ///          the NextKeyMarker and NextVersionIdMarker response parameters as a starting place in
    ///          another request to return the rest of the results.</p>
    public let isTruncated: Bool
    /// <p>Marks the last key returned in a truncated response.</p>
    public let keyMarker: String?
    /// <p>Specifies the maximum number of objects to return.</p>
    public let maxKeys: Int
    /// <p>The bucket name.</p>
    public let name: String?
    /// <p>When the number of responses exceeds the value of <code>MaxKeys</code>,
    ///             <code>NextKeyMarker</code> specifies the first key not returned that satisfies the
    ///          search criteria. Use this value for the key-marker request parameter in a subsequent
    ///          request.</p>
    public let nextKeyMarker: String?
    /// <p>When the number of responses exceeds the value of <code>MaxKeys</code>,
    ///             <code>NextVersionIdMarker</code> specifies the first object version not returned that
    ///          satisfies the search criteria. Use this value for the version-id-marker request parameter
    ///          in a subsequent request.</p>
    public let nextVersionIdMarker: String?
    /// <p>Selects objects that start with the value supplied by this parameter.</p>
    public let prefix: String?
    /// <p>Marks the last version of the key returned in a truncated response.</p>
    public let versionIdMarker: String?
    /// <p>Container for version information.</p>
    public let versions: [ObjectVersion]?

    public init (
        commonPrefixes: [CommonPrefix]? = nil,
        deleteMarkers: [DeleteMarkerEntry]? = nil,
        delimiter: String? = nil,
        encodingType: EncodingType? = nil,
        isTruncated: Bool = false,
        keyMarker: String? = nil,
        maxKeys: Int = 0,
        name: String? = nil,
        nextKeyMarker: String? = nil,
        nextVersionIdMarker: String? = nil,
        prefix: String? = nil,
        versionIdMarker: String? = nil,
        versions: [ObjectVersion]? = nil
    )
    {
        self.commonPrefixes = commonPrefixes
        self.deleteMarkers = deleteMarkers
        self.delimiter = delimiter
        self.encodingType = encodingType
        self.isTruncated = isTruncated
        self.keyMarker = keyMarker
        self.maxKeys = maxKeys
        self.name = name
        self.nextKeyMarker = nextKeyMarker
        self.nextVersionIdMarker = nextVersionIdMarker
        self.prefix = prefix
        self.versionIdMarker = versionIdMarker
        self.versions = versions
    }
}

struct ListObjectVersionsOutputResponseBody: Equatable {
    public let isTruncated: Bool
    public let keyMarker: String?
    public let versionIdMarker: String?
    public let nextKeyMarker: String?
    public let nextVersionIdMarker: String?
    public let versions: [ObjectVersion]?
    public let deleteMarkers: [DeleteMarkerEntry]?
    public let name: String?
    public let prefix: String?
    public let delimiter: String?
    public let maxKeys: Int
    public let commonPrefixes: [CommonPrefix]?
    public let encodingType: EncodingType?
}

extension ListObjectVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commonPrefixes = "CommonPrefixes"
        case deleteMarkers = "DeleteMarker"
        case delimiter = "Delimiter"
        case encodingType = "EncodingType"
        case isTruncated = "IsTruncated"
        case keyMarker = "KeyMarker"
        case maxKeys = "MaxKeys"
        case name = "Name"
        case nextKeyMarker = "NextKeyMarker"
        case nextVersionIdMarker = "NextVersionIdMarker"
        case prefix = "Prefix"
        case versionIdMarker = "VersionIdMarker"
        case versions = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let keyMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyMarker)
        keyMarker = keyMarkerDecoded
        let versionIdMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionIdMarker)
        versionIdMarker = versionIdMarkerDecoded
        let nextKeyMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextKeyMarker)
        nextKeyMarker = nextKeyMarkerDecoded
        let nextVersionIdMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextVersionIdMarker)
        nextVersionIdMarker = nextVersionIdMarkerDecoded
        if containerValues.contains(.versions) {
            let versionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .versions)
            if versionsWrappedContainer != nil {
                let versionsContainer = try containerValues.decodeIfPresent([ObjectVersion].self, forKey: .versions)
                var versionsBuffer:[ObjectVersion]? = nil
                if let versionsContainer = versionsContainer {
                    versionsBuffer = [ObjectVersion]()
                    for structureContainer0 in versionsContainer {
                        versionsBuffer?.append(structureContainer0)
                    }
                }
                versions = versionsBuffer
            } else {
                versions = []
            }
        } else {
            versions = nil
        }
        if containerValues.contains(.deleteMarkers) {
            let deleteMarkersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .deleteMarkers)
            if deleteMarkersWrappedContainer != nil {
                let deleteMarkersContainer = try containerValues.decodeIfPresent([DeleteMarkerEntry].self, forKey: .deleteMarkers)
                var deleteMarkersBuffer:[DeleteMarkerEntry]? = nil
                if let deleteMarkersContainer = deleteMarkersContainer {
                    deleteMarkersBuffer = [DeleteMarkerEntry]()
                    for structureContainer0 in deleteMarkersContainer {
                        deleteMarkersBuffer?.append(structureContainer0)
                    }
                }
                deleteMarkers = deleteMarkersBuffer
            } else {
                deleteMarkers = []
            }
        } else {
            deleteMarkers = nil
        }
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let maxKeysDecoded = try containerValues.decode(Int.self, forKey: .maxKeys)
        maxKeys = maxKeysDecoded
        if containerValues.contains(.commonPrefixes) {
            let commonPrefixesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .commonPrefixes)
            if commonPrefixesWrappedContainer != nil {
                let commonPrefixesContainer = try containerValues.decodeIfPresent([CommonPrefix].self, forKey: .commonPrefixes)
                var commonPrefixesBuffer:[CommonPrefix]? = nil
                if let commonPrefixesContainer = commonPrefixesContainer {
                    commonPrefixesBuffer = [CommonPrefix]()
                    for structureContainer0 in commonPrefixesContainer {
                        commonPrefixesBuffer?.append(structureContainer0)
                    }
                }
                commonPrefixes = commonPrefixesBuffer
            } else {
                commonPrefixes = []
            }
        } else {
            commonPrefixes = nil
        }
        let encodingTypeDecoded = try containerValues.decodeIfPresent(EncodingType.self, forKey: .encodingType)
        encodingType = encodingTypeDecoded
    }
}

extension ListObjectsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListObjectsInput(bucket: \(String(describing: bucket)), delimiter: \(String(describing: delimiter)), encodingType: \(String(describing: encodingType)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), marker: \(String(describing: marker)), maxKeys: \(String(describing: maxKeys)), prefix: \(String(describing: prefix)), requestPayer: \(String(describing: requestPayer)))"}
}

extension ListObjectsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListObjectsInputHeadersMiddleware: Middleware {
    public let id: String = "ListObjectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListObjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListObjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListObjectsInput>
    public typealias MOutput = OperationOutput<ListObjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListObjectsOutputError>
}

public struct ListObjectsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListObjectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListObjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListObjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let delimiter = input.operationInput.delimiter {
            let delimiterQueryItem = URLQueryItem(name: "delimiter".urlPercentEncoding(), value: String(delimiter).urlPercentEncoding())
            input.builder.withQueryItem(delimiterQueryItem)
        }
        if let encodingType = input.operationInput.encodingType {
            let encodingTypeQueryItem = URLQueryItem(name: "encoding-type".urlPercentEncoding(), value: String(encodingType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(encodingTypeQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let prefix = input.operationInput.prefix {
            let prefixQueryItem = URLQueryItem(name: "prefix".urlPercentEncoding(), value: String(prefix).urlPercentEncoding())
            input.builder.withQueryItem(prefixQueryItem)
        }
        let maxKeysQueryItem = URLQueryItem(name: "max-keys".urlPercentEncoding(), value: String(input.operationInput.maxKeys).urlPercentEncoding())
        input.builder.withQueryItem(maxKeysQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListObjectsInput>
    public typealias MOutput = OperationOutput<ListObjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListObjectsOutputError>
}

public struct ListObjectsInput: Equatable {
    /// <p>The name of the bucket containing the objects.</p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>A delimiter is a character you use to group keys.</p>
    public let delimiter: String?
    /// <p>Requests Amazon S3 to encode the object keys in the response and specifies the encoding
    ///          method to use. An object key may contain any Unicode character; however, XML 1.0 parser
    ///          cannot parse some characters, such as characters with an ASCII value from 0 to 10. For
    ///          characters that are not supported in XML 1.0, you can add this parameter to request that
    ///          Amazon S3 encode the keys in the response.</p>
    public let encodingType: EncodingType?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>Specifies the key to start with when listing objects in a bucket.</p>
    public let marker: String?
    /// <p>Sets the maximum number of keys returned in the response. By default the action returns up
    ///          to 1,000 key names. The response might contain fewer keys but will never contain more.
    ///       </p>
    public let maxKeys: Int
    /// <p>Limits the response to keys that begin with the specified prefix.</p>
    public let prefix: String?
    /// <p>Confirms that the requester knows that she or he will be charged for the list objects
    ///          request. Bucket owners need not specify this parameter in their requests.</p>
    public let requestPayer: RequestPayer?

    public init (
        bucket: String? = nil,
        delimiter: String? = nil,
        encodingType: EncodingType? = nil,
        expectedBucketOwner: String? = nil,
        marker: String? = nil,
        maxKeys: Int = 0,
        prefix: String? = nil,
        requestPayer: RequestPayer? = nil
    )
    {
        self.bucket = bucket
        self.delimiter = delimiter
        self.encodingType = encodingType
        self.expectedBucketOwner = expectedBucketOwner
        self.marker = marker
        self.maxKeys = maxKeys
        self.prefix = prefix
        self.requestPayer = requestPayer
    }
}

struct ListObjectsInputBody: Equatable {
}

extension ListObjectsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListObjectsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListObjectsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchBucket" : self = .noSuchBucket(try NoSuchBucket(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListObjectsOutputError: Equatable {
    case noSuchBucket(NoSuchBucket)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListObjectsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListObjectsOutputResponse(commonPrefixes: \(String(describing: commonPrefixes)), contents: \(String(describing: contents)), delimiter: \(String(describing: delimiter)), encodingType: \(String(describing: encodingType)), isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), maxKeys: \(String(describing: maxKeys)), name: \(String(describing: name)), nextMarker: \(String(describing: nextMarker)), prefix: \(String(describing: prefix)))"}
}

extension ListObjectsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListObjectsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.commonPrefixes = output.commonPrefixes
            self.contents = output.contents
            self.delimiter = output.delimiter
            self.encodingType = output.encodingType
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.maxKeys = output.maxKeys
            self.name = output.name
            self.nextMarker = output.nextMarker
            self.prefix = output.prefix
        } else {
            self.commonPrefixes = nil
            self.contents = nil
            self.delimiter = nil
            self.encodingType = nil
            self.isTruncated = false
            self.marker = nil
            self.maxKeys = 0
            self.name = nil
            self.nextMarker = nil
            self.prefix = nil
        }
    }
}

public struct ListObjectsOutputResponse: Equatable {
    /// <p>All of the keys (up to 1,000) rolled up in a common prefix count as a single return when calculating
    ///          the number of returns. </p>
    ///
    ///          <p>A response can contain CommonPrefixes only if you specify a delimiter.</p>
    ///
    ///          <p>CommonPrefixes contains all (if there are any) keys between Prefix and the next
    ///          occurrence of the string specified by the delimiter.</p>
    ///
    ///          <p> CommonPrefixes lists keys that act like subdirectories in the directory specified by
    ///          Prefix.</p>
    ///
    ///          <p>For example, if the prefix is notes/ and the delimiter is a slash (/) as in
    ///          notes/summer/july, the common prefix is notes/summer/. All of the keys that roll up into a
    ///          common prefix count as a single return when calculating the number of returns.</p>
    public let commonPrefixes: [CommonPrefix]?
    /// <p>Metadata about each object returned.</p>
    public let contents: [Object]?
    /// <p>Causes keys that contain the same string between the prefix and the first occurrence of
    ///          the delimiter to be rolled up into a single result element in the
    ///             <code>CommonPrefixes</code> collection. These rolled-up keys are not returned elsewhere
    ///          in the response. Each rolled-up result counts as only one return against the
    ///             <code>MaxKeys</code> value.</p>
    public let delimiter: String?
    /// <p>Encoding type used by Amazon S3 to encode object keys in the response.</p>
    public let encodingType: EncodingType?
    /// <p>A flag that indicates whether Amazon S3 returned all of the results that satisfied the search
    ///          criteria.</p>
    public let isTruncated: Bool
    /// <p>Indicates where in the bucket listing begins. Marker is included in the response if it
    ///          was sent with the request.</p>
    public let marker: String?
    /// <p>The maximum number of keys returned in the response body.</p>
    public let maxKeys: Int
    /// <p>The bucket name.</p>
    public let name: String?
    /// <p>When response is truncated (the IsTruncated element value in the response is true), you
    ///          can use the key name in this field as marker in the subsequent request to get next set of
    ///          objects. Amazon S3 lists objects in alphabetical order Note: This element is returned only if
    ///          you have delimiter request parameter specified. If response does not include the NextMarker
    ///          and it is truncated, you can use the value of the last Key in the response as the marker in
    ///          the subsequent request to get the next set of object keys.</p>
    public let nextMarker: String?
    /// <p>Keys that begin with the indicated prefix.</p>
    public let prefix: String?

    public init (
        commonPrefixes: [CommonPrefix]? = nil,
        contents: [Object]? = nil,
        delimiter: String? = nil,
        encodingType: EncodingType? = nil,
        isTruncated: Bool = false,
        marker: String? = nil,
        maxKeys: Int = 0,
        name: String? = nil,
        nextMarker: String? = nil,
        prefix: String? = nil
    )
    {
        self.commonPrefixes = commonPrefixes
        self.contents = contents
        self.delimiter = delimiter
        self.encodingType = encodingType
        self.isTruncated = isTruncated
        self.marker = marker
        self.maxKeys = maxKeys
        self.name = name
        self.nextMarker = nextMarker
        self.prefix = prefix
    }
}

struct ListObjectsOutputResponseBody: Equatable {
    public let isTruncated: Bool
    public let marker: String?
    public let nextMarker: String?
    public let contents: [Object]?
    public let name: String?
    public let prefix: String?
    public let delimiter: String?
    public let maxKeys: Int
    public let commonPrefixes: [CommonPrefix]?
    public let encodingType: EncodingType?
}

extension ListObjectsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commonPrefixes = "CommonPrefixes"
        case contents = "Contents"
        case delimiter = "Delimiter"
        case encodingType = "EncodingType"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case maxKeys = "MaxKeys"
        case name = "Name"
        case nextMarker = "NextMarker"
        case prefix = "Prefix"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        if containerValues.contains(.contents) {
            let contentsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .contents)
            if contentsWrappedContainer != nil {
                let contentsContainer = try containerValues.decodeIfPresent([Object].self, forKey: .contents)
                var contentsBuffer:[Object]? = nil
                if let contentsContainer = contentsContainer {
                    contentsBuffer = [Object]()
                    for structureContainer0 in contentsContainer {
                        contentsBuffer?.append(structureContainer0)
                    }
                }
                contents = contentsBuffer
            } else {
                contents = []
            }
        } else {
            contents = nil
        }
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let maxKeysDecoded = try containerValues.decode(Int.self, forKey: .maxKeys)
        maxKeys = maxKeysDecoded
        if containerValues.contains(.commonPrefixes) {
            let commonPrefixesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .commonPrefixes)
            if commonPrefixesWrappedContainer != nil {
                let commonPrefixesContainer = try containerValues.decodeIfPresent([CommonPrefix].self, forKey: .commonPrefixes)
                var commonPrefixesBuffer:[CommonPrefix]? = nil
                if let commonPrefixesContainer = commonPrefixesContainer {
                    commonPrefixesBuffer = [CommonPrefix]()
                    for structureContainer0 in commonPrefixesContainer {
                        commonPrefixesBuffer?.append(structureContainer0)
                    }
                }
                commonPrefixes = commonPrefixesBuffer
            } else {
                commonPrefixes = []
            }
        } else {
            commonPrefixes = nil
        }
        let encodingTypeDecoded = try containerValues.decodeIfPresent(EncodingType.self, forKey: .encodingType)
        encodingType = encodingTypeDecoded
    }
}

extension ListObjectsV2Input: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListObjectsV2Input(bucket: \(String(describing: bucket)), continuationToken: \(String(describing: continuationToken)), delimiter: \(String(describing: delimiter)), encodingType: \(String(describing: encodingType)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), fetchOwner: \(String(describing: fetchOwner)), maxKeys: \(String(describing: maxKeys)), prefix: \(String(describing: prefix)), requestPayer: \(String(describing: requestPayer)), startAfter: \(String(describing: startAfter)))"}
}

extension ListObjectsV2Input: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListObjectsV2InputHeadersMiddleware: Middleware {
    public let id: String = "ListObjectsV2InputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListObjectsV2Input>,
                  next: H) -> Swift.Result<OperationOutput<ListObjectsV2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListObjectsV2Input>
    public typealias MOutput = OperationOutput<ListObjectsV2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListObjectsV2OutputError>
}

public struct ListObjectsV2InputQueryItemMiddleware: Middleware {
    public let id: String = "ListObjectsV2InputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListObjectsV2Input>,
                  next: H) -> Swift.Result<OperationOutput<ListObjectsV2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "list-type", value: "2"))
        if let continuationToken = input.operationInput.continuationToken {
            let continuationTokenQueryItem = URLQueryItem(name: "continuation-token".urlPercentEncoding(), value: String(continuationToken).urlPercentEncoding())
            input.builder.withQueryItem(continuationTokenQueryItem)
        }
        if let delimiter = input.operationInput.delimiter {
            let delimiterQueryItem = URLQueryItem(name: "delimiter".urlPercentEncoding(), value: String(delimiter).urlPercentEncoding())
            input.builder.withQueryItem(delimiterQueryItem)
        }
        let fetchOwnerQueryItem = URLQueryItem(name: "fetch-owner".urlPercentEncoding(), value: String(input.operationInput.fetchOwner).urlPercentEncoding())
        input.builder.withQueryItem(fetchOwnerQueryItem)
        if let encodingType = input.operationInput.encodingType {
            let encodingTypeQueryItem = URLQueryItem(name: "encoding-type".urlPercentEncoding(), value: String(encodingType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(encodingTypeQueryItem)
        }
        if let startAfter = input.operationInput.startAfter {
            let startAfterQueryItem = URLQueryItem(name: "start-after".urlPercentEncoding(), value: String(startAfter).urlPercentEncoding())
            input.builder.withQueryItem(startAfterQueryItem)
        }
        if let prefix = input.operationInput.prefix {
            let prefixQueryItem = URLQueryItem(name: "prefix".urlPercentEncoding(), value: String(prefix).urlPercentEncoding())
            input.builder.withQueryItem(prefixQueryItem)
        }
        let maxKeysQueryItem = URLQueryItem(name: "max-keys".urlPercentEncoding(), value: String(input.operationInput.maxKeys).urlPercentEncoding())
        input.builder.withQueryItem(maxKeysQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListObjectsV2Input>
    public typealias MOutput = OperationOutput<ListObjectsV2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListObjectsV2OutputError>
}

public struct ListObjectsV2Input: Equatable {
    /// <p>Bucket name to list. </p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>ContinuationToken indicates Amazon S3 that the list is being continued on this bucket with a
    ///          token. ContinuationToken is obfuscated and is not a real key.</p>
    public let continuationToken: String?
    /// <p>A delimiter is a character you use to group keys.</p>
    public let delimiter: String?
    /// <p>Encoding type used by Amazon S3 to encode object keys in the response.</p>
    public let encodingType: EncodingType?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The owner field is not present in listV2 by default, if you want to return owner field
    ///          with each key in the result then set the fetch owner field to true.</p>
    public let fetchOwner: Bool
    /// <p>Sets the maximum number of keys returned in the response. By default the action returns up
    ///          to 1,000 key names. The response might contain fewer keys but will never contain
    ///          more.</p>
    public let maxKeys: Int
    /// <p>Limits the response to keys that begin with the specified prefix.</p>
    public let prefix: String?
    /// <p>Confirms that the requester knows that she or he will be charged for the list objects
    ///          request in V2 style. Bucket owners need not specify this parameter in their
    ///          requests.</p>
    public let requestPayer: RequestPayer?
    /// <p>StartAfter is where you want Amazon S3 to start listing from. Amazon S3 starts listing after this
    ///          specified key. StartAfter can be any key in the bucket.</p>
    public let startAfter: String?

    public init (
        bucket: String? = nil,
        continuationToken: String? = nil,
        delimiter: String? = nil,
        encodingType: EncodingType? = nil,
        expectedBucketOwner: String? = nil,
        fetchOwner: Bool = false,
        maxKeys: Int = 0,
        prefix: String? = nil,
        requestPayer: RequestPayer? = nil,
        startAfter: String? = nil
    )
    {
        self.bucket = bucket
        self.continuationToken = continuationToken
        self.delimiter = delimiter
        self.encodingType = encodingType
        self.expectedBucketOwner = expectedBucketOwner
        self.fetchOwner = fetchOwner
        self.maxKeys = maxKeys
        self.prefix = prefix
        self.requestPayer = requestPayer
        self.startAfter = startAfter
    }
}

struct ListObjectsV2InputBody: Equatable {
}

extension ListObjectsV2InputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListObjectsV2OutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListObjectsV2OutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchBucket" : self = .noSuchBucket(try NoSuchBucket(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListObjectsV2OutputError: Equatable {
    case noSuchBucket(NoSuchBucket)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListObjectsV2OutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListObjectsV2OutputResponse(commonPrefixes: \(String(describing: commonPrefixes)), contents: \(String(describing: contents)), continuationToken: \(String(describing: continuationToken)), delimiter: \(String(describing: delimiter)), encodingType: \(String(describing: encodingType)), isTruncated: \(String(describing: isTruncated)), keyCount: \(String(describing: keyCount)), maxKeys: \(String(describing: maxKeys)), name: \(String(describing: name)), nextContinuationToken: \(String(describing: nextContinuationToken)), prefix: \(String(describing: prefix)), startAfter: \(String(describing: startAfter)))"}
}

extension ListObjectsV2OutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListObjectsV2OutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.commonPrefixes = output.commonPrefixes
            self.contents = output.contents
            self.continuationToken = output.continuationToken
            self.delimiter = output.delimiter
            self.encodingType = output.encodingType
            self.isTruncated = output.isTruncated
            self.keyCount = output.keyCount
            self.maxKeys = output.maxKeys
            self.name = output.name
            self.nextContinuationToken = output.nextContinuationToken
            self.prefix = output.prefix
            self.startAfter = output.startAfter
        } else {
            self.commonPrefixes = nil
            self.contents = nil
            self.continuationToken = nil
            self.delimiter = nil
            self.encodingType = nil
            self.isTruncated = false
            self.keyCount = 0
            self.maxKeys = 0
            self.name = nil
            self.nextContinuationToken = nil
            self.prefix = nil
            self.startAfter = nil
        }
    }
}

public struct ListObjectsV2OutputResponse: Equatable {
    /// <p>All of the keys (up to 1,000) rolled up into a common prefix count as a single return when calculating
    ///          the number of returns.</p>
    ///
    ///          <p>A response can contain <code>CommonPrefixes</code> only if you specify a
    ///          delimiter.</p>
    ///
    ///          <p>
    ///             <code>CommonPrefixes</code> contains all (if there are any) keys between
    ///             <code>Prefix</code> and the next occurrence of the string specified by a
    ///          delimiter.</p>
    ///
    ///          <p>
    ///             <code>CommonPrefixes</code> lists keys that act like subdirectories in the directory
    ///          specified by <code>Prefix</code>.</p>
    ///
    ///          <p>For example, if the prefix is <code>notes/</code> and the delimiter is a slash
    ///             (<code>/</code>) as in <code>notes/summer/july</code>, the common prefix is
    ///             <code>notes/summer/</code>. All of the keys that roll up into a common prefix count as a
    ///          single return when calculating the number of returns. </p>
    public let commonPrefixes: [CommonPrefix]?
    /// <p>Metadata about each object returned.</p>
    public let contents: [Object]?
    /// <p> If ContinuationToken was sent with the request, it is included in the response.</p>
    public let continuationToken: String?
    /// <p>Causes keys that contain the same string between the prefix and the first occurrence of
    ///          the delimiter to be rolled up into a single result element in the CommonPrefixes
    ///          collection. These rolled-up keys are not returned elsewhere in the response. Each rolled-up
    ///          result counts as only one return against the <code>MaxKeys</code> value.</p>
    public let delimiter: String?
    /// <p>Encoding type used by Amazon S3 to encode object key names in the XML response.</p>
    ///
    ///          <p>If you specify the encoding-type request parameter, Amazon S3 includes this element in the
    ///          response, and returns encoded key name values in the following response elements:</p>
    ///
    ///          <p>
    ///             <code>Delimiter, Prefix, Key,</code> and <code>StartAfter</code>.</p>
    public let encodingType: EncodingType?
    /// <p>Set to false if all of the results were returned. Set to true if more keys are available
    ///          to return. If the number of results exceeds that specified by MaxKeys, all of the results
    ///          might not be returned.</p>
    public let isTruncated: Bool
    /// <p>KeyCount is the number of keys returned with this request. KeyCount will always be less
    ///          than or equals to MaxKeys field. Say you ask for 50 keys, your result will include less than
    ///          equals 50 keys </p>
    public let keyCount: Int
    /// <p>Sets the maximum number of keys returned in the response. By default the action returns up
    ///          to 1,000 key names. The response might contain fewer keys but will never contain
    ///          more.</p>
    public let maxKeys: Int
    /// <p>The bucket name.</p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let name: String?
    /// <p>
    ///             <code>NextContinuationToken</code> is sent when <code>isTruncated</code> is true, which
    ///          means there are more keys in the bucket that can be listed. The next list requests to Amazon S3
    ///          can be continued with this <code>NextContinuationToken</code>.
    ///             <code>NextContinuationToken</code> is obfuscated and is not a real key</p>
    public let nextContinuationToken: String?
    /// <p> Keys that begin with the indicated prefix.</p>
    public let prefix: String?
    /// <p>If StartAfter was sent with the request, it is included in the response.</p>
    public let startAfter: String?

    public init (
        commonPrefixes: [CommonPrefix]? = nil,
        contents: [Object]? = nil,
        continuationToken: String? = nil,
        delimiter: String? = nil,
        encodingType: EncodingType? = nil,
        isTruncated: Bool = false,
        keyCount: Int = 0,
        maxKeys: Int = 0,
        name: String? = nil,
        nextContinuationToken: String? = nil,
        prefix: String? = nil,
        startAfter: String? = nil
    )
    {
        self.commonPrefixes = commonPrefixes
        self.contents = contents
        self.continuationToken = continuationToken
        self.delimiter = delimiter
        self.encodingType = encodingType
        self.isTruncated = isTruncated
        self.keyCount = keyCount
        self.maxKeys = maxKeys
        self.name = name
        self.nextContinuationToken = nextContinuationToken
        self.prefix = prefix
        self.startAfter = startAfter
    }
}

struct ListObjectsV2OutputResponseBody: Equatable {
    public let isTruncated: Bool
    public let contents: [Object]?
    public let name: String?
    public let prefix: String?
    public let delimiter: String?
    public let maxKeys: Int
    public let commonPrefixes: [CommonPrefix]?
    public let encodingType: EncodingType?
    public let keyCount: Int
    public let continuationToken: String?
    public let nextContinuationToken: String?
    public let startAfter: String?
}

extension ListObjectsV2OutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commonPrefixes = "CommonPrefixes"
        case contents = "Contents"
        case continuationToken = "ContinuationToken"
        case delimiter = "Delimiter"
        case encodingType = "EncodingType"
        case isTruncated = "IsTruncated"
        case keyCount = "KeyCount"
        case maxKeys = "MaxKeys"
        case name = "Name"
        case nextContinuationToken = "NextContinuationToken"
        case prefix = "Prefix"
        case startAfter = "StartAfter"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        if containerValues.contains(.contents) {
            let contentsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .contents)
            if contentsWrappedContainer != nil {
                let contentsContainer = try containerValues.decodeIfPresent([Object].self, forKey: .contents)
                var contentsBuffer:[Object]? = nil
                if let contentsContainer = contentsContainer {
                    contentsBuffer = [Object]()
                    for structureContainer0 in contentsContainer {
                        contentsBuffer?.append(structureContainer0)
                    }
                }
                contents = contentsBuffer
            } else {
                contents = []
            }
        } else {
            contents = nil
        }
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let maxKeysDecoded = try containerValues.decode(Int.self, forKey: .maxKeys)
        maxKeys = maxKeysDecoded
        if containerValues.contains(.commonPrefixes) {
            let commonPrefixesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .commonPrefixes)
            if commonPrefixesWrappedContainer != nil {
                let commonPrefixesContainer = try containerValues.decodeIfPresent([CommonPrefix].self, forKey: .commonPrefixes)
                var commonPrefixesBuffer:[CommonPrefix]? = nil
                if let commonPrefixesContainer = commonPrefixesContainer {
                    commonPrefixesBuffer = [CommonPrefix]()
                    for structureContainer0 in commonPrefixesContainer {
                        commonPrefixesBuffer?.append(structureContainer0)
                    }
                }
                commonPrefixes = commonPrefixesBuffer
            } else {
                commonPrefixes = []
            }
        } else {
            commonPrefixes = nil
        }
        let encodingTypeDecoded = try containerValues.decodeIfPresent(EncodingType.self, forKey: .encodingType)
        encodingType = encodingTypeDecoded
        let keyCountDecoded = try containerValues.decode(Int.self, forKey: .keyCount)
        keyCount = keyCountDecoded
        let continuationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .continuationToken)
        continuationToken = continuationTokenDecoded
        let nextContinuationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextContinuationToken)
        nextContinuationToken = nextContinuationTokenDecoded
        let startAfterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startAfter)
        startAfter = startAfterDecoded
    }
}

extension ListPartsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPartsInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), key: \(String(describing: key)), maxParts: \(String(describing: maxParts)), partNumberMarker: \(String(describing: partNumberMarker)), requestPayer: \(String(describing: requestPayer)), uploadId: \(String(describing: uploadId)))"}
}

extension ListPartsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPartsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPartsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPartsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPartsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPartsInput>
    public typealias MOutput = OperationOutput<ListPartsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPartsOutputError>
}

public struct ListPartsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPartsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPartsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPartsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "x-id", value: "ListParts"))
        if let partNumberMarker = input.operationInput.partNumberMarker {
            let partNumberMarkerQueryItem = URLQueryItem(name: "part-number-marker".urlPercentEncoding(), value: String(partNumberMarker).urlPercentEncoding())
            input.builder.withQueryItem(partNumberMarkerQueryItem)
        }
        let maxPartsQueryItem = URLQueryItem(name: "max-parts".urlPercentEncoding(), value: String(input.operationInput.maxParts).urlPercentEncoding())
        input.builder.withQueryItem(maxPartsQueryItem)
        if let uploadId = input.operationInput.uploadId {
            let uploadIdQueryItem = URLQueryItem(name: "uploadId".urlPercentEncoding(), value: String(uploadId).urlPercentEncoding())
            input.builder.withQueryItem(uploadIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPartsInput>
    public typealias MOutput = OperationOutput<ListPartsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPartsOutputError>
}

public struct ListPartsInput: Equatable {
    /// <p>The name of the bucket to which the parts are being uploaded. </p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>Object key for which the multipart upload was initiated.</p>
    public let key: String?
    /// <p>Sets the maximum number of parts to return.</p>
    public let maxParts: Int
    /// <p>Specifies the part after which listing should begin. Only parts with higher part numbers
    ///          will be listed.</p>
    public let partNumberMarker: String?
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    ///          owners need not specify this parameter in their requests. For information about downloading
    ///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    ///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let requestPayer: RequestPayer?
    /// <p>Upload ID identifying the multipart upload whose parts are being listed.</p>
    public let uploadId: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        key: String? = nil,
        maxParts: Int = 0,
        partNumberMarker: String? = nil,
        requestPayer: RequestPayer? = nil,
        uploadId: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.maxParts = maxParts
        self.partNumberMarker = partNumberMarker
        self.requestPayer = requestPayer
        self.uploadId = uploadId
    }
}

struct ListPartsInputBody: Equatable {
}

extension ListPartsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPartsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListPartsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPartsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPartsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPartsOutputResponse(abortDate: \(String(describing: abortDate)), abortRuleId: \(String(describing: abortRuleId)), bucket: \(String(describing: bucket)), initiator: \(String(describing: initiator)), isTruncated: \(String(describing: isTruncated)), key: \(String(describing: key)), maxParts: \(String(describing: maxParts)), nextPartNumberMarker: \(String(describing: nextPartNumberMarker)), owner: \(String(describing: owner)), partNumberMarker: \(String(describing: partNumberMarker)), parts: \(String(describing: parts)), requestCharged: \(String(describing: requestCharged)), storageClass: \(String(describing: storageClass)), uploadId: \(String(describing: uploadId)))"}
}

extension ListPartsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let abortDateHeaderValue = httpResponse.headers.value(for: "x-amz-abort-date") {
            self.abortDate = DateFormatter.rfc5322DateFormatter.date(from: abortDateHeaderValue)
        } else {
            self.abortDate = nil
        }
        if let abortRuleIdHeaderValue = httpResponse.headers.value(for: "x-amz-abort-rule-id") {
            self.abortRuleId = abortRuleIdHeaderValue
        } else {
            self.abortRuleId = nil
        }
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPartsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.bucket = output.bucket
            self.initiator = output.initiator
            self.isTruncated = output.isTruncated
            self.key = output.key
            self.maxParts = output.maxParts
            self.nextPartNumberMarker = output.nextPartNumberMarker
            self.owner = output.owner
            self.partNumberMarker = output.partNumberMarker
            self.parts = output.parts
            self.storageClass = output.storageClass
            self.uploadId = output.uploadId
        } else {
            self.bucket = nil
            self.initiator = nil
            self.isTruncated = false
            self.key = nil
            self.maxParts = 0
            self.nextPartNumberMarker = nil
            self.owner = nil
            self.partNumberMarker = nil
            self.parts = nil
            self.storageClass = nil
            self.uploadId = nil
        }
    }
}

public struct ListPartsOutputResponse: Equatable {
    /// <p>If the bucket has a lifecycle rule configured with an action to abort incomplete
    ///          multipart uploads and the prefix in the lifecycle rule matches the object name in the
    ///          request, then the response includes this header indicating when the initiated multipart
    ///          upload will become eligible for abort operation. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config">Aborting
    ///             Incomplete Multipart Uploads Using a Bucket Lifecycle Policy</a>.</p>
    ///
    ///          <p>The response will also include the <code>x-amz-abort-rule-id</code> header that will
    ///          provide the ID of the lifecycle configuration rule that defines this action.</p>
    public let abortDate: Date?
    /// <p>This header is returned along with the <code>x-amz-abort-date</code> header. It
    ///          identifies applicable lifecycle configuration rule that defines the action to abort
    ///          incomplete multipart uploads.</p>
    public let abortRuleId: String?
    /// <p>The name of the bucket to which the multipart upload was initiated.</p>
    public let bucket: String?
    /// <p>Container element that identifies who initiated the multipart upload. If the initiator
    ///          is an AWS account, this element provides the same information as the <code>Owner</code>
    ///          element. If the initiator is an IAM User, this element provides the user ARN and display
    ///          name.</p>
    public let initiator: Initiator?
    /// <p> Indicates whether the returned list of parts is truncated. A true value indicates that
    ///          the list was truncated. A list can be truncated if the number of parts exceeds the limit
    ///          returned in the MaxParts element.</p>
    public let isTruncated: Bool
    /// <p>Object key for which the multipart upload was initiated.</p>
    public let key: String?
    /// <p>Maximum number of parts that were allowed in the response.</p>
    public let maxParts: Int
    /// <p>When a list is truncated, this element specifies the last part in the list, as well as
    ///          the value to use for the part-number-marker request parameter in a subsequent
    ///          request.</p>
    public let nextPartNumberMarker: String?
    /// <p> Container element that identifies the object owner, after the object is created. If
    ///          multipart upload is initiated by an IAM user, this element provides the parent account ID
    ///          and display name.</p>
    public let owner: Owner?
    /// <p>When a list is truncated, this element specifies the last part in the list, as well as
    ///          the value to use for the part-number-marker request parameter in a subsequent
    ///          request.</p>
    public let partNumberMarker: String?
    /// <p> Container for elements related to a particular part. A response can contain zero or
    ///          more <code>Part</code> elements.</p>
    public let parts: [Part]?
    /// <p>If present, indicates that the requester was successfully charged for the
    ///          request.</p>
    public let requestCharged: RequestCharged?
    /// <p>Class of storage (STANDARD or REDUCED_REDUNDANCY) used to store the uploaded
    ///          object.</p>
    public let storageClass: StorageClass?
    /// <p>Upload ID identifying the multipart upload whose parts are being listed.</p>
    public let uploadId: String?

    public init (
        abortDate: Date? = nil,
        abortRuleId: String? = nil,
        bucket: String? = nil,
        initiator: Initiator? = nil,
        isTruncated: Bool = false,
        key: String? = nil,
        maxParts: Int = 0,
        nextPartNumberMarker: String? = nil,
        owner: Owner? = nil,
        partNumberMarker: String? = nil,
        parts: [Part]? = nil,
        requestCharged: RequestCharged? = nil,
        storageClass: StorageClass? = nil,
        uploadId: String? = nil
    )
    {
        self.abortDate = abortDate
        self.abortRuleId = abortRuleId
        self.bucket = bucket
        self.initiator = initiator
        self.isTruncated = isTruncated
        self.key = key
        self.maxParts = maxParts
        self.nextPartNumberMarker = nextPartNumberMarker
        self.owner = owner
        self.partNumberMarker = partNumberMarker
        self.parts = parts
        self.requestCharged = requestCharged
        self.storageClass = storageClass
        self.uploadId = uploadId
    }
}

struct ListPartsOutputResponseBody: Equatable {
    public let bucket: String?
    public let key: String?
    public let uploadId: String?
    public let partNumberMarker: String?
    public let nextPartNumberMarker: String?
    public let maxParts: Int
    public let isTruncated: Bool
    public let parts: [Part]?
    public let initiator: Initiator?
    public let owner: Owner?
    public let storageClass: StorageClass?
}

extension ListPartsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case initiator = "Initiator"
        case isTruncated = "IsTruncated"
        case key = "Key"
        case maxParts = "MaxParts"
        case nextPartNumberMarker = "NextPartNumberMarker"
        case owner = "Owner"
        case partNumberMarker = "PartNumberMarker"
        case parts = "Part"
        case storageClass = "StorageClass"
        case uploadId = "UploadId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let partNumberMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partNumberMarker)
        partNumberMarker = partNumberMarkerDecoded
        let nextPartNumberMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPartNumberMarker)
        nextPartNumberMarker = nextPartNumberMarkerDecoded
        let maxPartsDecoded = try containerValues.decode(Int.self, forKey: .maxParts)
        maxParts = maxPartsDecoded
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        if containerValues.contains(.parts) {
            let partsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .parts)
            if partsWrappedContainer != nil {
                let partsContainer = try containerValues.decodeIfPresent([Part].self, forKey: .parts)
                var partsBuffer:[Part]? = nil
                if let partsContainer = partsContainer {
                    partsBuffer = [Part]()
                    for structureContainer0 in partsContainer {
                        partsBuffer?.append(structureContainer0)
                    }
                }
                parts = partsBuffer
            } else {
                parts = []
            }
        } else {
            parts = nil
        }
        let initiatorDecoded = try containerValues.decodeIfPresent(Initiator.self, forKey: .initiator)
        initiator = initiatorDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Owner.self, forKey: .owner)
        owner = ownerDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

extension LoggingEnabled: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case targetBucket = "TargetBucket"
        case targetGrants = "TargetGrants"
        case targetPrefix = "TargetPrefix"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let targetBucket = targetBucket {
            try container.encode(targetBucket, forKey: Key("targetBucket"))
        }
        if let targetGrants = targetGrants {
            var targetGrantsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("targetGrants"))
            for targetgrant0 in targetGrants {
                try targetGrantsContainer.encode(targetgrant0, forKey: Key("Grant"))
            }
        }
        if let targetPrefix = targetPrefix {
            try container.encode(targetPrefix, forKey: Key("targetPrefix"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetBucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetBucket)
        targetBucket = targetBucketDecoded
        if containerValues.contains(.targetGrants) {
            struct KeyVal0{struct Grant{}}
            let targetGrantsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Grant>.CodingKeys.self, forKey: .targetGrants)
            if let targetGrantsWrappedContainer = targetGrantsWrappedContainer {
                let targetGrantsContainer = try targetGrantsWrappedContainer.decodeIfPresent([TargetGrant].self, forKey: .member)
                var targetGrantsBuffer:[TargetGrant]? = nil
                if let targetGrantsContainer = targetGrantsContainer {
                    targetGrantsBuffer = [TargetGrant]()
                    for structureContainer0 in targetGrantsContainer {
                        targetGrantsBuffer?.append(structureContainer0)
                    }
                }
                targetGrants = targetGrantsBuffer
            } else {
                targetGrants = []
            }
        } else {
            targetGrants = nil
        }
        let targetPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetPrefix)
        targetPrefix = targetPrefixDecoded
    }
}

extension LoggingEnabled: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoggingEnabled(targetBucket: \(String(describing: targetBucket)), targetGrants: \(String(describing: targetGrants)), targetPrefix: \(String(describing: targetPrefix)))"}
}

extension LoggingEnabled: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Describes where logs are stored and the prefix that Amazon S3 assigns to all log object keys
///          for a bucket. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTlogging.html">PUT Bucket logging</a> in the
///             <i>Amazon S3 API Reference</i>.</p>
public struct LoggingEnabled: Equatable {
    /// <p>Specifies the bucket where you want Amazon S3 to store server access logs. You can have your
    ///          logs delivered to any bucket that you own, including the same bucket that is being logged.
    ///          You can also configure multiple buckets to deliver their logs to the same target bucket. In
    ///          this case, you should choose a different <code>TargetPrefix</code> for each source bucket
    ///          so that the delivered log files can be distinguished by key.</p>
    public let targetBucket: String?
    /// <p>Container for granting information.</p>
    public let targetGrants: [TargetGrant]?
    /// <p>A prefix for all log object keys. If you store log files from multiple Amazon S3 buckets in a
    ///          single bucket, you can use a prefix to distinguish which log files came from which
    ///          bucket.</p>
    public let targetPrefix: String?

    public init (
        targetBucket: String? = nil,
        targetGrants: [TargetGrant]? = nil,
        targetPrefix: String? = nil
    )
    {
        self.targetBucket = targetBucket
        self.targetGrants = targetGrants
        self.targetPrefix = targetPrefix
    }
}

public enum MFADelete {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension MFADelete : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MFADelete] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "Disabled"
        case .enabled: return "Enabled"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MFADelete(rawValue: rawValue) ?? MFADelete.sdkUnknown(rawValue)
    }
}

public enum MFADeleteStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension MFADeleteStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MFADeleteStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "Disabled"
        case .enabled: return "Enabled"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MFADeleteStatus(rawValue: rawValue) ?? MFADeleteStatus.sdkUnknown(rawValue)
    }
}

public enum MetadataDirective {
    case copy
    case replace
    case sdkUnknown(String)
}

extension MetadataDirective : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MetadataDirective] {
        return [
            .copy,
            .replace,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .copy: return "COPY"
        case .replace: return "REPLACE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MetadataDirective(rawValue: rawValue) ?? MetadataDirective.sdkUnknown(rawValue)
    }
}

extension MetadataEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("name"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MetadataEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetadataEntry(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

extension MetadataEntry: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A metadata key-value pair to store with an object.</p>
public struct MetadataEntry: Equatable {
    /// <p>Name of the Object.</p>
    public let name: String?
    /// <p>Value of the Object.</p>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

extension Metrics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventThreshold = "EventThreshold"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let eventThreshold = eventThreshold {
            try container.encode(eventThreshold, forKey: Key("eventThreshold"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(MetricsStatus.self, forKey: .status)
        status = statusDecoded
        let eventThresholdDecoded = try containerValues.decodeIfPresent(ReplicationTimeValue.self, forKey: .eventThreshold)
        eventThreshold = eventThresholdDecoded
    }
}

extension Metrics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Metrics(eventThreshold: \(String(describing: eventThreshold)), status: \(String(describing: status)))"}
}

extension Metrics: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p> A container specifying replication metrics-related settings enabling replication
///          metrics and events.</p>
public struct Metrics: Equatable {
    /// <p> A container specifying the time threshold for emitting the
    ///             <code>s3:Replication:OperationMissedThreshold</code> event. </p>
    public let eventThreshold: ReplicationTimeValue?
    /// <p> Specifies whether the replication metrics are enabled. </p>
    public let status: MetricsStatus?

    public init (
        eventThreshold: ReplicationTimeValue? = nil,
        status: MetricsStatus? = nil
    )
    {
        self.eventThreshold = eventThreshold
        self.status = status
    }
}

extension MetricsAndOperator: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case prefix = "Prefix"
        case tags = "Tag"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let prefix = prefix {
            try container.encode(prefix, forKey: Key("prefix"))
        }
        if let tags = tags {
            if tags.isEmpty {
                var tagsContainer = container.nestedUnkeyedContainer(forKey: Key("Tag"))
                try tagsContainer.encodeNil()
            } else {
                for tag0 in tags {
                    var tagsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tag"))
                    try tagsContainer0.encode(tag0, forKey: Key(""))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        if containerValues.contains(.tags) {
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .tags)
            if tagsWrappedContainer != nil {
                let tagsContainer = try containerValues.decodeIfPresent([Tag].self, forKey: .tags)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension MetricsAndOperator: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetricsAndOperator(prefix: \(String(describing: prefix)), tags: \(String(describing: tags)))"}
}

extension MetricsAndOperator: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A conjunction (logical AND) of predicates, which is used in evaluating a metrics filter.
///          The operator must have at least two predicates, and an object must match all of the
///          predicates in order for the filter to apply.</p>
public struct MetricsAndOperator: Equatable {
    /// <p>The prefix used when evaluating an AND predicate.</p>
    public let prefix: String?
    /// <p>The list of tags used when evaluating an AND predicate.</p>
    public let tags: [Tag]?

    public init (
        prefix: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.prefix = prefix
        self.tags = tags
    }
}

extension MetricsConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let filter = filter {
            try container.encode(filter, forKey: Key("filter"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let filterDecoded = try containerValues.decodeIfPresent(MetricsFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension MetricsConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetricsConfiguration(filter: \(String(describing: filter)), id: \(String(describing: id)))"}
}

extension MetricsConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies a metrics configuration for the CloudWatch request metrics (specified by the
///          metrics configuration ID) from an Amazon S3 bucket. If you're updating an existing metrics
///          configuration, note that this is a full replacement of the existing metrics configuration.
///          If you don't include the elements you want to keep, they are erased. For more information,
///          see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTMetricConfiguration.html"> PUT Bucket
///             metrics</a> in the <i>Amazon S3 API Reference</i>.</p>
public struct MetricsConfiguration: Equatable {
    /// <p>Specifies a metrics configuration filter. The metrics configuration will only include
    ///          objects that meet the filter's criteria. A filter must be a prefix, a tag, or a conjunction
    ///          (MetricsAndOperator).</p>
    public let filter: MetricsFilter?
    /// <p>The ID used to identify the metrics configuration.</p>
    public let id: String?

    public init (
        filter: MetricsFilter? = nil,
        id: String? = nil
    )
    {
        self.filter = filter
        self.id = id
    }
}

extension MetricsFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case and = "And"
        case prefix = "Prefix"
        case tag = "Tag"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        switch self {
            case let .and(and):
                if let and = and {
                    try container.encode(and, forKey: Key("and"))
                }
            case let .prefix(prefix):
                if let prefix = prefix {
                    try container.encode(prefix, forKey: Key("prefix"))
                }
            case let .tag(tag):
                if let tag = tag {
                    try container.encode(tag, forKey: Key("tag"))
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: Key("sdkUnknown"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        if let prefix = prefixDecoded {
            self = .prefix(prefix)
            return
        }
        let tagDecoded = try containerValues.decodeIfPresent(Tag.self, forKey: .tag)
        if let tag = tagDecoded {
            self = .tag(tag)
            return
        }
        let andDecoded = try containerValues.decodeIfPresent(MetricsAndOperator.self, forKey: .and)
        if let and = andDecoded {
            self = .and(and)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>Specifies a metrics configuration filter. The metrics configuration only includes
///          objects that meet the filter's criteria. A filter must be a prefix, a tag, or a conjunction
///          (MetricsAndOperator).</p>
public enum MetricsFilter: Equatable {
    /// <p>The prefix used when evaluating a metrics filter.</p>
    case prefix(String?)
    /// <p>The tag used when evaluating a metrics filter.</p>
    case tag(Tag?)
    /// <p>A conjunction (logical AND) of predicates, which is used in evaluating a metrics filter.
    ///          The operator must have at least two predicates, and an object must match all of the
    ///          predicates in order for the filter to apply.</p>
    case and(MetricsAndOperator?)
    case sdkUnknown(String?)
}

public enum MetricsStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension MetricsStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MetricsStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "Disabled"
        case .enabled: return "Enabled"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MetricsStatus(rawValue: rawValue) ?? MetricsStatus.sdkUnknown(rawValue)
    }
}

extension MultipartUpload: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case initiated = "Initiated"
        case initiator = "Initiator"
        case key = "Key"
        case owner = "Owner"
        case storageClass = "StorageClass"
        case uploadId = "UploadId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let initiated = initiated {
            try container.encode(TimestampWrapper(initiated, format: .dateTime), forKey: Key("initiated"))
        }
        if let initiator = initiator {
            try container.encode(initiator, forKey: Key("initiator"))
        }
        if let key = key {
            try container.encode(key, forKey: Key("key"))
        }
        if let owner = owner {
            try container.encode(owner, forKey: Key("owner"))
        }
        if let storageClass = storageClass {
            try container.encode(storageClass, forKey: Key("storageClass"))
        }
        if let uploadId = uploadId {
            try container.encode(uploadId, forKey: Key("uploadId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let initiatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .initiated)
        var initiatedBuffer:Date? = nil
        if let initiatedDecoded = initiatedDecoded {
            initiatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(initiatedDecoded, format: .dateTime)
        }
        initiated = initiatedBuffer
        let storageClassDecoded = try containerValues.decodeIfPresent(StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Owner.self, forKey: .owner)
        owner = ownerDecoded
        let initiatorDecoded = try containerValues.decodeIfPresent(Initiator.self, forKey: .initiator)
        initiator = initiatorDecoded
    }
}

extension MultipartUpload: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MultipartUpload(initiated: \(String(describing: initiated)), initiator: \(String(describing: initiator)), key: \(String(describing: key)), owner: \(String(describing: owner)), storageClass: \(String(describing: storageClass)), uploadId: \(String(describing: uploadId)))"}
}

extension MultipartUpload: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container for the <code>MultipartUpload</code> for the Amazon S3 object.</p>
public struct MultipartUpload: Equatable {
    /// <p>Date and time at which the multipart upload was initiated.</p>
    public let initiated: Date?
    /// <p>Identifies who initiated the multipart upload.</p>
    public let initiator: Initiator?
    /// <p>Key of the object for which the multipart upload was initiated.</p>
    public let key: String?
    /// <p>Specifies the owner of the object that is part of the multipart upload. </p>
    public let owner: Owner?
    /// <p>The class of storage used to store the object.</p>
    public let storageClass: StorageClass?
    /// <p>Upload ID that identifies the multipart upload.</p>
    public let uploadId: String?

    public init (
        initiated: Date? = nil,
        initiator: Initiator? = nil,
        key: String? = nil,
        owner: Owner? = nil,
        storageClass: StorageClass? = nil,
        uploadId: String? = nil
    )
    {
        self.initiated = initiated
        self.initiator = initiator
        self.key = key
        self.owner = owner
        self.storageClass = storageClass
        self.uploadId = uploadId
    }
}

extension NoSuchBucket: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchBucket()"}
}

extension NoSuchBucket: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified bucket does not exist.</p>
public struct NoSuchBucket: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

extension NoSuchKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchKey()"}
}

extension NoSuchKey: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified key does not exist.</p>
public struct NoSuchKey: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

extension NoSuchUpload: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchUpload()"}
}

extension NoSuchUpload: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified multipart upload does not exist.</p>
public struct NoSuchUpload: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

extension NoncurrentVersionExpiration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case noncurrentDays = "NoncurrentDays"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if noncurrentDays != 0 {
            try container.encode(noncurrentDays, forKey: Key("noncurrentDays"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noncurrentDaysDecoded = try containerValues.decode(Int.self, forKey: .noncurrentDays)
        noncurrentDays = noncurrentDaysDecoded
    }
}

extension NoncurrentVersionExpiration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoncurrentVersionExpiration(noncurrentDays: \(String(describing: noncurrentDays)))"}
}

extension NoncurrentVersionExpiration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies when noncurrent object versions expire. Upon expiration, Amazon S3 permanently
///          deletes the noncurrent object versions. You set this lifecycle configuration action on a
///          bucket that has versioning enabled (or suspended) to request that Amazon S3 delete noncurrent
///          object versions at a specific period in the object's lifetime.</p>
public struct NoncurrentVersionExpiration: Equatable {
    /// <p>Specifies the number of days an object is noncurrent before Amazon S3 can perform the
    ///          associated action. For information about the noncurrent days calculations, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#non-current-days-calculations">How
    ///             Amazon S3 Calculates When an Object Became Noncurrent</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let noncurrentDays: Int

    public init (
        noncurrentDays: Int = 0
    )
    {
        self.noncurrentDays = noncurrentDays
    }
}

extension NoncurrentVersionTransition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case noncurrentDays = "NoncurrentDays"
        case storageClass = "StorageClass"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if noncurrentDays != 0 {
            try container.encode(noncurrentDays, forKey: Key("noncurrentDays"))
        }
        if let storageClass = storageClass {
            try container.encode(storageClass, forKey: Key("storageClass"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noncurrentDaysDecoded = try containerValues.decode(Int.self, forKey: .noncurrentDays)
        noncurrentDays = noncurrentDaysDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(TransitionStorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

extension NoncurrentVersionTransition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoncurrentVersionTransition(noncurrentDays: \(String(describing: noncurrentDays)), storageClass: \(String(describing: storageClass)))"}
}

extension NoncurrentVersionTransition: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container for the transition rule that describes when noncurrent objects transition to
///          the <code>STANDARD_IA</code>, <code>ONEZONE_IA</code>, <code>INTELLIGENT_TIERING</code>,
///             <code>GLACIER</code>, or <code>DEEP_ARCHIVE</code> storage class. If your bucket is
///          versioning-enabled (or versioning is suspended), you can set this action to request that
///          Amazon S3 transition noncurrent object versions to the <code>STANDARD_IA</code>,
///             <code>ONEZONE_IA</code>, <code>INTELLIGENT_TIERING</code>, <code>GLACIER</code>, or
///             <code>DEEP_ARCHIVE</code> storage class at a specific period in the object's
///          lifetime.</p>
public struct NoncurrentVersionTransition: Equatable {
    /// <p>Specifies the number of days an object is noncurrent before Amazon S3 can perform the
    ///          associated action. For information about the noncurrent days calculations, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#non-current-days-calculations">How
    ///             Amazon S3 Calculates How Long an Object Has Been Noncurrent</a> in the
    ///             <i>Amazon S3 User Guide</i>.</p>
    public let noncurrentDays: Int
    /// <p>The class of storage used to store the object.</p>
    public let storageClass: TransitionStorageClass?

    public init (
        noncurrentDays: Int = 0,
        storageClass: TransitionStorageClass? = nil
    )
    {
        self.noncurrentDays = noncurrentDays
        self.storageClass = storageClass
    }
}

extension NotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFound()"}
}

extension NotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified content does not exist.</p>
public struct NotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

extension NotificationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lambdaFunctionConfigurations = "CloudFunctionConfiguration"
        case queueConfigurations = "QueueConfiguration"
        case topicConfigurations = "TopicConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let lambdaFunctionConfigurations = lambdaFunctionConfigurations {
            if lambdaFunctionConfigurations.isEmpty {
                var lambdaFunctionConfigurationsContainer = container.nestedUnkeyedContainer(forKey: Key("CloudFunctionConfiguration"))
                try lambdaFunctionConfigurationsContainer.encodeNil()
            } else {
                for lambdafunctionconfiguration0 in lambdaFunctionConfigurations {
                    var lambdaFunctionConfigurationsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("CloudFunctionConfiguration"))
                    try lambdaFunctionConfigurationsContainer0.encode(lambdafunctionconfiguration0, forKey: Key(""))
                }
            }
        }
        if let queueConfigurations = queueConfigurations {
            if queueConfigurations.isEmpty {
                var queueConfigurationsContainer = container.nestedUnkeyedContainer(forKey: Key("QueueConfiguration"))
                try queueConfigurationsContainer.encodeNil()
            } else {
                for queueconfiguration0 in queueConfigurations {
                    var queueConfigurationsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("QueueConfiguration"))
                    try queueConfigurationsContainer0.encode(queueconfiguration0, forKey: Key(""))
                }
            }
        }
        if let topicConfigurations = topicConfigurations {
            if topicConfigurations.isEmpty {
                var topicConfigurationsContainer = container.nestedUnkeyedContainer(forKey: Key("TopicConfiguration"))
                try topicConfigurationsContainer.encodeNil()
            } else {
                for topicconfiguration0 in topicConfigurations {
                    var topicConfigurationsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("TopicConfiguration"))
                    try topicConfigurationsContainer0.encode(topicconfiguration0, forKey: Key(""))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.topicConfigurations) {
            let topicConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .topicConfigurations)
            if topicConfigurationsWrappedContainer != nil {
                let topicConfigurationsContainer = try containerValues.decodeIfPresent([TopicConfiguration].self, forKey: .topicConfigurations)
                var topicConfigurationsBuffer:[TopicConfiguration]? = nil
                if let topicConfigurationsContainer = topicConfigurationsContainer {
                    topicConfigurationsBuffer = [TopicConfiguration]()
                    for structureContainer0 in topicConfigurationsContainer {
                        topicConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                topicConfigurations = topicConfigurationsBuffer
            } else {
                topicConfigurations = []
            }
        } else {
            topicConfigurations = nil
        }
        if containerValues.contains(.queueConfigurations) {
            let queueConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .queueConfigurations)
            if queueConfigurationsWrappedContainer != nil {
                let queueConfigurationsContainer = try containerValues.decodeIfPresent([QueueConfiguration].self, forKey: .queueConfigurations)
                var queueConfigurationsBuffer:[QueueConfiguration]? = nil
                if let queueConfigurationsContainer = queueConfigurationsContainer {
                    queueConfigurationsBuffer = [QueueConfiguration]()
                    for structureContainer0 in queueConfigurationsContainer {
                        queueConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                queueConfigurations = queueConfigurationsBuffer
            } else {
                queueConfigurations = []
            }
        } else {
            queueConfigurations = nil
        }
        if containerValues.contains(.lambdaFunctionConfigurations) {
            let lambdaFunctionConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .lambdaFunctionConfigurations)
            if lambdaFunctionConfigurationsWrappedContainer != nil {
                let lambdaFunctionConfigurationsContainer = try containerValues.decodeIfPresent([LambdaFunctionConfiguration].self, forKey: .lambdaFunctionConfigurations)
                var lambdaFunctionConfigurationsBuffer:[LambdaFunctionConfiguration]? = nil
                if let lambdaFunctionConfigurationsContainer = lambdaFunctionConfigurationsContainer {
                    lambdaFunctionConfigurationsBuffer = [LambdaFunctionConfiguration]()
                    for structureContainer0 in lambdaFunctionConfigurationsContainer {
                        lambdaFunctionConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                lambdaFunctionConfigurations = lambdaFunctionConfigurationsBuffer
            } else {
                lambdaFunctionConfigurations = []
            }
        } else {
            lambdaFunctionConfigurations = nil
        }
    }
}

extension NotificationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotificationConfiguration(lambdaFunctionConfigurations: \(String(describing: lambdaFunctionConfigurations)), queueConfigurations: \(String(describing: queueConfigurations)), topicConfigurations: \(String(describing: topicConfigurations)))"}
}

extension NotificationConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container for specifying the notification configuration of the bucket. If this element
///          is empty, notifications are turned off for the bucket.</p>
public struct NotificationConfiguration: Equatable {
    /// <p>Describes the AWS Lambda functions to invoke and the events for which to invoke
    ///          them.</p>
    public let lambdaFunctionConfigurations: [LambdaFunctionConfiguration]?
    /// <p>The Amazon Simple Queue Service queues to publish messages to and the events for which
    ///          to publish messages.</p>
    public let queueConfigurations: [QueueConfiguration]?
    /// <p>The topic to which notifications are sent and the events for which notifications are
    ///          generated.</p>
    public let topicConfigurations: [TopicConfiguration]?

    public init (
        lambdaFunctionConfigurations: [LambdaFunctionConfiguration]? = nil,
        queueConfigurations: [QueueConfiguration]? = nil,
        topicConfigurations: [TopicConfiguration]? = nil
    )
    {
        self.lambdaFunctionConfigurations = lambdaFunctionConfigurations
        self.queueConfigurations = queueConfigurations
        self.topicConfigurations = topicConfigurations
    }
}

extension NotificationConfigurationFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "S3Key"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let key = key {
            try container.encode(key, forKey: Key("S3Key"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(S3KeyFilter.self, forKey: .key)
        key = keyDecoded
    }
}

extension NotificationConfigurationFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotificationConfigurationFilter(key: \(String(describing: key)))"}
}

extension NotificationConfigurationFilter: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies object key name filtering rules. For information about key name filtering, see
///             <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html">Configuring
///             Event Notifications</a> in the <i>Amazon S3 User Guide</i>.</p>
public struct NotificationConfigurationFilter: Equatable {
    /// <p>A container for object key name prefix and suffix filtering rules.</p>
    public let key: S3KeyFilter?

    public init (
        key: S3KeyFilter? = nil
    )
    {
        self.key = key
    }
}

extension Object: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eTag = "ETag"
        case key = "Key"
        case lastModified = "LastModified"
        case owner = "Owner"
        case size = "Size"
        case storageClass = "StorageClass"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let eTag = eTag {
            try container.encode(eTag, forKey: Key("eTag"))
        }
        if let key = key {
            try container.encode(key, forKey: Key("key"))
        }
        if let lastModified = lastModified {
            try container.encode(TimestampWrapper(lastModified, format: .dateTime), forKey: Key("lastModified"))
        }
        if let owner = owner {
            try container.encode(owner, forKey: Key("owner"))
        }
        if size != 0 {
            try container.encode(size, forKey: Key("size"))
        }
        if let storageClass = storageClass {
            try container.encode(storageClass, forKey: Key("storageClass"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModified)
        var lastModifiedBuffer:Date? = nil
        if let lastModifiedDecoded = lastModifiedDecoded {
            lastModifiedBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastModifiedDecoded, format: .dateTime)
        }
        lastModified = lastModifiedBuffer
        let eTagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eTag)
        eTag = eTagDecoded
        let sizeDecoded = try containerValues.decode(Int.self, forKey: .size)
        size = sizeDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(ObjectStorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Owner.self, forKey: .owner)
        owner = ownerDecoded
    }
}

extension Object: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Object(eTag: \(String(describing: eTag)), key: \(String(describing: key)), lastModified: \(String(describing: lastModified)), owner: \(String(describing: owner)), size: \(String(describing: size)), storageClass: \(String(describing: storageClass)))"}
}

extension Object: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>An object consists of data and its descriptive metadata.</p>
public struct Object: Equatable {
    /// <p>The entity tag is a hash of the object. The ETag reflects changes only to the contents
    ///          of an object, not its metadata. The ETag may or may not be an MD5 digest of the object
    ///          data. Whether or not it is depends on how the object was created and how it is encrypted as
    ///          described below:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Objects created by the PUT Object, POST Object, or Copy operation, or through the
    ///                AWS Management Console, and are encrypted by SSE-S3 or plaintext, have ETags that are
    ///                an MD5 digest of their object data.</p>
    ///             </li>
    ///             <li>
    ///                <p>Objects created by the PUT Object, POST Object, or Copy operation, or through the
    ///                AWS Management Console, and are encrypted by SSE-C or SSE-KMS, have ETags that are
    ///                not an MD5 digest of their object data.</p>
    ///             </li>
    ///             <li>
    ///                <p>If an object is created by either the Multipart Upload or Part Copy operation, the
    ///                ETag is not an MD5 digest, regardless of the method of encryption.</p>
    ///             </li>
    ///          </ul>
    public let eTag: String?
    /// <p>The name that you assign to an object. You use the object key to retrieve the
    ///          object.</p>
    public let key: String?
    /// <p>Creation date of the object.</p>
    public let lastModified: Date?
    /// <p>The owner of the object</p>
    public let owner: Owner?
    /// <p>Size in bytes of the object</p>
    public let size: Int
    /// <p>The class of storage used to store the object.</p>
    public let storageClass: ObjectStorageClass?

    public init (
        eTag: String? = nil,
        key: String? = nil,
        lastModified: Date? = nil,
        owner: Owner? = nil,
        size: Int = 0,
        storageClass: ObjectStorageClass? = nil
    )
    {
        self.eTag = eTag
        self.key = key
        self.lastModified = lastModified
        self.owner = owner
        self.size = size
        self.storageClass = storageClass
    }
}

extension ObjectAlreadyInActiveTierError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectAlreadyInActiveTierError()"}
}

extension ObjectAlreadyInActiveTierError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This action is not allowed against this storage tier.</p>
public struct ObjectAlreadyInActiveTierError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

public enum ObjectCannedACL {
    case authenticatedRead
    case awsExecRead
    case bucketOwnerFullControl
    case bucketOwnerRead
    case `private`
    case publicRead
    case publicReadWrite
    case sdkUnknown(String)
}

extension ObjectCannedACL : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ObjectCannedACL] {
        return [
            .authenticatedRead,
            .awsExecRead,
            .bucketOwnerFullControl,
            .bucketOwnerRead,
            .private,
            .publicRead,
            .publicReadWrite,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .authenticatedRead: return "authenticated-read"
        case .awsExecRead: return "aws-exec-read"
        case .bucketOwnerFullControl: return "bucket-owner-full-control"
        case .bucketOwnerRead: return "bucket-owner-read"
        case .private: return "private"
        case .publicRead: return "public-read"
        case .publicReadWrite: return "public-read-write"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ObjectCannedACL(rawValue: rawValue) ?? ObjectCannedACL.sdkUnknown(rawValue)
    }
}

extension ObjectIdentifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let key = key {
            try container.encode(key, forKey: Key("key"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: Key("versionId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension ObjectIdentifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectIdentifier(key: \(String(describing: key)), versionId: \(String(describing: versionId)))"}
}

extension ObjectIdentifier: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Object Identifier is unique value to identify objects.</p>
public struct ObjectIdentifier: Equatable {
    /// <p>Key name of the object.</p>
    ///          <important>
    ///             <p>Replacement must be made for object keys containing special characters (such as carriage returns) when using
    ///          XML requests. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints">
    ///             XML related object key constraints</a>.</p>
    ///          </important>
    public let key: String?
    /// <p>VersionId for the specific version of the object to delete.</p>
    public let versionId: String?

    public init (
        key: String? = nil,
        versionId: String? = nil
    )
    {
        self.key = key
        self.versionId = versionId
    }
}

extension ObjectLockConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectLockEnabled = "ObjectLockEnabled"
        case rule = "Rule"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let objectLockEnabled = objectLockEnabled {
            try container.encode(objectLockEnabled, forKey: Key("objectLockEnabled"))
        }
        if let rule = rule {
            try container.encode(rule, forKey: Key("rule"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectLockEnabledDecoded = try containerValues.decodeIfPresent(ObjectLockEnabled.self, forKey: .objectLockEnabled)
        objectLockEnabled = objectLockEnabledDecoded
        let ruleDecoded = try containerValues.decodeIfPresent(ObjectLockRule.self, forKey: .rule)
        rule = ruleDecoded
    }
}

extension ObjectLockConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectLockConfiguration(objectLockEnabled: \(String(describing: objectLockEnabled)), rule: \(String(describing: rule)))"}
}

extension ObjectLockConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The container element for Object Lock configuration parameters.</p>
public struct ObjectLockConfiguration: Equatable {
    /// <p>Indicates whether this bucket has an Object Lock configuration enabled.
    ///          Enable <code>ObjectLockEnabled</code> when you apply <code>ObjectLockConfiguration</code>
    ///          to a bucket. </p>
    public let objectLockEnabled: ObjectLockEnabled?
    /// <p>Specifies the Object Lock rule for the specified object. Enable the this rule when you apply
    ///          <code>ObjectLockConfiguration</code> to a bucket. Bucket settings require both a mode and a period.
    ///          The period can be either <code>Days</code> or <code>Years</code> but you must select one.
    ///          You cannot specify <code>Days</code> and <code>Years</code> at the same time.</p>
    public let rule: ObjectLockRule?

    public init (
        objectLockEnabled: ObjectLockEnabled? = nil,
        rule: ObjectLockRule? = nil
    )
    {
        self.objectLockEnabled = objectLockEnabled
        self.rule = rule
    }
}

public enum ObjectLockEnabled {
    case enabled
    case sdkUnknown(String)
}

extension ObjectLockEnabled : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ObjectLockEnabled] {
        return [
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .enabled: return "Enabled"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ObjectLockEnabled(rawValue: rawValue) ?? ObjectLockEnabled.sdkUnknown(rawValue)
    }
}

extension ObjectLockLegalHold: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ObjectLockLegalHoldStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ObjectLockLegalHold: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectLockLegalHold(status: \(String(describing: status)))"}
}

extension ObjectLockLegalHold: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A Legal Hold configuration for an object.</p>
public struct ObjectLockLegalHold: Equatable {
    /// <p>Indicates whether the specified object has a Legal Hold in place.</p>
    public let status: ObjectLockLegalHoldStatus?

    public init (
        status: ObjectLockLegalHoldStatus? = nil
    )
    {
        self.status = status
    }
}

public enum ObjectLockLegalHoldStatus {
    case off
    case on
    case sdkUnknown(String)
}

extension ObjectLockLegalHoldStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ObjectLockLegalHoldStatus] {
        return [
            .off,
            .on,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .off: return "OFF"
        case .on: return "ON"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ObjectLockLegalHoldStatus(rawValue: rawValue) ?? ObjectLockLegalHoldStatus.sdkUnknown(rawValue)
    }
}

public enum ObjectLockMode {
    case compliance
    case governance
    case sdkUnknown(String)
}

extension ObjectLockMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ObjectLockMode] {
        return [
            .compliance,
            .governance,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .compliance: return "COMPLIANCE"
        case .governance: return "GOVERNANCE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ObjectLockMode(rawValue: rawValue) ?? ObjectLockMode.sdkUnknown(rawValue)
    }
}

extension ObjectLockRetention: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mode = "Mode"
        case retainUntilDate = "RetainUntilDate"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let mode = mode {
            try container.encode(mode, forKey: Key("mode"))
        }
        if let retainUntilDate = retainUntilDate {
            try container.encode(TimestampWrapper(retainUntilDate, format: .dateTime), forKey: Key("retainUntilDate"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(ObjectLockRetentionMode.self, forKey: .mode)
        mode = modeDecoded
        let retainUntilDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .retainUntilDate)
        var retainUntilDateBuffer:Date? = nil
        if let retainUntilDateDecoded = retainUntilDateDecoded {
            retainUntilDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(retainUntilDateDecoded, format: .dateTime)
        }
        retainUntilDate = retainUntilDateBuffer
    }
}

extension ObjectLockRetention: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectLockRetention(mode: \(String(describing: mode)), retainUntilDate: \(String(describing: retainUntilDate)))"}
}

extension ObjectLockRetention: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A Retention configuration for an object.</p>
public struct ObjectLockRetention: Equatable {
    /// <p>Indicates the Retention mode for the specified object.</p>
    public let mode: ObjectLockRetentionMode?
    /// <p>The date on which this Object Lock Retention will expire.</p>
    public let retainUntilDate: Date?

    public init (
        mode: ObjectLockRetentionMode? = nil,
        retainUntilDate: Date? = nil
    )
    {
        self.mode = mode
        self.retainUntilDate = retainUntilDate
    }
}

public enum ObjectLockRetentionMode {
    case compliance
    case governance
    case sdkUnknown(String)
}

extension ObjectLockRetentionMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ObjectLockRetentionMode] {
        return [
            .compliance,
            .governance,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .compliance: return "COMPLIANCE"
        case .governance: return "GOVERNANCE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ObjectLockRetentionMode(rawValue: rawValue) ?? ObjectLockRetentionMode.sdkUnknown(rawValue)
    }
}

extension ObjectLockRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultRetention = "DefaultRetention"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let defaultRetention = defaultRetention {
            try container.encode(defaultRetention, forKey: Key("defaultRetention"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultRetentionDecoded = try containerValues.decodeIfPresent(DefaultRetention.self, forKey: .defaultRetention)
        defaultRetention = defaultRetentionDecoded
    }
}

extension ObjectLockRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectLockRule(defaultRetention: \(String(describing: defaultRetention)))"}
}

extension ObjectLockRule: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The container element for an Object Lock rule.</p>
public struct ObjectLockRule: Equatable {
    /// <p>The default Object Lock retention mode and period that you want to apply to new objects
    ///          placed in the specified bucket. Bucket settings require both a mode and a period.
    ///          The period can be either <code>Days</code> or <code>Years</code> but you must select one.
    ///          You cannot specify <code>Days</code> and <code>Years</code> at the same time.</p>
    public let defaultRetention: DefaultRetention?

    public init (
        defaultRetention: DefaultRetention? = nil
    )
    {
        self.defaultRetention = defaultRetention
    }
}

extension ObjectNotInActiveTierError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectNotInActiveTierError()"}
}

extension ObjectNotInActiveTierError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The source object of the COPY action is not in the active tier and is only stored in
///          Amazon S3 Glacier.</p>
public struct ObjectNotInActiveTierError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

/// <p>The container element for object ownership for a bucket's ownership controls.</p>
///          <p>BucketOwnerPreferred - Objects uploaded to the bucket change ownership to the bucket
///          owner if the objects are uploaded with the <code>bucket-owner-full-control</code> canned
///          ACL.</p>
///          <p>ObjectWriter - The uploading account will own the object if the object is uploaded with
///          the <code>bucket-owner-full-control</code> canned ACL.</p>
public enum ObjectOwnership {
    case bucketownerpreferred
    case objectwriter
    case sdkUnknown(String)
}

extension ObjectOwnership : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ObjectOwnership] {
        return [
            .bucketownerpreferred,
            .objectwriter,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bucketownerpreferred: return "BucketOwnerPreferred"
        case .objectwriter: return "ObjectWriter"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ObjectOwnership(rawValue: rawValue) ?? ObjectOwnership.sdkUnknown(rawValue)
    }
}

public enum ObjectStorageClass {
    case deepArchive
    case glacier
    case intelligentTiering
    case onezoneIa
    case outposts
    case reducedRedundancy
    case standard
    case standardIa
    case sdkUnknown(String)
}

extension ObjectStorageClass : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ObjectStorageClass] {
        return [
            .deepArchive,
            .glacier,
            .intelligentTiering,
            .onezoneIa,
            .outposts,
            .reducedRedundancy,
            .standard,
            .standardIa,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deepArchive: return "DEEP_ARCHIVE"
        case .glacier: return "GLACIER"
        case .intelligentTiering: return "INTELLIGENT_TIERING"
        case .onezoneIa: return "ONEZONE_IA"
        case .outposts: return "OUTPOSTS"
        case .reducedRedundancy: return "REDUCED_REDUNDANCY"
        case .standard: return "STANDARD"
        case .standardIa: return "STANDARD_IA"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ObjectStorageClass(rawValue: rawValue) ?? ObjectStorageClass.sdkUnknown(rawValue)
    }
}

extension ObjectVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eTag = "ETag"
        case isLatest = "IsLatest"
        case key = "Key"
        case lastModified = "LastModified"
        case owner = "Owner"
        case size = "Size"
        case storageClass = "StorageClass"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let eTag = eTag {
            try container.encode(eTag, forKey: Key("eTag"))
        }
        if isLatest != false {
            try container.encode(isLatest, forKey: Key("isLatest"))
        }
        if let key = key {
            try container.encode(key, forKey: Key("key"))
        }
        if let lastModified = lastModified {
            try container.encode(TimestampWrapper(lastModified, format: .dateTime), forKey: Key("lastModified"))
        }
        if let owner = owner {
            try container.encode(owner, forKey: Key("owner"))
        }
        if size != 0 {
            try container.encode(size, forKey: Key("size"))
        }
        if let storageClass = storageClass {
            try container.encode(storageClass, forKey: Key("storageClass"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: Key("versionId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eTagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eTag)
        eTag = eTagDecoded
        let sizeDecoded = try containerValues.decode(Int.self, forKey: .size)
        size = sizeDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(ObjectVersionStorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let isLatestDecoded = try containerValues.decode(Bool.self, forKey: .isLatest)
        isLatest = isLatestDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModified)
        var lastModifiedBuffer:Date? = nil
        if let lastModifiedDecoded = lastModifiedDecoded {
            lastModifiedBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastModifiedDecoded, format: .dateTime)
        }
        lastModified = lastModifiedBuffer
        let ownerDecoded = try containerValues.decodeIfPresent(Owner.self, forKey: .owner)
        owner = ownerDecoded
    }
}

extension ObjectVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectVersion(eTag: \(String(describing: eTag)), isLatest: \(String(describing: isLatest)), key: \(String(describing: key)), lastModified: \(String(describing: lastModified)), owner: \(String(describing: owner)), size: \(String(describing: size)), storageClass: \(String(describing: storageClass)), versionId: \(String(describing: versionId)))"}
}

extension ObjectVersion: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The version of an object.</p>
public struct ObjectVersion: Equatable {
    /// <p>The entity tag is an MD5 hash of that version of the object.</p>
    public let eTag: String?
    /// <p>Specifies whether the object is (true) or is not (false) the latest version of an
    ///          object.</p>
    public let isLatest: Bool
    /// <p>The object key.</p>
    public let key: String?
    /// <p>Date and time the object was last modified.</p>
    public let lastModified: Date?
    /// <p>Specifies the owner of the object.</p>
    public let owner: Owner?
    /// <p>Size in bytes of the object.</p>
    public let size: Int
    /// <p>The class of storage used to store the object.</p>
    public let storageClass: ObjectVersionStorageClass?
    /// <p>Version ID of an object.</p>
    public let versionId: String?

    public init (
        eTag: String? = nil,
        isLatest: Bool = false,
        key: String? = nil,
        lastModified: Date? = nil,
        owner: Owner? = nil,
        size: Int = 0,
        storageClass: ObjectVersionStorageClass? = nil,
        versionId: String? = nil
    )
    {
        self.eTag = eTag
        self.isLatest = isLatest
        self.key = key
        self.lastModified = lastModified
        self.owner = owner
        self.size = size
        self.storageClass = storageClass
        self.versionId = versionId
    }
}

public enum ObjectVersionStorageClass {
    case standard
    case sdkUnknown(String)
}

extension ObjectVersionStorageClass : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ObjectVersionStorageClass] {
        return [
            .standard,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .standard: return "STANDARD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ObjectVersionStorageClass(rawValue: rawValue) ?? ObjectVersionStorageClass.sdkUnknown(rawValue)
    }
}

extension OutputLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3 = "S3"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let s3 = s3 {
            try container.encode(s3, forKey: Key("s3"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension OutputLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutputLocation(s3: \(String(describing: s3)))"}
}

extension OutputLocation: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Describes the location where the restore job's output is stored.</p>
public struct OutputLocation: Equatable {
    /// <p>Describes an S3 location that will receive the results of the restore request.</p>
    public let s3: S3Location?

    public init (
        s3: S3Location? = nil
    )
    {
        self.s3 = s3
    }
}

extension OutputSerialization: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cSV = "CSV"
        case jSON = "JSON"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let cSV = cSV {
            try container.encode(cSV, forKey: Key("cSV"))
        }
        if let jSON = jSON {
            try container.encode(jSON, forKey: Key("jSON"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cSVDecoded = try containerValues.decodeIfPresent(CSVOutput.self, forKey: .cSV)
        cSV = cSVDecoded
        let jSONDecoded = try containerValues.decodeIfPresent(JSONOutput.self, forKey: .jSON)
        jSON = jSONDecoded
    }
}

extension OutputSerialization: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutputSerialization(cSV: \(String(describing: cSV)), jSON: \(String(describing: jSON)))"}
}

extension OutputSerialization: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Describes how results of the Select job are serialized.</p>
public struct OutputSerialization: Equatable {
    /// <p>Describes the serialization of CSV-encoded Select results.</p>
    public let cSV: CSVOutput?
    /// <p>Specifies JSON as request's output serialization format.</p>
    public let jSON: JSONOutput?

    public init (
        cSV: CSVOutput? = nil,
        jSON: JSONOutput? = nil
    )
    {
        self.cSV = cSV
        self.jSON = jSON
    }
}

extension Owner: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case displayName = "DisplayName"
        case iD = "ID"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let displayName = displayName {
            try container.encode(displayName, forKey: Key("displayName"))
        }
        if let iD = iD {
            try container.encode(iD, forKey: Key("iD"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let iDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iD)
        iD = iDDecoded
    }
}

extension Owner: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Owner(displayName: \(String(describing: displayName)), iD: \(String(describing: iD)))"}
}

extension Owner: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container for the owner's display name and ID.</p>
public struct Owner: Equatable {
    /// <p>Container for the display name of the owner.</p>
    public let displayName: String?
    /// <p>Container for the ID of the owner.</p>
    public let iD: String?

    public init (
        displayName: String? = nil,
        iD: String? = nil
    )
    {
        self.displayName = displayName
        self.iD = iD
    }
}

public enum OwnerOverride {
    case destination
    case sdkUnknown(String)
}

extension OwnerOverride : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OwnerOverride] {
        return [
            .destination,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .destination: return "Destination"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OwnerOverride(rawValue: rawValue) ?? OwnerOverride.sdkUnknown(rawValue)
    }
}

extension OwnershipControls: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case rules = "Rule"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let rules = rules {
            if rules.isEmpty {
                var rulesContainer = container.nestedUnkeyedContainer(forKey: Key("Rule"))
                try rulesContainer.encodeNil()
            } else {
                for ownershipcontrolsrule0 in rules {
                    var rulesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Rule"))
                    try rulesContainer0.encode(ownershipcontrolsrule0, forKey: Key(""))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.rules) {
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .rules)
            if rulesWrappedContainer != nil {
                let rulesContainer = try containerValues.decodeIfPresent([OwnershipControlsRule].self, forKey: .rules)
                var rulesBuffer:[OwnershipControlsRule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [OwnershipControlsRule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

extension OwnershipControls: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OwnershipControls(rules: \(String(describing: rules)))"}
}

extension OwnershipControls: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The container element for a bucket's ownership controls.</p>
public struct OwnershipControls: Equatable {
    /// <p>The container element for an ownership control rule.</p>
    public let rules: [OwnershipControlsRule]?

    public init (
        rules: [OwnershipControlsRule]? = nil
    )
    {
        self.rules = rules
    }
}

extension OwnershipControlsRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectOwnership = "ObjectOwnership"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let objectOwnership = objectOwnership {
            try container.encode(objectOwnership, forKey: Key("objectOwnership"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectOwnershipDecoded = try containerValues.decodeIfPresent(ObjectOwnership.self, forKey: .objectOwnership)
        objectOwnership = objectOwnershipDecoded
    }
}

extension OwnershipControlsRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OwnershipControlsRule(objectOwnership: \(String(describing: objectOwnership)))"}
}

extension OwnershipControlsRule: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The container element for an ownership control rule.</p>
public struct OwnershipControlsRule: Equatable {
    /// <p>The container element for object ownership for a bucket's ownership controls.</p>
    ///          <p>BucketOwnerPreferred - Objects uploaded to the bucket change ownership to the bucket
    ///          owner if the objects are uploaded with the <code>bucket-owner-full-control</code> canned
    ///          ACL.</p>
    ///          <p>ObjectWriter - The uploading account will own the object if the object is uploaded with
    ///          the <code>bucket-owner-full-control</code> canned ACL.</p>
    public let objectOwnership: ObjectOwnership?

    public init (
        objectOwnership: ObjectOwnership? = nil
    )
    {
        self.objectOwnership = objectOwnership
    }
}

extension ParquetInput: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension ParquetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParquetInput()"}
}

/// <p>Container for Parquet.</p>
public struct ParquetInput: Equatable {

    public init() {}
}

extension Part: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eTag = "ETag"
        case lastModified = "LastModified"
        case partNumber = "PartNumber"
        case size = "Size"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let eTag = eTag {
            try container.encode(eTag, forKey: Key("eTag"))
        }
        if let lastModified = lastModified {
            try container.encode(TimestampWrapper(lastModified, format: .dateTime), forKey: Key("lastModified"))
        }
        if partNumber != 0 {
            try container.encode(partNumber, forKey: Key("partNumber"))
        }
        if size != 0 {
            try container.encode(size, forKey: Key("size"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partNumberDecoded = try containerValues.decode(Int.self, forKey: .partNumber)
        partNumber = partNumberDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModified)
        var lastModifiedBuffer:Date? = nil
        if let lastModifiedDecoded = lastModifiedDecoded {
            lastModifiedBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastModifiedDecoded, format: .dateTime)
        }
        lastModified = lastModifiedBuffer
        let eTagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eTag)
        eTag = eTagDecoded
        let sizeDecoded = try containerValues.decode(Int.self, forKey: .size)
        size = sizeDecoded
    }
}

extension Part: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Part(eTag: \(String(describing: eTag)), lastModified: \(String(describing: lastModified)), partNumber: \(String(describing: partNumber)), size: \(String(describing: size)))"}
}

extension Part: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container for elements related to a part.</p>
public struct Part: Equatable {
    /// <p>Entity tag returned when the part was uploaded.</p>
    public let eTag: String?
    /// <p>Date and time at which the part was uploaded.</p>
    public let lastModified: Date?
    /// <p>Part number identifying the part. This is a positive integer between 1 and
    ///          10,000.</p>
    public let partNumber: Int
    /// <p>Size in bytes of the uploaded part data.</p>
    public let size: Int

    public init (
        eTag: String? = nil,
        lastModified: Date? = nil,
        partNumber: Int = 0,
        size: Int = 0
    )
    {
        self.eTag = eTag
        self.lastModified = lastModified
        self.partNumber = partNumber
        self.size = size
    }
}

public enum Payer {
    case bucketowner
    case requester
    case sdkUnknown(String)
}

extension Payer : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Payer] {
        return [
            .bucketowner,
            .requester,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bucketowner: return "BucketOwner"
        case .requester: return "Requester"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Payer(rawValue: rawValue) ?? Payer.sdkUnknown(rawValue)
    }
}

public enum Permission {
    case fullControl
    case read
    case readAcp
    case write
    case writeAcp
    case sdkUnknown(String)
}

extension Permission : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Permission] {
        return [
            .fullControl,
            .read,
            .readAcp,
            .write,
            .writeAcp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fullControl: return "FULL_CONTROL"
        case .read: return "READ"
        case .readAcp: return "READ_ACP"
        case .write: return "WRITE"
        case .writeAcp: return "WRITE_ACP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Permission(rawValue: rawValue) ?? Permission.sdkUnknown(rawValue)
    }
}

extension PolicyStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isPublic = "IsPublic"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if isPublic != false {
            try container.encode(isPublic, forKey: Key("IsPublic"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isPublicDecoded = try containerValues.decode(Bool.self, forKey: .isPublic)
        isPublic = isPublicDecoded
    }
}

extension PolicyStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyStatus(isPublic: \(String(describing: isPublic)))"}
}

extension PolicyStatus: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The container element for a bucket's policy status.</p>
public struct PolicyStatus: Equatable {
    /// <p>The policy status for this bucket. <code>TRUE</code> indicates that this bucket is
    ///          public. <code>FALSE</code> indicates that the bucket is not public.</p>
    public let isPublic: Bool

    public init (
        isPublic: Bool = false
    )
    {
        self.isPublic = isPublic
    }
}

extension Progress: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bytesProcessed = "BytesProcessed"
        case bytesReturned = "BytesReturned"
        case bytesScanned = "BytesScanned"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if bytesProcessed != 0 {
            try container.encode(bytesProcessed, forKey: Key("bytesProcessed"))
        }
        if bytesReturned != 0 {
            try container.encode(bytesReturned, forKey: Key("bytesReturned"))
        }
        if bytesScanned != 0 {
            try container.encode(bytesScanned, forKey: Key("bytesScanned"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bytesScannedDecoded = try containerValues.decode(Int.self, forKey: .bytesScanned)
        bytesScanned = bytesScannedDecoded
        let bytesProcessedDecoded = try containerValues.decode(Int.self, forKey: .bytesProcessed)
        bytesProcessed = bytesProcessedDecoded
        let bytesReturnedDecoded = try containerValues.decode(Int.self, forKey: .bytesReturned)
        bytesReturned = bytesReturnedDecoded
    }
}

extension Progress: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Progress(bytesProcessed: \(String(describing: bytesProcessed)), bytesReturned: \(String(describing: bytesReturned)), bytesScanned: \(String(describing: bytesScanned)))"}
}

extension Progress: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>This data type contains information about progress of an operation.</p>
public struct Progress: Equatable {
    /// <p>The current number of uncompressed object bytes processed.</p>
    public let bytesProcessed: Int
    /// <p>The current number of bytes of records payload data returned.</p>
    public let bytesReturned: Int
    /// <p>The current number of object bytes scanned.</p>
    public let bytesScanned: Int

    public init (
        bytesProcessed: Int = 0,
        bytesReturned: Int = 0,
        bytesScanned: Int = 0
    )
    {
        self.bytesProcessed = bytesProcessed
        self.bytesReturned = bytesReturned
        self.bytesScanned = bytesScanned
    }
}

extension ProgressEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case details = "Details"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let details = details {
            try container.encode(details, forKey: Key("details"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(Progress.self, forKey: .details)
        details = detailsDecoded
    }
}

extension ProgressEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProgressEvent(details: \(String(describing: details)))"}
}

extension ProgressEvent: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>This data type contains information about the progress event of an operation.</p>
public struct ProgressEvent: Equatable {
    /// <p>The Progress event details.</p>
    public let details: Progress?

    public init (
        details: Progress? = nil
    )
    {
        self.details = details
    }
}

public enum `Protocol` {
    case http
    case https
    case sdkUnknown(String)
}

extension `Protocol` : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [`Protocol`] {
        return [
            .http,
            .https,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .http: return "http"
        case .https: return "https"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = `Protocol`(rawValue: rawValue) ?? `Protocol`.sdkUnknown(rawValue)
    }
}

extension PublicAccessBlockConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blockPublicAcls = "BlockPublicAcls"
        case blockPublicPolicy = "BlockPublicPolicy"
        case ignorePublicAcls = "IgnorePublicAcls"
        case restrictPublicBuckets = "RestrictPublicBuckets"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if blockPublicAcls != false {
            try container.encode(blockPublicAcls, forKey: Key("BlockPublicAcls"))
        }
        if blockPublicPolicy != false {
            try container.encode(blockPublicPolicy, forKey: Key("BlockPublicPolicy"))
        }
        if ignorePublicAcls != false {
            try container.encode(ignorePublicAcls, forKey: Key("IgnorePublicAcls"))
        }
        if restrictPublicBuckets != false {
            try container.encode(restrictPublicBuckets, forKey: Key("RestrictPublicBuckets"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockPublicAclsDecoded = try containerValues.decode(Bool.self, forKey: .blockPublicAcls)
        blockPublicAcls = blockPublicAclsDecoded
        let ignorePublicAclsDecoded = try containerValues.decode(Bool.self, forKey: .ignorePublicAcls)
        ignorePublicAcls = ignorePublicAclsDecoded
        let blockPublicPolicyDecoded = try containerValues.decode(Bool.self, forKey: .blockPublicPolicy)
        blockPublicPolicy = blockPublicPolicyDecoded
        let restrictPublicBucketsDecoded = try containerValues.decode(Bool.self, forKey: .restrictPublicBuckets)
        restrictPublicBuckets = restrictPublicBucketsDecoded
    }
}

extension PublicAccessBlockConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublicAccessBlockConfiguration(blockPublicAcls: \(String(describing: blockPublicAcls)), blockPublicPolicy: \(String(describing: blockPublicPolicy)), ignorePublicAcls: \(String(describing: ignorePublicAcls)), restrictPublicBuckets: \(String(describing: restrictPublicBuckets)))"}
}

extension PublicAccessBlockConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The PublicAccessBlock configuration that you want to apply to this Amazon S3 bucket. You can
///          enable the configuration options in any combination. For more information about when Amazon S3
///          considers a bucket or object public, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status">The Meaning of "Public"</a> in the <i>Amazon S3 User Guide</i>. </p>
public struct PublicAccessBlockConfiguration: Equatable {
    /// <p>Specifies whether Amazon S3 should block public access control lists (ACLs) for this bucket
    ///          and objects in this bucket. Setting this element to <code>TRUE</code> causes the following
    ///          behavior:</p>
    ///          <ul>
    ///             <li>
    ///                <p>PUT Bucket acl and PUT Object acl calls fail if the specified ACL is
    ///                public.</p>
    ///             </li>
    ///             <li>
    ///                <p>PUT Object calls fail if the request includes a public ACL.</p>
    ///             </li>
    ///             <li>
    ///                <p>PUT Bucket calls fail if the request includes a public ACL.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Enabling this setting doesn't affect existing policies or ACLs.</p>
    public let blockPublicAcls: Bool
    /// <p>Specifies whether Amazon S3 should block public bucket policies for this bucket. Setting this
    ///          element to <code>TRUE</code> causes Amazon S3 to reject calls to PUT Bucket policy if the
    ///          specified bucket policy allows public access. </p>
    ///          <p>Enabling this setting doesn't affect existing bucket policies.</p>
    public let blockPublicPolicy: Bool
    /// <p>Specifies whether Amazon S3 should ignore public ACLs for this bucket and objects in this
    ///          bucket. Setting this element to <code>TRUE</code> causes Amazon S3 to ignore all public ACLs on
    ///          this bucket and objects in this bucket.</p>
    ///          <p>Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't
    ///          prevent new public ACLs from being set.</p>
    public let ignorePublicAcls: Bool
    /// <p>Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting
    ///          this element to <code>TRUE</code> restricts access to this bucket to only AWS service
    ///          principals and authorized users within this account if the bucket has a public
    ///          policy.</p>
    ///          <p>Enabling this setting doesn't affect previously stored bucket policies, except that
    ///          public and cross-account access within any public bucket policy, including non-public
    ///          delegation to specific accounts, is blocked.</p>
    public let restrictPublicBuckets: Bool

    public init (
        blockPublicAcls: Bool = false,
        blockPublicPolicy: Bool = false,
        ignorePublicAcls: Bool = false,
        restrictPublicBuckets: Bool = false
    )
    {
        self.blockPublicAcls = blockPublicAcls
        self.blockPublicPolicy = blockPublicPolicy
        self.ignorePublicAcls = ignorePublicAcls
        self.restrictPublicBuckets = restrictPublicBuckets
    }
}

public struct PutBucketAccelerateConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutBucketAccelerateConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketAccelerateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketAccelerateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accelerateConfiguration = input.operationInput.accelerateConfiguration {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(accelerateConfiguration)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketAccelerateConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketAccelerateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketAccelerateConfigurationOutputError>
}

extension PutBucketAccelerateConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketAccelerateConfigurationInput(accelerateConfiguration: \(String(describing: accelerateConfiguration)), bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension PutBucketAccelerateConfigurationInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketAccelerateConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accelerateConfiguration = "AccelerateConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let accelerateConfiguration = accelerateConfiguration {
            try container.encode(accelerateConfiguration, forKey: Key("AccelerateConfiguration"))
        }
    }
}

public struct PutBucketAccelerateConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutBucketAccelerateConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketAccelerateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketAccelerateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketAccelerateConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketAccelerateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketAccelerateConfigurationOutputError>
}

public struct PutBucketAccelerateConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBucketAccelerateConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketAccelerateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketAccelerateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "accelerate", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketAccelerateConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketAccelerateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketAccelerateConfigurationOutputError>
}

public struct PutBucketAccelerateConfigurationInput: Equatable {
    /// <p>Container for setting the transfer acceleration state.</p>
    public let accelerateConfiguration: AccelerateConfiguration?
    /// <p>The name of the bucket for which the accelerate configuration is set.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        accelerateConfiguration: AccelerateConfiguration? = nil,
        bucket: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.accelerateConfiguration = accelerateConfiguration
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct PutBucketAccelerateConfigurationInputBody: Equatable {
    public let accelerateConfiguration: AccelerateConfiguration?
}

extension PutBucketAccelerateConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accelerateConfiguration = "AccelerateConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accelerateConfigurationDecoded = try containerValues.decodeIfPresent(AccelerateConfiguration.self, forKey: .accelerateConfiguration)
        accelerateConfiguration = accelerateConfigurationDecoded
    }
}

extension PutBucketAccelerateConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutBucketAccelerateConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBucketAccelerateConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketAccelerateConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketAccelerateConfigurationOutputResponse()"}
}

extension PutBucketAccelerateConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketAccelerateConfigurationOutputResponse: Equatable {

    public init() {}
}

struct PutBucketAccelerateConfigurationOutputResponseBody: Equatable {
}

extension PutBucketAccelerateConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutBucketAclInputBodyMiddleware: Middleware {
    public let id: String = "PutBucketAclInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketAclInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketAclOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accessControlPolicy = input.operationInput.accessControlPolicy {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(accessControlPolicy)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketAclInput>
    public typealias MOutput = OperationOutput<PutBucketAclOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketAclOutputError>
}

extension PutBucketAclInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketAclInput(aCL: \(String(describing: aCL)), accessControlPolicy: \(String(describing: accessControlPolicy)), bucket: \(String(describing: bucket)), contentMD5: \(String(describing: contentMD5)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), grantFullControl: \(String(describing: grantFullControl)), grantRead: \(String(describing: grantRead)), grantReadACP: \(String(describing: grantReadACP)), grantWrite: \(String(describing: grantWrite)), grantWriteACP: \(String(describing: grantWriteACP)))"}
}

extension PutBucketAclInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketAclInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessControlPolicy = "AccessControlPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let accessControlPolicy = accessControlPolicy {
            try container.encode(accessControlPolicy, forKey: Key("AccessControlPolicy"))
        }
    }
}

public struct PutBucketAclInputHeadersMiddleware: Middleware {
    public let id: String = "PutBucketAclInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketAclInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketAclOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let aCL = input.operationInput.aCL {
            input.builder.withHeader(name: "x-amz-acl", value: String(aCL.rawValue))
        }
        if let contentMD5 = input.operationInput.contentMD5 {
            input.builder.withHeader(name: "Content-MD5", value: String(contentMD5))
        }
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let grantFullControl = input.operationInput.grantFullControl {
            input.builder.withHeader(name: "x-amz-grant-full-control", value: String(grantFullControl))
        }
        if let grantRead = input.operationInput.grantRead {
            input.builder.withHeader(name: "x-amz-grant-read", value: String(grantRead))
        }
        if let grantReadACP = input.operationInput.grantReadACP {
            input.builder.withHeader(name: "x-amz-grant-read-acp", value: String(grantReadACP))
        }
        if let grantWrite = input.operationInput.grantWrite {
            input.builder.withHeader(name: "x-amz-grant-write", value: String(grantWrite))
        }
        if let grantWriteACP = input.operationInput.grantWriteACP {
            input.builder.withHeader(name: "x-amz-grant-write-acp", value: String(grantWriteACP))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketAclInput>
    public typealias MOutput = OperationOutput<PutBucketAclOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketAclOutputError>
}

public struct PutBucketAclInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBucketAclInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketAclInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketAclOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "acl", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketAclInput>
    public typealias MOutput = OperationOutput<PutBucketAclOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketAclOutputError>
}

public struct PutBucketAclInput: Equatable {
    /// <p>The canned ACL to apply to the bucket.</p>
    public let aCL: BucketCannedACL?
    /// <p>Contains the elements that set the ACL permissions for an object per grantee.</p>
    public let accessControlPolicy: AccessControlPolicy?
    /// <p>The bucket to which to apply the ACL.</p>
    public let bucket: String?
    /// <p>The base64-encoded 128-bit MD5 digest of the data. This header must be used as a message
    ///          integrity check to verify that the request body was not corrupted in transit. For more
    ///          information, go to <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
    ///          1864.</a>
    ///          </p>
    ///          <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    public let contentMD5: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>Allows grantee the read, write, read ACP, and write ACP permissions on the
    ///          bucket.</p>
    public let grantFullControl: String?
    /// <p>Allows grantee to list the objects in the bucket.</p>
    public let grantRead: String?
    /// <p>Allows grantee to read the bucket ACL.</p>
    public let grantReadACP: String?
    /// <p>Allows grantee to create new objects in the bucket.</p>
    ///          <p>For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects.</p>
    public let grantWrite: String?
    /// <p>Allows grantee to write the ACL for the applicable bucket.</p>
    public let grantWriteACP: String?

    public init (
        aCL: BucketCannedACL? = nil,
        accessControlPolicy: AccessControlPolicy? = nil,
        bucket: String? = nil,
        contentMD5: String? = nil,
        expectedBucketOwner: String? = nil,
        grantFullControl: String? = nil,
        grantRead: String? = nil,
        grantReadACP: String? = nil,
        grantWrite: String? = nil,
        grantWriteACP: String? = nil
    )
    {
        self.aCL = aCL
        self.accessControlPolicy = accessControlPolicy
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.grantFullControl = grantFullControl
        self.grantRead = grantRead
        self.grantReadACP = grantReadACP
        self.grantWrite = grantWrite
        self.grantWriteACP = grantWriteACP
    }
}

struct PutBucketAclInputBody: Equatable {
    public let accessControlPolicy: AccessControlPolicy?
}

extension PutBucketAclInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessControlPolicy = "AccessControlPolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessControlPolicyDecoded = try containerValues.decodeIfPresent(AccessControlPolicy.self, forKey: .accessControlPolicy)
        accessControlPolicy = accessControlPolicyDecoded
    }
}

extension PutBucketAclOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutBucketAclOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBucketAclOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketAclOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketAclOutputResponse()"}
}

extension PutBucketAclOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketAclOutputResponse: Equatable {

    public init() {}
}

struct PutBucketAclOutputResponseBody: Equatable {
}

extension PutBucketAclOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutBucketAnalyticsConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutBucketAnalyticsConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketAnalyticsConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketAnalyticsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let analyticsConfiguration = input.operationInput.analyticsConfiguration {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(analyticsConfiguration)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketAnalyticsConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketAnalyticsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketAnalyticsConfigurationOutputError>
}

extension PutBucketAnalyticsConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketAnalyticsConfigurationInput(analyticsConfiguration: \(String(describing: analyticsConfiguration)), bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), id: \(String(describing: id)))"}
}

extension PutBucketAnalyticsConfigurationInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketAnalyticsConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analyticsConfiguration = "AnalyticsConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let analyticsConfiguration = analyticsConfiguration {
            try container.encode(analyticsConfiguration, forKey: Key("AnalyticsConfiguration"))
        }
    }
}

public struct PutBucketAnalyticsConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutBucketAnalyticsConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketAnalyticsConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketAnalyticsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketAnalyticsConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketAnalyticsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketAnalyticsConfigurationOutputError>
}

public struct PutBucketAnalyticsConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBucketAnalyticsConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketAnalyticsConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketAnalyticsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "analytics", value: nil))
        if let id = input.operationInput.id {
            let idQueryItem = URLQueryItem(name: "id".urlPercentEncoding(), value: String(id).urlPercentEncoding())
            input.builder.withQueryItem(idQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketAnalyticsConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketAnalyticsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketAnalyticsConfigurationOutputError>
}

public struct PutBucketAnalyticsConfigurationInput: Equatable {
    /// <p>The configuration and any analyses for the analytics filter.</p>
    public let analyticsConfiguration: AnalyticsConfiguration?
    /// <p>The name of the bucket to which an analytics configuration is stored.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The ID that identifies the analytics configuration.</p>
    public let id: String?

    public init (
        analyticsConfiguration: AnalyticsConfiguration? = nil,
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        id: String? = nil
    )
    {
        self.analyticsConfiguration = analyticsConfiguration
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.id = id
    }
}

struct PutBucketAnalyticsConfigurationInputBody: Equatable {
    public let analyticsConfiguration: AnalyticsConfiguration?
}

extension PutBucketAnalyticsConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyticsConfiguration = "AnalyticsConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyticsConfigurationDecoded = try containerValues.decodeIfPresent(AnalyticsConfiguration.self, forKey: .analyticsConfiguration)
        analyticsConfiguration = analyticsConfigurationDecoded
    }
}

extension PutBucketAnalyticsConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutBucketAnalyticsConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBucketAnalyticsConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketAnalyticsConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketAnalyticsConfigurationOutputResponse()"}
}

extension PutBucketAnalyticsConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketAnalyticsConfigurationOutputResponse: Equatable {

    public init() {}
}

struct PutBucketAnalyticsConfigurationOutputResponseBody: Equatable {
}

extension PutBucketAnalyticsConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutBucketCorsInputBodyMiddleware: Middleware {
    public let id: String = "PutBucketCorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketCorsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketCorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let cORSConfiguration = input.operationInput.cORSConfiguration {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(cORSConfiguration)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketCorsInput>
    public typealias MOutput = OperationOutput<PutBucketCorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketCorsOutputError>
}

extension PutBucketCorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketCorsInput(bucket: \(String(describing: bucket)), cORSConfiguration: \(String(describing: cORSConfiguration)), contentMD5: \(String(describing: contentMD5)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension PutBucketCorsInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketCorsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cORSConfiguration = "CORSConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let cORSConfiguration = cORSConfiguration {
            try container.encode(cORSConfiguration, forKey: Key("CORSConfiguration"))
        }
    }
}

public struct PutBucketCorsInputHeadersMiddleware: Middleware {
    public let id: String = "PutBucketCorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketCorsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketCorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contentMD5 = input.operationInput.contentMD5 {
            input.builder.withHeader(name: "Content-MD5", value: String(contentMD5))
        }
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketCorsInput>
    public typealias MOutput = OperationOutput<PutBucketCorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketCorsOutputError>
}

public struct PutBucketCorsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBucketCorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketCorsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketCorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "cors", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketCorsInput>
    public typealias MOutput = OperationOutput<PutBucketCorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketCorsOutputError>
}

public struct PutBucketCorsInput: Equatable {
    /// <p>Specifies the bucket impacted by the <code>cors</code>configuration.</p>
    public let bucket: String?
    /// <p>Describes the cross-origin access configuration for objects in an Amazon S3 bucket. For more
    ///          information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html">Enabling Cross-Origin Resource
    ///             Sharing</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let cORSConfiguration: CORSConfiguration?
    /// <p>The base64-encoded 128-bit MD5 digest of the data. This header must be used as a message
    ///          integrity check to verify that the request body was not corrupted in transit. For more
    ///          information, go to <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
    ///          1864.</a>
    ///          </p>
    ///          <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    public let contentMD5: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        cORSConfiguration: CORSConfiguration? = nil,
        contentMD5: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.cORSConfiguration = cORSConfiguration
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct PutBucketCorsInputBody: Equatable {
    public let cORSConfiguration: CORSConfiguration?
}

extension PutBucketCorsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cORSConfiguration = "CORSConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cORSConfigurationDecoded = try containerValues.decodeIfPresent(CORSConfiguration.self, forKey: .cORSConfiguration)
        cORSConfiguration = cORSConfigurationDecoded
    }
}

extension PutBucketCorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutBucketCorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBucketCorsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketCorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketCorsOutputResponse()"}
}

extension PutBucketCorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketCorsOutputResponse: Equatable {

    public init() {}
}

struct PutBucketCorsOutputResponseBody: Equatable {
}

extension PutBucketCorsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutBucketEncryptionInputBodyMiddleware: Middleware {
    public let id: String = "PutBucketEncryptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketEncryptionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let serverSideEncryptionConfiguration = input.operationInput.serverSideEncryptionConfiguration {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(serverSideEncryptionConfiguration)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketEncryptionInput>
    public typealias MOutput = OperationOutput<PutBucketEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketEncryptionOutputError>
}

extension PutBucketEncryptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketEncryptionInput(bucket: \(String(describing: bucket)), contentMD5: \(String(describing: contentMD5)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), serverSideEncryptionConfiguration: \(String(describing: serverSideEncryptionConfiguration)))"}
}

extension PutBucketEncryptionInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketEncryptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let serverSideEncryptionConfiguration = serverSideEncryptionConfiguration {
            try container.encode(serverSideEncryptionConfiguration, forKey: Key("ServerSideEncryptionConfiguration"))
        }
    }
}

public struct PutBucketEncryptionInputHeadersMiddleware: Middleware {
    public let id: String = "PutBucketEncryptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketEncryptionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contentMD5 = input.operationInput.contentMD5 {
            input.builder.withHeader(name: "Content-MD5", value: String(contentMD5))
        }
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketEncryptionInput>
    public typealias MOutput = OperationOutput<PutBucketEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketEncryptionOutputError>
}

public struct PutBucketEncryptionInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBucketEncryptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketEncryptionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "encryption", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketEncryptionInput>
    public typealias MOutput = OperationOutput<PutBucketEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketEncryptionOutputError>
}

public struct PutBucketEncryptionInput: Equatable {
    /// <p>Specifies default encryption for a bucket using server-side encryption with Amazon S3-managed
    ///          keys (SSE-S3) or customer master keys stored in AWS KMS (SSE-KMS). For information about
    ///          the Amazon S3 default encryption feature, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html">Amazon S3 Default Bucket Encryption</a>
    ///          in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>The base64-encoded 128-bit MD5 digest of the server-side encryption configuration.</p>
    ///          <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    public let contentMD5: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>Specifies the default server-side-encryption configuration.</p>
    public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?

    public init (
        bucket: String? = nil,
        contentMD5: String? = nil,
        expectedBucketOwner: String? = nil,
        serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil
    )
    {
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
    }
}

struct PutBucketEncryptionInputBody: Equatable {
    public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
}

extension PutBucketEncryptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
    }
}

extension PutBucketEncryptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutBucketEncryptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBucketEncryptionOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketEncryptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketEncryptionOutputResponse()"}
}

extension PutBucketEncryptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketEncryptionOutputResponse: Equatable {

    public init() {}
}

struct PutBucketEncryptionOutputResponseBody: Equatable {
}

extension PutBucketEncryptionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutBucketIntelligentTieringConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutBucketIntelligentTieringConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketIntelligentTieringConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketIntelligentTieringConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let intelligentTieringConfiguration = input.operationInput.intelligentTieringConfiguration {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(intelligentTieringConfiguration)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketIntelligentTieringConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketIntelligentTieringConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketIntelligentTieringConfigurationOutputError>
}

extension PutBucketIntelligentTieringConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketIntelligentTieringConfigurationInput(bucket: \(String(describing: bucket)), id: \(String(describing: id)), intelligentTieringConfiguration: \(String(describing: intelligentTieringConfiguration)))"}
}

extension PutBucketIntelligentTieringConfigurationInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketIntelligentTieringConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case intelligentTieringConfiguration = "IntelligentTieringConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let intelligentTieringConfiguration = intelligentTieringConfiguration {
            try container.encode(intelligentTieringConfiguration, forKey: Key("IntelligentTieringConfiguration"))
        }
    }
}

public struct PutBucketIntelligentTieringConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutBucketIntelligentTieringConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketIntelligentTieringConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketIntelligentTieringConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketIntelligentTieringConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketIntelligentTieringConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketIntelligentTieringConfigurationOutputError>
}

public struct PutBucketIntelligentTieringConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBucketIntelligentTieringConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketIntelligentTieringConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketIntelligentTieringConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "intelligent-tiering", value: nil))
        if let id = input.operationInput.id {
            let idQueryItem = URLQueryItem(name: "id".urlPercentEncoding(), value: String(id).urlPercentEncoding())
            input.builder.withQueryItem(idQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketIntelligentTieringConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketIntelligentTieringConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketIntelligentTieringConfigurationOutputError>
}

public struct PutBucketIntelligentTieringConfigurationInput: Equatable {
    /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
    public let bucket: String?
    /// <p>The ID used to identify the S3 Intelligent-Tiering configuration.</p>
    public let id: String?
    /// <p>Container for S3 Intelligent-Tiering configuration.</p>
    public let intelligentTieringConfiguration: IntelligentTieringConfiguration?

    public init (
        bucket: String? = nil,
        id: String? = nil,
        intelligentTieringConfiguration: IntelligentTieringConfiguration? = nil
    )
    {
        self.bucket = bucket
        self.id = id
        self.intelligentTieringConfiguration = intelligentTieringConfiguration
    }
}

struct PutBucketIntelligentTieringConfigurationInputBody: Equatable {
    public let intelligentTieringConfiguration: IntelligentTieringConfiguration?
}

extension PutBucketIntelligentTieringConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case intelligentTieringConfiguration = "IntelligentTieringConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intelligentTieringConfigurationDecoded = try containerValues.decodeIfPresent(IntelligentTieringConfiguration.self, forKey: .intelligentTieringConfiguration)
        intelligentTieringConfiguration = intelligentTieringConfigurationDecoded
    }
}

extension PutBucketIntelligentTieringConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutBucketIntelligentTieringConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBucketIntelligentTieringConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketIntelligentTieringConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketIntelligentTieringConfigurationOutputResponse()"}
}

extension PutBucketIntelligentTieringConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketIntelligentTieringConfigurationOutputResponse: Equatable {

    public init() {}
}

struct PutBucketIntelligentTieringConfigurationOutputResponseBody: Equatable {
}

extension PutBucketIntelligentTieringConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutBucketInventoryConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutBucketInventoryConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketInventoryConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketInventoryConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let inventoryConfiguration = input.operationInput.inventoryConfiguration {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(inventoryConfiguration)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketInventoryConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketInventoryConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketInventoryConfigurationOutputError>
}

extension PutBucketInventoryConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketInventoryConfigurationInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), id: \(String(describing: id)), inventoryConfiguration: \(String(describing: inventoryConfiguration)))"}
}

extension PutBucketInventoryConfigurationInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketInventoryConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inventoryConfiguration = "InventoryConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let inventoryConfiguration = inventoryConfiguration {
            try container.encode(inventoryConfiguration, forKey: Key("InventoryConfiguration"))
        }
    }
}

public struct PutBucketInventoryConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutBucketInventoryConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketInventoryConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketInventoryConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketInventoryConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketInventoryConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketInventoryConfigurationOutputError>
}

public struct PutBucketInventoryConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBucketInventoryConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketInventoryConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketInventoryConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "inventory", value: nil))
        if let id = input.operationInput.id {
            let idQueryItem = URLQueryItem(name: "id".urlPercentEncoding(), value: String(id).urlPercentEncoding())
            input.builder.withQueryItem(idQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketInventoryConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketInventoryConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketInventoryConfigurationOutputError>
}

public struct PutBucketInventoryConfigurationInput: Equatable {
    /// <p>The name of the bucket where the inventory configuration will be stored.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The ID used to identify the inventory configuration.</p>
    public let id: String?
    /// <p>Specifies the inventory configuration.</p>
    public let inventoryConfiguration: InventoryConfiguration?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        id: String? = nil,
        inventoryConfiguration: InventoryConfiguration? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.id = id
        self.inventoryConfiguration = inventoryConfiguration
    }
}

struct PutBucketInventoryConfigurationInputBody: Equatable {
    public let inventoryConfiguration: InventoryConfiguration?
}

extension PutBucketInventoryConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inventoryConfiguration = "InventoryConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inventoryConfigurationDecoded = try containerValues.decodeIfPresent(InventoryConfiguration.self, forKey: .inventoryConfiguration)
        inventoryConfiguration = inventoryConfigurationDecoded
    }
}

extension PutBucketInventoryConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutBucketInventoryConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBucketInventoryConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketInventoryConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketInventoryConfigurationOutputResponse()"}
}

extension PutBucketInventoryConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketInventoryConfigurationOutputResponse: Equatable {

    public init() {}
}

struct PutBucketInventoryConfigurationOutputResponseBody: Equatable {
}

extension PutBucketInventoryConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutBucketLifecycleConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutBucketLifecycleConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketLifecycleConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketLifecycleConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let lifecycleConfiguration = input.operationInput.lifecycleConfiguration {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(lifecycleConfiguration)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketLifecycleConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketLifecycleConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketLifecycleConfigurationOutputError>
}

extension PutBucketLifecycleConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketLifecycleConfigurationInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), lifecycleConfiguration: \(String(describing: lifecycleConfiguration)))"}
}

extension PutBucketLifecycleConfigurationInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketLifecycleConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lifecycleConfiguration = "LifecycleConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let lifecycleConfiguration = lifecycleConfiguration {
            try container.encode(lifecycleConfiguration, forKey: Key("LifecycleConfiguration"))
        }
    }
}

public struct PutBucketLifecycleConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutBucketLifecycleConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketLifecycleConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketLifecycleConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketLifecycleConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketLifecycleConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketLifecycleConfigurationOutputError>
}

public struct PutBucketLifecycleConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBucketLifecycleConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketLifecycleConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketLifecycleConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "lifecycle", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketLifecycleConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketLifecycleConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketLifecycleConfigurationOutputError>
}

public struct PutBucketLifecycleConfigurationInput: Equatable {
    /// <p>The name of the bucket for which to set the configuration.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>Container for lifecycle rules. You can add as many as 1,000 rules.</p>
    public let lifecycleConfiguration: BucketLifecycleConfiguration?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        lifecycleConfiguration: BucketLifecycleConfiguration? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.lifecycleConfiguration = lifecycleConfiguration
    }
}

struct PutBucketLifecycleConfigurationInputBody: Equatable {
    public let lifecycleConfiguration: BucketLifecycleConfiguration?
}

extension PutBucketLifecycleConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lifecycleConfiguration = "LifecycleConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleConfigurationDecoded = try containerValues.decodeIfPresent(BucketLifecycleConfiguration.self, forKey: .lifecycleConfiguration)
        lifecycleConfiguration = lifecycleConfigurationDecoded
    }
}

extension PutBucketLifecycleConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutBucketLifecycleConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBucketLifecycleConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketLifecycleConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketLifecycleConfigurationOutputResponse()"}
}

extension PutBucketLifecycleConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketLifecycleConfigurationOutputResponse: Equatable {

    public init() {}
}

struct PutBucketLifecycleConfigurationOutputResponseBody: Equatable {
}

extension PutBucketLifecycleConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutBucketLoggingInputBodyMiddleware: Middleware {
    public let id: String = "PutBucketLoggingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketLoggingInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let bucketLoggingStatus = input.operationInput.bucketLoggingStatus {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(bucketLoggingStatus)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketLoggingInput>
    public typealias MOutput = OperationOutput<PutBucketLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketLoggingOutputError>
}

extension PutBucketLoggingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketLoggingInput(bucket: \(String(describing: bucket)), bucketLoggingStatus: \(String(describing: bucketLoggingStatus)), contentMD5: \(String(describing: contentMD5)), expectedBucketOwner: \(String(describing: expectedBucketOwner)))"}
}

extension PutBucketLoggingInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketLoggingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketLoggingStatus = "BucketLoggingStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let bucketLoggingStatus = bucketLoggingStatus {
            try container.encode(bucketLoggingStatus, forKey: Key("BucketLoggingStatus"))
        }
    }
}

public struct PutBucketLoggingInputHeadersMiddleware: Middleware {
    public let id: String = "PutBucketLoggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketLoggingInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contentMD5 = input.operationInput.contentMD5 {
            input.builder.withHeader(name: "Content-MD5", value: String(contentMD5))
        }
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketLoggingInput>
    public typealias MOutput = OperationOutput<PutBucketLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketLoggingOutputError>
}

public struct PutBucketLoggingInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBucketLoggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketLoggingInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "logging", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketLoggingInput>
    public typealias MOutput = OperationOutput<PutBucketLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketLoggingOutputError>
}

public struct PutBucketLoggingInput: Equatable {
    /// <p>The name of the bucket for which to set the logging parameters.</p>
    public let bucket: String?
    /// <p>Container for logging status information.</p>
    public let bucketLoggingStatus: BucketLoggingStatus?
    /// <p>The MD5 hash of the <code>PutBucketLogging</code> request body.</p>
    ///          <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    public let contentMD5: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?

    public init (
        bucket: String? = nil,
        bucketLoggingStatus: BucketLoggingStatus? = nil,
        contentMD5: String? = nil,
        expectedBucketOwner: String? = nil
    )
    {
        self.bucket = bucket
        self.bucketLoggingStatus = bucketLoggingStatus
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
    }
}

struct PutBucketLoggingInputBody: Equatable {
    public let bucketLoggingStatus: BucketLoggingStatus?
}

extension PutBucketLoggingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bucketLoggingStatus = "BucketLoggingStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketLoggingStatusDecoded = try containerValues.decodeIfPresent(BucketLoggingStatus.self, forKey: .bucketLoggingStatus)
        bucketLoggingStatus = bucketLoggingStatusDecoded
    }
}

extension PutBucketLoggingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutBucketLoggingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBucketLoggingOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketLoggingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketLoggingOutputResponse()"}
}

extension PutBucketLoggingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketLoggingOutputResponse: Equatable {

    public init() {}
}

struct PutBucketLoggingOutputResponseBody: Equatable {
}

extension PutBucketLoggingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutBucketMetricsConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutBucketMetricsConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketMetricsConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketMetricsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let metricsConfiguration = input.operationInput.metricsConfiguration {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(metricsConfiguration)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketMetricsConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketMetricsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketMetricsConfigurationOutputError>
}

extension PutBucketMetricsConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketMetricsConfigurationInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), id: \(String(describing: id)), metricsConfiguration: \(String(describing: metricsConfiguration)))"}
}

extension PutBucketMetricsConfigurationInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketMetricsConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case metricsConfiguration = "MetricsConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let metricsConfiguration = metricsConfiguration {
            try container.encode(metricsConfiguration, forKey: Key("MetricsConfiguration"))
        }
    }
}

public struct PutBucketMetricsConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutBucketMetricsConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketMetricsConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketMetricsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketMetricsConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketMetricsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketMetricsConfigurationOutputError>
}

public struct PutBucketMetricsConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBucketMetricsConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketMetricsConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketMetricsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "metrics", value: nil))
        if let id = input.operationInput.id {
            let idQueryItem = URLQueryItem(name: "id".urlPercentEncoding(), value: String(id).urlPercentEncoding())
            input.builder.withQueryItem(idQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketMetricsConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketMetricsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketMetricsConfigurationOutputError>
}

public struct PutBucketMetricsConfigurationInput: Equatable {
    /// <p>The name of the bucket for which the metrics configuration is set.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The ID used to identify the metrics configuration.</p>
    public let id: String?
    /// <p>Specifies the metrics configuration.</p>
    public let metricsConfiguration: MetricsConfiguration?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        id: String? = nil,
        metricsConfiguration: MetricsConfiguration? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.id = id
        self.metricsConfiguration = metricsConfiguration
    }
}

struct PutBucketMetricsConfigurationInputBody: Equatable {
    public let metricsConfiguration: MetricsConfiguration?
}

extension PutBucketMetricsConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metricsConfiguration = "MetricsConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricsConfigurationDecoded = try containerValues.decodeIfPresent(MetricsConfiguration.self, forKey: .metricsConfiguration)
        metricsConfiguration = metricsConfigurationDecoded
    }
}

extension PutBucketMetricsConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutBucketMetricsConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBucketMetricsConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketMetricsConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketMetricsConfigurationOutputResponse()"}
}

extension PutBucketMetricsConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketMetricsConfigurationOutputResponse: Equatable {

    public init() {}
}

struct PutBucketMetricsConfigurationOutputResponseBody: Equatable {
}

extension PutBucketMetricsConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutBucketNotificationConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutBucketNotificationConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketNotificationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketNotificationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let notificationConfiguration = input.operationInput.notificationConfiguration {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(notificationConfiguration)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketNotificationConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketNotificationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketNotificationConfigurationOutputError>
}

extension PutBucketNotificationConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketNotificationConfigurationInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), notificationConfiguration: \(String(describing: notificationConfiguration)))"}
}

extension PutBucketNotificationConfigurationInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketNotificationConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case notificationConfiguration = "NotificationConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let notificationConfiguration = notificationConfiguration {
            try container.encode(notificationConfiguration, forKey: Key("NotificationConfiguration"))
        }
    }
}

public struct PutBucketNotificationConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutBucketNotificationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketNotificationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketNotificationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketNotificationConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketNotificationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketNotificationConfigurationOutputError>
}

public struct PutBucketNotificationConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBucketNotificationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketNotificationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketNotificationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "notification", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketNotificationConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketNotificationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketNotificationConfigurationOutputError>
}

public struct PutBucketNotificationConfigurationInput: Equatable {
    /// <p>The name of the bucket.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>A container for specifying the notification configuration of the bucket. If this element
    ///          is empty, notifications are turned off for the bucket.</p>
    public let notificationConfiguration: NotificationConfiguration?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        notificationConfiguration: NotificationConfiguration? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.notificationConfiguration = notificationConfiguration
    }
}

struct PutBucketNotificationConfigurationInputBody: Equatable {
    public let notificationConfiguration: NotificationConfiguration?
}

extension PutBucketNotificationConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case notificationConfiguration = "NotificationConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationConfigurationDecoded = try containerValues.decodeIfPresent(NotificationConfiguration.self, forKey: .notificationConfiguration)
        notificationConfiguration = notificationConfigurationDecoded
    }
}

extension PutBucketNotificationConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutBucketNotificationConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBucketNotificationConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketNotificationConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketNotificationConfigurationOutputResponse()"}
}

extension PutBucketNotificationConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketNotificationConfigurationOutputResponse: Equatable {

    public init() {}
}

struct PutBucketNotificationConfigurationOutputResponseBody: Equatable {
}

extension PutBucketNotificationConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutBucketOwnershipControlsInputBodyMiddleware: Middleware {
    public let id: String = "PutBucketOwnershipControlsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketOwnershipControlsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketOwnershipControlsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ownershipControls = input.operationInput.ownershipControls {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(ownershipControls)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketOwnershipControlsInput>
    public typealias MOutput = OperationOutput<PutBucketOwnershipControlsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketOwnershipControlsOutputError>
}

extension PutBucketOwnershipControlsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketOwnershipControlsInput(bucket: \(String(describing: bucket)), contentMD5: \(String(describing: contentMD5)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), ownershipControls: \(String(describing: ownershipControls)))"}
}

extension PutBucketOwnershipControlsInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketOwnershipControlsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ownershipControls = "OwnershipControls"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let ownershipControls = ownershipControls {
            try container.encode(ownershipControls, forKey: Key("OwnershipControls"))
        }
    }
}

public struct PutBucketOwnershipControlsInputHeadersMiddleware: Middleware {
    public let id: String = "PutBucketOwnershipControlsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketOwnershipControlsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketOwnershipControlsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contentMD5 = input.operationInput.contentMD5 {
            input.builder.withHeader(name: "Content-MD5", value: String(contentMD5))
        }
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketOwnershipControlsInput>
    public typealias MOutput = OperationOutput<PutBucketOwnershipControlsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketOwnershipControlsOutputError>
}

public struct PutBucketOwnershipControlsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBucketOwnershipControlsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketOwnershipControlsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketOwnershipControlsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "ownershipControls", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketOwnershipControlsInput>
    public typealias MOutput = OperationOutput<PutBucketOwnershipControlsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketOwnershipControlsOutputError>
}

public struct PutBucketOwnershipControlsInput: Equatable {
    /// <p>The name of the Amazon S3 bucket whose <code>OwnershipControls</code> you want to set.</p>
    public let bucket: String?
    /// <p>The MD5 hash of the <code>OwnershipControls</code> request body. </p>
    ///          <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    public let contentMD5: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The <code>OwnershipControls</code> (BucketOwnerPreferred or ObjectWriter) that you want
    ///          to apply to this Amazon S3 bucket.</p>
    public let ownershipControls: OwnershipControls?

    public init (
        bucket: String? = nil,
        contentMD5: String? = nil,
        expectedBucketOwner: String? = nil,
        ownershipControls: OwnershipControls? = nil
    )
    {
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.ownershipControls = ownershipControls
    }
}

struct PutBucketOwnershipControlsInputBody: Equatable {
    public let ownershipControls: OwnershipControls?
}

extension PutBucketOwnershipControlsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ownershipControls = "OwnershipControls"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownershipControlsDecoded = try containerValues.decodeIfPresent(OwnershipControls.self, forKey: .ownershipControls)
        ownershipControls = ownershipControlsDecoded
    }
}

extension PutBucketOwnershipControlsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutBucketOwnershipControlsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBucketOwnershipControlsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketOwnershipControlsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketOwnershipControlsOutputResponse()"}
}

extension PutBucketOwnershipControlsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketOwnershipControlsOutputResponse: Equatable {

    public init() {}
}

struct PutBucketOwnershipControlsOutputResponseBody: Equatable {
}

extension PutBucketOwnershipControlsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutBucketPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutBucketPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let policy = input.operationInput.policy {
            let data = policy.data(using: .utf8)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketPolicyInput>
    public typealias MOutput = OperationOutput<PutBucketPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketPolicyOutputError>
}

extension PutBucketPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketPolicyInput(bucket: \(String(describing: bucket)), confirmRemoveSelfBucketAccess: \(String(describing: confirmRemoveSelfBucketAccess)), contentMD5: \(String(describing: contentMD5)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), policy: \(String(describing: policy)))"}
}

extension PutBucketPolicyInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: Key("policy"))
        }
    }
}

public struct PutBucketPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutBucketPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withHeader(name: "x-amz-confirm-remove-self-bucket-access", value: String(input.operationInput.confirmRemoveSelfBucketAccess))
        if let contentMD5 = input.operationInput.contentMD5 {
            input.builder.withHeader(name: "Content-MD5", value: String(contentMD5))
        }
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketPolicyInput>
    public typealias MOutput = OperationOutput<PutBucketPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketPolicyOutputError>
}

public struct PutBucketPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBucketPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "policy", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketPolicyInput>
    public typealias MOutput = OperationOutput<PutBucketPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketPolicyOutputError>
}

public struct PutBucketPolicyInput: Equatable {
    /// <p>The name of the bucket.</p>
    public let bucket: String?
    /// <p>Set this parameter to true to confirm that you want to remove your permissions to change
    ///          this bucket policy in the future.</p>
    public let confirmRemoveSelfBucketAccess: Bool
    /// <p>The MD5 hash of the request body.</p>
    ///          <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    public let contentMD5: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The bucket policy as a JSON document.</p>
    public let policy: String?

    public init (
        bucket: String? = nil,
        confirmRemoveSelfBucketAccess: Bool = false,
        contentMD5: String? = nil,
        expectedBucketOwner: String? = nil,
        policy: String? = nil
    )
    {
        self.bucket = bucket
        self.confirmRemoveSelfBucketAccess = confirmRemoveSelfBucketAccess
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.policy = policy
    }
}

struct PutBucketPolicyInputBody: Equatable {
    public let policy: String?
}

extension PutBucketPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutBucketPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutBucketPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBucketPolicyOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketPolicyOutputResponse()"}
}

extension PutBucketPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketPolicyOutputResponse: Equatable {

    public init() {}
}

struct PutBucketPolicyOutputResponseBody: Equatable {
}

extension PutBucketPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutBucketReplicationInputBodyMiddleware: Middleware {
    public let id: String = "PutBucketReplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let replicationConfiguration = input.operationInput.replicationConfiguration {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(replicationConfiguration)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketReplicationInput>
    public typealias MOutput = OperationOutput<PutBucketReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketReplicationOutputError>
}

extension PutBucketReplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketReplicationInput(bucket: \(String(describing: bucket)), contentMD5: \(String(describing: contentMD5)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), replicationConfiguration: \(String(describing: replicationConfiguration)), token: \(String(describing: token)))"}
}

extension PutBucketReplicationInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketReplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replicationConfiguration = "ReplicationConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let replicationConfiguration = replicationConfiguration {
            try container.encode(replicationConfiguration, forKey: Key("ReplicationConfiguration"))
        }
    }
}

public struct PutBucketReplicationInputHeadersMiddleware: Middleware {
    public let id: String = "PutBucketReplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contentMD5 = input.operationInput.contentMD5 {
            input.builder.withHeader(name: "Content-MD5", value: String(contentMD5))
        }
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let token = input.operationInput.token {
            input.builder.withHeader(name: "x-amz-bucket-object-lock-token", value: String(token))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketReplicationInput>
    public typealias MOutput = OperationOutput<PutBucketReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketReplicationOutputError>
}

public struct PutBucketReplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBucketReplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "replication", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketReplicationInput>
    public typealias MOutput = OperationOutput<PutBucketReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketReplicationOutputError>
}

public struct PutBucketReplicationInput: Equatable {
    /// <p>The name of the bucket</p>
    public let bucket: String?
    /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message
    ///          integrity check to verify that the request body was not corrupted in transit. For more
    ///          information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC 1864</a>.</p>
    ///          <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    public let contentMD5: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>A container for replication rules. You can add up to 1,000 rules. The maximum size of a
    ///          replication configuration is 2 MB.</p>
    public let replicationConfiguration: ReplicationConfiguration?
    /// <p>A token to allow Object Lock to be enabled for an existing bucket.</p>
    public let token: String?

    public init (
        bucket: String? = nil,
        contentMD5: String? = nil,
        expectedBucketOwner: String? = nil,
        replicationConfiguration: ReplicationConfiguration? = nil,
        token: String? = nil
    )
    {
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.replicationConfiguration = replicationConfiguration
        self.token = token
    }
}

struct PutBucketReplicationInputBody: Equatable {
    public let replicationConfiguration: ReplicationConfiguration?
}

extension PutBucketReplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationConfiguration = "ReplicationConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationDecoded = try containerValues.decodeIfPresent(ReplicationConfiguration.self, forKey: .replicationConfiguration)
        replicationConfiguration = replicationConfigurationDecoded
    }
}

extension PutBucketReplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutBucketReplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBucketReplicationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketReplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketReplicationOutputResponse()"}
}

extension PutBucketReplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketReplicationOutputResponse: Equatable {

    public init() {}
}

struct PutBucketReplicationOutputResponseBody: Equatable {
}

extension PutBucketReplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutBucketRequestPaymentInputBodyMiddleware: Middleware {
    public let id: String = "PutBucketRequestPaymentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketRequestPaymentInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketRequestPaymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let requestPaymentConfiguration = input.operationInput.requestPaymentConfiguration {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(requestPaymentConfiguration)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketRequestPaymentInput>
    public typealias MOutput = OperationOutput<PutBucketRequestPaymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketRequestPaymentOutputError>
}

extension PutBucketRequestPaymentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketRequestPaymentInput(bucket: \(String(describing: bucket)), contentMD5: \(String(describing: contentMD5)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), requestPaymentConfiguration: \(String(describing: requestPaymentConfiguration)))"}
}

extension PutBucketRequestPaymentInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketRequestPaymentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case requestPaymentConfiguration = "RequestPaymentConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let requestPaymentConfiguration = requestPaymentConfiguration {
            try container.encode(requestPaymentConfiguration, forKey: Key("RequestPaymentConfiguration"))
        }
    }
}

public struct PutBucketRequestPaymentInputHeadersMiddleware: Middleware {
    public let id: String = "PutBucketRequestPaymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketRequestPaymentInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketRequestPaymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contentMD5 = input.operationInput.contentMD5 {
            input.builder.withHeader(name: "Content-MD5", value: String(contentMD5))
        }
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketRequestPaymentInput>
    public typealias MOutput = OperationOutput<PutBucketRequestPaymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketRequestPaymentOutputError>
}

public struct PutBucketRequestPaymentInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBucketRequestPaymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketRequestPaymentInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketRequestPaymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "requestPayment", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketRequestPaymentInput>
    public typealias MOutput = OperationOutput<PutBucketRequestPaymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketRequestPaymentOutputError>
}

public struct PutBucketRequestPaymentInput: Equatable {
    /// <p>The bucket name.</p>
    public let bucket: String?
    /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a
    ///          message integrity check to verify that the request body was not corrupted in transit. For
    ///          more information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
    ///          1864</a>.</p>
    ///          <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    public let contentMD5: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>Container for Payer.</p>
    public let requestPaymentConfiguration: RequestPaymentConfiguration?

    public init (
        bucket: String? = nil,
        contentMD5: String? = nil,
        expectedBucketOwner: String? = nil,
        requestPaymentConfiguration: RequestPaymentConfiguration? = nil
    )
    {
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.requestPaymentConfiguration = requestPaymentConfiguration
    }
}

struct PutBucketRequestPaymentInputBody: Equatable {
    public let requestPaymentConfiguration: RequestPaymentConfiguration?
}

extension PutBucketRequestPaymentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestPaymentConfiguration = "RequestPaymentConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestPaymentConfigurationDecoded = try containerValues.decodeIfPresent(RequestPaymentConfiguration.self, forKey: .requestPaymentConfiguration)
        requestPaymentConfiguration = requestPaymentConfigurationDecoded
    }
}

extension PutBucketRequestPaymentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutBucketRequestPaymentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBucketRequestPaymentOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketRequestPaymentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketRequestPaymentOutputResponse()"}
}

extension PutBucketRequestPaymentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketRequestPaymentOutputResponse: Equatable {

    public init() {}
}

struct PutBucketRequestPaymentOutputResponseBody: Equatable {
}

extension PutBucketRequestPaymentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutBucketTaggingInputBodyMiddleware: Middleware {
    public let id: String = "PutBucketTaggingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagging = input.operationInput.tagging {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(tagging)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketTaggingInput>
    public typealias MOutput = OperationOutput<PutBucketTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketTaggingOutputError>
}

extension PutBucketTaggingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketTaggingInput(bucket: \(String(describing: bucket)), contentMD5: \(String(describing: contentMD5)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), tagging: \(String(describing: tagging)))"}
}

extension PutBucketTaggingInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketTaggingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tagging = "Tagging"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let tagging = tagging {
            try container.encode(tagging, forKey: Key("Tagging"))
        }
    }
}

public struct PutBucketTaggingInputHeadersMiddleware: Middleware {
    public let id: String = "PutBucketTaggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contentMD5 = input.operationInput.contentMD5 {
            input.builder.withHeader(name: "Content-MD5", value: String(contentMD5))
        }
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketTaggingInput>
    public typealias MOutput = OperationOutput<PutBucketTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketTaggingOutputError>
}

public struct PutBucketTaggingInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBucketTaggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "tagging", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketTaggingInput>
    public typealias MOutput = OperationOutput<PutBucketTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketTaggingOutputError>
}

public struct PutBucketTaggingInput: Equatable {
    /// <p>The bucket name.</p>
    public let bucket: String?
    /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message
    ///          integrity check to verify that the request body was not corrupted in transit. For more
    ///          information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC 1864</a>.</p>
    ///          <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    public let contentMD5: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>Container for the <code>TagSet</code> and <code>Tag</code> elements.</p>
    public let tagging: Tagging?

    public init (
        bucket: String? = nil,
        contentMD5: String? = nil,
        expectedBucketOwner: String? = nil,
        tagging: Tagging? = nil
    )
    {
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.tagging = tagging
    }
}

struct PutBucketTaggingInputBody: Equatable {
    public let tagging: Tagging?
}

extension PutBucketTaggingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagging = "Tagging"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taggingDecoded = try containerValues.decodeIfPresent(Tagging.self, forKey: .tagging)
        tagging = taggingDecoded
    }
}

extension PutBucketTaggingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutBucketTaggingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBucketTaggingOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketTaggingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketTaggingOutputResponse()"}
}

extension PutBucketTaggingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketTaggingOutputResponse: Equatable {

    public init() {}
}

struct PutBucketTaggingOutputResponseBody: Equatable {
}

extension PutBucketTaggingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutBucketVersioningInputBodyMiddleware: Middleware {
    public let id: String = "PutBucketVersioningInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketVersioningInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketVersioningOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let versioningConfiguration = input.operationInput.versioningConfiguration {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(versioningConfiguration)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketVersioningInput>
    public typealias MOutput = OperationOutput<PutBucketVersioningOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketVersioningOutputError>
}

extension PutBucketVersioningInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketVersioningInput(bucket: \(String(describing: bucket)), contentMD5: \(String(describing: contentMD5)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), mFA: \(String(describing: mFA)), versioningConfiguration: \(String(describing: versioningConfiguration)))"}
}

extension PutBucketVersioningInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketVersioningInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case versioningConfiguration = "VersioningConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let versioningConfiguration = versioningConfiguration {
            try container.encode(versioningConfiguration, forKey: Key("VersioningConfiguration"))
        }
    }
}

public struct PutBucketVersioningInputHeadersMiddleware: Middleware {
    public let id: String = "PutBucketVersioningInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketVersioningInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketVersioningOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contentMD5 = input.operationInput.contentMD5 {
            input.builder.withHeader(name: "Content-MD5", value: String(contentMD5))
        }
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let mFA = input.operationInput.mFA {
            input.builder.withHeader(name: "x-amz-mfa", value: String(mFA))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketVersioningInput>
    public typealias MOutput = OperationOutput<PutBucketVersioningOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketVersioningOutputError>
}

public struct PutBucketVersioningInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBucketVersioningInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketVersioningInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketVersioningOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "versioning", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketVersioningInput>
    public typealias MOutput = OperationOutput<PutBucketVersioningOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketVersioningOutputError>
}

public struct PutBucketVersioningInput: Equatable {
    /// <p>The bucket name.</p>
    public let bucket: String?
    /// <p>>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a
    ///          message integrity check to verify that the request body was not corrupted in transit. For
    ///          more information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
    ///          1864</a>.</p>
    ///          <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    public let contentMD5: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The concatenation of the authentication device's serial number, a space, and the value
    ///          that is displayed on your authentication device.</p>
    public let mFA: String?
    /// <p>Container for setting the versioning state.</p>
    public let versioningConfiguration: VersioningConfiguration?

    public init (
        bucket: String? = nil,
        contentMD5: String? = nil,
        expectedBucketOwner: String? = nil,
        mFA: String? = nil,
        versioningConfiguration: VersioningConfiguration? = nil
    )
    {
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.mFA = mFA
        self.versioningConfiguration = versioningConfiguration
    }
}

struct PutBucketVersioningInputBody: Equatable {
    public let versioningConfiguration: VersioningConfiguration?
}

extension PutBucketVersioningInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case versioningConfiguration = "VersioningConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versioningConfigurationDecoded = try containerValues.decodeIfPresent(VersioningConfiguration.self, forKey: .versioningConfiguration)
        versioningConfiguration = versioningConfigurationDecoded
    }
}

extension PutBucketVersioningOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutBucketVersioningOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBucketVersioningOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketVersioningOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketVersioningOutputResponse()"}
}

extension PutBucketVersioningOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketVersioningOutputResponse: Equatable {

    public init() {}
}

struct PutBucketVersioningOutputResponseBody: Equatable {
}

extension PutBucketVersioningOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutBucketWebsiteInputBodyMiddleware: Middleware {
    public let id: String = "PutBucketWebsiteInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketWebsiteInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketWebsiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let websiteConfiguration = input.operationInput.websiteConfiguration {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(websiteConfiguration)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketWebsiteInput>
    public typealias MOutput = OperationOutput<PutBucketWebsiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketWebsiteOutputError>
}

extension PutBucketWebsiteInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketWebsiteInput(bucket: \(String(describing: bucket)), contentMD5: \(String(describing: contentMD5)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), websiteConfiguration: \(String(describing: websiteConfiguration)))"}
}

extension PutBucketWebsiteInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketWebsiteInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case websiteConfiguration = "WebsiteConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let websiteConfiguration = websiteConfiguration {
            try container.encode(websiteConfiguration, forKey: Key("WebsiteConfiguration"))
        }
    }
}

public struct PutBucketWebsiteInputHeadersMiddleware: Middleware {
    public let id: String = "PutBucketWebsiteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketWebsiteInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketWebsiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contentMD5 = input.operationInput.contentMD5 {
            input.builder.withHeader(name: "Content-MD5", value: String(contentMD5))
        }
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketWebsiteInput>
    public typealias MOutput = OperationOutput<PutBucketWebsiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketWebsiteOutputError>
}

public struct PutBucketWebsiteInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBucketWebsiteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketWebsiteInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketWebsiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "website", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketWebsiteInput>
    public typealias MOutput = OperationOutput<PutBucketWebsiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketWebsiteOutputError>
}

public struct PutBucketWebsiteInput: Equatable {
    /// <p>The bucket name.</p>
    public let bucket: String?
    /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message
    ///          integrity check to verify that the request body was not corrupted in transit. For more
    ///          information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC 1864</a>.</p>
    ///          <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    public let contentMD5: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>Container for the request.</p>
    public let websiteConfiguration: WebsiteConfiguration?

    public init (
        bucket: String? = nil,
        contentMD5: String? = nil,
        expectedBucketOwner: String? = nil,
        websiteConfiguration: WebsiteConfiguration? = nil
    )
    {
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.websiteConfiguration = websiteConfiguration
    }
}

struct PutBucketWebsiteInputBody: Equatable {
    public let websiteConfiguration: WebsiteConfiguration?
}

extension PutBucketWebsiteInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case websiteConfiguration = "WebsiteConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let websiteConfigurationDecoded = try containerValues.decodeIfPresent(WebsiteConfiguration.self, forKey: .websiteConfiguration)
        websiteConfiguration = websiteConfigurationDecoded
    }
}

extension PutBucketWebsiteOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutBucketWebsiteOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBucketWebsiteOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketWebsiteOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketWebsiteOutputResponse()"}
}

extension PutBucketWebsiteOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketWebsiteOutputResponse: Equatable {

    public init() {}
}

struct PutBucketWebsiteOutputResponseBody: Equatable {
}

extension PutBucketWebsiteOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutObjectAclInputBodyMiddleware: Middleware {
    public let id: String = "PutObjectAclInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutObjectAclInput>,
                  next: H) -> Swift.Result<OperationOutput<PutObjectAclOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accessControlPolicy = input.operationInput.accessControlPolicy {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(accessControlPolicy)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutObjectAclInput>
    public typealias MOutput = OperationOutput<PutObjectAclOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutObjectAclOutputError>
}

extension PutObjectAclInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutObjectAclInput(aCL: \(String(describing: aCL)), accessControlPolicy: \(String(describing: accessControlPolicy)), bucket: \(String(describing: bucket)), contentMD5: \(String(describing: contentMD5)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), grantFullControl: \(String(describing: grantFullControl)), grantRead: \(String(describing: grantRead)), grantReadACP: \(String(describing: grantReadACP)), grantWrite: \(String(describing: grantWrite)), grantWriteACP: \(String(describing: grantWriteACP)), key: \(String(describing: key)), requestPayer: \(String(describing: requestPayer)), versionId: \(String(describing: versionId)))"}
}

extension PutObjectAclInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutObjectAclInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessControlPolicy = "AccessControlPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let accessControlPolicy = accessControlPolicy {
            try container.encode(accessControlPolicy, forKey: Key("AccessControlPolicy"))
        }
    }
}

public struct PutObjectAclInputHeadersMiddleware: Middleware {
    public let id: String = "PutObjectAclInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutObjectAclInput>,
                  next: H) -> Swift.Result<OperationOutput<PutObjectAclOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let aCL = input.operationInput.aCL {
            input.builder.withHeader(name: "x-amz-acl", value: String(aCL.rawValue))
        }
        if let contentMD5 = input.operationInput.contentMD5 {
            input.builder.withHeader(name: "Content-MD5", value: String(contentMD5))
        }
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let grantFullControl = input.operationInput.grantFullControl {
            input.builder.withHeader(name: "x-amz-grant-full-control", value: String(grantFullControl))
        }
        if let grantRead = input.operationInput.grantRead {
            input.builder.withHeader(name: "x-amz-grant-read", value: String(grantRead))
        }
        if let grantReadACP = input.operationInput.grantReadACP {
            input.builder.withHeader(name: "x-amz-grant-read-acp", value: String(grantReadACP))
        }
        if let grantWrite = input.operationInput.grantWrite {
            input.builder.withHeader(name: "x-amz-grant-write", value: String(grantWrite))
        }
        if let grantWriteACP = input.operationInput.grantWriteACP {
            input.builder.withHeader(name: "x-amz-grant-write-acp", value: String(grantWriteACP))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutObjectAclInput>
    public typealias MOutput = OperationOutput<PutObjectAclOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutObjectAclOutputError>
}

public struct PutObjectAclInputQueryItemMiddleware: Middleware {
    public let id: String = "PutObjectAclInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutObjectAclInput>,
                  next: H) -> Swift.Result<OperationOutput<PutObjectAclOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "acl", value: nil))
        if let versionId = input.operationInput.versionId {
            let versionIdQueryItem = URLQueryItem(name: "versionId".urlPercentEncoding(), value: String(versionId).urlPercentEncoding())
            input.builder.withQueryItem(versionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutObjectAclInput>
    public typealias MOutput = OperationOutput<PutObjectAclOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutObjectAclOutputError>
}

public struct PutObjectAclInput: Equatable {
    /// <p>The canned ACL to apply to the object. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#CannedACL">Canned ACL</a>.</p>
    public let aCL: ObjectCannedACL?
    /// <p>Contains the elements that set the ACL permissions for an object per grantee.</p>
    public let accessControlPolicy: AccessControlPolicy?
    /// <p>The bucket name that contains the object to which you want to attach the ACL. </p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>The base64-encoded 128-bit MD5 digest of the data. This header must be used as a message
    ///          integrity check to verify that the request body was not corrupted in transit. For more
    ///          information, go to <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
    ///          1864.></a>
    ///          </p>
    ///          <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    public let contentMD5: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>Allows grantee the read, write, read ACP, and write ACP permissions on the
    ///          bucket.</p>
    ///          <p>This action is not supported by Amazon S3 on Outposts.</p>
    public let grantFullControl: String?
    /// <p>Allows grantee to list the objects in the
    ///       bucket.</p>
    ///          <p>This action is not supported by Amazon S3 on Outposts.</p>
    public let grantRead: String?
    /// <p>Allows grantee to read the bucket ACL.</p>
    ///          <p>This action is not supported by Amazon S3 on Outposts.</p>
    public let grantReadACP: String?
    /// <p>Allows grantee to create new objects in the bucket.</p>
    ///          <p>For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects.</p>
    public let grantWrite: String?
    /// <p>Allows grantee to write the ACL for the applicable
    ///       bucket.</p>
    ///          <p>This action is not supported by Amazon S3 on Outposts.</p>
    public let grantWriteACP: String?
    /// <p>Key for which the PUT action was initiated.</p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let key: String?
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    ///          owners need not specify this parameter in their requests. For information about downloading
    ///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    ///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let requestPayer: RequestPayer?
    /// <p>VersionId used to reference a specific version of the object.</p>
    public let versionId: String?

    public init (
        aCL: ObjectCannedACL? = nil,
        accessControlPolicy: AccessControlPolicy? = nil,
        bucket: String? = nil,
        contentMD5: String? = nil,
        expectedBucketOwner: String? = nil,
        grantFullControl: String? = nil,
        grantRead: String? = nil,
        grantReadACP: String? = nil,
        grantWrite: String? = nil,
        grantWriteACP: String? = nil,
        key: String? = nil,
        requestPayer: RequestPayer? = nil,
        versionId: String? = nil
    )
    {
        self.aCL = aCL
        self.accessControlPolicy = accessControlPolicy
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.grantFullControl = grantFullControl
        self.grantRead = grantRead
        self.grantReadACP = grantReadACP
        self.grantWrite = grantWrite
        self.grantWriteACP = grantWriteACP
        self.key = key
        self.requestPayer = requestPayer
        self.versionId = versionId
    }
}

struct PutObjectAclInputBody: Equatable {
    public let accessControlPolicy: AccessControlPolicy?
}

extension PutObjectAclInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessControlPolicy = "AccessControlPolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessControlPolicyDecoded = try containerValues.decodeIfPresent(AccessControlPolicy.self, forKey: .accessControlPolicy)
        accessControlPolicy = accessControlPolicyDecoded
    }
}

extension PutObjectAclOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutObjectAclOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchKey" : self = .noSuchKey(try NoSuchKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutObjectAclOutputError: Equatable {
    case noSuchKey(NoSuchKey)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutObjectAclOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutObjectAclOutputResponse(requestCharged: \(String(describing: requestCharged)))"}
}

extension PutObjectAclOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
    }
}

public struct PutObjectAclOutputResponse: Equatable {
    /// <p>If present, indicates that the requester was successfully charged for the
    ///          request.</p>
    public let requestCharged: RequestCharged?

    public init (
        requestCharged: RequestCharged? = nil
    )
    {
        self.requestCharged = requestCharged
    }
}

struct PutObjectAclOutputResponseBody: Equatable {
}

extension PutObjectAclOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutObjectInputBodyMiddleware: Middleware {
    public let id: String = "PutObjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<PutObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let body = input.operationInput.body {
            let data = body
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutObjectInput>
    public typealias MOutput = OperationOutput<PutObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutObjectOutputError>
}

extension PutObjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutObjectInput(aCL: \(String(describing: aCL)), body: \(String(describing: body)), bucket: \(String(describing: bucket)), bucketKeyEnabled: \(String(describing: bucketKeyEnabled)), cacheControl: \(String(describing: cacheControl)), contentDisposition: \(String(describing: contentDisposition)), contentEncoding: \(String(describing: contentEncoding)), contentLanguage: \(String(describing: contentLanguage)), contentLength: \(String(describing: contentLength)), contentMD5: \(String(describing: contentMD5)), contentType: \(String(describing: contentType)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), expires: \(String(describing: expires)), grantFullControl: \(String(describing: grantFullControl)), grantRead: \(String(describing: grantRead)), grantReadACP: \(String(describing: grantReadACP)), grantWriteACP: \(String(describing: grantWriteACP)), key: \(String(describing: key)), metadata: \(String(describing: metadata)), objectLockLegalHoldStatus: \(String(describing: objectLockLegalHoldStatus)), objectLockMode: \(String(describing: objectLockMode)), objectLockRetainUntilDate: \(String(describing: objectLockRetainUntilDate)), requestPayer: \(String(describing: requestPayer)), sSECustomerAlgorithm: \(String(describing: sSECustomerAlgorithm)), sSECustomerKey: \(String(describing: sSECustomerKey)), sSECustomerKeyMD5: \(String(describing: sSECustomerKeyMD5)), sSEKMSEncryptionContext: \(String(describing: sSEKMSEncryptionContext)), sSEKMSKeyId: \(String(describing: sSEKMSKeyId)), serverSideEncryption: \(String(describing: serverSideEncryption)), storageClass: \(String(describing: storageClass)), tagging: \(String(describing: tagging)), websiteRedirectLocation: \(String(describing: websiteRedirectLocation)))"}
}

extension PutObjectInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutObjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let body = body {
            try container.encode(body, forKey: Key("body"))
        }
    }
}

public struct PutObjectInputHeadersMiddleware: Middleware {
    public let id: String = "PutObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<PutObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let aCL = input.operationInput.aCL {
            input.builder.withHeader(name: "x-amz-acl", value: String(aCL.rawValue))
        }
        input.builder.withHeader(name: "x-amz-server-side-encryption-bucket-key-enabled", value: String(input.operationInput.bucketKeyEnabled))
        if let cacheControl = input.operationInput.cacheControl {
            input.builder.withHeader(name: "Cache-Control", value: String(cacheControl))
        }
        if let contentDisposition = input.operationInput.contentDisposition {
            input.builder.withHeader(name: "Content-Disposition", value: String(contentDisposition))
        }
        if let contentEncoding = input.operationInput.contentEncoding {
            input.builder.withHeader(name: "Content-Encoding", value: String(contentEncoding))
        }
        if let contentLanguage = input.operationInput.contentLanguage {
            input.builder.withHeader(name: "Content-Language", value: String(contentLanguage))
        }
        input.builder.withHeader(name: "Content-Length", value: String(input.operationInput.contentLength))
        if let contentMD5 = input.operationInput.contentMD5 {
            input.builder.withHeader(name: "Content-MD5", value: String(contentMD5))
        }
        if let contentType = input.operationInput.contentType {
            input.builder.withHeader(name: "Content-Type", value: String(contentType))
        }
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let expires = input.operationInput.expires {
            input.builder.withHeader(name: "Expires", value: String(expires.rfc5322()))
        }
        if let grantFullControl = input.operationInput.grantFullControl {
            input.builder.withHeader(name: "x-amz-grant-full-control", value: String(grantFullControl))
        }
        if let grantRead = input.operationInput.grantRead {
            input.builder.withHeader(name: "x-amz-grant-read", value: String(grantRead))
        }
        if let grantReadACP = input.operationInput.grantReadACP {
            input.builder.withHeader(name: "x-amz-grant-read-acp", value: String(grantReadACP))
        }
        if let grantWriteACP = input.operationInput.grantWriteACP {
            input.builder.withHeader(name: "x-amz-grant-write-acp", value: String(grantWriteACP))
        }
        if let objectLockLegalHoldStatus = input.operationInput.objectLockLegalHoldStatus {
            input.builder.withHeader(name: "x-amz-object-lock-legal-hold", value: String(objectLockLegalHoldStatus.rawValue))
        }
        if let objectLockMode = input.operationInput.objectLockMode {
            input.builder.withHeader(name: "x-amz-object-lock-mode", value: String(objectLockMode.rawValue))
        }
        if let objectLockRetainUntilDate = input.operationInput.objectLockRetainUntilDate {
            input.builder.withHeader(name: "x-amz-object-lock-retain-until-date", value: String(objectLockRetainUntilDate.iso8601WithoutFractionalSeconds()))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        if let sSECustomerAlgorithm = input.operationInput.sSECustomerAlgorithm {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-algorithm", value: String(sSECustomerAlgorithm))
        }
        if let sSECustomerKey = input.operationInput.sSECustomerKey {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-key", value: String(sSECustomerKey))
        }
        if let sSECustomerKeyMD5 = input.operationInput.sSECustomerKeyMD5 {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-key-MD5", value: String(sSECustomerKeyMD5))
        }
        if let sSEKMSEncryptionContext = input.operationInput.sSEKMSEncryptionContext {
            input.builder.withHeader(name: "x-amz-server-side-encryption-context", value: String(sSEKMSEncryptionContext))
        }
        if let sSEKMSKeyId = input.operationInput.sSEKMSKeyId {
            input.builder.withHeader(name: "x-amz-server-side-encryption-aws-kms-key-id", value: String(sSEKMSKeyId))
        }
        if let serverSideEncryption = input.operationInput.serverSideEncryption {
            input.builder.withHeader(name: "x-amz-server-side-encryption", value: String(serverSideEncryption.rawValue))
        }
        if let storageClass = input.operationInput.storageClass {
            input.builder.withHeader(name: "x-amz-storage-class", value: String(storageClass.rawValue))
        }
        if let tagging = input.operationInput.tagging {
            input.builder.withHeader(name: "x-amz-tagging", value: String(tagging))
        }
        if let websiteRedirectLocation = input.operationInput.websiteRedirectLocation {
            input.builder.withHeader(name: "x-amz-website-redirect-location", value: String(websiteRedirectLocation))
        }
        if let metadata = input.operationInput.metadata {
            for (prefixHeaderMapKey, prefixHeaderMapValue) in metadata {
                input.builder.withHeader(name: "x-amz-meta-\(prefixHeaderMapKey)", value: String(prefixHeaderMapValue))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutObjectInput>
    public typealias MOutput = OperationOutput<PutObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutObjectOutputError>
}

public struct PutObjectInputQueryItemMiddleware: Middleware {
    public let id: String = "PutObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<PutObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "x-id", value: "PutObject"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutObjectInput>
    public typealias MOutput = OperationOutput<PutObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutObjectOutputError>
}

public struct PutObjectInput: Equatable {
    /// <p>The canned ACL to apply to the object. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#CannedACL">Canned
    ///       ACL</a>.</p>
    ///          <p>This action is not supported by Amazon S3 on Outposts.</p>
    public let aCL: ObjectCannedACL?
    /// <p>Object data.</p>
    public let body: Data?
    /// <p>The bucket name to which the PUT action was initiated. </p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to <code>true</code> causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS.</p>
    ///          <p>Specifying this header with a PUT action doesnt affect bucket-level settings for S3 Bucket Key.</p>
    public let bucketKeyEnabled: Bool
    /// <p> Can be used to specify caching behavior along the request/reply chain. For more
    ///          information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9</a>.</p>
    public let cacheControl: String?
    /// <p>Specifies presentational information for the object. For more information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1">http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1</a>.</p>
    public let contentDisposition: String?
    /// <p>Specifies what content encodings have been applied to the object and thus what decoding
    ///          mechanisms must be applied to obtain the media-type referenced by the Content-Type header
    ///          field. For more information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11</a>.</p>
    public let contentEncoding: String?
    /// <p>The language the content is in.</p>
    public let contentLanguage: String?
    /// <p>Size of the body in bytes. This parameter is useful when the size of the body cannot be
    ///          determined automatically. For more information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13</a>.</p>
    public let contentLength: Int
    /// <p>The base64-encoded 128-bit MD5 digest of the message (without the headers) according to
    ///          RFC 1864. This header can be used as a message integrity check to verify that the data is
    ///          the same data that was originally sent. Although it is optional, we recommend using the
    ///          Content-MD5 mechanism as an end-to-end integrity check. For more information about REST
    ///          request authentication, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html">REST
    ///             Authentication</a>.</p>
    public let contentMD5: String?
    /// <p>A standard MIME type describing the format of the contents. For more information, see
    ///             <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17</a>.</p>
    public let contentType: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The date and time at which the object is no longer cacheable. For more information, see
    ///             <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21</a>.</p>
    public let expires: Date?
    /// <p>Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the
    ///       object.</p>
    ///          <p>This action is not supported by Amazon S3 on Outposts.</p>
    public let grantFullControl: String?
    /// <p>Allows grantee to read the object data and its
    ///       metadata.</p>
    ///          <p>This action is not supported by Amazon S3 on Outposts.</p>
    public let grantRead: String?
    /// <p>Allows grantee to read the object ACL.</p>
    ///          <p>This action is not supported by Amazon S3 on Outposts.</p>
    public let grantReadACP: String?
    /// <p>Allows grantee to write the ACL for the applicable
    ///       object.</p>
    ///          <p>This action is not supported by Amazon S3 on Outposts.</p>
    public let grantWriteACP: String?
    /// <p>Object key for which the PUT action was initiated.</p>
    public let key: String?
    /// <p>A map of metadata to store with the object in S3.</p>
    public let metadata: [String:String]?
    /// <p>Specifies whether a legal hold will be applied to this object. For more information
    ///          about S3 Object Lock, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock.html">Object
    ///          Lock</a>.</p>
    public let objectLockLegalHoldStatus: ObjectLockLegalHoldStatus?
    /// <p>The Object Lock mode that you want to apply to this object.</p>
    public let objectLockMode: ObjectLockMode?
    /// <p>The date and time when you want this object's Object Lock to expire. Must be formatted
    ///          as a timestamp parameter.</p>
    public let objectLockRetainUntilDate: Date?
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    ///          owners need not specify this parameter in their requests. For information about downloading
    ///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    ///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let requestPayer: RequestPayer?
    /// <p>Specifies the algorithm to use to when encrypting the object (for example,
    ///          AES256).</p>
    public let sSECustomerAlgorithm: String?
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
    ///          value is used to store the object and then it is discarded; Amazon S3 does not store the
    ///          encryption key. The key must be appropriate for use with the algorithm specified in the
    ///             <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
    public let sSECustomerKey: String?
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    ///          this header for a message integrity check to ensure that the encryption key was transmitted
    ///          without error.</p>
    public let sSECustomerKeyMD5: String?
    /// <p>Specifies the AWS KMS Encryption Context to use for object encryption. The value of this
    ///          header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value
    ///          pairs.</p>
    public let sSEKMSEncryptionContext: String?
    /// <p>If <code>x-amz-server-side-encryption</code> is present and has the value of
    ///          <code>aws:kms</code>, this header specifies the ID of the AWS Key Management Service
    ///          (AWS KMS) symmetrical customer managed customer master key (CMK) that was used for the
    ///          object. If you specify <code>x-amz-server-side-encryption:aws:kms</code>, but do not
    ///          provide<code> x-amz-server-side-encryption-aws-kms-key-id</code>, Amazon S3 uses the AWS
    ///          managed CMK in AWS to protect the data. If the KMS key does not exist in the same account
    ///          issuing the command, you must use the full ARN and not just the ID.
    ///       </p>
    public let sSEKMSKeyId: String?
    /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
    ///          AES256, aws:kms).</p>
    public let serverSideEncryption: ServerSideEncryption?
    /// <p>By default, Amazon S3 uses the STANDARD Storage Class to store newly created objects. The
    ///          STANDARD storage class provides high durability and high availability. Depending on
    ///          performance needs, you can specify a different Storage Class. Amazon S3 on Outposts only uses
    ///          the OUTPOSTS Storage Class. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html">Storage Classes</a> in the
    ///          <i>Amazon S3 User Guide</i>.</p>
    public let storageClass: StorageClass?
    /// <p>The tag-set for the object. The tag-set must be encoded as URL Query parameters. (For
    ///          example, "Key1=Value1")</p>
    public let tagging: String?
    /// <p>If the bucket is configured as a website, redirects requests for this object to another
    ///          object in the same bucket or to an external URL. Amazon S3 stores the value of this header in
    ///          the object metadata. For information about object metadata, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html">Object Key and Metadata</a>.</p>
    ///
    ///          <p>In the following example, the request header sets the redirect to an object
    ///          (anotherPage.html) in the same bucket:</p>
    ///
    ///          <p>
    ///             <code>x-amz-website-redirect-location: /anotherPage.html</code>
    ///          </p>
    ///
    ///          <p>In the following example, the request header sets the object redirect to another
    ///          website:</p>
    ///
    ///          <p>
    ///             <code>x-amz-website-redirect-location: http://www.example.com/</code>
    ///          </p>
    ///
    ///          <p>For more information about website hosting in Amazon S3, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html">Hosting Websites on Amazon S3</a> and <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/how-to-page-redirect.html">How to Configure Website Page
    ///             Redirects</a>. </p>
    public let websiteRedirectLocation: String?

    public init (
        aCL: ObjectCannedACL? = nil,
        body: Data? = nil,
        bucket: String? = nil,
        bucketKeyEnabled: Bool = false,
        cacheControl: String? = nil,
        contentDisposition: String? = nil,
        contentEncoding: String? = nil,
        contentLanguage: String? = nil,
        contentLength: Int = 0,
        contentMD5: String? = nil,
        contentType: String? = nil,
        expectedBucketOwner: String? = nil,
        expires: Date? = nil,
        grantFullControl: String? = nil,
        grantRead: String? = nil,
        grantReadACP: String? = nil,
        grantWriteACP: String? = nil,
        key: String? = nil,
        metadata: [String:String]? = nil,
        objectLockLegalHoldStatus: ObjectLockLegalHoldStatus? = nil,
        objectLockMode: ObjectLockMode? = nil,
        objectLockRetainUntilDate: Date? = nil,
        requestPayer: RequestPayer? = nil,
        sSECustomerAlgorithm: String? = nil,
        sSECustomerKey: String? = nil,
        sSECustomerKeyMD5: String? = nil,
        sSEKMSEncryptionContext: String? = nil,
        sSEKMSKeyId: String? = nil,
        serverSideEncryption: ServerSideEncryption? = nil,
        storageClass: StorageClass? = nil,
        tagging: String? = nil,
        websiteRedirectLocation: String? = nil
    )
    {
        self.aCL = aCL
        self.body = body
        self.bucket = bucket
        self.bucketKeyEnabled = bucketKeyEnabled
        self.cacheControl = cacheControl
        self.contentDisposition = contentDisposition
        self.contentEncoding = contentEncoding
        self.contentLanguage = contentLanguage
        self.contentLength = contentLength
        self.contentMD5 = contentMD5
        self.contentType = contentType
        self.expectedBucketOwner = expectedBucketOwner
        self.expires = expires
        self.grantFullControl = grantFullControl
        self.grantRead = grantRead
        self.grantReadACP = grantReadACP
        self.grantWriteACP = grantWriteACP
        self.key = key
        self.metadata = metadata
        self.objectLockLegalHoldStatus = objectLockLegalHoldStatus
        self.objectLockMode = objectLockMode
        self.objectLockRetainUntilDate = objectLockRetainUntilDate
        self.requestPayer = requestPayer
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKey = sSECustomerKey
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.sSEKMSEncryptionContext = sSEKMSEncryptionContext
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
        self.storageClass = storageClass
        self.tagging = tagging
        self.websiteRedirectLocation = websiteRedirectLocation
    }
}

struct PutObjectInputBody: Equatable {
    public let body: Data?
}

extension PutObjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.body) {
            do {
                let bodyDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .body)
                body = bodyDecoded
            } catch {
                body = "".data(using: .utf8)
            }
        } else {
            body = nil
        }
    }
}

public struct PutObjectLegalHoldInputBodyMiddleware: Middleware {
    public let id: String = "PutObjectLegalHoldInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutObjectLegalHoldInput>,
                  next: H) -> Swift.Result<OperationOutput<PutObjectLegalHoldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let legalHold = input.operationInput.legalHold {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(legalHold)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutObjectLegalHoldInput>
    public typealias MOutput = OperationOutput<PutObjectLegalHoldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutObjectLegalHoldOutputError>
}

extension PutObjectLegalHoldInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutObjectLegalHoldInput(bucket: \(String(describing: bucket)), contentMD5: \(String(describing: contentMD5)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), key: \(String(describing: key)), legalHold: \(String(describing: legalHold)), requestPayer: \(String(describing: requestPayer)), versionId: \(String(describing: versionId)))"}
}

extension PutObjectLegalHoldInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutObjectLegalHoldInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case legalHold = "LegalHold"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let legalHold = legalHold {
            try container.encode(legalHold, forKey: Key("LegalHold"))
        }
    }
}

public struct PutObjectLegalHoldInputHeadersMiddleware: Middleware {
    public let id: String = "PutObjectLegalHoldInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutObjectLegalHoldInput>,
                  next: H) -> Swift.Result<OperationOutput<PutObjectLegalHoldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contentMD5 = input.operationInput.contentMD5 {
            input.builder.withHeader(name: "Content-MD5", value: String(contentMD5))
        }
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutObjectLegalHoldInput>
    public typealias MOutput = OperationOutput<PutObjectLegalHoldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutObjectLegalHoldOutputError>
}

public struct PutObjectLegalHoldInputQueryItemMiddleware: Middleware {
    public let id: String = "PutObjectLegalHoldInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutObjectLegalHoldInput>,
                  next: H) -> Swift.Result<OperationOutput<PutObjectLegalHoldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "legal-hold", value: nil))
        if let versionId = input.operationInput.versionId {
            let versionIdQueryItem = URLQueryItem(name: "versionId".urlPercentEncoding(), value: String(versionId).urlPercentEncoding())
            input.builder.withQueryItem(versionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutObjectLegalHoldInput>
    public typealias MOutput = OperationOutput<PutObjectLegalHoldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutObjectLegalHoldOutputError>
}

public struct PutObjectLegalHoldInput: Equatable {
    /// <p>The bucket name containing the object that you want to place a Legal Hold on. </p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>The MD5 hash for the request body.</p>
    ///          <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    public let contentMD5: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The key name for the object that you want to place a Legal Hold on.</p>
    public let key: String?
    /// <p>Container element for the Legal Hold configuration you want to apply to the specified
    ///          object.</p>
    public let legalHold: ObjectLockLegalHold?
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    ///          owners need not specify this parameter in their requests. For information about downloading
    ///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    ///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let requestPayer: RequestPayer?
    /// <p>The version ID of the object that you want to place a Legal Hold on.</p>
    public let versionId: String?

    public init (
        bucket: String? = nil,
        contentMD5: String? = nil,
        expectedBucketOwner: String? = nil,
        key: String? = nil,
        legalHold: ObjectLockLegalHold? = nil,
        requestPayer: RequestPayer? = nil,
        versionId: String? = nil
    )
    {
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.legalHold = legalHold
        self.requestPayer = requestPayer
        self.versionId = versionId
    }
}

struct PutObjectLegalHoldInputBody: Equatable {
    public let legalHold: ObjectLockLegalHold?
}

extension PutObjectLegalHoldInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case legalHold = "LegalHold"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let legalHoldDecoded = try containerValues.decodeIfPresent(ObjectLockLegalHold.self, forKey: .legalHold)
        legalHold = legalHoldDecoded
    }
}

extension PutObjectLegalHoldOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutObjectLegalHoldOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutObjectLegalHoldOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutObjectLegalHoldOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutObjectLegalHoldOutputResponse(requestCharged: \(String(describing: requestCharged)))"}
}

extension PutObjectLegalHoldOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
    }
}

public struct PutObjectLegalHoldOutputResponse: Equatable {
    /// <p>If present, indicates that the requester was successfully charged for the
    ///          request.</p>
    public let requestCharged: RequestCharged?

    public init (
        requestCharged: RequestCharged? = nil
    )
    {
        self.requestCharged = requestCharged
    }
}

struct PutObjectLegalHoldOutputResponseBody: Equatable {
}

extension PutObjectLegalHoldOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutObjectLockConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutObjectLockConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutObjectLockConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutObjectLockConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let objectLockConfiguration = input.operationInput.objectLockConfiguration {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(objectLockConfiguration)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutObjectLockConfigurationInput>
    public typealias MOutput = OperationOutput<PutObjectLockConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutObjectLockConfigurationOutputError>
}

extension PutObjectLockConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutObjectLockConfigurationInput(bucket: \(String(describing: bucket)), contentMD5: \(String(describing: contentMD5)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), objectLockConfiguration: \(String(describing: objectLockConfiguration)), requestPayer: \(String(describing: requestPayer)), token: \(String(describing: token)))"}
}

extension PutObjectLockConfigurationInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutObjectLockConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectLockConfiguration = "ObjectLockConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let objectLockConfiguration = objectLockConfiguration {
            try container.encode(objectLockConfiguration, forKey: Key("ObjectLockConfiguration"))
        }
    }
}

public struct PutObjectLockConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutObjectLockConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutObjectLockConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutObjectLockConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contentMD5 = input.operationInput.contentMD5 {
            input.builder.withHeader(name: "Content-MD5", value: String(contentMD5))
        }
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        if let token = input.operationInput.token {
            input.builder.withHeader(name: "x-amz-bucket-object-lock-token", value: String(token))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutObjectLockConfigurationInput>
    public typealias MOutput = OperationOutput<PutObjectLockConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutObjectLockConfigurationOutputError>
}

public struct PutObjectLockConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutObjectLockConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutObjectLockConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutObjectLockConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "object-lock", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutObjectLockConfigurationInput>
    public typealias MOutput = OperationOutput<PutObjectLockConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutObjectLockConfigurationOutputError>
}

public struct PutObjectLockConfigurationInput: Equatable {
    /// <p>The bucket whose Object Lock configuration you want to create or replace.</p>
    public let bucket: String?
    /// <p>The MD5 hash for the request body.</p>
    ///          <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    public let contentMD5: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The Object Lock configuration that you want to apply to the specified bucket.</p>
    public let objectLockConfiguration: ObjectLockConfiguration?
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    ///          owners need not specify this parameter in their requests. For information about downloading
    ///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    ///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let requestPayer: RequestPayer?
    /// <p>A token to allow Object Lock to be enabled for an existing bucket.</p>
    public let token: String?

    public init (
        bucket: String? = nil,
        contentMD5: String? = nil,
        expectedBucketOwner: String? = nil,
        objectLockConfiguration: ObjectLockConfiguration? = nil,
        requestPayer: RequestPayer? = nil,
        token: String? = nil
    )
    {
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.objectLockConfiguration = objectLockConfiguration
        self.requestPayer = requestPayer
        self.token = token
    }
}

struct PutObjectLockConfigurationInputBody: Equatable {
    public let objectLockConfiguration: ObjectLockConfiguration?
}

extension PutObjectLockConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case objectLockConfiguration = "ObjectLockConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectLockConfigurationDecoded = try containerValues.decodeIfPresent(ObjectLockConfiguration.self, forKey: .objectLockConfiguration)
        objectLockConfiguration = objectLockConfigurationDecoded
    }
}

extension PutObjectLockConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutObjectLockConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutObjectLockConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutObjectLockConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutObjectLockConfigurationOutputResponse(requestCharged: \(String(describing: requestCharged)))"}
}

extension PutObjectLockConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
    }
}

public struct PutObjectLockConfigurationOutputResponse: Equatable {
    /// <p>If present, indicates that the requester was successfully charged for the
    ///          request.</p>
    public let requestCharged: RequestCharged?

    public init (
        requestCharged: RequestCharged? = nil
    )
    {
        self.requestCharged = requestCharged
    }
}

struct PutObjectLockConfigurationOutputResponseBody: Equatable {
}

extension PutObjectLockConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension PutObjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutObjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutObjectOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutObjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutObjectOutputResponse(bucketKeyEnabled: \(String(describing: bucketKeyEnabled)), eTag: \(String(describing: eTag)), expiration: \(String(describing: expiration)), requestCharged: \(String(describing: requestCharged)), sSECustomerAlgorithm: \(String(describing: sSECustomerAlgorithm)), sSECustomerKeyMD5: \(String(describing: sSECustomerKeyMD5)), sSEKMSEncryptionContext: \(String(describing: sSEKMSEncryptionContext)), sSEKMSKeyId: \(String(describing: sSEKMSKeyId)), serverSideEncryption: \(String(describing: serverSideEncryption)), versionId: \(String(describing: versionId)))"}
}

extension PutObjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let bucketKeyEnabledHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-bucket-key-enabled") {
            self.bucketKeyEnabled = Bool(bucketKeyEnabledHeaderValue) ?? false
        } else {
            self.bucketKeyEnabled = false
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let expirationHeaderValue = httpResponse.headers.value(for: "x-amz-expiration") {
            self.expiration = expirationHeaderValue
        } else {
            self.expiration = nil
        }
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if let sSECustomerAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-algorithm") {
            self.sSECustomerAlgorithm = sSECustomerAlgorithmHeaderValue
        } else {
            self.sSECustomerAlgorithm = nil
        }
        if let sSECustomerKeyMD5HeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-key-MD5") {
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5HeaderValue
        } else {
            self.sSECustomerKeyMD5 = nil
        }
        if let sSEKMSEncryptionContextHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-context") {
            self.sSEKMSEncryptionContext = sSEKMSEncryptionContextHeaderValue
        } else {
            self.sSEKMSEncryptionContext = nil
        }
        if let sSEKMSKeyIdHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-aws-kms-key-id") {
            self.sSEKMSKeyId = sSEKMSKeyIdHeaderValue
        } else {
            self.sSEKMSKeyId = nil
        }
        if let serverSideEncryptionHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption") {
            self.serverSideEncryption = ServerSideEncryption(rawValue: serverSideEncryptionHeaderValue)
        } else {
            self.serverSideEncryption = nil
        }
        if let versionIdHeaderValue = httpResponse.headers.value(for: "x-amz-version-id") {
            self.versionId = versionIdHeaderValue
        } else {
            self.versionId = nil
        }
    }
}

public struct PutObjectOutputResponse: Equatable {
    /// <p>Indicates whether the uploaded object uses an S3 Bucket Key for server-side encryption with AWS KMS (SSE-KMS).</p>
    public let bucketKeyEnabled: Bool
    /// <p>Entity tag for the uploaded object.</p>
    public let eTag: String?
    /// <p> If the expiration is configured for the object (see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketLifecycleConfiguration.html">PutBucketLifecycleConfiguration</a>), the response includes this header. It
    ///          includes the expiry-date and rule-id key-value pairs that provide information about object
    ///          expiration. The value of the rule-id is URL encoded.</p>
    public let expiration: String?
    /// <p>If present, indicates that the requester was successfully charged for the
    ///          request.</p>
    public let requestCharged: RequestCharged?
    /// <p>If server-side encryption with a customer-provided encryption key was requested, the
    ///          response will include this header confirming the encryption algorithm used.</p>
    public let sSECustomerAlgorithm: String?
    /// <p>If server-side encryption with a customer-provided encryption key was requested, the
    ///          response will include this header to provide round-trip message integrity verification of
    ///          the customer-provided encryption key.</p>
    public let sSECustomerKeyMD5: String?
    /// <p>If present, specifies the AWS KMS Encryption Context to use for object encryption. The
    ///          value of this header is a base64-encoded UTF-8 string holding JSON with the encryption
    ///          context key-value pairs.</p>
    public let sSEKMSEncryptionContext: String?
    /// <p>If <code>x-amz-server-side-encryption</code> is present and has the value of
    ///             <code>aws:kms</code>, this header specifies the ID of the AWS Key Management Service
    ///          (AWS KMS) symmetric customer managed customer master key (CMK) that was used for the
    ///          object. </p>
    public let sSEKMSKeyId: String?
    /// <p>If you specified server-side encryption either with an AWS KMS customer master key (CMK)
    ///          or Amazon S3-managed encryption key in your PUT request, the response includes this header. It
    ///          confirms the encryption algorithm that Amazon S3 used to encrypt the object.</p>
    public let serverSideEncryption: ServerSideEncryption?
    /// <p>Version of the object.</p>
    public let versionId: String?

    public init (
        bucketKeyEnabled: Bool = false,
        eTag: String? = nil,
        expiration: String? = nil,
        requestCharged: RequestCharged? = nil,
        sSECustomerAlgorithm: String? = nil,
        sSECustomerKeyMD5: String? = nil,
        sSEKMSEncryptionContext: String? = nil,
        sSEKMSKeyId: String? = nil,
        serverSideEncryption: ServerSideEncryption? = nil,
        versionId: String? = nil
    )
    {
        self.bucketKeyEnabled = bucketKeyEnabled
        self.eTag = eTag
        self.expiration = expiration
        self.requestCharged = requestCharged
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.sSEKMSEncryptionContext = sSEKMSEncryptionContext
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
        self.versionId = versionId
    }
}

struct PutObjectOutputResponseBody: Equatable {
}

extension PutObjectOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutObjectRetentionInputBodyMiddleware: Middleware {
    public let id: String = "PutObjectRetentionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutObjectRetentionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutObjectRetentionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let retention = input.operationInput.retention {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(retention)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutObjectRetentionInput>
    public typealias MOutput = OperationOutput<PutObjectRetentionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutObjectRetentionOutputError>
}

extension PutObjectRetentionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutObjectRetentionInput(bucket: \(String(describing: bucket)), bypassGovernanceRetention: \(String(describing: bypassGovernanceRetention)), contentMD5: \(String(describing: contentMD5)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), key: \(String(describing: key)), requestPayer: \(String(describing: requestPayer)), retention: \(String(describing: retention)), versionId: \(String(describing: versionId)))"}
}

extension PutObjectRetentionInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutObjectRetentionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case retention = "Retention"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let retention = retention {
            try container.encode(retention, forKey: Key("Retention"))
        }
    }
}

public struct PutObjectRetentionInputHeadersMiddleware: Middleware {
    public let id: String = "PutObjectRetentionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutObjectRetentionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutObjectRetentionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withHeader(name: "x-amz-bypass-governance-retention", value: String(input.operationInput.bypassGovernanceRetention))
        if let contentMD5 = input.operationInput.contentMD5 {
            input.builder.withHeader(name: "Content-MD5", value: String(contentMD5))
        }
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutObjectRetentionInput>
    public typealias MOutput = OperationOutput<PutObjectRetentionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutObjectRetentionOutputError>
}

public struct PutObjectRetentionInputQueryItemMiddleware: Middleware {
    public let id: String = "PutObjectRetentionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutObjectRetentionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutObjectRetentionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "retention", value: nil))
        if let versionId = input.operationInput.versionId {
            let versionIdQueryItem = URLQueryItem(name: "versionId".urlPercentEncoding(), value: String(versionId).urlPercentEncoding())
            input.builder.withQueryItem(versionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutObjectRetentionInput>
    public typealias MOutput = OperationOutput<PutObjectRetentionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutObjectRetentionOutputError>
}

public struct PutObjectRetentionInput: Equatable {
    /// <p>The bucket name that contains the object you want to apply this Object Retention
    ///          configuration to. </p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>Indicates whether this action should bypass Governance-mode restrictions.</p>
    public let bypassGovernanceRetention: Bool
    /// <p>The MD5 hash for the request body.</p>
    ///          <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    public let contentMD5: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The key name for the object that you want to apply this Object Retention configuration
    ///          to.</p>
    public let key: String?
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    ///          owners need not specify this parameter in their requests. For information about downloading
    ///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    ///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let requestPayer: RequestPayer?
    /// <p>The container element for the Object Retention configuration.</p>
    public let retention: ObjectLockRetention?
    /// <p>The version ID for the object that you want to apply this Object Retention configuration
    ///          to.</p>
    public let versionId: String?

    public init (
        bucket: String? = nil,
        bypassGovernanceRetention: Bool = false,
        contentMD5: String? = nil,
        expectedBucketOwner: String? = nil,
        key: String? = nil,
        requestPayer: RequestPayer? = nil,
        retention: ObjectLockRetention? = nil,
        versionId: String? = nil
    )
    {
        self.bucket = bucket
        self.bypassGovernanceRetention = bypassGovernanceRetention
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.requestPayer = requestPayer
        self.retention = retention
        self.versionId = versionId
    }
}

struct PutObjectRetentionInputBody: Equatable {
    public let retention: ObjectLockRetention?
}

extension PutObjectRetentionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case retention = "Retention"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionDecoded = try containerValues.decodeIfPresent(ObjectLockRetention.self, forKey: .retention)
        retention = retentionDecoded
    }
}

extension PutObjectRetentionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutObjectRetentionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutObjectRetentionOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutObjectRetentionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutObjectRetentionOutputResponse(requestCharged: \(String(describing: requestCharged)))"}
}

extension PutObjectRetentionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
    }
}

public struct PutObjectRetentionOutputResponse: Equatable {
    /// <p>If present, indicates that the requester was successfully charged for the
    ///          request.</p>
    public let requestCharged: RequestCharged?

    public init (
        requestCharged: RequestCharged? = nil
    )
    {
        self.requestCharged = requestCharged
    }
}

struct PutObjectRetentionOutputResponseBody: Equatable {
}

extension PutObjectRetentionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutObjectTaggingInputBodyMiddleware: Middleware {
    public let id: String = "PutObjectTaggingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutObjectTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<PutObjectTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagging = input.operationInput.tagging {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(tagging)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutObjectTaggingInput>
    public typealias MOutput = OperationOutput<PutObjectTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutObjectTaggingOutputError>
}

extension PutObjectTaggingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutObjectTaggingInput(bucket: \(String(describing: bucket)), contentMD5: \(String(describing: contentMD5)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), key: \(String(describing: key)), requestPayer: \(String(describing: requestPayer)), tagging: \(String(describing: tagging)), versionId: \(String(describing: versionId)))"}
}

extension PutObjectTaggingInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutObjectTaggingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tagging = "Tagging"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let tagging = tagging {
            try container.encode(tagging, forKey: Key("Tagging"))
        }
    }
}

public struct PutObjectTaggingInputHeadersMiddleware: Middleware {
    public let id: String = "PutObjectTaggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutObjectTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<PutObjectTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contentMD5 = input.operationInput.contentMD5 {
            input.builder.withHeader(name: "Content-MD5", value: String(contentMD5))
        }
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutObjectTaggingInput>
    public typealias MOutput = OperationOutput<PutObjectTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutObjectTaggingOutputError>
}

public struct PutObjectTaggingInputQueryItemMiddleware: Middleware {
    public let id: String = "PutObjectTaggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutObjectTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<PutObjectTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "tagging", value: nil))
        if let versionId = input.operationInput.versionId {
            let versionIdQueryItem = URLQueryItem(name: "versionId".urlPercentEncoding(), value: String(versionId).urlPercentEncoding())
            input.builder.withQueryItem(versionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutObjectTaggingInput>
    public typealias MOutput = OperationOutput<PutObjectTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutObjectTaggingOutputError>
}

public struct PutObjectTaggingInput: Equatable {
    /// <p>The bucket name containing the object. </p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>The MD5 hash for the request body.</p>
    ///          <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    public let contentMD5: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>Name of the object key.</p>
    public let key: String?
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    ///          owners need not specify this parameter in their requests. For information about downloading
    ///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    ///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let requestPayer: RequestPayer?
    /// <p>Container for the <code>TagSet</code> and <code>Tag</code> elements</p>
    public let tagging: Tagging?
    /// <p>The versionId of the object that the tag-set will be added to.</p>
    public let versionId: String?

    public init (
        bucket: String? = nil,
        contentMD5: String? = nil,
        expectedBucketOwner: String? = nil,
        key: String? = nil,
        requestPayer: RequestPayer? = nil,
        tagging: Tagging? = nil,
        versionId: String? = nil
    )
    {
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.requestPayer = requestPayer
        self.tagging = tagging
        self.versionId = versionId
    }
}

struct PutObjectTaggingInputBody: Equatable {
    public let tagging: Tagging?
}

extension PutObjectTaggingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagging = "Tagging"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taggingDecoded = try containerValues.decodeIfPresent(Tagging.self, forKey: .tagging)
        tagging = taggingDecoded
    }
}

extension PutObjectTaggingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutObjectTaggingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutObjectTaggingOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutObjectTaggingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutObjectTaggingOutputResponse(versionId: \(String(describing: versionId)))"}
}

extension PutObjectTaggingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let versionIdHeaderValue = httpResponse.headers.value(for: "x-amz-version-id") {
            self.versionId = versionIdHeaderValue
        } else {
            self.versionId = nil
        }
    }
}

public struct PutObjectTaggingOutputResponse: Equatable {
    /// <p>The versionId of the object the tag-set was added to.</p>
    public let versionId: String?

    public init (
        versionId: String? = nil
    )
    {
        self.versionId = versionId
    }
}

struct PutObjectTaggingOutputResponseBody: Equatable {
}

extension PutObjectTaggingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutPublicAccessBlockInputBodyMiddleware: Middleware {
    public let id: String = "PutPublicAccessBlockInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPublicAccessBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPublicAccessBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let publicAccessBlockConfiguration = input.operationInput.publicAccessBlockConfiguration {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(publicAccessBlockConfiguration)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPublicAccessBlockInput>
    public typealias MOutput = OperationOutput<PutPublicAccessBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPublicAccessBlockOutputError>
}

extension PutPublicAccessBlockInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPublicAccessBlockInput(bucket: \(String(describing: bucket)), contentMD5: \(String(describing: contentMD5)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), publicAccessBlockConfiguration: \(String(describing: publicAccessBlockConfiguration)))"}
}

extension PutPublicAccessBlockInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutPublicAccessBlockInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let publicAccessBlockConfiguration = publicAccessBlockConfiguration {
            try container.encode(publicAccessBlockConfiguration, forKey: Key("PublicAccessBlockConfiguration"))
        }
    }
}

public struct PutPublicAccessBlockInputHeadersMiddleware: Middleware {
    public let id: String = "PutPublicAccessBlockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPublicAccessBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPublicAccessBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contentMD5 = input.operationInput.contentMD5 {
            input.builder.withHeader(name: "Content-MD5", value: String(contentMD5))
        }
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPublicAccessBlockInput>
    public typealias MOutput = OperationOutput<PutPublicAccessBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPublicAccessBlockOutputError>
}

public struct PutPublicAccessBlockInputQueryItemMiddleware: Middleware {
    public let id: String = "PutPublicAccessBlockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPublicAccessBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPublicAccessBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "publicAccessBlock", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPublicAccessBlockInput>
    public typealias MOutput = OperationOutput<PutPublicAccessBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPublicAccessBlockOutputError>
}

public struct PutPublicAccessBlockInput: Equatable {
    /// <p>The name of the Amazon S3 bucket whose <code>PublicAccessBlock</code> configuration you want
    ///          to set.</p>
    public let bucket: String?
    /// <p>The MD5 hash of the <code>PutPublicAccessBlock</code> request body. </p>
    ///          <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    public let contentMD5: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The <code>PublicAccessBlock</code> configuration that you want to apply to this Amazon S3
    ///          bucket. You can enable the configuration options in any combination. For more information
    ///          about when Amazon S3 considers a bucket or object public, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status">The Meaning of "Public"</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let publicAccessBlockConfiguration: PublicAccessBlockConfiguration?

    public init (
        bucket: String? = nil,
        contentMD5: String? = nil,
        expectedBucketOwner: String? = nil,
        publicAccessBlockConfiguration: PublicAccessBlockConfiguration? = nil
    )
    {
        self.bucket = bucket
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
    }
}

struct PutPublicAccessBlockInputBody: Equatable {
    public let publicAccessBlockConfiguration: PublicAccessBlockConfiguration?
}

extension PutPublicAccessBlockInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicAccessBlockConfigurationDecoded = try containerValues.decodeIfPresent(PublicAccessBlockConfiguration.self, forKey: .publicAccessBlockConfiguration)
        publicAccessBlockConfiguration = publicAccessBlockConfigurationDecoded
    }
}

extension PutPublicAccessBlockOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutPublicAccessBlockOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutPublicAccessBlockOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPublicAccessBlockOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPublicAccessBlockOutputResponse()"}
}

extension PutPublicAccessBlockOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutPublicAccessBlockOutputResponse: Equatable {

    public init() {}
}

struct PutPublicAccessBlockOutputResponseBody: Equatable {
}

extension PutPublicAccessBlockOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension QueueConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case events = "Event"
        case filter = "Filter"
        case id = "Id"
        case queueArn = "Queue"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let events = events {
            if events.isEmpty {
                var eventsContainer = container.nestedUnkeyedContainer(forKey: Key("Event"))
                try eventsContainer.encodeNil()
            } else {
                for event0 in events {
                    var eventsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Event"))
                    try eventsContainer0.encode(event0, forKey: Key(""))
                }
            }
        }
        if let filter = filter {
            try container.encode(filter, forKey: Key("filter"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let queueArn = queueArn {
            try container.encode(queueArn, forKey: Key("Queue"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let queueArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queueArn)
        queueArn = queueArnDecoded
        if containerValues.contains(.events) {
            let eventsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .events)
            if eventsWrappedContainer != nil {
                let eventsContainer = try containerValues.decodeIfPresent([Event].self, forKey: .events)
                var eventsBuffer:[Event]? = nil
                if let eventsContainer = eventsContainer {
                    eventsBuffer = [Event]()
                    for stringContainer0 in eventsContainer {
                        eventsBuffer?.append(stringContainer0)
                    }
                }
                events = eventsBuffer
            } else {
                events = []
            }
        } else {
            events = nil
        }
        let filterDecoded = try containerValues.decodeIfPresent(NotificationConfigurationFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension QueueConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueueConfiguration(events: \(String(describing: events)), filter: \(String(describing: filter)), id: \(String(describing: id)), queueArn: \(String(describing: queueArn)))"}
}

extension QueueConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies the configuration for publishing messages to an Amazon Simple Queue Service
///          (Amazon SQS) queue when Amazon S3 detects specified events.</p>
public struct QueueConfiguration: Equatable {
    /// <p>A collection of bucket events for which to send notifications</p>
    public let events: [Event]?
    /// <p>Specifies object key name filtering rules. For information about key name filtering, see
    ///             <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html">Configuring
    ///             Event Notifications</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let filter: NotificationConfigurationFilter?
    /// <p>An optional unique identifier for configurations in a notification configuration. If you
    ///          don't provide one, Amazon S3 will assign an ID.</p>
    public let id: String?
    /// <p>The Amazon Resource Name (ARN) of the Amazon SQS queue to which Amazon S3 publishes a message
    ///          when it detects events of the specified type.</p>
    public let queueArn: String?

    public init (
        events: [Event]? = nil,
        filter: NotificationConfigurationFilter? = nil,
        id: String? = nil,
        queueArn: String? = nil
    )
    {
        self.events = events
        self.filter = filter
        self.id = id
        self.queueArn = queueArn
    }
}

public enum QuoteFields {
    case always
    case asneeded
    case sdkUnknown(String)
}

extension QuoteFields : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [QuoteFields] {
        return [
            .always,
            .asneeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .always: return "ALWAYS"
        case .asneeded: return "ASNEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = QuoteFields(rawValue: rawValue) ?? QuoteFields.sdkUnknown(rawValue)
    }
}

extension RecordsEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case payload = "Payload"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let payload = payload {
            try container.encode(payload, forKey: Key("payload"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.payload) {
            do {
                let payloadDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .payload)
                payload = payloadDecoded
            } catch {
                payload = "".data(using: .utf8)
            }
        } else {
            payload = nil
        }
    }
}

extension RecordsEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecordsEvent(payload: \(String(describing: payload)))"}
}

extension RecordsEvent: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The container for the records event.</p>
public struct RecordsEvent: Equatable {
    /// <p>The byte array of partial, one or more result records.</p>
    public let payload: Data?

    public init (
        payload: Data? = nil
    )
    {
        self.payload = payload
    }
}

extension Redirect: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hostName = "HostName"
        case httpRedirectCode = "HttpRedirectCode"
        case `protocol` = "Protocol"
        case replaceKeyPrefixWith = "ReplaceKeyPrefixWith"
        case replaceKeyWith = "ReplaceKeyWith"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let hostName = hostName {
            try container.encode(hostName, forKey: Key("hostName"))
        }
        if let httpRedirectCode = httpRedirectCode {
            try container.encode(httpRedirectCode, forKey: Key("httpRedirectCode"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: Key("protocol"))
        }
        if let replaceKeyPrefixWith = replaceKeyPrefixWith {
            try container.encode(replaceKeyPrefixWith, forKey: Key("replaceKeyPrefixWith"))
        }
        if let replaceKeyWith = replaceKeyWith {
            try container.encode(replaceKeyWith, forKey: Key("replaceKeyWith"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostName)
        hostName = hostNameDecoded
        let httpRedirectCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .httpRedirectCode)
        httpRedirectCode = httpRedirectCodeDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(`Protocol`.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let replaceKeyPrefixWithDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replaceKeyPrefixWith)
        replaceKeyPrefixWith = replaceKeyPrefixWithDecoded
        let replaceKeyWithDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replaceKeyWith)
        replaceKeyWith = replaceKeyWithDecoded
    }
}

extension Redirect: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Redirect(hostName: \(String(describing: hostName)), httpRedirectCode: \(String(describing: httpRedirectCode)), protocol: \(String(describing: `protocol`)), replaceKeyPrefixWith: \(String(describing: replaceKeyPrefixWith)), replaceKeyWith: \(String(describing: replaceKeyWith)))"}
}

extension Redirect: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies how requests are redirected. In the event of an error, you can specify a
///          different error code to return.</p>
public struct Redirect: Equatable {
    /// <p>Protocol to use when redirecting requests. The default is the protocol that is used in
    ///          the original request.</p>
    public let `protocol`: `Protocol`?
    /// <p>The host name to use in the redirect request.</p>
    public let hostName: String?
    /// <p>The HTTP redirect code to use on the response. Not required if one of the siblings is
    ///          present.</p>
    public let httpRedirectCode: String?
    /// <p>The object key prefix to use in the redirect request. For example, to redirect requests
    ///          for all pages with prefix <code>docs/</code> (objects in the <code>docs/</code> folder) to
    ///             <code>documents/</code>, you can set a condition block with <code>KeyPrefixEquals</code>
    ///          set to <code>docs/</code> and in the Redirect set <code>ReplaceKeyPrefixWith</code> to
    ///             <code>/documents</code>. Not required if one of the siblings is present. Can be present
    ///          only if <code>ReplaceKeyWith</code> is not provided.</p>
    ///          <important>
    ///             <p>Replacement must be made for object keys containing special characters (such as carriage returns) when using
    ///          XML requests. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints">
    ///             XML related object key constraints</a>.</p>
    ///          </important>
    public let replaceKeyPrefixWith: String?
    /// <p>The specific object key to use in the redirect request. For example, redirect request to
    ///             <code>error.html</code>. Not required if one of the siblings is present. Can be present
    ///          only if <code>ReplaceKeyPrefixWith</code> is not provided.</p>
    ///          <important>
    ///             <p>Replacement must be made for object keys containing special characters (such as carriage returns) when using
    ///          XML requests. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints">
    ///             XML related object key constraints</a>.</p>
    ///          </important>
    public let replaceKeyWith: String?

    public init (
        `protocol`: `Protocol`? = nil,
        hostName: String? = nil,
        httpRedirectCode: String? = nil,
        replaceKeyPrefixWith: String? = nil,
        replaceKeyWith: String? = nil
    )
    {
        self.`protocol` = `protocol`
        self.hostName = hostName
        self.httpRedirectCode = httpRedirectCode
        self.replaceKeyPrefixWith = replaceKeyPrefixWith
        self.replaceKeyWith = replaceKeyWith
    }
}

extension RedirectAllRequestsTo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hostName = "HostName"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let hostName = hostName {
            try container.encode(hostName, forKey: Key("hostName"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: Key("protocol"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostName)
        hostName = hostNameDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(`Protocol`.self, forKey: .protocol)
        `protocol` = protocolDecoded
    }
}

extension RedirectAllRequestsTo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RedirectAllRequestsTo(hostName: \(String(describing: hostName)), protocol: \(String(describing: `protocol`)))"}
}

extension RedirectAllRequestsTo: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies the redirect behavior of all requests to a website endpoint of an Amazon S3
///          bucket.</p>
public struct RedirectAllRequestsTo: Equatable {
    /// <p>Protocol to use when redirecting requests. The default is the protocol that is used in
    ///          the original request.</p>
    public let `protocol`: `Protocol`?
    /// <p>Name of the host where requests are redirected.</p>
    public let hostName: String?

    public init (
        `protocol`: `Protocol`? = nil,
        hostName: String? = nil
    )
    {
        self.`protocol` = `protocol`
        self.hostName = hostName
    }
}

extension ReplicaModifications: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ReplicaModificationsStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ReplicaModifications: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicaModifications(status: \(String(describing: status)))"}
}

extension ReplicaModifications: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A filter that you can specify for selection for modifications on replicas. Amazon S3 doesn't
///          replicate replica modifications by default. In the latest version of replication
///          configuration (when <code>Filter</code> is specified), you can specify this element and set
///          the status to <code>Enabled</code> to replicate modifications on replicas. </p>
///          <note>
///             <p> If you don't specify the <code>Filter</code> element, Amazon S3 assumes that the
///             replication configuration is the earlier version, V1. In the earlier version, this
///             element is not allowed.</p>
///          </note>
public struct ReplicaModifications: Equatable {
    /// <p>Specifies whether Amazon S3 replicates modifications on replicas.</p>
    public let status: ReplicaModificationsStatus?

    public init (
        status: ReplicaModificationsStatus? = nil
    )
    {
        self.status = status
    }
}

public enum ReplicaModificationsStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension ReplicaModificationsStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReplicaModificationsStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "Disabled"
        case .enabled: return "Enabled"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReplicaModificationsStatus(rawValue: rawValue) ?? ReplicaModificationsStatus.sdkUnknown(rawValue)
    }
}

extension ReplicationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case role = "Role"
        case rules = "Rule"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let role = role {
            try container.encode(role, forKey: Key("role"))
        }
        if let rules = rules {
            if rules.isEmpty {
                var rulesContainer = container.nestedUnkeyedContainer(forKey: Key("Rule"))
                try rulesContainer.encodeNil()
            } else {
                for replicationrule0 in rules {
                    var rulesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Rule"))
                    try rulesContainer0.encode(replicationrule0, forKey: Key(""))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        if containerValues.contains(.rules) {
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .rules)
            if rulesWrappedContainer != nil {
                let rulesContainer = try containerValues.decodeIfPresent([ReplicationRule].self, forKey: .rules)
                var rulesBuffer:[ReplicationRule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [ReplicationRule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

extension ReplicationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationConfiguration(role: \(String(describing: role)), rules: \(String(describing: rules)))"}
}

extension ReplicationConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container for replication rules. You can add up to 1,000 rules. The maximum size of a
///          replication configuration is 2 MB.</p>
public struct ReplicationConfiguration: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that
    ///          Amazon S3 assumes when replicating objects. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-how-setup.html">How to Set Up
    ///             Replication</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let role: String?
    /// <p>A container for one or more replication rules. A replication configuration must have at
    ///          least one rule and can contain a maximum of 1,000 rules. </p>
    public let rules: [ReplicationRule]?

    public init (
        role: String? = nil,
        rules: [ReplicationRule]? = nil
    )
    {
        self.role = role
        self.rules = rules
    }
}

extension ReplicationRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deleteMarkerReplication = "DeleteMarkerReplication"
        case destination = "Destination"
        case existingObjectReplication = "ExistingObjectReplication"
        case filter = "Filter"
        case iD = "ID"
        case prefix = "Prefix"
        case priority = "Priority"
        case sourceSelectionCriteria = "SourceSelectionCriteria"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let deleteMarkerReplication = deleteMarkerReplication {
            try container.encode(deleteMarkerReplication, forKey: Key("deleteMarkerReplication"))
        }
        if let destination = destination {
            try container.encode(destination, forKey: Key("destination"))
        }
        if let existingObjectReplication = existingObjectReplication {
            try container.encode(existingObjectReplication, forKey: Key("existingObjectReplication"))
        }
        if let filter = filter {
            try container.encode(filter, forKey: Key("filter"))
        }
        if let iD = iD {
            try container.encode(iD, forKey: Key("iD"))
        }
        if let prefix = prefix {
            try container.encode(prefix, forKey: Key("prefix"))
        }
        if priority != 0 {
            try container.encode(priority, forKey: Key("priority"))
        }
        if let sourceSelectionCriteria = sourceSelectionCriteria {
            try container.encode(sourceSelectionCriteria, forKey: Key("sourceSelectionCriteria"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iD)
        iD = iDDecoded
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        let filterDecoded = try containerValues.decodeIfPresent(ReplicationRuleFilter.self, forKey: .filter)
        filter = filterDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ReplicationRuleStatus.self, forKey: .status)
        status = statusDecoded
        let sourceSelectionCriteriaDecoded = try containerValues.decodeIfPresent(SourceSelectionCriteria.self, forKey: .sourceSelectionCriteria)
        sourceSelectionCriteria = sourceSelectionCriteriaDecoded
        let existingObjectReplicationDecoded = try containerValues.decodeIfPresent(ExistingObjectReplication.self, forKey: .existingObjectReplication)
        existingObjectReplication = existingObjectReplicationDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Destination.self, forKey: .destination)
        destination = destinationDecoded
        let deleteMarkerReplicationDecoded = try containerValues.decodeIfPresent(DeleteMarkerReplication.self, forKey: .deleteMarkerReplication)
        deleteMarkerReplication = deleteMarkerReplicationDecoded
    }
}

extension ReplicationRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationRule(deleteMarkerReplication: \(String(describing: deleteMarkerReplication)), destination: \(String(describing: destination)), existingObjectReplication: \(String(describing: existingObjectReplication)), filter: \(String(describing: filter)), iD: \(String(describing: iD)), prefix: \(String(describing: prefix)), priority: \(String(describing: priority)), sourceSelectionCriteria: \(String(describing: sourceSelectionCriteria)), status: \(String(describing: status)))"}
}

extension ReplicationRule: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies which Amazon S3 objects to replicate and where to store the replicas.</p>
public struct ReplicationRule: Equatable {
    /// <p>Specifies whether Amazon S3 replicates delete markers. If you specify a <code>Filter</code>
    ///          in your replication configuration, you must also include a
    ///             <code>DeleteMarkerReplication</code> element. If your <code>Filter</code> includes a
    ///             <code>Tag</code> element, the <code>DeleteMarkerReplication</code>
    ///             <code>Status</code> must be set to Disabled, because Amazon S3 does not support replicating
    ///          delete markers for tag-based rules. For an example configuration, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-config-min-rule-config">Basic Rule Configuration</a>. </p>
    ///          <p>For more information about delete marker replication, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/delete-marker-replication.html">Basic Rule
    ///             Configuration</a>. </p>
    ///          <note>
    ///             <p>If you are using an earlier version of the replication configuration, Amazon S3 handles
    ///             replication of delete markers differently. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-backward-compat-considerations">Backward Compatibility</a>.</p>
    ///          </note>
    public let deleteMarkerReplication: DeleteMarkerReplication?
    /// <p>A container for information about the replication destination and its configurations
    ///          including enabling the S3 Replication Time Control (S3 RTC).</p>
    public let destination: Destination?
    /// <p></p>
    public let existingObjectReplication: ExistingObjectReplication?
    /// <p>A filter that identifies the subset of objects to which the replication rule applies. A
    ///             <code>Filter</code> must specify exactly one <code>Prefix</code>, <code>Tag</code>, or
    ///          an <code>And</code> child element.</p>
    public let filter: ReplicationRuleFilter?
    /// <p>A unique identifier for the rule. The maximum value is 255 characters.</p>
    public let iD: String?
    /// <p>An object key name prefix that identifies the object or objects to which the rule
    ///          applies. The maximum prefix length is 1,024 characters. To include all objects in a bucket,
    ///          specify an empty string. </p>
    ///          <important>
    ///             <p>Replacement must be made for object keys containing special characters (such as carriage returns) when using
    ///          XML requests. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints">
    ///             XML related object key constraints</a>.</p>
    ///          </important>
    @available(*, deprecated)
    public let prefix: String?
    /// <p>The priority indicates which rule has precedence whenever two or more replication rules
    ///          conflict. Amazon S3 will attempt to replicate objects according to all replication rules.
    ///          However, if there are two or more rules with the same destination bucket, then objects will
    ///          be replicated according to the rule with the highest priority. The higher the number, the
    ///          higher the priority. </p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/replication.html">Replication</a> in the
    ///             <i>Amazon S3 User Guide</i>.</p>
    public let priority: Int
    /// <p>A container that describes additional filters for identifying the source objects that
    ///          you want to replicate. You can choose to enable or disable the replication of these
    ///          objects. Currently, Amazon S3 supports only the filter that you can specify for objects created
    ///          with server-side encryption using a customer master key (CMK) stored in AWS Key Management
    ///          Service (SSE-KMS).</p>
    public let sourceSelectionCriteria: SourceSelectionCriteria?
    /// <p>Specifies whether the rule is enabled.</p>
    public let status: ReplicationRuleStatus?

    public init (
        deleteMarkerReplication: DeleteMarkerReplication? = nil,
        destination: Destination? = nil,
        existingObjectReplication: ExistingObjectReplication? = nil,
        filter: ReplicationRuleFilter? = nil,
        iD: String? = nil,
        prefix: String? = nil,
        priority: Int = 0,
        sourceSelectionCriteria: SourceSelectionCriteria? = nil,
        status: ReplicationRuleStatus? = nil
    )
    {
        self.deleteMarkerReplication = deleteMarkerReplication
        self.destination = destination
        self.existingObjectReplication = existingObjectReplication
        self.filter = filter
        self.iD = iD
        self.prefix = prefix
        self.priority = priority
        self.sourceSelectionCriteria = sourceSelectionCriteria
        self.status = status
    }
}

extension ReplicationRuleAndOperator: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case prefix = "Prefix"
        case tags = "Tag"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let prefix = prefix {
            try container.encode(prefix, forKey: Key("prefix"))
        }
        if let tags = tags {
            if tags.isEmpty {
                var tagsContainer = container.nestedUnkeyedContainer(forKey: Key("Tag"))
                try tagsContainer.encodeNil()
            } else {
                for tag0 in tags {
                    var tagsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tag"))
                    try tagsContainer0.encode(tag0, forKey: Key(""))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        if containerValues.contains(.tags) {
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .tags)
            if tagsWrappedContainer != nil {
                let tagsContainer = try containerValues.decodeIfPresent([Tag].self, forKey: .tags)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension ReplicationRuleAndOperator: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationRuleAndOperator(prefix: \(String(describing: prefix)), tags: \(String(describing: tags)))"}
}

extension ReplicationRuleAndOperator: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container for specifying rule filters. The filters determine the subset of objects to
///          which the rule applies. This element is required only if you specify more than one filter. </p>
///          <p>For example:</p>
///          <ul>
///             <li>
///                <p>If you specify both a <code>Prefix</code> and a <code>Tag</code> filter, wrap
///                these filters in an <code>And</code> tag. </p>
///             </li>
///             <li>
///                <p>If you specify a filter based on multiple tags, wrap the <code>Tag</code> elements
///                in an <code>And</code> tag.</p>
///             </li>
///          </ul>
public struct ReplicationRuleAndOperator: Equatable {
    /// <p>An object key name prefix that identifies the subset of objects to which the rule
    ///          applies.</p>
    public let prefix: String?
    /// <p>An array of tags containing key and value pairs.</p>
    public let tags: [Tag]?

    public init (
        prefix: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.prefix = prefix
        self.tags = tags
    }
}

extension ReplicationRuleFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case and = "And"
        case prefix = "Prefix"
        case tag = "Tag"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        switch self {
            case let .and(and):
                if let and = and {
                    try container.encode(and, forKey: Key("and"))
                }
            case let .prefix(prefix):
                if let prefix = prefix {
                    try container.encode(prefix, forKey: Key("prefix"))
                }
            case let .tag(tag):
                if let tag = tag {
                    try container.encode(tag, forKey: Key("tag"))
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: Key("sdkUnknown"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        if let prefix = prefixDecoded {
            self = .prefix(prefix)
            return
        }
        let tagDecoded = try containerValues.decodeIfPresent(Tag.self, forKey: .tag)
        if let tag = tagDecoded {
            self = .tag(tag)
            return
        }
        let andDecoded = try containerValues.decodeIfPresent(ReplicationRuleAndOperator.self, forKey: .and)
        if let and = andDecoded {
            self = .and(and)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>A filter that identifies the subset of objects to which the replication rule applies. A
///             <code>Filter</code> must specify exactly one <code>Prefix</code>, <code>Tag</code>, or
///          an <code>And</code> child element.</p>
public enum ReplicationRuleFilter: Equatable {
    /// <p>An object key name prefix that identifies the subset of objects to which the rule
    ///          applies.</p>
    ///          <important>
    ///             <p>Replacement must be made for object keys containing special characters (such as carriage returns) when using
    ///          XML requests. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints">
    ///             XML related object key constraints</a>.</p>
    ///          </important>
    case prefix(String?)
    /// <p>A container for specifying a tag key and value. </p>
    ///          <p>The rule applies only to objects that have the tag in their tag set.</p>
    case tag(Tag?)
    /// <p>A container for specifying rule filters. The filters determine the subset of objects to
    ///          which the rule applies. This element is required only if you specify more than one filter.
    ///          For example: </p>
    ///          <ul>
    ///             <li>
    ///                <p>If you specify both a <code>Prefix</code> and a <code>Tag</code> filter, wrap
    ///                these filters in an <code>And</code> tag.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you specify a filter based on multiple tags, wrap the <code>Tag</code> elements
    ///                in an <code>And</code> tag.</p>
    ///             </li>
    ///          </ul>
    case and(ReplicationRuleAndOperator?)
    case sdkUnknown(String?)
}

public enum ReplicationRuleStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension ReplicationRuleStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReplicationRuleStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "Disabled"
        case .enabled: return "Enabled"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReplicationRuleStatus(rawValue: rawValue) ?? ReplicationRuleStatus.sdkUnknown(rawValue)
    }
}

public enum ReplicationStatus {
    case complete
    case failed
    case pending
    case replica
    case sdkUnknown(String)
}

extension ReplicationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReplicationStatus] {
        return [
            .complete,
            .failed,
            .pending,
            .replica,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .complete: return "COMPLETE"
        case .failed: return "FAILED"
        case .pending: return "PENDING"
        case .replica: return "REPLICA"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReplicationStatus(rawValue: rawValue) ?? ReplicationStatus.sdkUnknown(rawValue)
    }
}

extension ReplicationTime: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
        case time = "Time"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
        if let time = time {
            try container.encode(time, forKey: Key("time"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ReplicationTimeStatus.self, forKey: .status)
        status = statusDecoded
        let timeDecoded = try containerValues.decodeIfPresent(ReplicationTimeValue.self, forKey: .time)
        time = timeDecoded
    }
}

extension ReplicationTime: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationTime(status: \(String(describing: status)), time: \(String(describing: time)))"}
}

extension ReplicationTime: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p> A container specifying S3 Replication Time Control (S3 RTC) related information, including whether S3 RTC is
///          enabled and the time when all objects and operations on objects must be replicated. Must be
///          specified together with a <code>Metrics</code> block. </p>
public struct ReplicationTime: Equatable {
    /// <p> Specifies whether the replication time is enabled. </p>
    public let status: ReplicationTimeStatus?
    /// <p> A container specifying the time by which replication should be complete for all objects
    ///          and operations on objects. </p>
    public let time: ReplicationTimeValue?

    public init (
        status: ReplicationTimeStatus? = nil,
        time: ReplicationTimeValue? = nil
    )
    {
        self.status = status
        self.time = time
    }
}

public enum ReplicationTimeStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension ReplicationTimeStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReplicationTimeStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "Disabled"
        case .enabled: return "Enabled"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReplicationTimeStatus(rawValue: rawValue) ?? ReplicationTimeStatus.sdkUnknown(rawValue)
    }
}

extension ReplicationTimeValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case minutes = "Minutes"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if minutes != 0 {
            try container.encode(minutes, forKey: Key("minutes"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minutesDecoded = try containerValues.decode(Int.self, forKey: .minutes)
        minutes = minutesDecoded
    }
}

extension ReplicationTimeValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationTimeValue(minutes: \(String(describing: minutes)))"}
}

extension ReplicationTimeValue: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p> A container specifying the time value for S3 Replication Time Control (S3 RTC) and replication metrics
///             <code>EventThreshold</code>. </p>
public struct ReplicationTimeValue: Equatable {
    /// <p> Contains an integer specifying time in minutes. </p>
    ///          <p> Valid values: 15 minutes. </p>
    public let minutes: Int

    public init (
        minutes: Int = 0
    )
    {
        self.minutes = minutes
    }
}

/// <p>If present, indicates that the requester was successfully charged for the
///          request.</p>
public enum RequestCharged {
    case requester
    case sdkUnknown(String)
}

extension RequestCharged : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RequestCharged] {
        return [
            .requester,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .requester: return "requester"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RequestCharged(rawValue: rawValue) ?? RequestCharged.sdkUnknown(rawValue)
    }
}

/// <p>Confirms that the requester knows that they will be charged for the request. Bucket
///          owners need not specify this parameter in their requests. For information about downloading
///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
public enum RequestPayer {
    case requester
    case sdkUnknown(String)
}

extension RequestPayer : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RequestPayer] {
        return [
            .requester,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .requester: return "requester"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RequestPayer(rawValue: rawValue) ?? RequestPayer.sdkUnknown(rawValue)
    }
}

extension RequestPaymentConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case payer = "Payer"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let payer = payer {
            try container.encode(payer, forKey: Key("payer"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payerDecoded = try containerValues.decodeIfPresent(Payer.self, forKey: .payer)
        payer = payerDecoded
    }
}

extension RequestPaymentConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestPaymentConfiguration(payer: \(String(describing: payer)))"}
}

extension RequestPaymentConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container for Payer.</p>
public struct RequestPaymentConfiguration: Equatable {
    /// <p>Specifies who pays for the download and request fees.</p>
    public let payer: Payer?

    public init (
        payer: Payer? = nil
    )
    {
        self.payer = payer
    }
}

extension RequestProgress: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if enabled != false {
            try container.encode(enabled, forKey: Key("enabled"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension RequestProgress: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestProgress(enabled: \(String(describing: enabled)))"}
}

extension RequestProgress: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container for specifying if periodic <code>QueryProgress</code> messages should be
///          sent.</p>
public struct RequestProgress: Equatable {
    /// <p>Specifies whether periodic QueryProgress frames should be sent. Valid values: TRUE,
    ///          FALSE. Default value: FALSE.</p>
    public let enabled: Bool

    public init (
        enabled: Bool = false
    )
    {
        self.enabled = enabled
    }
}

public struct RestoreObjectInputBodyMiddleware: Middleware {
    public let id: String = "RestoreObjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let restoreRequest = input.operationInput.restoreRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(restoreRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreObjectInput>
    public typealias MOutput = OperationOutput<RestoreObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreObjectOutputError>
}

extension RestoreObjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreObjectInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), key: \(String(describing: key)), requestPayer: \(String(describing: requestPayer)), restoreRequest: \(String(describing: restoreRequest)), versionId: \(String(describing: versionId)))"}
}

extension RestoreObjectInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension RestoreObjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case restoreRequest = "RestoreRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let restoreRequest = restoreRequest {
            try container.encode(restoreRequest, forKey: Key("RestoreRequest"))
        }
    }
}

public struct RestoreObjectInputHeadersMiddleware: Middleware {
    public let id: String = "RestoreObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreObjectInput>
    public typealias MOutput = OperationOutput<RestoreObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreObjectOutputError>
}

public struct RestoreObjectInputQueryItemMiddleware: Middleware {
    public let id: String = "RestoreObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "restore", value: nil))
        input.builder.withQueryItem(URLQueryItem(name: "x-id", value: "RestoreObject"))
        if let versionId = input.operationInput.versionId {
            let versionIdQueryItem = URLQueryItem(name: "versionId".urlPercentEncoding(), value: String(versionId).urlPercentEncoding())
            input.builder.withQueryItem(versionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreObjectInput>
    public typealias MOutput = OperationOutput<RestoreObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreObjectOutputError>
}

public struct RestoreObjectInput: Equatable {
    /// <p>The bucket name containing the object to restore. </p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>Object key for which the action was initiated.</p>
    public let key: String?
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    ///          owners need not specify this parameter in their requests. For information about downloading
    ///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    ///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let requestPayer: RequestPayer?
    /// <p>Container for restore job parameters.</p>
    public let restoreRequest: RestoreRequest?
    /// <p>VersionId used to reference a specific version of the object.</p>
    public let versionId: String?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        key: String? = nil,
        requestPayer: RequestPayer? = nil,
        restoreRequest: RestoreRequest? = nil,
        versionId: String? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.requestPayer = requestPayer
        self.restoreRequest = restoreRequest
        self.versionId = versionId
    }
}

struct RestoreObjectInputBody: Equatable {
    public let restoreRequest: RestoreRequest?
}

extension RestoreObjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case restoreRequest = "RestoreRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restoreRequestDecoded = try containerValues.decodeIfPresent(RestoreRequest.self, forKey: .restoreRequest)
        restoreRequest = restoreRequestDecoded
    }
}

extension RestoreObjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreObjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ObjectAlreadyInActiveTierError" : self = .objectAlreadyInActiveTierError(try ObjectAlreadyInActiveTierError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreObjectOutputError: Equatable {
    case objectAlreadyInActiveTierError(ObjectAlreadyInActiveTierError)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreObjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreObjectOutputResponse(requestCharged: \(String(describing: requestCharged)), restoreOutputPath: \(String(describing: restoreOutputPath)))"}
}

extension RestoreObjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if let restoreOutputPathHeaderValue = httpResponse.headers.value(for: "x-amz-restore-output-path") {
            self.restoreOutputPath = restoreOutputPathHeaderValue
        } else {
            self.restoreOutputPath = nil
        }
    }
}

public struct RestoreObjectOutputResponse: Equatable {
    /// <p>If present, indicates that the requester was successfully charged for the
    ///          request.</p>
    public let requestCharged: RequestCharged?
    /// <p>Indicates the path in the provided S3 output location where Select results will be
    ///          restored to.</p>
    public let restoreOutputPath: String?

    public init (
        requestCharged: RequestCharged? = nil,
        restoreOutputPath: String? = nil
    )
    {
        self.requestCharged = requestCharged
        self.restoreOutputPath = restoreOutputPath
    }
}

struct RestoreObjectOutputResponseBody: Equatable {
}

extension RestoreObjectOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RestoreRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case days = "Days"
        case description = "Description"
        case glacierJobParameters = "GlacierJobParameters"
        case outputLocation = "OutputLocation"
        case selectParameters = "SelectParameters"
        case tier = "Tier"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if days != 0 {
            try container.encode(days, forKey: Key("days"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("description"))
        }
        if let glacierJobParameters = glacierJobParameters {
            try container.encode(glacierJobParameters, forKey: Key("glacierJobParameters"))
        }
        if let outputLocation = outputLocation {
            try container.encode(outputLocation, forKey: Key("outputLocation"))
        }
        if let selectParameters = selectParameters {
            try container.encode(selectParameters, forKey: Key("selectParameters"))
        }
        if let tier = tier {
            try container.encode(tier, forKey: Key("tier"))
        }
        if let type = type {
            try container.encode(type, forKey: Key("type"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let daysDecoded = try containerValues.decode(Int.self, forKey: .days)
        days = daysDecoded
        let glacierJobParametersDecoded = try containerValues.decodeIfPresent(GlacierJobParameters.self, forKey: .glacierJobParameters)
        glacierJobParameters = glacierJobParametersDecoded
        let typeDecoded = try containerValues.decodeIfPresent(RestoreRequestType.self, forKey: .type)
        type = typeDecoded
        let tierDecoded = try containerValues.decodeIfPresent(Tier.self, forKey: .tier)
        tier = tierDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let selectParametersDecoded = try containerValues.decodeIfPresent(SelectParameters.self, forKey: .selectParameters)
        selectParameters = selectParametersDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
    }
}

extension RestoreRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreRequest(days: \(String(describing: days)), description: \(String(describing: description)), glacierJobParameters: \(String(describing: glacierJobParameters)), outputLocation: \(String(describing: outputLocation)), selectParameters: \(String(describing: selectParameters)), tier: \(String(describing: tier)), type: \(String(describing: type)))"}
}

extension RestoreRequest: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container for restore job parameters.</p>
public struct RestoreRequest: Equatable {
    /// <p>Lifetime of the active copy in days. Do not use with restores that specify
    ///             <code>OutputLocation</code>.</p>
    ///          <p>The Days element is required for regular restores, and must not be provided for select
    ///          requests.</p>
    public let days: Int
    /// <p>The optional description for the job.</p>
    public let description: String?
    /// <p>S3 Glacier related parameters pertaining to this job. Do not use with restores that
    ///          specify <code>OutputLocation</code>.</p>
    public let glacierJobParameters: GlacierJobParameters?
    /// <p>Describes the location where the restore job's output is stored.</p>
    public let outputLocation: OutputLocation?
    /// <p>Describes the parameters for Select job types.</p>
    public let selectParameters: SelectParameters?
    /// <p>Retrieval tier at which the restore will be processed.</p>
    public let tier: Tier?
    /// <p>Type of restore request.</p>
    public let type: RestoreRequestType?

    public init (
        days: Int = 0,
        description: String? = nil,
        glacierJobParameters: GlacierJobParameters? = nil,
        outputLocation: OutputLocation? = nil,
        selectParameters: SelectParameters? = nil,
        tier: Tier? = nil,
        type: RestoreRequestType? = nil
    )
    {
        self.days = days
        self.description = description
        self.glacierJobParameters = glacierJobParameters
        self.outputLocation = outputLocation
        self.selectParameters = selectParameters
        self.tier = tier
        self.type = type
    }
}

public enum RestoreRequestType {
    case select
    case sdkUnknown(String)
}

extension RestoreRequestType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RestoreRequestType] {
        return [
            .select,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .select: return "SELECT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RestoreRequestType(rawValue: rawValue) ?? RestoreRequestType.sdkUnknown(rawValue)
    }
}

extension RoutingRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case condition = "Condition"
        case redirect = "Redirect"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let condition = condition {
            try container.encode(condition, forKey: Key("condition"))
        }
        if let redirect = redirect {
            try container.encode(redirect, forKey: Key("redirect"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionDecoded = try containerValues.decodeIfPresent(Condition.self, forKey: .condition)
        condition = conditionDecoded
        let redirectDecoded = try containerValues.decodeIfPresent(Redirect.self, forKey: .redirect)
        redirect = redirectDecoded
    }
}

extension RoutingRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RoutingRule(condition: \(String(describing: condition)), redirect: \(String(describing: redirect)))"}
}

extension RoutingRule: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies the redirect behavior and when a redirect is applied. For more information
///          about routing rules, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/how-to-page-redirect.html#advanced-conditional-redirects">Configuring advanced conditional redirects</a> in the
///             <i>Amazon S3 User Guide</i>.</p>
public struct RoutingRule: Equatable {
    /// <p>A container for describing a condition that must be met for the specified redirect to
    ///          apply. For example, 1. If request is for pages in the <code>/docs</code> folder, redirect
    ///          to the <code>/documents</code> folder. 2. If request results in HTTP error 4xx, redirect
    ///          request to another host where you might process the error.</p>
    public let condition: Condition?
    /// <p>Container for redirect information. You can redirect requests to another host, to
    ///          another page, or with another protocol. In the event of an error, you can specify a
    ///          different error code to return.</p>
    public let redirect: Redirect?

    public init (
        condition: Condition? = nil,
        redirect: Redirect? = nil
    )
    {
        self.condition = condition
        self.redirect = redirect
    }
}

extension S3KeyFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filterRules = "FilterRule"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let filterRules = filterRules {
            if filterRules.isEmpty {
                var filterRulesContainer = container.nestedUnkeyedContainer(forKey: Key("FilterRule"))
                try filterRulesContainer.encodeNil()
            } else {
                for filterrule0 in filterRules {
                    var filterRulesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("FilterRule"))
                    try filterRulesContainer0.encode(filterrule0, forKey: Key(""))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.filterRules) {
            let filterRulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .filterRules)
            if filterRulesWrappedContainer != nil {
                let filterRulesContainer = try containerValues.decodeIfPresent([FilterRule].self, forKey: .filterRules)
                var filterRulesBuffer:[FilterRule]? = nil
                if let filterRulesContainer = filterRulesContainer {
                    filterRulesBuffer = [FilterRule]()
                    for structureContainer0 in filterRulesContainer {
                        filterRulesBuffer?.append(structureContainer0)
                    }
                }
                filterRules = filterRulesBuffer
            } else {
                filterRules = []
            }
        } else {
            filterRules = nil
        }
    }
}

extension S3KeyFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3KeyFilter(filterRules: \(String(describing: filterRules)))"}
}

extension S3KeyFilter: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container for object key name prefix and suffix filtering rules.</p>
public struct S3KeyFilter: Equatable {
    /// <p>A list of containers for the key-value pair that defines the criteria for the filter
    ///          rule.</p>
    public let filterRules: [FilterRule]?

    public init (
        filterRules: [FilterRule]? = nil
    )
    {
        self.filterRules = filterRules
    }
}

extension S3Location: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessControlList = "AccessControlList"
        case bucketName = "BucketName"
        case cannedACL = "CannedACL"
        case encryption = "Encryption"
        case prefix = "Prefix"
        case storageClass = "StorageClass"
        case tagging = "Tagging"
        case userMetadata = "UserMetadata"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let accessControlList = accessControlList {
            var accessControlListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("accessControlList"))
            for grant0 in accessControlList {
                try accessControlListContainer.encode(grant0, forKey: Key("Grant"))
            }
        }
        if let bucketName = bucketName {
            try container.encode(bucketName, forKey: Key("bucketName"))
        }
        if let cannedACL = cannedACL {
            try container.encode(cannedACL, forKey: Key("cannedACL"))
        }
        if let encryption = encryption {
            try container.encode(encryption, forKey: Key("encryption"))
        }
        if let prefix = prefix {
            try container.encode(prefix, forKey: Key("prefix"))
        }
        if let storageClass = storageClass {
            try container.encode(storageClass, forKey: Key("storageClass"))
        }
        if let tagging = tagging {
            try container.encode(tagging, forKey: Key("tagging"))
        }
        if let userMetadata = userMetadata {
            var userMetadataContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("userMetadata"))
            for metadataentry0 in userMetadata {
                try userMetadataContainer.encode(metadataentry0, forKey: Key("MetadataEntry"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let cannedACLDecoded = try containerValues.decodeIfPresent(ObjectCannedACL.self, forKey: .cannedACL)
        cannedACL = cannedACLDecoded
        if containerValues.contains(.accessControlList) {
            struct KeyVal0{struct Grant{}}
            let accessControlListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Grant>.CodingKeys.self, forKey: .accessControlList)
            if let accessControlListWrappedContainer = accessControlListWrappedContainer {
                let accessControlListContainer = try accessControlListWrappedContainer.decodeIfPresent([Grant].self, forKey: .member)
                var accessControlListBuffer:[Grant]? = nil
                if let accessControlListContainer = accessControlListContainer {
                    accessControlListBuffer = [Grant]()
                    for structureContainer0 in accessControlListContainer {
                        accessControlListBuffer?.append(structureContainer0)
                    }
                }
                accessControlList = accessControlListBuffer
            } else {
                accessControlList = []
            }
        } else {
            accessControlList = nil
        }
        let taggingDecoded = try containerValues.decodeIfPresent(Tagging.self, forKey: .tagging)
        tagging = taggingDecoded
        if containerValues.contains(.userMetadata) {
            struct KeyVal0{struct MetadataEntry{}}
            let userMetadataWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.MetadataEntry>.CodingKeys.self, forKey: .userMetadata)
            if let userMetadataWrappedContainer = userMetadataWrappedContainer {
                let userMetadataContainer = try userMetadataWrappedContainer.decodeIfPresent([MetadataEntry].self, forKey: .member)
                var userMetadataBuffer:[MetadataEntry]? = nil
                if let userMetadataContainer = userMetadataContainer {
                    userMetadataBuffer = [MetadataEntry]()
                    for structureContainer0 in userMetadataContainer {
                        userMetadataBuffer?.append(structureContainer0)
                    }
                }
                userMetadata = userMetadataBuffer
            } else {
                userMetadata = []
            }
        } else {
            userMetadata = nil
        }
        let storageClassDecoded = try containerValues.decodeIfPresent(StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

extension S3Location: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Location(accessControlList: \(String(describing: accessControlList)), bucketName: \(String(describing: bucketName)), cannedACL: \(String(describing: cannedACL)), encryption: \(String(describing: encryption)), prefix: \(String(describing: prefix)), storageClass: \(String(describing: storageClass)), tagging: \(String(describing: tagging)), userMetadata: \(String(describing: userMetadata)))"}
}

extension S3Location: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Describes an Amazon S3 location that will receive the results of the restore request.</p>
public struct S3Location: Equatable {
    /// <p>A list of grants that control access to the staged results.</p>
    public let accessControlList: [Grant]?
    /// <p>The name of the bucket where the restore results will be placed.</p>
    public let bucketName: String?
    /// <p>The canned ACL to apply to the restore results.</p>
    public let cannedACL: ObjectCannedACL?
    /// <p>Contains the type of server-side encryption used.</p>
    public let encryption: Encryption?
    /// <p>The prefix that is prepended to the restore results for this request.</p>
    public let prefix: String?
    /// <p>The class of storage used to store the restore results.</p>
    public let storageClass: StorageClass?
    /// <p>The tag-set that is applied to the restore results.</p>
    public let tagging: Tagging?
    /// <p>A list of metadata to store with the restore results in S3.</p>
    public let userMetadata: [MetadataEntry]?

    public init (
        accessControlList: [Grant]? = nil,
        bucketName: String? = nil,
        cannedACL: ObjectCannedACL? = nil,
        encryption: Encryption? = nil,
        prefix: String? = nil,
        storageClass: StorageClass? = nil,
        tagging: Tagging? = nil,
        userMetadata: [MetadataEntry]? = nil
    )
    {
        self.accessControlList = accessControlList
        self.bucketName = bucketName
        self.cannedACL = cannedACL
        self.encryption = encryption
        self.prefix = prefix
        self.storageClass = storageClass
        self.tagging = tagging
        self.userMetadata = userMetadata
    }
}

extension SSEKMS: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let keyId = keyId {
            try container.encode(keyId, forKey: Key("keyId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension SSEKMS: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SSEKMS(keyId: \(String(describing: keyId)))"}
}

extension SSEKMS: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies the use of SSE-KMS to encrypt delivered inventory reports.</p>
public struct SSEKMS: Equatable {
    /// <p>Specifies the ID of the AWS Key Management Service (AWS KMS) symmetric customer managed
    ///          customer master key (CMK) to use for encrypting inventory reports.</p>
    public let keyId: String?

    public init (
        keyId: String? = nil
    )
    {
        self.keyId = keyId
    }
}

extension SSES3: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension SSES3: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SSES3()"}
}

/// <p>Specifies the use of SSE-S3 to encrypt delivered inventory reports.</p>
public struct SSES3: Equatable {

    public init() {}
}

extension ScanRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case end = "End"
        case start = "Start"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if end != 0 {
            try container.encode(end, forKey: Key("end"))
        }
        if start != 0 {
            try container.encode(start, forKey: Key("start"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decode(Int.self, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decode(Int.self, forKey: .end)
        end = endDecoded
    }
}

extension ScanRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScanRange(end: \(String(describing: end)), start: \(String(describing: start)))"}
}

extension ScanRange: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies the byte range of the object to get the records from. A record is processed
///          when its first byte is contained by the range. This parameter is optional, but when
///          specified, it must not be empty. See RFC 2616, Section 14.35.1 about how to specify the
///          start and end of the range.</p>
public struct ScanRange: Equatable {
    /// <p>Specifies the end of the byte range. This parameter is optional. Valid values:
    ///          non-negative integers. The default value is one less than the size of the object being
    ///          queried. If only the End parameter is supplied, it is interpreted to mean scan the last N
    ///          bytes of the file. For example,
    ///             <code><scanrange><end>50</end></scanrange></code> means scan the
    ///          last 50 bytes.</p>
    public let end: Int
    /// <p>Specifies the start of the byte range. This parameter is optional. Valid values:
    ///          non-negative integers. The default value is 0. If only start is supplied, it means scan
    ///          from that point to the end of the file.For example;
    ///             <code><scanrange><start>50</start></scanrange></code> means scan
    ///          from byte 50 until the end of the file.</p>
    public let start: Int

    public init (
        end: Int = 0,
        start: Int = 0
    )
    {
        self.end = end
        self.start = start
    }
}

extension SelectObjectContentEventStream: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cont = "Cont"
        case end = "End"
        case progress = "Progress"
        case records = "Records"
        case stats = "Stats"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        switch self {
            case let .cont(cont):
                if let cont = cont {
                    try container.encode(cont, forKey: Key("cont"))
                }
            case let .end(end):
                if let end = end {
                    try container.encode(end, forKey: Key("end"))
                }
            case let .progress(progress):
                if let progress = progress {
                    try container.encode(progress, forKey: Key("progress"))
                }
            case let .records(records):
                if let records = records {
                    try container.encode(records, forKey: Key("records"))
                }
            case let .stats(stats):
                if let stats = stats {
                    try container.encode(stats, forKey: Key("stats"))
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: Key("sdkUnknown"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsDecoded = try containerValues.decodeIfPresent(RecordsEvent.self, forKey: .records)
        if let records = recordsDecoded {
            self = .records(records)
            return
        }
        let statsDecoded = try containerValues.decodeIfPresent(StatsEvent.self, forKey: .stats)
        if let stats = statsDecoded {
            self = .stats(stats)
            return
        }
        let progressDecoded = try containerValues.decodeIfPresent(ProgressEvent.self, forKey: .progress)
        if let progress = progressDecoded {
            self = .progress(progress)
            return
        }
        let contDecoded = try containerValues.decodeIfPresent(ContinuationEvent.self, forKey: .cont)
        if let cont = contDecoded {
            self = .cont(cont)
            return
        }
        let endDecoded = try containerValues.decodeIfPresent(EndEvent.self, forKey: .end)
        if let end = endDecoded {
            self = .end(end)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>The container for selecting objects from a content event stream.</p>
public enum SelectObjectContentEventStream: Equatable {
    /// <p>The Records Event.</p>
    case records(RecordsEvent?)
    /// <p>The Stats Event.</p>
    case stats(StatsEvent?)
    /// <p>The Progress Event.</p>
    case progress(ProgressEvent?)
    /// <p>The Continuation Event.</p>
    case cont(ContinuationEvent?)
    /// <p>The End Event.</p>
    case end(EndEvent?)
    case sdkUnknown(String?)
}

public struct SelectObjectContentInputBodyMiddleware: Middleware {
    public let id: String = "SelectObjectContentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SelectObjectContentInput>,
                  next: H) -> Swift.Result<OperationOutput<SelectObjectContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SelectObjectContentInput>
    public typealias MOutput = OperationOutput<SelectObjectContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SelectObjectContentOutputError>
}

extension SelectObjectContentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SelectObjectContentInput(bucket: \(String(describing: bucket)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), expression: \(String(describing: expression)), expressionType: \(String(describing: expressionType)), inputSerialization: \(String(describing: inputSerialization)), key: \(String(describing: key)), outputSerialization: \(String(describing: outputSerialization)), requestProgress: \(String(describing: requestProgress)), sSECustomerAlgorithm: \(String(describing: sSECustomerAlgorithm)), sSECustomerKey: \(String(describing: sSECustomerKey)), sSECustomerKeyMD5: \(String(describing: sSECustomerKeyMD5)), scanRange: \(String(describing: scanRange)))"}
}

extension SelectObjectContentInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension SelectObjectContentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case inputSerialization = "InputSerialization"
        case outputSerialization = "OutputSerialization"
        case requestProgress = "RequestProgress"
        case scanRange = "ScanRange"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let expression = expression {
            try container.encode(expression, forKey: Key("expression"))
        }
        if let expressionType = expressionType {
            try container.encode(expressionType, forKey: Key("expressionType"))
        }
        if let inputSerialization = inputSerialization {
            try container.encode(inputSerialization, forKey: Key("inputSerialization"))
        }
        if let outputSerialization = outputSerialization {
            try container.encode(outputSerialization, forKey: Key("outputSerialization"))
        }
        if let requestProgress = requestProgress {
            try container.encode(requestProgress, forKey: Key("requestProgress"))
        }
        if let scanRange = scanRange {
            try container.encode(scanRange, forKey: Key("scanRange"))
        }
    }
}

public struct SelectObjectContentInputHeadersMiddleware: Middleware {
    public let id: String = "SelectObjectContentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SelectObjectContentInput>,
                  next: H) -> Swift.Result<OperationOutput<SelectObjectContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let sSECustomerAlgorithm = input.operationInput.sSECustomerAlgorithm {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-algorithm", value: String(sSECustomerAlgorithm))
        }
        if let sSECustomerKey = input.operationInput.sSECustomerKey {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-key", value: String(sSECustomerKey))
        }
        if let sSECustomerKeyMD5 = input.operationInput.sSECustomerKeyMD5 {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-key-MD5", value: String(sSECustomerKeyMD5))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SelectObjectContentInput>
    public typealias MOutput = OperationOutput<SelectObjectContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SelectObjectContentOutputError>
}

public struct SelectObjectContentInputQueryItemMiddleware: Middleware {
    public let id: String = "SelectObjectContentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SelectObjectContentInput>,
                  next: H) -> Swift.Result<OperationOutput<SelectObjectContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "select", value: nil))
        input.builder.withQueryItem(URLQueryItem(name: "select-type", value: "2"))
        input.builder.withQueryItem(URLQueryItem(name: "x-id", value: "SelectObjectContent"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SelectObjectContentInput>
    public typealias MOutput = OperationOutput<SelectObjectContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SelectObjectContentOutputError>
}

/// <p>Request to filter the contents of an Amazon S3 object based on a simple Structured Query
///          Language (SQL) statement. In the request, along with the SQL expression, you must specify a
///          data serialization format (JSON or CSV) of the object. Amazon S3 uses this to parse object data
///          into records. It returns only records that match the specified SQL expression. You must
///          also specify the data serialization format for the response. For more information, see
///             <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectSELECTContent.html">S3Select API Documentation</a>.</p>
public struct SelectObjectContentInput: Equatable {
    /// <p>The S3 bucket.</p>
    public let bucket: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The expression that is used to query the object.</p>
    public let expression: String?
    /// <p>The type of the provided expression (for example, SQL).</p>
    public let expressionType: ExpressionType?
    /// <p>Describes the format of the data in the object that is being queried.</p>
    public let inputSerialization: InputSerialization?
    /// <p>The object key.</p>
    public let key: String?
    /// <p>Describes the format of the data that you want Amazon S3 to return in response.</p>
    public let outputSerialization: OutputSerialization?
    /// <p>Specifies if periodic request progress information should be enabled.</p>
    public let requestProgress: RequestProgress?
    /// <p>The SSE Algorithm used to encrypt the object. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ServerSideEncryptionCustomerKeys.html">Server-Side Encryption (Using Customer-Provided Encryption Keys</a>. </p>
    public let sSECustomerAlgorithm: String?
    /// <p>The SSE Customer Key. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ServerSideEncryptionCustomerKeys.html">Server-Side Encryption
    ///             (Using Customer-Provided Encryption Keys</a>. </p>
    public let sSECustomerKey: String?
    /// <p>The SSE Customer Key MD5. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ServerSideEncryptionCustomerKeys.html">Server-Side Encryption
    ///             (Using Customer-Provided Encryption Keys</a>. </p>
    public let sSECustomerKeyMD5: String?
    /// <p>Specifies the byte range of the object to get the records from. A record is processed
    ///          when its first byte is contained by the range. This parameter is optional, but when
    ///          specified, it must not be empty. See RFC 2616, Section 14.35.1 about how to specify the
    ///          start and end of the range.</p>
    ///          <p>
    ///             <code>ScanRange</code>may be used in the following ways:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code><scanrange><start>50</start><end>100</end></scanrange></code>
    ///                - process only the records starting between the bytes 50 and 100 (inclusive, counting
    ///                from zero)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code><scanrange><start>50</start></scanrange></code> -
    ///                process only the records starting after the byte 50</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code><scanrange><end>50</end></scanrange></code> -
    ///                process only the records within the last 50 bytes of the file.</p>
    ///             </li>
    ///          </ul>
    public let scanRange: ScanRange?

    public init (
        bucket: String? = nil,
        expectedBucketOwner: String? = nil,
        expression: String? = nil,
        expressionType: ExpressionType? = nil,
        inputSerialization: InputSerialization? = nil,
        key: String? = nil,
        outputSerialization: OutputSerialization? = nil,
        requestProgress: RequestProgress? = nil,
        sSECustomerAlgorithm: String? = nil,
        sSECustomerKey: String? = nil,
        sSECustomerKeyMD5: String? = nil,
        scanRange: ScanRange? = nil
    )
    {
        self.bucket = bucket
        self.expectedBucketOwner = expectedBucketOwner
        self.expression = expression
        self.expressionType = expressionType
        self.inputSerialization = inputSerialization
        self.key = key
        self.outputSerialization = outputSerialization
        self.requestProgress = requestProgress
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKey = sSECustomerKey
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.scanRange = scanRange
    }
}

struct SelectObjectContentInputBody: Equatable {
    public let expression: String?
    public let expressionType: ExpressionType?
    public let requestProgress: RequestProgress?
    public let inputSerialization: InputSerialization?
    public let outputSerialization: OutputSerialization?
    public let scanRange: ScanRange?
}

extension SelectObjectContentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case inputSerialization = "InputSerialization"
        case outputSerialization = "OutputSerialization"
        case requestProgress = "RequestProgress"
        case scanRange = "ScanRange"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
        let expressionTypeDecoded = try containerValues.decodeIfPresent(ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let requestProgressDecoded = try containerValues.decodeIfPresent(RequestProgress.self, forKey: .requestProgress)
        requestProgress = requestProgressDecoded
        let inputSerializationDecoded = try containerValues.decodeIfPresent(InputSerialization.self, forKey: .inputSerialization)
        inputSerialization = inputSerializationDecoded
        let outputSerializationDecoded = try containerValues.decodeIfPresent(OutputSerialization.self, forKey: .outputSerialization)
        outputSerialization = outputSerializationDecoded
        let scanRangeDecoded = try containerValues.decodeIfPresent(ScanRange.self, forKey: .scanRange)
        scanRange = scanRangeDecoded
    }
}

extension SelectObjectContentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SelectObjectContentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SelectObjectContentOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SelectObjectContentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SelectObjectContentOutputResponse(payload: \(String(describing: payload)))"}
}

extension SelectObjectContentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: SelectObjectContentEventStream = try responseDecoder.decode(responseBody: unwrappedData)
                self.payload = output
            } else {
                self.payload = nil
            }
        } else {
            self.payload = nil
        }
    }
}

public struct SelectObjectContentOutputResponse: Equatable {
    /// <p>The array of results.</p>
    public let payload: SelectObjectContentEventStream?

    public init (
        payload: SelectObjectContentEventStream? = nil
    )
    {
        self.payload = payload
    }
}

struct SelectObjectContentOutputResponseBody: Equatable {
    public let payload: SelectObjectContentEventStream?
}

extension SelectObjectContentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case payload = "Payload"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(SelectObjectContentEventStream.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension SelectParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case inputSerialization = "InputSerialization"
        case outputSerialization = "OutputSerialization"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let expression = expression {
            try container.encode(expression, forKey: Key("expression"))
        }
        if let expressionType = expressionType {
            try container.encode(expressionType, forKey: Key("expressionType"))
        }
        if let inputSerialization = inputSerialization {
            try container.encode(inputSerialization, forKey: Key("inputSerialization"))
        }
        if let outputSerialization = outputSerialization {
            try container.encode(outputSerialization, forKey: Key("outputSerialization"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputSerializationDecoded = try containerValues.decodeIfPresent(InputSerialization.self, forKey: .inputSerialization)
        inputSerialization = inputSerializationDecoded
        let expressionTypeDecoded = try containerValues.decodeIfPresent(ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
        let outputSerializationDecoded = try containerValues.decodeIfPresent(OutputSerialization.self, forKey: .outputSerialization)
        outputSerialization = outputSerializationDecoded
    }
}

extension SelectParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SelectParameters(expression: \(String(describing: expression)), expressionType: \(String(describing: expressionType)), inputSerialization: \(String(describing: inputSerialization)), outputSerialization: \(String(describing: outputSerialization)))"}
}

extension SelectParameters: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Describes the parameters for Select job types.</p>
public struct SelectParameters: Equatable {
    /// <p>The expression that is used to query the object.</p>
    public let expression: String?
    /// <p>The type of the provided expression (for example, SQL).</p>
    public let expressionType: ExpressionType?
    /// <p>Describes the serialization format of the object.</p>
    public let inputSerialization: InputSerialization?
    /// <p>Describes how the results of the Select job are serialized.</p>
    public let outputSerialization: OutputSerialization?

    public init (
        expression: String? = nil,
        expressionType: ExpressionType? = nil,
        inputSerialization: InputSerialization? = nil,
        outputSerialization: OutputSerialization? = nil
    )
    {
        self.expression = expression
        self.expressionType = expressionType
        self.inputSerialization = inputSerialization
        self.outputSerialization = outputSerialization
    }
}

public enum ServerSideEncryption {
    case aes256
    case awsKms
    case sdkUnknown(String)
}

extension ServerSideEncryption : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServerSideEncryption] {
        return [
            .aes256,
            .awsKms,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aes256: return "AES256"
        case .awsKms: return "aws:kms"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServerSideEncryption(rawValue: rawValue) ?? ServerSideEncryption.sdkUnknown(rawValue)
    }
}

extension ServerSideEncryptionByDefault: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kMSMasterKeyID = "KMSMasterKeyID"
        case sSEAlgorithm = "SSEAlgorithm"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let kMSMasterKeyID = kMSMasterKeyID {
            try container.encode(kMSMasterKeyID, forKey: Key("kMSMasterKeyID"))
        }
        if let sSEAlgorithm = sSEAlgorithm {
            try container.encode(sSEAlgorithm, forKey: Key("sSEAlgorithm"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sSEAlgorithmDecoded = try containerValues.decodeIfPresent(ServerSideEncryption.self, forKey: .sSEAlgorithm)
        sSEAlgorithm = sSEAlgorithmDecoded
        let kMSMasterKeyIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSMasterKeyID)
        kMSMasterKeyID = kMSMasterKeyIDDecoded
    }
}

extension ServerSideEncryptionByDefault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerSideEncryptionByDefault(kMSMasterKeyID: \(String(describing: kMSMasterKeyID)), sSEAlgorithm: \(String(describing: sSEAlgorithm)))"}
}

extension ServerSideEncryptionByDefault: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Describes the default server-side encryption to apply to new objects in the bucket. If a
///          PUT Object request doesn't specify any server-side encryption, this default encryption will
///          be applied. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTencryption.html">PUT Bucket encryption</a> in
///          the <i>Amazon S3 API Reference</i>.</p>
public struct ServerSideEncryptionByDefault: Equatable {
    /// <p>AWS Key Management Service (KMS) customer AWS KMS key ID to use for the default
    ///         encryption. This parameter is allowed if and only if <code>SSEAlgorithm</code> is set to
    ///         <code>aws:kms</code>.</p>
    ///          <p>You can specify the key ID or the Amazon Resource Name (ARN) of the KMS key. However, if you
    ///         are using encryption with cross-account operations, you must use a fully qualified KMS key ARN.
    ///         For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html#bucket-encryption-update-bucket-policy">Using encryption for cross-account operations</a>. </p>
    ///          <p>
    ///             <b>For example:</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN:
    ///                   <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <important>
    ///             <p>Amazon S3 only supports symmetric KMS keys and not asymmetric KMS keys. For more information, see
    ///            <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using symmetric and
    ///            asymmetric keys</a> in the <i>AWS Key Management Service Developer Guide</i>.</p>
    ///          </important>
    public let kMSMasterKeyID: String?
    /// <p>Server-side encryption algorithm to use for the default encryption.</p>
    public let sSEAlgorithm: ServerSideEncryption?

    public init (
        kMSMasterKeyID: String? = nil,
        sSEAlgorithm: ServerSideEncryption? = nil
    )
    {
        self.kMSMasterKeyID = kMSMasterKeyID
        self.sSEAlgorithm = sSEAlgorithm
    }
}

extension ServerSideEncryptionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case rules = "Rule"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let rules = rules {
            if rules.isEmpty {
                var rulesContainer = container.nestedUnkeyedContainer(forKey: Key("Rule"))
                try rulesContainer.encodeNil()
            } else {
                for serversideencryptionrule0 in rules {
                    var rulesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Rule"))
                    try rulesContainer0.encode(serversideencryptionrule0, forKey: Key(""))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.rules) {
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .rules)
            if rulesWrappedContainer != nil {
                let rulesContainer = try containerValues.decodeIfPresent([ServerSideEncryptionRule].self, forKey: .rules)
                var rulesBuffer:[ServerSideEncryptionRule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [ServerSideEncryptionRule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

extension ServerSideEncryptionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerSideEncryptionConfiguration(rules: \(String(describing: rules)))"}
}

extension ServerSideEncryptionConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies the default server-side-encryption configuration.</p>
public struct ServerSideEncryptionConfiguration: Equatable {
    /// <p>Container for information about a particular server-side encryption configuration
    ///          rule.</p>
    public let rules: [ServerSideEncryptionRule]?

    public init (
        rules: [ServerSideEncryptionRule]? = nil
    )
    {
        self.rules = rules
    }
}

extension ServerSideEncryptionRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applyServerSideEncryptionByDefault = "ApplyServerSideEncryptionByDefault"
        case bucketKeyEnabled = "BucketKeyEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let applyServerSideEncryptionByDefault = applyServerSideEncryptionByDefault {
            try container.encode(applyServerSideEncryptionByDefault, forKey: Key("applyServerSideEncryptionByDefault"))
        }
        if bucketKeyEnabled != false {
            try container.encode(bucketKeyEnabled, forKey: Key("bucketKeyEnabled"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applyServerSideEncryptionByDefaultDecoded = try containerValues.decodeIfPresent(ServerSideEncryptionByDefault.self, forKey: .applyServerSideEncryptionByDefault)
        applyServerSideEncryptionByDefault = applyServerSideEncryptionByDefaultDecoded
        let bucketKeyEnabledDecoded = try containerValues.decode(Bool.self, forKey: .bucketKeyEnabled)
        bucketKeyEnabled = bucketKeyEnabledDecoded
    }
}

extension ServerSideEncryptionRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerSideEncryptionRule(applyServerSideEncryptionByDefault: \(String(describing: applyServerSideEncryptionByDefault)), bucketKeyEnabled: \(String(describing: bucketKeyEnabled)))"}
}

extension ServerSideEncryptionRule: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies the default server-side encryption configuration.</p>
public struct ServerSideEncryptionRule: Equatable {
    /// <p>Specifies the default server-side encryption to apply to new objects in the bucket. If a
    ///          PUT Object request doesn't specify any server-side encryption, this default encryption will
    ///          be applied.</p>
    public let applyServerSideEncryptionByDefault: ServerSideEncryptionByDefault?
    /// <p>Specifies whether Amazon S3 should use an S3 Bucket Key with server-side encryption using KMS (SSE-KMS) for new objects in the bucket. Existing objects are not affected. Setting the <code>BucketKeyEnabled</code> element to <code>true</code> causes Amazon S3 to use an S3 Bucket Key. By default, S3 Bucket Key is not enabled.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-key.html">Amazon S3 Bucket Keys</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucketKeyEnabled: Bool

    public init (
        applyServerSideEncryptionByDefault: ServerSideEncryptionByDefault? = nil,
        bucketKeyEnabled: Bool = false
    )
    {
        self.applyServerSideEncryptionByDefault = applyServerSideEncryptionByDefault
        self.bucketKeyEnabled = bucketKeyEnabled
    }
}

extension SourceSelectionCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replicaModifications = "ReplicaModifications"
        case sseKmsEncryptedObjects = "SseKmsEncryptedObjects"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let replicaModifications = replicaModifications {
            try container.encode(replicaModifications, forKey: Key("replicaModifications"))
        }
        if let sseKmsEncryptedObjects = sseKmsEncryptedObjects {
            try container.encode(sseKmsEncryptedObjects, forKey: Key("sseKmsEncryptedObjects"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sseKmsEncryptedObjectsDecoded = try containerValues.decodeIfPresent(SseKmsEncryptedObjects.self, forKey: .sseKmsEncryptedObjects)
        sseKmsEncryptedObjects = sseKmsEncryptedObjectsDecoded
        let replicaModificationsDecoded = try containerValues.decodeIfPresent(ReplicaModifications.self, forKey: .replicaModifications)
        replicaModifications = replicaModificationsDecoded
    }
}

extension SourceSelectionCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceSelectionCriteria(replicaModifications: \(String(describing: replicaModifications)), sseKmsEncryptedObjects: \(String(describing: sseKmsEncryptedObjects)))"}
}

extension SourceSelectionCriteria: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container that describes additional filters for identifying the source objects that
///          you want to replicate. You can choose to enable or disable the replication of these
///          objects. Currently, Amazon S3 supports only the filter that you can specify for objects created
///          with server-side encryption using a customer master key (CMK) stored in AWS Key Management
///          Service (SSE-KMS).</p>
public struct SourceSelectionCriteria: Equatable {
    /// <p>A filter that you can specify for selections for modifications on replicas. Amazon S3 doesn't
    ///          replicate replica modifications by default. In the latest version of replication
    ///          configuration (when <code>Filter</code> is specified), you can specify this element and set
    ///          the status to <code>Enabled</code> to replicate modifications on replicas. </p>
    ///          <note>
    ///             <p> If you don't specify the <code>Filter</code> element, Amazon S3 assumes that the
    ///             replication configuration is the earlier version, V1. In the earlier version, this
    ///             element is not allowed</p>
    ///          </note>
    public let replicaModifications: ReplicaModifications?
    /// <p> A container for filter information for the selection of Amazon S3 objects encrypted with AWS
    ///          KMS. If you include <code>SourceSelectionCriteria</code> in the replication configuration,
    ///          this element is required. </p>
    public let sseKmsEncryptedObjects: SseKmsEncryptedObjects?

    public init (
        replicaModifications: ReplicaModifications? = nil,
        sseKmsEncryptedObjects: SseKmsEncryptedObjects? = nil
    )
    {
        self.replicaModifications = replicaModifications
        self.sseKmsEncryptedObjects = sseKmsEncryptedObjects
    }
}

extension SseKmsEncryptedObjects: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SseKmsEncryptedObjectsStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension SseKmsEncryptedObjects: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SseKmsEncryptedObjects(status: \(String(describing: status)))"}
}

extension SseKmsEncryptedObjects: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container for filter information for the selection of S3 objects encrypted with AWS
///          KMS.</p>
public struct SseKmsEncryptedObjects: Equatable {
    /// <p>Specifies whether Amazon S3 replicates objects created with server-side encryption using an
    ///          AWS KMS key stored in AWS Key Management Service.</p>
    public let status: SseKmsEncryptedObjectsStatus?

    public init (
        status: SseKmsEncryptedObjectsStatus? = nil
    )
    {
        self.status = status
    }
}

public enum SseKmsEncryptedObjectsStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension SseKmsEncryptedObjectsStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SseKmsEncryptedObjectsStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "Disabled"
        case .enabled: return "Enabled"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SseKmsEncryptedObjectsStatus(rawValue: rawValue) ?? SseKmsEncryptedObjectsStatus.sdkUnknown(rawValue)
    }
}

extension Stats: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bytesProcessed = "BytesProcessed"
        case bytesReturned = "BytesReturned"
        case bytesScanned = "BytesScanned"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if bytesProcessed != 0 {
            try container.encode(bytesProcessed, forKey: Key("bytesProcessed"))
        }
        if bytesReturned != 0 {
            try container.encode(bytesReturned, forKey: Key("bytesReturned"))
        }
        if bytesScanned != 0 {
            try container.encode(bytesScanned, forKey: Key("bytesScanned"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bytesScannedDecoded = try containerValues.decode(Int.self, forKey: .bytesScanned)
        bytesScanned = bytesScannedDecoded
        let bytesProcessedDecoded = try containerValues.decode(Int.self, forKey: .bytesProcessed)
        bytesProcessed = bytesProcessedDecoded
        let bytesReturnedDecoded = try containerValues.decode(Int.self, forKey: .bytesReturned)
        bytesReturned = bytesReturnedDecoded
    }
}

extension Stats: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Stats(bytesProcessed: \(String(describing: bytesProcessed)), bytesReturned: \(String(describing: bytesReturned)), bytesScanned: \(String(describing: bytesScanned)))"}
}

extension Stats: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container for the stats details.</p>
public struct Stats: Equatable {
    /// <p>The total number of uncompressed object bytes processed.</p>
    public let bytesProcessed: Int
    /// <p>The total number of bytes of records payload data returned.</p>
    public let bytesReturned: Int
    /// <p>The total number of object bytes scanned.</p>
    public let bytesScanned: Int

    public init (
        bytesProcessed: Int = 0,
        bytesReturned: Int = 0,
        bytesScanned: Int = 0
    )
    {
        self.bytesProcessed = bytesProcessed
        self.bytesReturned = bytesReturned
        self.bytesScanned = bytesScanned
    }
}

extension StatsEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case details = "Details"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let details = details {
            try container.encode(details, forKey: Key("details"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(Stats.self, forKey: .details)
        details = detailsDecoded
    }
}

extension StatsEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StatsEvent(details: \(String(describing: details)))"}
}

extension StatsEvent: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container for the Stats Event.</p>
public struct StatsEvent: Equatable {
    /// <p>The Stats event details.</p>
    public let details: Stats?

    public init (
        details: Stats? = nil
    )
    {
        self.details = details
    }
}

public enum StorageClass {
    case deepArchive
    case glacier
    case intelligentTiering
    case onezoneIa
    case outposts
    case reducedRedundancy
    case standard
    case standardIa
    case sdkUnknown(String)
}

extension StorageClass : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StorageClass] {
        return [
            .deepArchive,
            .glacier,
            .intelligentTiering,
            .onezoneIa,
            .outposts,
            .reducedRedundancy,
            .standard,
            .standardIa,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deepArchive: return "DEEP_ARCHIVE"
        case .glacier: return "GLACIER"
        case .intelligentTiering: return "INTELLIGENT_TIERING"
        case .onezoneIa: return "ONEZONE_IA"
        case .outposts: return "OUTPOSTS"
        case .reducedRedundancy: return "REDUCED_REDUNDANCY"
        case .standard: return "STANDARD"
        case .standardIa: return "STANDARD_IA"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StorageClass(rawValue: rawValue) ?? StorageClass.sdkUnknown(rawValue)
    }
}

extension StorageClassAnalysis: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataExport = "DataExport"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let dataExport = dataExport {
            try container.encode(dataExport, forKey: Key("dataExport"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataExportDecoded = try containerValues.decodeIfPresent(StorageClassAnalysisDataExport.self, forKey: .dataExport)
        dataExport = dataExportDecoded
    }
}

extension StorageClassAnalysis: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StorageClassAnalysis(dataExport: \(String(describing: dataExport)))"}
}

extension StorageClassAnalysis: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies data related to access patterns to be collected and made available to analyze
///          the tradeoffs between different storage classes for an Amazon S3 bucket.</p>
public struct StorageClassAnalysis: Equatable {
    /// <p>Specifies how data related to the storage class analysis for an Amazon S3 bucket should be
    ///          exported.</p>
    public let dataExport: StorageClassAnalysisDataExport?

    public init (
        dataExport: StorageClassAnalysisDataExport? = nil
    )
    {
        self.dataExport = dataExport
    }
}

extension StorageClassAnalysisDataExport: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destination = "Destination"
        case outputSchemaVersion = "OutputSchemaVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let destination = destination {
            try container.encode(destination, forKey: Key("destination"))
        }
        if let outputSchemaVersion = outputSchemaVersion {
            try container.encode(outputSchemaVersion, forKey: Key("outputSchemaVersion"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputSchemaVersionDecoded = try containerValues.decodeIfPresent(StorageClassAnalysisSchemaVersion.self, forKey: .outputSchemaVersion)
        outputSchemaVersion = outputSchemaVersionDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(AnalyticsExportDestination.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension StorageClassAnalysisDataExport: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StorageClassAnalysisDataExport(destination: \(String(describing: destination)), outputSchemaVersion: \(String(describing: outputSchemaVersion)))"}
}

extension StorageClassAnalysisDataExport: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container for data related to the storage class analysis for an Amazon S3 bucket for
///          export.</p>
public struct StorageClassAnalysisDataExport: Equatable {
    /// <p>The place to store the data for an analysis.</p>
    public let destination: AnalyticsExportDestination?
    /// <p>The version of the output schema to use when exporting data. Must be
    ///          <code>V_1</code>.</p>
    public let outputSchemaVersion: StorageClassAnalysisSchemaVersion?

    public init (
        destination: AnalyticsExportDestination? = nil,
        outputSchemaVersion: StorageClassAnalysisSchemaVersion? = nil
    )
    {
        self.destination = destination
        self.outputSchemaVersion = outputSchemaVersion
    }
}

public enum StorageClassAnalysisSchemaVersion {
    case v1
    case sdkUnknown(String)
}

extension StorageClassAnalysisSchemaVersion : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StorageClassAnalysisSchemaVersion] {
        return [
            .v1,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .v1: return "V_1"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StorageClassAnalysisSchemaVersion(rawValue: rawValue) ?? StorageClassAnalysisSchemaVersion.sdkUnknown(rawValue)
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let key = key {
            try container.encode(key, forKey: Key("key"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

extension Tag: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container of a key value name pair.</p>
public struct Tag: Equatable {
    /// <p>Name of the object key.</p>
    public let key: String?
    /// <p>Value of the tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension Tagging: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tagSet = "TagSet"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let tagSet = tagSet {
            var tagSetContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("tagSet"))
            for tag0 in tagSet {
                try tagSetContainer.encode(tag0, forKey: Key("Tag"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tagSet) {
            struct KeyVal0{struct Tag{}}
            let tagSetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagSet)
            if let tagSetWrappedContainer = tagSetWrappedContainer {
                let tagSetContainer = try tagSetWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagSetBuffer:[Tag]? = nil
                if let tagSetContainer = tagSetContainer {
                    tagSetBuffer = [Tag]()
                    for structureContainer0 in tagSetContainer {
                        tagSetBuffer?.append(structureContainer0)
                    }
                }
                tagSet = tagSetBuffer
            } else {
                tagSet = []
            }
        } else {
            tagSet = nil
        }
    }
}

extension Tagging: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tagging(tagSet: \(String(describing: tagSet)))"}
}

extension Tagging: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container for <code>TagSet</code> elements.</p>
public struct Tagging: Equatable {
    /// <p>A collection for a set of tags</p>
    public let tagSet: [Tag]?

    public init (
        tagSet: [Tag]? = nil
    )
    {
        self.tagSet = tagSet
    }
}

public enum TaggingDirective {
    case copy
    case replace
    case sdkUnknown(String)
}

extension TaggingDirective : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TaggingDirective] {
        return [
            .copy,
            .replace,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .copy: return "COPY"
        case .replace: return "REPLACE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TaggingDirective(rawValue: rawValue) ?? TaggingDirective.sdkUnknown(rawValue)
    }
}

extension TargetGrant: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantee = "Grantee"
        case permission = "Permission"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let grantee = grantee {
            var granteeContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("grantee"))
            try granteeContainer.encode(grantee, forKey: Key(""))
            try granteeContainer.encode("http://www.w3.org/2001/XMLSchema-instance", forKey: Key("xmlns:xsi"))
        }
        if let permission = permission {
            try container.encode(permission, forKey: Key("permission"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let granteeDecoded = try containerValues.decodeIfPresent(Grantee.self, forKey: .grantee)
        grantee = granteeDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(BucketLogsPermission.self, forKey: .permission)
        permission = permissionDecoded
    }
}

extension TargetGrant: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TargetGrant(grantee: \(String(describing: grantee)), permission: \(String(describing: permission)))"}
}

extension TargetGrant: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns",
            "xmlns:xsi"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Container for granting information.</p>
public struct TargetGrant: Equatable {
    /// <p>Container for the person being granted permissions.</p>
    public let grantee: Grantee?
    /// <p>Logging permissions assigned to the grantee for the bucket.</p>
    public let permission: BucketLogsPermission?

    public init (
        grantee: Grantee? = nil,
        permission: BucketLogsPermission? = nil
    )
    {
        self.grantee = grantee
        self.permission = permission
    }
}

public enum Tier {
    case bulk
    case expedited
    case standard
    case sdkUnknown(String)
}

extension Tier : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Tier] {
        return [
            .bulk,
            .expedited,
            .standard,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bulk: return "Bulk"
        case .expedited: return "Expedited"
        case .standard: return "Standard"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Tier(rawValue: rawValue) ?? Tier.sdkUnknown(rawValue)
    }
}

extension Tiering: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessTier = "AccessTier"
        case days = "Days"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let accessTier = accessTier {
            try container.encode(accessTier, forKey: Key("accessTier"))
        }
        if days != 0 {
            try container.encode(days, forKey: Key("days"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let daysDecoded = try containerValues.decode(Int.self, forKey: .days)
        days = daysDecoded
        let accessTierDecoded = try containerValues.decodeIfPresent(IntelligentTieringAccessTier.self, forKey: .accessTier)
        accessTier = accessTierDecoded
    }
}

extension Tiering: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tiering(accessTier: \(String(describing: accessTier)), days: \(String(describing: days)))"}
}

extension Tiering: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The S3 Intelligent-Tiering storage class is designed to optimize storage costs by
///          automatically moving data to the most cost-effective storage access tier, without
///          additional operational overhead.</p>
public struct Tiering: Equatable {
    /// <p>S3 Intelligent-Tiering access tier. See <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html#sc-dynamic-data-access">Storage class for
    ///             automatically optimizing frequently and infrequently accessed objects</a> for a list
    ///          of access tiers in the S3 Intelligent-Tiering storage class.</p>
    public let accessTier: IntelligentTieringAccessTier?
    /// <p>The number of consecutive days of no access after which an object will be eligible to be
    ///          transitioned to the corresponding tier. The minimum number of days specified for
    ///          Archive Access tier must be at least 90 days and Deep Archive Access tier must be at least
    ///          180 days. The maximum can be up to 2 years (730 days).</p>
    public let days: Int

    public init (
        accessTier: IntelligentTieringAccessTier? = nil,
        days: Int = 0
    )
    {
        self.accessTier = accessTier
        self.days = days
    }
}

extension TopicConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case events = "Event"
        case filter = "Filter"
        case id = "Id"
        case topicArn = "Topic"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let events = events {
            if events.isEmpty {
                var eventsContainer = container.nestedUnkeyedContainer(forKey: Key("Event"))
                try eventsContainer.encodeNil()
            } else {
                for event0 in events {
                    var eventsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Event"))
                    try eventsContainer0.encode(event0, forKey: Key(""))
                }
            }
        }
        if let filter = filter {
            try container.encode(filter, forKey: Key("filter"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: Key("Topic"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let topicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        if containerValues.contains(.events) {
            let eventsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .events)
            if eventsWrappedContainer != nil {
                let eventsContainer = try containerValues.decodeIfPresent([Event].self, forKey: .events)
                var eventsBuffer:[Event]? = nil
                if let eventsContainer = eventsContainer {
                    eventsBuffer = [Event]()
                    for stringContainer0 in eventsContainer {
                        eventsBuffer?.append(stringContainer0)
                    }
                }
                events = eventsBuffer
            } else {
                events = []
            }
        } else {
            events = nil
        }
        let filterDecoded = try containerValues.decodeIfPresent(NotificationConfigurationFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension TopicConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TopicConfiguration(events: \(String(describing: events)), filter: \(String(describing: filter)), id: \(String(describing: id)), topicArn: \(String(describing: topicArn)))"}
}

extension TopicConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container for specifying the configuration for publication of messages to an Amazon
///          Simple Notification Service (Amazon SNS) topic when Amazon S3 detects specified events.</p>
public struct TopicConfiguration: Equatable {
    /// <p>The Amazon S3 bucket event about which to send notifications. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html">Supported
    ///             Event Types</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let events: [Event]?
    /// <p>Specifies object key name filtering rules. For information about key name filtering, see
    ///             <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html">Configuring
    ///             Event Notifications</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let filter: NotificationConfigurationFilter?
    /// <p>An optional unique identifier for configurations in a notification configuration. If you
    ///          don't provide one, Amazon S3 will assign an ID.</p>
    public let id: String?
    /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic to which Amazon S3 publishes a message
    ///          when it detects events of the specified type.</p>
    public let topicArn: String?

    public init (
        events: [Event]? = nil,
        filter: NotificationConfigurationFilter? = nil,
        id: String? = nil,
        topicArn: String? = nil
    )
    {
        self.events = events
        self.filter = filter
        self.id = id
        self.topicArn = topicArn
    }
}

extension Transition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case date = "Date"
        case days = "Days"
        case storageClass = "StorageClass"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let date = date {
            try container.encode(TimestampWrapper(date, format: .dateTime), forKey: Key("date"))
        }
        if days != 0 {
            try container.encode(days, forKey: Key("days"))
        }
        if let storageClass = storageClass {
            try container.encode(storageClass, forKey: Key("storageClass"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .date)
        var dateBuffer:Date? = nil
        if let dateDecoded = dateDecoded {
            dateBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateDecoded, format: .dateTime)
        }
        date = dateBuffer
        let daysDecoded = try containerValues.decode(Int.self, forKey: .days)
        days = daysDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(TransitionStorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

extension Transition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Transition(date: \(String(describing: date)), days: \(String(describing: days)), storageClass: \(String(describing: storageClass)))"}
}

extension Transition: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies when an object transitions to a specified storage class. For more information
///          about Amazon S3 lifecycle configuration rules, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/lifecycle-transition-general-considerations.html">Transitioning
///             Objects Using Amazon S3 Lifecycle</a> in the <i>Amazon S3 User Guide</i>.</p>
public struct Transition: Equatable {
    /// <p>Indicates when objects are transitioned to the specified storage class. The date value
    ///          must be in ISO 8601 format. The time is always midnight UTC.</p>
    public let date: Date?
    /// <p>Indicates the number of days after creation when objects are transitioned to the
    ///          specified storage class. The value must be a positive integer.</p>
    public let days: Int
    /// <p>The storage class to which you want the object to transition.</p>
    public let storageClass: TransitionStorageClass?

    public init (
        date: Date? = nil,
        days: Int = 0,
        storageClass: TransitionStorageClass? = nil
    )
    {
        self.date = date
        self.days = days
        self.storageClass = storageClass
    }
}

public enum TransitionStorageClass {
    case deepArchive
    case glacier
    case intelligentTiering
    case onezoneIa
    case standardIa
    case sdkUnknown(String)
}

extension TransitionStorageClass : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TransitionStorageClass] {
        return [
            .deepArchive,
            .glacier,
            .intelligentTiering,
            .onezoneIa,
            .standardIa,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deepArchive: return "DEEP_ARCHIVE"
        case .glacier: return "GLACIER"
        case .intelligentTiering: return "INTELLIGENT_TIERING"
        case .onezoneIa: return "ONEZONE_IA"
        case .standardIa: return "STANDARD_IA"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TransitionStorageClass(rawValue: rawValue) ?? TransitionStorageClass.sdkUnknown(rawValue)
    }
}

public enum `Type` {
    case amazoncustomerbyemail
    case canonicaluser
    case group
    case sdkUnknown(String)
}

extension `Type` : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [`Type`] {
        return [
            .amazoncustomerbyemail,
            .canonicaluser,
            .group,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .amazoncustomerbyemail: return "AmazonCustomerByEmail"
        case .canonicaluser: return "CanonicalUser"
        case .group: return "Group"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = `Type`(rawValue: rawValue) ?? `Type`.sdkUnknown(rawValue)
    }
}

extension UploadPartCopyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadPartCopyInput(bucket: \(String(describing: bucket)), copySource: \(String(describing: copySource)), copySourceIfMatch: \(String(describing: copySourceIfMatch)), copySourceIfModifiedSince: \(String(describing: copySourceIfModifiedSince)), copySourceIfNoneMatch: \(String(describing: copySourceIfNoneMatch)), copySourceIfUnmodifiedSince: \(String(describing: copySourceIfUnmodifiedSince)), copySourceRange: \(String(describing: copySourceRange)), copySourceSSECustomerAlgorithm: \(String(describing: copySourceSSECustomerAlgorithm)), copySourceSSECustomerKey: \(String(describing: copySourceSSECustomerKey)), copySourceSSECustomerKeyMD5: \(String(describing: copySourceSSECustomerKeyMD5)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), expectedSourceBucketOwner: \(String(describing: expectedSourceBucketOwner)), key: \(String(describing: key)), partNumber: \(String(describing: partNumber)), requestPayer: \(String(describing: requestPayer)), sSECustomerAlgorithm: \(String(describing: sSECustomerAlgorithm)), sSECustomerKey: \(String(describing: sSECustomerKey)), sSECustomerKeyMD5: \(String(describing: sSECustomerKeyMD5)), uploadId: \(String(describing: uploadId)))"}
}

extension UploadPartCopyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UploadPartCopyInputHeadersMiddleware: Middleware {
    public let id: String = "UploadPartCopyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadPartCopyInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadPartCopyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let copySource = input.operationInput.copySource {
            input.builder.withHeader(name: "x-amz-copy-source", value: String(copySource))
        }
        if let copySourceIfMatch = input.operationInput.copySourceIfMatch {
            input.builder.withHeader(name: "x-amz-copy-source-if-match", value: String(copySourceIfMatch))
        }
        if let copySourceIfModifiedSince = input.operationInput.copySourceIfModifiedSince {
            input.builder.withHeader(name: "x-amz-copy-source-if-modified-since", value: String(copySourceIfModifiedSince.rfc5322()))
        }
        if let copySourceIfNoneMatch = input.operationInput.copySourceIfNoneMatch {
            input.builder.withHeader(name: "x-amz-copy-source-if-none-match", value: String(copySourceIfNoneMatch))
        }
        if let copySourceIfUnmodifiedSince = input.operationInput.copySourceIfUnmodifiedSince {
            input.builder.withHeader(name: "x-amz-copy-source-if-unmodified-since", value: String(copySourceIfUnmodifiedSince.rfc5322()))
        }
        if let copySourceRange = input.operationInput.copySourceRange {
            input.builder.withHeader(name: "x-amz-copy-source-range", value: String(copySourceRange))
        }
        if let copySourceSSECustomerAlgorithm = input.operationInput.copySourceSSECustomerAlgorithm {
            input.builder.withHeader(name: "x-amz-copy-source-server-side-encryption-customer-algorithm", value: String(copySourceSSECustomerAlgorithm))
        }
        if let copySourceSSECustomerKey = input.operationInput.copySourceSSECustomerKey {
            input.builder.withHeader(name: "x-amz-copy-source-server-side-encryption-customer-key", value: String(copySourceSSECustomerKey))
        }
        if let copySourceSSECustomerKeyMD5 = input.operationInput.copySourceSSECustomerKeyMD5 {
            input.builder.withHeader(name: "x-amz-copy-source-server-side-encryption-customer-key-MD5", value: String(copySourceSSECustomerKeyMD5))
        }
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let expectedSourceBucketOwner = input.operationInput.expectedSourceBucketOwner {
            input.builder.withHeader(name: "x-amz-source-expected-bucket-owner", value: String(expectedSourceBucketOwner))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        if let sSECustomerAlgorithm = input.operationInput.sSECustomerAlgorithm {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-algorithm", value: String(sSECustomerAlgorithm))
        }
        if let sSECustomerKey = input.operationInput.sSECustomerKey {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-key", value: String(sSECustomerKey))
        }
        if let sSECustomerKeyMD5 = input.operationInput.sSECustomerKeyMD5 {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-key-MD5", value: String(sSECustomerKeyMD5))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadPartCopyInput>
    public typealias MOutput = OperationOutput<UploadPartCopyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadPartCopyOutputError>
}

public struct UploadPartCopyInputQueryItemMiddleware: Middleware {
    public let id: String = "UploadPartCopyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadPartCopyInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadPartCopyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "x-id", value: "UploadPartCopy"))
        let partNumberQueryItem = URLQueryItem(name: "partNumber".urlPercentEncoding(), value: String(input.operationInput.partNumber).urlPercentEncoding())
        input.builder.withQueryItem(partNumberQueryItem)
        if let uploadId = input.operationInput.uploadId {
            let uploadIdQueryItem = URLQueryItem(name: "uploadId".urlPercentEncoding(), value: String(uploadId).urlPercentEncoding())
            input.builder.withQueryItem(uploadIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadPartCopyInput>
    public typealias MOutput = OperationOutput<UploadPartCopyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadPartCopyOutputError>
}

public struct UploadPartCopyInput: Equatable {
    /// <p>The bucket name.</p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>Specifies the source object for the copy operation. You specify the value in one of two
    ///          formats, depending on whether you want to access the source object through an <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points.html">access point</a>:</p>
    ///          <ul>
    ///             <li>
    ///                <p>For objects not accessed through an access point, specify the name of the source
    ///                bucket and key of the source object, separated by a slash (/). For example, to copy
    ///                the object <code>reports/january.pdf</code> from the bucket
    ///                   <code>awsexamplebucket</code>, use
    ///                   <code>awsexamplebucket/reports/january.pdf</code>. The value must be URL
    ///                encoded.</p>
    ///             </li>
    ///             <li>
    ///                <p>For objects accessed through access points, specify the Amazon Resource Name (ARN) of the object as accessed through the access point, in the format <code>arn:aws:s3:<Region>:<account-id>:accesspoint/<access-point-name>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through access point <code>my-access-point</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3:us-west-2:123456789012:accesspoint/my-access-point/object/reports/january.pdf</code>. The value must be URL encoded.</p>
    ///                <note>
    ///                   <p>Amazon S3 supports copy operations using access points only when the source and destination buckets are in the same AWS Region.</p>
    ///                </note>
    ///                <p>Alternatively, for objects accessed through Amazon S3 on Outposts, specify the ARN of the object as accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/object/reports/january.pdf</code>. The value must be URL encoded.  </p>
    ///             </li>
    ///          </ul>
    ///          <p>To copy a specific version of an object, append <code>?versionId=<version-id></code>
    ///          to the value (for example,
    ///             <code>awsexamplebucket/reports/january.pdf?versionId=QUpfdndhfd8438MNFDN93jdnJFkdmqnh893</code>).
    ///          If you don't specify a version ID, Amazon S3 copies the latest version of the source
    ///          object.</p>
    public let copySource: String?
    /// <p>Copies the object if its entity tag (ETag) matches the specified tag.</p>
    public let copySourceIfMatch: String?
    /// <p>Copies the object if it has been modified since the specified time.</p>
    public let copySourceIfModifiedSince: Date?
    /// <p>Copies the object if its entity tag (ETag) is different than the specified ETag.</p>
    public let copySourceIfNoneMatch: String?
    /// <p>Copies the object if it hasn't been modified since the specified time.</p>
    public let copySourceIfUnmodifiedSince: Date?
    /// <p>The range of bytes to copy from the source object. The range value must use the form
    ///          bytes=first-last, where the first and last are the zero-based byte offsets to copy. For
    ///          example, bytes=0-9 indicates that you want to copy the first 10 bytes of the source. You
    ///          can copy a range only if the source object is greater than 5 MB.</p>
    public let copySourceRange: String?
    /// <p>Specifies the algorithm to use when decrypting the source object (for example,
    ///          AES256).</p>
    public let copySourceSSECustomerAlgorithm: String?
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use to decrypt the source
    ///          object. The encryption key provided in this header must be one that was used when the
    ///          source object was created.</p>
    public let copySourceSSECustomerKey: String?
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    ///          this header for a message integrity check to ensure that the encryption key was transmitted
    ///          without error.</p>
    public let copySourceSSECustomerKeyMD5: String?
    /// <p>The account ID of the expected destination bucket owner. If the destination bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The account ID of the expected source bucket owner. If the source bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedSourceBucketOwner: String?
    /// <p>Object key for which the multipart upload was initiated.</p>
    public let key: String?
    /// <p>Part number of part being copied. This is a positive integer between 1 and
    ///          10,000.</p>
    public let partNumber: Int
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    ///          owners need not specify this parameter in their requests. For information about downloading
    ///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    ///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let requestPayer: RequestPayer?
    /// <p>Specifies the algorithm to use to when encrypting the object (for example,
    ///          AES256).</p>
    public let sSECustomerAlgorithm: String?
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
    ///          value is used to store the object and then it is discarded; Amazon S3 does not store the
    ///          encryption key. The key must be appropriate for use with the algorithm specified in the
    ///             <code>x-amz-server-side-encryption-customer-algorithm</code> header. This must be the
    ///          same encryption key specified in the initiate multipart upload request.</p>
    public let sSECustomerKey: String?
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    ///          this header for a message integrity check to ensure that the encryption key was transmitted
    ///          without error.</p>
    public let sSECustomerKeyMD5: String?
    /// <p>Upload ID identifying the multipart upload whose part is being copied.</p>
    public let uploadId: String?

    public init (
        bucket: String? = nil,
        copySource: String? = nil,
        copySourceIfMatch: String? = nil,
        copySourceIfModifiedSince: Date? = nil,
        copySourceIfNoneMatch: String? = nil,
        copySourceIfUnmodifiedSince: Date? = nil,
        copySourceRange: String? = nil,
        copySourceSSECustomerAlgorithm: String? = nil,
        copySourceSSECustomerKey: String? = nil,
        copySourceSSECustomerKeyMD5: String? = nil,
        expectedBucketOwner: String? = nil,
        expectedSourceBucketOwner: String? = nil,
        key: String? = nil,
        partNumber: Int = 0,
        requestPayer: RequestPayer? = nil,
        sSECustomerAlgorithm: String? = nil,
        sSECustomerKey: String? = nil,
        sSECustomerKeyMD5: String? = nil,
        uploadId: String? = nil
    )
    {
        self.bucket = bucket
        self.copySource = copySource
        self.copySourceIfMatch = copySourceIfMatch
        self.copySourceIfModifiedSince = copySourceIfModifiedSince
        self.copySourceIfNoneMatch = copySourceIfNoneMatch
        self.copySourceIfUnmodifiedSince = copySourceIfUnmodifiedSince
        self.copySourceRange = copySourceRange
        self.copySourceSSECustomerAlgorithm = copySourceSSECustomerAlgorithm
        self.copySourceSSECustomerKey = copySourceSSECustomerKey
        self.copySourceSSECustomerKeyMD5 = copySourceSSECustomerKeyMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.expectedSourceBucketOwner = expectedSourceBucketOwner
        self.key = key
        self.partNumber = partNumber
        self.requestPayer = requestPayer
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKey = sSECustomerKey
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.uploadId = uploadId
    }
}

struct UploadPartCopyInputBody: Equatable {
}

extension UploadPartCopyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UploadPartCopyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UploadPartCopyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UploadPartCopyOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UploadPartCopyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadPartCopyOutputResponse(bucketKeyEnabled: \(String(describing: bucketKeyEnabled)), copyPartResult: \(String(describing: copyPartResult)), copySourceVersionId: \(String(describing: copySourceVersionId)), requestCharged: \(String(describing: requestCharged)), sSECustomerAlgorithm: \(String(describing: sSECustomerAlgorithm)), sSECustomerKeyMD5: \(String(describing: sSECustomerKeyMD5)), sSEKMSKeyId: \(String(describing: sSEKMSKeyId)), serverSideEncryption: \(String(describing: serverSideEncryption)))"}
}

extension UploadPartCopyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let bucketKeyEnabledHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-bucket-key-enabled") {
            self.bucketKeyEnabled = Bool(bucketKeyEnabledHeaderValue) ?? false
        } else {
            self.bucketKeyEnabled = false
        }
        if let copySourceVersionIdHeaderValue = httpResponse.headers.value(for: "x-amz-copy-source-version-id") {
            self.copySourceVersionId = copySourceVersionIdHeaderValue
        } else {
            self.copySourceVersionId = nil
        }
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if let sSECustomerAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-algorithm") {
            self.sSECustomerAlgorithm = sSECustomerAlgorithmHeaderValue
        } else {
            self.sSECustomerAlgorithm = nil
        }
        if let sSECustomerKeyMD5HeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-key-MD5") {
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5HeaderValue
        } else {
            self.sSECustomerKeyMD5 = nil
        }
        if let sSEKMSKeyIdHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-aws-kms-key-id") {
            self.sSEKMSKeyId = sSEKMSKeyIdHeaderValue
        } else {
            self.sSEKMSKeyId = nil
        }
        if let serverSideEncryptionHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption") {
            self.serverSideEncryption = ServerSideEncryption(rawValue: serverSideEncryptionHeaderValue)
        } else {
            self.serverSideEncryption = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CopyPartResult = try responseDecoder.decode(responseBody: unwrappedData)
                self.copyPartResult = output
            } else {
                self.copyPartResult = nil
            }
        } else {
            self.copyPartResult = nil
        }
    }
}

public struct UploadPartCopyOutputResponse: Equatable {
    /// <p>Indicates whether the multipart upload uses an S3 Bucket Key for server-side encryption with AWS KMS (SSE-KMS).</p>
    public let bucketKeyEnabled: Bool
    /// <p>Container for all response elements.</p>
    public let copyPartResult: CopyPartResult?
    /// <p>The version of the source object that was copied, if you have enabled versioning on the
    ///          source bucket.</p>
    public let copySourceVersionId: String?
    /// <p>If present, indicates that the requester was successfully charged for the
    ///          request.</p>
    public let requestCharged: RequestCharged?
    /// <p>If server-side encryption with a customer-provided encryption key was requested, the
    ///          response will include this header confirming the encryption algorithm used.</p>
    public let sSECustomerAlgorithm: String?
    /// <p>If server-side encryption with a customer-provided encryption key was requested, the
    ///          response will include this header to provide round-trip message integrity verification of
    ///          the customer-provided encryption key.</p>
    public let sSECustomerKeyMD5: String?
    /// <p>If present, specifies the ID of the AWS Key Management Service (AWS KMS) symmetric
    ///          customer managed customer master key (CMK) that was used for the object.</p>
    public let sSEKMSKeyId: String?
    /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
    ///          AES256, aws:kms).</p>
    public let serverSideEncryption: ServerSideEncryption?

    public init (
        bucketKeyEnabled: Bool = false,
        copyPartResult: CopyPartResult? = nil,
        copySourceVersionId: String? = nil,
        requestCharged: RequestCharged? = nil,
        sSECustomerAlgorithm: String? = nil,
        sSECustomerKeyMD5: String? = nil,
        sSEKMSKeyId: String? = nil,
        serverSideEncryption: ServerSideEncryption? = nil
    )
    {
        self.bucketKeyEnabled = bucketKeyEnabled
        self.copyPartResult = copyPartResult
        self.copySourceVersionId = copySourceVersionId
        self.requestCharged = requestCharged
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
    }
}

struct UploadPartCopyOutputResponseBody: Equatable {
    public let copyPartResult: CopyPartResult?
}

extension UploadPartCopyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case copyPartResult = "CopyPartResult"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyPartResultDecoded = try containerValues.decodeIfPresent(CopyPartResult.self, forKey: .copyPartResult)
        copyPartResult = copyPartResultDecoded
    }
}

public struct UploadPartInputBodyMiddleware: Middleware {
    public let id: String = "UploadPartInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadPartInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let body = input.operationInput.body {
            let data = body
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadPartInput>
    public typealias MOutput = OperationOutput<UploadPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadPartOutputError>
}

extension UploadPartInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadPartInput(body: \(String(describing: body)), bucket: \(String(describing: bucket)), contentLength: \(String(describing: contentLength)), contentMD5: \(String(describing: contentMD5)), expectedBucketOwner: \(String(describing: expectedBucketOwner)), key: \(String(describing: key)), partNumber: \(String(describing: partNumber)), requestPayer: \(String(describing: requestPayer)), sSECustomerAlgorithm: \(String(describing: sSECustomerAlgorithm)), sSECustomerKey: \(String(describing: sSECustomerKey)), sSECustomerKeyMD5: \(String(describing: sSECustomerKeyMD5)), uploadId: \(String(describing: uploadId)))"}
}

extension UploadPartInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UploadPartInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let body = body {
            try container.encode(body, forKey: Key("body"))
        }
    }
}

public struct UploadPartInputHeadersMiddleware: Middleware {
    public let id: String = "UploadPartInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadPartInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withHeader(name: "Content-Length", value: String(input.operationInput.contentLength))
        if let contentMD5 = input.operationInput.contentMD5 {
            input.builder.withHeader(name: "Content-MD5", value: String(contentMD5))
        }
        if let expectedBucketOwner = input.operationInput.expectedBucketOwner {
            input.builder.withHeader(name: "x-amz-expected-bucket-owner", value: String(expectedBucketOwner))
        }
        if let requestPayer = input.operationInput.requestPayer {
            input.builder.withHeader(name: "x-amz-request-payer", value: String(requestPayer.rawValue))
        }
        if let sSECustomerAlgorithm = input.operationInput.sSECustomerAlgorithm {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-algorithm", value: String(sSECustomerAlgorithm))
        }
        if let sSECustomerKey = input.operationInput.sSECustomerKey {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-key", value: String(sSECustomerKey))
        }
        if let sSECustomerKeyMD5 = input.operationInput.sSECustomerKeyMD5 {
            input.builder.withHeader(name: "x-amz-server-side-encryption-customer-key-MD5", value: String(sSECustomerKeyMD5))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadPartInput>
    public typealias MOutput = OperationOutput<UploadPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadPartOutputError>
}

public struct UploadPartInputQueryItemMiddleware: Middleware {
    public let id: String = "UploadPartInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadPartInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "x-id", value: "UploadPart"))
        let partNumberQueryItem = URLQueryItem(name: "partNumber".urlPercentEncoding(), value: String(input.operationInput.partNumber).urlPercentEncoding())
        input.builder.withQueryItem(partNumberQueryItem)
        if let uploadId = input.operationInput.uploadId {
            let uploadIdQueryItem = URLQueryItem(name: "uploadId".urlPercentEncoding(), value: String(uploadId).urlPercentEncoding())
            input.builder.withQueryItem(uploadIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadPartInput>
    public typealias MOutput = OperationOutput<UploadPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadPartOutputError>
}

public struct UploadPartInput: Equatable {
    /// <p>Object data.</p>
    public let body: Data?
    /// <p>The name of the bucket to which the multipart upload was initiated.</p>
    ///          <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let bucket: String?
    /// <p>Size of the body in bytes. This parameter is useful when the size of the body cannot be
    ///          determined automatically.</p>
    public let contentLength: Int
    /// <p>The base64-encoded 128-bit MD5 digest of the part data. This parameter is auto-populated
    ///          when using the command from the CLI. This parameter is required if object lock parameters
    ///          are specified.</p>
    public let contentMD5: String?
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>Object key for which the multipart upload was initiated.</p>
    public let key: String?
    /// <p>Part number of part being uploaded. This is a positive integer between 1 and
    ///          10,000.</p>
    public let partNumber: Int
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    ///          owners need not specify this parameter in their requests. For information about downloading
    ///          objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    ///             Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let requestPayer: RequestPayer?
    /// <p>Specifies the algorithm to use to when encrypting the object (for example,
    ///          AES256).</p>
    public let sSECustomerAlgorithm: String?
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
    ///          value is used to store the object and then it is discarded; Amazon S3 does not store the
    ///          encryption key. The key must be appropriate for use with the algorithm specified in the
    ///             <code>x-amz-server-side-encryption-customer-algorithm header</code>. This must be the
    ///          same encryption key specified in the initiate multipart upload request.</p>
    public let sSECustomerKey: String?
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    ///          this header for a message integrity check to ensure that the encryption key was transmitted
    ///          without error.</p>
    public let sSECustomerKeyMD5: String?
    /// <p>Upload ID identifying the multipart upload whose part is being uploaded.</p>
    public let uploadId: String?

    public init (
        body: Data? = nil,
        bucket: String? = nil,
        contentLength: Int = 0,
        contentMD5: String? = nil,
        expectedBucketOwner: String? = nil,
        key: String? = nil,
        partNumber: Int = 0,
        requestPayer: RequestPayer? = nil,
        sSECustomerAlgorithm: String? = nil,
        sSECustomerKey: String? = nil,
        sSECustomerKeyMD5: String? = nil,
        uploadId: String? = nil
    )
    {
        self.body = body
        self.bucket = bucket
        self.contentLength = contentLength
        self.contentMD5 = contentMD5
        self.expectedBucketOwner = expectedBucketOwner
        self.key = key
        self.partNumber = partNumber
        self.requestPayer = requestPayer
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKey = sSECustomerKey
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.uploadId = uploadId
    }
}

struct UploadPartInputBody: Equatable {
    public let body: Data?
}

extension UploadPartInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.body) {
            do {
                let bodyDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .body)
                body = bodyDecoded
            } catch {
                body = "".data(using: .utf8)
            }
        } else {
            body = nil
        }
    }
}

extension UploadPartOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UploadPartOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UploadPartOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UploadPartOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadPartOutputResponse(bucketKeyEnabled: \(String(describing: bucketKeyEnabled)), eTag: \(String(describing: eTag)), requestCharged: \(String(describing: requestCharged)), sSECustomerAlgorithm: \(String(describing: sSECustomerAlgorithm)), sSECustomerKeyMD5: \(String(describing: sSECustomerKeyMD5)), sSEKMSKeyId: \(String(describing: sSEKMSKeyId)), serverSideEncryption: \(String(describing: serverSideEncryption)))"}
}

extension UploadPartOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let bucketKeyEnabledHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-bucket-key-enabled") {
            self.bucketKeyEnabled = Bool(bucketKeyEnabledHeaderValue) ?? false
        } else {
            self.bucketKeyEnabled = false
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let requestChargedHeaderValue = httpResponse.headers.value(for: "x-amz-request-charged") {
            self.requestCharged = RequestCharged(rawValue: requestChargedHeaderValue)
        } else {
            self.requestCharged = nil
        }
        if let sSECustomerAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-algorithm") {
            self.sSECustomerAlgorithm = sSECustomerAlgorithmHeaderValue
        } else {
            self.sSECustomerAlgorithm = nil
        }
        if let sSECustomerKeyMD5HeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-customer-key-MD5") {
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5HeaderValue
        } else {
            self.sSECustomerKeyMD5 = nil
        }
        if let sSEKMSKeyIdHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption-aws-kms-key-id") {
            self.sSEKMSKeyId = sSEKMSKeyIdHeaderValue
        } else {
            self.sSEKMSKeyId = nil
        }
        if let serverSideEncryptionHeaderValue = httpResponse.headers.value(for: "x-amz-server-side-encryption") {
            self.serverSideEncryption = ServerSideEncryption(rawValue: serverSideEncryptionHeaderValue)
        } else {
            self.serverSideEncryption = nil
        }
    }
}

public struct UploadPartOutputResponse: Equatable {
    /// <p>Indicates whether the multipart upload uses an S3 Bucket Key for server-side encryption with AWS KMS (SSE-KMS).</p>
    public let bucketKeyEnabled: Bool
    /// <p>Entity tag for the uploaded object.</p>
    public let eTag: String?
    /// <p>If present, indicates that the requester was successfully charged for the
    ///          request.</p>
    public let requestCharged: RequestCharged?
    /// <p>If server-side encryption with a customer-provided encryption key was requested, the
    ///          response will include this header confirming the encryption algorithm used.</p>
    public let sSECustomerAlgorithm: String?
    /// <p>If server-side encryption with a customer-provided encryption key was requested, the
    ///          response will include this header to provide round-trip message integrity verification of
    ///          the customer-provided encryption key.</p>
    public let sSECustomerKeyMD5: String?
    /// <p>If present, specifies the ID of the AWS Key Management Service (AWS KMS) symmetric
    ///          customer managed customer master key (CMK) was used for the object.</p>
    public let sSEKMSKeyId: String?
    /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
    ///          AES256, aws:kms).</p>
    public let serverSideEncryption: ServerSideEncryption?

    public init (
        bucketKeyEnabled: Bool = false,
        eTag: String? = nil,
        requestCharged: RequestCharged? = nil,
        sSECustomerAlgorithm: String? = nil,
        sSECustomerKeyMD5: String? = nil,
        sSEKMSKeyId: String? = nil,
        serverSideEncryption: ServerSideEncryption? = nil
    )
    {
        self.bucketKeyEnabled = bucketKeyEnabled
        self.eTag = eTag
        self.requestCharged = requestCharged
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
    }
}

struct UploadPartOutputResponseBody: Equatable {
}

extension UploadPartOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension VersioningConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mFADelete = "MfaDelete"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let mFADelete = mFADelete {
            try container.encode(mFADelete, forKey: Key("MfaDelete"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mFADeleteDecoded = try containerValues.decodeIfPresent(MFADelete.self, forKey: .mFADelete)
        mFADelete = mFADeleteDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BucketVersioningStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension VersioningConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VersioningConfiguration(mFADelete: \(String(describing: mFADelete)), status: \(String(describing: status)))"}
}

extension VersioningConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Describes the versioning state of an Amazon S3 bucket. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTVersioningStatus.html">PUT
///             Bucket versioning</a> in the <i>Amazon S3 API Reference</i>.</p>
public struct VersioningConfiguration: Equatable {
    /// <p>Specifies whether MFA delete is enabled in the bucket versioning configuration. This
    ///          element is only returned if the bucket has been configured with MFA delete. If the bucket
    ///          has never been so configured, this element is not returned.</p>
    public let mFADelete: MFADelete?
    /// <p>The versioning state of the bucket.</p>
    public let status: BucketVersioningStatus?

    public init (
        mFADelete: MFADelete? = nil,
        status: BucketVersioningStatus? = nil
    )
    {
        self.mFADelete = mFADelete
        self.status = status
    }
}

extension WebsiteConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorDocument = "ErrorDocument"
        case indexDocument = "IndexDocument"
        case redirectAllRequestsTo = "RedirectAllRequestsTo"
        case routingRules = "RoutingRules"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let errorDocument = errorDocument {
            try container.encode(errorDocument, forKey: Key("errorDocument"))
        }
        if let indexDocument = indexDocument {
            try container.encode(indexDocument, forKey: Key("indexDocument"))
        }
        if let redirectAllRequestsTo = redirectAllRequestsTo {
            try container.encode(redirectAllRequestsTo, forKey: Key("redirectAllRequestsTo"))
        }
        if let routingRules = routingRules {
            var routingRulesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("routingRules"))
            for routingrule0 in routingRules {
                try routingRulesContainer.encode(routingrule0, forKey: Key("RoutingRule"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDocumentDecoded = try containerValues.decodeIfPresent(ErrorDocument.self, forKey: .errorDocument)
        errorDocument = errorDocumentDecoded
        let indexDocumentDecoded = try containerValues.decodeIfPresent(IndexDocument.self, forKey: .indexDocument)
        indexDocument = indexDocumentDecoded
        let redirectAllRequestsToDecoded = try containerValues.decodeIfPresent(RedirectAllRequestsTo.self, forKey: .redirectAllRequestsTo)
        redirectAllRequestsTo = redirectAllRequestsToDecoded
        if containerValues.contains(.routingRules) {
            struct KeyVal0{struct RoutingRule{}}
            let routingRulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.RoutingRule>.CodingKeys.self, forKey: .routingRules)
            if let routingRulesWrappedContainer = routingRulesWrappedContainer {
                let routingRulesContainer = try routingRulesWrappedContainer.decodeIfPresent([RoutingRule].self, forKey: .member)
                var routingRulesBuffer:[RoutingRule]? = nil
                if let routingRulesContainer = routingRulesContainer {
                    routingRulesBuffer = [RoutingRule]()
                    for structureContainer0 in routingRulesContainer {
                        routingRulesBuffer?.append(structureContainer0)
                    }
                }
                routingRules = routingRulesBuffer
            } else {
                routingRules = []
            }
        } else {
            routingRules = nil
        }
    }
}

extension WebsiteConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WebsiteConfiguration(errorDocument: \(String(describing: errorDocument)), indexDocument: \(String(describing: indexDocument)), redirectAllRequestsTo: \(String(describing: redirectAllRequestsTo)), routingRules: \(String(describing: routingRules)))"}
}

extension WebsiteConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies website configuration parameters for an Amazon S3 bucket.</p>
public struct WebsiteConfiguration: Equatable {
    /// <p>The name of the error document for the website.</p>
    public let errorDocument: ErrorDocument?
    /// <p>The name of the index document for the website.</p>
    public let indexDocument: IndexDocument?
    /// <p>The redirect behavior for every request to this bucket's website endpoint.</p>
    ///          <important>
    ///             <p>If you specify this property, you can't specify any other property.</p>
    ///          </important>
    public let redirectAllRequestsTo: RedirectAllRequestsTo?
    /// <p>Rules that define when a redirect is applied and the redirect behavior.</p>
    public let routingRules: [RoutingRule]?

    public init (
        errorDocument: ErrorDocument? = nil,
        indexDocument: IndexDocument? = nil,
        redirectAllRequestsTo: RedirectAllRequestsTo? = nil,
        routingRules: [RoutingRule]? = nil
    )
    {
        self.errorDocument = errorDocument
        self.indexDocument = indexDocument
        self.redirectAllRequestsTo = redirectAllRequestsTo
        self.routingRules = routingRules
    }
}

public struct WriteGetObjectResponseInputBodyMiddleware: Middleware {
    public let id: String = "WriteGetObjectResponseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<WriteGetObjectResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<WriteGetObjectResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let body = input.operationInput.body {
            let data = body
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<WriteGetObjectResponseInput>
    public typealias MOutput = OperationOutput<WriteGetObjectResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<WriteGetObjectResponseOutputError>
}

extension WriteGetObjectResponseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WriteGetObjectResponseInput(acceptRanges: \(String(describing: acceptRanges)), body: \(String(describing: body)), bucketKeyEnabled: \(String(describing: bucketKeyEnabled)), cacheControl: \(String(describing: cacheControl)), contentDisposition: \(String(describing: contentDisposition)), contentEncoding: \(String(describing: contentEncoding)), contentLanguage: \(String(describing: contentLanguage)), contentLength: \(String(describing: contentLength)), contentRange: \(String(describing: contentRange)), contentType: \(String(describing: contentType)), deleteMarker: \(String(describing: deleteMarker)), eTag: \(String(describing: eTag)), errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), expiration: \(String(describing: expiration)), expires: \(String(describing: expires)), lastModified: \(String(describing: lastModified)), metadata: \(String(describing: metadata)), missingMeta: \(String(describing: missingMeta)), objectLockLegalHoldStatus: \(String(describing: objectLockLegalHoldStatus)), objectLockMode: \(String(describing: objectLockMode)), objectLockRetainUntilDate: \(String(describing: objectLockRetainUntilDate)), partsCount: \(String(describing: partsCount)), replicationStatus: \(String(describing: replicationStatus)), requestCharged: \(String(describing: requestCharged)), requestRoute: \(String(describing: requestRoute)), requestToken: \(String(describing: requestToken)), restore: \(String(describing: restore)), sSECustomerAlgorithm: \(String(describing: sSECustomerAlgorithm)), sSECustomerKeyMD5: \(String(describing: sSECustomerKeyMD5)), sSEKMSKeyId: \(String(describing: sSEKMSKeyId)), serverSideEncryption: \(String(describing: serverSideEncryption)), statusCode: \(String(describing: statusCode)), storageClass: \(String(describing: storageClass)), tagCount: \(String(describing: tagCount)), versionId: \(String(describing: versionId)))"}
}

extension WriteGetObjectResponseInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension WriteGetObjectResponseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let body = body {
            try container.encode(body, forKey: Key("body"))
        }
    }
}

public struct WriteGetObjectResponseInputHeadersMiddleware: Middleware {
    public let id: String = "WriteGetObjectResponseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<WriteGetObjectResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<WriteGetObjectResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let acceptRanges = input.operationInput.acceptRanges {
            input.builder.withHeader(name: "x-amz-fwd-header-accept-ranges", value: String(acceptRanges))
        }
        input.builder.withHeader(name: "x-amz-fwd-header-x-amz-server-side-encryption-bucket-key-enabled", value: String(input.operationInput.bucketKeyEnabled))
        if let cacheControl = input.operationInput.cacheControl {
            input.builder.withHeader(name: "x-amz-fwd-header-Cache-Control", value: String(cacheControl))
        }
        if let contentDisposition = input.operationInput.contentDisposition {
            input.builder.withHeader(name: "x-amz-fwd-header-Content-Disposition", value: String(contentDisposition))
        }
        if let contentEncoding = input.operationInput.contentEncoding {
            input.builder.withHeader(name: "x-amz-fwd-header-Content-Encoding", value: String(contentEncoding))
        }
        if let contentLanguage = input.operationInput.contentLanguage {
            input.builder.withHeader(name: "x-amz-fwd-header-Content-Language", value: String(contentLanguage))
        }
        input.builder.withHeader(name: "Content-Length", value: String(input.operationInput.contentLength))
        if let contentRange = input.operationInput.contentRange {
            input.builder.withHeader(name: "x-amz-fwd-header-Content-Range", value: String(contentRange))
        }
        if let contentType = input.operationInput.contentType {
            input.builder.withHeader(name: "x-amz-fwd-header-Content-Type", value: String(contentType))
        }
        input.builder.withHeader(name: "x-amz-fwd-header-x-amz-delete-marker", value: String(input.operationInput.deleteMarker))
        if let eTag = input.operationInput.eTag {
            input.builder.withHeader(name: "x-amz-fwd-header-ETag", value: String(eTag))
        }
        if let errorCode = input.operationInput.errorCode {
            input.builder.withHeader(name: "x-amz-fwd-error-code", value: String(errorCode))
        }
        if let errorMessage = input.operationInput.errorMessage {
            input.builder.withHeader(name: "x-amz-fwd-error-message", value: String(errorMessage))
        }
        if let expiration = input.operationInput.expiration {
            input.builder.withHeader(name: "x-amz-fwd-header-x-amz-expiration", value: String(expiration))
        }
        if let expires = input.operationInput.expires {
            input.builder.withHeader(name: "x-amz-fwd-header-Expires", value: String(expires.rfc5322()))
        }
        if let lastModified = input.operationInput.lastModified {
            input.builder.withHeader(name: "x-amz-fwd-header-Last-Modified", value: String(lastModified.rfc5322()))
        }
        input.builder.withHeader(name: "x-amz-fwd-header-x-amz-missing-meta", value: String(input.operationInput.missingMeta))
        if let objectLockLegalHoldStatus = input.operationInput.objectLockLegalHoldStatus {
            input.builder.withHeader(name: "x-amz-fwd-header-x-amz-object-lock-legal-hold", value: String(objectLockLegalHoldStatus.rawValue))
        }
        if let objectLockMode = input.operationInput.objectLockMode {
            input.builder.withHeader(name: "x-amz-fwd-header-x-amz-object-lock-mode", value: String(objectLockMode.rawValue))
        }
        if let objectLockRetainUntilDate = input.operationInput.objectLockRetainUntilDate {
            input.builder.withHeader(name: "x-amz-fwd-header-x-amz-object-lock-retain-until-date", value: String(objectLockRetainUntilDate.iso8601WithoutFractionalSeconds()))
        }
        input.builder.withHeader(name: "x-amz-fwd-header-x-amz-mp-parts-count", value: String(input.operationInput.partsCount))
        if let replicationStatus = input.operationInput.replicationStatus {
            input.builder.withHeader(name: "x-amz-fwd-header-x-amz-replication-status", value: String(replicationStatus.rawValue))
        }
        if let requestCharged = input.operationInput.requestCharged {
            input.builder.withHeader(name: "x-amz-fwd-header-x-amz-request-charged", value: String(requestCharged.rawValue))
        }
        if let requestRoute = input.operationInput.requestRoute {
            input.builder.withHeader(name: "x-amz-request-route", value: String(requestRoute))
        }
        if let requestToken = input.operationInput.requestToken {
            input.builder.withHeader(name: "x-amz-request-token", value: String(requestToken))
        }
        if let restore = input.operationInput.restore {
            input.builder.withHeader(name: "x-amz-fwd-header-x-amz-restore", value: String(restore))
        }
        if let sSECustomerAlgorithm = input.operationInput.sSECustomerAlgorithm {
            input.builder.withHeader(name: "x-amz-fwd-header-x-amz-server-side-encryption-customer-algorithm", value: String(sSECustomerAlgorithm))
        }
        if let sSECustomerKeyMD5 = input.operationInput.sSECustomerKeyMD5 {
            input.builder.withHeader(name: "x-amz-fwd-header-x-amz-server-side-encryption-customer-key-MD5", value: String(sSECustomerKeyMD5))
        }
        if let sSEKMSKeyId = input.operationInput.sSEKMSKeyId {
            input.builder.withHeader(name: "x-amz-fwd-header-x-amz-server-side-encryption-aws-kms-key-id", value: String(sSEKMSKeyId))
        }
        if let serverSideEncryption = input.operationInput.serverSideEncryption {
            input.builder.withHeader(name: "x-amz-fwd-header-x-amz-server-side-encryption", value: String(serverSideEncryption.rawValue))
        }
        input.builder.withHeader(name: "x-amz-fwd-status", value: String(input.operationInput.statusCode))
        if let storageClass = input.operationInput.storageClass {
            input.builder.withHeader(name: "x-amz-fwd-header-x-amz-storage-class", value: String(storageClass.rawValue))
        }
        input.builder.withHeader(name: "x-amz-fwd-header-x-amz-tagging-count", value: String(input.operationInput.tagCount))
        if let versionId = input.operationInput.versionId {
            input.builder.withHeader(name: "x-amz-fwd-header-x-amz-version-id", value: String(versionId))
        }
        if let metadata = input.operationInput.metadata {
            for (prefixHeaderMapKey, prefixHeaderMapValue) in metadata {
                input.builder.withHeader(name: "x-amz-meta-\(prefixHeaderMapKey)", value: String(prefixHeaderMapValue))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<WriteGetObjectResponseInput>
    public typealias MOutput = OperationOutput<WriteGetObjectResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<WriteGetObjectResponseOutputError>
}

public struct WriteGetObjectResponseInputQueryItemMiddleware: Middleware {
    public let id: String = "WriteGetObjectResponseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<WriteGetObjectResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<WriteGetObjectResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "x-id", value: "WriteGetObjectResponse"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<WriteGetObjectResponseInput>
    public typealias MOutput = OperationOutput<WriteGetObjectResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<WriteGetObjectResponseOutputError>
}

public struct WriteGetObjectResponseInput: Equatable {
    /// <p>Indicates that a range of bytes was specified.</p>
    public let acceptRanges: String?
    /// <p>The object data.</p>
    public let body: Data?
    /// <p> Indicates whether the object stored in Amazon S3 uses an S3 bucket key for server-side
    ///          encryption with AWS KMS (SSE-KMS).</p>
    public let bucketKeyEnabled: Bool
    /// <p>Specifies caching behavior along the request/reply chain.</p>
    public let cacheControl: String?
    /// <p>Specifies presentational information for the object.</p>
    public let contentDisposition: String?
    /// <p>Specifies what content encodings have been applied to the object and thus what decoding
    ///           mechanisms must be applied to obtain the media-type referenced by the Content-Type header
    ///           field.</p>
    public let contentEncoding: String?
    /// <p>The language the content is in.</p>
    public let contentLanguage: String?
    /// <p>The size of the content body in bytes.</p>
    public let contentLength: Int
    /// <p>The portion of the object returned in the response.</p>
    public let contentRange: String?
    /// <p>A standard MIME type describing the format of the object data.</p>
    public let contentType: String?
    /// <p>Specifies whether an object stored in Amazon S3 is (<code>true</code>) or is not
    ///             (<code>false</code>) a delete marker. </p>
    public let deleteMarker: Bool
    /// <p>An opaque identifier assigned by a web server to a specific version of a resource found
    ///          at a URL. </p>
    public let eTag: String?
    /// <p>A string that uniquely identifies an error condition. Returned in the <Code> tag
    ///          of the error XML response for a corresponding <code>GetObject</code> call. Cannot be used
    ///          with a successful <code>StatusCode</code> header or when the transformed object is provided
    ///           in the body. All error codes from S3 are sentence-cased. Regex value is "^[A-Z][a-zA-Z]+$".</p>
    public let errorCode: String?
    /// <p>Contains a generic description of the error condition. Returned in the <Message>
    ///          tag of the error XML response for a corresponding <code>GetObject</code> call. Cannot be
    ///          used with a successful <code>StatusCode</code> header or when the transformed object is
    ///          provided in body.</p>
    public let errorMessage: String?
    /// <p>If object stored in Amazon S3 expiration is configured (see PUT Bucket lifecycle) it includes expiry-date and rule-id key-value pairs providing object expiration information. The value of the rule-id is URL encoded. </p>
    public let expiration: String?
    /// <p>The date and time at which the object is no longer cacheable.</p>
    public let expires: Date?
    /// <p>The date and time that the object was last modified.</p>
    public let lastModified: Date?
    /// <p>A map of metadata to store with the object in S3.</p>
    public let metadata: [String:String]?
    /// <p>Set to the number of metadata entries not returned in <code>x-amz-meta</code> headers.
    ///          This can happen if you create metadata using an API like SOAP that supports more flexible
    ///          metadata than the REST API. For example, using SOAP, you can create metadata whose values
    ///          are not legal HTTP headers.</p>
    public let missingMeta: Int
    /// <p>Indicates whether an object stored in Amazon S3 has an active legal hold.</p>
    public let objectLockLegalHoldStatus: ObjectLockLegalHoldStatus?
    /// <p>Indicates whether an object stored in Amazon S3 has Object Lock enabled. For more
    ///           information about S3 Object Lock, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-lock.html">Object Lock</a>.</p>
    public let objectLockMode: ObjectLockMode?
    /// <p>The date and time when Object Lock is configured to expire.</p>
    public let objectLockRetainUntilDate: Date?
    /// <p>The count of parts this object has.</p>
    public let partsCount: Int
    /// <p>Indicates if request involves bucket that is either a source or destination in a Replication rule. For more
    ///           information about S3 Replication, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/replication.html">Replication</a>.</p>
    public let replicationStatus: ReplicationStatus?
    /// <p>If present, indicates that the requester was successfully charged for the
    ///          request.</p>
    public let requestCharged: RequestCharged?
    /// <p>Route prefix to the HTTP URL generated.</p>
    public let requestRoute: String?
    /// <p>A single use encrypted token that maps <code>WriteGetObjectResponse</code> to the end
    ///          user <code>GetObject</code> request.</p>
    public let requestToken: String?
    /// <p>Provides information about object restoration operation and expiration time of the
    ///           restored object copy.</p>
    public let restore: String?
    /// <p>Encryption algorithm used if server-side encryption with a customer-provided encryption key was specified for object stored in Amazon S3.</p>
    public let sSECustomerAlgorithm: String?
    /// <p> 128-bit MD5 digest of customer-provided encryption key used in Amazon S3 to encrypt data
    ///          stored in S3. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/ServerSideEncryptionCustomerKeys.html">Protecting data
    ///             using server-side encryption with customer-provided encryption keys
    ///          (SSE-C)</a>.</p>
    public let sSECustomerKeyMD5: String?
    /// <p> If present, specifies the ID of the AWS Key Management Service (AWS KMS) symmetric customer managed customer master key (CMK) that was used for stored in Amazon S3 object. </p>
    public let sSEKMSKeyId: String?
    /// <p> The server-side encryption algorithm used when storing requested object in Amazon S3 (for example, AES256, aws:kms).</p>
    public let serverSideEncryption: ServerSideEncryption?
    /// <p>The integer status code for an HTTP response of a corresponding <code>GetObject</code>
    ///          request.</p>
    ///              <p class="title">
    ///             <b>Status Codes</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                    <p>
    ///                   <i>200 - OK</i>
    ///                </p>
    ///                 </li>
    ///             <li>
    ///                    <p>
    ///                   <i>206 - Partial Content</i>
    ///                </p>
    ///                 </li>
    ///             <li>
    ///                    <p>
    ///                   <i>304 - Not Modified</i>
    ///                </p>
    ///                 </li>
    ///             <li>
    ///                    <p>
    ///                   <i>400 - Bad Request</i>
    ///                    </p>
    ///                 </li>
    ///             <li>
    ///                    <p>
    ///                   <i>401 - Unauthorized</i>
    ///                    </p>
    ///                 </li>
    ///             <li>
    ///                    <p>
    ///                   <i>403 - Forbidden</i>
    ///                    </p>
    ///                 </li>
    ///             <li>
    ///                    <p>
    ///                   <i>404 - Not Found</i>
    ///                    </p>
    ///                 </li>
    ///             <li>
    ///                    <p>
    ///                   <i>405 - Method Not Allowed</i>
    ///                    </p>
    ///                 </li>
    ///             <li>
    ///                    <p>
    ///                   <i>409 - Conflict</i>
    ///                    </p>
    ///                 </li>
    ///             <li>
    ///                    <p>
    ///                   <i>411 - Length Required</i>
    ///                    </p>
    ///                 </li>
    ///             <li>
    ///                    <p>
    ///                   <i>412 - Precondition Failed</i>
    ///                    </p>
    ///                 </li>
    ///             <li>
    ///                    <p>
    ///                   <i>416 - Range Not Satisfiable</i>
    ///                    </p>
    ///                 </li>
    ///             <li>
    ///                    <p>
    ///                   <i>500 - Internal Server Error</i>
    ///                    </p>
    ///                 </li>
    ///             <li>
    ///                    <p>
    ///                   <i>503 - Service Unavailable</i>
    ///                    </p>
    ///                 </li>
    ///          </ul>
    public let statusCode: Int
    /// <p> The class of storage used to store object in Amazon S3.</p>
    public let storageClass: StorageClass?
    /// <p>The number of tags, if any, on the object.</p>
    public let tagCount: Int
    /// <p>An ID used to reference a specific version of the object.</p>
    public let versionId: String?

    public init (
        acceptRanges: String? = nil,
        body: Data? = nil,
        bucketKeyEnabled: Bool = false,
        cacheControl: String? = nil,
        contentDisposition: String? = nil,
        contentEncoding: String? = nil,
        contentLanguage: String? = nil,
        contentLength: Int = 0,
        contentRange: String? = nil,
        contentType: String? = nil,
        deleteMarker: Bool = false,
        eTag: String? = nil,
        errorCode: String? = nil,
        errorMessage: String? = nil,
        expiration: String? = nil,
        expires: Date? = nil,
        lastModified: Date? = nil,
        metadata: [String:String]? = nil,
        missingMeta: Int = 0,
        objectLockLegalHoldStatus: ObjectLockLegalHoldStatus? = nil,
        objectLockMode: ObjectLockMode? = nil,
        objectLockRetainUntilDate: Date? = nil,
        partsCount: Int = 0,
        replicationStatus: ReplicationStatus? = nil,
        requestCharged: RequestCharged? = nil,
        requestRoute: String? = nil,
        requestToken: String? = nil,
        restore: String? = nil,
        sSECustomerAlgorithm: String? = nil,
        sSECustomerKeyMD5: String? = nil,
        sSEKMSKeyId: String? = nil,
        serverSideEncryption: ServerSideEncryption? = nil,
        statusCode: Int = 0,
        storageClass: StorageClass? = nil,
        tagCount: Int = 0,
        versionId: String? = nil
    )
    {
        self.acceptRanges = acceptRanges
        self.body = body
        self.bucketKeyEnabled = bucketKeyEnabled
        self.cacheControl = cacheControl
        self.contentDisposition = contentDisposition
        self.contentEncoding = contentEncoding
        self.contentLanguage = contentLanguage
        self.contentLength = contentLength
        self.contentRange = contentRange
        self.contentType = contentType
        self.deleteMarker = deleteMarker
        self.eTag = eTag
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.expiration = expiration
        self.expires = expires
        self.lastModified = lastModified
        self.metadata = metadata
        self.missingMeta = missingMeta
        self.objectLockLegalHoldStatus = objectLockLegalHoldStatus
        self.objectLockMode = objectLockMode
        self.objectLockRetainUntilDate = objectLockRetainUntilDate
        self.partsCount = partsCount
        self.replicationStatus = replicationStatus
        self.requestCharged = requestCharged
        self.requestRoute = requestRoute
        self.requestToken = requestToken
        self.restore = restore
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
        self.statusCode = statusCode
        self.storageClass = storageClass
        self.tagCount = tagCount
        self.versionId = versionId
    }
}

struct WriteGetObjectResponseInputBody: Equatable {
    public let body: Data?
}

extension WriteGetObjectResponseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.body) {
            do {
                let bodyDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .body)
                body = bodyDecoded
            } catch {
                body = "".data(using: .utf8)
            }
        } else {
            body = nil
        }
    }
}

extension WriteGetObjectResponseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension WriteGetObjectResponseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum WriteGetObjectResponseOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension WriteGetObjectResponseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WriteGetObjectResponseOutputResponse()"}
}

extension WriteGetObjectResponseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct WriteGetObjectResponseOutputResponse: Equatable {

    public init() {}
}

struct WriteGetObjectResponseOutputResponseBody: Equatable {
}

extension WriteGetObjectResponseOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}
