// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct ListPartsOutputBody: Equatable {
    public let bucket: String?
    public let key: String?
    public let uploadId: String?
    public let partNumberMarker: String?
    public let nextPartNumberMarker: String?
    public let maxParts: Int
    public let isTruncated: Bool
    public let parts: [Part]?
    public let initiator: Initiator?
    public let owner: Owner?
    public let storageClass: StorageClass?
}

extension ListPartsOutputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case initiator = "Initiator"
        case isTruncated = "IsTruncated"
        case key = "Key"
        case maxParts = "MaxParts"
        case nextPartNumberMarker = "NextPartNumberMarker"
        case owner = "Owner"
        case partNumberMarker = "PartNumberMarker"
        case parts = "Part"
        case storageClass = "StorageClass"
        case uploadId = "UploadId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let partNumberMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partNumberMarker)
        partNumberMarker = partNumberMarkerDecoded
        let nextPartNumberMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPartNumberMarker)
        nextPartNumberMarker = nextPartNumberMarkerDecoded
        let maxPartsDecoded = try containerValues.decode(Int.self, forKey: .maxParts)
        maxParts = maxPartsDecoded
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        if containerValues.contains(.parts) {
            let partsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .parts)
            if partsWrappedContainer != nil {
                let partsContainer = try containerValues.decodeIfPresent([Part].self, forKey: .parts)
                var partsBuffer:[Part]? = nil
                if let partsContainer = partsContainer {
                    partsBuffer = [Part]()
                    for structureContainer0 in partsContainer {
                        partsBuffer?.append(structureContainer0)
                    }
                }
                parts = partsBuffer
            } else {
                parts = []
            }
        } else {
            parts = nil
        }
        let initiatorDecoded = try containerValues.decodeIfPresent(Initiator.self, forKey: .initiator)
        initiator = initiatorDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Owner.self, forKey: .owner)
        owner = ownerDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}
