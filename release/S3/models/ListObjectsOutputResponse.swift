// Code generated by smithy-swift-codegen. DO NOT EDIT!



public struct ListObjectsOutputResponse: Equatable {
    /// <p>All of the keys (up to 1,000) rolled up in a common prefix count as a single return when calculating
    ///          the number of returns. </p>
    ///
    ///          <p>A response can contain CommonPrefixes only if you specify a delimiter.</p>
    ///
    ///          <p>CommonPrefixes contains all (if there are any) keys between Prefix and the next
    ///          occurrence of the string specified by the delimiter.</p>
    ///
    ///          <p> CommonPrefixes lists keys that act like subdirectories in the directory specified by
    ///          Prefix.</p>
    ///
    ///          <p>For example, if the prefix is notes/ and the delimiter is a slash (/) as in
    ///          notes/summer/july, the common prefix is notes/summer/. All of the keys that roll up into a
    ///          common prefix count as a single return when calculating the number of returns.</p>
    public let commonPrefixes: [CommonPrefix]?
    /// <p>Metadata about each object returned.</p>
    public let contents: [Object]?
    /// <p>Causes keys that contain the same string between the prefix and the first occurrence of
    ///          the delimiter to be rolled up into a single result element in the
    ///             <code>CommonPrefixes</code> collection. These rolled-up keys are not returned elsewhere
    ///          in the response. Each rolled-up result counts as only one return against the
    ///             <code>MaxKeys</code> value.</p>
    public let delimiter: String?
    /// <p>Encoding type used by Amazon S3 to encode object keys in the response.</p>
    public let encodingType: EncodingType?
    /// <p>A flag that indicates whether Amazon S3 returned all of the results that satisfied the search
    ///          criteria.</p>
    public let isTruncated: Bool
    /// <p>Indicates where in the bucket listing begins. Marker is included in the response if it
    ///          was sent with the request.</p>
    public let marker: String?
    /// <p>The maximum number of keys returned in the response body.</p>
    public let maxKeys: Int
    /// <p>The bucket name.</p>
    public let name: String?
    /// <p>When response is truncated (the IsTruncated element value in the response is true), you
    ///          can use the key name in this field as marker in the subsequent request to get next set of
    ///          objects. Amazon S3 lists objects in alphabetical order Note: This element is returned only if
    ///          you have delimiter request parameter specified. If response does not include the NextMarker
    ///          and it is truncated, you can use the value of the last Key in the response as the marker in
    ///          the subsequent request to get the next set of object keys.</p>
    public let nextMarker: String?
    /// <p>Keys that begin with the indicated prefix.</p>
    public let prefix: String?

    public init (
        commonPrefixes: [CommonPrefix]? = nil,
        contents: [Object]? = nil,
        delimiter: String? = nil,
        encodingType: EncodingType? = nil,
        isTruncated: Bool = false,
        marker: String? = nil,
        maxKeys: Int = 0,
        name: String? = nil,
        nextMarker: String? = nil,
        prefix: String? = nil
    )
    {
        self.commonPrefixes = commonPrefixes
        self.contents = contents
        self.delimiter = delimiter
        self.encodingType = encodingType
        self.isTruncated = isTruncated
        self.marker = marker
        self.maxKeys = maxKeys
        self.name = name
        self.nextMarker = nextMarker
        self.prefix = prefix
    }
}

extension ListObjectsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListObjectsOutputResponse(commonPrefixes: \(String(describing: commonPrefixes)), contents: \(String(describing: contents)), delimiter: \(String(describing: delimiter)), encodingType: \(String(describing: encodingType)), isTruncated: \(String(describing: isTruncated)), marker: \(String(describing: marker)), maxKeys: \(String(describing: maxKeys)), name: \(String(describing: name)), nextMarker: \(String(describing: nextMarker)), prefix: \(String(describing: prefix)))"}
}
