// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var error: Swift.String?
    public var error_description: Swift.String?

    public init (
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension AuthorizationPendingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AuthorizationPendingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that a request to authorize a client with an access user session token is pending.
public struct AuthorizationPendingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var error: Swift.String?
    public var error_description: Swift.String?

    public init (
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct AuthorizationPendingExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension AuthorizationPendingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension CreateTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId
        case clientSecret
        case code
        case deviceCode
        case grantType
        case redirectUri
        case refreshToken
        case scope
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let deviceCode = deviceCode {
            try encodeContainer.encode(deviceCode, forKey: .deviceCode)
        }
        if let grantType = grantType {
            try encodeContainer.encode(grantType, forKey: .grantType)
        }
        if let redirectUri = redirectUri {
            try encodeContainer.encode(redirectUri, forKey: .redirectUri)
        }
        if let refreshToken = refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
        if let scope = scope {
            var scopeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scope)
            for scopes0 in scope {
                try scopeContainer.encode(scopes0)
            }
        }
    }
}

extension CreateTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/token"
    }
}

public struct CreateTokenInput: Swift.Equatable {
    /// The unique identifier string for each client. This value should come from the persisted result of the [RegisterClient] API.
    /// This member is required.
    public var clientId: Swift.String?
    /// A secret string generated for the client. This value should come from the persisted result of the [RegisterClient] API.
    /// This member is required.
    public var clientSecret: Swift.String?
    /// The authorization code received from the authorization service. This parameter is required to perform an authorization grant request to get access to a token.
    public var code: Swift.String?
    /// Used only when calling this API for the device code grant type. This short-term code is used to identify this authentication attempt. This should come from an in-memory reference to the result of the [StartDeviceAuthorization] API.
    /// This member is required.
    public var deviceCode: Swift.String?
    /// Supports grant types for authorization code, refresh token, and device code request.
    /// This member is required.
    public var grantType: Swift.String?
    /// The location of the application that will receive the authorization code. Users authorize the service to send the request to this location.
    public var redirectUri: Swift.String?
    /// The token used to obtain an access token in the event that the access token is invalid or expired. This token is not issued by the service.
    public var refreshToken: Swift.String?
    /// The list of scopes that is defined by the client. Upon authorization, this list is used to restrict permissions when granting an access token.
    public var scope: [Swift.String]?

    public init (
        clientId: Swift.String? = nil,
        clientSecret: Swift.String? = nil,
        code: Swift.String? = nil,
        deviceCode: Swift.String? = nil,
        grantType: Swift.String? = nil,
        redirectUri: Swift.String? = nil,
        refreshToken: Swift.String? = nil,
        scope: [Swift.String]? = nil
    )
    {
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.code = code
        self.deviceCode = deviceCode
        self.grantType = grantType
        self.redirectUri = redirectUri
        self.refreshToken = refreshToken
        self.scope = scope
    }
}

struct CreateTokenInputBody: Swift.Equatable {
    let clientId: Swift.String?
    let clientSecret: Swift.String?
    let grantType: Swift.String?
    let deviceCode: Swift.String?
    let code: Swift.String?
    let refreshToken: Swift.String?
    let scope: [Swift.String]?
    let redirectUri: Swift.String?
}

extension CreateTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId
        case clientSecret
        case code
        case deviceCode
        case grantType
        case redirectUri
        case refreshToken
        case scope
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let grantTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantType)
        grantType = grantTypeDecoded
        let deviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceCode)
        deviceCode = deviceCodeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let scopeContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .scope)
        var scopeDecoded0:[Swift.String]? = nil
        if let scopeContainer = scopeContainer {
            scopeDecoded0 = [Swift.String]()
            for string0 in scopeContainer {
                if let string0 = string0 {
                    scopeDecoded0?.append(string0)
                }
            }
        }
        scope = scopeDecoded0
        let redirectUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redirectUri)
        redirectUri = redirectUriDecoded
    }
}

extension CreateTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationPendingException" : self = .authorizationPendingException(try AuthorizationPendingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredTokenException" : self = .expiredTokenException(try ExpiredTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientException" : self = .invalidClientException(try InvalidClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGrantException" : self = .invalidGrantException(try InvalidGrantException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidScopeException" : self = .invalidScopeException(try InvalidScopeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SlowDownException" : self = .slowDownException(try SlowDownException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedGrantTypeException" : self = .unsupportedGrantTypeException(try UnsupportedGrantTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTokenOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationPendingException(AuthorizationPendingException)
    case expiredTokenException(ExpiredTokenException)
    case internalServerException(InternalServerException)
    case invalidClientException(InvalidClientException)
    case invalidGrantException(InvalidGrantException)
    case invalidRequestException(InvalidRequestException)
    case invalidScopeException(InvalidScopeException)
    case slowDownException(SlowDownException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unsupportedGrantTypeException(UnsupportedGrantTypeException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessToken = output.accessToken
            self.expiresIn = output.expiresIn
            self.idToken = output.idToken
            self.refreshToken = output.refreshToken
            self.tokenType = output.tokenType
        } else {
            self.accessToken = nil
            self.expiresIn = 0
            self.idToken = nil
            self.refreshToken = nil
            self.tokenType = nil
        }
    }
}

public struct CreateTokenOutputResponse: Swift.Equatable {
    /// An opaque token to access AWS SSO resources assigned to a user.
    public var accessToken: Swift.String?
    /// Indicates the time in seconds when an access token will expire.
    public var expiresIn: Swift.Int
    /// The identifier of the user that associated with the access token, if present.
    public var idToken: Swift.String?
    /// A token that, if present, can be used to refresh a previously issued access token that might have expired.
    public var refreshToken: Swift.String?
    /// Used to notify the client that the returned token is an access token. The supported type is BearerToken.
    public var tokenType: Swift.String?

    public init (
        accessToken: Swift.String? = nil,
        expiresIn: Swift.Int = 0,
        idToken: Swift.String? = nil,
        refreshToken: Swift.String? = nil,
        tokenType: Swift.String? = nil
    )
    {
        self.accessToken = accessToken
        self.expiresIn = expiresIn
        self.idToken = idToken
        self.refreshToken = refreshToken
        self.tokenType = tokenType
    }
}

struct CreateTokenOutputResponseBody: Swift.Equatable {
    let accessToken: Swift.String?
    let tokenType: Swift.String?
    let expiresIn: Swift.Int
    let refreshToken: Swift.String?
    let idToken: Swift.String?
}

extension CreateTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case expiresIn
        case idToken
        case refreshToken
        case tokenType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let tokenTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenType)
        tokenType = tokenTypeDecoded
        let expiresInDecoded = try containerValues.decode(Swift.Int.self, forKey: .expiresIn)
        expiresIn = expiresInDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let idTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idToken)
        idToken = idTokenDecoded
    }
}

extension ExpiredTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExpiredTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the token issued by the service is expired and is no longer valid.
public struct ExpiredTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var error: Swift.String?
    public var error_description: Swift.String?

    public init (
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct ExpiredTokenExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension ExpiredTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that an error from the service occurred while trying to process a request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var error: Swift.String?
    public var error_description: Swift.String?

    public init (
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InvalidClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the clientId or clientSecret in the request is invalid. For example, this can occur when a client sends an incorrect clientId or an expired clientSecret.
public struct InvalidClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var error: Swift.String?
    public var error_description: Swift.String?

    public init (
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct InvalidClientExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension InvalidClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InvalidClientMetadataException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidClientMetadataExceptionBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the client information sent in the request during registration is invalid.
public struct InvalidClientMetadataException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var error: Swift.String?
    public var error_description: Swift.String?

    public init (
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct InvalidClientMetadataExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension InvalidClientMetadataExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InvalidGrantException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidGrantExceptionBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that a request contains an invalid grant. This can occur if a client makes a [CreateToken] request with an invalid grant type.
public struct InvalidGrantException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var error: Swift.String?
    public var error_description: Swift.String?

    public init (
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct InvalidGrantExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension InvalidGrantExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that something is wrong with the input to the request. For example, a required parameter might be missing or out of range.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var error: Swift.String?
    public var error_description: Swift.String?

    public init (
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InvalidScopeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidScopeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the scope provided in the request is invalid.
public struct InvalidScopeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var error: Swift.String?
    public var error_description: Swift.String?

    public init (
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct InvalidScopeExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension InvalidScopeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension RegisterClientInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientName
        case clientType
        case scopes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientName = clientName {
            try encodeContainer.encode(clientName, forKey: .clientName)
        }
        if let clientType = clientType {
            try encodeContainer.encode(clientType, forKey: .clientType)
        }
        if let scopes = scopes {
            var scopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scopes)
            for scopes0 in scopes {
                try scopesContainer.encode(scopes0)
            }
        }
    }
}

extension RegisterClientInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/client/register"
    }
}

public struct RegisterClientInput: Swift.Equatable {
    /// The friendly name of the client.
    /// This member is required.
    public var clientName: Swift.String?
    /// The type of client. The service supports only public as a client type. Anything other than public will be rejected by the service.
    /// This member is required.
    public var clientType: Swift.String?
    /// The list of scopes that are defined by the client. Upon authorization, this list is used to restrict permissions when granting an access token.
    public var scopes: [Swift.String]?

    public init (
        clientName: Swift.String? = nil,
        clientType: Swift.String? = nil,
        scopes: [Swift.String]? = nil
    )
    {
        self.clientName = clientName
        self.clientType = clientType
        self.scopes = scopes
    }
}

struct RegisterClientInputBody: Swift.Equatable {
    let clientName: Swift.String?
    let clientType: Swift.String?
    let scopes: [Swift.String]?
}

extension RegisterClientInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientName
        case clientType
        case scopes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientName)
        clientName = clientNameDecoded
        let clientTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientType)
        clientType = clientTypeDecoded
        let scopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .scopes)
        var scopesDecoded0:[Swift.String]? = nil
        if let scopesContainer = scopesContainer {
            scopesDecoded0 = [Swift.String]()
            for string0 in scopesContainer {
                if let string0 = string0 {
                    scopesDecoded0?.append(string0)
                }
            }
        }
        scopes = scopesDecoded0
    }
}

extension RegisterClientOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterClientOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientMetadataException" : self = .invalidClientMetadataException(try InvalidClientMetadataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidScopeException" : self = .invalidScopeException(try InvalidScopeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterClientOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidClientMetadataException(InvalidClientMetadataException)
    case invalidRequestException(InvalidRequestException)
    case invalidScopeException(InvalidScopeException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterClientOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterClientOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authorizationEndpoint = output.authorizationEndpoint
            self.clientId = output.clientId
            self.clientIdIssuedAt = output.clientIdIssuedAt
            self.clientSecret = output.clientSecret
            self.clientSecretExpiresAt = output.clientSecretExpiresAt
            self.tokenEndpoint = output.tokenEndpoint
        } else {
            self.authorizationEndpoint = nil
            self.clientId = nil
            self.clientIdIssuedAt = 0
            self.clientSecret = nil
            self.clientSecretExpiresAt = 0
            self.tokenEndpoint = nil
        }
    }
}

public struct RegisterClientOutputResponse: Swift.Equatable {
    /// The endpoint where the client can request authorization.
    public var authorizationEndpoint: Swift.String?
    /// The unique identifier string for each client. This client uses this identifier to get authenticated by the service in subsequent calls.
    public var clientId: Swift.String?
    /// Indicates the time at which the clientId and clientSecret were issued.
    public var clientIdIssuedAt: Swift.Int
    /// A secret string generated for the client. The client will use this string to get authenticated by the service in subsequent calls.
    public var clientSecret: Swift.String?
    /// Indicates the time at which the clientId and clientSecret will become invalid.
    public var clientSecretExpiresAt: Swift.Int
    /// The endpoint where the client can get an access token.
    public var tokenEndpoint: Swift.String?

    public init (
        authorizationEndpoint: Swift.String? = nil,
        clientId: Swift.String? = nil,
        clientIdIssuedAt: Swift.Int = 0,
        clientSecret: Swift.String? = nil,
        clientSecretExpiresAt: Swift.Int = 0,
        tokenEndpoint: Swift.String? = nil
    )
    {
        self.authorizationEndpoint = authorizationEndpoint
        self.clientId = clientId
        self.clientIdIssuedAt = clientIdIssuedAt
        self.clientSecret = clientSecret
        self.clientSecretExpiresAt = clientSecretExpiresAt
        self.tokenEndpoint = tokenEndpoint
    }
}

struct RegisterClientOutputResponseBody: Swift.Equatable {
    let clientId: Swift.String?
    let clientSecret: Swift.String?
    let clientIdIssuedAt: Swift.Int
    let clientSecretExpiresAt: Swift.Int
    let authorizationEndpoint: Swift.String?
    let tokenEndpoint: Swift.String?
}

extension RegisterClientOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationEndpoint
        case clientId
        case clientIdIssuedAt
        case clientSecret
        case clientSecretExpiresAt
        case tokenEndpoint
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let clientIdIssuedAtDecoded = try containerValues.decode(Swift.Int.self, forKey: .clientIdIssuedAt)
        clientIdIssuedAt = clientIdIssuedAtDecoded
        let clientSecretExpiresAtDecoded = try containerValues.decode(Swift.Int.self, forKey: .clientSecretExpiresAt)
        clientSecretExpiresAt = clientSecretExpiresAtDecoded
        let authorizationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationEndpoint)
        authorizationEndpoint = authorizationEndpointDecoded
        let tokenEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenEndpoint)
        tokenEndpoint = tokenEndpointDecoded
    }
}

extension SlowDownException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SlowDownExceptionBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the client is making the request too frequently and is more than the service can handle.
public struct SlowDownException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var error: Swift.String?
    public var error_description: Swift.String?

    public init (
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct SlowDownExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension SlowDownExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension StartDeviceAuthorizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId
        case clientSecret
        case startUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let startUrl = startUrl {
            try encodeContainer.encode(startUrl, forKey: .startUrl)
        }
    }
}

extension StartDeviceAuthorizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/device_authorization"
    }
}

public struct StartDeviceAuthorizationInput: Swift.Equatable {
    /// The unique identifier string for the client that is registered with AWS SSO. This value should come from the persisted result of the [RegisterClient] API operation.
    /// This member is required.
    public var clientId: Swift.String?
    /// A secret string that is generated for the client. This value should come from the persisted result of the [RegisterClient] API operation.
    /// This member is required.
    public var clientSecret: Swift.String?
    /// The URL for the AWS SSO user portal. For more information, see [Using the User Portal](https://docs.aws.amazon.com/singlesignon/latest/userguide/using-the-portal.html) in the AWS Single Sign-On User Guide.
    /// This member is required.
    public var startUrl: Swift.String?

    public init (
        clientId: Swift.String? = nil,
        clientSecret: Swift.String? = nil,
        startUrl: Swift.String? = nil
    )
    {
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.startUrl = startUrl
    }
}

struct StartDeviceAuthorizationInputBody: Swift.Equatable {
    let clientId: Swift.String?
    let clientSecret: Swift.String?
    let startUrl: Swift.String?
}

extension StartDeviceAuthorizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId
        case clientSecret
        case startUrl
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let startUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startUrl)
        startUrl = startUrlDecoded
    }
}

extension StartDeviceAuthorizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDeviceAuthorizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientException" : self = .invalidClientException(try InvalidClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SlowDownException" : self = .slowDownException(try SlowDownException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDeviceAuthorizationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidClientException(InvalidClientException)
    case invalidRequestException(InvalidRequestException)
    case slowDownException(SlowDownException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDeviceAuthorizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartDeviceAuthorizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceCode = output.deviceCode
            self.expiresIn = output.expiresIn
            self.interval = output.interval
            self.userCode = output.userCode
            self.verificationUri = output.verificationUri
            self.verificationUriComplete = output.verificationUriComplete
        } else {
            self.deviceCode = nil
            self.expiresIn = 0
            self.interval = 0
            self.userCode = nil
            self.verificationUri = nil
            self.verificationUriComplete = nil
        }
    }
}

public struct StartDeviceAuthorizationOutputResponse: Swift.Equatable {
    /// The short-lived code that is used by the device when polling for a session token.
    public var deviceCode: Swift.String?
    /// Indicates the number of seconds in which the verification code will become invalid.
    public var expiresIn: Swift.Int
    /// Indicates the number of seconds the client must wait between attempts when polling for a session.
    public var interval: Swift.Int
    /// A one-time user verification code. This is needed to authorize an in-use device.
    public var userCode: Swift.String?
    /// The URI of the verification page that takes the userCode to authorize the device.
    public var verificationUri: Swift.String?
    /// An alternate URL that the client can use to automatically launch a browser. This process skips the manual step in which the user visits the verification page and enters their code.
    public var verificationUriComplete: Swift.String?

    public init (
        deviceCode: Swift.String? = nil,
        expiresIn: Swift.Int = 0,
        interval: Swift.Int = 0,
        userCode: Swift.String? = nil,
        verificationUri: Swift.String? = nil,
        verificationUriComplete: Swift.String? = nil
    )
    {
        self.deviceCode = deviceCode
        self.expiresIn = expiresIn
        self.interval = interval
        self.userCode = userCode
        self.verificationUri = verificationUri
        self.verificationUriComplete = verificationUriComplete
    }
}

struct StartDeviceAuthorizationOutputResponseBody: Swift.Equatable {
    let deviceCode: Swift.String?
    let userCode: Swift.String?
    let verificationUri: Swift.String?
    let verificationUriComplete: Swift.String?
    let expiresIn: Swift.Int
    let interval: Swift.Int
}

extension StartDeviceAuthorizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceCode
        case expiresIn
        case interval
        case userCode
        case verificationUri
        case verificationUriComplete
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceCode)
        deviceCode = deviceCodeDecoded
        let userCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userCode)
        userCode = userCodeDecoded
        let verificationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verificationUri)
        verificationUri = verificationUriDecoded
        let verificationUriCompleteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verificationUriComplete)
        verificationUriComplete = verificationUriCompleteDecoded
        let expiresInDecoded = try containerValues.decode(Swift.Int.self, forKey: .expiresIn)
        expiresIn = expiresInDecoded
        let intervalDecoded = try containerValues.decode(Swift.Int.self, forKey: .interval)
        interval = intervalDecoded
    }
}

extension UnauthorizedClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnauthorizedClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the client is not currently authorized to make the request. This can happen when a clientId is not issued for a public client.
public struct UnauthorizedClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var error: Swift.String?
    public var error_description: Swift.String?

    public init (
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct UnauthorizedClientExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension UnauthorizedClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension UnsupportedGrantTypeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedGrantTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the grant type in the request is not supported by the service.
public struct UnsupportedGrantTypeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var error: Swift.String?
    public var error_description: Swift.String?

    public init (
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct UnsupportedGrantTypeExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension UnsupportedGrantTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}
