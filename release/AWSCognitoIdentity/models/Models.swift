// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CognitoIdentityClientTypes {
    public enum AmbiguousRoleResolutionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authenticatedRole
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [AmbiguousRoleResolutionType] {
            return [
                .authenticatedRole,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authenticatedRole: return "AuthenticatedRole"
            case .deny: return "Deny"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AmbiguousRoleResolutionType(rawValue: rawValue) ?? AmbiguousRoleResolutionType.sdkUnknown(rawValue)
        }
    }
}

extension CognitoIdentityClientTypes.CognitoIdentityProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId = "ClientId"
        case providerName = "ProviderName"
        case serverSideTokenCheck = "ServerSideTokenCheck"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if serverSideTokenCheck != false {
            try encodeContainer.encode(serverSideTokenCheck, forKey: .serverSideTokenCheck)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let serverSideTokenCheckDecoded = try containerValues.decode(Swift.Bool.self, forKey: .serverSideTokenCheck)
        serverSideTokenCheck = serverSideTokenCheckDecoded
    }
}

extension CognitoIdentityClientTypes {
    /// A provider representing an Amazon Cognito user pool and its client ID.
    public struct CognitoIdentityProvider: Swift.Equatable {
        /// The client ID for the Amazon Cognito user pool.
        public var clientId: Swift.String?
        /// The provider name for an Amazon Cognito user pool. For example, cognito-idp.us-east-1.amazonaws.com/us-east-1_123456789.
        public var providerName: Swift.String?
        /// TRUE if server-side token validation is enabled for the identity providerâ€™s token. Once you set ServerSideTokenCheck to TRUE for an identity pool, that identity pool will check with the integrated user pools to make sure that the user has not been globally signed out or deleted before the identity pool provides an OIDC token or AWS credentials for the user. If the user is signed out or deleted, the identity pool will return a 400 Not Authorized error.
        public var serverSideTokenCheck: Swift.Bool

        public init (
            clientId: Swift.String? = nil,
            providerName: Swift.String? = nil,
            serverSideTokenCheck: Swift.Bool = false
        )
        {
            self.clientId = clientId
            self.providerName = providerName
            self.serverSideTokenCheck = serverSideTokenCheck
        }
    }

}

extension ConcurrentModificationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown if there are parallel requests to modify a resource.
public struct ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message returned by a ConcurrentModificationException.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateIdentityPoolInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowClassicFlow = allowClassicFlow {
            try encodeContainer.encode(allowClassicFlow, forKey: .allowClassicFlow)
        }
        if allowUnauthenticatedIdentities != false {
            try encodeContainer.encode(allowUnauthenticatedIdentities, forKey: .allowUnauthenticatedIdentities)
        }
        if let cognitoIdentityProviders = cognitoIdentityProviders {
            var cognitoIdentityProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cognitoIdentityProviders)
            for cognitoidentityproviderlist0 in cognitoIdentityProviders {
                try cognitoIdentityProvidersContainer.encode(cognitoidentityproviderlist0)
            }
        }
        if let developerProviderName = developerProviderName {
            try encodeContainer.encode(developerProviderName, forKey: .developerProviderName)
        }
        if let identityPoolName = identityPoolName {
            try encodeContainer.encode(identityPoolName, forKey: .identityPoolName)
        }
        if let identityPoolTags = identityPoolTags {
            var identityPoolTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identityPoolTags)
            for (dictKey0, identitypooltagstype0) in identityPoolTags {
                try identityPoolTagsContainer.encode(identitypooltagstype0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let openIdConnectProviderARNs = openIdConnectProviderARNs {
            var openIdConnectProviderARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .openIdConnectProviderARNs)
            for oidcproviderlist0 in openIdConnectProviderARNs {
                try openIdConnectProviderARNsContainer.encode(oidcproviderlist0)
            }
        }
        if let samlProviderARNs = samlProviderARNs {
            var samlProviderARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .samlProviderARNs)
            for samlproviderlist0 in samlProviderARNs {
                try samlProviderARNsContainer.encode(samlproviderlist0)
            }
        }
        if let supportedLoginProviders = supportedLoginProviders {
            var supportedLoginProvidersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .supportedLoginProviders)
            for (dictKey0, identityproviders0) in supportedLoginProviders {
                try supportedLoginProvidersContainer.encode(identityproviders0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateIdentityPoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the CreateIdentityPool action.
public struct CreateIdentityPoolInput: Swift.Equatable {
    /// Enables or disables the Basic (Classic) authentication flow. For more information, see [Identity Pools (Federated Identities) Authentication Flow](https://docs.aws.amazon.com/cognito/latest/developerguide/authentication-flow.html) in the Amazon Cognito Developer Guide.
    public var allowClassicFlow: Swift.Bool?
    /// TRUE if the identity pool supports unauthenticated logins.
    /// This member is required.
    public var allowUnauthenticatedIdentities: Swift.Bool
    /// An array of Amazon Cognito user pools and their client IDs.
    public var cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    /// The "domain" by which Cognito will refer to your users. This name acts as a placeholder that allows your backend and the Cognito service to communicate about the developer provider. For the DeveloperProviderName, you can use letters as well as period (.), underscore (_), and dash (-). Once you have set a developer provider name, you cannot change it. Please take care in setting this parameter.
    public var developerProviderName: Swift.String?
    /// A string that you provide.
    /// This member is required.
    public var identityPoolName: Swift.String?
    /// Tags to assign to the identity pool. A tag is a label that you can apply to identity pools to categorize and manage them in different ways, such as by purpose, owner, environment, or other criteria.
    public var identityPoolTags: [Swift.String:Swift.String]?
    /// The Amazon Resource Names (ARN) of the OpenID Connect providers.
    public var openIdConnectProviderARNs: [Swift.String]?
    /// An array of Amazon Resource Names (ARNs) of the SAML provider for your identity pool.
    public var samlProviderARNs: [Swift.String]?
    /// Optional key:value pairs mapping provider names to provider app IDs.
    public var supportedLoginProviders: [Swift.String:Swift.String]?

    public init (
        allowClassicFlow: Swift.Bool? = nil,
        allowUnauthenticatedIdentities: Swift.Bool = false,
        cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil,
        developerProviderName: Swift.String? = nil,
        identityPoolName: Swift.String? = nil,
        identityPoolTags: [Swift.String:Swift.String]? = nil,
        openIdConnectProviderARNs: [Swift.String]? = nil,
        samlProviderARNs: [Swift.String]? = nil,
        supportedLoginProviders: [Swift.String:Swift.String]? = nil
    )
    {
        self.allowClassicFlow = allowClassicFlow
        self.allowUnauthenticatedIdentities = allowUnauthenticatedIdentities
        self.cognitoIdentityProviders = cognitoIdentityProviders
        self.developerProviderName = developerProviderName
        self.identityPoolName = identityPoolName
        self.identityPoolTags = identityPoolTags
        self.openIdConnectProviderARNs = openIdConnectProviderARNs
        self.samlProviderARNs = samlProviderARNs
        self.supportedLoginProviders = supportedLoginProviders
    }
}

struct CreateIdentityPoolInputBody: Swift.Equatable {
    let identityPoolName: Swift.String?
    let allowUnauthenticatedIdentities: Swift.Bool
    let allowClassicFlow: Swift.Bool?
    let supportedLoginProviders: [Swift.String:Swift.String]?
    let developerProviderName: Swift.String?
    let openIdConnectProviderARNs: [Swift.String]?
    let cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    let samlProviderARNs: [Swift.String]?
    let identityPoolTags: [Swift.String:Swift.String]?
}

extension CreateIdentityPoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let allowUnauthenticatedIdentitiesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowUnauthenticatedIdentities)
        allowUnauthenticatedIdentities = allowUnauthenticatedIdentitiesDecoded
        let allowClassicFlowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowClassicFlow)
        allowClassicFlow = allowClassicFlowDecoded
        let supportedLoginProvidersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .supportedLoginProviders)
        var supportedLoginProvidersDecoded0: [Swift.String:Swift.String]? = nil
        if let supportedLoginProvidersContainer = supportedLoginProvidersContainer {
            supportedLoginProvidersDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityproviderid0) in supportedLoginProvidersContainer {
                if let identityproviderid0 = identityproviderid0 {
                    supportedLoginProvidersDecoded0?[key0] = identityproviderid0
                }
            }
        }
        supportedLoginProviders = supportedLoginProvidersDecoded0
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let openIdConnectProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .openIdConnectProviderARNs)
        var openIdConnectProviderARNsDecoded0:[Swift.String]? = nil
        if let openIdConnectProviderARNsContainer = openIdConnectProviderARNsContainer {
            openIdConnectProviderARNsDecoded0 = [Swift.String]()
            for string0 in openIdConnectProviderARNsContainer {
                if let string0 = string0 {
                    openIdConnectProviderARNsDecoded0?.append(string0)
                }
            }
        }
        openIdConnectProviderARNs = openIdConnectProviderARNsDecoded0
        let cognitoIdentityProvidersContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.CognitoIdentityProvider?].self, forKey: .cognitoIdentityProviders)
        var cognitoIdentityProvidersDecoded0:[CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil
        if let cognitoIdentityProvidersContainer = cognitoIdentityProvidersContainer {
            cognitoIdentityProvidersDecoded0 = [CognitoIdentityClientTypes.CognitoIdentityProvider]()
            for structure0 in cognitoIdentityProvidersContainer {
                if let structure0 = structure0 {
                    cognitoIdentityProvidersDecoded0?.append(structure0)
                }
            }
        }
        cognitoIdentityProviders = cognitoIdentityProvidersDecoded0
        let samlProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .samlProviderARNs)
        var samlProviderARNsDecoded0:[Swift.String]? = nil
        if let samlProviderARNsContainer = samlProviderARNsContainer {
            samlProviderARNsDecoded0 = [Swift.String]()
            for string0 in samlProviderARNsContainer {
                if let string0 = string0 {
                    samlProviderARNsDecoded0?.append(string0)
                }
            }
        }
        samlProviderARNs = samlProviderARNsDecoded0
        let identityPoolTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityPoolTags)
        var identityPoolTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityPoolTagsContainer = identityPoolTagsContainer {
            identityPoolTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvaluetype0) in identityPoolTagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    identityPoolTagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        identityPoolTags = identityPoolTagsDecoded0
    }
}

extension CreateIdentityPoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIdentityPoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIdentityPoolOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIdentityPoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateIdentityPoolOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.allowClassicFlow = output.allowClassicFlow
            self.allowUnauthenticatedIdentities = output.allowUnauthenticatedIdentities
            self.cognitoIdentityProviders = output.cognitoIdentityProviders
            self.developerProviderName = output.developerProviderName
            self.identityPoolId = output.identityPoolId
            self.identityPoolName = output.identityPoolName
            self.identityPoolTags = output.identityPoolTags
            self.openIdConnectProviderARNs = output.openIdConnectProviderARNs
            self.samlProviderARNs = output.samlProviderARNs
            self.supportedLoginProviders = output.supportedLoginProviders
        } else {
            self.allowClassicFlow = nil
            self.allowUnauthenticatedIdentities = false
            self.cognitoIdentityProviders = nil
            self.developerProviderName = nil
            self.identityPoolId = nil
            self.identityPoolName = nil
            self.identityPoolTags = nil
            self.openIdConnectProviderARNs = nil
            self.samlProviderARNs = nil
            self.supportedLoginProviders = nil
        }
    }
}

/// An object representing an Amazon Cognito identity pool.
public struct CreateIdentityPoolOutputResponse: Swift.Equatable {
    /// Enables or disables the Basic (Classic) authentication flow. For more information, see [Identity Pools (Federated Identities) Authentication Flow](https://docs.aws.amazon.com/cognito/latest/developerguide/authentication-flow.html) in the Amazon Cognito Developer Guide.
    public var allowClassicFlow: Swift.Bool?
    /// TRUE if the identity pool supports unauthenticated logins.
    /// This member is required.
    public var allowUnauthenticatedIdentities: Swift.Bool
    /// A list representing an Amazon Cognito user pool and its client ID.
    public var cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    /// The "domain" by which Cognito will refer to your users.
    public var developerProviderName: Swift.String?
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// A string that you provide.
    /// This member is required.
    public var identityPoolName: Swift.String?
    /// The tags that are assigned to the identity pool. A tag is a label that you can apply to identity pools to categorize and manage them in different ways, such as by purpose, owner, environment, or other criteria.
    public var identityPoolTags: [Swift.String:Swift.String]?
    /// The ARNs of the OpenID Connect providers.
    public var openIdConnectProviderARNs: [Swift.String]?
    /// An array of Amazon Resource Names (ARNs) of the SAML provider for your identity pool.
    public var samlProviderARNs: [Swift.String]?
    /// Optional key:value pairs mapping provider names to provider app IDs.
    public var supportedLoginProviders: [Swift.String:Swift.String]?

    public init (
        allowClassicFlow: Swift.Bool? = nil,
        allowUnauthenticatedIdentities: Swift.Bool = false,
        cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil,
        developerProviderName: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        identityPoolName: Swift.String? = nil,
        identityPoolTags: [Swift.String:Swift.String]? = nil,
        openIdConnectProviderARNs: [Swift.String]? = nil,
        samlProviderARNs: [Swift.String]? = nil,
        supportedLoginProviders: [Swift.String:Swift.String]? = nil
    )
    {
        self.allowClassicFlow = allowClassicFlow
        self.allowUnauthenticatedIdentities = allowUnauthenticatedIdentities
        self.cognitoIdentityProviders = cognitoIdentityProviders
        self.developerProviderName = developerProviderName
        self.identityPoolId = identityPoolId
        self.identityPoolName = identityPoolName
        self.identityPoolTags = identityPoolTags
        self.openIdConnectProviderARNs = openIdConnectProviderARNs
        self.samlProviderARNs = samlProviderARNs
        self.supportedLoginProviders = supportedLoginProviders
    }
}

struct CreateIdentityPoolOutputResponseBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let identityPoolName: Swift.String?
    let allowUnauthenticatedIdentities: Swift.Bool
    let allowClassicFlow: Swift.Bool?
    let supportedLoginProviders: [Swift.String:Swift.String]?
    let developerProviderName: Swift.String?
    let openIdConnectProviderARNs: [Swift.String]?
    let cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    let samlProviderARNs: [Swift.String]?
    let identityPoolTags: [Swift.String:Swift.String]?
}

extension CreateIdentityPoolOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let allowUnauthenticatedIdentitiesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowUnauthenticatedIdentities)
        allowUnauthenticatedIdentities = allowUnauthenticatedIdentitiesDecoded
        let allowClassicFlowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowClassicFlow)
        allowClassicFlow = allowClassicFlowDecoded
        let supportedLoginProvidersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .supportedLoginProviders)
        var supportedLoginProvidersDecoded0: [Swift.String:Swift.String]? = nil
        if let supportedLoginProvidersContainer = supportedLoginProvidersContainer {
            supportedLoginProvidersDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityproviderid0) in supportedLoginProvidersContainer {
                if let identityproviderid0 = identityproviderid0 {
                    supportedLoginProvidersDecoded0?[key0] = identityproviderid0
                }
            }
        }
        supportedLoginProviders = supportedLoginProvidersDecoded0
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let openIdConnectProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .openIdConnectProviderARNs)
        var openIdConnectProviderARNsDecoded0:[Swift.String]? = nil
        if let openIdConnectProviderARNsContainer = openIdConnectProviderARNsContainer {
            openIdConnectProviderARNsDecoded0 = [Swift.String]()
            for string0 in openIdConnectProviderARNsContainer {
                if let string0 = string0 {
                    openIdConnectProviderARNsDecoded0?.append(string0)
                }
            }
        }
        openIdConnectProviderARNs = openIdConnectProviderARNsDecoded0
        let cognitoIdentityProvidersContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.CognitoIdentityProvider?].self, forKey: .cognitoIdentityProviders)
        var cognitoIdentityProvidersDecoded0:[CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil
        if let cognitoIdentityProvidersContainer = cognitoIdentityProvidersContainer {
            cognitoIdentityProvidersDecoded0 = [CognitoIdentityClientTypes.CognitoIdentityProvider]()
            for structure0 in cognitoIdentityProvidersContainer {
                if let structure0 = structure0 {
                    cognitoIdentityProvidersDecoded0?.append(structure0)
                }
            }
        }
        cognitoIdentityProviders = cognitoIdentityProvidersDecoded0
        let samlProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .samlProviderARNs)
        var samlProviderARNsDecoded0:[Swift.String]? = nil
        if let samlProviderARNsContainer = samlProviderARNsContainer {
            samlProviderARNsDecoded0 = [Swift.String]()
            for string0 in samlProviderARNsContainer {
                if let string0 = string0 {
                    samlProviderARNsDecoded0?.append(string0)
                }
            }
        }
        samlProviderARNs = samlProviderARNsDecoded0
        let identityPoolTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityPoolTags)
        var identityPoolTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityPoolTagsContainer = identityPoolTagsContainer {
            identityPoolTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvaluetype0) in identityPoolTagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    identityPoolTagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        identityPoolTags = identityPoolTagsDecoded0
    }
}

extension CognitoIdentityClientTypes.Credentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case expiration = "Expiration"
        case secretKey = "SecretKey"
        case sessionToken = "SessionToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let expiration = expiration {
            try encodeContainer.encode(expiration.timeIntervalSince1970, forKey: .expiration)
        }
        if let secretKey = secretKey {
            try encodeContainer.encode(secretKey, forKey: .secretKey)
        }
        if let sessionToken = sessionToken {
            try encodeContainer.encode(sessionToken, forKey: .sessionToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let secretKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretKey)
        secretKey = secretKeyDecoded
        let sessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expiration)
        expiration = expirationDecoded
    }
}

extension CognitoIdentityClientTypes {
    /// Credentials for the provided identity ID.
    public struct Credentials: Swift.Equatable {
        /// The Access Key portion of the credentials.
        public var accessKeyId: Swift.String?
        /// The date at which these credentials will expire.
        public var expiration: ClientRuntime.Date?
        /// The Secret Access Key portion of the credentials
        public var secretKey: Swift.String?
        /// The Session Token portion of the credentials
        public var sessionToken: Swift.String?

        public init (
            accessKeyId: Swift.String? = nil,
            expiration: ClientRuntime.Date? = nil,
            secretKey: Swift.String? = nil,
            sessionToken: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.expiration = expiration
            self.secretKey = secretKey
            self.sessionToken = sessionToken
        }
    }

}

extension DeleteIdentitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityIdsToDelete = "IdentityIdsToDelete"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityIdsToDelete = identityIdsToDelete {
            var identityIdsToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identityIdsToDelete)
            for identityidlist0 in identityIdsToDelete {
                try identityIdsToDeleteContainer.encode(identityidlist0)
            }
        }
    }
}

extension DeleteIdentitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the DeleteIdentities action.
public struct DeleteIdentitiesInput: Swift.Equatable {
    /// A list of 1-60 identities that you want to delete.
    /// This member is required.
    public var identityIdsToDelete: [Swift.String]?

    public init (
        identityIdsToDelete: [Swift.String]? = nil
    )
    {
        self.identityIdsToDelete = identityIdsToDelete
    }
}

struct DeleteIdentitiesInputBody: Swift.Equatable {
    let identityIdsToDelete: [Swift.String]?
}

extension DeleteIdentitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityIdsToDelete = "IdentityIdsToDelete"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdsToDeleteContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identityIdsToDelete)
        var identityIdsToDeleteDecoded0:[Swift.String]? = nil
        if let identityIdsToDeleteContainer = identityIdsToDeleteContainer {
            identityIdsToDeleteDecoded0 = [Swift.String]()
            for string0 in identityIdsToDeleteContainer {
                if let string0 = string0 {
                    identityIdsToDeleteDecoded0?.append(string0)
                }
            }
        }
        identityIdsToDelete = identityIdsToDeleteDecoded0
    }
}

extension DeleteIdentitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIdentitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIdentitiesOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIdentitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteIdentitiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedIdentityIds = output.unprocessedIdentityIds
        } else {
            self.unprocessedIdentityIds = nil
        }
    }
}

/// Returned in response to a successful DeleteIdentities operation.
public struct DeleteIdentitiesOutputResponse: Swift.Equatable {
    /// An array of UnprocessedIdentityId objects, each of which contains an ErrorCode and IdentityId.
    public var unprocessedIdentityIds: [CognitoIdentityClientTypes.UnprocessedIdentityId]?

    public init (
        unprocessedIdentityIds: [CognitoIdentityClientTypes.UnprocessedIdentityId]? = nil
    )
    {
        self.unprocessedIdentityIds = unprocessedIdentityIds
    }
}

struct DeleteIdentitiesOutputResponseBody: Swift.Equatable {
    let unprocessedIdentityIds: [CognitoIdentityClientTypes.UnprocessedIdentityId]?
}

extension DeleteIdentitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedIdentityIds = "UnprocessedIdentityIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedIdentityIdsContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.UnprocessedIdentityId?].self, forKey: .unprocessedIdentityIds)
        var unprocessedIdentityIdsDecoded0:[CognitoIdentityClientTypes.UnprocessedIdentityId]? = nil
        if let unprocessedIdentityIdsContainer = unprocessedIdentityIdsContainer {
            unprocessedIdentityIdsDecoded0 = [CognitoIdentityClientTypes.UnprocessedIdentityId]()
            for structure0 in unprocessedIdentityIdsContainer {
                if let structure0 = structure0 {
                    unprocessedIdentityIdsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedIdentityIds = unprocessedIdentityIdsDecoded0
    }
}

extension DeleteIdentityPoolInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
    }
}

extension DeleteIdentityPoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the DeleteIdentityPool action.
public struct DeleteIdentityPoolInput: Swift.Equatable {
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init (
        identityPoolId: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct DeleteIdentityPoolInputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
}

extension DeleteIdentityPoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
    }
}

extension DeleteIdentityPoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIdentityPoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIdentityPoolOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIdentityPoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIdentityPoolOutputResponse: Swift.Equatable {

}

extension DescribeIdentityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
    }
}

extension DescribeIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the DescribeIdentity action.
public struct DescribeIdentityInput: Swift.Equatable {
    /// A unique identifier in the format REGION:GUID.
    /// This member is required.
    public var identityId: Swift.String?

    public init (
        identityId: Swift.String? = nil
    )
    {
        self.identityId = identityId
    }
}

struct DescribeIdentityInputBody: Swift.Equatable {
    let identityId: Swift.String?
}

extension DescribeIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
    }
}

extension DescribeIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIdentityOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeIdentityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.identityId = output.identityId
            self.lastModifiedDate = output.lastModifiedDate
            self.logins = output.logins
        } else {
            self.creationDate = nil
            self.identityId = nil
            self.lastModifiedDate = nil
            self.logins = nil
        }
    }
}

/// A description of the identity.
public struct DescribeIdentityOutputResponse: Swift.Equatable {
    /// Date on which the identity was created.
    public var creationDate: ClientRuntime.Date?
    /// A unique identifier in the format REGION:GUID.
    public var identityId: Swift.String?
    /// Date on which the identity was last modified.
    public var lastModifiedDate: ClientRuntime.Date?
    /// The provider names.
    public var logins: [Swift.String]?

    public init (
        creationDate: ClientRuntime.Date? = nil,
        identityId: Swift.String? = nil,
        lastModifiedDate: ClientRuntime.Date? = nil,
        logins: [Swift.String]? = nil
    )
    {
        self.creationDate = creationDate
        self.identityId = identityId
        self.lastModifiedDate = lastModifiedDate
        self.logins = logins
    }
}

struct DescribeIdentityOutputResponseBody: Swift.Equatable {
    let identityId: Swift.String?
    let logins: [Swift.String]?
    let creationDate: ClientRuntime.Date?
    let lastModifiedDate: ClientRuntime.Date?
}

extension DescribeIdentityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case identityId = "IdentityId"
        case lastModifiedDate = "LastModifiedDate"
        case logins = "Logins"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .logins)
        var loginsDecoded0:[Swift.String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [Swift.String]()
            for string0 in loginsContainer {
                if let string0 = string0 {
                    loginsDecoded0?.append(string0)
                }
            }
        }
        logins = loginsDecoded0
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension DescribeIdentityPoolInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
    }
}

extension DescribeIdentityPoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the DescribeIdentityPool action.
public struct DescribeIdentityPoolInput: Swift.Equatable {
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init (
        identityPoolId: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct DescribeIdentityPoolInputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
}

extension DescribeIdentityPoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
    }
}

extension DescribeIdentityPoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIdentityPoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIdentityPoolOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIdentityPoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeIdentityPoolOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.allowClassicFlow = output.allowClassicFlow
            self.allowUnauthenticatedIdentities = output.allowUnauthenticatedIdentities
            self.cognitoIdentityProviders = output.cognitoIdentityProviders
            self.developerProviderName = output.developerProviderName
            self.identityPoolId = output.identityPoolId
            self.identityPoolName = output.identityPoolName
            self.identityPoolTags = output.identityPoolTags
            self.openIdConnectProviderARNs = output.openIdConnectProviderARNs
            self.samlProviderARNs = output.samlProviderARNs
            self.supportedLoginProviders = output.supportedLoginProviders
        } else {
            self.allowClassicFlow = nil
            self.allowUnauthenticatedIdentities = false
            self.cognitoIdentityProviders = nil
            self.developerProviderName = nil
            self.identityPoolId = nil
            self.identityPoolName = nil
            self.identityPoolTags = nil
            self.openIdConnectProviderARNs = nil
            self.samlProviderARNs = nil
            self.supportedLoginProviders = nil
        }
    }
}

/// An object representing an Amazon Cognito identity pool.
public struct DescribeIdentityPoolOutputResponse: Swift.Equatable {
    /// Enables or disables the Basic (Classic) authentication flow. For more information, see [Identity Pools (Federated Identities) Authentication Flow](https://docs.aws.amazon.com/cognito/latest/developerguide/authentication-flow.html) in the Amazon Cognito Developer Guide.
    public var allowClassicFlow: Swift.Bool?
    /// TRUE if the identity pool supports unauthenticated logins.
    /// This member is required.
    public var allowUnauthenticatedIdentities: Swift.Bool
    /// A list representing an Amazon Cognito user pool and its client ID.
    public var cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    /// The "domain" by which Cognito will refer to your users.
    public var developerProviderName: Swift.String?
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// A string that you provide.
    /// This member is required.
    public var identityPoolName: Swift.String?
    /// The tags that are assigned to the identity pool. A tag is a label that you can apply to identity pools to categorize and manage them in different ways, such as by purpose, owner, environment, or other criteria.
    public var identityPoolTags: [Swift.String:Swift.String]?
    /// The ARNs of the OpenID Connect providers.
    public var openIdConnectProviderARNs: [Swift.String]?
    /// An array of Amazon Resource Names (ARNs) of the SAML provider for your identity pool.
    public var samlProviderARNs: [Swift.String]?
    /// Optional key:value pairs mapping provider names to provider app IDs.
    public var supportedLoginProviders: [Swift.String:Swift.String]?

    public init (
        allowClassicFlow: Swift.Bool? = nil,
        allowUnauthenticatedIdentities: Swift.Bool = false,
        cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil,
        developerProviderName: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        identityPoolName: Swift.String? = nil,
        identityPoolTags: [Swift.String:Swift.String]? = nil,
        openIdConnectProviderARNs: [Swift.String]? = nil,
        samlProviderARNs: [Swift.String]? = nil,
        supportedLoginProviders: [Swift.String:Swift.String]? = nil
    )
    {
        self.allowClassicFlow = allowClassicFlow
        self.allowUnauthenticatedIdentities = allowUnauthenticatedIdentities
        self.cognitoIdentityProviders = cognitoIdentityProviders
        self.developerProviderName = developerProviderName
        self.identityPoolId = identityPoolId
        self.identityPoolName = identityPoolName
        self.identityPoolTags = identityPoolTags
        self.openIdConnectProviderARNs = openIdConnectProviderARNs
        self.samlProviderARNs = samlProviderARNs
        self.supportedLoginProviders = supportedLoginProviders
    }
}

struct DescribeIdentityPoolOutputResponseBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let identityPoolName: Swift.String?
    let allowUnauthenticatedIdentities: Swift.Bool
    let allowClassicFlow: Swift.Bool?
    let supportedLoginProviders: [Swift.String:Swift.String]?
    let developerProviderName: Swift.String?
    let openIdConnectProviderARNs: [Swift.String]?
    let cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    let samlProviderARNs: [Swift.String]?
    let identityPoolTags: [Swift.String:Swift.String]?
}

extension DescribeIdentityPoolOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let allowUnauthenticatedIdentitiesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowUnauthenticatedIdentities)
        allowUnauthenticatedIdentities = allowUnauthenticatedIdentitiesDecoded
        let allowClassicFlowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowClassicFlow)
        allowClassicFlow = allowClassicFlowDecoded
        let supportedLoginProvidersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .supportedLoginProviders)
        var supportedLoginProvidersDecoded0: [Swift.String:Swift.String]? = nil
        if let supportedLoginProvidersContainer = supportedLoginProvidersContainer {
            supportedLoginProvidersDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityproviderid0) in supportedLoginProvidersContainer {
                if let identityproviderid0 = identityproviderid0 {
                    supportedLoginProvidersDecoded0?[key0] = identityproviderid0
                }
            }
        }
        supportedLoginProviders = supportedLoginProvidersDecoded0
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let openIdConnectProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .openIdConnectProviderARNs)
        var openIdConnectProviderARNsDecoded0:[Swift.String]? = nil
        if let openIdConnectProviderARNsContainer = openIdConnectProviderARNsContainer {
            openIdConnectProviderARNsDecoded0 = [Swift.String]()
            for string0 in openIdConnectProviderARNsContainer {
                if let string0 = string0 {
                    openIdConnectProviderARNsDecoded0?.append(string0)
                }
            }
        }
        openIdConnectProviderARNs = openIdConnectProviderARNsDecoded0
        let cognitoIdentityProvidersContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.CognitoIdentityProvider?].self, forKey: .cognitoIdentityProviders)
        var cognitoIdentityProvidersDecoded0:[CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil
        if let cognitoIdentityProvidersContainer = cognitoIdentityProvidersContainer {
            cognitoIdentityProvidersDecoded0 = [CognitoIdentityClientTypes.CognitoIdentityProvider]()
            for structure0 in cognitoIdentityProvidersContainer {
                if let structure0 = structure0 {
                    cognitoIdentityProvidersDecoded0?.append(structure0)
                }
            }
        }
        cognitoIdentityProviders = cognitoIdentityProvidersDecoded0
        let samlProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .samlProviderARNs)
        var samlProviderARNsDecoded0:[Swift.String]? = nil
        if let samlProviderARNsContainer = samlProviderARNsContainer {
            samlProviderARNsDecoded0 = [Swift.String]()
            for string0 in samlProviderARNsContainer {
                if let string0 = string0 {
                    samlProviderARNsDecoded0?.append(string0)
                }
            }
        }
        samlProviderARNs = samlProviderARNsDecoded0
        let identityPoolTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityPoolTags)
        var identityPoolTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityPoolTagsContainer = identityPoolTagsContainer {
            identityPoolTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvaluetype0) in identityPoolTagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    identityPoolTagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        identityPoolTags = identityPoolTagsDecoded0
    }
}

extension DeveloperUserAlreadyRegisteredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeveloperUserAlreadyRegisteredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The provided developer user identifier is already registered with Cognito under a different identity ID.
public struct DeveloperUserAlreadyRegisteredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This developer user identifier is already registered with Cognito.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeveloperUserAlreadyRegisteredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeveloperUserAlreadyRegisteredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CognitoIdentityClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case internalServerError
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .accessDenied,
                .internalServerError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "AccessDenied"
            case .internalServerError: return "InternalServerError"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension ExternalServiceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExternalServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception thrown when a dependent service such as Facebook or Twitter is not responding
public struct ExternalServiceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message returned by an ExternalServiceException
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ExternalServiceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ExternalServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetCredentialsForIdentityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customRoleArn = "CustomRoleArn"
        case identityId = "IdentityId"
        case logins = "Logins"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customRoleArn = customRoleArn {
            try encodeContainer.encode(customRoleArn, forKey: .customRoleArn)
        }
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logins)
            for (dictKey0, loginsmap0) in logins {
                try loginsContainer.encode(loginsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension GetCredentialsForIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the GetCredentialsForIdentity action.
public struct GetCredentialsForIdentityInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the role to be assumed when multiple roles were received in the token from the identity provider. For example, a SAML-based identity provider. This parameter is optional for identity providers that do not support role customization.
    public var customRoleArn: Swift.String?
    /// A unique identifier in the format REGION:GUID.
    /// This member is required.
    public var identityId: Swift.String?
    /// A set of optional name-value pairs that map provider names to provider tokens. The name-value pair will follow the syntax "provider_name": "provider_user_identifier". Logins should not be specified when trying to get credentials for an unauthenticated identity. The Logins parameter is required when using identities associated with external identity providers such as Facebook. For examples of Logins maps, see the code examples in the [External Identity Providers](https://docs.aws.amazon.com/cognito/latest/developerguide/external-identity-providers.html) section of the Amazon Cognito Developer Guide.
    public var logins: [Swift.String:Swift.String]?

    public init (
        customRoleArn: Swift.String? = nil,
        identityId: Swift.String? = nil,
        logins: [Swift.String:Swift.String]? = nil
    )
    {
        self.customRoleArn = customRoleArn
        self.identityId = identityId
        self.logins = logins
    }
}

struct GetCredentialsForIdentityInputBody: Swift.Equatable {
    let identityId: Swift.String?
    let logins: [Swift.String:Swift.String]?
    let customRoleArn: Swift.String?
}

extension GetCredentialsForIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customRoleArn = "CustomRoleArn"
        case identityId = "IdentityId"
        case logins = "Logins"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .logins)
        var loginsDecoded0: [Swift.String:Swift.String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityprovidertoken0) in loginsContainer {
                if let identityprovidertoken0 = identityprovidertoken0 {
                    loginsDecoded0?[key0] = identityprovidertoken0
                }
            }
        }
        logins = loginsDecoded0
        let customRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customRoleArn)
        customRoleArn = customRoleArnDecoded
    }
}

extension GetCredentialsForIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCredentialsForIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExternalServiceException" : self = .externalServiceException(try ExternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIdentityPoolConfigurationException" : self = .invalidIdentityPoolConfigurationException(try InvalidIdentityPoolConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCredentialsForIdentityOutputError: Swift.Error, Swift.Equatable {
    case externalServiceException(ExternalServiceException)
    case internalErrorException(InternalErrorException)
    case invalidIdentityPoolConfigurationException(InvalidIdentityPoolConfigurationException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCredentialsForIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCredentialsForIdentityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.credentials = output.credentials
            self.identityId = output.identityId
        } else {
            self.credentials = nil
            self.identityId = nil
        }
    }
}

/// Returned in response to a successful GetCredentialsForIdentity operation.
public struct GetCredentialsForIdentityOutputResponse: Swift.Equatable {
    /// Credentials for the provided identity ID.
    public var credentials: CognitoIdentityClientTypes.Credentials?
    /// A unique identifier in the format REGION:GUID.
    public var identityId: Swift.String?

    public init (
        credentials: CognitoIdentityClientTypes.Credentials? = nil,
        identityId: Swift.String? = nil
    )
    {
        self.credentials = credentials
        self.identityId = identityId
    }
}

struct GetCredentialsForIdentityOutputResponseBody: Swift.Equatable {
    let identityId: Swift.String?
    let credentials: CognitoIdentityClientTypes.Credentials?
}

extension GetCredentialsForIdentityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
        case identityId = "IdentityId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(CognitoIdentityClientTypes.Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
    }
}

extension GetIdInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case identityPoolId = "IdentityPoolId"
        case logins = "Logins"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logins)
            for (dictKey0, loginsmap0) in logins {
                try loginsContainer.encode(loginsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension GetIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the GetId action.
public struct GetIdInput: Swift.Equatable {
    /// A standard AWS account ID (9+ digits).
    public var accountId: Swift.String?
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// A set of optional name-value pairs that map provider names to provider tokens. The available provider names for Logins are as follows:
    ///
    /// * Facebook: graph.facebook.com
    ///
    /// * Amazon Cognito user pool: cognito-idp..amazonaws.com/, for example, cognito-idp.us-east-1.amazonaws.com/us-east-1_123456789.
    ///
    /// * Google: accounts.google.com
    ///
    /// * Amazon: www.amazon.com
    ///
    /// * Twitter: api.twitter.com
    ///
    /// * Digits: www.digits.com
    public var logins: [Swift.String:Swift.String]?

    public init (
        accountId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        logins: [Swift.String:Swift.String]? = nil
    )
    {
        self.accountId = accountId
        self.identityPoolId = identityPoolId
        self.logins = logins
    }
}

struct GetIdInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let identityPoolId: Swift.String?
    let logins: [Swift.String:Swift.String]?
}

extension GetIdInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case identityPoolId = "IdentityPoolId"
        case logins = "Logins"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .logins)
        var loginsDecoded0: [Swift.String:Swift.String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityprovidertoken0) in loginsContainer {
                if let identityprovidertoken0 = identityprovidertoken0 {
                    loginsDecoded0?[key0] = identityprovidertoken0
                }
            }
        }
        logins = loginsDecoded0
    }
}

extension GetIdOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIdOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExternalServiceException" : self = .externalServiceException(try ExternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIdOutputError: Swift.Error, Swift.Equatable {
    case externalServiceException(ExternalServiceException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIdOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetIdOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityId = output.identityId
        } else {
            self.identityId = nil
        }
    }
}

/// Returned in response to a GetId request.
public struct GetIdOutputResponse: Swift.Equatable {
    /// A unique identifier in the format REGION:GUID.
    public var identityId: Swift.String?

    public init (
        identityId: Swift.String? = nil
    )
    {
        self.identityId = identityId
    }
}

struct GetIdOutputResponseBody: Swift.Equatable {
    let identityId: Swift.String?
}

extension GetIdOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
    }
}

extension GetIdentityPoolRolesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
    }
}

extension GetIdentityPoolRolesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the GetIdentityPoolRoles action.
public struct GetIdentityPoolRolesInput: Swift.Equatable {
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init (
        identityPoolId: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct GetIdentityPoolRolesInputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
}

extension GetIdentityPoolRolesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
    }
}

extension GetIdentityPoolRolesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIdentityPoolRolesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIdentityPoolRolesOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIdentityPoolRolesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetIdentityPoolRolesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityPoolId = output.identityPoolId
            self.roleMappings = output.roleMappings
            self.roles = output.roles
        } else {
            self.identityPoolId = nil
            self.roleMappings = nil
            self.roles = nil
        }
    }
}

/// Returned in response to a successful GetIdentityPoolRoles operation.
public struct GetIdentityPoolRolesOutputResponse: Swift.Equatable {
    /// An identity pool ID in the format REGION:GUID.
    public var identityPoolId: Swift.String?
    /// How users for a specific identity provider are to mapped to roles. This is a String-to-[RoleMapping] object map. The string identifies the identity provider, for example, "graph.facebook.com" or "cognito-idp.us-east-1.amazonaws.com/us-east-1_abcdefghi:app_client_id".
    public var roleMappings: [Swift.String:CognitoIdentityClientTypes.RoleMapping]?
    /// The map of roles associated with this pool. Currently only authenticated and unauthenticated roles are supported.
    public var roles: [Swift.String:Swift.String]?

    public init (
        identityPoolId: Swift.String? = nil,
        roleMappings: [Swift.String:CognitoIdentityClientTypes.RoleMapping]? = nil,
        roles: [Swift.String:Swift.String]? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.roleMappings = roleMappings
        self.roles = roles
    }
}

struct GetIdentityPoolRolesOutputResponseBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let roles: [Swift.String:Swift.String]?
    let roleMappings: [Swift.String:CognitoIdentityClientTypes.RoleMapping]?
}

extension GetIdentityPoolRolesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case roleMappings = "RoleMappings"
        case roles = "Roles"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let rolesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .roles)
        var rolesDecoded0: [Swift.String:Swift.String]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [Swift.String:Swift.String]()
            for (key0, arnstring0) in rolesContainer {
                if let arnstring0 = arnstring0 {
                    rolesDecoded0?[key0] = arnstring0
                }
            }
        }
        roles = rolesDecoded0
        let roleMappingsContainer = try containerValues.decodeIfPresent([Swift.String: CognitoIdentityClientTypes.RoleMapping?].self, forKey: .roleMappings)
        var roleMappingsDecoded0: [Swift.String:CognitoIdentityClientTypes.RoleMapping]? = nil
        if let roleMappingsContainer = roleMappingsContainer {
            roleMappingsDecoded0 = [Swift.String:CognitoIdentityClientTypes.RoleMapping]()
            for (key0, rolemapping0) in roleMappingsContainer {
                if let rolemapping0 = rolemapping0 {
                    roleMappingsDecoded0?[key0] = rolemapping0
                }
            }
        }
        roleMappings = roleMappingsDecoded0
    }
}

extension GetOpenIdTokenForDeveloperIdentityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
        case logins = "Logins"
        case principalTags = "PrincipalTags"
        case tokenDuration = "TokenDuration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logins)
            for (dictKey0, loginsmap0) in logins {
                try loginsContainer.encode(loginsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let principalTags = principalTags {
            var principalTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .principalTags)
            for (dictKey0, principaltags0) in principalTags {
                try principalTagsContainer.encode(principaltags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tokenDuration = tokenDuration {
            try encodeContainer.encode(tokenDuration, forKey: .tokenDuration)
        }
    }
}

extension GetOpenIdTokenForDeveloperIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the GetOpenIdTokenForDeveloperIdentity action.
public struct GetOpenIdTokenForDeveloperIdentityInput: Swift.Equatable {
    /// A unique identifier in the format REGION:GUID.
    public var identityId: Swift.String?
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// A set of optional name-value pairs that map provider names to provider tokens. Each name-value pair represents a user from a public provider or developer provider. If the user is from a developer provider, the name-value pair will follow the syntax "developer_provider_name": "developer_user_identifier". The developer provider is the "domain" by which Cognito will refer to your users; you provided this domain while creating/updating the identity pool. The developer user identifier is an identifier from your backend that uniquely identifies a user. When you create an identity pool, you can specify the supported logins.
    /// This member is required.
    public var logins: [Swift.String:Swift.String]?
    /// Use this operation to configure attribute mappings for custom providers.
    public var principalTags: [Swift.String:Swift.String]?
    /// The expiration time of the token, in seconds. You can specify a custom expiration time for the token so that you can cache it. If you don't provide an expiration time, the token is valid for 15 minutes. You can exchange the token with Amazon STS for temporary AWS credentials, which are valid for a maximum of one hour. The maximum token duration you can set is 24 hours. You should take care in setting the expiration time for a token, as there are significant security implications: an attacker could use a leaked token to access your AWS resources for the token's duration. Please provide for a small grace period, usually no more than 5 minutes, to account for clock skew.
    public var tokenDuration: Swift.Int?

    public init (
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        logins: [Swift.String:Swift.String]? = nil,
        principalTags: [Swift.String:Swift.String]? = nil,
        tokenDuration: Swift.Int? = nil
    )
    {
        self.identityId = identityId
        self.identityPoolId = identityPoolId
        self.logins = logins
        self.principalTags = principalTags
        self.tokenDuration = tokenDuration
    }
}

struct GetOpenIdTokenForDeveloperIdentityInputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let identityId: Swift.String?
    let logins: [Swift.String:Swift.String]?
    let principalTags: [Swift.String:Swift.String]?
    let tokenDuration: Swift.Int?
}

extension GetOpenIdTokenForDeveloperIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
        case logins = "Logins"
        case principalTags = "PrincipalTags"
        case tokenDuration = "TokenDuration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .logins)
        var loginsDecoded0: [Swift.String:Swift.String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityprovidertoken0) in loginsContainer {
                if let identityprovidertoken0 = identityprovidertoken0 {
                    loginsDecoded0?[key0] = identityprovidertoken0
                }
            }
        }
        logins = loginsDecoded0
        let principalTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .principalTags)
        var principalTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let principalTagsContainer = principalTagsContainer {
            principalTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, principaltagvalue0) in principalTagsContainer {
                if let principaltagvalue0 = principaltagvalue0 {
                    principalTagsDecoded0?[key0] = principaltagvalue0
                }
            }
        }
        principalTags = principalTagsDecoded0
        let tokenDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tokenDuration)
        tokenDuration = tokenDurationDecoded
    }
}

extension GetOpenIdTokenForDeveloperIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOpenIdTokenForDeveloperIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DeveloperUserAlreadyRegisteredException" : self = .developerUserAlreadyRegisteredException(try DeveloperUserAlreadyRegisteredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOpenIdTokenForDeveloperIdentityOutputError: Swift.Error, Swift.Equatable {
    case developerUserAlreadyRegisteredException(DeveloperUserAlreadyRegisteredException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOpenIdTokenForDeveloperIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetOpenIdTokenForDeveloperIdentityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityId = output.identityId
            self.token = output.token
        } else {
            self.identityId = nil
            self.token = nil
        }
    }
}

/// Returned in response to a successful GetOpenIdTokenForDeveloperIdentity request.
public struct GetOpenIdTokenForDeveloperIdentityOutputResponse: Swift.Equatable {
    /// A unique identifier in the format REGION:GUID.
    public var identityId: Swift.String?
    /// An OpenID token.
    public var token: Swift.String?

    public init (
        identityId: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.identityId = identityId
        self.token = token
    }
}

struct GetOpenIdTokenForDeveloperIdentityOutputResponseBody: Swift.Equatable {
    let identityId: Swift.String?
    let token: Swift.String?
}

extension GetOpenIdTokenForDeveloperIdentityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case token = "Token"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
    }
}

extension GetOpenIdTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case logins = "Logins"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logins)
            for (dictKey0, loginsmap0) in logins {
                try loginsContainer.encode(loginsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension GetOpenIdTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the GetOpenIdToken action.
public struct GetOpenIdTokenInput: Swift.Equatable {
    /// A unique identifier in the format REGION:GUID.
    /// This member is required.
    public var identityId: Swift.String?
    /// A set of optional name-value pairs that map provider names to provider tokens. When using graph.facebook.com and www.amazon.com, supply the access_token returned from the provider's authflow. For accounts.google.com, an Amazon Cognito user pool provider, or any other OpenID Connect provider, always include the id_token.
    public var logins: [Swift.String:Swift.String]?

    public init (
        identityId: Swift.String? = nil,
        logins: [Swift.String:Swift.String]? = nil
    )
    {
        self.identityId = identityId
        self.logins = logins
    }
}

struct GetOpenIdTokenInputBody: Swift.Equatable {
    let identityId: Swift.String?
    let logins: [Swift.String:Swift.String]?
}

extension GetOpenIdTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case logins = "Logins"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .logins)
        var loginsDecoded0: [Swift.String:Swift.String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityprovidertoken0) in loginsContainer {
                if let identityprovidertoken0 = identityprovidertoken0 {
                    loginsDecoded0?[key0] = identityprovidertoken0
                }
            }
        }
        logins = loginsDecoded0
    }
}

extension GetOpenIdTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOpenIdTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExternalServiceException" : self = .externalServiceException(try ExternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOpenIdTokenOutputError: Swift.Error, Swift.Equatable {
    case externalServiceException(ExternalServiceException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOpenIdTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetOpenIdTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityId = output.identityId
            self.token = output.token
        } else {
            self.identityId = nil
            self.token = nil
        }
    }
}

/// Returned in response to a successful GetOpenIdToken request.
public struct GetOpenIdTokenOutputResponse: Swift.Equatable {
    /// A unique identifier in the format REGION:GUID. Note that the IdentityId returned may not match the one passed on input.
    public var identityId: Swift.String?
    /// An OpenID token, valid for 10 minutes.
    public var token: Swift.String?

    public init (
        identityId: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.identityId = identityId
        self.token = token
    }
}

struct GetOpenIdTokenOutputResponseBody: Swift.Equatable {
    let identityId: Swift.String?
    let token: Swift.String?
}

extension GetOpenIdTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case token = "Token"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
    }
}

extension GetPrincipalTagAttributeMapInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let identityProviderName = identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
    }
}

extension GetPrincipalTagAttributeMapInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPrincipalTagAttributeMapInput: Swift.Equatable {
    /// You can use this operation to get the ID of the Identity Pool you setup attribute mappings for.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// You can use this operation to get the provider name.
    /// This member is required.
    public var identityProviderName: Swift.String?

    public init (
        identityPoolId: Swift.String? = nil,
        identityProviderName: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.identityProviderName = identityProviderName
    }
}

struct GetPrincipalTagAttributeMapInputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let identityProviderName: Swift.String?
}

extension GetPrincipalTagAttributeMapInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
    }
}

extension GetPrincipalTagAttributeMapOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPrincipalTagAttributeMapOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPrincipalTagAttributeMapOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPrincipalTagAttributeMapOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPrincipalTagAttributeMapOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityPoolId = output.identityPoolId
            self.identityProviderName = output.identityProviderName
            self.principalTags = output.principalTags
            self.useDefaults = output.useDefaults
        } else {
            self.identityPoolId = nil
            self.identityProviderName = nil
            self.principalTags = nil
            self.useDefaults = nil
        }
    }
}

public struct GetPrincipalTagAttributeMapOutputResponse: Swift.Equatable {
    /// You can use this operation to get the ID of the Identity Pool you setup attribute mappings for.
    public var identityPoolId: Swift.String?
    /// You can use this operation to get the provider name.
    public var identityProviderName: Swift.String?
    /// You can use this operation to add principal tags. The PrincipalTagsoperation enables you to reference user attributes in your IAM permissions policy.
    public var principalTags: [Swift.String:Swift.String]?
    /// You can use this operation to list
    public var useDefaults: Swift.Bool?

    public init (
        identityPoolId: Swift.String? = nil,
        identityProviderName: Swift.String? = nil,
        principalTags: [Swift.String:Swift.String]? = nil,
        useDefaults: Swift.Bool? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.identityProviderName = identityProviderName
        self.principalTags = principalTags
        self.useDefaults = useDefaults
    }
}

struct GetPrincipalTagAttributeMapOutputResponseBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let identityProviderName: Swift.String?
    let useDefaults: Swift.Bool?
    let principalTags: [Swift.String:Swift.String]?
}

extension GetPrincipalTagAttributeMapOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
        case principalTags = "PrincipalTags"
        case useDefaults = "UseDefaults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let useDefaultsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaults)
        useDefaults = useDefaultsDecoded
        let principalTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .principalTags)
        var principalTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let principalTagsContainer = principalTagsContainer {
            principalTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, principaltagvalue0) in principalTagsContainer {
                if let principaltagvalue0 = principaltagvalue0 {
                    principalTagsDecoded0?[key0] = principaltagvalue0
                }
            }
        }
        principalTags = principalTagsDecoded0
    }
}

extension CognitoIdentityClientTypes.IdentityDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case identityId = "IdentityId"
        case lastModifiedDate = "LastModifiedDate"
        case logins = "Logins"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logins)
            for loginslist0 in logins {
                try loginsContainer.encode(loginslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .logins)
        var loginsDecoded0:[Swift.String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [Swift.String]()
            for string0 in loginsContainer {
                if let string0 = string0 {
                    loginsDecoded0?.append(string0)
                }
            }
        }
        logins = loginsDecoded0
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension CognitoIdentityClientTypes {
    /// A description of the identity.
    public struct IdentityDescription: Swift.Equatable {
        /// Date on which the identity was created.
        public var creationDate: ClientRuntime.Date?
        /// A unique identifier in the format REGION:GUID.
        public var identityId: Swift.String?
        /// Date on which the identity was last modified.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The provider names.
        public var logins: [Swift.String]?

        public init (
            creationDate: ClientRuntime.Date? = nil,
            identityId: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            logins: [Swift.String]? = nil
        )
        {
            self.creationDate = creationDate
            self.identityId = identityId
            self.lastModifiedDate = lastModifiedDate
            self.logins = logins
        }
    }

}

extension CognitoIdentityClientTypes.IdentityPoolShortDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let identityPoolName = identityPoolName {
            try encodeContainer.encode(identityPoolName, forKey: .identityPoolName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
    }
}

extension CognitoIdentityClientTypes {
    /// A description of the identity pool.
    public struct IdentityPoolShortDescription: Swift.Equatable {
        /// An identity pool ID in the format REGION:GUID.
        public var identityPoolId: Swift.String?
        /// A string that you provide.
        public var identityPoolName: Swift.String?

        public init (
            identityPoolId: Swift.String? = nil,
            identityPoolName: Swift.String? = nil
        )
        {
            self.identityPoolId = identityPoolId
            self.identityPoolName = identityPoolName
        }
    }

}

extension InternalErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown when the service encounters an error during processing the request.
public struct InternalErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The message returned by an InternalErrorException.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidIdentityPoolConfigurationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidIdentityPoolConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown if the identity pool has no role associated for the given auth type (auth/unauth) or if the AssumeRole fails.
public struct InvalidIdentityPoolConfigurationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message returned for an InvalidIdentityPoolConfigurationException
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidIdentityPoolConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidIdentityPoolConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown for missing or bad input parameter(s).
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message returned by an InvalidParameterException.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown when the total number of user pools has exceeded a preset limit.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message returned by a LimitExceededException.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListIdentitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hideDisabled = "HideDisabled"
        case identityPoolId = "IdentityPoolId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if hideDisabled != false {
            try encodeContainer.encode(hideDisabled, forKey: .hideDisabled)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListIdentitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the ListIdentities action.
public struct ListIdentitiesInput: Swift.Equatable {
    /// An optional boolean parameter that allows you to hide disabled identities. If omitted, the ListIdentities API will include disabled identities in the response.
    public var hideDisabled: Swift.Bool
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// The maximum number of identities to return.
    /// This member is required.
    public var maxResults: Swift.Int
    /// A pagination token.
    public var nextToken: Swift.String?

    public init (
        hideDisabled: Swift.Bool = false,
        identityPoolId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.hideDisabled = hideDisabled
        self.identityPoolId = identityPoolId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIdentitiesInputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
    let hideDisabled: Swift.Bool
}

extension ListIdentitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hideDisabled = "HideDisabled"
        case identityPoolId = "IdentityPoolId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let hideDisabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .hideDisabled)
        hideDisabled = hideDisabledDecoded
    }
}

extension ListIdentitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIdentitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIdentitiesOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIdentitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListIdentitiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identities = output.identities
            self.identityPoolId = output.identityPoolId
            self.nextToken = output.nextToken
        } else {
            self.identities = nil
            self.identityPoolId = nil
            self.nextToken = nil
        }
    }
}

/// The response to a ListIdentities request.
public struct ListIdentitiesOutputResponse: Swift.Equatable {
    /// An object containing a set of identities and associated mappings.
    public var identities: [CognitoIdentityClientTypes.IdentityDescription]?
    /// An identity pool ID in the format REGION:GUID.
    public var identityPoolId: Swift.String?
    /// A pagination token.
    public var nextToken: Swift.String?

    public init (
        identities: [CognitoIdentityClientTypes.IdentityDescription]? = nil,
        identityPoolId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.identities = identities
        self.identityPoolId = identityPoolId
        self.nextToken = nextToken
    }
}

struct ListIdentitiesOutputResponseBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let identities: [CognitoIdentityClientTypes.IdentityDescription]?
    let nextToken: Swift.String?
}

extension ListIdentitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identities = "Identities"
        case identityPoolId = "IdentityPoolId"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identitiesContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.IdentityDescription?].self, forKey: .identities)
        var identitiesDecoded0:[CognitoIdentityClientTypes.IdentityDescription]? = nil
        if let identitiesContainer = identitiesContainer {
            identitiesDecoded0 = [CognitoIdentityClientTypes.IdentityDescription]()
            for structure0 in identitiesContainer {
                if let structure0 = structure0 {
                    identitiesDecoded0?.append(structure0)
                }
            }
        }
        identities = identitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIdentityPoolsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListIdentityPoolsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the ListIdentityPools action.
public struct ListIdentityPoolsInput: Swift.Equatable {
    /// The maximum number of identities to return.
    /// This member is required.
    public var maxResults: Swift.Int
    /// A pagination token.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIdentityPoolsInputBody: Swift.Equatable {
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension ListIdentityPoolsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIdentityPoolsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIdentityPoolsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIdentityPoolsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIdentityPoolsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListIdentityPoolsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityPools = output.identityPools
            self.nextToken = output.nextToken
        } else {
            self.identityPools = nil
            self.nextToken = nil
        }
    }
}

/// The result of a successful ListIdentityPools action.
public struct ListIdentityPoolsOutputResponse: Swift.Equatable {
    /// The identity pools returned by the ListIdentityPools action.
    public var identityPools: [CognitoIdentityClientTypes.IdentityPoolShortDescription]?
    /// A pagination token.
    public var nextToken: Swift.String?

    public init (
        identityPools: [CognitoIdentityClientTypes.IdentityPoolShortDescription]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.identityPools = identityPools
        self.nextToken = nextToken
    }
}

struct ListIdentityPoolsOutputResponseBody: Swift.Equatable {
    let identityPools: [CognitoIdentityClientTypes.IdentityPoolShortDescription]?
    let nextToken: Swift.String?
}

extension ListIdentityPoolsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPools = "IdentityPools"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolsContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.IdentityPoolShortDescription?].self, forKey: .identityPools)
        var identityPoolsDecoded0:[CognitoIdentityClientTypes.IdentityPoolShortDescription]? = nil
        if let identityPoolsContainer = identityPoolsContainer {
            identityPoolsDecoded0 = [CognitoIdentityClientTypes.IdentityPoolShortDescription]()
            for structure0 in identityPoolsContainer {
                if let structure0 = structure0 {
                    identityPoolsDecoded0?.append(structure0)
                }
            }
        }
        identityPools = identityPoolsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the identity pool that the tags are assigned to.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags that are assigned to the identity pool.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvaluetype0) in tagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    tagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension LookupDeveloperIdentityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case developerUserIdentifier = "DeveloperUserIdentifier"
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let developerUserIdentifier = developerUserIdentifier {
            try encodeContainer.encode(developerUserIdentifier, forKey: .developerUserIdentifier)
        }
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension LookupDeveloperIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the LookupDeveloperIdentityInput action.
public struct LookupDeveloperIdentityInput: Swift.Equatable {
    /// A unique ID used by your backend authentication process to identify a user. Typically, a developer identity provider would issue many developer user identifiers, in keeping with the number of users.
    public var developerUserIdentifier: Swift.String?
    /// A unique identifier in the format REGION:GUID.
    public var identityId: Swift.String?
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// The maximum number of identities to return.
    public var maxResults: Swift.Int
    /// A pagination token. The first call you make will have NextToken set to null. After that the service will return NextToken values as needed. For example, let's say you make a request with MaxResults set to 10, and there are 20 matches in the database. The service will return a pagination token as a part of the response. This token can be used to call the API again and get results starting from the 11th match.
    public var nextToken: Swift.String?

    public init (
        developerUserIdentifier: Swift.String? = nil,
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.developerUserIdentifier = developerUserIdentifier
        self.identityId = identityId
        self.identityPoolId = identityPoolId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct LookupDeveloperIdentityInputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let identityId: Swift.String?
    let developerUserIdentifier: Swift.String?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension LookupDeveloperIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case developerUserIdentifier = "DeveloperUserIdentifier"
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let developerUserIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerUserIdentifier)
        developerUserIdentifier = developerUserIdentifierDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LookupDeveloperIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension LookupDeveloperIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum LookupDeveloperIdentityOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension LookupDeveloperIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LookupDeveloperIdentityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.developerUserIdentifierList = output.developerUserIdentifierList
            self.identityId = output.identityId
            self.nextToken = output.nextToken
        } else {
            self.developerUserIdentifierList = nil
            self.identityId = nil
            self.nextToken = nil
        }
    }
}

/// Returned in response to a successful LookupDeveloperIdentity action.
public struct LookupDeveloperIdentityOutputResponse: Swift.Equatable {
    /// This is the list of developer user identifiers associated with an identity ID. Cognito supports the association of multiple developer user identifiers with an identity ID.
    public var developerUserIdentifierList: [Swift.String]?
    /// A unique identifier in the format REGION:GUID.
    public var identityId: Swift.String?
    /// A pagination token. The first call you make will have NextToken set to null. After that the service will return NextToken values as needed. For example, let's say you make a request with MaxResults set to 10, and there are 20 matches in the database. The service will return a pagination token as a part of the response. This token can be used to call the API again and get results starting from the 11th match.
    public var nextToken: Swift.String?

    public init (
        developerUserIdentifierList: [Swift.String]? = nil,
        identityId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.developerUserIdentifierList = developerUserIdentifierList
        self.identityId = identityId
        self.nextToken = nextToken
    }
}

struct LookupDeveloperIdentityOutputResponseBody: Swift.Equatable {
    let identityId: Swift.String?
    let developerUserIdentifierList: [Swift.String]?
    let nextToken: Swift.String?
}

extension LookupDeveloperIdentityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case developerUserIdentifierList = "DeveloperUserIdentifierList"
        case identityId = "IdentityId"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let developerUserIdentifierListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .developerUserIdentifierList)
        var developerUserIdentifierListDecoded0:[Swift.String]? = nil
        if let developerUserIdentifierListContainer = developerUserIdentifierListContainer {
            developerUserIdentifierListDecoded0 = [Swift.String]()
            for string0 in developerUserIdentifierListContainer {
                if let string0 = string0 {
                    developerUserIdentifierListDecoded0?.append(string0)
                }
            }
        }
        developerUserIdentifierList = developerUserIdentifierListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CognitoIdentityClientTypes.MappingRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case claim = "Claim"
        case matchType = "MatchType"
        case roleARN = "RoleARN"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let claim = claim {
            try encodeContainer.encode(claim, forKey: .claim)
        }
        if let matchType = matchType {
            try encodeContainer.encode(matchType.rawValue, forKey: .matchType)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let claimDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .claim)
        claim = claimDecoded
        let matchTypeDecoded = try containerValues.decodeIfPresent(CognitoIdentityClientTypes.MappingRuleMatchType.self, forKey: .matchType)
        matchType = matchTypeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension CognitoIdentityClientTypes {
    /// A rule that maps a claim name, a claim value, and a match type to a role ARN.
    public struct MappingRule: Swift.Equatable {
        /// The claim name that must be present in the token, for example, "isAdmin" or "paid".
        /// This member is required.
        public var claim: Swift.String?
        /// The match condition that specifies how closely the claim value in the IdP token must match Value.
        /// This member is required.
        public var matchType: CognitoIdentityClientTypes.MappingRuleMatchType?
        /// The role ARN.
        /// This member is required.
        public var roleARN: Swift.String?
        /// A brief string that the claim must match, for example, "paid" or "yes".
        /// This member is required.
        public var value: Swift.String?

        public init (
            claim: Swift.String? = nil,
            matchType: CognitoIdentityClientTypes.MappingRuleMatchType? = nil,
            roleARN: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.claim = claim
            self.matchType = matchType
            self.roleARN = roleARN
            self.value = value
        }
    }

}

extension CognitoIdentityClientTypes {
    public enum MappingRuleMatchType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contains
        case equals
        case notEqual
        case startsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [MappingRuleMatchType] {
            return [
                .contains,
                .equals,
                .notEqual,
                .startsWith,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "Contains"
            case .equals: return "Equals"
            case .notEqual: return "NotEqual"
            case .startsWith: return "StartsWith"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MappingRuleMatchType(rawValue: rawValue) ?? MappingRuleMatchType.sdkUnknown(rawValue)
        }
    }
}

extension MergeDeveloperIdentitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationUserIdentifier = "DestinationUserIdentifier"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case sourceUserIdentifier = "SourceUserIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationUserIdentifier = destinationUserIdentifier {
            try encodeContainer.encode(destinationUserIdentifier, forKey: .destinationUserIdentifier)
        }
        if let developerProviderName = developerProviderName {
            try encodeContainer.encode(developerProviderName, forKey: .developerProviderName)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let sourceUserIdentifier = sourceUserIdentifier {
            try encodeContainer.encode(sourceUserIdentifier, forKey: .sourceUserIdentifier)
        }
    }
}

extension MergeDeveloperIdentitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the MergeDeveloperIdentities action.
public struct MergeDeveloperIdentitiesInput: Swift.Equatable {
    /// User identifier for the destination user. The value should be a DeveloperUserIdentifier.
    /// This member is required.
    public var destinationUserIdentifier: Swift.String?
    /// The "domain" by which Cognito will refer to your users. This is a (pseudo) domain name that you provide while creating an identity pool. This name acts as a placeholder that allows your backend and the Cognito service to communicate about the developer provider. For the DeveloperProviderName, you can use letters as well as period (.), underscore (_), and dash (-).
    /// This member is required.
    public var developerProviderName: Swift.String?
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// User identifier for the source user. The value should be a DeveloperUserIdentifier.
    /// This member is required.
    public var sourceUserIdentifier: Swift.String?

    public init (
        destinationUserIdentifier: Swift.String? = nil,
        developerProviderName: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        sourceUserIdentifier: Swift.String? = nil
    )
    {
        self.destinationUserIdentifier = destinationUserIdentifier
        self.developerProviderName = developerProviderName
        self.identityPoolId = identityPoolId
        self.sourceUserIdentifier = sourceUserIdentifier
    }
}

struct MergeDeveloperIdentitiesInputBody: Swift.Equatable {
    let sourceUserIdentifier: Swift.String?
    let destinationUserIdentifier: Swift.String?
    let developerProviderName: Swift.String?
    let identityPoolId: Swift.String?
}

extension MergeDeveloperIdentitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationUserIdentifier = "DestinationUserIdentifier"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case sourceUserIdentifier = "SourceUserIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceUserIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceUserIdentifier)
        sourceUserIdentifier = sourceUserIdentifierDecoded
        let destinationUserIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationUserIdentifier)
        destinationUserIdentifier = destinationUserIdentifierDecoded
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
    }
}

extension MergeDeveloperIdentitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MergeDeveloperIdentitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum MergeDeveloperIdentitiesOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MergeDeveloperIdentitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MergeDeveloperIdentitiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityId = output.identityId
        } else {
            self.identityId = nil
        }
    }
}

/// Returned in response to a successful MergeDeveloperIdentities action.
public struct MergeDeveloperIdentitiesOutputResponse: Swift.Equatable {
    /// A unique identifier in the format REGION:GUID.
    public var identityId: Swift.String?

    public init (
        identityId: Swift.String? = nil
    )
    {
        self.identityId = identityId
    }
}

struct MergeDeveloperIdentitiesOutputResponseBody: Swift.Equatable {
    let identityId: Swift.String?
}

extension MergeDeveloperIdentitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
    }
}

extension NotAuthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotAuthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown when a user is not authorized to access the requested resource.
public struct NotAuthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message returned by a NotAuthorizedException
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotAuthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotAuthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown when a user tries to use a login which is already linked to another account.
public struct ResourceConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message returned by a ResourceConflictException.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown when the requested resource (for example, a dataset or record) does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message returned by a ResourceNotFoundException.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CognitoIdentityClientTypes.RoleMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ambiguousRoleResolution = "AmbiguousRoleResolution"
        case rulesConfiguration = "RulesConfiguration"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ambiguousRoleResolution = ambiguousRoleResolution {
            try encodeContainer.encode(ambiguousRoleResolution.rawValue, forKey: .ambiguousRoleResolution)
        }
        if let rulesConfiguration = rulesConfiguration {
            try encodeContainer.encode(rulesConfiguration, forKey: .rulesConfiguration)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CognitoIdentityClientTypes.RoleMappingType.self, forKey: .type)
        type = typeDecoded
        let ambiguousRoleResolutionDecoded = try containerValues.decodeIfPresent(CognitoIdentityClientTypes.AmbiguousRoleResolutionType.self, forKey: .ambiguousRoleResolution)
        ambiguousRoleResolution = ambiguousRoleResolutionDecoded
        let rulesConfigurationDecoded = try containerValues.decodeIfPresent(CognitoIdentityClientTypes.RulesConfigurationType.self, forKey: .rulesConfiguration)
        rulesConfiguration = rulesConfigurationDecoded
    }
}

extension CognitoIdentityClientTypes {
    /// A role mapping.
    public struct RoleMapping: Swift.Equatable {
        /// If you specify Token or Rules as the Type, AmbiguousRoleResolution is required. Specifies the action to be taken if either no rules match the claim value for the Rules type, or there is no cognito:preferred_role claim and there are multiple cognito:roles matches for the Token type.
        public var ambiguousRoleResolution: CognitoIdentityClientTypes.AmbiguousRoleResolutionType?
        /// The rules to be used for mapping users to roles. If you specify Rules as the role mapping type, RulesConfiguration is required.
        public var rulesConfiguration: CognitoIdentityClientTypes.RulesConfigurationType?
        /// The role mapping type. Token will use cognito:roles and cognito:preferred_role claims from the Cognito identity provider token to map groups to roles. Rules will attempt to match claims from the token to map to a role.
        /// This member is required.
        public var type: CognitoIdentityClientTypes.RoleMappingType?

        public init (
            ambiguousRoleResolution: CognitoIdentityClientTypes.AmbiguousRoleResolutionType? = nil,
            rulesConfiguration: CognitoIdentityClientTypes.RulesConfigurationType? = nil,
            type: CognitoIdentityClientTypes.RoleMappingType? = nil
        )
        {
            self.ambiguousRoleResolution = ambiguousRoleResolution
            self.rulesConfiguration = rulesConfiguration
            self.type = type
        }
    }

}

extension CognitoIdentityClientTypes {
    public enum RoleMappingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case rules
        case token
        case sdkUnknown(Swift.String)

        public static var allCases: [RoleMappingType] {
            return [
                .rules,
                .token,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .rules: return "Rules"
            case .token: return "Token"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RoleMappingType(rawValue: rawValue) ?? RoleMappingType.sdkUnknown(rawValue)
        }
    }
}

extension CognitoIdentityClientTypes.RulesConfigurationType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for mappingruleslist0 in rules {
                try rulesContainer.encode(mappingruleslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.MappingRule?].self, forKey: .rules)
        var rulesDecoded0:[CognitoIdentityClientTypes.MappingRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [CognitoIdentityClientTypes.MappingRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension CognitoIdentityClientTypes {
    /// A container for rules.
    public struct RulesConfigurationType: Swift.Equatable {
        /// An array of rules. You can specify up to 25 rules per identity provider. Rules are evaluated in order. The first one to match specifies the role.
        /// This member is required.
        public var rules: [CognitoIdentityClientTypes.MappingRule]?

        public init (
            rules: [CognitoIdentityClientTypes.MappingRule]? = nil
        )
        {
            self.rules = rules
        }
    }

}

extension SetIdentityPoolRolesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case roleMappings = "RoleMappings"
        case roles = "Roles"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let roleMappings = roleMappings {
            var roleMappingsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .roleMappings)
            for (dictKey0, rolemappingmap0) in roleMappings {
                try roleMappingsContainer.encode(rolemappingmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .roles)
            for (dictKey0, rolesmap0) in roles {
                try rolesContainer.encode(rolesmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension SetIdentityPoolRolesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the SetIdentityPoolRoles action.
public struct SetIdentityPoolRolesInput: Swift.Equatable {
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// How users for a specific identity provider are to mapped to roles. This is a string to [RoleMapping] object map. The string identifies the identity provider, for example, "graph.facebook.com" or "cognito-idp.us-east-1.amazonaws.com/us-east-1_abcdefghi:app_client_id". Up to 25 rules can be specified per identity provider.
    public var roleMappings: [Swift.String:CognitoIdentityClientTypes.RoleMapping]?
    /// The map of roles associated with this pool. For a given role, the key will be either "authenticated" or "unauthenticated" and the value will be the Role ARN.
    /// This member is required.
    public var roles: [Swift.String:Swift.String]?

    public init (
        identityPoolId: Swift.String? = nil,
        roleMappings: [Swift.String:CognitoIdentityClientTypes.RoleMapping]? = nil,
        roles: [Swift.String:Swift.String]? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.roleMappings = roleMappings
        self.roles = roles
    }
}

struct SetIdentityPoolRolesInputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let roles: [Swift.String:Swift.String]?
    let roleMappings: [Swift.String:CognitoIdentityClientTypes.RoleMapping]?
}

extension SetIdentityPoolRolesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case roleMappings = "RoleMappings"
        case roles = "Roles"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let rolesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .roles)
        var rolesDecoded0: [Swift.String:Swift.String]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [Swift.String:Swift.String]()
            for (key0, arnstring0) in rolesContainer {
                if let arnstring0 = arnstring0 {
                    rolesDecoded0?[key0] = arnstring0
                }
            }
        }
        roles = rolesDecoded0
        let roleMappingsContainer = try containerValues.decodeIfPresent([Swift.String: CognitoIdentityClientTypes.RoleMapping?].self, forKey: .roleMappings)
        var roleMappingsDecoded0: [Swift.String:CognitoIdentityClientTypes.RoleMapping]? = nil
        if let roleMappingsContainer = roleMappingsContainer {
            roleMappingsDecoded0 = [Swift.String:CognitoIdentityClientTypes.RoleMapping]()
            for (key0, rolemapping0) in roleMappingsContainer {
                if let rolemapping0 = rolemapping0 {
                    roleMappingsDecoded0?[key0] = rolemapping0
                }
            }
        }
        roleMappings = roleMappingsDecoded0
    }
}

extension SetIdentityPoolRolesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetIdentityPoolRolesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetIdentityPoolRolesOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetIdentityPoolRolesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SetIdentityPoolRolesOutputResponse: Swift.Equatable {

}

extension SetPrincipalTagAttributeMapInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
        case principalTags = "PrincipalTags"
        case useDefaults = "UseDefaults"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let identityProviderName = identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
        if let principalTags = principalTags {
            var principalTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .principalTags)
            for (dictKey0, principaltags0) in principalTags {
                try principalTagsContainer.encode(principaltags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDefaults = useDefaults {
            try encodeContainer.encode(useDefaults, forKey: .useDefaults)
        }
    }
}

extension SetPrincipalTagAttributeMapInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SetPrincipalTagAttributeMapInput: Swift.Equatable {
    /// The ID of the Identity Pool you want to set attribute mappings for.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// The provider name you want to use for attribute mappings.
    /// This member is required.
    public var identityProviderName: Swift.String?
    /// You can use this operation to add principal tags.
    public var principalTags: [Swift.String:Swift.String]?
    /// You can use this operation to use default (username and clientID) attribute mappings.
    public var useDefaults: Swift.Bool?

    public init (
        identityPoolId: Swift.String? = nil,
        identityProviderName: Swift.String? = nil,
        principalTags: [Swift.String:Swift.String]? = nil,
        useDefaults: Swift.Bool? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.identityProviderName = identityProviderName
        self.principalTags = principalTags
        self.useDefaults = useDefaults
    }
}

struct SetPrincipalTagAttributeMapInputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let identityProviderName: Swift.String?
    let useDefaults: Swift.Bool?
    let principalTags: [Swift.String:Swift.String]?
}

extension SetPrincipalTagAttributeMapInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
        case principalTags = "PrincipalTags"
        case useDefaults = "UseDefaults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let useDefaultsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaults)
        useDefaults = useDefaultsDecoded
        let principalTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .principalTags)
        var principalTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let principalTagsContainer = principalTagsContainer {
            principalTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, principaltagvalue0) in principalTagsContainer {
                if let principaltagvalue0 = principaltagvalue0 {
                    principalTagsDecoded0?[key0] = principaltagvalue0
                }
            }
        }
        principalTags = principalTagsDecoded0
    }
}

extension SetPrincipalTagAttributeMapOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetPrincipalTagAttributeMapOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetPrincipalTagAttributeMapOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetPrincipalTagAttributeMapOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SetPrincipalTagAttributeMapOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityPoolId = output.identityPoolId
            self.identityProviderName = output.identityProviderName
            self.principalTags = output.principalTags
            self.useDefaults = output.useDefaults
        } else {
            self.identityPoolId = nil
            self.identityProviderName = nil
            self.principalTags = nil
            self.useDefaults = nil
        }
    }
}

public struct SetPrincipalTagAttributeMapOutputResponse: Swift.Equatable {
    /// The ID of the Identity Pool you want to set attribute mappings for.
    public var identityPoolId: Swift.String?
    /// The provider name you want to use for attribute mappings.
    public var identityProviderName: Swift.String?
    /// You can use this operation to add principal tags. The PrincipalTagsoperation enables you to reference user attributes in your IAM permissions policy.
    public var principalTags: [Swift.String:Swift.String]?
    /// You can use this operation to select default (username and clientID) attribute mappings.
    public var useDefaults: Swift.Bool?

    public init (
        identityPoolId: Swift.String? = nil,
        identityProviderName: Swift.String? = nil,
        principalTags: [Swift.String:Swift.String]? = nil,
        useDefaults: Swift.Bool? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.identityProviderName = identityProviderName
        self.principalTags = principalTags
        self.useDefaults = useDefaults
    }
}

struct SetPrincipalTagAttributeMapOutputResponseBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let identityProviderName: Swift.String?
    let useDefaults: Swift.Bool?
    let principalTags: [Swift.String:Swift.String]?
}

extension SetPrincipalTagAttributeMapOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
        case principalTags = "PrincipalTags"
        case useDefaults = "UseDefaults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let useDefaultsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaults)
        useDefaults = useDefaultsDecoded
        let principalTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .principalTags)
        var principalTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let principalTagsContainer = principalTagsContainer {
            principalTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, principaltagvalue0) in principalTagsContainer {
                if let principaltagvalue0 = principaltagvalue0 {
                    principalTagsDecoded0?[key0] = principaltagvalue0
                }
            }
        }
        principalTags = principalTagsDecoded0
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, identitypooltagstype0) in tags {
                try tagsContainer.encode(identitypooltagstype0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the identity pool.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to assign to the identity pool.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvaluetype0) in tagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    tagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown when a request is throttled.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Message returned by a TooManyRequestsException
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnlinkDeveloperIdentityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case developerProviderName = "DeveloperProviderName"
        case developerUserIdentifier = "DeveloperUserIdentifier"
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let developerProviderName = developerProviderName {
            try encodeContainer.encode(developerProviderName, forKey: .developerProviderName)
        }
        if let developerUserIdentifier = developerUserIdentifier {
            try encodeContainer.encode(developerUserIdentifier, forKey: .developerUserIdentifier)
        }
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
    }
}

extension UnlinkDeveloperIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the UnlinkDeveloperIdentity action.
public struct UnlinkDeveloperIdentityInput: Swift.Equatable {
    /// The "domain" by which Cognito will refer to your users.
    /// This member is required.
    public var developerProviderName: Swift.String?
    /// A unique ID used by your backend authentication process to identify a user.
    /// This member is required.
    public var developerUserIdentifier: Swift.String?
    /// A unique identifier in the format REGION:GUID.
    /// This member is required.
    public var identityId: Swift.String?
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init (
        developerProviderName: Swift.String? = nil,
        developerUserIdentifier: Swift.String? = nil,
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil
    )
    {
        self.developerProviderName = developerProviderName
        self.developerUserIdentifier = developerUserIdentifier
        self.identityId = identityId
        self.identityPoolId = identityPoolId
    }
}

struct UnlinkDeveloperIdentityInputBody: Swift.Equatable {
    let identityId: Swift.String?
    let identityPoolId: Swift.String?
    let developerProviderName: Swift.String?
    let developerUserIdentifier: Swift.String?
}

extension UnlinkDeveloperIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case developerProviderName = "DeveloperProviderName"
        case developerUserIdentifier = "DeveloperUserIdentifier"
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let developerUserIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerUserIdentifier)
        developerUserIdentifier = developerUserIdentifierDecoded
    }
}

extension UnlinkDeveloperIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnlinkDeveloperIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnlinkDeveloperIdentityOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnlinkDeveloperIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UnlinkDeveloperIdentityOutputResponse: Swift.Equatable {

}

extension UnlinkIdentityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case logins = "Logins"
        case loginsToRemove = "LoginsToRemove"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logins)
            for (dictKey0, loginsmap0) in logins {
                try loginsContainer.encode(loginsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let loginsToRemove = loginsToRemove {
            var loginsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loginsToRemove)
            for loginslist0 in loginsToRemove {
                try loginsToRemoveContainer.encode(loginslist0)
            }
        }
    }
}

extension UnlinkIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the UnlinkIdentity action.
public struct UnlinkIdentityInput: Swift.Equatable {
    /// A unique identifier in the format REGION:GUID.
    /// This member is required.
    public var identityId: Swift.String?
    /// A set of optional name-value pairs that map provider names to provider tokens.
    /// This member is required.
    public var logins: [Swift.String:Swift.String]?
    /// Provider names to unlink from this identity.
    /// This member is required.
    public var loginsToRemove: [Swift.String]?

    public init (
        identityId: Swift.String? = nil,
        logins: [Swift.String:Swift.String]? = nil,
        loginsToRemove: [Swift.String]? = nil
    )
    {
        self.identityId = identityId
        self.logins = logins
        self.loginsToRemove = loginsToRemove
    }
}

struct UnlinkIdentityInputBody: Swift.Equatable {
    let identityId: Swift.String?
    let logins: [Swift.String:Swift.String]?
    let loginsToRemove: [Swift.String]?
}

extension UnlinkIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case logins = "Logins"
        case loginsToRemove = "LoginsToRemove"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .logins)
        var loginsDecoded0: [Swift.String:Swift.String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityprovidertoken0) in loginsContainer {
                if let identityprovidertoken0 = identityprovidertoken0 {
                    loginsDecoded0?[key0] = identityprovidertoken0
                }
            }
        }
        logins = loginsDecoded0
        let loginsToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .loginsToRemove)
        var loginsToRemoveDecoded0:[Swift.String]? = nil
        if let loginsToRemoveContainer = loginsToRemoveContainer {
            loginsToRemoveDecoded0 = [Swift.String]()
            for string0 in loginsToRemoveContainer {
                if let string0 = string0 {
                    loginsToRemoveDecoded0?.append(string0)
                }
            }
        }
        loginsToRemove = loginsToRemoveDecoded0
    }
}

extension UnlinkIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnlinkIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExternalServiceException" : self = .externalServiceException(try ExternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnlinkIdentityOutputError: Swift.Error, Swift.Equatable {
    case externalServiceException(ExternalServiceException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnlinkIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UnlinkIdentityOutputResponse: Swift.Equatable {

}

extension CognitoIdentityClientTypes.UnprocessedIdentityId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case identityId = "IdentityId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(CognitoIdentityClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
    }
}

extension CognitoIdentityClientTypes {
    /// An array of UnprocessedIdentityId objects, each of which contains an ErrorCode and IdentityId.
    public struct UnprocessedIdentityId: Swift.Equatable {
        /// The error code indicating the type of error that occurred.
        public var errorCode: CognitoIdentityClientTypes.ErrorCode?
        /// A unique identifier in the format REGION:GUID.
        public var identityId: Swift.String?

        public init (
            errorCode: CognitoIdentityClientTypes.ErrorCode? = nil,
            identityId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.identityId = identityId
        }
    }

}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for identitypooltagslisttype0 in tagKeys {
                try tagKeysContainer.encode(identitypooltagslisttype0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the identity pool.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to remove from the user pool.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateIdentityPoolInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowClassicFlow = allowClassicFlow {
            try encodeContainer.encode(allowClassicFlow, forKey: .allowClassicFlow)
        }
        if allowUnauthenticatedIdentities != false {
            try encodeContainer.encode(allowUnauthenticatedIdentities, forKey: .allowUnauthenticatedIdentities)
        }
        if let cognitoIdentityProviders = cognitoIdentityProviders {
            var cognitoIdentityProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cognitoIdentityProviders)
            for cognitoidentityproviderlist0 in cognitoIdentityProviders {
                try cognitoIdentityProvidersContainer.encode(cognitoidentityproviderlist0)
            }
        }
        if let developerProviderName = developerProviderName {
            try encodeContainer.encode(developerProviderName, forKey: .developerProviderName)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let identityPoolName = identityPoolName {
            try encodeContainer.encode(identityPoolName, forKey: .identityPoolName)
        }
        if let identityPoolTags = identityPoolTags {
            var identityPoolTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identityPoolTags)
            for (dictKey0, identitypooltagstype0) in identityPoolTags {
                try identityPoolTagsContainer.encode(identitypooltagstype0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let openIdConnectProviderARNs = openIdConnectProviderARNs {
            var openIdConnectProviderARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .openIdConnectProviderARNs)
            for oidcproviderlist0 in openIdConnectProviderARNs {
                try openIdConnectProviderARNsContainer.encode(oidcproviderlist0)
            }
        }
        if let samlProviderARNs = samlProviderARNs {
            var samlProviderARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .samlProviderARNs)
            for samlproviderlist0 in samlProviderARNs {
                try samlProviderARNsContainer.encode(samlproviderlist0)
            }
        }
        if let supportedLoginProviders = supportedLoginProviders {
            var supportedLoginProvidersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .supportedLoginProviders)
            for (dictKey0, identityproviders0) in supportedLoginProviders {
                try supportedLoginProvidersContainer.encode(identityproviders0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateIdentityPoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// An object representing an Amazon Cognito identity pool.
public struct UpdateIdentityPoolInput: Swift.Equatable {
    /// Enables or disables the Basic (Classic) authentication flow. For more information, see [Identity Pools (Federated Identities) Authentication Flow](https://docs.aws.amazon.com/cognito/latest/developerguide/authentication-flow.html) in the Amazon Cognito Developer Guide.
    public var allowClassicFlow: Swift.Bool?
    /// TRUE if the identity pool supports unauthenticated logins.
    /// This member is required.
    public var allowUnauthenticatedIdentities: Swift.Bool
    /// A list representing an Amazon Cognito user pool and its client ID.
    public var cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    /// The "domain" by which Cognito will refer to your users.
    public var developerProviderName: Swift.String?
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// A string that you provide.
    /// This member is required.
    public var identityPoolName: Swift.String?
    /// The tags that are assigned to the identity pool. A tag is a label that you can apply to identity pools to categorize and manage them in different ways, such as by purpose, owner, environment, or other criteria.
    public var identityPoolTags: [Swift.String:Swift.String]?
    /// The ARNs of the OpenID Connect providers.
    public var openIdConnectProviderARNs: [Swift.String]?
    /// An array of Amazon Resource Names (ARNs) of the SAML provider for your identity pool.
    public var samlProviderARNs: [Swift.String]?
    /// Optional key:value pairs mapping provider names to provider app IDs.
    public var supportedLoginProviders: [Swift.String:Swift.String]?

    public init (
        allowClassicFlow: Swift.Bool? = nil,
        allowUnauthenticatedIdentities: Swift.Bool = false,
        cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil,
        developerProviderName: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        identityPoolName: Swift.String? = nil,
        identityPoolTags: [Swift.String:Swift.String]? = nil,
        openIdConnectProviderARNs: [Swift.String]? = nil,
        samlProviderARNs: [Swift.String]? = nil,
        supportedLoginProviders: [Swift.String:Swift.String]? = nil
    )
    {
        self.allowClassicFlow = allowClassicFlow
        self.allowUnauthenticatedIdentities = allowUnauthenticatedIdentities
        self.cognitoIdentityProviders = cognitoIdentityProviders
        self.developerProviderName = developerProviderName
        self.identityPoolId = identityPoolId
        self.identityPoolName = identityPoolName
        self.identityPoolTags = identityPoolTags
        self.openIdConnectProviderARNs = openIdConnectProviderARNs
        self.samlProviderARNs = samlProviderARNs
        self.supportedLoginProviders = supportedLoginProviders
    }
}

struct UpdateIdentityPoolInputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let identityPoolName: Swift.String?
    let allowUnauthenticatedIdentities: Swift.Bool
    let allowClassicFlow: Swift.Bool?
    let supportedLoginProviders: [Swift.String:Swift.String]?
    let developerProviderName: Swift.String?
    let openIdConnectProviderARNs: [Swift.String]?
    let cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    let samlProviderARNs: [Swift.String]?
    let identityPoolTags: [Swift.String:Swift.String]?
}

extension UpdateIdentityPoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let allowUnauthenticatedIdentitiesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowUnauthenticatedIdentities)
        allowUnauthenticatedIdentities = allowUnauthenticatedIdentitiesDecoded
        let allowClassicFlowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowClassicFlow)
        allowClassicFlow = allowClassicFlowDecoded
        let supportedLoginProvidersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .supportedLoginProviders)
        var supportedLoginProvidersDecoded0: [Swift.String:Swift.String]? = nil
        if let supportedLoginProvidersContainer = supportedLoginProvidersContainer {
            supportedLoginProvidersDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityproviderid0) in supportedLoginProvidersContainer {
                if let identityproviderid0 = identityproviderid0 {
                    supportedLoginProvidersDecoded0?[key0] = identityproviderid0
                }
            }
        }
        supportedLoginProviders = supportedLoginProvidersDecoded0
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let openIdConnectProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .openIdConnectProviderARNs)
        var openIdConnectProviderARNsDecoded0:[Swift.String]? = nil
        if let openIdConnectProviderARNsContainer = openIdConnectProviderARNsContainer {
            openIdConnectProviderARNsDecoded0 = [Swift.String]()
            for string0 in openIdConnectProviderARNsContainer {
                if let string0 = string0 {
                    openIdConnectProviderARNsDecoded0?.append(string0)
                }
            }
        }
        openIdConnectProviderARNs = openIdConnectProviderARNsDecoded0
        let cognitoIdentityProvidersContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.CognitoIdentityProvider?].self, forKey: .cognitoIdentityProviders)
        var cognitoIdentityProvidersDecoded0:[CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil
        if let cognitoIdentityProvidersContainer = cognitoIdentityProvidersContainer {
            cognitoIdentityProvidersDecoded0 = [CognitoIdentityClientTypes.CognitoIdentityProvider]()
            for structure0 in cognitoIdentityProvidersContainer {
                if let structure0 = structure0 {
                    cognitoIdentityProvidersDecoded0?.append(structure0)
                }
            }
        }
        cognitoIdentityProviders = cognitoIdentityProvidersDecoded0
        let samlProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .samlProviderARNs)
        var samlProviderARNsDecoded0:[Swift.String]? = nil
        if let samlProviderARNsContainer = samlProviderARNsContainer {
            samlProviderARNsDecoded0 = [Swift.String]()
            for string0 in samlProviderARNsContainer {
                if let string0 = string0 {
                    samlProviderARNsDecoded0?.append(string0)
                }
            }
        }
        samlProviderARNs = samlProviderARNsDecoded0
        let identityPoolTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityPoolTags)
        var identityPoolTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityPoolTagsContainer = identityPoolTagsContainer {
            identityPoolTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvaluetype0) in identityPoolTagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    identityPoolTagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        identityPoolTags = identityPoolTagsDecoded0
    }
}

extension UpdateIdentityPoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIdentityPoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIdentityPoolOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIdentityPoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateIdentityPoolOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.allowClassicFlow = output.allowClassicFlow
            self.allowUnauthenticatedIdentities = output.allowUnauthenticatedIdentities
            self.cognitoIdentityProviders = output.cognitoIdentityProviders
            self.developerProviderName = output.developerProviderName
            self.identityPoolId = output.identityPoolId
            self.identityPoolName = output.identityPoolName
            self.identityPoolTags = output.identityPoolTags
            self.openIdConnectProviderARNs = output.openIdConnectProviderARNs
            self.samlProviderARNs = output.samlProviderARNs
            self.supportedLoginProviders = output.supportedLoginProviders
        } else {
            self.allowClassicFlow = nil
            self.allowUnauthenticatedIdentities = false
            self.cognitoIdentityProviders = nil
            self.developerProviderName = nil
            self.identityPoolId = nil
            self.identityPoolName = nil
            self.identityPoolTags = nil
            self.openIdConnectProviderARNs = nil
            self.samlProviderARNs = nil
            self.supportedLoginProviders = nil
        }
    }
}

/// An object representing an Amazon Cognito identity pool.
public struct UpdateIdentityPoolOutputResponse: Swift.Equatable {
    /// Enables or disables the Basic (Classic) authentication flow. For more information, see [Identity Pools (Federated Identities) Authentication Flow](https://docs.aws.amazon.com/cognito/latest/developerguide/authentication-flow.html) in the Amazon Cognito Developer Guide.
    public var allowClassicFlow: Swift.Bool?
    /// TRUE if the identity pool supports unauthenticated logins.
    /// This member is required.
    public var allowUnauthenticatedIdentities: Swift.Bool
    /// A list representing an Amazon Cognito user pool and its client ID.
    public var cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    /// The "domain" by which Cognito will refer to your users.
    public var developerProviderName: Swift.String?
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// A string that you provide.
    /// This member is required.
    public var identityPoolName: Swift.String?
    /// The tags that are assigned to the identity pool. A tag is a label that you can apply to identity pools to categorize and manage them in different ways, such as by purpose, owner, environment, or other criteria.
    public var identityPoolTags: [Swift.String:Swift.String]?
    /// The ARNs of the OpenID Connect providers.
    public var openIdConnectProviderARNs: [Swift.String]?
    /// An array of Amazon Resource Names (ARNs) of the SAML provider for your identity pool.
    public var samlProviderARNs: [Swift.String]?
    /// Optional key:value pairs mapping provider names to provider app IDs.
    public var supportedLoginProviders: [Swift.String:Swift.String]?

    public init (
        allowClassicFlow: Swift.Bool? = nil,
        allowUnauthenticatedIdentities: Swift.Bool = false,
        cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil,
        developerProviderName: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        identityPoolName: Swift.String? = nil,
        identityPoolTags: [Swift.String:Swift.String]? = nil,
        openIdConnectProviderARNs: [Swift.String]? = nil,
        samlProviderARNs: [Swift.String]? = nil,
        supportedLoginProviders: [Swift.String:Swift.String]? = nil
    )
    {
        self.allowClassicFlow = allowClassicFlow
        self.allowUnauthenticatedIdentities = allowUnauthenticatedIdentities
        self.cognitoIdentityProviders = cognitoIdentityProviders
        self.developerProviderName = developerProviderName
        self.identityPoolId = identityPoolId
        self.identityPoolName = identityPoolName
        self.identityPoolTags = identityPoolTags
        self.openIdConnectProviderARNs = openIdConnectProviderARNs
        self.samlProviderARNs = samlProviderARNs
        self.supportedLoginProviders = supportedLoginProviders
    }
}

struct UpdateIdentityPoolOutputResponseBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let identityPoolName: Swift.String?
    let allowUnauthenticatedIdentities: Swift.Bool
    let allowClassicFlow: Swift.Bool?
    let supportedLoginProviders: [Swift.String:Swift.String]?
    let developerProviderName: Swift.String?
    let openIdConnectProviderARNs: [Swift.String]?
    let cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    let samlProviderARNs: [Swift.String]?
    let identityPoolTags: [Swift.String:Swift.String]?
}

extension UpdateIdentityPoolOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let allowUnauthenticatedIdentitiesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowUnauthenticatedIdentities)
        allowUnauthenticatedIdentities = allowUnauthenticatedIdentitiesDecoded
        let allowClassicFlowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowClassicFlow)
        allowClassicFlow = allowClassicFlowDecoded
        let supportedLoginProvidersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .supportedLoginProviders)
        var supportedLoginProvidersDecoded0: [Swift.String:Swift.String]? = nil
        if let supportedLoginProvidersContainer = supportedLoginProvidersContainer {
            supportedLoginProvidersDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityproviderid0) in supportedLoginProvidersContainer {
                if let identityproviderid0 = identityproviderid0 {
                    supportedLoginProvidersDecoded0?[key0] = identityproviderid0
                }
            }
        }
        supportedLoginProviders = supportedLoginProvidersDecoded0
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let openIdConnectProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .openIdConnectProviderARNs)
        var openIdConnectProviderARNsDecoded0:[Swift.String]? = nil
        if let openIdConnectProviderARNsContainer = openIdConnectProviderARNsContainer {
            openIdConnectProviderARNsDecoded0 = [Swift.String]()
            for string0 in openIdConnectProviderARNsContainer {
                if let string0 = string0 {
                    openIdConnectProviderARNsDecoded0?.append(string0)
                }
            }
        }
        openIdConnectProviderARNs = openIdConnectProviderARNsDecoded0
        let cognitoIdentityProvidersContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.CognitoIdentityProvider?].self, forKey: .cognitoIdentityProviders)
        var cognitoIdentityProvidersDecoded0:[CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil
        if let cognitoIdentityProvidersContainer = cognitoIdentityProvidersContainer {
            cognitoIdentityProvidersDecoded0 = [CognitoIdentityClientTypes.CognitoIdentityProvider]()
            for structure0 in cognitoIdentityProvidersContainer {
                if let structure0 = structure0 {
                    cognitoIdentityProvidersDecoded0?.append(structure0)
                }
            }
        }
        cognitoIdentityProviders = cognitoIdentityProvidersDecoded0
        let samlProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .samlProviderARNs)
        var samlProviderARNsDecoded0:[Swift.String]? = nil
        if let samlProviderARNsContainer = samlProviderARNsContainer {
            samlProviderARNsDecoded0 = [Swift.String]()
            for string0 in samlProviderARNsContainer {
                if let string0 = string0 {
                    samlProviderARNsDecoded0?.append(string0)
                }
            }
        }
        samlProviderARNs = samlProviderARNsDecoded0
        let identityPoolTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityPoolTags)
        var identityPoolTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityPoolTagsContainer = identityPoolTagsContainer {
            identityPoolTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvaluetype0) in identityPoolTagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    identityPoolTagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        identityPoolTags = identityPoolTagsDecoded0
    }
}
