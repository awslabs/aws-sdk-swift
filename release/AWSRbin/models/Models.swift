// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CreateRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for resourcetags0 in resourceTags {
                try resourceTagsContainer.encode(resourcetags0)
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/rules"
    }
}

public struct CreateRuleInput: Swift.Equatable {
    /// The retention rule description.
    public var description: Swift.String?
    /// Specifies the resource tags to use to identify resources that are to be retained by a tag-level retention rule. For tag-level retention rules, only deleted resources, of the specified resource type, that have one or more of the specified tag key and value pairs are retained. If a resource is deleted, but it does not have any of the specified tag key and value pairs, it is immediately deleted without being retained by the retention rule. You can add the same tag key and value pair to a maximum or five retention rules. To create a Region-level retention rule, omit this parameter. A Region-level retention rule does not have any resource tags specified. It retains all deleted resources of the specified resource type in the Region in which the rule is created, even if the resources are not tagged.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type to be retained by the retention rule. Currently, only Amazon EBS snapshots and EBS-backed AMIs are supported. To retain snapshots, specify EBS_SNAPSHOT. To retain EBS-backed AMIs, specify EC2_IMAGE.
    /// This member is required.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    /// This member is required.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?
    /// Information about the tags to assign to the retention rule.
    public var tags: [RbinClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil,
        tags: [RbinClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
        self.tags = tags
    }
}

struct CreateRuleInputBody: Swift.Equatable {
    let retentionPeriod: RbinClientTypes.RetentionPeriod?
    let description: Swift.String?
    let tags: [RbinClientTypes.Tag]?
    let resourceType: RbinClientTypes.ResourceType?
    let resourceTags: [RbinClientTypes.ResourceTag]?
}

extension CreateRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RbinClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RbinClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[RbinClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [RbinClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
    }
}

extension CreateRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRuleOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.identifier = output.identifier
            self.resourceTags = output.resourceTags
            self.resourceType = output.resourceType
            self.retentionPeriod = output.retentionPeriod
            self.status = output.status
            self.tags = output.tags
        } else {
            self.description = nil
            self.identifier = nil
            self.resourceTags = nil
            self.resourceType = nil
            self.retentionPeriod = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct CreateRuleOutputResponse: Swift.Equatable {
    /// The retention rule description.
    public var description: Swift.String?
    /// The unique ID of the retention rule.
    public var identifier: Swift.String?
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type retained by the retention rule.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?
    /// The state of the retention rule. Only retention rules that are in the available state retain resources.
    public var status: RbinClientTypes.RuleStatus?
    /// Information about the tags assigned to the retention rule.
    public var tags: [RbinClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil,
        status: RbinClientTypes.RuleStatus? = nil,
        tags: [RbinClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
        self.status = status
        self.tags = tags
    }
}

struct CreateRuleOutputResponseBody: Swift.Equatable {
    let identifier: Swift.String?
    let retentionPeriod: RbinClientTypes.RetentionPeriod?
    let description: Swift.String?
    let tags: [RbinClientTypes.Tag]?
    let resourceType: RbinClientTypes.ResourceType?
    let resourceTags: [RbinClientTypes.ResourceTag]?
    let status: RbinClientTypes.RuleStatus?
}

extension CreateRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case identifier = "Identifier"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
        case status = "Status"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RbinClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RbinClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[RbinClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [RbinClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RuleStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/rules/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteRuleInput: Swift.Equatable {
    /// The unique ID of the retention rule.
    /// This member is required.
    public var identifier: Swift.String?

    public init (
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct DeleteRuleInputBody: Swift.Equatable {
}

extension DeleteRuleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRuleOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRuleOutputResponse: Swift.Equatable {

    public init () { }
}

extension GetRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/rules/\(identifier.urlPercentEncoding())"
    }
}

public struct GetRuleInput: Swift.Equatable {
    /// The unique ID of the retention rule.
    /// This member is required.
    public var identifier: Swift.String?

    public init (
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct GetRuleInputBody: Swift.Equatable {
}

extension GetRuleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRuleOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.identifier = output.identifier
            self.resourceTags = output.resourceTags
            self.resourceType = output.resourceType
            self.retentionPeriod = output.retentionPeriod
            self.status = output.status
        } else {
            self.description = nil
            self.identifier = nil
            self.resourceTags = nil
            self.resourceType = nil
            self.retentionPeriod = nil
            self.status = nil
        }
    }
}

public struct GetRuleOutputResponse: Swift.Equatable {
    /// The retention rule description.
    public var description: Swift.String?
    /// The unique ID of the retention rule.
    public var identifier: Swift.String?
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type retained by the retention rule.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?
    /// The state of the retention rule. Only retention rules that are in the available state retain resources.
    public var status: RbinClientTypes.RuleStatus?

    public init (
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil,
        status: RbinClientTypes.RuleStatus? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
        self.status = status
    }
}

struct GetRuleOutputResponseBody: Swift.Equatable {
    let identifier: Swift.String?
    let description: Swift.String?
    let resourceType: RbinClientTypes.ResourceType?
    let retentionPeriod: RbinClientTypes.RetentionPeriod?
    let resourceTags: [RbinClientTypes.ResourceTag]?
    let status: RbinClientTypes.RuleStatus?
}

extension GetRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case identifier = "Identifier"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[RbinClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [RbinClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RuleStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service could not respond to the request due to an internal problem.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for resourcetags0 in resourceTags {
                try resourceTagsContainer.encode(resourcetags0)
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }
}

extension ListRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-rules"
    }
}

public struct ListRulesInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type retained by the retention rule. Only retention rules that retain the specified resource type are listed. Currently, only Amazon EBS snapshots and EBS-backed AMIs are supported. To list retention rules that retain snapshots, specify EBS_SNAPSHOT. To list retention rules that retain EBS-backed AMIs, specify EC2_IMAGE.
    /// This member is required.
    public var resourceType: RbinClientTypes.ResourceType?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceTags = resourceTags
        self.resourceType = resourceType
    }
}

struct ListRulesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let resourceType: RbinClientTypes.ResourceType?
    let resourceTags: [RbinClientTypes.ResourceTag]?
}

extension ListRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[RbinClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [RbinClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
    }
}

extension ListRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRulesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rules = output.rules
        } else {
            self.nextToken = nil
            self.rules = nil
        }
    }
}

public struct ListRulesOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the retention rules.
    public var rules: [RbinClientTypes.RuleSummary]?

    public init (
        nextToken: Swift.String? = nil,
        rules: [RbinClientTypes.RuleSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.rules = rules
    }
}

struct ListRulesOutputResponseBody: Swift.Equatable {
    let rules: [RbinClientTypes.RuleSummary]?
    let nextToken: Swift.String?
}

extension ListRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case rules = "Rules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([RbinClientTypes.RuleSummary?].self, forKey: .rules)
        var rulesDecoded0:[RbinClientTypes.RuleSummary]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [RbinClientTypes.RuleSummary]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the retention rule.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Information about the tags assigned to the retention rule.
    public var tags: [RbinClientTypes.Tag]?

    public init (
        tags: [RbinClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [RbinClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RbinClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RbinClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The reason for the exception.
    public var reason: RbinClientTypes.ResourceNotFoundExceptionReason?

    public init (
        message: Swift.String? = nil,
        reason: RbinClientTypes.ResourceNotFoundExceptionReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: RbinClientTypes.ResourceNotFoundExceptionReason?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceNotFoundExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension RbinClientTypes {
    public enum ResourceNotFoundExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ruleNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceNotFoundExceptionReason] {
            return [
                .ruleNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ruleNotFound: return "RULE_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceNotFoundExceptionReason(rawValue: rawValue) ?? ResourceNotFoundExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension RbinClientTypes.ResourceTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceTagKey = "ResourceTagKey"
        case resourceTagValue = "ResourceTagValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceTagKey = self.resourceTagKey {
            try encodeContainer.encode(resourceTagKey, forKey: .resourceTagKey)
        }
        if let resourceTagValue = self.resourceTagValue {
            try encodeContainer.encode(resourceTagValue, forKey: .resourceTagValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceTagKey)
        resourceTagKey = resourceTagKeyDecoded
        let resourceTagValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceTagValue)
        resourceTagValue = resourceTagValueDecoded
    }
}

extension RbinClientTypes {
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public struct ResourceTag: Swift.Equatable {
        /// The tag key.
        /// This member is required.
        public var resourceTagKey: Swift.String?
        /// The tag value.
        public var resourceTagValue: Swift.String?

        public init (
            resourceTagKey: Swift.String? = nil,
            resourceTagValue: Swift.String? = nil
        )
        {
            self.resourceTagKey = resourceTagKey
            self.resourceTagValue = resourceTagValue
        }
    }

}

extension RbinClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ebsSnapshot
        case ec2Image
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .ebsSnapshot,
                .ec2Image,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ebsSnapshot: return "EBS_SNAPSHOT"
            case .ec2Image: return "EC2_IMAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension RbinClientTypes.RetentionPeriod: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionPeriodUnit = "RetentionPeriodUnit"
        case retentionPeriodValue = "RetentionPeriodValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionPeriodUnit = self.retentionPeriodUnit {
            try encodeContainer.encode(retentionPeriodUnit.rawValue, forKey: .retentionPeriodUnit)
        }
        if let retentionPeriodValue = self.retentionPeriodValue {
            try encodeContainer.encode(retentionPeriodValue, forKey: .retentionPeriodValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionPeriodValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriodValue)
        retentionPeriodValue = retentionPeriodValueDecoded
        let retentionPeriodUnitDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriodUnit.self, forKey: .retentionPeriodUnit)
        retentionPeriodUnit = retentionPeriodUnitDecoded
    }
}

extension RbinClientTypes {
    /// Information about the retention period for which the retention rule is to retain resources.
    public struct RetentionPeriod: Swift.Equatable {
        /// The unit of time in which the retention period is measured. Currently, only DAYS is supported.
        /// This member is required.
        public var retentionPeriodUnit: RbinClientTypes.RetentionPeriodUnit?
        /// The period value for which the retention rule is to retain resources. The period is measured using the unit specified for RetentionPeriodUnit.
        /// This member is required.
        public var retentionPeriodValue: Swift.Int?

        public init (
            retentionPeriodUnit: RbinClientTypes.RetentionPeriodUnit? = nil,
            retentionPeriodValue: Swift.Int? = nil
        )
        {
            self.retentionPeriodUnit = retentionPeriodUnit
            self.retentionPeriodValue = retentionPeriodValue
        }
    }

}

extension RbinClientTypes {
    public enum RetentionPeriodUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case days
        case sdkUnknown(Swift.String)

        public static var allCases: [RetentionPeriodUnit] {
            return [
                .days,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .days: return "DAYS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RetentionPeriodUnit(rawValue: rawValue) ?? RetentionPeriodUnit.sdkUnknown(rawValue)
        }
    }
}

extension RbinClientTypes {
    public enum RuleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleStatus] {
            return [
                .available,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "available"
            case .pending: return "pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RuleStatus(rawValue: rawValue) ?? RuleStatus.sdkUnknown(rawValue)
        }
    }
}

extension RbinClientTypes.RuleSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case identifier = "Identifier"
        case retentionPeriod = "RetentionPeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
    }
}

extension RbinClientTypes {
    /// Information about a Recycle Bin retention rule.
    public struct RuleSummary: Swift.Equatable {
        /// The retention rule description.
        public var description: Swift.String?
        /// The unique ID of the retention rule.
        public var identifier: Swift.String?
        /// Information about the retention period for which the retention rule is to retain resources.
        public var retentionPeriod: RbinClientTypes.RetentionPeriod?

        public init (
            description: Swift.String? = nil,
            identifier: Swift.String? = nil,
            retentionPeriod: RbinClientTypes.RetentionPeriod? = nil
        )
        {
            self.description = description
            self.identifier = identifier
            self.retentionPeriod = retentionPeriod
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would cause a service quota for the number of tags per resource to be exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The reason for the exception.
    public var reason: RbinClientTypes.ServiceQuotaExceededExceptionReason?

    public init (
        message: Swift.String? = nil,
        reason: RbinClientTypes.ServiceQuotaExceededExceptionReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: RbinClientTypes.ServiceQuotaExceededExceptionReason?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ServiceQuotaExceededExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension RbinClientTypes {
    public enum ServiceQuotaExceededExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case serviceQuotaExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceQuotaExceededExceptionReason] {
            return [
                .serviceQuotaExceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .serviceQuotaExceeded: return "SERVICE_QUOTA_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceQuotaExceededExceptionReason(rawValue: rawValue) ?? ServiceQuotaExceededExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension RbinClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension RbinClientTypes {
    /// Information about the tags to assign to the retention rule.
    public struct Tag: Swift.Equatable {
        /// The tag key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag value.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the retention rule.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Information about the tags to assign to the retention rule.
    /// This member is required.
    public var tags: [RbinClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [RbinClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [RbinClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RbinClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RbinClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the retention rule.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys of the tags to unassign. All tags that have the specified tag key are unassigned.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for resourcetags0 in resourceTags {
                try resourceTagsContainer.encode(resourcetags0)
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
    }
}

extension UpdateRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/rules/\(identifier.urlPercentEncoding())"
    }
}

public struct UpdateRuleInput: Swift.Equatable {
    /// The retention rule description.
    public var description: Swift.String?
    /// The unique ID of the retention rule.
    /// This member is required.
    public var identifier: Swift.String?
    /// Specifies the resource tags to use to identify resources that are to be retained by a tag-level retention rule. For tag-level retention rules, only deleted resources, of the specified resource type, that have one or more of the specified tag key and value pairs are retained. If a resource is deleted, but it does not have any of the specified tag key and value pairs, it is immediately deleted without being retained by the retention rule. You can add the same tag key and value pair to a maximum or five retention rules. To create a Region-level retention rule, omit this parameter. A Region-level retention rule does not have any resource tags specified. It retains all deleted resources of the specified resource type in the Region in which the rule is created, even if the resources are not tagged.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type to be retained by the retention rule. Currently, only Amazon EBS snapshots and EBS-backed AMIs are supported. To retain snapshots, specify EBS_SNAPSHOT. To retain EBS-backed AMIs, specify EC2_IMAGE.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?

    public init (
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
    }
}

struct UpdateRuleInputBody: Swift.Equatable {
    let retentionPeriod: RbinClientTypes.RetentionPeriod?
    let description: Swift.String?
    let resourceType: RbinClientTypes.ResourceType?
    let resourceTags: [RbinClientTypes.ResourceTag]?
}

extension UpdateRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[RbinClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [RbinClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
    }
}

extension UpdateRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRuleOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.identifier = output.identifier
            self.resourceTags = output.resourceTags
            self.resourceType = output.resourceType
            self.retentionPeriod = output.retentionPeriod
            self.status = output.status
        } else {
            self.description = nil
            self.identifier = nil
            self.resourceTags = nil
            self.resourceType = nil
            self.retentionPeriod = nil
            self.status = nil
        }
    }
}

public struct UpdateRuleOutputResponse: Swift.Equatable {
    /// The retention rule description.
    public var description: Swift.String?
    /// The unique ID of the retention rule.
    public var identifier: Swift.String?
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type retained by the retention rule.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?
    /// The state of the retention rule. Only retention rules that are in the available state retain resources.
    public var status: RbinClientTypes.RuleStatus?

    public init (
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil,
        status: RbinClientTypes.RuleStatus? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
        self.status = status
    }
}

struct UpdateRuleOutputResponseBody: Swift.Equatable {
    let identifier: Swift.String?
    let retentionPeriod: RbinClientTypes.RetentionPeriod?
    let description: Swift.String?
    let resourceType: RbinClientTypes.ResourceType?
    let resourceTags: [RbinClientTypes.ResourceTag]?
    let status: RbinClientTypes.RuleStatus?
}

extension UpdateRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case identifier = "Identifier"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[RbinClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [RbinClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RuleStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more of the parameters in the request is not valid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The reason for the exception.
    public var reason: RbinClientTypes.ValidationExceptionReason?

    public init (
        message: Swift.String? = nil,
        reason: RbinClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: RbinClientTypes.ValidationExceptionReason?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension RbinClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidPageToken
        case invalidParameterValue
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .invalidPageToken,
                .invalidParameterValue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidPageToken: return "INVALID_PAGE_TOKEN"
            case .invalidParameterValue: return "INVALID_PARAMETER_VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
