// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AgentListEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentArn = "AgentArn"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentArn = agentArn {
            try encodeContainer.encode(agentArn, forKey: .agentArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentArn)
        agentArn = agentArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AgentStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AgentListEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AgentListEntry(agentArn: \(String(describing: agentArn)), name: \(String(describing: name)), status: \(String(describing: status)))"}
}

/// <p>Represents a single entry in a list of agents. <code>AgentListEntry</code> returns an
///       array that contains a list of agents when the <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_ListAgents.html">ListAgents</a>
///       operation is
///       called.</p>
public struct AgentListEntry: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the agent.</p>
    public let agentArn: String?
    /// <p>The name of the agent.</p>
    public let name: String?
    /// <p>The status of the agent.</p>
    public let status: AgentStatus?

    public init (
        agentArn: String? = nil,
        name: String? = nil,
        status: AgentStatus? = nil
    )
    {
        self.agentArn = agentArn
        self.name = name
        self.status = status
    }
}

public enum AgentStatus {
    case offline
    case online
    case sdkUnknown(String)
}

extension AgentStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AgentStatus] {
        return [
            .offline,
            .online,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .offline: return "OFFLINE"
        case .online: return "ONLINE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AgentStatus(rawValue: rawValue) ?? AgentStatus.sdkUnknown(rawValue)
    }
}

public enum Atime {
    case bestEffort
    case `none`
    case sdkUnknown(String)
}

extension Atime : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Atime] {
        return [
            .bestEffort,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bestEffort: return "BEST_EFFORT"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Atime(rawValue: rawValue) ?? Atime.sdkUnknown(rawValue)
    }
}

public struct CancelTaskExecutionInputBodyMiddleware: Middleware {
    public let id: String = "CancelTaskExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelTaskExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelTaskExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelTaskExecutionInput>
    public typealias MOutput = OperationOutput<CancelTaskExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelTaskExecutionOutputError>
}

extension CancelTaskExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelTaskExecutionInput(taskExecutionArn: \(String(describing: taskExecutionArn)))"}
}

extension CancelTaskExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case taskExecutionArn = "TaskExecutionArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let taskExecutionArn = taskExecutionArn {
            try encodeContainer.encode(taskExecutionArn, forKey: .taskExecutionArn)
        }
    }
}

public struct CancelTaskExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "CancelTaskExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelTaskExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelTaskExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelTaskExecutionInput>
    public typealias MOutput = OperationOutput<CancelTaskExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelTaskExecutionOutputError>
}

public struct CancelTaskExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelTaskExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelTaskExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelTaskExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelTaskExecutionInput>
    public typealias MOutput = OperationOutput<CancelTaskExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelTaskExecutionOutputError>
}

/// <p>CancelTaskExecutionRequest</p>
public struct CancelTaskExecutionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the task execution to cancel.</p>
    public let taskExecutionArn: String?

    public init (
        taskExecutionArn: String? = nil
    )
    {
        self.taskExecutionArn = taskExecutionArn
    }
}

struct CancelTaskExecutionInputBody: Equatable {
    public let taskExecutionArn: String?
}

extension CancelTaskExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case taskExecutionArn = "TaskExecutionArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskExecutionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskExecutionArn)
        taskExecutionArn = taskExecutionArnDecoded
    }
}

extension CancelTaskExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelTaskExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelTaskExecutionOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelTaskExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelTaskExecutionOutputResponse()"}
}

extension CancelTaskExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CancelTaskExecutionOutputResponse: Equatable {

    public init() {}
}

struct CancelTaskExecutionOutputResponseBody: Equatable {
}

extension CancelTaskExecutionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateAgentInputBodyMiddleware: Middleware {
    public let id: String = "CreateAgentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAgentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAgentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAgentInput>
    public typealias MOutput = OperationOutput<CreateAgentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAgentOutputError>
}

extension CreateAgentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAgentInput(activationKey: \(String(describing: activationKey)), agentName: \(String(describing: agentName)), securityGroupArns: \(String(describing: securityGroupArns)), subnetArns: \(String(describing: subnetArns)), tags: \(String(describing: tags)), vpcEndpointId: \(String(describing: vpcEndpointId)))"}
}

extension CreateAgentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activationKey = "ActivationKey"
        case agentName = "AgentName"
        case securityGroupArns = "SecurityGroupArns"
        case subnetArns = "SubnetArns"
        case tags = "Tags"
        case vpcEndpointId = "VpcEndpointId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationKey = activationKey {
            try encodeContainer.encode(activationKey, forKey: .activationKey)
        }
        if let agentName = agentName {
            try encodeContainer.encode(agentName, forKey: .agentName)
        }
        if let securityGroupArns = securityGroupArns {
            var securityGroupArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupArns)
            for plsecuritygrouparnlist0 in securityGroupArns {
                try securityGroupArnsContainer.encode(plsecuritygrouparnlist0)
            }
        }
        if let subnetArns = subnetArns {
            var subnetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetArns)
            for plsubnetarnlist0 in subnetArns {
                try subnetArnsContainer.encode(plsubnetarnlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for inputtaglist0 in tags {
                try tagsContainer.encode(inputtaglist0)
            }
        }
        if let vpcEndpointId = vpcEndpointId {
            try encodeContainer.encode(vpcEndpointId, forKey: .vpcEndpointId)
        }
    }
}

public struct CreateAgentInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAgentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAgentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAgentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAgentInput>
    public typealias MOutput = OperationOutput<CreateAgentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAgentOutputError>
}

public struct CreateAgentInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAgentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAgentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAgentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAgentInput>
    public typealias MOutput = OperationOutput<CreateAgentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAgentOutputError>
}

/// <p>CreateAgentRequest</p>
public struct CreateAgentInput: Equatable {
    /// <p>Your agent activation key. You can get the activation key either by sending an HTTP GET
    ///       request with redirects that enable you to get the agent IP address (port 80). Alternatively,
    ///       you can get it from the AWS DataSync console.</p>
    ///          <p>The redirect URL returned in the response provides you the activation key for your
    ///       agent in the query string parameter <code>activationKey</code>. It might also include other
    ///       activation-related parameters; however, these are merely defaults. The arguments you pass to
    ///       this API call determine the actual configuration of your agent.</p>
    ///
    ///
    ///          <p>For more information, see Activating an Agent in the <i>AWS DataSync
    ///         User Guide.</i>
    ///          </p>
    public let activationKey: String?
    /// <p>The name you configured for your agent. This value is a text reference that is used to
    ///       identify the agent in the console.</p>
    public let agentName: String?
    /// <p>The ARNs of the security groups used to protect your data transfer task subnets. See <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_Ec2Config.html#DataSync-Type-Ec2Config-SecurityGroupArns">SecurityGroupArns</a>.</p>
    public let securityGroupArns: [String]?
    /// <p>The Amazon Resource Names (ARNs) of the subnets in which DataSync will create elastic
    ///       network interfaces for each data transfer task. The agent that runs a task must be private.
    ///       When you start a task that is associated with an agent created in a VPC, or one that has
    ///       access to an IP address in a VPC, then the task is also private. In this case, DataSync
    ///       creates four network interfaces for each task in your subnet. For a data transfer to work, the
    ///       agent must be able to route to all these four network interfaces.</p>
    public let subnetArns: [String]?
    /// <p>The key-value pair that represents the tag that you want to associate with the agent.
    ///       The value can be an empty string. This value helps you manage, filter, and search for your
    ///       agents.</p>
    ///          <note>
    ///             <p>Valid characters for key and value are letters, spaces, and numbers representable in
    ///         UTF-8 format, and the following special characters: + - = . _ : / @. </p>
    ///          </note>
    public let tags: [TagListEntry]?
    /// <p>The ID of the VPC (virtual private cloud) endpoint that the agent has access to. This is
    ///       the client-side VPC endpoint, also called a PrivateLink. If you don't have a PrivateLink VPC
    ///       endpoint, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/endpoint-service.html#create-endpoint-service">Creating a VPC Endpoint Service Configuration</a> in the Amazon VPC User Guide.</p>
    ///          <p>VPC endpoint ID looks like this: <code>vpce-01234d5aff67890e1</code>.</p>
    public let vpcEndpointId: String?

    public init (
        activationKey: String? = nil,
        agentName: String? = nil,
        securityGroupArns: [String]? = nil,
        subnetArns: [String]? = nil,
        tags: [TagListEntry]? = nil,
        vpcEndpointId: String? = nil
    )
    {
        self.activationKey = activationKey
        self.agentName = agentName
        self.securityGroupArns = securityGroupArns
        self.subnetArns = subnetArns
        self.tags = tags
        self.vpcEndpointId = vpcEndpointId
    }
}

struct CreateAgentInputBody: Equatable {
    public let activationKey: String?
    public let agentName: String?
    public let tags: [TagListEntry]?
    public let vpcEndpointId: String?
    public let subnetArns: [String]?
    public let securityGroupArns: [String]?
}

extension CreateAgentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activationKey = "ActivationKey"
        case agentName = "AgentName"
        case securityGroupArns = "SecurityGroupArns"
        case subnetArns = "SubnetArns"
        case tags = "Tags"
        case vpcEndpointId = "VpcEndpointId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activationKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activationKey)
        activationKey = activationKeyDecoded
        let agentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentName)
        agentName = agentNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TagListEntry?].self, forKey: .tags)
        var tagsDecoded0:[TagListEntry]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TagListEntry]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
        let subnetArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetArns)
        var subnetArnsDecoded0:[String]? = nil
        if let subnetArnsContainer = subnetArnsContainer {
            subnetArnsDecoded0 = [String]()
            for string0 in subnetArnsContainer {
                if let string0 = string0 {
                    subnetArnsDecoded0?.append(string0)
                }
            }
        }
        subnetArns = subnetArnsDecoded0
        let securityGroupArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupArns)
        var securityGroupArnsDecoded0:[String]? = nil
        if let securityGroupArnsContainer = securityGroupArnsContainer {
            securityGroupArnsDecoded0 = [String]()
            for string0 in securityGroupArnsContainer {
                if let string0 = string0 {
                    securityGroupArnsDecoded0?.append(string0)
                }
            }
        }
        securityGroupArns = securityGroupArnsDecoded0
    }
}

extension CreateAgentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAgentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAgentOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAgentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAgentOutputResponse(agentArn: \(String(describing: agentArn)))"}
}

extension CreateAgentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAgentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.agentArn = output.agentArn
        } else {
            self.agentArn = nil
        }
    }
}

/// <p>CreateAgentResponse</p>
public struct CreateAgentOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the agent. Use the <code>ListAgents</code> operation
    ///       to return a list of agents for your account and AWS Region.</p>
    public let agentArn: String?

    public init (
        agentArn: String? = nil
    )
    {
        self.agentArn = agentArn
    }
}

struct CreateAgentOutputResponseBody: Equatable {
    public let agentArn: String?
}

extension CreateAgentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentArn = "AgentArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentArn)
        agentArn = agentArnDecoded
    }
}

public struct CreateLocationEfsInputBodyMiddleware: Middleware {
    public let id: String = "CreateLocationEfsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLocationEfsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLocationEfsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLocationEfsInput>
    public typealias MOutput = OperationOutput<CreateLocationEfsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLocationEfsOutputError>
}

extension CreateLocationEfsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLocationEfsInput(ec2Config: \(String(describing: ec2Config)), efsFilesystemArn: \(String(describing: efsFilesystemArn)), subdirectory: \(String(describing: subdirectory)), tags: \(String(describing: tags)))"}
}

extension CreateLocationEfsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ec2Config = "Ec2Config"
        case efsFilesystemArn = "EfsFilesystemArn"
        case subdirectory = "Subdirectory"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2Config = ec2Config {
            try encodeContainer.encode(ec2Config, forKey: .ec2Config)
        }
        if let efsFilesystemArn = efsFilesystemArn {
            try encodeContainer.encode(efsFilesystemArn, forKey: .efsFilesystemArn)
        }
        if let subdirectory = subdirectory {
            try encodeContainer.encode(subdirectory, forKey: .subdirectory)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for inputtaglist0 in tags {
                try tagsContainer.encode(inputtaglist0)
            }
        }
    }
}

public struct CreateLocationEfsInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLocationEfsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLocationEfsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLocationEfsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLocationEfsInput>
    public typealias MOutput = OperationOutput<CreateLocationEfsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLocationEfsOutputError>
}

public struct CreateLocationEfsInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLocationEfsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLocationEfsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLocationEfsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLocationEfsInput>
    public typealias MOutput = OperationOutput<CreateLocationEfsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLocationEfsOutputError>
}

/// <p>CreateLocationEfsRequest</p>
public struct CreateLocationEfsInput: Equatable {
    /// <p>The subnet and security group that the Amazon EFS file system uses. The security group
    ///       that you provide needs to be able to communicate with the security group on the mount target
    ///       in the subnet specified.</p>
    ///          <p>The exact relationship between security group M (of the mount target) and security
    ///       group S (which you provide for DataSync to use at this stage) is as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p> Security group M (which you associate with the mount target) must allow inbound
    ///           access for the Transmission Control Protocol (TCP) on the NFS port (2049) from security
    ///           group S. You can enable inbound connections either by IP address (CIDR range) or security
    ///           group. </p>
    ///             </li>
    ///             <li>
    ///                <p>Security group S (provided to DataSync to access EFS) should have a rule that
    ///           enables outbound connections to the NFS port on one of the file system’s mount targets.
    ///           You can enable outbound connections either by IP address (CIDR range) or security
    ///           group.</p>
    ///
    ///                <p>For information about security groups and mount targets, see Security
    ///           Groups for Amazon EC2 Instances and Mount Targets in the <i>Amazon EFS User
    ///             Guide.</i>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let ec2Config: Ec2Config?
    /// <p>The Amazon Resource Name (ARN) for the Amazon EFS file system.</p>
    public let efsFilesystemArn: String?
    /// <p>A subdirectory in the location’s path. This subdirectory in the EFS file system is used
    ///       to read data from the EFS source location or write data to the EFS destination. By default,
    ///       AWS DataSync uses the root directory.</p>
    ///          <note>
    ///             <p>
    ///                <code>Subdirectory</code> must be specified with forward slashes. For example,
    ///           <code>/path/to/folder</code>.</p>
    ///          </note>
    public let subdirectory: String?
    /// <p>The key-value pair that represents a tag that you want to add to the resource. The
    ///       value can be an empty string. This value helps you manage, filter, and search for your
    ///       resources. We recommend that you create a name tag for your location.</p>
    public let tags: [TagListEntry]?

    public init (
        ec2Config: Ec2Config? = nil,
        efsFilesystemArn: String? = nil,
        subdirectory: String? = nil,
        tags: [TagListEntry]? = nil
    )
    {
        self.ec2Config = ec2Config
        self.efsFilesystemArn = efsFilesystemArn
        self.subdirectory = subdirectory
        self.tags = tags
    }
}

struct CreateLocationEfsInputBody: Equatable {
    public let subdirectory: String?
    public let efsFilesystemArn: String?
    public let ec2Config: Ec2Config?
    public let tags: [TagListEntry]?
}

extension CreateLocationEfsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ec2Config = "Ec2Config"
        case efsFilesystemArn = "EfsFilesystemArn"
        case subdirectory = "Subdirectory"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subdirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subdirectory)
        subdirectory = subdirectoryDecoded
        let efsFilesystemArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .efsFilesystemArn)
        efsFilesystemArn = efsFilesystemArnDecoded
        let ec2ConfigDecoded = try containerValues.decodeIfPresent(Ec2Config.self, forKey: .ec2Config)
        ec2Config = ec2ConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TagListEntry?].self, forKey: .tags)
        var tagsDecoded0:[TagListEntry]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TagListEntry]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLocationEfsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLocationEfsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLocationEfsOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLocationEfsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLocationEfsOutputResponse(locationArn: \(String(describing: locationArn)))"}
}

extension CreateLocationEfsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLocationEfsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.locationArn = output.locationArn
        } else {
            self.locationArn = nil
        }
    }
}

/// <p>CreateLocationEfs</p>
public struct CreateLocationEfsOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Amazon EFS file system location that is
    ///       created.</p>
    public let locationArn: String?

    public init (
        locationArn: String? = nil
    )
    {
        self.locationArn = locationArn
    }
}

struct CreateLocationEfsOutputResponseBody: Equatable {
    public let locationArn: String?
}

extension CreateLocationEfsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case locationArn = "LocationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationArn)
        locationArn = locationArnDecoded
    }
}

public struct CreateLocationFsxWindowsInputBodyMiddleware: Middleware {
    public let id: String = "CreateLocationFsxWindowsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLocationFsxWindowsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLocationFsxWindowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLocationFsxWindowsInput>
    public typealias MOutput = OperationOutput<CreateLocationFsxWindowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLocationFsxWindowsOutputError>
}

extension CreateLocationFsxWindowsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLocationFsxWindowsInput(domain: \(String(describing: domain)), fsxFilesystemArn: \(String(describing: fsxFilesystemArn)), password: \(String(describing: password)), securityGroupArns: \(String(describing: securityGroupArns)), subdirectory: \(String(describing: subdirectory)), tags: \(String(describing: tags)), user: \(String(describing: user)))"}
}

extension CreateLocationFsxWindowsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domain = "Domain"
        case fsxFilesystemArn = "FsxFilesystemArn"
        case password = "Password"
        case securityGroupArns = "SecurityGroupArns"
        case subdirectory = "Subdirectory"
        case tags = "Tags"
        case user = "User"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let fsxFilesystemArn = fsxFilesystemArn {
            try encodeContainer.encode(fsxFilesystemArn, forKey: .fsxFilesystemArn)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let securityGroupArns = securityGroupArns {
            var securityGroupArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupArns)
            for ec2securitygrouparnlist0 in securityGroupArns {
                try securityGroupArnsContainer.encode(ec2securitygrouparnlist0)
            }
        }
        if let subdirectory = subdirectory {
            try encodeContainer.encode(subdirectory, forKey: .subdirectory)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for inputtaglist0 in tags {
                try tagsContainer.encode(inputtaglist0)
            }
        }
        if let user = user {
            try encodeContainer.encode(user, forKey: .user)
        }
    }
}

public struct CreateLocationFsxWindowsInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLocationFsxWindowsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLocationFsxWindowsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLocationFsxWindowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLocationFsxWindowsInput>
    public typealias MOutput = OperationOutput<CreateLocationFsxWindowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLocationFsxWindowsOutputError>
}

public struct CreateLocationFsxWindowsInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLocationFsxWindowsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLocationFsxWindowsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLocationFsxWindowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLocationFsxWindowsInput>
    public typealias MOutput = OperationOutput<CreateLocationFsxWindowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLocationFsxWindowsOutputError>
}

public struct CreateLocationFsxWindowsInput: Equatable {
    /// <p>The name of the Windows domain that the FSx for Windows File Server belongs to.</p>
    public let domain: String?
    /// <p>The Amazon Resource Name (ARN) for the FSx for Windows File Server file system.</p>
    public let fsxFilesystemArn: String?
    /// <p>The password of the user who has the permissions to access files and folders in the FSx
    ///       for Windows File Server file system.</p>
    public let password: String?
    /// <p>The Amazon Resource Names (ARNs) of the security groups that are to use to configure the
    ///       FSx for Windows File Server file system.</p>
    public let securityGroupArns: [String]?
    /// <p>A subdirectory in the location’s path. This subdirectory in the Amazon FSx for Windows
    ///       File Server file system is used to read data from the Amazon FSx for Windows File Server
    ///       source location or write data to the FSx for Windows File Server destination.</p>
    public let subdirectory: String?
    /// <p>The key-value pair that represents a tag that you want to add to the resource. The
    ///       value can be an empty string. This value helps you manage, filter, and search for your
    ///       resources. We recommend that you create a name tag for your location.</p>
    public let tags: [TagListEntry]?
    /// <p>The user who has the permissions to access files and folders in the FSx for Windows File
    ///       Server file system.</p>
    ///          <p>For information about choosing a user name that ensures sufficient permissions to files,
    ///       folders, and metadata, see <a href="create-fsx-location.html#FSxWuser">user</a>.</p>
    public let user: String?

    public init (
        domain: String? = nil,
        fsxFilesystemArn: String? = nil,
        password: String? = nil,
        securityGroupArns: [String]? = nil,
        subdirectory: String? = nil,
        tags: [TagListEntry]? = nil,
        user: String? = nil
    )
    {
        self.domain = domain
        self.fsxFilesystemArn = fsxFilesystemArn
        self.password = password
        self.securityGroupArns = securityGroupArns
        self.subdirectory = subdirectory
        self.tags = tags
        self.user = user
    }
}

struct CreateLocationFsxWindowsInputBody: Equatable {
    public let subdirectory: String?
    public let fsxFilesystemArn: String?
    public let securityGroupArns: [String]?
    public let tags: [TagListEntry]?
    public let user: String?
    public let domain: String?
    public let password: String?
}

extension CreateLocationFsxWindowsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domain = "Domain"
        case fsxFilesystemArn = "FsxFilesystemArn"
        case password = "Password"
        case securityGroupArns = "SecurityGroupArns"
        case subdirectory = "Subdirectory"
        case tags = "Tags"
        case user = "User"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subdirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subdirectory)
        subdirectory = subdirectoryDecoded
        let fsxFilesystemArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fsxFilesystemArn)
        fsxFilesystemArn = fsxFilesystemArnDecoded
        let securityGroupArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupArns)
        var securityGroupArnsDecoded0:[String]? = nil
        if let securityGroupArnsContainer = securityGroupArnsContainer {
            securityGroupArnsDecoded0 = [String]()
            for string0 in securityGroupArnsContainer {
                if let string0 = string0 {
                    securityGroupArnsDecoded0?.append(string0)
                }
            }
        }
        securityGroupArns = securityGroupArnsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([TagListEntry?].self, forKey: .tags)
        var tagsDecoded0:[TagListEntry]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TagListEntry]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let userDecoded = try containerValues.decodeIfPresent(String.self, forKey: .user)
        user = userDecoded
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension CreateLocationFsxWindowsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLocationFsxWindowsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLocationFsxWindowsOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLocationFsxWindowsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLocationFsxWindowsOutputResponse(locationArn: \(String(describing: locationArn)))"}
}

extension CreateLocationFsxWindowsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLocationFsxWindowsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.locationArn = output.locationArn
        } else {
            self.locationArn = nil
        }
    }
}

public struct CreateLocationFsxWindowsOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the FSx for Windows File Server file system location
    ///       that is created.</p>
    public let locationArn: String?

    public init (
        locationArn: String? = nil
    )
    {
        self.locationArn = locationArn
    }
}

struct CreateLocationFsxWindowsOutputResponseBody: Equatable {
    public let locationArn: String?
}

extension CreateLocationFsxWindowsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case locationArn = "LocationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationArn)
        locationArn = locationArnDecoded
    }
}

public struct CreateLocationNfsInputBodyMiddleware: Middleware {
    public let id: String = "CreateLocationNfsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLocationNfsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLocationNfsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLocationNfsInput>
    public typealias MOutput = OperationOutput<CreateLocationNfsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLocationNfsOutputError>
}

extension CreateLocationNfsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLocationNfsInput(mountOptions: \(String(describing: mountOptions)), onPremConfig: \(String(describing: onPremConfig)), serverHostname: \(String(describing: serverHostname)), subdirectory: \(String(describing: subdirectory)), tags: \(String(describing: tags)))"}
}

extension CreateLocationNfsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mountOptions = "MountOptions"
        case onPremConfig = "OnPremConfig"
        case serverHostname = "ServerHostname"
        case subdirectory = "Subdirectory"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mountOptions = mountOptions {
            try encodeContainer.encode(mountOptions, forKey: .mountOptions)
        }
        if let onPremConfig = onPremConfig {
            try encodeContainer.encode(onPremConfig, forKey: .onPremConfig)
        }
        if let serverHostname = serverHostname {
            try encodeContainer.encode(serverHostname, forKey: .serverHostname)
        }
        if let subdirectory = subdirectory {
            try encodeContainer.encode(subdirectory, forKey: .subdirectory)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for inputtaglist0 in tags {
                try tagsContainer.encode(inputtaglist0)
            }
        }
    }
}

public struct CreateLocationNfsInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLocationNfsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLocationNfsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLocationNfsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLocationNfsInput>
    public typealias MOutput = OperationOutput<CreateLocationNfsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLocationNfsOutputError>
}

public struct CreateLocationNfsInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLocationNfsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLocationNfsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLocationNfsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLocationNfsInput>
    public typealias MOutput = OperationOutput<CreateLocationNfsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLocationNfsOutputError>
}

/// <p>CreateLocationNfsRequest</p>
public struct CreateLocationNfsInput: Equatable {
    /// <p>The NFS mount options that DataSync can use to mount your NFS share.</p>
    public let mountOptions: NfsMountOptions?
    /// <p>Contains a list of Amazon Resource Names (ARNs) of agents that are used to connect to
    ///       an NFS server. </p>
    ///          <p>If you are copying data to or from your AWS Snowcone device, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-nfs-location.html#nfs-on-snowcone">NFS Server on AWS Snowcone</a> for more information.</p>
    public let onPremConfig: OnPremConfig?
    /// <p>The name of the NFS server. This value is the IP address or Domain Name Service (DNS)
    ///       name of the NFS server. An agent that is installed on-premises uses this host name to mount
    ///       the NFS server in a network. </p>
    ///          <p>If you are copying data to or from your AWS Snowcone device, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-nfs-location.html#nfs-on-snowcone">NFS Server on AWS Snowcone</a> for more information.</p>
    ///          <note>
    ///             <p>This name must either be DNS-compliant or must be an IP version 4 (IPv4)
    ///         address.</p>
    ///          </note>
    public let serverHostname: String?
    /// <p>The subdirectory in the NFS file system that is used to read data from the NFS source
    ///       location or write data to the NFS destination. The NFS path should be a path that's
    ///       exported by the NFS server, or a subdirectory of that path. The path should be such that it
    ///       can be mounted by other NFS clients in your network. </p>
    ///          <p>To see all the paths exported by your NFS server, run "<code>showmount -e
    ///         nfs-server-name</code>" from an NFS client that has access to your server. You can specify
    ///       any directory that appears in the results, and any subdirectory of that directory. Ensure that
    ///       the NFS export is accessible without Kerberos authentication. </p>
    ///          <p>To transfer all the data in the folder you specified, DataSync needs to have
    ///       permissions to read all the data. To ensure this, either configure the NFS export with
    ///         <code>no_root_squash,</code> or ensure that the permissions for all of the files that you
    ///       want DataSync allow read access for all users. Doing either enables the agent to read the
    ///       files. For the agent to access directories, you must additionally enable all execute
    ///       access.</p>
    ///          <p>If you are copying data to or from your AWS Snowcone device, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-nfs-location.html#nfs-on-snowcone">NFS Server on AWS Snowcone</a> for more information.</p>
    ///
    ///          <p>For information about NFS export configuration, see 18.7. The /etc/exports
    ///       Configuration File in the Red Hat Enterprise Linux documentation.</p>
    public let subdirectory: String?
    /// <p>The key-value pair that represents the tag that you want to add to the location. The
    ///       value can be an empty string. We recommend using tags to name your resources.</p>
    public let tags: [TagListEntry]?

    public init (
        mountOptions: NfsMountOptions? = nil,
        onPremConfig: OnPremConfig? = nil,
        serverHostname: String? = nil,
        subdirectory: String? = nil,
        tags: [TagListEntry]? = nil
    )
    {
        self.mountOptions = mountOptions
        self.onPremConfig = onPremConfig
        self.serverHostname = serverHostname
        self.subdirectory = subdirectory
        self.tags = tags
    }
}

struct CreateLocationNfsInputBody: Equatable {
    public let subdirectory: String?
    public let serverHostname: String?
    public let onPremConfig: OnPremConfig?
    public let mountOptions: NfsMountOptions?
    public let tags: [TagListEntry]?
}

extension CreateLocationNfsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case mountOptions = "MountOptions"
        case onPremConfig = "OnPremConfig"
        case serverHostname = "ServerHostname"
        case subdirectory = "Subdirectory"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subdirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subdirectory)
        subdirectory = subdirectoryDecoded
        let serverHostnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverHostname)
        serverHostname = serverHostnameDecoded
        let onPremConfigDecoded = try containerValues.decodeIfPresent(OnPremConfig.self, forKey: .onPremConfig)
        onPremConfig = onPremConfigDecoded
        let mountOptionsDecoded = try containerValues.decodeIfPresent(NfsMountOptions.self, forKey: .mountOptions)
        mountOptions = mountOptionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TagListEntry?].self, forKey: .tags)
        var tagsDecoded0:[TagListEntry]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TagListEntry]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLocationNfsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLocationNfsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLocationNfsOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLocationNfsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLocationNfsOutputResponse(locationArn: \(String(describing: locationArn)))"}
}

extension CreateLocationNfsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLocationNfsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.locationArn = output.locationArn
        } else {
            self.locationArn = nil
        }
    }
}

/// <p>CreateLocationNfsResponse</p>
public struct CreateLocationNfsOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the source NFS file system location that is
    ///       created.</p>
    public let locationArn: String?

    public init (
        locationArn: String? = nil
    )
    {
        self.locationArn = locationArn
    }
}

struct CreateLocationNfsOutputResponseBody: Equatable {
    public let locationArn: String?
}

extension CreateLocationNfsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case locationArn = "LocationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationArn)
        locationArn = locationArnDecoded
    }
}

public struct CreateLocationObjectStorageInputBodyMiddleware: Middleware {
    public let id: String = "CreateLocationObjectStorageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLocationObjectStorageInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLocationObjectStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLocationObjectStorageInput>
    public typealias MOutput = OperationOutput<CreateLocationObjectStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLocationObjectStorageOutputError>
}

extension CreateLocationObjectStorageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLocationObjectStorageInput(accessKey: \(String(describing: accessKey)), agentArns: \(String(describing: agentArns)), bucketName: \(String(describing: bucketName)), secretKey: \(String(describing: secretKey)), serverHostname: \(String(describing: serverHostname)), serverPort: \(String(describing: serverPort)), serverProtocol: \(String(describing: serverProtocol)), subdirectory: \(String(describing: subdirectory)), tags: \(String(describing: tags)))"}
}

extension CreateLocationObjectStorageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessKey = "AccessKey"
        case agentArns = "AgentArns"
        case bucketName = "BucketName"
        case secretKey = "SecretKey"
        case serverHostname = "ServerHostname"
        case serverPort = "ServerPort"
        case serverProtocol = "ServerProtocol"
        case subdirectory = "Subdirectory"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKey = accessKey {
            try encodeContainer.encode(accessKey, forKey: .accessKey)
        }
        if let agentArns = agentArns {
            var agentArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentArns)
            for agentarnlist0 in agentArns {
                try agentArnsContainer.encode(agentarnlist0)
            }
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let secretKey = secretKey {
            try encodeContainer.encode(secretKey, forKey: .secretKey)
        }
        if let serverHostname = serverHostname {
            try encodeContainer.encode(serverHostname, forKey: .serverHostname)
        }
        if let serverPort = serverPort {
            try encodeContainer.encode(serverPort, forKey: .serverPort)
        }
        if let serverProtocol = serverProtocol {
            try encodeContainer.encode(serverProtocol.rawValue, forKey: .serverProtocol)
        }
        if let subdirectory = subdirectory {
            try encodeContainer.encode(subdirectory, forKey: .subdirectory)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for inputtaglist0 in tags {
                try tagsContainer.encode(inputtaglist0)
            }
        }
    }
}

public struct CreateLocationObjectStorageInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLocationObjectStorageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLocationObjectStorageInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLocationObjectStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLocationObjectStorageInput>
    public typealias MOutput = OperationOutput<CreateLocationObjectStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLocationObjectStorageOutputError>
}

public struct CreateLocationObjectStorageInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLocationObjectStorageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLocationObjectStorageInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLocationObjectStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLocationObjectStorageInput>
    public typealias MOutput = OperationOutput<CreateLocationObjectStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLocationObjectStorageOutputError>
}

/// <p>CreateLocationObjectStorageRequest</p>
public struct CreateLocationObjectStorageInput: Equatable {
    /// <p>Optional. The access key is used if credentials are required to access the self-managed
    ///       object storage server. If your object storage requires a user name and password to
    ///       authenticate, use <code>AccessKey</code> and <code>SecretKey</code> to provide the user name
    ///       and password, respectively.</p>
    public let accessKey: String?
    /// <p>The Amazon Resource Name (ARN) of the agents associated with the
    ///       self-managed object storage server location.</p>
    public let agentArns: [String]?
    /// <p>The bucket on the self-managed object storage server that is used
    ///       to read data from.</p>
    public let bucketName: String?
    /// <p>Optional. The secret key is used if credentials are required to access the self-managed
    ///       object storage server. If your object storage requires a user name and password to
    ///       authenticate, use <code>AccessKey</code> and <code>SecretKey</code> to provide the user name
    ///       and password, respectively.</p>
    public let secretKey: String?
    /// <p>The name of the self-managed object storage server. This value is the
    ///       IP address or Domain Name Service (DNS) name of the object storage server.
    ///       An agent uses this host name to mount the object storage server in a network. </p>
    public let serverHostname: String?
    /// <p>The port that your self-managed object storage server accepts inbound network traffic on.
    ///       The server port is set by default to TCP 80 (HTTP) or TCP 443 (HTTPS). You can
    ///       specify a custom port if your self-managed object storage server requires one.</p>
    public let serverPort: Int?
    /// <p>The protocol that the object storage server uses to communicate.
    ///       Valid values are HTTP or HTTPS.</p>
    public let serverProtocol: ObjectStorageServerProtocol?
    /// <p>The subdirectory in the self-managed object storage server that is used
    ///       to read data from.</p>
    public let subdirectory: String?
    /// <p>The key-value pair that represents the tag that you want to add to the location. The
    ///       value can be an empty string. We recommend using tags to name your resources.</p>
    public let tags: [TagListEntry]?

    public init (
        accessKey: String? = nil,
        agentArns: [String]? = nil,
        bucketName: String? = nil,
        secretKey: String? = nil,
        serverHostname: String? = nil,
        serverPort: Int? = nil,
        serverProtocol: ObjectStorageServerProtocol? = nil,
        subdirectory: String? = nil,
        tags: [TagListEntry]? = nil
    )
    {
        self.accessKey = accessKey
        self.agentArns = agentArns
        self.bucketName = bucketName
        self.secretKey = secretKey
        self.serverHostname = serverHostname
        self.serverPort = serverPort
        self.serverProtocol = serverProtocol
        self.subdirectory = subdirectory
        self.tags = tags
    }
}

struct CreateLocationObjectStorageInputBody: Equatable {
    public let serverHostname: String?
    public let serverPort: Int?
    public let serverProtocol: ObjectStorageServerProtocol?
    public let subdirectory: String?
    public let bucketName: String?
    public let accessKey: String?
    public let secretKey: String?
    public let agentArns: [String]?
    public let tags: [TagListEntry]?
}

extension CreateLocationObjectStorageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessKey = "AccessKey"
        case agentArns = "AgentArns"
        case bucketName = "BucketName"
        case secretKey = "SecretKey"
        case serverHostname = "ServerHostname"
        case serverPort = "ServerPort"
        case serverProtocol = "ServerProtocol"
        case subdirectory = "Subdirectory"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverHostnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverHostname)
        serverHostname = serverHostnameDecoded
        let serverPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .serverPort)
        serverPort = serverPortDecoded
        let serverProtocolDecoded = try containerValues.decodeIfPresent(ObjectStorageServerProtocol.self, forKey: .serverProtocol)
        serverProtocol = serverProtocolDecoded
        let subdirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subdirectory)
        subdirectory = subdirectoryDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let accessKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessKey)
        accessKey = accessKeyDecoded
        let secretKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretKey)
        secretKey = secretKeyDecoded
        let agentArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .agentArns)
        var agentArnsDecoded0:[String]? = nil
        if let agentArnsContainer = agentArnsContainer {
            agentArnsDecoded0 = [String]()
            for string0 in agentArnsContainer {
                if let string0 = string0 {
                    agentArnsDecoded0?.append(string0)
                }
            }
        }
        agentArns = agentArnsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([TagListEntry?].self, forKey: .tags)
        var tagsDecoded0:[TagListEntry]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TagListEntry]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLocationObjectStorageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLocationObjectStorageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLocationObjectStorageOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLocationObjectStorageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLocationObjectStorageOutputResponse(locationArn: \(String(describing: locationArn)))"}
}

extension CreateLocationObjectStorageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLocationObjectStorageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.locationArn = output.locationArn
        } else {
            self.locationArn = nil
        }
    }
}

/// <p>CreateLocationObjectStorageResponse</p>
public struct CreateLocationObjectStorageOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the agents associated with the
    ///       self-managed object storage server location.</p>
    public let locationArn: String?

    public init (
        locationArn: String? = nil
    )
    {
        self.locationArn = locationArn
    }
}

struct CreateLocationObjectStorageOutputResponseBody: Equatable {
    public let locationArn: String?
}

extension CreateLocationObjectStorageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case locationArn = "LocationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationArn)
        locationArn = locationArnDecoded
    }
}

public struct CreateLocationS3InputBodyMiddleware: Middleware {
    public let id: String = "CreateLocationS3InputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLocationS3Input>,
                  next: H) -> Swift.Result<OperationOutput<CreateLocationS3OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLocationS3Input>
    public typealias MOutput = OperationOutput<CreateLocationS3OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLocationS3OutputError>
}

extension CreateLocationS3Input: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLocationS3Input(agentArns: \(String(describing: agentArns)), s3BucketArn: \(String(describing: s3BucketArn)), s3Config: \(String(describing: s3Config)), s3StorageClass: \(String(describing: s3StorageClass)), subdirectory: \(String(describing: subdirectory)), tags: \(String(describing: tags)))"}
}

extension CreateLocationS3Input: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentArns = "AgentArns"
        case s3BucketArn = "S3BucketArn"
        case s3Config = "S3Config"
        case s3StorageClass = "S3StorageClass"
        case subdirectory = "Subdirectory"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentArns = agentArns {
            var agentArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentArns)
            for agentarnlist0 in agentArns {
                try agentArnsContainer.encode(agentarnlist0)
            }
        }
        if let s3BucketArn = s3BucketArn {
            try encodeContainer.encode(s3BucketArn, forKey: .s3BucketArn)
        }
        if let s3Config = s3Config {
            try encodeContainer.encode(s3Config, forKey: .s3Config)
        }
        if let s3StorageClass = s3StorageClass {
            try encodeContainer.encode(s3StorageClass.rawValue, forKey: .s3StorageClass)
        }
        if let subdirectory = subdirectory {
            try encodeContainer.encode(subdirectory, forKey: .subdirectory)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for inputtaglist0 in tags {
                try tagsContainer.encode(inputtaglist0)
            }
        }
    }
}

public struct CreateLocationS3InputHeadersMiddleware: Middleware {
    public let id: String = "CreateLocationS3InputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLocationS3Input>,
                  next: H) -> Swift.Result<OperationOutput<CreateLocationS3OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLocationS3Input>
    public typealias MOutput = OperationOutput<CreateLocationS3OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLocationS3OutputError>
}

public struct CreateLocationS3InputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLocationS3InputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLocationS3Input>,
                  next: H) -> Swift.Result<OperationOutput<CreateLocationS3OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLocationS3Input>
    public typealias MOutput = OperationOutput<CreateLocationS3OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLocationS3OutputError>
}

/// <p>CreateLocationS3Request</p>
public struct CreateLocationS3Input: Equatable {
    /// <p>If you are using DataSync on an AWS Outpost, specify the Amazon Resource Names (ARNs) of
    ///       the DataSync agents deployed on your Outpost. For more information about launching a DataSync
    ///       agent on an AWS Outpost, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/deploy-agents.html#outposts-agent">Deploy your DataSync agent on AWS Outposts</a>.</p>
    public let agentArns: [String]?
    /// <p>The ARN of the Amazon S3 bucket. If the bucket is on an AWS Outpost, this must be an
    ///       access point ARN.</p>
    public let s3BucketArn: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role
    ///       that is used to access an Amazon S3 bucket.</p>
    ///
    ///          <p>For detailed information about using such a role, see Creating a Location for
    ///       Amazon S3 in the <i>AWS DataSync User Guide</i>.</p>
    public let s3Config: S3Config?
    /// <p>The Amazon S3 storage class that you want to store your files in when this location is
    ///       used as a task destination. For buckets in AWS Regions, the storage class defaults to Standard.
    ///       For buckets on AWS Outposts, the storage class defaults to AWS S3 Outposts.</p>
    ///
    ///          <p>For more information about S3 storage classes, see <a href="http://aws.amazon.com/s3/storage-classes/">Amazon S3 Storage Classes</a>. Some storage classes have behaviors that
    ///       can affect your S3 storage cost. For detailed information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-s3-location.html#using-storage-classes">Considerations when working with S3 storage classes in DataSync</a>.</p>
    public let s3StorageClass: S3StorageClass?
    /// <p>A subdirectory in the Amazon S3 bucket. This subdirectory in Amazon S3 is used to read
    ///       data from the S3 source location or write data to the S3 destination.</p>
    public let subdirectory: String?
    /// <p>The key-value pair that represents the tag that you want to add to the location. The
    ///       value can be an empty string. We recommend using tags to name your resources.</p>
    public let tags: [TagListEntry]?

    public init (
        agentArns: [String]? = nil,
        s3BucketArn: String? = nil,
        s3Config: S3Config? = nil,
        s3StorageClass: S3StorageClass? = nil,
        subdirectory: String? = nil,
        tags: [TagListEntry]? = nil
    )
    {
        self.agentArns = agentArns
        self.s3BucketArn = s3BucketArn
        self.s3Config = s3Config
        self.s3StorageClass = s3StorageClass
        self.subdirectory = subdirectory
        self.tags = tags
    }
}

struct CreateLocationS3InputBody: Equatable {
    public let subdirectory: String?
    public let s3BucketArn: String?
    public let s3StorageClass: S3StorageClass?
    public let s3Config: S3Config?
    public let agentArns: [String]?
    public let tags: [TagListEntry]?
}

extension CreateLocationS3InputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentArns = "AgentArns"
        case s3BucketArn = "S3BucketArn"
        case s3Config = "S3Config"
        case s3StorageClass = "S3StorageClass"
        case subdirectory = "Subdirectory"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subdirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subdirectory)
        subdirectory = subdirectoryDecoded
        let s3BucketArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketArn)
        s3BucketArn = s3BucketArnDecoded
        let s3StorageClassDecoded = try containerValues.decodeIfPresent(S3StorageClass.self, forKey: .s3StorageClass)
        s3StorageClass = s3StorageClassDecoded
        let s3ConfigDecoded = try containerValues.decodeIfPresent(S3Config.self, forKey: .s3Config)
        s3Config = s3ConfigDecoded
        let agentArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .agentArns)
        var agentArnsDecoded0:[String]? = nil
        if let agentArnsContainer = agentArnsContainer {
            agentArnsDecoded0 = [String]()
            for string0 in agentArnsContainer {
                if let string0 = string0 {
                    agentArnsDecoded0?.append(string0)
                }
            }
        }
        agentArns = agentArnsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([TagListEntry?].self, forKey: .tags)
        var tagsDecoded0:[TagListEntry]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TagListEntry]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLocationS3OutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLocationS3OutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLocationS3OutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLocationS3OutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLocationS3OutputResponse(locationArn: \(String(describing: locationArn)))"}
}

extension CreateLocationS3OutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLocationS3OutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.locationArn = output.locationArn
        } else {
            self.locationArn = nil
        }
    }
}

/// <p>CreateLocationS3Response</p>
public struct CreateLocationS3OutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the source Amazon S3 bucket location that is
    ///       created.</p>
    public let locationArn: String?

    public init (
        locationArn: String? = nil
    )
    {
        self.locationArn = locationArn
    }
}

struct CreateLocationS3OutputResponseBody: Equatable {
    public let locationArn: String?
}

extension CreateLocationS3OutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case locationArn = "LocationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationArn)
        locationArn = locationArnDecoded
    }
}

public struct CreateLocationSmbInputBodyMiddleware: Middleware {
    public let id: String = "CreateLocationSmbInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLocationSmbInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLocationSmbOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLocationSmbInput>
    public typealias MOutput = OperationOutput<CreateLocationSmbOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLocationSmbOutputError>
}

extension CreateLocationSmbInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLocationSmbInput(agentArns: \(String(describing: agentArns)), domain: \(String(describing: domain)), mountOptions: \(String(describing: mountOptions)), password: \(String(describing: password)), serverHostname: \(String(describing: serverHostname)), subdirectory: \(String(describing: subdirectory)), tags: \(String(describing: tags)), user: \(String(describing: user)))"}
}

extension CreateLocationSmbInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentArns = "AgentArns"
        case domain = "Domain"
        case mountOptions = "MountOptions"
        case password = "Password"
        case serverHostname = "ServerHostname"
        case subdirectory = "Subdirectory"
        case tags = "Tags"
        case user = "User"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentArns = agentArns {
            var agentArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentArns)
            for agentarnlist0 in agentArns {
                try agentArnsContainer.encode(agentarnlist0)
            }
        }
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let mountOptions = mountOptions {
            try encodeContainer.encode(mountOptions, forKey: .mountOptions)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let serverHostname = serverHostname {
            try encodeContainer.encode(serverHostname, forKey: .serverHostname)
        }
        if let subdirectory = subdirectory {
            try encodeContainer.encode(subdirectory, forKey: .subdirectory)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for inputtaglist0 in tags {
                try tagsContainer.encode(inputtaglist0)
            }
        }
        if let user = user {
            try encodeContainer.encode(user, forKey: .user)
        }
    }
}

public struct CreateLocationSmbInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLocationSmbInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLocationSmbInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLocationSmbOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLocationSmbInput>
    public typealias MOutput = OperationOutput<CreateLocationSmbOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLocationSmbOutputError>
}

public struct CreateLocationSmbInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLocationSmbInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLocationSmbInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLocationSmbOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLocationSmbInput>
    public typealias MOutput = OperationOutput<CreateLocationSmbOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLocationSmbOutputError>
}

/// <p>CreateLocationSmbRequest</p>
public struct CreateLocationSmbInput: Equatable {
    /// <p>The Amazon Resource Names (ARNs) of agents to use for a Simple Message Block (SMB)
    ///       location. </p>
    public let agentArns: [String]?
    /// <p>The name of the Windows domain that the SMB server belongs to.</p>
    public let domain: String?
    /// <p>The mount options used by DataSync to access the SMB server.</p>
    public let mountOptions: SmbMountOptions?
    /// <p>The password of the user who can mount the share, has the permissions to access files and
    ///       folders in the SMB share.</p>
    public let password: String?
    /// <p>The name of the SMB server. This value is the IP address or Domain Name Service (DNS) name
    ///       of the SMB server. An agent that is installed on-premises uses this hostname to mount the SMB
    ///       server in a network.</p>
    ///          <note>
    ///             <p>This name must either be DNS-compliant or must be an IP version 4 (IPv4) address.</p>
    ///          </note>
    public let serverHostname: String?
    /// <p>The subdirectory in the SMB file system that is used to read data from the SMB source
    ///       location or write data to the SMB destination. The SMB path should be a path that's
    ///       exported by the SMB server, or a subdirectory of that path. The path should be such that it
    ///       can be mounted by other SMB clients in your network.</p>
    ///          <note>
    ///             <p>
    ///                <code>Subdirectory</code> must be specified with forward slashes. For example,
    ///           <code>/path/to/folder</code>.</p>
    ///          </note>
    ///
    ///          <p>To transfer all the data in the folder you specified, DataSync needs to have permissions
    ///       to mount the SMB share, as well as to access all the data in that share. To ensure this,
    ///       either ensure that the user/password specified belongs to the user who can mount the share,
    ///       and who has the appropriate permissions for all of the files and directories that you want
    ///       DataSync to access, or use credentials of a member of the Backup Operators group to mount
    ///       the share. Doing either enables the agent to access the data. For the agent to access
    ///       directories, you must additionally enable all execute access.</p>
    public let subdirectory: String?
    /// <p>The key-value pair that represents the tag that you want to add to the location. The value
    ///       can be an empty string. We recommend using tags to name your resources.</p>
    public let tags: [TagListEntry]?
    /// <p>The user who can mount the share, has the permissions to access files and folders in the
    ///       SMB share.</p>
    ///
    ///          <p>For information about choosing a user name that ensures sufficient permissions to files,
    ///       folders, and metadata, see <a href="create-smb-location.html#SMBuser">user</a>.</p>
    public let user: String?

    public init (
        agentArns: [String]? = nil,
        domain: String? = nil,
        mountOptions: SmbMountOptions? = nil,
        password: String? = nil,
        serverHostname: String? = nil,
        subdirectory: String? = nil,
        tags: [TagListEntry]? = nil,
        user: String? = nil
    )
    {
        self.agentArns = agentArns
        self.domain = domain
        self.mountOptions = mountOptions
        self.password = password
        self.serverHostname = serverHostname
        self.subdirectory = subdirectory
        self.tags = tags
        self.user = user
    }
}

struct CreateLocationSmbInputBody: Equatable {
    public let subdirectory: String?
    public let serverHostname: String?
    public let user: String?
    public let domain: String?
    public let password: String?
    public let agentArns: [String]?
    public let mountOptions: SmbMountOptions?
    public let tags: [TagListEntry]?
}

extension CreateLocationSmbInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentArns = "AgentArns"
        case domain = "Domain"
        case mountOptions = "MountOptions"
        case password = "Password"
        case serverHostname = "ServerHostname"
        case subdirectory = "Subdirectory"
        case tags = "Tags"
        case user = "User"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subdirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subdirectory)
        subdirectory = subdirectoryDecoded
        let serverHostnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverHostname)
        serverHostname = serverHostnameDecoded
        let userDecoded = try containerValues.decodeIfPresent(String.self, forKey: .user)
        user = userDecoded
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let agentArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .agentArns)
        var agentArnsDecoded0:[String]? = nil
        if let agentArnsContainer = agentArnsContainer {
            agentArnsDecoded0 = [String]()
            for string0 in agentArnsContainer {
                if let string0 = string0 {
                    agentArnsDecoded0?.append(string0)
                }
            }
        }
        agentArns = agentArnsDecoded0
        let mountOptionsDecoded = try containerValues.decodeIfPresent(SmbMountOptions.self, forKey: .mountOptions)
        mountOptions = mountOptionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TagListEntry?].self, forKey: .tags)
        var tagsDecoded0:[TagListEntry]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TagListEntry]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLocationSmbOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLocationSmbOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLocationSmbOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLocationSmbOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLocationSmbOutputResponse(locationArn: \(String(describing: locationArn)))"}
}

extension CreateLocationSmbOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLocationSmbOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.locationArn = output.locationArn
        } else {
            self.locationArn = nil
        }
    }
}

/// <p>CreateLocationSmbResponse</p>
public struct CreateLocationSmbOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the source SMB file system location that is
    ///       created.</p>
    public let locationArn: String?

    public init (
        locationArn: String? = nil
    )
    {
        self.locationArn = locationArn
    }
}

struct CreateLocationSmbOutputResponseBody: Equatable {
    public let locationArn: String?
}

extension CreateLocationSmbOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case locationArn = "LocationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationArn)
        locationArn = locationArnDecoded
    }
}

public struct CreateTaskInputBodyMiddleware: Middleware {
    public let id: String = "CreateTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTaskInput>
    public typealias MOutput = OperationOutput<CreateTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTaskOutputError>
}

extension CreateTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTaskInput(cloudWatchLogGroupArn: \(String(describing: cloudWatchLogGroupArn)), destinationLocationArn: \(String(describing: destinationLocationArn)), excludes: \(String(describing: excludes)), name: \(String(describing: name)), options: \(String(describing: options)), schedule: \(String(describing: schedule)), sourceLocationArn: \(String(describing: sourceLocationArn)), tags: \(String(describing: tags)))"}
}

extension CreateTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogGroupArn = "CloudWatchLogGroupArn"
        case destinationLocationArn = "DestinationLocationArn"
        case excludes = "Excludes"
        case name = "Name"
        case options = "Options"
        case schedule = "Schedule"
        case sourceLocationArn = "SourceLocationArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogGroupArn = cloudWatchLogGroupArn {
            try encodeContainer.encode(cloudWatchLogGroupArn, forKey: .cloudWatchLogGroupArn)
        }
        if let destinationLocationArn = destinationLocationArn {
            try encodeContainer.encode(destinationLocationArn, forKey: .destinationLocationArn)
        }
        if let excludes = excludes {
            var excludesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludes)
            for filterlist0 in excludes {
                try excludesContainer.encode(filterlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let options = options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let sourceLocationArn = sourceLocationArn {
            try encodeContainer.encode(sourceLocationArn, forKey: .sourceLocationArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for inputtaglist0 in tags {
                try tagsContainer.encode(inputtaglist0)
            }
        }
    }
}

public struct CreateTaskInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTaskInput>
    public typealias MOutput = OperationOutput<CreateTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTaskOutputError>
}

public struct CreateTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTaskInput>
    public typealias MOutput = OperationOutput<CreateTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTaskOutputError>
}

/// <p>CreateTaskRequest</p>
public struct CreateTaskInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Amazon CloudWatch log group that is used to
    ///       monitor and log events in the task. </p>
    public let cloudWatchLogGroupArn: String?
    /// <p>The Amazon Resource Name (ARN) of an AWS storage resource's location. </p>
    public let destinationLocationArn: String?
    /// <p>A list of filter rules that determines which files to exclude from a task. The list should
    ///       contain a single filter string that consists of the patterns to exclude. The patterns are
    ///       delimited by "|" (that is, a pipe), for example, <code>"/folder1|/folder2"</code>. </p>
    ///          <p>
    ///     </p>
    public let excludes: [FilterRule]?
    /// <p>The name of a task. This value is a text reference that is used to identify the task in
    ///       the console. </p>
    public let name: String?
    /// <p>The set of configuration options that control the behavior of a single execution of the
    ///       task that occurs when you call <code>StartTaskExecution</code>. You can configure these
    ///       options to preserve metadata such as user ID (UID) and group ID (GID), file permissions, data
    ///       integrity verification, and so on.</p>
    ///          <p>For each individual task execution, you can override these options by specifying the
    ///         <code>OverrideOptions</code> before starting the task execution. For more information, see
    ///       the <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a> operation. </p>
    public let options: Options?
    /// <p>Specifies a schedule used to periodically transfer files from a source to a destination
    ///       location. The schedule should be specified in UTC time. For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/task-scheduling.html">Scheduling your task</a>.</p>
    public let schedule: TaskSchedule?
    /// <p>The Amazon Resource Name (ARN) of the source location for the task.</p>
    public let sourceLocationArn: String?
    /// <p>The key-value pair that represents the tag that you want to add to the resource. The
    ///       value can be an empty string. </p>
    public let tags: [TagListEntry]?

    public init (
        cloudWatchLogGroupArn: String? = nil,
        destinationLocationArn: String? = nil,
        excludes: [FilterRule]? = nil,
        name: String? = nil,
        options: Options? = nil,
        schedule: TaskSchedule? = nil,
        sourceLocationArn: String? = nil,
        tags: [TagListEntry]? = nil
    )
    {
        self.cloudWatchLogGroupArn = cloudWatchLogGroupArn
        self.destinationLocationArn = destinationLocationArn
        self.excludes = excludes
        self.name = name
        self.options = options
        self.schedule = schedule
        self.sourceLocationArn = sourceLocationArn
        self.tags = tags
    }
}

struct CreateTaskInputBody: Equatable {
    public let sourceLocationArn: String?
    public let destinationLocationArn: String?
    public let cloudWatchLogGroupArn: String?
    public let name: String?
    public let options: Options?
    public let excludes: [FilterRule]?
    public let schedule: TaskSchedule?
    public let tags: [TagListEntry]?
}

extension CreateTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogGroupArn = "CloudWatchLogGroupArn"
        case destinationLocationArn = "DestinationLocationArn"
        case excludes = "Excludes"
        case name = "Name"
        case options = "Options"
        case schedule = "Schedule"
        case sourceLocationArn = "SourceLocationArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceLocationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLocationArn)
        sourceLocationArn = sourceLocationArnDecoded
        let destinationLocationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationLocationArn)
        destinationLocationArn = destinationLocationArnDecoded
        let cloudWatchLogGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogGroupArn)
        cloudWatchLogGroupArn = cloudWatchLogGroupArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let optionsDecoded = try containerValues.decodeIfPresent(Options.self, forKey: .options)
        options = optionsDecoded
        let excludesContainer = try containerValues.decodeIfPresent([FilterRule?].self, forKey: .excludes)
        var excludesDecoded0:[FilterRule]? = nil
        if let excludesContainer = excludesContainer {
            excludesDecoded0 = [FilterRule]()
            for structure0 in excludesContainer {
                if let structure0 = structure0 {
                    excludesDecoded0?.append(structure0)
                }
            }
        }
        excludes = excludesDecoded0
        let scheduleDecoded = try containerValues.decodeIfPresent(TaskSchedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TagListEntry?].self, forKey: .tags)
        var tagsDecoded0:[TagListEntry]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TagListEntry]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTaskOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTaskOutputResponse(taskArn: \(String(describing: taskArn)))"}
}

extension CreateTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.taskArn = output.taskArn
        } else {
            self.taskArn = nil
        }
    }
}

/// <p>CreateTaskResponse</p>
public struct CreateTaskOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the task.</p>
    public let taskArn: String?

    public init (
        taskArn: String? = nil
    )
    {
        self.taskArn = taskArn
    }
}

struct CreateTaskOutputResponseBody: Equatable {
    public let taskArn: String?
}

extension CreateTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case taskArn = "TaskArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
    }
}

public struct DeleteAgentInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAgentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAgentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAgentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAgentInput>
    public typealias MOutput = OperationOutput<DeleteAgentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAgentOutputError>
}

extension DeleteAgentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAgentInput(agentArn: \(String(describing: agentArn)))"}
}

extension DeleteAgentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentArn = "AgentArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentArn = agentArn {
            try encodeContainer.encode(agentArn, forKey: .agentArn)
        }
    }
}

public struct DeleteAgentInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAgentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAgentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAgentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAgentInput>
    public typealias MOutput = OperationOutput<DeleteAgentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAgentOutputError>
}

public struct DeleteAgentInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAgentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAgentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAgentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAgentInput>
    public typealias MOutput = OperationOutput<DeleteAgentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAgentOutputError>
}

/// <p>DeleteAgentRequest</p>
public struct DeleteAgentInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the agent to delete. Use the <code>ListAgents</code>
    ///       operation to return a list of agents for your account and AWS Region.</p>
    public let agentArn: String?

    public init (
        agentArn: String? = nil
    )
    {
        self.agentArn = agentArn
    }
}

struct DeleteAgentInputBody: Equatable {
    public let agentArn: String?
}

extension DeleteAgentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentArn = "AgentArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentArn)
        agentArn = agentArnDecoded
    }
}

extension DeleteAgentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAgentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAgentOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAgentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAgentOutputResponse()"}
}

extension DeleteAgentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAgentOutputResponse: Equatable {

    public init() {}
}

struct DeleteAgentOutputResponseBody: Equatable {
}

extension DeleteAgentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteLocationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteLocationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLocationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLocationInput>
    public typealias MOutput = OperationOutput<DeleteLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLocationOutputError>
}

extension DeleteLocationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLocationInput(locationArn: \(String(describing: locationArn)))"}
}

extension DeleteLocationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case locationArn = "LocationArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locationArn = locationArn {
            try encodeContainer.encode(locationArn, forKey: .locationArn)
        }
    }
}

public struct DeleteLocationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLocationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLocationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLocationInput>
    public typealias MOutput = OperationOutput<DeleteLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLocationOutputError>
}

public struct DeleteLocationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLocationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLocationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLocationInput>
    public typealias MOutput = OperationOutput<DeleteLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLocationOutputError>
}

/// <p>DeleteLocation</p>
public struct DeleteLocationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the location to delete.</p>
    public let locationArn: String?

    public init (
        locationArn: String? = nil
    )
    {
        self.locationArn = locationArn
    }
}

struct DeleteLocationInputBody: Equatable {
    public let locationArn: String?
}

extension DeleteLocationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case locationArn = "LocationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationArn)
        locationArn = locationArnDecoded
    }
}

extension DeleteLocationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLocationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLocationOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLocationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLocationOutputResponse()"}
}

extension DeleteLocationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLocationOutputResponse: Equatable {

    public init() {}
}

struct DeleteLocationOutputResponseBody: Equatable {
}

extension DeleteLocationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteTaskInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTaskInput>
    public typealias MOutput = OperationOutput<DeleteTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTaskOutputError>
}

extension DeleteTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTaskInput(taskArn: \(String(describing: taskArn)))"}
}

extension DeleteTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case taskArn = "TaskArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let taskArn = taskArn {
            try encodeContainer.encode(taskArn, forKey: .taskArn)
        }
    }
}

public struct DeleteTaskInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTaskInput>
    public typealias MOutput = OperationOutput<DeleteTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTaskOutputError>
}

public struct DeleteTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTaskInput>
    public typealias MOutput = OperationOutput<DeleteTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTaskOutputError>
}

/// <p>DeleteTask</p>
public struct DeleteTaskInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the task to delete.</p>
    public let taskArn: String?

    public init (
        taskArn: String? = nil
    )
    {
        self.taskArn = taskArn
    }
}

struct DeleteTaskInputBody: Equatable {
    public let taskArn: String?
}

extension DeleteTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case taskArn = "TaskArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
    }
}

extension DeleteTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTaskOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTaskOutputResponse()"}
}

extension DeleteTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTaskOutputResponse: Equatable {

    public init() {}
}

struct DeleteTaskOutputResponseBody: Equatable {
}

extension DeleteTaskOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeAgentInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAgentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAgentInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAgentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAgentInput>
    public typealias MOutput = OperationOutput<DescribeAgentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAgentOutputError>
}

extension DescribeAgentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAgentInput(agentArn: \(String(describing: agentArn)))"}
}

extension DescribeAgentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentArn = "AgentArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentArn = agentArn {
            try encodeContainer.encode(agentArn, forKey: .agentArn)
        }
    }
}

public struct DescribeAgentInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAgentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAgentInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAgentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAgentInput>
    public typealias MOutput = OperationOutput<DescribeAgentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAgentOutputError>
}

public struct DescribeAgentInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAgentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAgentInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAgentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAgentInput>
    public typealias MOutput = OperationOutput<DescribeAgentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAgentOutputError>
}

/// <p>DescribeAgent</p>
public struct DescribeAgentInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the agent to describe.</p>
    public let agentArn: String?

    public init (
        agentArn: String? = nil
    )
    {
        self.agentArn = agentArn
    }
}

struct DescribeAgentInputBody: Equatable {
    public let agentArn: String?
}

extension DescribeAgentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentArn = "AgentArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentArn)
        agentArn = agentArnDecoded
    }
}

extension DescribeAgentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAgentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAgentOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAgentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAgentOutputResponse(agentArn: \(String(describing: agentArn)), creationTime: \(String(describing: creationTime)), endpointType: \(String(describing: endpointType)), lastConnectionTime: \(String(describing: lastConnectionTime)), name: \(String(describing: name)), privateLinkConfig: \(String(describing: privateLinkConfig)), status: \(String(describing: status)))"}
}

extension DescribeAgentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAgentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.agentArn = output.agentArn
            self.creationTime = output.creationTime
            self.endpointType = output.endpointType
            self.lastConnectionTime = output.lastConnectionTime
            self.name = output.name
            self.privateLinkConfig = output.privateLinkConfig
            self.status = output.status
        } else {
            self.agentArn = nil
            self.creationTime = nil
            self.endpointType = nil
            self.lastConnectionTime = nil
            self.name = nil
            self.privateLinkConfig = nil
            self.status = nil
        }
    }
}

/// <p>DescribeAgentResponse</p>
public struct DescribeAgentOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the agent.</p>
    public let agentArn: String?
    /// <p>The time that the agent was activated (that is, created in your account).</p>
    public let creationTime: Date?
    /// <p>The type of endpoint that your agent is connected to. If the endpoint is a VPC endpoint,
    ///       the agent is not accessible over the public internet. </p>
    public let endpointType: EndpointType?
    /// <p>The time that the agent last connected to DataSync.</p>
    public let lastConnectionTime: Date?
    /// <p>The name of the agent.</p>
    public let name: String?
    /// <p>The subnet and the security group that DataSync used to access a VPC endpoint.</p>
    public let privateLinkConfig: PrivateLinkConfig?
    /// <p>The status of the agent. If the status is ONLINE, then the agent is configured properly
    ///       and is available to use. The Running status is the normal running status for an agent. If the
    ///       status is OFFLINE, the agent's VM is turned off or the agent is in an unhealthy state. When
    ///       the issue that caused the unhealthy state is resolved, the agent returns to ONLINE
    ///       status.</p>
    public let status: AgentStatus?

    public init (
        agentArn: String? = nil,
        creationTime: Date? = nil,
        endpointType: EndpointType? = nil,
        lastConnectionTime: Date? = nil,
        name: String? = nil,
        privateLinkConfig: PrivateLinkConfig? = nil,
        status: AgentStatus? = nil
    )
    {
        self.agentArn = agentArn
        self.creationTime = creationTime
        self.endpointType = endpointType
        self.lastConnectionTime = lastConnectionTime
        self.name = name
        self.privateLinkConfig = privateLinkConfig
        self.status = status
    }
}

struct DescribeAgentOutputResponseBody: Equatable {
    public let agentArn: String?
    public let name: String?
    public let status: AgentStatus?
    public let lastConnectionTime: Date?
    public let creationTime: Date?
    public let endpointType: EndpointType?
    public let privateLinkConfig: PrivateLinkConfig?
}

extension DescribeAgentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentArn = "AgentArn"
        case creationTime = "CreationTime"
        case endpointType = "EndpointType"
        case lastConnectionTime = "LastConnectionTime"
        case name = "Name"
        case privateLinkConfig = "PrivateLinkConfig"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentArn)
        agentArn = agentArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AgentStatus.self, forKey: .status)
        status = statusDecoded
        let lastConnectionTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastConnectionTime)
        lastConnectionTime = lastConnectionTimeDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let privateLinkConfigDecoded = try containerValues.decodeIfPresent(PrivateLinkConfig.self, forKey: .privateLinkConfig)
        privateLinkConfig = privateLinkConfigDecoded
    }
}

public struct DescribeLocationEfsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeLocationEfsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLocationEfsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLocationEfsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLocationEfsInput>
    public typealias MOutput = OperationOutput<DescribeLocationEfsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLocationEfsOutputError>
}

extension DescribeLocationEfsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLocationEfsInput(locationArn: \(String(describing: locationArn)))"}
}

extension DescribeLocationEfsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case locationArn = "LocationArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locationArn = locationArn {
            try encodeContainer.encode(locationArn, forKey: .locationArn)
        }
    }
}

public struct DescribeLocationEfsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLocationEfsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLocationEfsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLocationEfsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLocationEfsInput>
    public typealias MOutput = OperationOutput<DescribeLocationEfsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLocationEfsOutputError>
}

public struct DescribeLocationEfsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLocationEfsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLocationEfsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLocationEfsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLocationEfsInput>
    public typealias MOutput = OperationOutput<DescribeLocationEfsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLocationEfsOutputError>
}

/// <p>DescribeLocationEfsRequest</p>
public struct DescribeLocationEfsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the EFS location to describe.</p>
    public let locationArn: String?

    public init (
        locationArn: String? = nil
    )
    {
        self.locationArn = locationArn
    }
}

struct DescribeLocationEfsInputBody: Equatable {
    public let locationArn: String?
}

extension DescribeLocationEfsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case locationArn = "LocationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationArn)
        locationArn = locationArnDecoded
    }
}

extension DescribeLocationEfsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLocationEfsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLocationEfsOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLocationEfsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLocationEfsOutputResponse(creationTime: \(String(describing: creationTime)), ec2Config: \(String(describing: ec2Config)), locationArn: \(String(describing: locationArn)), locationUri: \(String(describing: locationUri)))"}
}

extension DescribeLocationEfsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeLocationEfsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.ec2Config = output.ec2Config
            self.locationArn = output.locationArn
            self.locationUri = output.locationUri
        } else {
            self.creationTime = nil
            self.ec2Config = nil
            self.locationArn = nil
            self.locationUri = nil
        }
    }
}

/// <p>DescribeLocationEfsResponse</p>
public struct DescribeLocationEfsOutputResponse: Equatable {
    /// <p>The time that the EFS location was created.</p>
    public let creationTime: Date?
    /// <p>The subnet and the security group that DataSync uses to access target EFS file system.
    ///       The subnet must have at least one mount target for that file system. The security group that
    ///       you provide needs to be able to communicate with the security group on the mount target in the
    ///       subnet specified. </p>
    public let ec2Config: Ec2Config?
    /// <p>The Amazon Resource Name (ARN) of the EFS location that was described.</p>
    public let locationArn: String?
    /// <p>The URL of the EFS location that was described.</p>
    public let locationUri: String?

    public init (
        creationTime: Date? = nil,
        ec2Config: Ec2Config? = nil,
        locationArn: String? = nil,
        locationUri: String? = nil
    )
    {
        self.creationTime = creationTime
        self.ec2Config = ec2Config
        self.locationArn = locationArn
        self.locationUri = locationUri
    }
}

struct DescribeLocationEfsOutputResponseBody: Equatable {
    public let locationArn: String?
    public let locationUri: String?
    public let ec2Config: Ec2Config?
    public let creationTime: Date?
}

extension DescribeLocationEfsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case ec2Config = "Ec2Config"
        case locationArn = "LocationArn"
        case locationUri = "LocationUri"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationArn)
        locationArn = locationArnDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let ec2ConfigDecoded = try containerValues.decodeIfPresent(Ec2Config.self, forKey: .ec2Config)
        ec2Config = ec2ConfigDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

public struct DescribeLocationFsxWindowsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeLocationFsxWindowsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLocationFsxWindowsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLocationFsxWindowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLocationFsxWindowsInput>
    public typealias MOutput = OperationOutput<DescribeLocationFsxWindowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLocationFsxWindowsOutputError>
}

extension DescribeLocationFsxWindowsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLocationFsxWindowsInput(locationArn: \(String(describing: locationArn)))"}
}

extension DescribeLocationFsxWindowsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case locationArn = "LocationArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locationArn = locationArn {
            try encodeContainer.encode(locationArn, forKey: .locationArn)
        }
    }
}

public struct DescribeLocationFsxWindowsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLocationFsxWindowsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLocationFsxWindowsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLocationFsxWindowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLocationFsxWindowsInput>
    public typealias MOutput = OperationOutput<DescribeLocationFsxWindowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLocationFsxWindowsOutputError>
}

public struct DescribeLocationFsxWindowsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLocationFsxWindowsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLocationFsxWindowsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLocationFsxWindowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLocationFsxWindowsInput>
    public typealias MOutput = OperationOutput<DescribeLocationFsxWindowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLocationFsxWindowsOutputError>
}

public struct DescribeLocationFsxWindowsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the FSx for Windows File Server location to
    ///       describe.</p>
    public let locationArn: String?

    public init (
        locationArn: String? = nil
    )
    {
        self.locationArn = locationArn
    }
}

struct DescribeLocationFsxWindowsInputBody: Equatable {
    public let locationArn: String?
}

extension DescribeLocationFsxWindowsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case locationArn = "LocationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationArn)
        locationArn = locationArnDecoded
    }
}

extension DescribeLocationFsxWindowsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLocationFsxWindowsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLocationFsxWindowsOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLocationFsxWindowsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLocationFsxWindowsOutputResponse(creationTime: \(String(describing: creationTime)), domain: \(String(describing: domain)), locationArn: \(String(describing: locationArn)), locationUri: \(String(describing: locationUri)), securityGroupArns: \(String(describing: securityGroupArns)), user: \(String(describing: user)))"}
}

extension DescribeLocationFsxWindowsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeLocationFsxWindowsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.domain = output.domain
            self.locationArn = output.locationArn
            self.locationUri = output.locationUri
            self.securityGroupArns = output.securityGroupArns
            self.user = output.user
        } else {
            self.creationTime = nil
            self.domain = nil
            self.locationArn = nil
            self.locationUri = nil
            self.securityGroupArns = nil
            self.user = nil
        }
    }
}

public struct DescribeLocationFsxWindowsOutputResponse: Equatable {
    /// <p>The time that the FSx for Windows File Server location was created.</p>
    public let creationTime: Date?
    /// <p>The name of the Windows domain that the FSx for Windows File Server belongs to.</p>
    public let domain: String?
    /// <p>The Amazon Resource Name (ARN) of the FSx for Windows File Server location that was
    ///       described.</p>
    public let locationArn: String?
    /// <p>The URL of the FSx for Windows File Server location that was described.</p>
    public let locationUri: String?
    /// <p>The Amazon Resource Names (ARNs) of the security groups that are configured for the FSx
    ///       for Windows File Server file system.</p>
    public let securityGroupArns: [String]?
    /// <p>The user who has the permissions to access files and folders in the FSx for Windows File
    ///       Server file system.</p>
    public let user: String?

    public init (
        creationTime: Date? = nil,
        domain: String? = nil,
        locationArn: String? = nil,
        locationUri: String? = nil,
        securityGroupArns: [String]? = nil,
        user: String? = nil
    )
    {
        self.creationTime = creationTime
        self.domain = domain
        self.locationArn = locationArn
        self.locationUri = locationUri
        self.securityGroupArns = securityGroupArns
        self.user = user
    }
}

struct DescribeLocationFsxWindowsOutputResponseBody: Equatable {
    public let locationArn: String?
    public let locationUri: String?
    public let securityGroupArns: [String]?
    public let creationTime: Date?
    public let user: String?
    public let domain: String?
}

extension DescribeLocationFsxWindowsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case domain = "Domain"
        case locationArn = "LocationArn"
        case locationUri = "LocationUri"
        case securityGroupArns = "SecurityGroupArns"
        case user = "User"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationArn)
        locationArn = locationArnDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let securityGroupArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupArns)
        var securityGroupArnsDecoded0:[String]? = nil
        if let securityGroupArnsContainer = securityGroupArnsContainer {
            securityGroupArnsDecoded0 = [String]()
            for string0 in securityGroupArnsContainer {
                if let string0 = string0 {
                    securityGroupArnsDecoded0?.append(string0)
                }
            }
        }
        securityGroupArns = securityGroupArnsDecoded0
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let userDecoded = try containerValues.decodeIfPresent(String.self, forKey: .user)
        user = userDecoded
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
    }
}

public struct DescribeLocationNfsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeLocationNfsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLocationNfsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLocationNfsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLocationNfsInput>
    public typealias MOutput = OperationOutput<DescribeLocationNfsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLocationNfsOutputError>
}

extension DescribeLocationNfsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLocationNfsInput(locationArn: \(String(describing: locationArn)))"}
}

extension DescribeLocationNfsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case locationArn = "LocationArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locationArn = locationArn {
            try encodeContainer.encode(locationArn, forKey: .locationArn)
        }
    }
}

public struct DescribeLocationNfsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLocationNfsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLocationNfsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLocationNfsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLocationNfsInput>
    public typealias MOutput = OperationOutput<DescribeLocationNfsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLocationNfsOutputError>
}

public struct DescribeLocationNfsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLocationNfsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLocationNfsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLocationNfsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLocationNfsInput>
    public typealias MOutput = OperationOutput<DescribeLocationNfsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLocationNfsOutputError>
}

/// <p>DescribeLocationNfsRequest</p>
public struct DescribeLocationNfsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the NFS location to describe.</p>
    public let locationArn: String?

    public init (
        locationArn: String? = nil
    )
    {
        self.locationArn = locationArn
    }
}

struct DescribeLocationNfsInputBody: Equatable {
    public let locationArn: String?
}

extension DescribeLocationNfsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case locationArn = "LocationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationArn)
        locationArn = locationArnDecoded
    }
}

extension DescribeLocationNfsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLocationNfsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLocationNfsOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLocationNfsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLocationNfsOutputResponse(creationTime: \(String(describing: creationTime)), locationArn: \(String(describing: locationArn)), locationUri: \(String(describing: locationUri)), mountOptions: \(String(describing: mountOptions)), onPremConfig: \(String(describing: onPremConfig)))"}
}

extension DescribeLocationNfsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeLocationNfsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.locationArn = output.locationArn
            self.locationUri = output.locationUri
            self.mountOptions = output.mountOptions
            self.onPremConfig = output.onPremConfig
        } else {
            self.creationTime = nil
            self.locationArn = nil
            self.locationUri = nil
            self.mountOptions = nil
            self.onPremConfig = nil
        }
    }
}

/// <p>DescribeLocationNfsResponse</p>
public struct DescribeLocationNfsOutputResponse: Equatable {
    /// <p>The time that the NFS location was created.</p>
    public let creationTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the NFS location that was described.</p>
    public let locationArn: String?
    /// <p>The URL of the source NFS location that was described.</p>
    public let locationUri: String?
    /// <p>The NFS mount options that DataSync used to mount your NFS share.</p>
    public let mountOptions: NfsMountOptions?
    /// <p>A list of Amazon Resource Names (ARNs) of agents to use for a Network File System (NFS)
    ///       location.</p>
    public let onPremConfig: OnPremConfig?

    public init (
        creationTime: Date? = nil,
        locationArn: String? = nil,
        locationUri: String? = nil,
        mountOptions: NfsMountOptions? = nil,
        onPremConfig: OnPremConfig? = nil
    )
    {
        self.creationTime = creationTime
        self.locationArn = locationArn
        self.locationUri = locationUri
        self.mountOptions = mountOptions
        self.onPremConfig = onPremConfig
    }
}

struct DescribeLocationNfsOutputResponseBody: Equatable {
    public let locationArn: String?
    public let locationUri: String?
    public let onPremConfig: OnPremConfig?
    public let mountOptions: NfsMountOptions?
    public let creationTime: Date?
}

extension DescribeLocationNfsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case locationArn = "LocationArn"
        case locationUri = "LocationUri"
        case mountOptions = "MountOptions"
        case onPremConfig = "OnPremConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationArn)
        locationArn = locationArnDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let onPremConfigDecoded = try containerValues.decodeIfPresent(OnPremConfig.self, forKey: .onPremConfig)
        onPremConfig = onPremConfigDecoded
        let mountOptionsDecoded = try containerValues.decodeIfPresent(NfsMountOptions.self, forKey: .mountOptions)
        mountOptions = mountOptionsDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

public struct DescribeLocationObjectStorageInputBodyMiddleware: Middleware {
    public let id: String = "DescribeLocationObjectStorageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLocationObjectStorageInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLocationObjectStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLocationObjectStorageInput>
    public typealias MOutput = OperationOutput<DescribeLocationObjectStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLocationObjectStorageOutputError>
}

extension DescribeLocationObjectStorageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLocationObjectStorageInput(locationArn: \(String(describing: locationArn)))"}
}

extension DescribeLocationObjectStorageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case locationArn = "LocationArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locationArn = locationArn {
            try encodeContainer.encode(locationArn, forKey: .locationArn)
        }
    }
}

public struct DescribeLocationObjectStorageInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLocationObjectStorageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLocationObjectStorageInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLocationObjectStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLocationObjectStorageInput>
    public typealias MOutput = OperationOutput<DescribeLocationObjectStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLocationObjectStorageOutputError>
}

public struct DescribeLocationObjectStorageInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLocationObjectStorageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLocationObjectStorageInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLocationObjectStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLocationObjectStorageInput>
    public typealias MOutput = OperationOutput<DescribeLocationObjectStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLocationObjectStorageOutputError>
}

/// <p>DescribeLocationObjectStorageRequest</p>
public struct DescribeLocationObjectStorageInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the self-managed object storage server location that was described.</p>
    public let locationArn: String?

    public init (
        locationArn: String? = nil
    )
    {
        self.locationArn = locationArn
    }
}

struct DescribeLocationObjectStorageInputBody: Equatable {
    public let locationArn: String?
}

extension DescribeLocationObjectStorageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case locationArn = "LocationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationArn)
        locationArn = locationArnDecoded
    }
}

extension DescribeLocationObjectStorageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLocationObjectStorageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLocationObjectStorageOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLocationObjectStorageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLocationObjectStorageOutputResponse(accessKey: \(String(describing: accessKey)), agentArns: \(String(describing: agentArns)), creationTime: \(String(describing: creationTime)), locationArn: \(String(describing: locationArn)), locationUri: \(String(describing: locationUri)), serverPort: \(String(describing: serverPort)), serverProtocol: \(String(describing: serverProtocol)))"}
}

extension DescribeLocationObjectStorageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeLocationObjectStorageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessKey = output.accessKey
            self.agentArns = output.agentArns
            self.creationTime = output.creationTime
            self.locationArn = output.locationArn
            self.locationUri = output.locationUri
            self.serverPort = output.serverPort
            self.serverProtocol = output.serverProtocol
        } else {
            self.accessKey = nil
            self.agentArns = nil
            self.creationTime = nil
            self.locationArn = nil
            self.locationUri = nil
            self.serverPort = nil
            self.serverProtocol = nil
        }
    }
}

/// <p>DescribeLocationObjectStorageResponse</p>
public struct DescribeLocationObjectStorageOutputResponse: Equatable {
    /// <p>Optional. The access key is used if credentials are required to access the self-managed
    ///       object storage server. If your object storage requires a user name and password to
    ///       authenticate, use <code>AccessKey</code> and <code>SecretKey</code> to provide the user name
    ///       and password, respectively.</p>
    public let accessKey: String?
    /// <p>The Amazon Resource Name (ARN) of the agents associated with the
    ///       self-managed object storage server location.</p>
    public let agentArns: [String]?
    /// <p>The time that the self-managed object storage server agent was created.</p>
    public let creationTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the self-managed object storage server location to describe.</p>
    public let locationArn: String?
    /// <p>The URL of the source self-managed object storage server location that was described.</p>
    public let locationUri: String?
    /// <p>The port that your self-managed object storage server accepts inbound network traffic on.
    ///       The server port is set by default to TCP 80 (HTTP) or TCP 443 (HTTPS).</p>
    public let serverPort: Int?
    /// <p>The protocol that the object storage server uses to communicate.
    ///       Valid values are HTTP or HTTPS.</p>
    public let serverProtocol: ObjectStorageServerProtocol?

    public init (
        accessKey: String? = nil,
        agentArns: [String]? = nil,
        creationTime: Date? = nil,
        locationArn: String? = nil,
        locationUri: String? = nil,
        serverPort: Int? = nil,
        serverProtocol: ObjectStorageServerProtocol? = nil
    )
    {
        self.accessKey = accessKey
        self.agentArns = agentArns
        self.creationTime = creationTime
        self.locationArn = locationArn
        self.locationUri = locationUri
        self.serverPort = serverPort
        self.serverProtocol = serverProtocol
    }
}

struct DescribeLocationObjectStorageOutputResponseBody: Equatable {
    public let locationArn: String?
    public let locationUri: String?
    public let accessKey: String?
    public let serverPort: Int?
    public let serverProtocol: ObjectStorageServerProtocol?
    public let agentArns: [String]?
    public let creationTime: Date?
}

extension DescribeLocationObjectStorageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessKey = "AccessKey"
        case agentArns = "AgentArns"
        case creationTime = "CreationTime"
        case locationArn = "LocationArn"
        case locationUri = "LocationUri"
        case serverPort = "ServerPort"
        case serverProtocol = "ServerProtocol"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationArn)
        locationArn = locationArnDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let accessKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessKey)
        accessKey = accessKeyDecoded
        let serverPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .serverPort)
        serverPort = serverPortDecoded
        let serverProtocolDecoded = try containerValues.decodeIfPresent(ObjectStorageServerProtocol.self, forKey: .serverProtocol)
        serverProtocol = serverProtocolDecoded
        let agentArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .agentArns)
        var agentArnsDecoded0:[String]? = nil
        if let agentArnsContainer = agentArnsContainer {
            agentArnsDecoded0 = [String]()
            for string0 in agentArnsContainer {
                if let string0 = string0 {
                    agentArnsDecoded0?.append(string0)
                }
            }
        }
        agentArns = agentArnsDecoded0
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

public struct DescribeLocationS3InputBodyMiddleware: Middleware {
    public let id: String = "DescribeLocationS3InputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLocationS3Input>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLocationS3OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLocationS3Input>
    public typealias MOutput = OperationOutput<DescribeLocationS3OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLocationS3OutputError>
}

extension DescribeLocationS3Input: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLocationS3Input(locationArn: \(String(describing: locationArn)))"}
}

extension DescribeLocationS3Input: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case locationArn = "LocationArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locationArn = locationArn {
            try encodeContainer.encode(locationArn, forKey: .locationArn)
        }
    }
}

public struct DescribeLocationS3InputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLocationS3InputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLocationS3Input>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLocationS3OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLocationS3Input>
    public typealias MOutput = OperationOutput<DescribeLocationS3OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLocationS3OutputError>
}

public struct DescribeLocationS3InputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLocationS3InputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLocationS3Input>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLocationS3OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLocationS3Input>
    public typealias MOutput = OperationOutput<DescribeLocationS3OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLocationS3OutputError>
}

/// <p>DescribeLocationS3Request</p>
public struct DescribeLocationS3Input: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Amazon S3 bucket location to describe.</p>
    public let locationArn: String?

    public init (
        locationArn: String? = nil
    )
    {
        self.locationArn = locationArn
    }
}

struct DescribeLocationS3InputBody: Equatable {
    public let locationArn: String?
}

extension DescribeLocationS3InputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case locationArn = "LocationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationArn)
        locationArn = locationArnDecoded
    }
}

extension DescribeLocationS3OutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLocationS3OutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLocationS3OutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLocationS3OutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLocationS3OutputResponse(agentArns: \(String(describing: agentArns)), creationTime: \(String(describing: creationTime)), locationArn: \(String(describing: locationArn)), locationUri: \(String(describing: locationUri)), s3Config: \(String(describing: s3Config)), s3StorageClass: \(String(describing: s3StorageClass)))"}
}

extension DescribeLocationS3OutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeLocationS3OutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.agentArns = output.agentArns
            self.creationTime = output.creationTime
            self.locationArn = output.locationArn
            self.locationUri = output.locationUri
            self.s3Config = output.s3Config
            self.s3StorageClass = output.s3StorageClass
        } else {
            self.agentArns = nil
            self.creationTime = nil
            self.locationArn = nil
            self.locationUri = nil
            self.s3Config = nil
            self.s3StorageClass = nil
        }
    }
}

/// <p>DescribeLocationS3Response</p>
public struct DescribeLocationS3OutputResponse: Equatable {
    /// <p>If you are using DataSync on an AWS Outpost, the Amazon Resource Name (ARNs) of the EC2
    ///       agents deployed on your Outpost. For more information about launching a DataSync agent on an
    ///       AWS Outpost, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/deploy-agents.html#outposts-agent">Deploy your DataSync agent on AWS Outposts</a>.</p>
    public let agentArns: [String]?
    /// <p>The time that the Amazon S3 bucket location was created.</p>
    public let creationTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the Amazon S3 bucket or access point.</p>
    public let locationArn: String?
    /// <p>The URL of the Amazon S3 location that was described.</p>
    public let locationUri: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role
    ///       that is used to access an Amazon S3 bucket.</p>
    ///
    ///          <p>For detailed information about using such a role, see Creating a Location for
    ///       Amazon S3 in the <i>AWS DataSync User Guide</i>.</p>
    public let s3Config: S3Config?
    /// <p>The Amazon S3 storage class that you chose to store your files in when this location is
    ///       used as a task destination. For more information about S3 storage classes, see <a href="http://aws.amazon.com/s3/storage-classes/">Amazon S3 Storage Classes</a>. Some storage
    ///       classes have behaviors that can affect your S3 storage cost. For detailed information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-s3-location.html#using-storage-classes">Considerations when
    ///         working with S3 storage classes in DataSync</a>.</p>
    public let s3StorageClass: S3StorageClass?

    public init (
        agentArns: [String]? = nil,
        creationTime: Date? = nil,
        locationArn: String? = nil,
        locationUri: String? = nil,
        s3Config: S3Config? = nil,
        s3StorageClass: S3StorageClass? = nil
    )
    {
        self.agentArns = agentArns
        self.creationTime = creationTime
        self.locationArn = locationArn
        self.locationUri = locationUri
        self.s3Config = s3Config
        self.s3StorageClass = s3StorageClass
    }
}

struct DescribeLocationS3OutputResponseBody: Equatable {
    public let locationArn: String?
    public let locationUri: String?
    public let s3StorageClass: S3StorageClass?
    public let s3Config: S3Config?
    public let agentArns: [String]?
    public let creationTime: Date?
}

extension DescribeLocationS3OutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentArns = "AgentArns"
        case creationTime = "CreationTime"
        case locationArn = "LocationArn"
        case locationUri = "LocationUri"
        case s3Config = "S3Config"
        case s3StorageClass = "S3StorageClass"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationArn)
        locationArn = locationArnDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let s3StorageClassDecoded = try containerValues.decodeIfPresent(S3StorageClass.self, forKey: .s3StorageClass)
        s3StorageClass = s3StorageClassDecoded
        let s3ConfigDecoded = try containerValues.decodeIfPresent(S3Config.self, forKey: .s3Config)
        s3Config = s3ConfigDecoded
        let agentArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .agentArns)
        var agentArnsDecoded0:[String]? = nil
        if let agentArnsContainer = agentArnsContainer {
            agentArnsDecoded0 = [String]()
            for string0 in agentArnsContainer {
                if let string0 = string0 {
                    agentArnsDecoded0?.append(string0)
                }
            }
        }
        agentArns = agentArnsDecoded0
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

public struct DescribeLocationSmbInputBodyMiddleware: Middleware {
    public let id: String = "DescribeLocationSmbInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLocationSmbInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLocationSmbOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLocationSmbInput>
    public typealias MOutput = OperationOutput<DescribeLocationSmbOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLocationSmbOutputError>
}

extension DescribeLocationSmbInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLocationSmbInput(locationArn: \(String(describing: locationArn)))"}
}

extension DescribeLocationSmbInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case locationArn = "LocationArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locationArn = locationArn {
            try encodeContainer.encode(locationArn, forKey: .locationArn)
        }
    }
}

public struct DescribeLocationSmbInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLocationSmbInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLocationSmbInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLocationSmbOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLocationSmbInput>
    public typealias MOutput = OperationOutput<DescribeLocationSmbOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLocationSmbOutputError>
}

public struct DescribeLocationSmbInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLocationSmbInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLocationSmbInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLocationSmbOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLocationSmbInput>
    public typealias MOutput = OperationOutput<DescribeLocationSmbOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLocationSmbOutputError>
}

/// <p>DescribeLocationSmbRequest</p>
public struct DescribeLocationSmbInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the SMB location to describe.</p>
    public let locationArn: String?

    public init (
        locationArn: String? = nil
    )
    {
        self.locationArn = locationArn
    }
}

struct DescribeLocationSmbInputBody: Equatable {
    public let locationArn: String?
}

extension DescribeLocationSmbInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case locationArn = "LocationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationArn)
        locationArn = locationArnDecoded
    }
}

extension DescribeLocationSmbOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLocationSmbOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLocationSmbOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLocationSmbOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLocationSmbOutputResponse(agentArns: \(String(describing: agentArns)), creationTime: \(String(describing: creationTime)), domain: \(String(describing: domain)), locationArn: \(String(describing: locationArn)), locationUri: \(String(describing: locationUri)), mountOptions: \(String(describing: mountOptions)), user: \(String(describing: user)))"}
}

extension DescribeLocationSmbOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeLocationSmbOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.agentArns = output.agentArns
            self.creationTime = output.creationTime
            self.domain = output.domain
            self.locationArn = output.locationArn
            self.locationUri = output.locationUri
            self.mountOptions = output.mountOptions
            self.user = output.user
        } else {
            self.agentArns = nil
            self.creationTime = nil
            self.domain = nil
            self.locationArn = nil
            self.locationUri = nil
            self.mountOptions = nil
            self.user = nil
        }
    }
}

/// <p>DescribeLocationSmbResponse</p>
public struct DescribeLocationSmbOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the source SMB file system location that is
    ///       created.</p>
    public let agentArns: [String]?
    /// <p>The time that the SMB location was created.</p>
    public let creationTime: Date?
    /// <p>The name of the Windows domain that the SMB server belongs to.</p>
    public let domain: String?
    /// <p>The Amazon Resource Name (ARN) of the SMB location that was described.</p>
    public let locationArn: String?
    /// <p>The URL of the source SMB location that was described.</p>
    public let locationUri: String?
    /// <p>The mount options that are available for DataSync to use to access an SMB location.</p>
    public let mountOptions: SmbMountOptions?
    /// <p>The user who can mount the share, has the permissions to access files and folders in the
    ///       SMB share.</p>
    public let user: String?

    public init (
        agentArns: [String]? = nil,
        creationTime: Date? = nil,
        domain: String? = nil,
        locationArn: String? = nil,
        locationUri: String? = nil,
        mountOptions: SmbMountOptions? = nil,
        user: String? = nil
    )
    {
        self.agentArns = agentArns
        self.creationTime = creationTime
        self.domain = domain
        self.locationArn = locationArn
        self.locationUri = locationUri
        self.mountOptions = mountOptions
        self.user = user
    }
}

struct DescribeLocationSmbOutputResponseBody: Equatable {
    public let locationArn: String?
    public let locationUri: String?
    public let agentArns: [String]?
    public let user: String?
    public let domain: String?
    public let mountOptions: SmbMountOptions?
    public let creationTime: Date?
}

extension DescribeLocationSmbOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentArns = "AgentArns"
        case creationTime = "CreationTime"
        case domain = "Domain"
        case locationArn = "LocationArn"
        case locationUri = "LocationUri"
        case mountOptions = "MountOptions"
        case user = "User"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationArn)
        locationArn = locationArnDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let agentArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .agentArns)
        var agentArnsDecoded0:[String]? = nil
        if let agentArnsContainer = agentArnsContainer {
            agentArnsDecoded0 = [String]()
            for string0 in agentArnsContainer {
                if let string0 = string0 {
                    agentArnsDecoded0?.append(string0)
                }
            }
        }
        agentArns = agentArnsDecoded0
        let userDecoded = try containerValues.decodeIfPresent(String.self, forKey: .user)
        user = userDecoded
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
        let mountOptionsDecoded = try containerValues.decodeIfPresent(SmbMountOptions.self, forKey: .mountOptions)
        mountOptions = mountOptionsDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

public struct DescribeTaskExecutionInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTaskExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTaskExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTaskExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTaskExecutionInput>
    public typealias MOutput = OperationOutput<DescribeTaskExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTaskExecutionOutputError>
}

extension DescribeTaskExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTaskExecutionInput(taskExecutionArn: \(String(describing: taskExecutionArn)))"}
}

extension DescribeTaskExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case taskExecutionArn = "TaskExecutionArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let taskExecutionArn = taskExecutionArn {
            try encodeContainer.encode(taskExecutionArn, forKey: .taskExecutionArn)
        }
    }
}

public struct DescribeTaskExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTaskExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTaskExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTaskExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTaskExecutionInput>
    public typealias MOutput = OperationOutput<DescribeTaskExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTaskExecutionOutputError>
}

public struct DescribeTaskExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTaskExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTaskExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTaskExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTaskExecutionInput>
    public typealias MOutput = OperationOutput<DescribeTaskExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTaskExecutionOutputError>
}

/// <p>DescribeTaskExecutionRequest</p>
public struct DescribeTaskExecutionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the task that is being executed.</p>
    public let taskExecutionArn: String?

    public init (
        taskExecutionArn: String? = nil
    )
    {
        self.taskExecutionArn = taskExecutionArn
    }
}

struct DescribeTaskExecutionInputBody: Equatable {
    public let taskExecutionArn: String?
}

extension DescribeTaskExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case taskExecutionArn = "TaskExecutionArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskExecutionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskExecutionArn)
        taskExecutionArn = taskExecutionArnDecoded
    }
}

extension DescribeTaskExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTaskExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTaskExecutionOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTaskExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTaskExecutionOutputResponse(bytesTransferred: \(String(describing: bytesTransferred)), bytesWritten: \(String(describing: bytesWritten)), estimatedBytesToTransfer: \(String(describing: estimatedBytesToTransfer)), estimatedFilesToTransfer: \(String(describing: estimatedFilesToTransfer)), excludes: \(String(describing: excludes)), filesTransferred: \(String(describing: filesTransferred)), includes: \(String(describing: includes)), options: \(String(describing: options)), result: \(String(describing: result)), startTime: \(String(describing: startTime)), status: \(String(describing: status)), taskExecutionArn: \(String(describing: taskExecutionArn)))"}
}

extension DescribeTaskExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTaskExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bytesTransferred = output.bytesTransferred
            self.bytesWritten = output.bytesWritten
            self.estimatedBytesToTransfer = output.estimatedBytesToTransfer
            self.estimatedFilesToTransfer = output.estimatedFilesToTransfer
            self.excludes = output.excludes
            self.filesTransferred = output.filesTransferred
            self.includes = output.includes
            self.options = output.options
            self.result = output.result
            self.startTime = output.startTime
            self.status = output.status
            self.taskExecutionArn = output.taskExecutionArn
        } else {
            self.bytesTransferred = 0
            self.bytesWritten = 0
            self.estimatedBytesToTransfer = 0
            self.estimatedFilesToTransfer = 0
            self.excludes = nil
            self.filesTransferred = 0
            self.includes = nil
            self.options = nil
            self.result = nil
            self.startTime = nil
            self.status = nil
            self.taskExecutionArn = nil
        }
    }
}

/// <p>DescribeTaskExecutionResponse</p>
public struct DescribeTaskExecutionOutputResponse: Equatable {
    /// <p>The physical number of bytes transferred over the network.</p>
    public let bytesTransferred: Int
    /// <p>The number of logical bytes written to the destination AWS storage resource.</p>
    public let bytesWritten: Int
    /// <p>The estimated physical number of bytes that is to be transferred over the
    ///       network.</p>
    public let estimatedBytesToTransfer: Int
    /// <p>The expected number of files that is to be transferred over the network. This value is
    ///       calculated during the PREPARING phase, before the TRANSFERRING phase. This value is the
    ///       expected number of files to be transferred. It's calculated based on comparing the
    ///       content of the source and destination locations and finding the delta that needs to be
    ///       transferred. </p>
    public let estimatedFilesToTransfer: Int
    /// <p>A list of filter rules that determines which files to exclude from a task. The list should
    ///       contain a single filter string that consists of the patterns to exclude. The patterns are
    ///       delimited by "|" (that is, a pipe), for example: <code>"/folder1|/folder2"</code>
    ///          </p>
    ///          <p>
    ///     </p>
    public let excludes: [FilterRule]?
    /// <p>The actual number of files that was transferred over the network. This value is
    ///       calculated and updated on an ongoing basis during the TRANSFERRING phase. It's updated
    ///       periodically when each file is read from the source and sent over the network. </p>
    ///          <p>If failures occur during a transfer, this value can be less than
    ///         <code>EstimatedFilesToTransfer</code>. This value can also be greater than
    ///         <code>EstimatedFilesTransferred</code> in some cases. This element is
    ///       implementation-specific for some location types, so don't use it as an indicator for a correct
    ///       file number or to monitor your task execution.</p>
    public let filesTransferred: Int
    /// <p>A list of filter rules that determines which files to include when running a task. The
    ///       list should contain a single filter string that consists of the patterns to include. The
    ///       patterns are delimited by "|" (that is, a pipe), for example: <code>"/folder1|/folder2"</code>
    ///          </p>
    ///          <p>
    ///     </p>
    public let includes: [FilterRule]?
    /// <p>Represents the options that are available to control the behavior of a
    ///       <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>
    ///       operation. Behavior includes preserving metadata such as user
    ///       ID (UID), group ID (GID), and file permissions, and also overwriting files in the destination,
    ///       data integrity verification, and so on.</p>
    ///          <p>A task has a set of default options associated with it. If you don't specify an option
    ///       in <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>,
    ///       the default value is used. You can override the
    ///       defaults options on each task execution by specifying an overriding <code>Options</code> value
    ///       to <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>.</p>
    public let options: Options?
    /// <p>The result of the task execution.</p>
    public let result: TaskExecutionResultDetail?
    /// <p>The time that the task execution was started.</p>
    public let startTime: Date?
    /// <p>The status of the task execution. </p>
    ///
    ///
    ///          <p>For detailed information about task execution statuses, see Understanding
    ///       Task Statuses in the <i>AWS DataSync User Guide.</i>
    ///          </p>
    public let status: TaskExecutionStatus?
    /// <p>The Amazon Resource Name (ARN) of the task execution that was described.
    ///         <code>TaskExecutionArn</code> is hierarchical and includes <code>TaskArn</code> for the task
    ///       that was executed. </p>
    ///          <p>For example, a <code>TaskExecution</code> value with the ARN
    ///         <code>arn:aws:datasync:us-east-1:111222333444:task/task-0208075f79cedf4a2/execution/exec-08ef1e88ec491019b</code>
    ///       executed the task with the ARN
    ///         <code>arn:aws:datasync:us-east-1:111222333444:task/task-0208075f79cedf4a2</code>. </p>
    public let taskExecutionArn: String?

    public init (
        bytesTransferred: Int = 0,
        bytesWritten: Int = 0,
        estimatedBytesToTransfer: Int = 0,
        estimatedFilesToTransfer: Int = 0,
        excludes: [FilterRule]? = nil,
        filesTransferred: Int = 0,
        includes: [FilterRule]? = nil,
        options: Options? = nil,
        result: TaskExecutionResultDetail? = nil,
        startTime: Date? = nil,
        status: TaskExecutionStatus? = nil,
        taskExecutionArn: String? = nil
    )
    {
        self.bytesTransferred = bytesTransferred
        self.bytesWritten = bytesWritten
        self.estimatedBytesToTransfer = estimatedBytesToTransfer
        self.estimatedFilesToTransfer = estimatedFilesToTransfer
        self.excludes = excludes
        self.filesTransferred = filesTransferred
        self.includes = includes
        self.options = options
        self.result = result
        self.startTime = startTime
        self.status = status
        self.taskExecutionArn = taskExecutionArn
    }
}

struct DescribeTaskExecutionOutputResponseBody: Equatable {
    public let taskExecutionArn: String?
    public let status: TaskExecutionStatus?
    public let options: Options?
    public let excludes: [FilterRule]?
    public let includes: [FilterRule]?
    public let startTime: Date?
    public let estimatedFilesToTransfer: Int
    public let estimatedBytesToTransfer: Int
    public let filesTransferred: Int
    public let bytesWritten: Int
    public let bytesTransferred: Int
    public let result: TaskExecutionResultDetail?
}

extension DescribeTaskExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bytesTransferred = "BytesTransferred"
        case bytesWritten = "BytesWritten"
        case estimatedBytesToTransfer = "EstimatedBytesToTransfer"
        case estimatedFilesToTransfer = "EstimatedFilesToTransfer"
        case excludes = "Excludes"
        case filesTransferred = "FilesTransferred"
        case includes = "Includes"
        case options = "Options"
        case result = "Result"
        case startTime = "StartTime"
        case status = "Status"
        case taskExecutionArn = "TaskExecutionArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskExecutionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskExecutionArn)
        taskExecutionArn = taskExecutionArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TaskExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let optionsDecoded = try containerValues.decodeIfPresent(Options.self, forKey: .options)
        options = optionsDecoded
        let excludesContainer = try containerValues.decodeIfPresent([FilterRule?].self, forKey: .excludes)
        var excludesDecoded0:[FilterRule]? = nil
        if let excludesContainer = excludesContainer {
            excludesDecoded0 = [FilterRule]()
            for structure0 in excludesContainer {
                if let structure0 = structure0 {
                    excludesDecoded0?.append(structure0)
                }
            }
        }
        excludes = excludesDecoded0
        let includesContainer = try containerValues.decodeIfPresent([FilterRule?].self, forKey: .includes)
        var includesDecoded0:[FilterRule]? = nil
        if let includesContainer = includesContainer {
            includesDecoded0 = [FilterRule]()
            for structure0 in includesContainer {
                if let structure0 = structure0 {
                    includesDecoded0?.append(structure0)
                }
            }
        }
        includes = includesDecoded0
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let estimatedFilesToTransferDecoded = try containerValues.decode(Int.self, forKey: .estimatedFilesToTransfer)
        estimatedFilesToTransfer = estimatedFilesToTransferDecoded
        let estimatedBytesToTransferDecoded = try containerValues.decode(Int.self, forKey: .estimatedBytesToTransfer)
        estimatedBytesToTransfer = estimatedBytesToTransferDecoded
        let filesTransferredDecoded = try containerValues.decode(Int.self, forKey: .filesTransferred)
        filesTransferred = filesTransferredDecoded
        let bytesWrittenDecoded = try containerValues.decode(Int.self, forKey: .bytesWritten)
        bytesWritten = bytesWrittenDecoded
        let bytesTransferredDecoded = try containerValues.decode(Int.self, forKey: .bytesTransferred)
        bytesTransferred = bytesTransferredDecoded
        let resultDecoded = try containerValues.decodeIfPresent(TaskExecutionResultDetail.self, forKey: .result)
        result = resultDecoded
    }
}

public struct DescribeTaskInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTaskInput>
    public typealias MOutput = OperationOutput<DescribeTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTaskOutputError>
}

extension DescribeTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTaskInput(taskArn: \(String(describing: taskArn)))"}
}

extension DescribeTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case taskArn = "TaskArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let taskArn = taskArn {
            try encodeContainer.encode(taskArn, forKey: .taskArn)
        }
    }
}

public struct DescribeTaskInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTaskInput>
    public typealias MOutput = OperationOutput<DescribeTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTaskOutputError>
}

public struct DescribeTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTaskInput>
    public typealias MOutput = OperationOutput<DescribeTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTaskOutputError>
}

/// <p>DescribeTaskRequest</p>
public struct DescribeTaskInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the task to describe.</p>
    public let taskArn: String?

    public init (
        taskArn: String? = nil
    )
    {
        self.taskArn = taskArn
    }
}

struct DescribeTaskInputBody: Equatable {
    public let taskArn: String?
}

extension DescribeTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case taskArn = "TaskArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
    }
}

extension DescribeTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTaskOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTaskOutputResponse(cloudWatchLogGroupArn: \(String(describing: cloudWatchLogGroupArn)), creationTime: \(String(describing: creationTime)), currentTaskExecutionArn: \(String(describing: currentTaskExecutionArn)), destinationLocationArn: \(String(describing: destinationLocationArn)), destinationNetworkInterfaceArns: \(String(describing: destinationNetworkInterfaceArns)), errorCode: \(String(describing: errorCode)), errorDetail: \(String(describing: errorDetail)), excludes: \(String(describing: excludes)), name: \(String(describing: name)), options: \(String(describing: options)), schedule: \(String(describing: schedule)), sourceLocationArn: \(String(describing: sourceLocationArn)), sourceNetworkInterfaceArns: \(String(describing: sourceNetworkInterfaceArns)), status: \(String(describing: status)), taskArn: \(String(describing: taskArn)))"}
}

extension DescribeTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cloudWatchLogGroupArn = output.cloudWatchLogGroupArn
            self.creationTime = output.creationTime
            self.currentTaskExecutionArn = output.currentTaskExecutionArn
            self.destinationLocationArn = output.destinationLocationArn
            self.destinationNetworkInterfaceArns = output.destinationNetworkInterfaceArns
            self.errorCode = output.errorCode
            self.errorDetail = output.errorDetail
            self.excludes = output.excludes
            self.name = output.name
            self.options = output.options
            self.schedule = output.schedule
            self.sourceLocationArn = output.sourceLocationArn
            self.sourceNetworkInterfaceArns = output.sourceNetworkInterfaceArns
            self.status = output.status
            self.taskArn = output.taskArn
        } else {
            self.cloudWatchLogGroupArn = nil
            self.creationTime = nil
            self.currentTaskExecutionArn = nil
            self.destinationLocationArn = nil
            self.destinationNetworkInterfaceArns = nil
            self.errorCode = nil
            self.errorDetail = nil
            self.excludes = nil
            self.name = nil
            self.options = nil
            self.schedule = nil
            self.sourceLocationArn = nil
            self.sourceNetworkInterfaceArns = nil
            self.status = nil
            self.taskArn = nil
        }
    }
}

/// <p>DescribeTaskResponse</p>
public struct DescribeTaskOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Amazon CloudWatch log group that was used to
    ///       monitor and log events in the task.</p>
    ///
    ///
    ///          <p>For more information on these groups, see Working with Log Groups and Log
    ///       Streams in the <i>Amazon CloudWatch User Guide</i>.</p>
    public let cloudWatchLogGroupArn: String?
    /// <p>The time that the task was created.</p>
    public let creationTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the task execution that is syncing files.</p>
    public let currentTaskExecutionArn: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS storage resource's location.</p>
    public let destinationLocationArn: String?
    /// <p>The Amazon Resource Name (ARN) of the destination ENIs (Elastic Network Interface) that
    ///       was created for your subnet.</p>
    public let destinationNetworkInterfaceArns: [String]?
    /// <p>Errors that AWS DataSync encountered during execution of the task. You can use this
    ///       error code to help troubleshoot issues.</p>
    public let errorCode: String?
    /// <p>Detailed description of an error that was encountered during the task execution. You
    ///       can use this information to help troubleshoot issues. </p>
    public let errorDetail: String?
    /// <p>A list of filter rules that determines which files to exclude from a task. The list should
    ///       contain a single filter string that consists of the patterns to exclude. The patterns are
    ///       delimited by "|" (that is, a pipe), for example: <code>"/folder1|/folder2"</code>
    ///          </p>
    ///          <p>
    ///     </p>
    public let excludes: [FilterRule]?
    /// <p>The name of the task that was described.</p>
    public let name: String?
    /// <p>The set of configuration options that control the behavior of a single execution of the
    ///       task that occurs when you call <code>StartTaskExecution</code>. You can configure these
    ///       options to preserve metadata such as user ID (UID) and group (GID), file permissions, data
    ///       integrity verification, and so on.</p>
    ///          <p>For each individual task execution, you can override these options by specifying the
    ///       overriding <code>OverrideOptions</code> value to <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a> operation. </p>
    public let options: Options?
    /// <p>The schedule used to periodically transfer files from a source to a destination location.</p>
    public let schedule: TaskSchedule?
    /// <p>The Amazon Resource Name (ARN) of the source file system's location.</p>
    public let sourceLocationArn: String?
    /// <p>The Amazon Resource Name (ARN) of the source ENIs (Elastic Network Interface) that was
    ///       created for your subnet.</p>
    public let sourceNetworkInterfaceArns: [String]?
    /// <p>The status of the task that was described.</p>
    ///
    ///
    ///          <p>For detailed information about task execution statuses, see Understanding
    ///       Task Statuses in the <i>AWS DataSync User Guide</i>.</p>
    public let status: TaskStatus?
    /// <p>The Amazon Resource Name (ARN) of the task that was described.</p>
    public let taskArn: String?

    public init (
        cloudWatchLogGroupArn: String? = nil,
        creationTime: Date? = nil,
        currentTaskExecutionArn: String? = nil,
        destinationLocationArn: String? = nil,
        destinationNetworkInterfaceArns: [String]? = nil,
        errorCode: String? = nil,
        errorDetail: String? = nil,
        excludes: [FilterRule]? = nil,
        name: String? = nil,
        options: Options? = nil,
        schedule: TaskSchedule? = nil,
        sourceLocationArn: String? = nil,
        sourceNetworkInterfaceArns: [String]? = nil,
        status: TaskStatus? = nil,
        taskArn: String? = nil
    )
    {
        self.cloudWatchLogGroupArn = cloudWatchLogGroupArn
        self.creationTime = creationTime
        self.currentTaskExecutionArn = currentTaskExecutionArn
        self.destinationLocationArn = destinationLocationArn
        self.destinationNetworkInterfaceArns = destinationNetworkInterfaceArns
        self.errorCode = errorCode
        self.errorDetail = errorDetail
        self.excludes = excludes
        self.name = name
        self.options = options
        self.schedule = schedule
        self.sourceLocationArn = sourceLocationArn
        self.sourceNetworkInterfaceArns = sourceNetworkInterfaceArns
        self.status = status
        self.taskArn = taskArn
    }
}

struct DescribeTaskOutputResponseBody: Equatable {
    public let taskArn: String?
    public let status: TaskStatus?
    public let name: String?
    public let currentTaskExecutionArn: String?
    public let sourceLocationArn: String?
    public let destinationLocationArn: String?
    public let cloudWatchLogGroupArn: String?
    public let sourceNetworkInterfaceArns: [String]?
    public let destinationNetworkInterfaceArns: [String]?
    public let options: Options?
    public let excludes: [FilterRule]?
    public let schedule: TaskSchedule?
    public let errorCode: String?
    public let errorDetail: String?
    public let creationTime: Date?
}

extension DescribeTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogGroupArn = "CloudWatchLogGroupArn"
        case creationTime = "CreationTime"
        case currentTaskExecutionArn = "CurrentTaskExecutionArn"
        case destinationLocationArn = "DestinationLocationArn"
        case destinationNetworkInterfaceArns = "DestinationNetworkInterfaceArns"
        case errorCode = "ErrorCode"
        case errorDetail = "ErrorDetail"
        case excludes = "Excludes"
        case name = "Name"
        case options = "Options"
        case schedule = "Schedule"
        case sourceLocationArn = "SourceLocationArn"
        case sourceNetworkInterfaceArns = "SourceNetworkInterfaceArns"
        case status = "Status"
        case taskArn = "TaskArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TaskStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let currentTaskExecutionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentTaskExecutionArn)
        currentTaskExecutionArn = currentTaskExecutionArnDecoded
        let sourceLocationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLocationArn)
        sourceLocationArn = sourceLocationArnDecoded
        let destinationLocationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationLocationArn)
        destinationLocationArn = destinationLocationArnDecoded
        let cloudWatchLogGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogGroupArn)
        cloudWatchLogGroupArn = cloudWatchLogGroupArnDecoded
        let sourceNetworkInterfaceArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .sourceNetworkInterfaceArns)
        var sourceNetworkInterfaceArnsDecoded0:[String]? = nil
        if let sourceNetworkInterfaceArnsContainer = sourceNetworkInterfaceArnsContainer {
            sourceNetworkInterfaceArnsDecoded0 = [String]()
            for string0 in sourceNetworkInterfaceArnsContainer {
                if let string0 = string0 {
                    sourceNetworkInterfaceArnsDecoded0?.append(string0)
                }
            }
        }
        sourceNetworkInterfaceArns = sourceNetworkInterfaceArnsDecoded0
        let destinationNetworkInterfaceArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .destinationNetworkInterfaceArns)
        var destinationNetworkInterfaceArnsDecoded0:[String]? = nil
        if let destinationNetworkInterfaceArnsContainer = destinationNetworkInterfaceArnsContainer {
            destinationNetworkInterfaceArnsDecoded0 = [String]()
            for string0 in destinationNetworkInterfaceArnsContainer {
                if let string0 = string0 {
                    destinationNetworkInterfaceArnsDecoded0?.append(string0)
                }
            }
        }
        destinationNetworkInterfaceArns = destinationNetworkInterfaceArnsDecoded0
        let optionsDecoded = try containerValues.decodeIfPresent(Options.self, forKey: .options)
        options = optionsDecoded
        let excludesContainer = try containerValues.decodeIfPresent([FilterRule?].self, forKey: .excludes)
        var excludesDecoded0:[FilterRule]? = nil
        if let excludesContainer = excludesContainer {
            excludesDecoded0 = [FilterRule]()
            for structure0 in excludesContainer {
                if let structure0 = structure0 {
                    excludesDecoded0?.append(structure0)
                }
            }
        }
        excludes = excludesDecoded0
        let scheduleDecoded = try containerValues.decodeIfPresent(TaskSchedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorDetailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorDetail)
        errorDetail = errorDetailDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension Ec2Config: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityGroupArns = "SecurityGroupArns"
        case subnetArn = "SubnetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupArns = securityGroupArns {
            var securityGroupArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupArns)
            for ec2securitygrouparnlist0 in securityGroupArns {
                try securityGroupArnsContainer.encode(ec2securitygrouparnlist0)
            }
        }
        if let subnetArn = subnetArn {
            try encodeContainer.encode(subnetArn, forKey: .subnetArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetArn)
        subnetArn = subnetArnDecoded
        let securityGroupArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupArns)
        var securityGroupArnsDecoded0:[String]? = nil
        if let securityGroupArnsContainer = securityGroupArnsContainer {
            securityGroupArnsDecoded0 = [String]()
            for string0 in securityGroupArnsContainer {
                if let string0 = string0 {
                    securityGroupArnsDecoded0?.append(string0)
                }
            }
        }
        securityGroupArns = securityGroupArnsDecoded0
    }
}

extension Ec2Config: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Ec2Config(securityGroupArns: \(String(describing: securityGroupArns)), subnetArn: \(String(describing: subnetArn)))"}
}

/// <p>The subnet and the security group that DataSync uses to access target EFS file system.
///       The subnet must have at least one mount target for that file system. The security group that
///       you provide needs to be able to communicate with the security group on the mount target in the
///       subnet specified. </p>
public struct Ec2Config: Equatable {
    /// <p>The Amazon Resource Names (ARNs) of the security groups that are configured for the
    ///       Amazon EC2 resource.</p>
    public let securityGroupArns: [String]?
    /// <p>The ARN of the subnet and the security group that DataSync uses to access the target
    ///       EFS file system.</p>
    public let subnetArn: String?

    public init (
        securityGroupArns: [String]? = nil,
        subnetArn: String? = nil
    )
    {
        self.securityGroupArns = securityGroupArns
        self.subnetArn = subnetArn
    }
}

public enum EndpointType {
    case fips
    case privateLink
    case `public`
    case sdkUnknown(String)
}

extension EndpointType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EndpointType] {
        return [
            .fips,
            .privateLink,
            .public,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fips: return "FIPS"
        case .privateLink: return "PRIVATE_LINK"
        case .public: return "PUBLIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EndpointType(rawValue: rawValue) ?? EndpointType.sdkUnknown(rawValue)
    }
}

extension FilterRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filterType = "FilterType"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterType = filterType {
            try encodeContainer.encode(filterType.rawValue, forKey: .filterType)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterTypeDecoded = try containerValues.decodeIfPresent(FilterType.self, forKey: .filterType)
        filterType = filterTypeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension FilterRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FilterRule(filterType: \(String(describing: filterType)), value: \(String(describing: value)))"}
}

/// <p>Specifies which files, folders, and objects to include or exclude when transferring files
///       from source to destination.</p>
public struct FilterRule: Equatable {
    /// <p>The type of filter rule to apply. AWS DataSync only supports the SIMPLE_PATTERN rule
    ///       type.</p>
    public let filterType: FilterType?
    /// <p>A single filter string that consists of the patterns to include or exclude. The patterns
    ///       are delimited by "|" (that is, a pipe), for example: <code>/folder1|/folder2</code>
    ///          </p>
    ///          <p>
    ///     </p>
    public let value: String?

    public init (
        filterType: FilterType? = nil,
        value: String? = nil
    )
    {
        self.filterType = filterType
        self.value = value
    }
}

public enum FilterType {
    case simplePattern
    case sdkUnknown(String)
}

extension FilterType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FilterType] {
        return [
            .simplePattern,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .simplePattern: return "SIMPLE_PATTERN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FilterType(rawValue: rawValue) ?? FilterType.sdkUnknown(rawValue)
    }
}

public enum Gid {
    case both
    case intValue
    case name
    case `none`
    case sdkUnknown(String)
}

extension Gid : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Gid] {
        return [
            .both,
            .intValue,
            .name,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .both: return "BOTH"
        case .intValue: return "INT_VALUE"
        case .name: return "NAME"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Gid(rawValue: rawValue) ?? Gid.sdkUnknown(rawValue)
    }
}

extension InternalException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalException(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension InternalException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when an error occurs in the AWS DataSync service.</p>
public struct InternalException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct InternalExceptionBody: Equatable {
    public let message: String?
    public let errorCode: String?
}

extension InternalExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the client submits a malformed request.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
    public let errorCode: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
    }
}

public struct ListAgentsInputBodyMiddleware: Middleware {
    public let id: String = "ListAgentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAgentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAgentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAgentsInput>
    public typealias MOutput = OperationOutput<ListAgentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAgentsOutputError>
}

extension ListAgentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAgentsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAgentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAgentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAgentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAgentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAgentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAgentsInput>
    public typealias MOutput = OperationOutput<ListAgentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAgentsOutputError>
}

public struct ListAgentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAgentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAgentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAgentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAgentsInput>
    public typealias MOutput = OperationOutput<ListAgentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAgentsOutputError>
}

/// <p>ListAgentsRequest</p>
public struct ListAgentsInput: Equatable {
    /// <p>The maximum number of agents to list.</p>
    public let maxResults: Int?
    /// <p>An opaque string that indicates the position at which to begin the next list of
    ///       agents.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAgentsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListAgentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAgentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAgentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAgentsOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAgentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAgentsOutputResponse(agents: \(String(describing: agents)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAgentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAgentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.agents = output.agents
            self.nextToken = output.nextToken
        } else {
            self.agents = nil
            self.nextToken = nil
        }
    }
}

/// <p>ListAgentsResponse</p>
public struct ListAgentsOutputResponse: Equatable {
    /// <p>A list of agents in your account.</p>
    public let agents: [AgentListEntry]?
    /// <p>An opaque string that indicates the position at which to begin returning the next list
    ///       of agents.</p>
    public let nextToken: String?

    public init (
        agents: [AgentListEntry]? = nil,
        nextToken: String? = nil
    )
    {
        self.agents = agents
        self.nextToken = nextToken
    }
}

struct ListAgentsOutputResponseBody: Equatable {
    public let agents: [AgentListEntry]?
    public let nextToken: String?
}

extension ListAgentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agents = "Agents"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentsContainer = try containerValues.decodeIfPresent([AgentListEntry?].self, forKey: .agents)
        var agentsDecoded0:[AgentListEntry]? = nil
        if let agentsContainer = agentsContainer {
            agentsDecoded0 = [AgentListEntry]()
            for structure0 in agentsContainer {
                if let structure0 = structure0 {
                    agentsDecoded0?.append(structure0)
                }
            }
        }
        agents = agentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListLocationsInputBodyMiddleware: Middleware {
    public let id: String = "ListLocationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLocationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLocationsInput>
    public typealias MOutput = OperationOutput<ListLocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLocationsOutputError>
}

extension ListLocationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLocationsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLocationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for locationfilters0 in filters {
                try filtersContainer.encode(locationfilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListLocationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListLocationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLocationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLocationsInput>
    public typealias MOutput = OperationOutput<ListLocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLocationsOutputError>
}

public struct ListLocationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLocationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLocationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLocationsInput>
    public typealias MOutput = OperationOutput<ListLocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLocationsOutputError>
}

/// <p>ListLocationsRequest</p>
public struct ListLocationsInput: Equatable {
    /// <p>You can use API filters to narrow down the list of resources returned by <code>ListLocations</code>.
    ///       For example, to retrieve all tasks on a specific source location, you can use <code>ListLocations</code>
    ///       with filter name <code>LocationType S3</code> and <code>Operator Equals</code>.</p>
    public let filters: [LocationFilter]?
    /// <p>The maximum number of locations to return.</p>
    public let maxResults: Int?
    /// <p>An opaque string that indicates the position at which to begin the next list of
    ///       locations.</p>
    public let nextToken: String?

    public init (
        filters: [LocationFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLocationsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
    public let filters: [LocationFilter]?
}

extension ListLocationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LocationFilter?].self, forKey: .filters)
        var filtersDecoded0:[LocationFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LocationFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListLocationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLocationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLocationsOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLocationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLocationsOutputResponse(locations: \(String(describing: locations)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLocationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLocationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.locations = output.locations
            self.nextToken = output.nextToken
        } else {
            self.locations = nil
            self.nextToken = nil
        }
    }
}

/// <p>ListLocationsResponse</p>
public struct ListLocationsOutputResponse: Equatable {
    /// <p>An array that contains a list of locations.</p>
    public let locations: [LocationListEntry]?
    /// <p>An opaque string that indicates the position at which to begin returning the next list
    ///       of locations.</p>
    public let nextToken: String?

    public init (
        locations: [LocationListEntry]? = nil,
        nextToken: String? = nil
    )
    {
        self.locations = locations
        self.nextToken = nextToken
    }
}

struct ListLocationsOutputResponseBody: Equatable {
    public let locations: [LocationListEntry]?
    public let nextToken: String?
}

extension ListLocationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case locations = "Locations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationsContainer = try containerValues.decodeIfPresent([LocationListEntry?].self, forKey: .locations)
        var locationsDecoded0:[LocationListEntry]? = nil
        if let locationsContainer = locationsContainer {
            locationsDecoded0 = [LocationListEntry]()
            for structure0 in locationsContainer {
                if let structure0 = structure0 {
                    locationsDecoded0?.append(structure0)
                }
            }
        }
        locations = locationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

/// <p>ListTagsForResourceRequest</p>
public struct ListTagsForResourceInput: Equatable {
    /// <p>The maximum number of locations to return.</p>
    public let maxResults: Int?
    /// <p>An opaque string that indicates the position at which to begin the next list of
    ///       locations.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the resource whose tags to list.</p>
    public let resourceArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

/// <p>ListTagsForResourceResponse</p>
public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>An opaque string that indicates the position at which to begin returning the next list
    ///       of resource tags.</p>
    public let nextToken: String?
    /// <p>Array of resource tags.</p>
    public let tags: [TagListEntry]?

    public init (
        nextToken: String? = nil,
        tags: [TagListEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [TagListEntry]?
    public let nextToken: String?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([TagListEntry?].self, forKey: .tags)
        var tagsDecoded0:[TagListEntry]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TagListEntry]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTaskExecutionsInputBodyMiddleware: Middleware {
    public let id: String = "ListTaskExecutionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTaskExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTaskExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTaskExecutionsInput>
    public typealias MOutput = OperationOutput<ListTaskExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTaskExecutionsOutputError>
}

extension ListTaskExecutionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTaskExecutionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), taskArn: \(String(describing: taskArn)))"}
}

extension ListTaskExecutionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case taskArn = "TaskArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let taskArn = taskArn {
            try encodeContainer.encode(taskArn, forKey: .taskArn)
        }
    }
}

public struct ListTaskExecutionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTaskExecutionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTaskExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTaskExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTaskExecutionsInput>
    public typealias MOutput = OperationOutput<ListTaskExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTaskExecutionsOutputError>
}

public struct ListTaskExecutionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTaskExecutionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTaskExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTaskExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTaskExecutionsInput>
    public typealias MOutput = OperationOutput<ListTaskExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTaskExecutionsOutputError>
}

/// <p>ListTaskExecutions</p>
public struct ListTaskExecutionsInput: Equatable {
    /// <p>The maximum number of executed tasks to list.</p>
    public let maxResults: Int?
    /// <p>An opaque string that indicates the position at which to begin the next list of the
    ///       executed tasks.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the task whose tasks you want to list.</p>
    public let taskArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        taskArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.taskArn = taskArn
    }
}

struct ListTaskExecutionsInputBody: Equatable {
    public let taskArn: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListTaskExecutionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case taskArn = "TaskArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTaskExecutionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTaskExecutionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTaskExecutionsOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTaskExecutionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTaskExecutionsOutputResponse(nextToken: \(String(describing: nextToken)), taskExecutions: \(String(describing: taskExecutions)))"}
}

extension ListTaskExecutionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTaskExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.taskExecutions = output.taskExecutions
        } else {
            self.nextToken = nil
            self.taskExecutions = nil
        }
    }
}

/// <p>ListTaskExecutionsResponse</p>
public struct ListTaskExecutionsOutputResponse: Equatable {
    /// <p>An opaque string that indicates the position at which to begin returning the next list
    ///       of executed tasks.</p>
    public let nextToken: String?
    /// <p>A list of executed tasks.</p>
    public let taskExecutions: [TaskExecutionListEntry]?

    public init (
        nextToken: String? = nil,
        taskExecutions: [TaskExecutionListEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.taskExecutions = taskExecutions
    }
}

struct ListTaskExecutionsOutputResponseBody: Equatable {
    public let taskExecutions: [TaskExecutionListEntry]?
    public let nextToken: String?
}

extension ListTaskExecutionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case taskExecutions = "TaskExecutions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskExecutionsContainer = try containerValues.decodeIfPresent([TaskExecutionListEntry?].self, forKey: .taskExecutions)
        var taskExecutionsDecoded0:[TaskExecutionListEntry]? = nil
        if let taskExecutionsContainer = taskExecutionsContainer {
            taskExecutionsDecoded0 = [TaskExecutionListEntry]()
            for structure0 in taskExecutionsContainer {
                if let structure0 = structure0 {
                    taskExecutionsDecoded0?.append(structure0)
                }
            }
        }
        taskExecutions = taskExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTasksInputBodyMiddleware: Middleware {
    public let id: String = "ListTasksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTasksInput>
    public typealias MOutput = OperationOutput<ListTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTasksOutputError>
}

extension ListTasksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTasksInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListTasksInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for taskfilters0 in filters {
                try filtersContainer.encode(taskfilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTasksInputHeadersMiddleware: Middleware {
    public let id: String = "ListTasksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTasksInput>
    public typealias MOutput = OperationOutput<ListTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTasksOutputError>
}

public struct ListTasksInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTasksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTasksInput>
    public typealias MOutput = OperationOutput<ListTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTasksOutputError>
}

/// <p>ListTasksRequest</p>
public struct ListTasksInput: Equatable {
    /// <p>You can use API filters to narrow down the list of resources returned by <code>ListTasks</code>.
    ///       For example, to retrieve all tasks on a specific source location, you can use <code>ListTasks</code>
    ///       with filter name <code>LocationId</code> and <code>Operator Equals</code> with the ARN for the
    ///       location.</p>
    public let filters: [TaskFilter]?
    /// <p>The maximum number of tasks to return.</p>
    public let maxResults: Int?
    /// <p>An opaque string that indicates the position at which to begin the next list of
    ///       tasks.</p>
    public let nextToken: String?

    public init (
        filters: [TaskFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTasksInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
    public let filters: [TaskFilter]?
}

extension ListTasksInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([TaskFilter?].self, forKey: .filters)
        var filtersDecoded0:[TaskFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [TaskFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListTasksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTasksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTasksOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTasksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTasksOutputResponse(nextToken: \(String(describing: nextToken)), tasks: \(String(describing: tasks)))"}
}

extension ListTasksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTasksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tasks = output.tasks
        } else {
            self.nextToken = nil
            self.tasks = nil
        }
    }
}

/// <p>ListTasksResponse</p>
public struct ListTasksOutputResponse: Equatable {
    /// <p>An opaque string that indicates the position at which to begin returning the next list
    ///       of tasks.</p>
    public let nextToken: String?
    /// <p>A list of all the tasks that are returned.</p>
    public let tasks: [TaskListEntry]?

    public init (
        nextToken: String? = nil,
        tasks: [TaskListEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

struct ListTasksOutputResponseBody: Equatable {
    public let tasks: [TaskListEntry]?
    public let nextToken: String?
}

extension ListTasksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tasks = "Tasks"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tasksContainer = try containerValues.decodeIfPresent([TaskListEntry?].self, forKey: .tasks)
        var tasksDecoded0:[TaskListEntry]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [TaskListEntry]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LocationFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case `operator` = "Operator"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LocationFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(Operator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension LocationFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LocationFilter(name: \(String(describing: name)), operator: \(String(describing: `operator`)), values: \(String(describing: values)))"}
}

/// <p>You can use API filters to narrow down the list of resources returned by <code>ListLocations</code>.
///       For example, to retrieve all your Amazon S3 locations, you can use <code>ListLocations</code> with
///       filter name <code>LocationType S3</code> and <code>Operator Equals</code>.</p>
public struct LocationFilter: Equatable {
    /// <p>The operator that is used to compare filter values (for example, <code>Equals</code> or
    ///       <code>Contains</code>). For more about API filtering operators, see
    ///       <a href="https://docs.aws.amazon.com/datasync/latest/userguide/query-resources.html">API filters for ListTasks and ListLocations</a>.</p>
    public let `operator`: Operator?
    /// <p>The name of the filter being used. Each API call supports a list of filters that are available
    ///       for it (for example, <code>LocationType</code> for <code>ListLocations</code>).</p>
    public let name: LocationFilterName?
    /// <p>The values that you want to filter for. For example, you might want to display only Amazon S3
    ///       locations.</p>
    public let values: [String]?

    public init (
        `operator`: Operator? = nil,
        name: LocationFilterName? = nil,
        values: [String]? = nil
    )
    {
        self.`operator` = `operator`
        self.name = name
        self.values = values
    }
}

public enum LocationFilterName {
    case creationtime
    case locationtype
    case locationuri
    case sdkUnknown(String)
}

extension LocationFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LocationFilterName] {
        return [
            .creationtime,
            .locationtype,
            .locationuri,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .creationtime: return "CreationTime"
        case .locationtype: return "LocationType"
        case .locationuri: return "LocationUri"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LocationFilterName(rawValue: rawValue) ?? LocationFilterName.sdkUnknown(rawValue)
    }
}

extension LocationListEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case locationArn = "LocationArn"
        case locationUri = "LocationUri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locationArn = locationArn {
            try encodeContainer.encode(locationArn, forKey: .locationArn)
        }
        if let locationUri = locationUri {
            try encodeContainer.encode(locationUri, forKey: .locationUri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationArn)
        locationArn = locationArnDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
    }
}

extension LocationListEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LocationListEntry(locationArn: \(String(describing: locationArn)), locationUri: \(String(describing: locationUri)))"}
}

/// <p>Represents a single entry in a list of locations. <code>LocationListEntry</code>
///       returns an array that contains a list of locations when the
///       <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_ListLocations.html">ListLocations</a>
///       operation is called.</p>
public struct LocationListEntry: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the location. For Network File System (NFS) or Amazon
    ///       EFS, the location is the export path. For Amazon S3, the location is the prefix path that you
    ///       want to mount and use as the root of the location.</p>
    public let locationArn: String?
    /// <p>Represents a list of URLs of a location. <code>LocationUri</code> returns an array that
    ///       contains a list of locations when the <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_ListLocations.html">ListLocations</a> operation is
    ///       called.</p>
    ///          <p>Format: <code>TYPE://GLOBAL_ID/SUBDIR</code>.</p>
    ///          <p>TYPE designates the type of location. Valid values: NFS | EFS | S3.</p>
    ///          <p>GLOBAL_ID is the globally unique identifier of the resource that backs the location. An
    ///       example for EFS is <code>us-east-2.fs-abcd1234</code>. An example for Amazon S3 is the bucket
    ///       name, such as <code>myBucket</code>. An example for NFS is a valid IPv4 address or a host name
    ///       compliant with Domain Name Service (DNS).</p>
    ///          <p>SUBDIR is a valid file system path, delimited by forward slashes as is the *nix
    ///       convention. For NFS and Amazon EFS, it's the export path to mount the location. For
    ///       Amazon S3, it's the prefix path that you mount to and treat as the root of the
    ///       location.</p>
    ///          <p></p>
    public let locationUri: String?

    public init (
        locationArn: String? = nil,
        locationUri: String? = nil
    )
    {
        self.locationArn = locationArn
        self.locationUri = locationUri
    }
}

public enum LogLevel {
    case basic
    case off
    case transfer
    case sdkUnknown(String)
}

extension LogLevel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LogLevel] {
        return [
            .basic,
            .off,
            .transfer,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .basic: return "BASIC"
        case .off: return "OFF"
        case .transfer: return "TRANSFER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LogLevel(rawValue: rawValue) ?? LogLevel.sdkUnknown(rawValue)
    }
}

public enum Mtime {
    case `none`
    case preserve
    case sdkUnknown(String)
}

extension Mtime : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Mtime] {
        return [
            .none,
            .preserve,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .none: return "NONE"
        case .preserve: return "PRESERVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Mtime(rawValue: rawValue) ?? Mtime.sdkUnknown(rawValue)
    }
}

extension NfsMountOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let version = version {
            try encodeContainer.encode(version.rawValue, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(NfsVersion.self, forKey: .version)
        version = versionDecoded
    }
}

extension NfsMountOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NfsMountOptions(version: \(String(describing: version)))"}
}

/// <p>Represents the mount options that are available for DataSync to access an NFS
///       location.</p>
public struct NfsMountOptions: Equatable {
    /// <p>The specific NFS version that you want DataSync to use to mount your NFS share. If the
    ///       server refuses to use the version specified, the sync will fail. If you don't specify a
    ///       version, DataSync defaults to <code>AUTOMATIC</code>. That is, DataSync automatically
    ///       selects a version based on negotiation with the NFS server.</p>
    ///
    ///          <p>You can specify the following NFS versions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>
    ///                      <a href="https://tools.ietf.org/html/rfc1813">NFSv3</a>
    ///                   </b> - stateless protocol version that allows for asynchronous
    ///           writes on the server.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>
    ///                      <a href="https://tools.ietf.org/html/rfc3530">NFSv4.0</a>
    ///                   </b> - stateful, firewall-friendly protocol version that supports
    ///           delegations and pseudo filesystems.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>
    ///                      <a href="https://tools.ietf.org/html/rfc5661">NFSv4.1</a>
    ///                   </b> - stateful protocol version that supports sessions,
    ///           directory delegations, and parallel data processing. Version 4.1 also includes all
    ///           features available in version 4.0.</p>
    ///             </li>
    ///          </ul>
    public let version: NfsVersion?

    public init (
        version: NfsVersion? = nil
    )
    {
        self.version = version
    }
}

public enum NfsVersion {
    case automatic
    case nfs3
    case nfs40
    case nfs41
    case sdkUnknown(String)
}

extension NfsVersion : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NfsVersion] {
        return [
            .automatic,
            .nfs3,
            .nfs40,
            .nfs41,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .automatic: return "AUTOMATIC"
        case .nfs3: return "NFS3"
        case .nfs40: return "NFS4_0"
        case .nfs41: return "NFS4_1"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NfsVersion(rawValue: rawValue) ?? NfsVersion.sdkUnknown(rawValue)
    }
}

public enum ObjectStorageServerProtocol {
    case http
    case https
    case sdkUnknown(String)
}

extension ObjectStorageServerProtocol : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ObjectStorageServerProtocol] {
        return [
            .http,
            .https,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .http: return "HTTP"
        case .https: return "HTTPS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ObjectStorageServerProtocol(rawValue: rawValue) ?? ObjectStorageServerProtocol.sdkUnknown(rawValue)
    }
}

extension OnPremConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentArns = "AgentArns"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentArns = agentArns {
            var agentArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentArns)
            for agentarnlist0 in agentArns {
                try agentArnsContainer.encode(agentarnlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .agentArns)
        var agentArnsDecoded0:[String]? = nil
        if let agentArnsContainer = agentArnsContainer {
            agentArnsDecoded0 = [String]()
            for string0 in agentArnsContainer {
                if let string0 = string0 {
                    agentArnsDecoded0?.append(string0)
                }
            }
        }
        agentArns = agentArnsDecoded0
    }
}

extension OnPremConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OnPremConfig(agentArns: \(String(describing: agentArns)))"}
}

/// <p>A list of Amazon Resource Names (ARNs) of agents to use for a Network File System (NFS)
///       location.</p>
public struct OnPremConfig: Equatable {
    /// <p>ARNs of the agents to use for an NFS location.</p>
    public let agentArns: [String]?

    public init (
        agentArns: [String]? = nil
    )
    {
        self.agentArns = agentArns
    }
}

public enum Operator {
    case beginsWith
    case contains
    case eq
    case ge
    case gt
    case `in`
    case le
    case lt
    case ne
    case notContains
    case sdkUnknown(String)
}

extension Operator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Operator] {
        return [
            .beginsWith,
            .contains,
            .eq,
            .ge,
            .gt,
            .in,
            .le,
            .lt,
            .ne,
            .notContains,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .beginsWith: return "BeginsWith"
        case .contains: return "Contains"
        case .eq: return "Equals"
        case .ge: return "GreaterThanOrEqual"
        case .gt: return "GreaterThan"
        case .in: return "In"
        case .le: return "LessThanOrEqual"
        case .lt: return "LessThan"
        case .ne: return "NotEquals"
        case .notContains: return "NotContains"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Operator(rawValue: rawValue) ?? Operator.sdkUnknown(rawValue)
    }
}

extension Options: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case atime = "Atime"
        case bytesPerSecond = "BytesPerSecond"
        case gid = "Gid"
        case logLevel = "LogLevel"
        case mtime = "Mtime"
        case overwriteMode = "OverwriteMode"
        case posixPermissions = "PosixPermissions"
        case preserveDeletedFiles = "PreserveDeletedFiles"
        case preserveDevices = "PreserveDevices"
        case securityDescriptorCopyFlags = "SecurityDescriptorCopyFlags"
        case taskQueueing = "TaskQueueing"
        case transferMode = "TransferMode"
        case uid = "Uid"
        case verifyMode = "VerifyMode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let atime = atime {
            try encodeContainer.encode(atime.rawValue, forKey: .atime)
        }
        if let bytesPerSecond = bytesPerSecond {
            try encodeContainer.encode(bytesPerSecond, forKey: .bytesPerSecond)
        }
        if let gid = gid {
            try encodeContainer.encode(gid.rawValue, forKey: .gid)
        }
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let mtime = mtime {
            try encodeContainer.encode(mtime.rawValue, forKey: .mtime)
        }
        if let overwriteMode = overwriteMode {
            try encodeContainer.encode(overwriteMode.rawValue, forKey: .overwriteMode)
        }
        if let posixPermissions = posixPermissions {
            try encodeContainer.encode(posixPermissions.rawValue, forKey: .posixPermissions)
        }
        if let preserveDeletedFiles = preserveDeletedFiles {
            try encodeContainer.encode(preserveDeletedFiles.rawValue, forKey: .preserveDeletedFiles)
        }
        if let preserveDevices = preserveDevices {
            try encodeContainer.encode(preserveDevices.rawValue, forKey: .preserveDevices)
        }
        if let securityDescriptorCopyFlags = securityDescriptorCopyFlags {
            try encodeContainer.encode(securityDescriptorCopyFlags.rawValue, forKey: .securityDescriptorCopyFlags)
        }
        if let taskQueueing = taskQueueing {
            try encodeContainer.encode(taskQueueing.rawValue, forKey: .taskQueueing)
        }
        if let transferMode = transferMode {
            try encodeContainer.encode(transferMode.rawValue, forKey: .transferMode)
        }
        if let uid = uid {
            try encodeContainer.encode(uid.rawValue, forKey: .uid)
        }
        if let verifyMode = verifyMode {
            try encodeContainer.encode(verifyMode.rawValue, forKey: .verifyMode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let verifyModeDecoded = try containerValues.decodeIfPresent(VerifyMode.self, forKey: .verifyMode)
        verifyMode = verifyModeDecoded
        let overwriteModeDecoded = try containerValues.decodeIfPresent(OverwriteMode.self, forKey: .overwriteMode)
        overwriteMode = overwriteModeDecoded
        let atimeDecoded = try containerValues.decodeIfPresent(Atime.self, forKey: .atime)
        atime = atimeDecoded
        let mtimeDecoded = try containerValues.decodeIfPresent(Mtime.self, forKey: .mtime)
        mtime = mtimeDecoded
        let uidDecoded = try containerValues.decodeIfPresent(Uid.self, forKey: .uid)
        uid = uidDecoded
        let gidDecoded = try containerValues.decodeIfPresent(Gid.self, forKey: .gid)
        gid = gidDecoded
        let preserveDeletedFilesDecoded = try containerValues.decodeIfPresent(PreserveDeletedFiles.self, forKey: .preserveDeletedFiles)
        preserveDeletedFiles = preserveDeletedFilesDecoded
        let preserveDevicesDecoded = try containerValues.decodeIfPresent(PreserveDevices.self, forKey: .preserveDevices)
        preserveDevices = preserveDevicesDecoded
        let posixPermissionsDecoded = try containerValues.decodeIfPresent(PosixPermissions.self, forKey: .posixPermissions)
        posixPermissions = posixPermissionsDecoded
        let bytesPerSecondDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .bytesPerSecond)
        bytesPerSecond = bytesPerSecondDecoded
        let taskQueueingDecoded = try containerValues.decodeIfPresent(TaskQueueing.self, forKey: .taskQueueing)
        taskQueueing = taskQueueingDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
        let transferModeDecoded = try containerValues.decodeIfPresent(TransferMode.self, forKey: .transferMode)
        transferMode = transferModeDecoded
        let securityDescriptorCopyFlagsDecoded = try containerValues.decodeIfPresent(SmbSecurityDescriptorCopyFlags.self, forKey: .securityDescriptorCopyFlags)
        securityDescriptorCopyFlags = securityDescriptorCopyFlagsDecoded
    }
}

extension Options: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Options(atime: \(String(describing: atime)), bytesPerSecond: \(String(describing: bytesPerSecond)), gid: \(String(describing: gid)), logLevel: \(String(describing: logLevel)), mtime: \(String(describing: mtime)), overwriteMode: \(String(describing: overwriteMode)), posixPermissions: \(String(describing: posixPermissions)), preserveDeletedFiles: \(String(describing: preserveDeletedFiles)), preserveDevices: \(String(describing: preserveDevices)), securityDescriptorCopyFlags: \(String(describing: securityDescriptorCopyFlags)), taskQueueing: \(String(describing: taskQueueing)), transferMode: \(String(describing: transferMode)), uid: \(String(describing: uid)), verifyMode: \(String(describing: verifyMode)))"}
}

/// <p>Represents the options that are available to control the behavior of a
///       <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>
///       operation. Behavior includes preserving metadata such as user
///       ID (UID), group ID (GID), and file permissions, and also overwriting files in the destination,
///       data integrity verification, and so on.</p>
///          <p>A task has a set of default options associated with it. If you don't specify an option
///       in <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>,
///       the default value is used. You can override the
///       defaults options on each task execution by specifying an overriding <code>Options</code> value
///       to <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>.</p>
public struct Options: Equatable {
    /// <p>A file metadata value that shows the last time a file was accessed (that is, when the
    ///       file was read or written to). If you set <code>Atime</code> to BEST_EFFORT, DataSync
    ///       attempts to preserve the original <code>Atime</code> attribute on all source files (that is,
    ///       the version before the PREPARING phase). However, <code>Atime</code>'s behavior is not
    ///       fully standard across platforms, so AWS DataSync can only do this on a best-effort basis. </p>
    ///          <p>Default value: BEST_EFFORT.</p>
    ///          <p>BEST_EFFORT: Attempt to preserve the per-file <code>Atime</code> value
    ///       (recommended).</p>
    ///          <p>NONE: Ignore <code>Atime</code>.</p>
    ///          <note>
    ///             <p>If <code>Atime</code> is set to BEST_EFFORT, <code>Mtime</code> must be set to PRESERVE. </p>
    ///             <p>If <code>Atime</code> is set to NONE, <code>Mtime</code> must also be NONE. </p>
    ///          </note>
    public let atime: Atime?
    /// <p>A value that limits the bandwidth used by AWS DataSync. For example, if you want
    ///       AWS DataSync to use a maximum of 1 MB, set this value to <code>1048576</code>
    ///         (<code>=1024*1024</code>).</p>
    public let bytesPerSecond: Int?
    /// <p>The POSIX group ID (GID) of the file's owners. This option should only be set for
    ///       NFS, EFS, and S3 locations. For more information about what metadata is copied by DataSync,
    ///       see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/special-files.html#metadata-copied">Metadata Copied by DataSync</a>. </p>
    ///          <p>Default value: INT_VALUE. This preserves the integer value of the ID.</p>
    ///          <p>INT_VALUE: Preserve the integer value of user ID (UID) and GID (recommended).</p>
    ///          <p>NONE: Ignore UID and GID. </p>
    public let gid: Gid?
    /// <p>A value that determines the type of logs that DataSync publishes to a log stream in the
    ///       Amazon CloudWatch log group that you provide. For more information about providing a log group
    ///       for DataSync, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_CreateTask.html#DataSync-CreateTask-request-CloudWatchLogGroupArn">CloudWatchLogGroupArn</a>. If set to <code>OFF</code>, no logs are published.
    ///         <code>BASIC</code> publishes logs on errors for individual files transferred, and
    ///         <code>TRANSFER</code> publishes logs for every file or object that is transferred and
    ///       integrity checked.</p>
    public let logLevel: LogLevel?
    /// <p>A value that indicates the last time that a file was modified (that is, a file was
    ///       written to) before the PREPARING phase. This option is required for cases when you need to run
    ///       the same task more than one time. </p>
    ///          <p>Default value: PRESERVE. </p>
    ///          <p>PRESERVE: Preserve original <code>Mtime</code> (recommended)</p>
    ///          <p> NONE: Ignore <code>Mtime</code>. </p>
    ///          <note>
    ///             <p>If <code>Mtime</code> is set to PRESERVE, <code>Atime</code> must be set to
    ///         BEST_EFFORT.</p>
    ///             <p>If <code>Mtime</code> is set to NONE, <code>Atime</code> must also be set to NONE.
    ///       </p>
    ///          </note>
    public let mtime: Mtime?
    /// <p>A value that determines whether files at the destination should be overwritten or
    ///       preserved when copying files. If set to <code>NEVER</code> a destination file will not be
    ///       replaced by a source file, even if the destination file differs from the source file. If you modify files in the destination and you sync the files, you can use this value to
    ///       protect against overwriting those changes. </p>
    ///          <p>Some storage classes have specific behaviors that can affect your S3 storage cost. For detailed information, see
    ///       <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-s3-location.html#using-storage-classes">Considerations when working with Amazon S3 storage classes in DataSync </a>
    ///       in the <i>AWS DataSync
    ///         User Guide</i>.</p>
    public let overwriteMode: OverwriteMode?
    /// <p>A value that determines which users or groups can access a file for a specific purpose
    ///       such as reading, writing, or execution of the file. This option should only be set for NFS,
    ///       EFS, and S3 locations. For more information about what metadata is copied by DataSync, see
    ///         <a href="https://docs.aws.amazon.com/datasync/latest/userguide/special-files.html#metadata-copied">Metadata Copied by DataSync</a>. </p>
    ///          <p>Default value: PRESERVE.</p>
    ///          <p>PRESERVE: Preserve POSIX-style permissions (recommended).</p>
    ///          <p>NONE: Ignore permissions. </p>
    ///          <note>
    ///             <p>AWS DataSync can preserve extant permissions of a source location.</p>
    ///          </note>
    public let posixPermissions: PosixPermissions?
    /// <p>A value that specifies whether files in the destination that don't exist in the source
    ///       file system should be preserved. This option can affect your storage cost.
    ///       If your task deletes objects, you might incur minimum storage duration charges for certain storage classes. For detailed
    ///       information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-s3-location.html#using-storage-classes">Considerations when working with Amazon S3 storage classes in DataSync </a> in the <i>AWS DataSync User
    ///         Guide</i>.</p>
    ///          <p>Default value: PRESERVE.</p>
    ///          <p>PRESERVE: Ignore such destination files (recommended). </p>
    ///          <p>REMOVE: Delete destination files that aren’t present in the source.</p>
    public let preserveDeletedFiles: PreserveDeletedFiles?
    /// <p>A value that determines whether AWS DataSync should preserve the metadata of block
    ///       and character devices in the source file system, and re-create the files with that device name
    ///       and metadata on the destination. DataSync does not copy the contents of such devices, only the
    ///       name and metadata. </p>
    ///          <note>
    ///             <p>AWS DataSync can't sync the actual contents of such devices, because they are
    ///         nonterminal and don't return an end-of-file (EOF) marker.</p>
    ///          </note>
    ///          <p>Default value: NONE.</p>
    ///          <p>NONE: Ignore special devices (recommended). </p>
    ///          <p>PRESERVE: Preserve character and block device metadata. This option isn't currently
    ///       supported for Amazon EFS. </p>
    public let preserveDevices: PreserveDevices?
    /// <p>A value that determines which components of the SMB security descriptor are copied from source
    ///       to destination objects.
    ///       </p>
    ///          <p>This value is only used for transfers
    ///       between SMB and Amazon FSx for Windows File Server locations, or between two Amazon FSx for Windows File
    ///       Server locations. For more information about how
    ///       DataSync handles metadata, see
    ///       <a href="https://docs.aws.amazon.com/datasync/latest/userguide/special-files.html">How DataSync Handles Metadata and Special Files</a>.
    ///     </p>
    ///          <p>Default value: OWNER_DACL.</p>
    ///
    ///          <p>
    ///             <b>OWNER_DACL</b>: For each copied object, DataSync copies the following metadata:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Object owner.</p>
    ///             </li>
    ///             <li>
    ///                <p>NTFS discretionary access control lists (DACLs), which determine whether to
    ///         grant access to an object.</p>
    ///             </li>
    ///          </ul>
    ///          <p>When choosing this option, DataSync does NOT copy the NTFS system access control lists
    ///       (SACLs), which are used by administrators to log attempts to access a secured object.</p>
    ///
    ///          <p>
    ///             <b>OWNER_DACL_SACL</b>: For each copied object, DataSync copies the following metadata:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Object owner.</p>
    ///             </li>
    ///             <li>
    ///                <p>NTFS discretionary access control lists (DACLs), which determine whether to
    ///           grant access to an object.</p>
    ///             </li>
    ///             <li>
    ///                <p>NTFS system access control lists (SACLs), which are used by administrators
    ///           to log attempts to access a secured object.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Copying SACLs requires granting additional permissions to the Windows user that DataSync
    ///       uses to access your SMB location. For information about choosing a user that ensures
    ///       sufficient permissions to files, folders, and metadata, see <a href="create-smb-location.html#SMBuser">user</a>.</p>
    ///
    ///          <p>
    ///             <b>NONE</b>: None of the SMB security descriptor components
    ///       are copied. Destination objects are owned by the user that was provided for accessing the
    ///       destination location. DACLs and SACLs are set based on the destination server’s configuration.
    ///     </p>
    public let securityDescriptorCopyFlags: SmbSecurityDescriptorCopyFlags?
    /// <p>A value that determines whether tasks should be queued before executing the tasks. If set
    ///       to <code>ENABLED</code>, the tasks will be queued. The default is <code>ENABLED</code>.</p>
    ///          <p>If you use the same agent to run multiple tasks, you can enable the tasks to run in
    ///       series. For more information, see
    ///       <a href="https://docs.aws.amazon.com/datasync/latest/userguide/run-task.html#queue-task-execution">Queueing task executions</a>.</p>
    public let taskQueueing: TaskQueueing?
    /// <p>A value that determines whether DataSync transfers only the data and metadata that differ between the source
    ///       and the destination location, or whether DataSync transfers all the content from the source, without comparing to
    ///       the destination location. </p>
    ///          <p>CHANGED: DataSync copies only data or metadata that is new or different content from the source location to the
    ///       destination location.</p>
    ///          <p>ALL: DataSync copies all source location content to the destination, without comparing to existing content on
    ///       the destination.</p>
    public let transferMode: TransferMode?
    /// <p>The POSIX user ID (UID) of the file's owner. This option should only be set for NFS,
    ///       EFS, and S3 locations. To learn more about what metadata is copied by DataSync, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/special-files.html#metadata-copied">Metadata Copied by DataSync</a>.</p>
    ///          <p>Default value: INT_VALUE. This preserves the integer value of the ID.</p>
    ///          <p>INT_VALUE: Preserve the integer value of UID and group ID (GID)
    ///       (recommended).</p>
    ///          <p>NONE: Ignore UID and GID. </p>
    public let uid: Uid?
    /// <p>A value that determines whether a data integrity verification should be performed at
    ///       the end of a task execution after all data and metadata have been transferred.
    ///       For more information, see
    ///       <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-task.html">Configure task settings</a>.
    ///     </p>
    ///          <p>Default value: POINT_IN_TIME_CONSISTENT.</p>
    ///          <p>ONLY_FILES_TRANSFERRED (recommended): Perform verification only on files that were transferred.
    ///     </p>
    ///
    ///          <p>POINT_IN_TIME_CONSISTENT: Scan the entire source and entire destination
    ///       at the end of the transfer
    ///       to verify that source and destination are fully
    ///       synchronized. This option isn't supported when transferring to S3 Glacier or S3 Glacier
    ///       Deep Archive storage classes.</p>
    ///          <p>NONE: No additional verification is done at the end of the
    ///       transfer, but all data transmissions are integrity-checked with
    ///       checksum verification during the transfer.</p>
    public let verifyMode: VerifyMode?

    public init (
        atime: Atime? = nil,
        bytesPerSecond: Int? = nil,
        gid: Gid? = nil,
        logLevel: LogLevel? = nil,
        mtime: Mtime? = nil,
        overwriteMode: OverwriteMode? = nil,
        posixPermissions: PosixPermissions? = nil,
        preserveDeletedFiles: PreserveDeletedFiles? = nil,
        preserveDevices: PreserveDevices? = nil,
        securityDescriptorCopyFlags: SmbSecurityDescriptorCopyFlags? = nil,
        taskQueueing: TaskQueueing? = nil,
        transferMode: TransferMode? = nil,
        uid: Uid? = nil,
        verifyMode: VerifyMode? = nil
    )
    {
        self.atime = atime
        self.bytesPerSecond = bytesPerSecond
        self.gid = gid
        self.logLevel = logLevel
        self.mtime = mtime
        self.overwriteMode = overwriteMode
        self.posixPermissions = posixPermissions
        self.preserveDeletedFiles = preserveDeletedFiles
        self.preserveDevices = preserveDevices
        self.securityDescriptorCopyFlags = securityDescriptorCopyFlags
        self.taskQueueing = taskQueueing
        self.transferMode = transferMode
        self.uid = uid
        self.verifyMode = verifyMode
    }
}

public enum OverwriteMode {
    case always
    case never
    case sdkUnknown(String)
}

extension OverwriteMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OverwriteMode] {
        return [
            .always,
            .never,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .always: return "ALWAYS"
        case .never: return "NEVER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OverwriteMode(rawValue: rawValue) ?? OverwriteMode.sdkUnknown(rawValue)
    }
}

public enum PhaseStatus {
    case error
    case pending
    case success
    case sdkUnknown(String)
}

extension PhaseStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PhaseStatus] {
        return [
            .error,
            .pending,
            .success,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .error: return "ERROR"
        case .pending: return "PENDING"
        case .success: return "SUCCESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PhaseStatus(rawValue: rawValue) ?? PhaseStatus.sdkUnknown(rawValue)
    }
}

public enum PosixPermissions {
    case `none`
    case preserve
    case sdkUnknown(String)
}

extension PosixPermissions : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PosixPermissions] {
        return [
            .none,
            .preserve,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .none: return "NONE"
        case .preserve: return "PRESERVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PosixPermissions(rawValue: rawValue) ?? PosixPermissions.sdkUnknown(rawValue)
    }
}

public enum PreserveDeletedFiles {
    case preserve
    case remove
    case sdkUnknown(String)
}

extension PreserveDeletedFiles : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PreserveDeletedFiles] {
        return [
            .preserve,
            .remove,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .preserve: return "PRESERVE"
        case .remove: return "REMOVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PreserveDeletedFiles(rawValue: rawValue) ?? PreserveDeletedFiles.sdkUnknown(rawValue)
    }
}

public enum PreserveDevices {
    case `none`
    case preserve
    case sdkUnknown(String)
}

extension PreserveDevices : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PreserveDevices] {
        return [
            .none,
            .preserve,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .none: return "NONE"
        case .preserve: return "PRESERVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PreserveDevices(rawValue: rawValue) ?? PreserveDevices.sdkUnknown(rawValue)
    }
}

extension PrivateLinkConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case privateLinkEndpoint = "PrivateLinkEndpoint"
        case securityGroupArns = "SecurityGroupArns"
        case subnetArns = "SubnetArns"
        case vpcEndpointId = "VpcEndpointId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let privateLinkEndpoint = privateLinkEndpoint {
            try encodeContainer.encode(privateLinkEndpoint, forKey: .privateLinkEndpoint)
        }
        if let securityGroupArns = securityGroupArns {
            var securityGroupArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupArns)
            for plsecuritygrouparnlist0 in securityGroupArns {
                try securityGroupArnsContainer.encode(plsecuritygrouparnlist0)
            }
        }
        if let subnetArns = subnetArns {
            var subnetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetArns)
            for plsubnetarnlist0 in subnetArns {
                try subnetArnsContainer.encode(plsubnetarnlist0)
            }
        }
        if let vpcEndpointId = vpcEndpointId {
            try encodeContainer.encode(vpcEndpointId, forKey: .vpcEndpointId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
        let privateLinkEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateLinkEndpoint)
        privateLinkEndpoint = privateLinkEndpointDecoded
        let subnetArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetArns)
        var subnetArnsDecoded0:[String]? = nil
        if let subnetArnsContainer = subnetArnsContainer {
            subnetArnsDecoded0 = [String]()
            for string0 in subnetArnsContainer {
                if let string0 = string0 {
                    subnetArnsDecoded0?.append(string0)
                }
            }
        }
        subnetArns = subnetArnsDecoded0
        let securityGroupArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupArns)
        var securityGroupArnsDecoded0:[String]? = nil
        if let securityGroupArnsContainer = securityGroupArnsContainer {
            securityGroupArnsDecoded0 = [String]()
            for string0 in securityGroupArnsContainer {
                if let string0 = string0 {
                    securityGroupArnsDecoded0?.append(string0)
                }
            }
        }
        securityGroupArns = securityGroupArnsDecoded0
    }
}

extension PrivateLinkConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PrivateLinkConfig(privateLinkEndpoint: \(String(describing: privateLinkEndpoint)), securityGroupArns: \(String(describing: securityGroupArns)), subnetArns: \(String(describing: subnetArns)), vpcEndpointId: \(String(describing: vpcEndpointId)))"}
}

/// <p>The VPC endpoint, subnet, and security group that an agent uses to access IP addresses in
///       a VPC (Virtual Private Cloud).</p>
public struct PrivateLinkConfig: Equatable {
    /// <p>The private endpoint that is configured for an agent that has access to IP addresses in a
    ///         <a href="https://docs.aws.amazon.com/vpc/latest/userguide/endpoint-service.html">PrivateLink</a>. An agent that is configured with this endpoint will not be accessible
    ///       over the public internet.</p>
    public let privateLinkEndpoint: String?
    /// <p>The Amazon Resource Names (ARNs) of the security groups that are configured for the EC2
    ///       resource that hosts an agent activated in a VPC or an agent that has access to a VPC
    ///       endpoint.</p>
    public let securityGroupArns: [String]?
    /// <p>The Amazon Resource Names (ARNs) of the subnets that are configured for an agent activated
    ///       in a VPC or an agent that has access to a VPC endpoint.</p>
    public let subnetArns: [String]?
    /// <p>The ID of the VPC endpoint that is configured for an agent. An agent that is configured
    ///       with a VPC endpoint will not be accessible over the public internet.</p>
    public let vpcEndpointId: String?

    public init (
        privateLinkEndpoint: String? = nil,
        securityGroupArns: [String]? = nil,
        subnetArns: [String]? = nil,
        vpcEndpointId: String? = nil
    )
    {
        self.privateLinkEndpoint = privateLinkEndpoint
        self.securityGroupArns = securityGroupArns
        self.subnetArns = subnetArns
        self.vpcEndpointId = vpcEndpointId
    }
}

extension S3Config: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketAccessRoleArn = "BucketAccessRoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketAccessRoleArn = bucketAccessRoleArn {
            try encodeContainer.encode(bucketAccessRoleArn, forKey: .bucketAccessRoleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketAccessRoleArn)
        bucketAccessRoleArn = bucketAccessRoleArnDecoded
    }
}

extension S3Config: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Config(bucketAccessRoleArn: \(String(describing: bucketAccessRoleArn)))"}
}

/// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role
///       that is used to access an Amazon S3 bucket.</p>
///
///          <p>For detailed information about using such a role, see Creating a Location for
///       Amazon S3 in the <i>AWS DataSync User Guide</i>.</p>
public struct S3Config: Equatable {
    /// <p>The Amazon S3 bucket to access. This bucket is used as a parameter in the
    ///       <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_CreateLocationS3.html">CreateLocationS3</a>
    ///       operation. </p>
    public let bucketAccessRoleArn: String?

    public init (
        bucketAccessRoleArn: String? = nil
    )
    {
        self.bucketAccessRoleArn = bucketAccessRoleArn
    }
}

public enum S3StorageClass {
    case deepArchive
    case glacier
    case intelligentTiering
    case onezoneIa
    case outposts
    case standard
    case standardIa
    case sdkUnknown(String)
}

extension S3StorageClass : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [S3StorageClass] {
        return [
            .deepArchive,
            .glacier,
            .intelligentTiering,
            .onezoneIa,
            .outposts,
            .standard,
            .standardIa,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deepArchive: return "DEEP_ARCHIVE"
        case .glacier: return "GLACIER"
        case .intelligentTiering: return "INTELLIGENT_TIERING"
        case .onezoneIa: return "ONEZONE_IA"
        case .outposts: return "OUTPOSTS"
        case .standard: return "STANDARD"
        case .standardIa: return "STANDARD_IA"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = S3StorageClass(rawValue: rawValue) ?? S3StorageClass.sdkUnknown(rawValue)
    }
}

extension SmbMountOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let version = version {
            try encodeContainer.encode(version.rawValue, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(SmbVersion.self, forKey: .version)
        version = versionDecoded
    }
}

extension SmbMountOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SmbMountOptions(version: \(String(describing: version)))"}
}

/// <p>Represents the mount options that are available for DataSync to access an SMB
///       location.</p>
public struct SmbMountOptions: Equatable {
    /// <p>The specific SMB version that you want DataSync to use to mount your SMB share. If you
    ///       don't specify a version, DataSync defaults to <code>AUTOMATIC</code>. That is, DataSync
    ///       automatically selects a version based on negotiation with the SMB server.</p>
    public let version: SmbVersion?

    public init (
        version: SmbVersion? = nil
    )
    {
        self.version = version
    }
}

public enum SmbSecurityDescriptorCopyFlags {
    case `none`
    case ownerDacl
    case ownerDaclSacl
    case sdkUnknown(String)
}

extension SmbSecurityDescriptorCopyFlags : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SmbSecurityDescriptorCopyFlags] {
        return [
            .none,
            .ownerDacl,
            .ownerDaclSacl,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .none: return "NONE"
        case .ownerDacl: return "OWNER_DACL"
        case .ownerDaclSacl: return "OWNER_DACL_SACL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SmbSecurityDescriptorCopyFlags(rawValue: rawValue) ?? SmbSecurityDescriptorCopyFlags.sdkUnknown(rawValue)
    }
}

public enum SmbVersion {
    case automatic
    case smb2
    case smb3
    case sdkUnknown(String)
}

extension SmbVersion : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SmbVersion] {
        return [
            .automatic,
            .smb2,
            .smb3,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .automatic: return "AUTOMATIC"
        case .smb2: return "SMB2"
        case .smb3: return "SMB3"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SmbVersion(rawValue: rawValue) ?? SmbVersion.sdkUnknown(rawValue)
    }
}

public struct StartTaskExecutionInputBodyMiddleware: Middleware {
    public let id: String = "StartTaskExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartTaskExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartTaskExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartTaskExecutionInput>
    public typealias MOutput = OperationOutput<StartTaskExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartTaskExecutionOutputError>
}

extension StartTaskExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartTaskExecutionInput(includes: \(String(describing: includes)), overrideOptions: \(String(describing: overrideOptions)), taskArn: \(String(describing: taskArn)))"}
}

extension StartTaskExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case includes = "Includes"
        case overrideOptions = "OverrideOptions"
        case taskArn = "TaskArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includes = includes {
            var includesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .includes)
            for filterlist0 in includes {
                try includesContainer.encode(filterlist0)
            }
        }
        if let overrideOptions = overrideOptions {
            try encodeContainer.encode(overrideOptions, forKey: .overrideOptions)
        }
        if let taskArn = taskArn {
            try encodeContainer.encode(taskArn, forKey: .taskArn)
        }
    }
}

public struct StartTaskExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "StartTaskExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartTaskExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartTaskExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartTaskExecutionInput>
    public typealias MOutput = OperationOutput<StartTaskExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartTaskExecutionOutputError>
}

public struct StartTaskExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "StartTaskExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartTaskExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartTaskExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartTaskExecutionInput>
    public typealias MOutput = OperationOutput<StartTaskExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartTaskExecutionOutputError>
}

/// <p>StartTaskExecutionRequest</p>
public struct StartTaskExecutionInput: Equatable {
    /// <p>A list of filter rules that determines which files to include when running a task. The
    ///       pattern should contain a single filter string that consists of the patterns to include. The
    ///       patterns are delimited by "|" (that is, a pipe). For example: <code>"/folder1|/folder2"</code>
    ///          </p>
    ///
    ///          <p>
    ///     </p>
    public let includes: [FilterRule]?
    /// <p>Represents the options that are available to control the behavior of a
    ///       <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>
    ///       operation. Behavior includes preserving metadata such as user
    ///       ID (UID), group ID (GID), and file permissions, and also overwriting files in the destination,
    ///       data integrity verification, and so on.</p>
    ///          <p>A task has a set of default options associated with it. If you don't specify an option
    ///       in <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>,
    ///       the default value is used. You can override the
    ///       defaults options on each task execution by specifying an overriding <code>Options</code> value
    ///       to <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>.</p>
    public let overrideOptions: Options?
    /// <p>The Amazon Resource Name (ARN) of the task to start.</p>
    public let taskArn: String?

    public init (
        includes: [FilterRule]? = nil,
        overrideOptions: Options? = nil,
        taskArn: String? = nil
    )
    {
        self.includes = includes
        self.overrideOptions = overrideOptions
        self.taskArn = taskArn
    }
}

struct StartTaskExecutionInputBody: Equatable {
    public let taskArn: String?
    public let overrideOptions: Options?
    public let includes: [FilterRule]?
}

extension StartTaskExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case includes = "Includes"
        case overrideOptions = "OverrideOptions"
        case taskArn = "TaskArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let overrideOptionsDecoded = try containerValues.decodeIfPresent(Options.self, forKey: .overrideOptions)
        overrideOptions = overrideOptionsDecoded
        let includesContainer = try containerValues.decodeIfPresent([FilterRule?].self, forKey: .includes)
        var includesDecoded0:[FilterRule]? = nil
        if let includesContainer = includesContainer {
            includesDecoded0 = [FilterRule]()
            for structure0 in includesContainer {
                if let structure0 = structure0 {
                    includesDecoded0?.append(structure0)
                }
            }
        }
        includes = includesDecoded0
    }
}

extension StartTaskExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartTaskExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartTaskExecutionOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartTaskExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartTaskExecutionOutputResponse(taskExecutionArn: \(String(describing: taskExecutionArn)))"}
}

extension StartTaskExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartTaskExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.taskExecutionArn = output.taskExecutionArn
        } else {
            self.taskExecutionArn = nil
        }
    }
}

/// <p>StartTaskExecutionResponse</p>
public struct StartTaskExecutionOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the specific task execution that was
    ///       started.</p>
    public let taskExecutionArn: String?

    public init (
        taskExecutionArn: String? = nil
    )
    {
        self.taskExecutionArn = taskExecutionArn
    }
}

struct StartTaskExecutionOutputResponseBody: Equatable {
    public let taskExecutionArn: String?
}

extension StartTaskExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case taskExecutionArn = "TaskExecutionArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskExecutionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskExecutionArn)
        taskExecutionArn = taskExecutionArnDecoded
    }
}

extension TagListEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension TagListEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagListEntry(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Represents a single entry in a list of AWS resource tags. <code>TagListEntry</code>
///       returns an array that contains a list of tasks when the
///       <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_ListTagsForResource.html">ListTagsForResource</a>
///       operation is called.</p>
public struct TagListEntry: Equatable {
    /// <p>The key for an AWS resource tag.</p>
    public let key: String?
    /// <p>The value for an AWS resource tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for inputtaglist0 in tags {
                try tagsContainer.encode(inputtaglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

/// <p>TagResourceRequest</p>
public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource to apply the tag to.</p>
    public let resourceArn: String?
    /// <p>The tags to apply.</p>
    public let tags: [TagListEntry]?

    public init (
        resourceArn: String? = nil,
        tags: [TagListEntry]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [TagListEntry]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TagListEntry?].self, forKey: .tags)
        var tagsDecoded0:[TagListEntry]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TagListEntry]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TaskExecutionListEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
        case taskExecutionArn = "TaskExecutionArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let taskExecutionArn = taskExecutionArn {
            try encodeContainer.encode(taskExecutionArn, forKey: .taskExecutionArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskExecutionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskExecutionArn)
        taskExecutionArn = taskExecutionArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TaskExecutionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension TaskExecutionListEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskExecutionListEntry(status: \(String(describing: status)), taskExecutionArn: \(String(describing: taskExecutionArn)))"}
}

/// <p>Represents a single entry in a list of task executions.
///         <code>TaskExecutionListEntry</code> returns an array that contains a list of specific
///       invocations of a task when the
///       <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_ListTaskExecutions.html">ListTaskExecutions</a>
///       operation is called.</p>
public struct TaskExecutionListEntry: Equatable {
    /// <p>The status of a task execution.</p>
    public let status: TaskExecutionStatus?
    /// <p>The Amazon Resource Name (ARN) of the task that was executed.</p>
    public let taskExecutionArn: String?

    public init (
        status: TaskExecutionStatus? = nil,
        taskExecutionArn: String? = nil
    )
    {
        self.status = status
        self.taskExecutionArn = taskExecutionArn
    }
}

extension TaskExecutionResultDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorDetail = "ErrorDetail"
        case prepareDuration = "PrepareDuration"
        case prepareStatus = "PrepareStatus"
        case totalDuration = "TotalDuration"
        case transferDuration = "TransferDuration"
        case transferStatus = "TransferStatus"
        case verifyDuration = "VerifyDuration"
        case verifyStatus = "VerifyStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorDetail = errorDetail {
            try encodeContainer.encode(errorDetail, forKey: .errorDetail)
        }
        if let prepareDuration = prepareDuration {
            try encodeContainer.encode(prepareDuration, forKey: .prepareDuration)
        }
        if let prepareStatus = prepareStatus {
            try encodeContainer.encode(prepareStatus.rawValue, forKey: .prepareStatus)
        }
        if let totalDuration = totalDuration {
            try encodeContainer.encode(totalDuration, forKey: .totalDuration)
        }
        if let transferDuration = transferDuration {
            try encodeContainer.encode(transferDuration, forKey: .transferDuration)
        }
        if let transferStatus = transferStatus {
            try encodeContainer.encode(transferStatus.rawValue, forKey: .transferStatus)
        }
        if let verifyDuration = verifyDuration {
            try encodeContainer.encode(verifyDuration, forKey: .verifyDuration)
        }
        if let verifyStatus = verifyStatus {
            try encodeContainer.encode(verifyStatus.rawValue, forKey: .verifyStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prepareDurationDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .prepareDuration)
        prepareDuration = prepareDurationDecoded
        let prepareStatusDecoded = try containerValues.decodeIfPresent(PhaseStatus.self, forKey: .prepareStatus)
        prepareStatus = prepareStatusDecoded
        let totalDurationDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalDuration)
        totalDuration = totalDurationDecoded
        let transferDurationDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .transferDuration)
        transferDuration = transferDurationDecoded
        let transferStatusDecoded = try containerValues.decodeIfPresent(PhaseStatus.self, forKey: .transferStatus)
        transferStatus = transferStatusDecoded
        let verifyDurationDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .verifyDuration)
        verifyDuration = verifyDurationDecoded
        let verifyStatusDecoded = try containerValues.decodeIfPresent(PhaseStatus.self, forKey: .verifyStatus)
        verifyStatus = verifyStatusDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorDetailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorDetail)
        errorDetail = errorDetailDecoded
    }
}

extension TaskExecutionResultDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskExecutionResultDetail(errorCode: \(String(describing: errorCode)), errorDetail: \(String(describing: errorDetail)), prepareDuration: \(String(describing: prepareDuration)), prepareStatus: \(String(describing: prepareStatus)), totalDuration: \(String(describing: totalDuration)), transferDuration: \(String(describing: transferDuration)), transferStatus: \(String(describing: transferStatus)), verifyDuration: \(String(describing: verifyDuration)), verifyStatus: \(String(describing: verifyStatus)))"}
}

/// <p>Describes the detailed result of a <code>TaskExecution</code> operation. This result
///       includes the time in milliseconds spent in each phase, the status of the task execution, and
///       the errors encountered.</p>
public struct TaskExecutionResultDetail: Equatable {
    /// <p>Errors that AWS DataSync encountered during execution of the task. You can use this
    ///       error code to help troubleshoot issues.</p>
    public let errorCode: String?
    /// <p>Detailed description of an error that was encountered during the task execution. You
    ///       can use this information to help troubleshoot issues. </p>
    public let errorDetail: String?
    /// <p>The total time in milliseconds that AWS DataSync spent in the PREPARING phase.
    ///     </p>
    public let prepareDuration: Int?
    /// <p>The status of the PREPARING phase.</p>
    public let prepareStatus: PhaseStatus?
    /// <p>The total time in milliseconds that AWS DataSync took to transfer the file from the source to the destination location.</p>
    public let totalDuration: Int?
    /// <p>The total time in milliseconds that AWS DataSync spent in the TRANSFERRING
    ///       phase.</p>
    public let transferDuration: Int?
    /// <p>The status of the TRANSFERRING phase.</p>
    public let transferStatus: PhaseStatus?
    /// <p>The total time in milliseconds that AWS DataSync spent in the VERIFYING
    ///       phase.</p>
    public let verifyDuration: Int?
    /// <p>The status of the VERIFYING phase.</p>
    public let verifyStatus: PhaseStatus?

    public init (
        errorCode: String? = nil,
        errorDetail: String? = nil,
        prepareDuration: Int? = nil,
        prepareStatus: PhaseStatus? = nil,
        totalDuration: Int? = nil,
        transferDuration: Int? = nil,
        transferStatus: PhaseStatus? = nil,
        verifyDuration: Int? = nil,
        verifyStatus: PhaseStatus? = nil
    )
    {
        self.errorCode = errorCode
        self.errorDetail = errorDetail
        self.prepareDuration = prepareDuration
        self.prepareStatus = prepareStatus
        self.totalDuration = totalDuration
        self.transferDuration = transferDuration
        self.transferStatus = transferStatus
        self.verifyDuration = verifyDuration
        self.verifyStatus = verifyStatus
    }
}

public enum TaskExecutionStatus {
    case error
    case launching
    case preparing
    case queued
    case success
    case transferring
    case verifying
    case sdkUnknown(String)
}

extension TaskExecutionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TaskExecutionStatus] {
        return [
            .error,
            .launching,
            .preparing,
            .queued,
            .success,
            .transferring,
            .verifying,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .error: return "ERROR"
        case .launching: return "LAUNCHING"
        case .preparing: return "PREPARING"
        case .queued: return "QUEUED"
        case .success: return "SUCCESS"
        case .transferring: return "TRANSFERRING"
        case .verifying: return "VERIFYING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TaskExecutionStatus(rawValue: rawValue) ?? TaskExecutionStatus.sdkUnknown(rawValue)
    }
}

extension TaskFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case `operator` = "Operator"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(TaskFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(Operator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension TaskFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskFilter(name: \(String(describing: name)), operator: \(String(describing: `operator`)), values: \(String(describing: values)))"}
}

/// <p>You can use API filters to narrow down the list of resources returned by <code>ListTasks</code>.
///       For example, to retrieve all tasks on a source location, you can use <code>ListTasks</code>
///       with filter name <code>LocationId</code> and <code>Operator Equals</code> with the ARN for the
///       location.</p>
public struct TaskFilter: Equatable {
    /// <p>The operator that is used to compare filter values (for example, <code>Equals</code> or
    ///       <code>Contains</code>). For more about API filtering operators, see
    ///       <a href="https://docs.aws.amazon.com/datasync/latest/userguide/query-resources.html">API filters for ListTasks and ListLocations</a>.</p>
    public let `operator`: Operator?
    /// <p>The name of the filter being used. Each API call supports a list of filters that are available
    ///       for it. For example, <code>LocationId</code> for <code>ListTasks</code>.</p>
    public let name: TaskFilterName?
    /// <p>The values that you want to filter for. For example, you might want to display only tasks
    ///       for a specific destination location.</p>
    public let values: [String]?

    public init (
        `operator`: Operator? = nil,
        name: TaskFilterName? = nil,
        values: [String]? = nil
    )
    {
        self.`operator` = `operator`
        self.name = name
        self.values = values
    }
}

public enum TaskFilterName {
    case creationtime
    case locationid
    case sdkUnknown(String)
}

extension TaskFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TaskFilterName] {
        return [
            .creationtime,
            .locationid,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .creationtime: return "CreationTime"
        case .locationid: return "LocationId"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TaskFilterName(rawValue: rawValue) ?? TaskFilterName.sdkUnknown(rawValue)
    }
}

extension TaskListEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case status = "Status"
        case taskArn = "TaskArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let taskArn = taskArn {
            try encodeContainer.encode(taskArn, forKey: .taskArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TaskStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension TaskListEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskListEntry(name: \(String(describing: name)), status: \(String(describing: status)), taskArn: \(String(describing: taskArn)))"}
}

/// <p>Represents a single entry in a list of tasks. <code>TaskListEntry</code> returns an
///       array that contains a list of tasks when the <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_ListTasks.html">ListTasks</a> operation is called.
///       A task includes the source and destination file systems to sync and the options to use for the
///       tasks.</p>
public struct TaskListEntry: Equatable {
    /// <p>The name of the task.</p>
    public let name: String?
    /// <p>The status of the task.</p>
    public let status: TaskStatus?
    /// <p>The Amazon Resource Name (ARN) of the task.</p>
    public let taskArn: String?

    public init (
        name: String? = nil,
        status: TaskStatus? = nil,
        taskArn: String? = nil
    )
    {
        self.name = name
        self.status = status
        self.taskArn = taskArn
    }
}

public enum TaskQueueing {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension TaskQueueing : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TaskQueueing] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TaskQueueing(rawValue: rawValue) ?? TaskQueueing.sdkUnknown(rawValue)
    }
}

extension TaskSchedule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case scheduleExpression = "ScheduleExpression"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
    }
}

extension TaskSchedule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskSchedule(scheduleExpression: \(String(describing: scheduleExpression)))"}
}

/// <p>Specifies the schedule you want your task to use for repeated executions. For more
///       information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html">Schedule Expressions for Rules</a>.</p>
public struct TaskSchedule: Equatable {
    /// <p>A cron expression that specifies when AWS DataSync initiates a scheduled transfer from a
    ///       source to a destination location. </p>
    public let scheduleExpression: String?

    public init (
        scheduleExpression: String? = nil
    )
    {
        self.scheduleExpression = scheduleExpression
    }
}

public enum TaskStatus {
    case available
    case creating
    case queued
    case running
    case unavailable
    case sdkUnknown(String)
}

extension TaskStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TaskStatus] {
        return [
            .available,
            .creating,
            .queued,
            .running,
            .unavailable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .creating: return "CREATING"
        case .queued: return "QUEUED"
        case .running: return "RUNNING"
        case .unavailable: return "UNAVAILABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TaskStatus(rawValue: rawValue) ?? TaskStatus.sdkUnknown(rawValue)
    }
}

public enum TransferMode {
    case all
    case changed
    case sdkUnknown(String)
}

extension TransferMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TransferMode] {
        return [
            .all,
            .changed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .changed: return "CHANGED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TransferMode(rawValue: rawValue) ?? TransferMode.sdkUnknown(rawValue)
    }
}

public enum Uid {
    case both
    case intValue
    case name
    case `none`
    case sdkUnknown(String)
}

extension Uid : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Uid] {
        return [
            .both,
            .intValue,
            .name,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .both: return "BOTH"
        case .intValue: return "INT_VALUE"
        case .name: return "NAME"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Uid(rawValue: rawValue) ?? Uid.sdkUnknown(rawValue)
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(keys: \(String(describing: keys)), resourceArn: \(String(describing: resourceArn)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keys = "Keys"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keys = keys {
            var keysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keys)
            for tagkeylist0 in keys {
                try keysContainer.encode(tagkeylist0)
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

/// <p>UntagResourceRequest</p>
public struct UntagResourceInput: Equatable {
    /// <p>The keys in the key-value pair in the tag to remove.</p>
    public let keys: [String]?
    /// <p>The Amazon Resource Name (ARN) of the resource to remove the tag from.</p>
    public let resourceArn: String?

    public init (
        keys: [String]? = nil,
        resourceArn: String? = nil
    )
    {
        self.keys = keys
        self.resourceArn = resourceArn
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let keys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keys = "Keys"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let keysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .keys)
        var keysDecoded0:[String]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [String]()
            for string0 in keysContainer {
                if let string0 = string0 {
                    keysDecoded0?.append(string0)
                }
            }
        }
        keys = keysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAgentInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAgentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAgentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAgentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAgentInput>
    public typealias MOutput = OperationOutput<UpdateAgentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAgentOutputError>
}

extension UpdateAgentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAgentInput(agentArn: \(String(describing: agentArn)), name: \(String(describing: name)))"}
}

extension UpdateAgentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentArn = "AgentArn"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentArn = agentArn {
            try encodeContainer.encode(agentArn, forKey: .agentArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateAgentInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAgentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAgentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAgentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAgentInput>
    public typealias MOutput = OperationOutput<UpdateAgentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAgentOutputError>
}

public struct UpdateAgentInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAgentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAgentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAgentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAgentInput>
    public typealias MOutput = OperationOutput<UpdateAgentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAgentOutputError>
}

/// <p>UpdateAgentRequest</p>
public struct UpdateAgentInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the agent to update.</p>
    public let agentArn: String?
    /// <p>The name that you want to use to configure the agent.</p>
    public let name: String?

    public init (
        agentArn: String? = nil,
        name: String? = nil
    )
    {
        self.agentArn = agentArn
        self.name = name
    }
}

struct UpdateAgentInputBody: Equatable {
    public let agentArn: String?
    public let name: String?
}

extension UpdateAgentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentArn = "AgentArn"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentArn)
        agentArn = agentArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateAgentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAgentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAgentOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAgentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAgentOutputResponse()"}
}

extension UpdateAgentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAgentOutputResponse: Equatable {

    public init() {}
}

struct UpdateAgentOutputResponseBody: Equatable {
}

extension UpdateAgentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateLocationNfsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLocationNfsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLocationNfsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLocationNfsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLocationNfsInput>
    public typealias MOutput = OperationOutput<UpdateLocationNfsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLocationNfsOutputError>
}

extension UpdateLocationNfsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLocationNfsInput(locationArn: \(String(describing: locationArn)), mountOptions: \(String(describing: mountOptions)), onPremConfig: \(String(describing: onPremConfig)), subdirectory: \(String(describing: subdirectory)))"}
}

extension UpdateLocationNfsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case locationArn = "LocationArn"
        case mountOptions = "MountOptions"
        case onPremConfig = "OnPremConfig"
        case subdirectory = "Subdirectory"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locationArn = locationArn {
            try encodeContainer.encode(locationArn, forKey: .locationArn)
        }
        if let mountOptions = mountOptions {
            try encodeContainer.encode(mountOptions, forKey: .mountOptions)
        }
        if let onPremConfig = onPremConfig {
            try encodeContainer.encode(onPremConfig, forKey: .onPremConfig)
        }
        if let subdirectory = subdirectory {
            try encodeContainer.encode(subdirectory, forKey: .subdirectory)
        }
    }
}

public struct UpdateLocationNfsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLocationNfsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLocationNfsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLocationNfsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLocationNfsInput>
    public typealias MOutput = OperationOutput<UpdateLocationNfsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLocationNfsOutputError>
}

public struct UpdateLocationNfsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLocationNfsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLocationNfsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLocationNfsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLocationNfsInput>
    public typealias MOutput = OperationOutput<UpdateLocationNfsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLocationNfsOutputError>
}

public struct UpdateLocationNfsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the NFS location to update.</p>
    public let locationArn: String?
    /// <p>Represents the mount options that are available for DataSync to access an NFS
    ///       location.</p>
    public let mountOptions: NfsMountOptions?
    /// <p>A list of Amazon Resource Names (ARNs) of agents to use for a Network File System (NFS)
    ///       location.</p>
    public let onPremConfig: OnPremConfig?
    /// <p>The subdirectory in the NFS file system that is used to read data from the NFS source
    ///       location or write data to the NFS destination. The NFS path should be a path that's
    ///       exported by the NFS server, or a subdirectory of that path. The path should be such that it
    ///       can be mounted by other NFS clients in your network.</p>
    ///
    ///          <p>To see all the paths exported by your NFS server, run "<code>showmount -e
    ///         nfs-server-name</code>" from an NFS client that has access to your server. You can specify
    ///         any directory that appears in the results, and any subdirectory of that directory. Ensure that
    ///         the NFS export is accessible without Kerberos authentication. </p>
    ///          <p>To transfer all the data in the folder that you specified, DataSync must have
    ///       permissions to read all the data. To ensure this, either configure the NFS export with
    ///         <code>no_root_squash</code>, or ensure that the files you want DataSync to
    ///       access have permissions that allow read access for all users. Doing either option enables the
    ///       agent to read the files. For the agent to access directories, you must additionally enable all
    ///       execute access.</p>
    ///          <p>If you are copying data to or from your AWS Snowcone device, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-nfs-location.html#nfs-on-snowcone">NFS Server on AWS Snowcone</a> for more information.</p>
    ///
    ///          <p>For information about NFS export configuration, see 18.7. The /etc/exports
    ///       Configuration File in the Red Hat Enterprise Linux documentation.</p>
    public let subdirectory: String?

    public init (
        locationArn: String? = nil,
        mountOptions: NfsMountOptions? = nil,
        onPremConfig: OnPremConfig? = nil,
        subdirectory: String? = nil
    )
    {
        self.locationArn = locationArn
        self.mountOptions = mountOptions
        self.onPremConfig = onPremConfig
        self.subdirectory = subdirectory
    }
}

struct UpdateLocationNfsInputBody: Equatable {
    public let locationArn: String?
    public let subdirectory: String?
    public let onPremConfig: OnPremConfig?
    public let mountOptions: NfsMountOptions?
}

extension UpdateLocationNfsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case locationArn = "LocationArn"
        case mountOptions = "MountOptions"
        case onPremConfig = "OnPremConfig"
        case subdirectory = "Subdirectory"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationArn)
        locationArn = locationArnDecoded
        let subdirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subdirectory)
        subdirectory = subdirectoryDecoded
        let onPremConfigDecoded = try containerValues.decodeIfPresent(OnPremConfig.self, forKey: .onPremConfig)
        onPremConfig = onPremConfigDecoded
        let mountOptionsDecoded = try containerValues.decodeIfPresent(NfsMountOptions.self, forKey: .mountOptions)
        mountOptions = mountOptionsDecoded
    }
}

extension UpdateLocationNfsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLocationNfsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLocationNfsOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLocationNfsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLocationNfsOutputResponse()"}
}

extension UpdateLocationNfsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLocationNfsOutputResponse: Equatable {

    public init() {}
}

struct UpdateLocationNfsOutputResponseBody: Equatable {
}

extension UpdateLocationNfsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateLocationObjectStorageInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLocationObjectStorageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLocationObjectStorageInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLocationObjectStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLocationObjectStorageInput>
    public typealias MOutput = OperationOutput<UpdateLocationObjectStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLocationObjectStorageOutputError>
}

extension UpdateLocationObjectStorageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLocationObjectStorageInput(accessKey: \(String(describing: accessKey)), agentArns: \(String(describing: agentArns)), locationArn: \(String(describing: locationArn)), secretKey: \(String(describing: secretKey)), serverPort: \(String(describing: serverPort)), serverProtocol: \(String(describing: serverProtocol)), subdirectory: \(String(describing: subdirectory)))"}
}

extension UpdateLocationObjectStorageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessKey = "AccessKey"
        case agentArns = "AgentArns"
        case locationArn = "LocationArn"
        case secretKey = "SecretKey"
        case serverPort = "ServerPort"
        case serverProtocol = "ServerProtocol"
        case subdirectory = "Subdirectory"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKey = accessKey {
            try encodeContainer.encode(accessKey, forKey: .accessKey)
        }
        if let agentArns = agentArns {
            var agentArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentArns)
            for agentarnlist0 in agentArns {
                try agentArnsContainer.encode(agentarnlist0)
            }
        }
        if let locationArn = locationArn {
            try encodeContainer.encode(locationArn, forKey: .locationArn)
        }
        if let secretKey = secretKey {
            try encodeContainer.encode(secretKey, forKey: .secretKey)
        }
        if let serverPort = serverPort {
            try encodeContainer.encode(serverPort, forKey: .serverPort)
        }
        if let serverProtocol = serverProtocol {
            try encodeContainer.encode(serverProtocol.rawValue, forKey: .serverProtocol)
        }
        if let subdirectory = subdirectory {
            try encodeContainer.encode(subdirectory, forKey: .subdirectory)
        }
    }
}

public struct UpdateLocationObjectStorageInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLocationObjectStorageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLocationObjectStorageInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLocationObjectStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLocationObjectStorageInput>
    public typealias MOutput = OperationOutput<UpdateLocationObjectStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLocationObjectStorageOutputError>
}

public struct UpdateLocationObjectStorageInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLocationObjectStorageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLocationObjectStorageInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLocationObjectStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLocationObjectStorageInput>
    public typealias MOutput = OperationOutput<UpdateLocationObjectStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLocationObjectStorageOutputError>
}

public struct UpdateLocationObjectStorageInput: Equatable {
    /// <p>Optional. The access key is used if credentials are required to access the self-managed
    ///       object storage server. If your object storage requires a user name and password to
    ///       authenticate, use <code>AccessKey</code> and <code>SecretKey</code> to provide the user name
    ///       and password, respectively.</p>
    public let accessKey: String?
    /// <p>The Amazon Resource Name (ARN) of the agents associated with the
    ///       self-managed object storage server location.</p>
    public let agentArns: [String]?
    /// <p>The Amazon Resource Name (ARN) of the self-managed object storage server location to be updated.</p>
    public let locationArn: String?
    /// <p>Optional. The secret key is used if credentials are required to access the self-managed
    ///       object storage server. If your object storage requires a user name and password to
    ///       authenticate, use <code>AccessKey</code> and <code>SecretKey</code> to provide the user name
    ///       and password, respectively.</p>
    public let secretKey: String?
    /// <p>The port that your self-managed object storage server accepts inbound network traffic on.
    ///       The server port is set by default to TCP 80 (HTTP) or TCP 443 (HTTPS). You can
    ///       specify a custom port if your self-managed object storage server requires one.</p>
    public let serverPort: Int?
    /// <p>The protocol that the object storage server uses to communicate. Valid values are
    ///         <code>HTTP</code> or <code>HTTPS</code>.</p>
    public let serverProtocol: ObjectStorageServerProtocol?
    /// <p>The subdirectory in the self-managed object storage server that is used
    ///       to read data from.</p>
    public let subdirectory: String?

    public init (
        accessKey: String? = nil,
        agentArns: [String]? = nil,
        locationArn: String? = nil,
        secretKey: String? = nil,
        serverPort: Int? = nil,
        serverProtocol: ObjectStorageServerProtocol? = nil,
        subdirectory: String? = nil
    )
    {
        self.accessKey = accessKey
        self.agentArns = agentArns
        self.locationArn = locationArn
        self.secretKey = secretKey
        self.serverPort = serverPort
        self.serverProtocol = serverProtocol
        self.subdirectory = subdirectory
    }
}

struct UpdateLocationObjectStorageInputBody: Equatable {
    public let locationArn: String?
    public let serverPort: Int?
    public let serverProtocol: ObjectStorageServerProtocol?
    public let subdirectory: String?
    public let accessKey: String?
    public let secretKey: String?
    public let agentArns: [String]?
}

extension UpdateLocationObjectStorageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessKey = "AccessKey"
        case agentArns = "AgentArns"
        case locationArn = "LocationArn"
        case secretKey = "SecretKey"
        case serverPort = "ServerPort"
        case serverProtocol = "ServerProtocol"
        case subdirectory = "Subdirectory"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationArn)
        locationArn = locationArnDecoded
        let serverPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .serverPort)
        serverPort = serverPortDecoded
        let serverProtocolDecoded = try containerValues.decodeIfPresent(ObjectStorageServerProtocol.self, forKey: .serverProtocol)
        serverProtocol = serverProtocolDecoded
        let subdirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subdirectory)
        subdirectory = subdirectoryDecoded
        let accessKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessKey)
        accessKey = accessKeyDecoded
        let secretKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretKey)
        secretKey = secretKeyDecoded
        let agentArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .agentArns)
        var agentArnsDecoded0:[String]? = nil
        if let agentArnsContainer = agentArnsContainer {
            agentArnsDecoded0 = [String]()
            for string0 in agentArnsContainer {
                if let string0 = string0 {
                    agentArnsDecoded0?.append(string0)
                }
            }
        }
        agentArns = agentArnsDecoded0
    }
}

extension UpdateLocationObjectStorageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLocationObjectStorageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLocationObjectStorageOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLocationObjectStorageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLocationObjectStorageOutputResponse()"}
}

extension UpdateLocationObjectStorageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLocationObjectStorageOutputResponse: Equatable {

    public init() {}
}

struct UpdateLocationObjectStorageOutputResponseBody: Equatable {
}

extension UpdateLocationObjectStorageOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateLocationSmbInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLocationSmbInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLocationSmbInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLocationSmbOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLocationSmbInput>
    public typealias MOutput = OperationOutput<UpdateLocationSmbOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLocationSmbOutputError>
}

extension UpdateLocationSmbInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLocationSmbInput(agentArns: \(String(describing: agentArns)), domain: \(String(describing: domain)), locationArn: \(String(describing: locationArn)), mountOptions: \(String(describing: mountOptions)), password: \(String(describing: password)), subdirectory: \(String(describing: subdirectory)), user: \(String(describing: user)))"}
}

extension UpdateLocationSmbInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentArns = "AgentArns"
        case domain = "Domain"
        case locationArn = "LocationArn"
        case mountOptions = "MountOptions"
        case password = "Password"
        case subdirectory = "Subdirectory"
        case user = "User"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentArns = agentArns {
            var agentArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentArns)
            for agentarnlist0 in agentArns {
                try agentArnsContainer.encode(agentarnlist0)
            }
        }
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let locationArn = locationArn {
            try encodeContainer.encode(locationArn, forKey: .locationArn)
        }
        if let mountOptions = mountOptions {
            try encodeContainer.encode(mountOptions, forKey: .mountOptions)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let subdirectory = subdirectory {
            try encodeContainer.encode(subdirectory, forKey: .subdirectory)
        }
        if let user = user {
            try encodeContainer.encode(user, forKey: .user)
        }
    }
}

public struct UpdateLocationSmbInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLocationSmbInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLocationSmbInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLocationSmbOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLocationSmbInput>
    public typealias MOutput = OperationOutput<UpdateLocationSmbOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLocationSmbOutputError>
}

public struct UpdateLocationSmbInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLocationSmbInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLocationSmbInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLocationSmbOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLocationSmbInput>
    public typealias MOutput = OperationOutput<UpdateLocationSmbOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLocationSmbOutputError>
}

public struct UpdateLocationSmbInput: Equatable {
    /// <p>The Amazon Resource Names (ARNs) of agents to use for a Simple Message Block (SMB)
    ///       location.</p>
    public let agentArns: [String]?
    /// <p>The name of the Windows domain that the SMB server belongs to.</p>
    public let domain: String?
    /// <p>The Amazon Resource Name (ARN) of the SMB location to update.</p>
    public let locationArn: String?
    /// <p>Represents the mount options that are available for DataSync to access an SMB
    ///       location.</p>
    public let mountOptions: SmbMountOptions?
    /// <p>The password of the user who can mount the share has the permissions to access files and
    ///       folders in the SMB share.</p>
    public let password: String?
    /// <p>The subdirectory in the SMB file system that is used to read data from the SMB source
    ///       location or write data to the SMB destination. The SMB path should be a path that's
    ///       exported by the SMB server, or a subdirectory of that path. The path should be such that it
    ///       can be mounted by other SMB clients in your network.</p>
    ///          <note>
    ///             <p>
    ///                <code>Subdirectory</code> must be specified with forward slashes. For example,
    ///       <code>/path/to/folder</code>.</p>
    ///          </note>
    ///
    ///          <p>To transfer all the data in the folder that you specified, DataSync must have
    ///       permissions to mount the SMB share and to access all the data in that share. To ensure this,
    ///       do either of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Ensure that the user/password specified belongs to the user who can mount the share
    ///           and who has the appropriate permissions for all of the files and directories that you want
    ///           DataSync to access.</p>
    ///             </li>
    ///             <li>
    ///                <p>Use credentials of a member of the Backup Operators group to mount the share. </p>
    ///             </li>
    ///          </ul>
    ///          <p>Doing either of these options enables the agent to access the data. For the agent to
    ///       access directories, you must also enable all execute access.</p>
    public let subdirectory: String?
    /// <p>The user who can mount the share has the permissions to access files and folders in the
    ///       SMB share.</p>
    public let user: String?

    public init (
        agentArns: [String]? = nil,
        domain: String? = nil,
        locationArn: String? = nil,
        mountOptions: SmbMountOptions? = nil,
        password: String? = nil,
        subdirectory: String? = nil,
        user: String? = nil
    )
    {
        self.agentArns = agentArns
        self.domain = domain
        self.locationArn = locationArn
        self.mountOptions = mountOptions
        self.password = password
        self.subdirectory = subdirectory
        self.user = user
    }
}

struct UpdateLocationSmbInputBody: Equatable {
    public let locationArn: String?
    public let subdirectory: String?
    public let user: String?
    public let domain: String?
    public let password: String?
    public let agentArns: [String]?
    public let mountOptions: SmbMountOptions?
}

extension UpdateLocationSmbInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentArns = "AgentArns"
        case domain = "Domain"
        case locationArn = "LocationArn"
        case mountOptions = "MountOptions"
        case password = "Password"
        case subdirectory = "Subdirectory"
        case user = "User"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationArn)
        locationArn = locationArnDecoded
        let subdirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subdirectory)
        subdirectory = subdirectoryDecoded
        let userDecoded = try containerValues.decodeIfPresent(String.self, forKey: .user)
        user = userDecoded
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let agentArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .agentArns)
        var agentArnsDecoded0:[String]? = nil
        if let agentArnsContainer = agentArnsContainer {
            agentArnsDecoded0 = [String]()
            for string0 in agentArnsContainer {
                if let string0 = string0 {
                    agentArnsDecoded0?.append(string0)
                }
            }
        }
        agentArns = agentArnsDecoded0
        let mountOptionsDecoded = try containerValues.decodeIfPresent(SmbMountOptions.self, forKey: .mountOptions)
        mountOptions = mountOptionsDecoded
    }
}

extension UpdateLocationSmbOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLocationSmbOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLocationSmbOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLocationSmbOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLocationSmbOutputResponse()"}
}

extension UpdateLocationSmbOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLocationSmbOutputResponse: Equatable {

    public init() {}
}

struct UpdateLocationSmbOutputResponseBody: Equatable {
}

extension UpdateLocationSmbOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateTaskExecutionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateTaskExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTaskExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTaskExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTaskExecutionInput>
    public typealias MOutput = OperationOutput<UpdateTaskExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTaskExecutionOutputError>
}

extension UpdateTaskExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTaskExecutionInput(options: \(String(describing: options)), taskExecutionArn: \(String(describing: taskExecutionArn)))"}
}

extension UpdateTaskExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case options = "Options"
        case taskExecutionArn = "TaskExecutionArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let options = options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let taskExecutionArn = taskExecutionArn {
            try encodeContainer.encode(taskExecutionArn, forKey: .taskExecutionArn)
        }
    }
}

public struct UpdateTaskExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateTaskExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTaskExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTaskExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTaskExecutionInput>
    public typealias MOutput = OperationOutput<UpdateTaskExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTaskExecutionOutputError>
}

public struct UpdateTaskExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateTaskExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTaskExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTaskExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTaskExecutionInput>
    public typealias MOutput = OperationOutput<UpdateTaskExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTaskExecutionOutputError>
}

public struct UpdateTaskExecutionInput: Equatable {
    /// <p>Represents the options that are available to control the behavior of a
    ///       <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>
    ///       operation. Behavior includes preserving metadata such as user
    ///       ID (UID), group ID (GID), and file permissions, and also overwriting files in the destination,
    ///       data integrity verification, and so on.</p>
    ///          <p>A task has a set of default options associated with it. If you don't specify an option
    ///       in <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>,
    ///       the default value is used. You can override the
    ///       defaults options on each task execution by specifying an overriding <code>Options</code> value
    ///       to <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>.</p>
    public let options: Options?
    /// <p>The Amazon Resource Name (ARN) of the specific task execution that is being updated. </p>
    public let taskExecutionArn: String?

    public init (
        options: Options? = nil,
        taskExecutionArn: String? = nil
    )
    {
        self.options = options
        self.taskExecutionArn = taskExecutionArn
    }
}

struct UpdateTaskExecutionInputBody: Equatable {
    public let taskExecutionArn: String?
    public let options: Options?
}

extension UpdateTaskExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case options = "Options"
        case taskExecutionArn = "TaskExecutionArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskExecutionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskExecutionArn)
        taskExecutionArn = taskExecutionArnDecoded
        let optionsDecoded = try containerValues.decodeIfPresent(Options.self, forKey: .options)
        options = optionsDecoded
    }
}

extension UpdateTaskExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTaskExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTaskExecutionOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTaskExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTaskExecutionOutputResponse()"}
}

extension UpdateTaskExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateTaskExecutionOutputResponse: Equatable {

    public init() {}
}

struct UpdateTaskExecutionOutputResponseBody: Equatable {
}

extension UpdateTaskExecutionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateTaskInputBodyMiddleware: Middleware {
    public let id: String = "UpdateTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTaskInput>
    public typealias MOutput = OperationOutput<UpdateTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTaskOutputError>
}

extension UpdateTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTaskInput(cloudWatchLogGroupArn: \(String(describing: cloudWatchLogGroupArn)), excludes: \(String(describing: excludes)), name: \(String(describing: name)), options: \(String(describing: options)), schedule: \(String(describing: schedule)), taskArn: \(String(describing: taskArn)))"}
}

extension UpdateTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogGroupArn = "CloudWatchLogGroupArn"
        case excludes = "Excludes"
        case name = "Name"
        case options = "Options"
        case schedule = "Schedule"
        case taskArn = "TaskArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogGroupArn = cloudWatchLogGroupArn {
            try encodeContainer.encode(cloudWatchLogGroupArn, forKey: .cloudWatchLogGroupArn)
        }
        if let excludes = excludes {
            var excludesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludes)
            for filterlist0 in excludes {
                try excludesContainer.encode(filterlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let options = options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let taskArn = taskArn {
            try encodeContainer.encode(taskArn, forKey: .taskArn)
        }
    }
}

public struct UpdateTaskInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTaskInput>
    public typealias MOutput = OperationOutput<UpdateTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTaskOutputError>
}

public struct UpdateTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTaskInput>
    public typealias MOutput = OperationOutput<UpdateTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTaskOutputError>
}

/// <p>UpdateTaskResponse</p>
public struct UpdateTaskInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource name of the CloudWatch
    ///       LogGroup.</p>
    public let cloudWatchLogGroupArn: String?
    /// <p>A list of filter rules that determines which files to exclude from a task. The list should
    ///       contain a single filter string that consists of the patterns to exclude. The patterns are
    ///       delimited by "|" (that is, a pipe), for example: <code>"/folder1|/folder2"</code>
    ///          </p>
    ///          <p>
    ///     </p>
    public let excludes: [FilterRule]?
    /// <p>The name of the task to update.</p>
    public let name: String?
    /// <p>Represents the options that are available to control the behavior of a
    ///       <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>
    ///       operation. Behavior includes preserving metadata such as user
    ///       ID (UID), group ID (GID), and file permissions, and also overwriting files in the destination,
    ///       data integrity verification, and so on.</p>
    ///          <p>A task has a set of default options associated with it. If you don't specify an option
    ///       in <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>,
    ///       the default value is used. You can override the
    ///       defaults options on each task execution by specifying an overriding <code>Options</code> value
    ///       to <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>.</p>
    public let options: Options?
    /// <p>Specifies a schedule used to periodically transfer files from a source to a destination
    ///       location. You can configure your task to execute hourly, daily, weekly or on specific days of
    ///       the week. You control when in the day or hour you want the task to execute. The time you
    ///       specify is UTC time. For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/task-scheduling.html">Scheduling your task</a>.</p>
    public let schedule: TaskSchedule?
    /// <p>The Amazon Resource Name (ARN) of the resource name of the task to update.</p>
    public let taskArn: String?

    public init (
        cloudWatchLogGroupArn: String? = nil,
        excludes: [FilterRule]? = nil,
        name: String? = nil,
        options: Options? = nil,
        schedule: TaskSchedule? = nil,
        taskArn: String? = nil
    )
    {
        self.cloudWatchLogGroupArn = cloudWatchLogGroupArn
        self.excludes = excludes
        self.name = name
        self.options = options
        self.schedule = schedule
        self.taskArn = taskArn
    }
}

struct UpdateTaskInputBody: Equatable {
    public let taskArn: String?
    public let options: Options?
    public let excludes: [FilterRule]?
    public let schedule: TaskSchedule?
    public let name: String?
    public let cloudWatchLogGroupArn: String?
}

extension UpdateTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogGroupArn = "CloudWatchLogGroupArn"
        case excludes = "Excludes"
        case name = "Name"
        case options = "Options"
        case schedule = "Schedule"
        case taskArn = "TaskArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let optionsDecoded = try containerValues.decodeIfPresent(Options.self, forKey: .options)
        options = optionsDecoded
        let excludesContainer = try containerValues.decodeIfPresent([FilterRule?].self, forKey: .excludes)
        var excludesDecoded0:[FilterRule]? = nil
        if let excludesContainer = excludesContainer {
            excludesDecoded0 = [FilterRule]()
            for structure0 in excludesContainer {
                if let structure0 = structure0 {
                    excludesDecoded0?.append(structure0)
                }
            }
        }
        excludes = excludesDecoded0
        let scheduleDecoded = try containerValues.decodeIfPresent(TaskSchedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let cloudWatchLogGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogGroupArn)
        cloudWatchLogGroupArn = cloudWatchLogGroupArnDecoded
    }
}

extension UpdateTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTaskOutputError: Swift.Error, Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTaskOutputResponse()"}
}

extension UpdateTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateTaskOutputResponse: Equatable {

    public init() {}
}

struct UpdateTaskOutputResponseBody: Equatable {
}

extension UpdateTaskOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum VerifyMode {
    case `none`
    case onlyFilesTransferred
    case pointInTimeConsistent
    case sdkUnknown(String)
}

extension VerifyMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VerifyMode] {
        return [
            .none,
            .onlyFilesTransferred,
            .pointInTimeConsistent,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .none: return "NONE"
        case .onlyFilesTransferred: return "ONLY_FILES_TRANSFERRED"
        case .pointInTimeConsistent: return "POINT_IN_TIME_CONSISTENT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VerifyMode(rawValue: rawValue) ?? VerifyMode.sdkUnknown(rawValue)
    }
}
