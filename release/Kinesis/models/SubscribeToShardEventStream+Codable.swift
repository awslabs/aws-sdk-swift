// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension SubscribeToShardEventStream: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case internalFailureException = "InternalFailureException"
        case kMSAccessDeniedException = "KMSAccessDeniedException"
        case kMSDisabledException = "KMSDisabledException"
        case kMSInvalidStateException = "KMSInvalidStateException"
        case kMSNotFoundException = "KMSNotFoundException"
        case kMSOptInRequired = "KMSOptInRequired"
        case kMSThrottlingException = "KMSThrottlingException"
        case resourceInUseException = "ResourceInUseException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case subscribeToShardEvent = "SubscribeToShardEvent"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .internalFailureException(internalFailureException):
                if let internalFailureException = internalFailureException {
                    try container.encode(internalFailureException, forKey: .internalFailureException)
                }
            case let .kMSAccessDeniedException(kMSAccessDeniedException):
                if let kMSAccessDeniedException = kMSAccessDeniedException {
                    try container.encode(kMSAccessDeniedException, forKey: .kMSAccessDeniedException)
                }
            case let .kMSDisabledException(kMSDisabledException):
                if let kMSDisabledException = kMSDisabledException {
                    try container.encode(kMSDisabledException, forKey: .kMSDisabledException)
                }
            case let .kMSInvalidStateException(kMSInvalidStateException):
                if let kMSInvalidStateException = kMSInvalidStateException {
                    try container.encode(kMSInvalidStateException, forKey: .kMSInvalidStateException)
                }
            case let .kMSNotFoundException(kMSNotFoundException):
                if let kMSNotFoundException = kMSNotFoundException {
                    try container.encode(kMSNotFoundException, forKey: .kMSNotFoundException)
                }
            case let .kMSOptInRequired(kMSOptInRequired):
                if let kMSOptInRequired = kMSOptInRequired {
                    try container.encode(kMSOptInRequired, forKey: .kMSOptInRequired)
                }
            case let .kMSThrottlingException(kMSThrottlingException):
                if let kMSThrottlingException = kMSThrottlingException {
                    try container.encode(kMSThrottlingException, forKey: .kMSThrottlingException)
                }
            case let .resourceInUseException(resourceInUseException):
                if let resourceInUseException = resourceInUseException {
                    try container.encode(resourceInUseException, forKey: .resourceInUseException)
                }
            case let .resourceNotFoundException(resourceNotFoundException):
                if let resourceNotFoundException = resourceNotFoundException {
                    try container.encode(resourceNotFoundException, forKey: .resourceNotFoundException)
                }
            case let .subscribeToShardEvent(subscribeToShardEvent):
                if let subscribeToShardEvent = subscribeToShardEvent {
                    try container.encode(subscribeToShardEvent, forKey: .subscribeToShardEvent)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let subscribeToShardEventDecoded = try values.decodeIfPresent(SubscribeToShardEvent.self, forKey: .subscribeToShardEvent)
        if let subscribeToShardEvent = subscribeToShardEventDecoded {
            self = .subscribeToShardEvent(subscribeToShardEvent)
            return
        }
        let resourceNotFoundExceptionDecoded = try values.decodeIfPresent(ResourceNotFoundException.self, forKey: .resourceNotFoundException)
        if let resourceNotFoundException = resourceNotFoundExceptionDecoded {
            self = .resourceNotFoundException(resourceNotFoundException)
            return
        }
        let resourceInUseExceptionDecoded = try values.decodeIfPresent(ResourceInUseException.self, forKey: .resourceInUseException)
        if let resourceInUseException = resourceInUseExceptionDecoded {
            self = .resourceInUseException(resourceInUseException)
            return
        }
        let kMSDisabledExceptionDecoded = try values.decodeIfPresent(KMSDisabledException.self, forKey: .kMSDisabledException)
        if let kMSDisabledException = kMSDisabledExceptionDecoded {
            self = .kMSDisabledException(kMSDisabledException)
            return
        }
        let kMSInvalidStateExceptionDecoded = try values.decodeIfPresent(KMSInvalidStateException.self, forKey: .kMSInvalidStateException)
        if let kMSInvalidStateException = kMSInvalidStateExceptionDecoded {
            self = .kMSInvalidStateException(kMSInvalidStateException)
            return
        }
        let kMSAccessDeniedExceptionDecoded = try values.decodeIfPresent(KMSAccessDeniedException.self, forKey: .kMSAccessDeniedException)
        if let kMSAccessDeniedException = kMSAccessDeniedExceptionDecoded {
            self = .kMSAccessDeniedException(kMSAccessDeniedException)
            return
        }
        let kMSNotFoundExceptionDecoded = try values.decodeIfPresent(KMSNotFoundException.self, forKey: .kMSNotFoundException)
        if let kMSNotFoundException = kMSNotFoundExceptionDecoded {
            self = .kMSNotFoundException(kMSNotFoundException)
            return
        }
        let kMSOptInRequiredDecoded = try values.decodeIfPresent(KMSOptInRequired.self, forKey: .kMSOptInRequired)
        if let kMSOptInRequired = kMSOptInRequiredDecoded {
            self = .kMSOptInRequired(kMSOptInRequired)
            return
        }
        let kMSThrottlingExceptionDecoded = try values.decodeIfPresent(KMSThrottlingException.self, forKey: .kMSThrottlingException)
        if let kMSThrottlingException = kMSThrottlingExceptionDecoded {
            self = .kMSThrottlingException(kMSThrottlingException)
            return
        }
        let internalFailureExceptionDecoded = try values.decodeIfPresent(InternalFailureException.self, forKey: .internalFailureException)
        if let internalFailureException = internalFailureExceptionDecoded {
            self = .internalFailureException(internalFailureException)
            return
        }
        self = .sdkUnknown("")
    }
}
