// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AddTagsToStreamInputBodyMiddleware: Middleware {
    public let id: String = "AddTagsToStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToStreamInput>
    public typealias MOutput = OperationOutput<AddTagsToStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToStreamOutputError>
}

extension AddTagsToStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsToStreamInput(streamName: \(String(describing: streamName)), tags: \(String(describing: tags)))"}
}

extension AddTagsToStreamInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct AddTagsToStreamInputHeadersMiddleware: Middleware {
    public let id: String = "AddTagsToStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToStreamInput>
    public typealias MOutput = OperationOutput<AddTagsToStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToStreamOutputError>
}

public struct AddTagsToStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "AddTagsToStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToStreamInput>
    public typealias MOutput = OperationOutput<AddTagsToStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToStreamOutputError>
}

/// <p>Represents the input for <code>AddTagsToStream</code>.</p>
public struct AddTagsToStreamInput: Equatable {
    /// <p>The name of the stream.</p>
    public let streamName: String?
    /// <p>A set of up to 10 key-value pairs to use to create the tags.</p>
    public let tags: [String:String]?

    public init (
        streamName: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.streamName = streamName
        self.tags = tags
    }
}

struct AddTagsToStreamInputBody: Equatable {
    public let streamName: String?
    public let tags: [String:String]?
}

extension AddTagsToStreamInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AddTagsToStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddTagsToStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsToStreamOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsToStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsToStreamOutputResponse()"}
}

extension AddTagsToStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AddTagsToStreamOutputResponse: Equatable {

    public init() {}
}

struct AddTagsToStreamOutputResponseBody: Equatable {
}

extension AddTagsToStreamOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ChildShard: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hashKeyRange = "HashKeyRange"
        case parentShards = "ParentShards"
        case shardId = "ShardId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hashKeyRange = hashKeyRange {
            try encodeContainer.encode(hashKeyRange, forKey: .hashKeyRange)
        }
        if let parentShards = parentShards {
            var parentShardsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parentShards)
            for shardidlist0 in parentShards {
                try parentShardsContainer.encode(shardidlist0)
            }
        }
        if let shardId = shardId {
            try encodeContainer.encode(shardId, forKey: .shardId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shardId)
        shardId = shardIdDecoded
        let parentShardsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .parentShards)
        var parentShardsDecoded0:[String]? = nil
        if let parentShardsContainer = parentShardsContainer {
            parentShardsDecoded0 = [String]()
            for string0 in parentShardsContainer {
                if let string0 = string0 {
                    parentShardsDecoded0?.append(string0)
                }
            }
        }
        parentShards = parentShardsDecoded0
        let hashKeyRangeDecoded = try containerValues.decodeIfPresent(HashKeyRange.self, forKey: .hashKeyRange)
        hashKeyRange = hashKeyRangeDecoded
    }
}

extension ChildShard: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChildShard(hashKeyRange: \(String(describing: hashKeyRange)), parentShards: \(String(describing: parentShards)), shardId: \(String(describing: shardId)))"}
}

public struct ChildShard: Equatable {
    /// <p>The range of possible hash key values for the shard, which is a set of ordered
    ///             contiguous positive integers.</p>
    public let hashKeyRange: HashKeyRange?
    public let parentShards: [String]?
    public let shardId: String?

    public init (
        hashKeyRange: HashKeyRange? = nil,
        parentShards: [String]? = nil,
        shardId: String? = nil
    )
    {
        self.hashKeyRange = hashKeyRange
        self.parentShards = parentShards
        self.shardId = shardId
    }
}

extension Consumer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case consumerARN = "ConsumerARN"
        case consumerCreationTimestamp = "ConsumerCreationTimestamp"
        case consumerName = "ConsumerName"
        case consumerStatus = "ConsumerStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumerARN = consumerARN {
            try encodeContainer.encode(consumerARN, forKey: .consumerARN)
        }
        if let consumerCreationTimestamp = consumerCreationTimestamp {
            try encodeContainer.encode(consumerCreationTimestamp.timeIntervalSince1970, forKey: .consumerCreationTimestamp)
        }
        if let consumerName = consumerName {
            try encodeContainer.encode(consumerName, forKey: .consumerName)
        }
        if let consumerStatus = consumerStatus {
            try encodeContainer.encode(consumerStatus.rawValue, forKey: .consumerStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consumerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .consumerName)
        consumerName = consumerNameDecoded
        let consumerARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .consumerARN)
        consumerARN = consumerARNDecoded
        let consumerStatusDecoded = try containerValues.decodeIfPresent(ConsumerStatus.self, forKey: .consumerStatus)
        consumerStatus = consumerStatusDecoded
        let consumerCreationTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .consumerCreationTimestamp)
        consumerCreationTimestamp = consumerCreationTimestampDecoded
    }
}

extension Consumer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Consumer(consumerARN: \(String(describing: consumerARN)), consumerCreationTimestamp: \(String(describing: consumerCreationTimestamp)), consumerName: \(String(describing: consumerName)), consumerStatus: \(String(describing: consumerStatus)))"}
}

/// <p>An object that represents the details of the consumer you registered. This type of
///             object is returned by <a>RegisterStreamConsumer</a>.</p>
public struct Consumer: Equatable {
    /// <p>When you register a consumer, Kinesis Data Streams generates an ARN for it. You need
    ///             this ARN to be able to call <a>SubscribeToShard</a>.</p>
    ///         <p>If you delete a consumer and then create a new one with the same name, it won't have
    ///             the same ARN. That's because consumer ARNs contain the creation timestamp. This is
    ///             important to keep in mind if you have IAM policies that reference consumer ARNs.</p>
    public let consumerARN: String?
    /// <p></p>
    public let consumerCreationTimestamp: Date?
    /// <p>The name of the consumer is something you choose when you register the
    ///             consumer.</p>
    public let consumerName: String?
    /// <p>A consumer can't read data while in the <code>CREATING</code> or <code>DELETING</code>
    ///             states.</p>
    public let consumerStatus: ConsumerStatus?

    public init (
        consumerARN: String? = nil,
        consumerCreationTimestamp: Date? = nil,
        consumerName: String? = nil,
        consumerStatus: ConsumerStatus? = nil
    )
    {
        self.consumerARN = consumerARN
        self.consumerCreationTimestamp = consumerCreationTimestamp
        self.consumerName = consumerName
        self.consumerStatus = consumerStatus
    }
}

extension ConsumerDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case consumerARN = "ConsumerARN"
        case consumerCreationTimestamp = "ConsumerCreationTimestamp"
        case consumerName = "ConsumerName"
        case consumerStatus = "ConsumerStatus"
        case streamARN = "StreamARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumerARN = consumerARN {
            try encodeContainer.encode(consumerARN, forKey: .consumerARN)
        }
        if let consumerCreationTimestamp = consumerCreationTimestamp {
            try encodeContainer.encode(consumerCreationTimestamp.timeIntervalSince1970, forKey: .consumerCreationTimestamp)
        }
        if let consumerName = consumerName {
            try encodeContainer.encode(consumerName, forKey: .consumerName)
        }
        if let consumerStatus = consumerStatus {
            try encodeContainer.encode(consumerStatus.rawValue, forKey: .consumerStatus)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consumerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .consumerName)
        consumerName = consumerNameDecoded
        let consumerARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .consumerARN)
        consumerARN = consumerARNDecoded
        let consumerStatusDecoded = try containerValues.decodeIfPresent(ConsumerStatus.self, forKey: .consumerStatus)
        consumerStatus = consumerStatusDecoded
        let consumerCreationTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .consumerCreationTimestamp)
        consumerCreationTimestamp = consumerCreationTimestampDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
    }
}

extension ConsumerDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConsumerDescription(consumerARN: \(String(describing: consumerARN)), consumerCreationTimestamp: \(String(describing: consumerCreationTimestamp)), consumerName: \(String(describing: consumerName)), consumerStatus: \(String(describing: consumerStatus)), streamARN: \(String(describing: streamARN)))"}
}

/// <p>An object that represents the details of a registered consumer. This type of object is
///             returned by <a>DescribeStreamConsumer</a>.</p>
public struct ConsumerDescription: Equatable {
    /// <p>When you register a consumer, Kinesis Data Streams generates an ARN for it. You need
    ///             this ARN to be able to call <a>SubscribeToShard</a>.</p>
    ///         <p>If you delete a consumer and then create a new one with the same name, it won't have
    ///             the same ARN. That's because consumer ARNs contain the creation timestamp. This is
    ///             important to keep in mind if you have IAM policies that reference consumer ARNs.</p>
    public let consumerARN: String?
    /// <p></p>
    public let consumerCreationTimestamp: Date?
    /// <p>The name of the consumer is something you choose when you register the
    ///             consumer.</p>
    public let consumerName: String?
    /// <p>A consumer can't read data while in the <code>CREATING</code> or <code>DELETING</code>
    ///             states.</p>
    public let consumerStatus: ConsumerStatus?
    /// <p>The ARN of the stream with which you registered the consumer.</p>
    public let streamARN: String?

    public init (
        consumerARN: String? = nil,
        consumerCreationTimestamp: Date? = nil,
        consumerName: String? = nil,
        consumerStatus: ConsumerStatus? = nil,
        streamARN: String? = nil
    )
    {
        self.consumerARN = consumerARN
        self.consumerCreationTimestamp = consumerCreationTimestamp
        self.consumerName = consumerName
        self.consumerStatus = consumerStatus
        self.streamARN = streamARN
    }
}

public enum ConsumerStatus {
    case active
    case creating
    case deleting
    case sdkUnknown(String)
}

extension ConsumerStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConsumerStatus] {
        return [
            .active,
            .creating,
            .deleting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConsumerStatus(rawValue: rawValue) ?? ConsumerStatus.sdkUnknown(rawValue)
    }
}

public struct CreateStreamInputBodyMiddleware: Middleware {
    public let id: String = "CreateStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamInput>
    public typealias MOutput = OperationOutput<CreateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamOutputError>
}

extension CreateStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStreamInput(shardCount: \(String(describing: shardCount)), streamName: \(String(describing: streamName)))"}
}

extension CreateStreamInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case shardCount = "ShardCount"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shardCount = shardCount {
            try encodeContainer.encode(shardCount, forKey: .shardCount)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct CreateStreamInputHeadersMiddleware: Middleware {
    public let id: String = "CreateStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamInput>
    public typealias MOutput = OperationOutput<CreateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamOutputError>
}

public struct CreateStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamInput>
    public typealias MOutput = OperationOutput<CreateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamOutputError>
}

/// <p>Represents the input for <code>CreateStream</code>.</p>
public struct CreateStreamInput: Equatable {
    /// <p>The number of shards that the stream will use. The throughput of the stream is a
    ///             function of the number of shards; more shards are required for greater provisioned
    ///             throughput.</p>
    public let shardCount: Int?
    /// <p>A name to identify the stream. The stream name is scoped to the AWS account used by
    ///             the application that creates the stream. It is also scoped by AWS Region. That is, two
    ///             streams in two different AWS accounts can have the same name. Two streams in the same
    ///             AWS account but in two different Regions can also have the same name.</p>
    public let streamName: String?

    public init (
        shardCount: Int? = nil,
        streamName: String? = nil
    )
    {
        self.shardCount = shardCount
        self.streamName = streamName
    }
}

struct CreateStreamInputBody: Equatable {
    public let streamName: String?
    public let shardCount: Int?
}

extension CreateStreamInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case shardCount = "ShardCount"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let shardCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .shardCount)
        shardCount = shardCountDecoded
    }
}

extension CreateStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStreamOutputResponse()"}
}

extension CreateStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateStreamOutputResponse: Equatable {

    public init() {}
}

struct CreateStreamOutputResponseBody: Equatable {
}

extension CreateStreamOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DecreaseStreamRetentionPeriodInputBodyMiddleware: Middleware {
    public let id: String = "DecreaseStreamRetentionPeriodInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DecreaseStreamRetentionPeriodInput>,
                  next: H) -> Swift.Result<OperationOutput<DecreaseStreamRetentionPeriodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DecreaseStreamRetentionPeriodInput>
    public typealias MOutput = OperationOutput<DecreaseStreamRetentionPeriodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DecreaseStreamRetentionPeriodOutputError>
}

extension DecreaseStreamRetentionPeriodInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DecreaseStreamRetentionPeriodInput(retentionPeriodHours: \(String(describing: retentionPeriodHours)), streamName: \(String(describing: streamName)))"}
}

extension DecreaseStreamRetentionPeriodInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case retentionPeriodHours = "RetentionPeriodHours"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionPeriodHours = retentionPeriodHours {
            try encodeContainer.encode(retentionPeriodHours, forKey: .retentionPeriodHours)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct DecreaseStreamRetentionPeriodInputHeadersMiddleware: Middleware {
    public let id: String = "DecreaseStreamRetentionPeriodInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DecreaseStreamRetentionPeriodInput>,
                  next: H) -> Swift.Result<OperationOutput<DecreaseStreamRetentionPeriodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DecreaseStreamRetentionPeriodInput>
    public typealias MOutput = OperationOutput<DecreaseStreamRetentionPeriodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DecreaseStreamRetentionPeriodOutputError>
}

public struct DecreaseStreamRetentionPeriodInputQueryItemMiddleware: Middleware {
    public let id: String = "DecreaseStreamRetentionPeriodInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DecreaseStreamRetentionPeriodInput>,
                  next: H) -> Swift.Result<OperationOutput<DecreaseStreamRetentionPeriodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DecreaseStreamRetentionPeriodInput>
    public typealias MOutput = OperationOutput<DecreaseStreamRetentionPeriodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DecreaseStreamRetentionPeriodOutputError>
}

/// <p>Represents the input for <a>DecreaseStreamRetentionPeriod</a>.</p>
public struct DecreaseStreamRetentionPeriodInput: Equatable {
    /// <p>The new retention period of the stream, in hours. Must be less than the current
    ///             retention period.</p>
    public let retentionPeriodHours: Int?
    /// <p>The name of the stream to modify.</p>
    public let streamName: String?

    public init (
        retentionPeriodHours: Int? = nil,
        streamName: String? = nil
    )
    {
        self.retentionPeriodHours = retentionPeriodHours
        self.streamName = streamName
    }
}

struct DecreaseStreamRetentionPeriodInputBody: Equatable {
    public let streamName: String?
    public let retentionPeriodHours: Int?
}

extension DecreaseStreamRetentionPeriodInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case retentionPeriodHours = "RetentionPeriodHours"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let retentionPeriodHoursDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .retentionPeriodHours)
        retentionPeriodHours = retentionPeriodHoursDecoded
    }
}

extension DecreaseStreamRetentionPeriodOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DecreaseStreamRetentionPeriodOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DecreaseStreamRetentionPeriodOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DecreaseStreamRetentionPeriodOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DecreaseStreamRetentionPeriodOutputResponse()"}
}

extension DecreaseStreamRetentionPeriodOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DecreaseStreamRetentionPeriodOutputResponse: Equatable {

    public init() {}
}

struct DecreaseStreamRetentionPeriodOutputResponseBody: Equatable {
}

extension DecreaseStreamRetentionPeriodOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteStreamInputBodyMiddleware: Middleware {
    public let id: String = "DeleteStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStreamInput>
    public typealias MOutput = OperationOutput<DeleteStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStreamOutputError>
}

extension DeleteStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStreamInput(enforceConsumerDeletion: \(String(describing: enforceConsumerDeletion)), streamName: \(String(describing: streamName)))"}
}

extension DeleteStreamInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enforceConsumerDeletion = "EnforceConsumerDeletion"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enforceConsumerDeletion = enforceConsumerDeletion {
            try encodeContainer.encode(enforceConsumerDeletion, forKey: .enforceConsumerDeletion)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct DeleteStreamInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStreamInput>
    public typealias MOutput = OperationOutput<DeleteStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStreamOutputError>
}

public struct DeleteStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStreamInput>
    public typealias MOutput = OperationOutput<DeleteStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStreamOutputError>
}

/// <p>Represents the input for <a>DeleteStream</a>.</p>
public struct DeleteStreamInput: Equatable {
    /// <p>If this parameter is unset (<code>null</code>) or if you set it to <code>false</code>,
    ///             and the stream has registered consumers, the call to <code>DeleteStream</code> fails
    ///             with a <code>ResourceInUseException</code>. </p>
    public let enforceConsumerDeletion: Bool?
    /// <p>The name of the stream to delete.</p>
    public let streamName: String?

    public init (
        enforceConsumerDeletion: Bool? = nil,
        streamName: String? = nil
    )
    {
        self.enforceConsumerDeletion = enforceConsumerDeletion
        self.streamName = streamName
    }
}

struct DeleteStreamInputBody: Equatable {
    public let streamName: String?
    public let enforceConsumerDeletion: Bool?
}

extension DeleteStreamInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case enforceConsumerDeletion = "EnforceConsumerDeletion"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let enforceConsumerDeletionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enforceConsumerDeletion)
        enforceConsumerDeletion = enforceConsumerDeletionDecoded
    }
}

extension DeleteStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStreamOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStreamOutputResponse()"}
}

extension DeleteStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStreamOutputResponse: Equatable {

    public init() {}
}

struct DeleteStreamOutputResponseBody: Equatable {
}

extension DeleteStreamOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeregisterStreamConsumerInputBodyMiddleware: Middleware {
    public let id: String = "DeregisterStreamConsumerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterStreamConsumerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterStreamConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterStreamConsumerInput>
    public typealias MOutput = OperationOutput<DeregisterStreamConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterStreamConsumerOutputError>
}

extension DeregisterStreamConsumerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterStreamConsumerInput(consumerARN: \(String(describing: consumerARN)), consumerName: \(String(describing: consumerName)), streamARN: \(String(describing: streamARN)))"}
}

extension DeregisterStreamConsumerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case consumerARN = "ConsumerARN"
        case consumerName = "ConsumerName"
        case streamARN = "StreamARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumerARN = consumerARN {
            try encodeContainer.encode(consumerARN, forKey: .consumerARN)
        }
        if let consumerName = consumerName {
            try encodeContainer.encode(consumerName, forKey: .consumerName)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
    }
}

public struct DeregisterStreamConsumerInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterStreamConsumerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterStreamConsumerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterStreamConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterStreamConsumerInput>
    public typealias MOutput = OperationOutput<DeregisterStreamConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterStreamConsumerOutputError>
}

public struct DeregisterStreamConsumerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterStreamConsumerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterStreamConsumerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterStreamConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterStreamConsumerInput>
    public typealias MOutput = OperationOutput<DeregisterStreamConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterStreamConsumerOutputError>
}

public struct DeregisterStreamConsumerInput: Equatable {
    /// <p>The ARN returned by Kinesis Data Streams when you registered the consumer. If you
    ///             don't know the ARN of the consumer that you want to deregister, you can use the
    ///             ListStreamConsumers operation to get a list of the descriptions of all the consumers
    ///             that are currently registered with a given data stream. The description of a consumer
    ///             contains its ARN.</p>
    public let consumerARN: String?
    /// <p>The name that you gave to the consumer.</p>
    public let consumerName: String?
    /// <p>The ARN of the Kinesis data stream that the consumer is registered with. For more
    ///             information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
    public let streamARN: String?

    public init (
        consumerARN: String? = nil,
        consumerName: String? = nil,
        streamARN: String? = nil
    )
    {
        self.consumerARN = consumerARN
        self.consumerName = consumerName
        self.streamARN = streamARN
    }
}

struct DeregisterStreamConsumerInputBody: Equatable {
    public let streamARN: String?
    public let consumerName: String?
    public let consumerARN: String?
}

extension DeregisterStreamConsumerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case consumerARN = "ConsumerARN"
        case consumerName = "ConsumerName"
        case streamARN = "StreamARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let consumerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .consumerName)
        consumerName = consumerNameDecoded
        let consumerARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .consumerARN)
        consumerARN = consumerARNDecoded
    }
}

extension DeregisterStreamConsumerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterStreamConsumerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterStreamConsumerOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterStreamConsumerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterStreamConsumerOutputResponse()"}
}

extension DeregisterStreamConsumerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterStreamConsumerOutputResponse: Equatable {

    public init() {}
}

struct DeregisterStreamConsumerOutputResponseBody: Equatable {
}

extension DeregisterStreamConsumerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeLimitsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLimitsInput()"}
}

extension DescribeLimitsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeLimitsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLimitsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLimitsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLimitsInput>
    public typealias MOutput = OperationOutput<DescribeLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLimitsOutputError>
}

public struct DescribeLimitsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLimitsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLimitsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLimitsInput>
    public typealias MOutput = OperationOutput<DescribeLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLimitsOutputError>
}

public struct DescribeLimitsInput: Equatable {

    public init() {}
}

struct DescribeLimitsInputBody: Equatable {
}

extension DescribeLimitsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeLimitsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLimitsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLimitsOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLimitsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLimitsOutputResponse(openShardCount: \(String(describing: openShardCount)), shardLimit: \(String(describing: shardLimit)))"}
}

extension DescribeLimitsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeLimitsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.openShardCount = output.openShardCount
            self.shardLimit = output.shardLimit
        } else {
            self.openShardCount = nil
            self.shardLimit = nil
        }
    }
}

public struct DescribeLimitsOutputResponse: Equatable {
    /// <p>The number of open shards.</p>
    public let openShardCount: Int?
    /// <p>The maximum number of shards.</p>
    public let shardLimit: Int?

    public init (
        openShardCount: Int? = nil,
        shardLimit: Int? = nil
    )
    {
        self.openShardCount = openShardCount
        self.shardLimit = shardLimit
    }
}

struct DescribeLimitsOutputResponseBody: Equatable {
    public let shardLimit: Int?
    public let openShardCount: Int?
}

extension DescribeLimitsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case openShardCount = "OpenShardCount"
        case shardLimit = "ShardLimit"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shardLimitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .shardLimit)
        shardLimit = shardLimitDecoded
        let openShardCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .openShardCount)
        openShardCount = openShardCountDecoded
    }
}

public struct DescribeStreamConsumerInputBodyMiddleware: Middleware {
    public let id: String = "DescribeStreamConsumerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStreamConsumerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStreamConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStreamConsumerInput>
    public typealias MOutput = OperationOutput<DescribeStreamConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStreamConsumerOutputError>
}

extension DescribeStreamConsumerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStreamConsumerInput(consumerARN: \(String(describing: consumerARN)), consumerName: \(String(describing: consumerName)), streamARN: \(String(describing: streamARN)))"}
}

extension DescribeStreamConsumerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case consumerARN = "ConsumerARN"
        case consumerName = "ConsumerName"
        case streamARN = "StreamARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumerARN = consumerARN {
            try encodeContainer.encode(consumerARN, forKey: .consumerARN)
        }
        if let consumerName = consumerName {
            try encodeContainer.encode(consumerName, forKey: .consumerName)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
    }
}

public struct DescribeStreamConsumerInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStreamConsumerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStreamConsumerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStreamConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStreamConsumerInput>
    public typealias MOutput = OperationOutput<DescribeStreamConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStreamConsumerOutputError>
}

public struct DescribeStreamConsumerInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStreamConsumerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStreamConsumerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStreamConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStreamConsumerInput>
    public typealias MOutput = OperationOutput<DescribeStreamConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStreamConsumerOutputError>
}

public struct DescribeStreamConsumerInput: Equatable {
    /// <p>The ARN returned by Kinesis Data Streams when you registered the consumer.</p>
    public let consumerARN: String?
    /// <p>The name that you gave to the consumer.</p>
    public let consumerName: String?
    /// <p>The ARN of the Kinesis data stream that the consumer is registered with. For more
    ///             information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
    public let streamARN: String?

    public init (
        consumerARN: String? = nil,
        consumerName: String? = nil,
        streamARN: String? = nil
    )
    {
        self.consumerARN = consumerARN
        self.consumerName = consumerName
        self.streamARN = streamARN
    }
}

struct DescribeStreamConsumerInputBody: Equatable {
    public let streamARN: String?
    public let consumerName: String?
    public let consumerARN: String?
}

extension DescribeStreamConsumerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case consumerARN = "ConsumerARN"
        case consumerName = "ConsumerName"
        case streamARN = "StreamARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let consumerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .consumerName)
        consumerName = consumerNameDecoded
        let consumerARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .consumerARN)
        consumerARN = consumerARNDecoded
    }
}

extension DescribeStreamConsumerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStreamConsumerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStreamConsumerOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStreamConsumerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStreamConsumerOutputResponse(consumerDescription: \(String(describing: consumerDescription)))"}
}

extension DescribeStreamConsumerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStreamConsumerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.consumerDescription = output.consumerDescription
        } else {
            self.consumerDescription = nil
        }
    }
}

public struct DescribeStreamConsumerOutputResponse: Equatable {
    /// <p>An object that represents the details of the consumer.</p>
    public let consumerDescription: ConsumerDescription?

    public init (
        consumerDescription: ConsumerDescription? = nil
    )
    {
        self.consumerDescription = consumerDescription
    }
}

struct DescribeStreamConsumerOutputResponseBody: Equatable {
    public let consumerDescription: ConsumerDescription?
}

extension DescribeStreamConsumerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case consumerDescription = "ConsumerDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consumerDescriptionDecoded = try containerValues.decodeIfPresent(ConsumerDescription.self, forKey: .consumerDescription)
        consumerDescription = consumerDescriptionDecoded
    }
}

public struct DescribeStreamInputBodyMiddleware: Middleware {
    public let id: String = "DescribeStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStreamInput>
    public typealias MOutput = OperationOutput<DescribeStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStreamOutputError>
}

extension DescribeStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStreamInput(exclusiveStartShardId: \(String(describing: exclusiveStartShardId)), limit: \(String(describing: limit)), streamName: \(String(describing: streamName)))"}
}

extension DescribeStreamInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exclusiveStartShardId = "ExclusiveStartShardId"
        case limit = "Limit"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusiveStartShardId = exclusiveStartShardId {
            try encodeContainer.encode(exclusiveStartShardId, forKey: .exclusiveStartShardId)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct DescribeStreamInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStreamInput>
    public typealias MOutput = OperationOutput<DescribeStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStreamOutputError>
}

public struct DescribeStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStreamInput>
    public typealias MOutput = OperationOutput<DescribeStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStreamOutputError>
}

/// <p>Represents the input for <code>DescribeStream</code>.</p>
public struct DescribeStreamInput: Equatable {
    /// <p>The shard ID of the shard to start with.</p>
    public let exclusiveStartShardId: String?
    /// <p>The maximum number of shards to return in a single call. The default value is 100.
    ///             If you specify a value greater than 100, at most 100 shards are returned.</p>
    public let limit: Int?
    /// <p>The name of the stream to describe.</p>
    public let streamName: String?

    public init (
        exclusiveStartShardId: String? = nil,
        limit: Int? = nil,
        streamName: String? = nil
    )
    {
        self.exclusiveStartShardId = exclusiveStartShardId
        self.limit = limit
        self.streamName = streamName
    }
}

struct DescribeStreamInputBody: Equatable {
    public let streamName: String?
    public let limit: Int?
    public let exclusiveStartShardId: String?
}

extension DescribeStreamInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exclusiveStartShardId = "ExclusiveStartShardId"
        case limit = "Limit"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let exclusiveStartShardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exclusiveStartShardId)
        exclusiveStartShardId = exclusiveStartShardIdDecoded
    }
}

extension DescribeStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStreamOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStreamOutputResponse(streamDescription: \(String(describing: streamDescription)))"}
}

extension DescribeStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStreamOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.streamDescription = output.streamDescription
        } else {
            self.streamDescription = nil
        }
    }
}

/// <p>Represents the output for <code>DescribeStream</code>.</p>
public struct DescribeStreamOutputResponse: Equatable {
    /// <p>The current status of the stream, the stream Amazon Resource Name (ARN), an array
    ///             of shard objects that comprise the stream, and whether there are more shards
    ///             available.</p>
    public let streamDescription: StreamDescription?

    public init (
        streamDescription: StreamDescription? = nil
    )
    {
        self.streamDescription = streamDescription
    }
}

struct DescribeStreamOutputResponseBody: Equatable {
    public let streamDescription: StreamDescription?
}

extension DescribeStreamOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamDescription = "StreamDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamDescriptionDecoded = try containerValues.decodeIfPresent(StreamDescription.self, forKey: .streamDescription)
        streamDescription = streamDescriptionDecoded
    }
}

public struct DescribeStreamSummaryInputBodyMiddleware: Middleware {
    public let id: String = "DescribeStreamSummaryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStreamSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStreamSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStreamSummaryInput>
    public typealias MOutput = OperationOutput<DescribeStreamSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStreamSummaryOutputError>
}

extension DescribeStreamSummaryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStreamSummaryInput(streamName: \(String(describing: streamName)))"}
}

extension DescribeStreamSummaryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct DescribeStreamSummaryInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStreamSummaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStreamSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStreamSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStreamSummaryInput>
    public typealias MOutput = OperationOutput<DescribeStreamSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStreamSummaryOutputError>
}

public struct DescribeStreamSummaryInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStreamSummaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStreamSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStreamSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStreamSummaryInput>
    public typealias MOutput = OperationOutput<DescribeStreamSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStreamSummaryOutputError>
}

public struct DescribeStreamSummaryInput: Equatable {
    /// <p>The name of the stream to describe.</p>
    public let streamName: String?

    public init (
        streamName: String? = nil
    )
    {
        self.streamName = streamName
    }
}

struct DescribeStreamSummaryInputBody: Equatable {
    public let streamName: String?
}

extension DescribeStreamSummaryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
    }
}

extension DescribeStreamSummaryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStreamSummaryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStreamSummaryOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStreamSummaryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStreamSummaryOutputResponse(streamDescriptionSummary: \(String(describing: streamDescriptionSummary)))"}
}

extension DescribeStreamSummaryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStreamSummaryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.streamDescriptionSummary = output.streamDescriptionSummary
        } else {
            self.streamDescriptionSummary = nil
        }
    }
}

public struct DescribeStreamSummaryOutputResponse: Equatable {
    /// <p>A <a>StreamDescriptionSummary</a> containing information about the
    ///             stream.</p>
    public let streamDescriptionSummary: StreamDescriptionSummary?

    public init (
        streamDescriptionSummary: StreamDescriptionSummary? = nil
    )
    {
        self.streamDescriptionSummary = streamDescriptionSummary
    }
}

struct DescribeStreamSummaryOutputResponseBody: Equatable {
    public let streamDescriptionSummary: StreamDescriptionSummary?
}

extension DescribeStreamSummaryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamDescriptionSummary = "StreamDescriptionSummary"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamDescriptionSummaryDecoded = try containerValues.decodeIfPresent(StreamDescriptionSummary.self, forKey: .streamDescriptionSummary)
        streamDescriptionSummary = streamDescriptionSummaryDecoded
    }
}

public struct DisableEnhancedMonitoringInputBodyMiddleware: Middleware {
    public let id: String = "DisableEnhancedMonitoringInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableEnhancedMonitoringInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableEnhancedMonitoringOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableEnhancedMonitoringInput>
    public typealias MOutput = OperationOutput<DisableEnhancedMonitoringOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableEnhancedMonitoringOutputError>
}

extension DisableEnhancedMonitoringInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableEnhancedMonitoringInput(shardLevelMetrics: \(String(describing: shardLevelMetrics)), streamName: \(String(describing: streamName)))"}
}

extension DisableEnhancedMonitoringInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case shardLevelMetrics = "ShardLevelMetrics"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shardLevelMetrics = shardLevelMetrics {
            var shardLevelMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .shardLevelMetrics)
            for metricsnamelist0 in shardLevelMetrics {
                try shardLevelMetricsContainer.encode(metricsnamelist0.rawValue)
            }
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct DisableEnhancedMonitoringInputHeadersMiddleware: Middleware {
    public let id: String = "DisableEnhancedMonitoringInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableEnhancedMonitoringInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableEnhancedMonitoringOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableEnhancedMonitoringInput>
    public typealias MOutput = OperationOutput<DisableEnhancedMonitoringOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableEnhancedMonitoringOutputError>
}

public struct DisableEnhancedMonitoringInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableEnhancedMonitoringInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableEnhancedMonitoringInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableEnhancedMonitoringOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableEnhancedMonitoringInput>
    public typealias MOutput = OperationOutput<DisableEnhancedMonitoringOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableEnhancedMonitoringOutputError>
}

/// <p>Represents the input for <a>DisableEnhancedMonitoring</a>.</p>
public struct DisableEnhancedMonitoringInput: Equatable {
    /// <p>List of shard-level metrics to disable.</p>
    ///         <p>The following are the valid shard-level metrics. The value "<code>ALL</code>"
    ///             disables every metric.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>IncomingBytes</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>IncomingRecords</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>OutgoingBytes</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>OutgoingRecords</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>WriteProvisionedThroughputExceeded</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>ReadProvisionedThroughputExceeded</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>IteratorAgeMilliseconds</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>ALL</code>
    ///                 </p>
    ///             </li>
    ///          </ul>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/monitoring-with-cloudwatch.html">Monitoring the Amazon
    ///                 Kinesis Data Streams Service with Amazon CloudWatch</a> in the <i>Amazon
    ///                 Kinesis Data Streams Developer Guide</i>.</p>
    public let shardLevelMetrics: [MetricsName]?
    /// <p>The name of the Kinesis data stream for which to disable enhanced
    ///             monitoring.</p>
    public let streamName: String?

    public init (
        shardLevelMetrics: [MetricsName]? = nil,
        streamName: String? = nil
    )
    {
        self.shardLevelMetrics = shardLevelMetrics
        self.streamName = streamName
    }
}

struct DisableEnhancedMonitoringInputBody: Equatable {
    public let streamName: String?
    public let shardLevelMetrics: [MetricsName]?
}

extension DisableEnhancedMonitoringInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case shardLevelMetrics = "ShardLevelMetrics"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let shardLevelMetricsContainer = try containerValues.decodeIfPresent([MetricsName?].self, forKey: .shardLevelMetrics)
        var shardLevelMetricsDecoded0:[MetricsName]? = nil
        if let shardLevelMetricsContainer = shardLevelMetricsContainer {
            shardLevelMetricsDecoded0 = [MetricsName]()
            for string0 in shardLevelMetricsContainer {
                if let string0 = string0 {
                    shardLevelMetricsDecoded0?.append(string0)
                }
            }
        }
        shardLevelMetrics = shardLevelMetricsDecoded0
    }
}

extension DisableEnhancedMonitoringOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableEnhancedMonitoringOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableEnhancedMonitoringOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableEnhancedMonitoringOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableEnhancedMonitoringOutputResponse(currentShardLevelMetrics: \(String(describing: currentShardLevelMetrics)), desiredShardLevelMetrics: \(String(describing: desiredShardLevelMetrics)), streamName: \(String(describing: streamName)))"}
}

extension DisableEnhancedMonitoringOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisableEnhancedMonitoringOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.currentShardLevelMetrics = output.currentShardLevelMetrics
            self.desiredShardLevelMetrics = output.desiredShardLevelMetrics
            self.streamName = output.streamName
        } else {
            self.currentShardLevelMetrics = nil
            self.desiredShardLevelMetrics = nil
            self.streamName = nil
        }
    }
}

/// <p>Represents the output for <a>EnableEnhancedMonitoring</a> and <a>DisableEnhancedMonitoring</a>.</p>
public struct DisableEnhancedMonitoringOutputResponse: Equatable {
    /// <p>Represents the current state of the metrics that are in the enhanced state before
    ///             the operation.</p>
    public let currentShardLevelMetrics: [MetricsName]?
    /// <p>Represents the list of all the metrics that would be in the enhanced state after
    ///             the operation.</p>
    public let desiredShardLevelMetrics: [MetricsName]?
    /// <p>The name of the Kinesis data stream.</p>
    public let streamName: String?

    public init (
        currentShardLevelMetrics: [MetricsName]? = nil,
        desiredShardLevelMetrics: [MetricsName]? = nil,
        streamName: String? = nil
    )
    {
        self.currentShardLevelMetrics = currentShardLevelMetrics
        self.desiredShardLevelMetrics = desiredShardLevelMetrics
        self.streamName = streamName
    }
}

struct DisableEnhancedMonitoringOutputResponseBody: Equatable {
    public let streamName: String?
    public let currentShardLevelMetrics: [MetricsName]?
    public let desiredShardLevelMetrics: [MetricsName]?
}

extension DisableEnhancedMonitoringOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case currentShardLevelMetrics = "CurrentShardLevelMetrics"
        case desiredShardLevelMetrics = "DesiredShardLevelMetrics"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let currentShardLevelMetricsContainer = try containerValues.decodeIfPresent([MetricsName?].self, forKey: .currentShardLevelMetrics)
        var currentShardLevelMetricsDecoded0:[MetricsName]? = nil
        if let currentShardLevelMetricsContainer = currentShardLevelMetricsContainer {
            currentShardLevelMetricsDecoded0 = [MetricsName]()
            for string0 in currentShardLevelMetricsContainer {
                if let string0 = string0 {
                    currentShardLevelMetricsDecoded0?.append(string0)
                }
            }
        }
        currentShardLevelMetrics = currentShardLevelMetricsDecoded0
        let desiredShardLevelMetricsContainer = try containerValues.decodeIfPresent([MetricsName?].self, forKey: .desiredShardLevelMetrics)
        var desiredShardLevelMetricsDecoded0:[MetricsName]? = nil
        if let desiredShardLevelMetricsContainer = desiredShardLevelMetricsContainer {
            desiredShardLevelMetricsDecoded0 = [MetricsName]()
            for string0 in desiredShardLevelMetricsContainer {
                if let string0 = string0 {
                    desiredShardLevelMetricsDecoded0?.append(string0)
                }
            }
        }
        desiredShardLevelMetrics = desiredShardLevelMetricsDecoded0
    }
}

public struct EnableEnhancedMonitoringInputBodyMiddleware: Middleware {
    public let id: String = "EnableEnhancedMonitoringInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableEnhancedMonitoringInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableEnhancedMonitoringOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableEnhancedMonitoringInput>
    public typealias MOutput = OperationOutput<EnableEnhancedMonitoringOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableEnhancedMonitoringOutputError>
}

extension EnableEnhancedMonitoringInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableEnhancedMonitoringInput(shardLevelMetrics: \(String(describing: shardLevelMetrics)), streamName: \(String(describing: streamName)))"}
}

extension EnableEnhancedMonitoringInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case shardLevelMetrics = "ShardLevelMetrics"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shardLevelMetrics = shardLevelMetrics {
            var shardLevelMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .shardLevelMetrics)
            for metricsnamelist0 in shardLevelMetrics {
                try shardLevelMetricsContainer.encode(metricsnamelist0.rawValue)
            }
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct EnableEnhancedMonitoringInputHeadersMiddleware: Middleware {
    public let id: String = "EnableEnhancedMonitoringInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableEnhancedMonitoringInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableEnhancedMonitoringOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableEnhancedMonitoringInput>
    public typealias MOutput = OperationOutput<EnableEnhancedMonitoringOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableEnhancedMonitoringOutputError>
}

public struct EnableEnhancedMonitoringInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableEnhancedMonitoringInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableEnhancedMonitoringInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableEnhancedMonitoringOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableEnhancedMonitoringInput>
    public typealias MOutput = OperationOutput<EnableEnhancedMonitoringOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableEnhancedMonitoringOutputError>
}

/// <p>Represents the input for <a>EnableEnhancedMonitoring</a>.</p>
public struct EnableEnhancedMonitoringInput: Equatable {
    /// <p>List of shard-level metrics to enable.</p>
    ///         <p>The following are the valid shard-level metrics. The value "<code>ALL</code>"
    ///             enables every metric.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>IncomingBytes</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>IncomingRecords</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>OutgoingBytes</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>OutgoingRecords</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>WriteProvisionedThroughputExceeded</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>ReadProvisionedThroughputExceeded</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>IteratorAgeMilliseconds</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>ALL</code>
    ///                 </p>
    ///             </li>
    ///          </ul>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/monitoring-with-cloudwatch.html">Monitoring the Amazon
    ///                 Kinesis Data Streams Service with Amazon CloudWatch</a> in the <i>Amazon
    ///                 Kinesis Data Streams Developer Guide</i>.</p>
    public let shardLevelMetrics: [MetricsName]?
    /// <p>The name of the stream for which to enable enhanced monitoring.</p>
    public let streamName: String?

    public init (
        shardLevelMetrics: [MetricsName]? = nil,
        streamName: String? = nil
    )
    {
        self.shardLevelMetrics = shardLevelMetrics
        self.streamName = streamName
    }
}

struct EnableEnhancedMonitoringInputBody: Equatable {
    public let streamName: String?
    public let shardLevelMetrics: [MetricsName]?
}

extension EnableEnhancedMonitoringInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case shardLevelMetrics = "ShardLevelMetrics"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let shardLevelMetricsContainer = try containerValues.decodeIfPresent([MetricsName?].self, forKey: .shardLevelMetrics)
        var shardLevelMetricsDecoded0:[MetricsName]? = nil
        if let shardLevelMetricsContainer = shardLevelMetricsContainer {
            shardLevelMetricsDecoded0 = [MetricsName]()
            for string0 in shardLevelMetricsContainer {
                if let string0 = string0 {
                    shardLevelMetricsDecoded0?.append(string0)
                }
            }
        }
        shardLevelMetrics = shardLevelMetricsDecoded0
    }
}

extension EnableEnhancedMonitoringOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableEnhancedMonitoringOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableEnhancedMonitoringOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableEnhancedMonitoringOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableEnhancedMonitoringOutputResponse(currentShardLevelMetrics: \(String(describing: currentShardLevelMetrics)), desiredShardLevelMetrics: \(String(describing: desiredShardLevelMetrics)), streamName: \(String(describing: streamName)))"}
}

extension EnableEnhancedMonitoringOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EnableEnhancedMonitoringOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.currentShardLevelMetrics = output.currentShardLevelMetrics
            self.desiredShardLevelMetrics = output.desiredShardLevelMetrics
            self.streamName = output.streamName
        } else {
            self.currentShardLevelMetrics = nil
            self.desiredShardLevelMetrics = nil
            self.streamName = nil
        }
    }
}

/// <p>Represents the output for <a>EnableEnhancedMonitoring</a> and <a>DisableEnhancedMonitoring</a>.</p>
public struct EnableEnhancedMonitoringOutputResponse: Equatable {
    /// <p>Represents the current state of the metrics that are in the enhanced state before
    ///             the operation.</p>
    public let currentShardLevelMetrics: [MetricsName]?
    /// <p>Represents the list of all the metrics that would be in the enhanced state after
    ///             the operation.</p>
    public let desiredShardLevelMetrics: [MetricsName]?
    /// <p>The name of the Kinesis data stream.</p>
    public let streamName: String?

    public init (
        currentShardLevelMetrics: [MetricsName]? = nil,
        desiredShardLevelMetrics: [MetricsName]? = nil,
        streamName: String? = nil
    )
    {
        self.currentShardLevelMetrics = currentShardLevelMetrics
        self.desiredShardLevelMetrics = desiredShardLevelMetrics
        self.streamName = streamName
    }
}

struct EnableEnhancedMonitoringOutputResponseBody: Equatable {
    public let streamName: String?
    public let currentShardLevelMetrics: [MetricsName]?
    public let desiredShardLevelMetrics: [MetricsName]?
}

extension EnableEnhancedMonitoringOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case currentShardLevelMetrics = "CurrentShardLevelMetrics"
        case desiredShardLevelMetrics = "DesiredShardLevelMetrics"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let currentShardLevelMetricsContainer = try containerValues.decodeIfPresent([MetricsName?].self, forKey: .currentShardLevelMetrics)
        var currentShardLevelMetricsDecoded0:[MetricsName]? = nil
        if let currentShardLevelMetricsContainer = currentShardLevelMetricsContainer {
            currentShardLevelMetricsDecoded0 = [MetricsName]()
            for string0 in currentShardLevelMetricsContainer {
                if let string0 = string0 {
                    currentShardLevelMetricsDecoded0?.append(string0)
                }
            }
        }
        currentShardLevelMetrics = currentShardLevelMetricsDecoded0
        let desiredShardLevelMetricsContainer = try containerValues.decodeIfPresent([MetricsName?].self, forKey: .desiredShardLevelMetrics)
        var desiredShardLevelMetricsDecoded0:[MetricsName]? = nil
        if let desiredShardLevelMetricsContainer = desiredShardLevelMetricsContainer {
            desiredShardLevelMetricsDecoded0 = [MetricsName]()
            for string0 in desiredShardLevelMetricsContainer {
                if let string0 = string0 {
                    desiredShardLevelMetricsDecoded0?.append(string0)
                }
            }
        }
        desiredShardLevelMetrics = desiredShardLevelMetricsDecoded0
    }
}

public enum EncryptionType {
    case kms
    case `none`
    case sdkUnknown(String)
}

extension EncryptionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncryptionType] {
        return [
            .kms,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .kms: return "KMS"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
    }
}

extension EnhancedMetrics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case shardLevelMetrics = "ShardLevelMetrics"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shardLevelMetrics = shardLevelMetrics {
            var shardLevelMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .shardLevelMetrics)
            for metricsnamelist0 in shardLevelMetrics {
                try shardLevelMetricsContainer.encode(metricsnamelist0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shardLevelMetricsContainer = try containerValues.decodeIfPresent([MetricsName?].self, forKey: .shardLevelMetrics)
        var shardLevelMetricsDecoded0:[MetricsName]? = nil
        if let shardLevelMetricsContainer = shardLevelMetricsContainer {
            shardLevelMetricsDecoded0 = [MetricsName]()
            for string0 in shardLevelMetricsContainer {
                if let string0 = string0 {
                    shardLevelMetricsDecoded0?.append(string0)
                }
            }
        }
        shardLevelMetrics = shardLevelMetricsDecoded0
    }
}

extension EnhancedMetrics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnhancedMetrics(shardLevelMetrics: \(String(describing: shardLevelMetrics)))"}
}

/// <p>Represents enhanced metrics types.</p>
public struct EnhancedMetrics: Equatable {
    /// <p>List of shard-level metrics.</p>
    ///         <p>The following are the valid shard-level metrics. The value "<code>ALL</code>"
    ///             enhances every metric.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>IncomingBytes</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>IncomingRecords</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>OutgoingBytes</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>OutgoingRecords</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>WriteProvisionedThroughputExceeded</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>ReadProvisionedThroughputExceeded</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>IteratorAgeMilliseconds</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>ALL</code>
    ///                 </p>
    ///             </li>
    ///          </ul>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/monitoring-with-cloudwatch.html">Monitoring the Amazon
    ///                 Kinesis Data Streams Service with Amazon CloudWatch</a> in the <i>Amazon
    ///                 Kinesis Data Streams Developer Guide</i>.</p>
    public let shardLevelMetrics: [MetricsName]?

    public init (
        shardLevelMetrics: [MetricsName]? = nil
    )
    {
        self.shardLevelMetrics = shardLevelMetrics
    }
}

extension ExpiredIteratorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExpiredIteratorException(message: \(String(describing: message)))"}
}

extension ExpiredIteratorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExpiredIteratorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The provided iterator exceeds the maximum age allowed.</p>
public struct ExpiredIteratorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message that provides information about the error.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ExpiredIteratorExceptionBody: Equatable {
    public let message: String?
}

extension ExpiredIteratorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ExpiredNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExpiredNextTokenException(message: \(String(describing: message)))"}
}

extension ExpiredNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExpiredNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pagination token passed to the operation is expired.</p>
public struct ExpiredNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ExpiredNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension ExpiredNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GetRecordsInputBodyMiddleware: Middleware {
    public let id: String = "GetRecordsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecordsInput>
    public typealias MOutput = OperationOutput<GetRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecordsOutputError>
}

extension GetRecordsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRecordsInput(limit: \(String(describing: limit)), shardIterator: \(String(describing: shardIterator)))"}
}

extension GetRecordsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case shardIterator = "ShardIterator"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let shardIterator = shardIterator {
            try encodeContainer.encode(shardIterator, forKey: .shardIterator)
        }
    }
}

public struct GetRecordsInputHeadersMiddleware: Middleware {
    public let id: String = "GetRecordsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecordsInput>
    public typealias MOutput = OperationOutput<GetRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecordsOutputError>
}

public struct GetRecordsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRecordsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecordsInput>
    public typealias MOutput = OperationOutput<GetRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecordsOutputError>
}

/// <p>Represents the input for <a>GetRecords</a>.</p>
public struct GetRecordsInput: Equatable {
    /// <p>The maximum number of records to return. Specify a value of up to 10,000. If you
    ///             specify a value that is greater than 10,000, <a>GetRecords</a> throws
    ///                 <code>InvalidArgumentException</code>. The default value is 10,000.</p>
    public let limit: Int?
    /// <p>The position in the shard from which you want to start sequentially reading data
    ///             records. A shard iterator specifies this position using the sequence number of a data
    ///             record in the shard.</p>
    public let shardIterator: String?

    public init (
        limit: Int? = nil,
        shardIterator: String? = nil
    )
    {
        self.limit = limit
        self.shardIterator = shardIterator
    }
}

struct GetRecordsInputBody: Equatable {
    public let shardIterator: String?
    public let limit: Int?
}

extension GetRecordsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case shardIterator = "ShardIterator"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shardIteratorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shardIterator)
        shardIterator = shardIteratorDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension GetRecordsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecordsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ExpiredIteratorException" : self = .expiredIteratorException(try ExpiredIteratorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSAccessDeniedException" : self = .kMSAccessDeniedException(try KMSAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabledException" : self = .kMSDisabledException(try KMSDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFoundException" : self = .kMSNotFoundException(try KMSNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSOptInRequired" : self = .kMSOptInRequired(try KMSOptInRequired(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSThrottlingException" : self = .kMSThrottlingException(try KMSThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedThroughputExceededException" : self = .provisionedThroughputExceededException(try ProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRecordsOutputError: Equatable {
    case expiredIteratorException(ExpiredIteratorException)
    case invalidArgumentException(InvalidArgumentException)
    case kMSAccessDeniedException(KMSAccessDeniedException)
    case kMSDisabledException(KMSDisabledException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case kMSNotFoundException(KMSNotFoundException)
    case kMSOptInRequired(KMSOptInRequired)
    case kMSThrottlingException(KMSThrottlingException)
    case provisionedThroughputExceededException(ProvisionedThroughputExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecordsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRecordsOutputResponse(childShards: \(String(describing: childShards)), millisBehindLatest: \(String(describing: millisBehindLatest)), nextShardIterator: \(String(describing: nextShardIterator)), records: \(String(describing: records)))"}
}

extension GetRecordsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRecordsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.childShards = output.childShards
            self.millisBehindLatest = output.millisBehindLatest
            self.nextShardIterator = output.nextShardIterator
            self.records = output.records
        } else {
            self.childShards = nil
            self.millisBehindLatest = nil
            self.nextShardIterator = nil
            self.records = nil
        }
    }
}

/// <p>Represents the output for <a>GetRecords</a>.</p>
public struct GetRecordsOutputResponse: Equatable {
    public let childShards: [ChildShard]?
    /// <p>The number of milliseconds the <a>GetRecords</a> response is from the
    ///             tip of the stream, indicating how far behind current time the consumer is. A value of
    ///             zero indicates that record processing is caught up, and there are no new records to
    ///             process at this moment.</p>
    public let millisBehindLatest: Int?
    /// <p>The next position in the shard from which to start sequentially reading data
    ///             records. If set to <code>null</code>, the shard has been closed and the requested
    ///             iterator does not return any more data. </p>
    public let nextShardIterator: String?
    /// <p>The data records retrieved from the shard.</p>
    public let records: [Record]?

    public init (
        childShards: [ChildShard]? = nil,
        millisBehindLatest: Int? = nil,
        nextShardIterator: String? = nil,
        records: [Record]? = nil
    )
    {
        self.childShards = childShards
        self.millisBehindLatest = millisBehindLatest
        self.nextShardIterator = nextShardIterator
        self.records = records
    }
}

struct GetRecordsOutputResponseBody: Equatable {
    public let records: [Record]?
    public let nextShardIterator: String?
    public let millisBehindLatest: Int?
    public let childShards: [ChildShard]?
}

extension GetRecordsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case childShards = "ChildShards"
        case millisBehindLatest = "MillisBehindLatest"
        case nextShardIterator = "NextShardIterator"
        case records = "Records"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([Record?].self, forKey: .records)
        var recordsDecoded0:[Record]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [Record]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let nextShardIteratorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextShardIterator)
        nextShardIterator = nextShardIteratorDecoded
        let millisBehindLatestDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .millisBehindLatest)
        millisBehindLatest = millisBehindLatestDecoded
        let childShardsContainer = try containerValues.decodeIfPresent([ChildShard?].self, forKey: .childShards)
        var childShardsDecoded0:[ChildShard]? = nil
        if let childShardsContainer = childShardsContainer {
            childShardsDecoded0 = [ChildShard]()
            for structure0 in childShardsContainer {
                if let structure0 = structure0 {
                    childShardsDecoded0?.append(structure0)
                }
            }
        }
        childShards = childShardsDecoded0
    }
}

public struct GetShardIteratorInputBodyMiddleware: Middleware {
    public let id: String = "GetShardIteratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetShardIteratorInput>,
                  next: H) -> Swift.Result<OperationOutput<GetShardIteratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetShardIteratorInput>
    public typealias MOutput = OperationOutput<GetShardIteratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetShardIteratorOutputError>
}

extension GetShardIteratorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetShardIteratorInput(shardId: \(String(describing: shardId)), shardIteratorType: \(String(describing: shardIteratorType)), startingSequenceNumber: \(String(describing: startingSequenceNumber)), streamName: \(String(describing: streamName)), timestamp: \(String(describing: timestamp)))"}
}

extension GetShardIteratorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case shardId = "ShardId"
        case shardIteratorType = "ShardIteratorType"
        case startingSequenceNumber = "StartingSequenceNumber"
        case streamName = "StreamName"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shardId = shardId {
            try encodeContainer.encode(shardId, forKey: .shardId)
        }
        if let shardIteratorType = shardIteratorType {
            try encodeContainer.encode(shardIteratorType.rawValue, forKey: .shardIteratorType)
        }
        if let startingSequenceNumber = startingSequenceNumber {
            try encodeContainer.encode(startingSequenceNumber, forKey: .startingSequenceNumber)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
    }
}

public struct GetShardIteratorInputHeadersMiddleware: Middleware {
    public let id: String = "GetShardIteratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetShardIteratorInput>,
                  next: H) -> Swift.Result<OperationOutput<GetShardIteratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetShardIteratorInput>
    public typealias MOutput = OperationOutput<GetShardIteratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetShardIteratorOutputError>
}

public struct GetShardIteratorInputQueryItemMiddleware: Middleware {
    public let id: String = "GetShardIteratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetShardIteratorInput>,
                  next: H) -> Swift.Result<OperationOutput<GetShardIteratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetShardIteratorInput>
    public typealias MOutput = OperationOutput<GetShardIteratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetShardIteratorOutputError>
}

/// <p>Represents the input for <code>GetShardIterator</code>.</p>
public struct GetShardIteratorInput: Equatable {
    /// <p>The shard ID of the Kinesis Data Streams shard to get the iterator for.</p>
    public let shardId: String?
    /// <p>Determines how the shard iterator is used to start reading data records from the
    ///             shard.</p>
    ///         <p>The following are the valid Amazon Kinesis shard iterator types:</p>
    ///         <ul>
    ///             <li>
    ///
    ///                 <p>AT_SEQUENCE_NUMBER - Start reading from the position denoted by a specific
    ///                     sequence number, provided in the value
    ///                     <code>StartingSequenceNumber</code>.</p>
    ///             </li>
    ///             <li>
    ///
    ///                 <p>AFTER_SEQUENCE_NUMBER - Start reading right after the position denoted by a
    ///                     specific sequence number, provided in the value
    ///                         <code>StartingSequenceNumber</code>.</p>
    ///             </li>
    ///             <li>
    ///
    ///                 <p>AT_TIMESTAMP - Start reading from the position denoted by a specific time
    ///                     stamp, provided in the value <code>Timestamp</code>.</p>
    ///             </li>
    ///             <li>
    ///
    ///                 <p>TRIM_HORIZON - Start reading at the last untrimmed record in the shard in
    ///                     the system, which is the oldest data record in the shard.</p>
    ///             </li>
    ///             <li>
    ///
    ///                 <p>LATEST - Start reading just after the most recent record in the shard, so
    ///                     that you always read the most recent data in the shard.</p>
    ///             </li>
    ///          </ul>
    public let shardIteratorType: ShardIteratorType?
    /// <p>The sequence number of the data record in the shard from which to start reading.
    ///             Used with shard iterator type AT_SEQUENCE_NUMBER and AFTER_SEQUENCE_NUMBER.</p>
    public let startingSequenceNumber: String?
    /// <p>The name of the Amazon Kinesis data stream.</p>
    public let streamName: String?
    /// <p>The time stamp of the data record from which to start reading. Used with shard
    ///             iterator type AT_TIMESTAMP. A time stamp is the Unix epoch date with precision in
    ///             milliseconds. For example, <code>2016-04-04T19:58:46.480-00:00</code> or
    ///                 <code>1459799926.480</code>. If a record with this exact time stamp does not exist,
    ///             the iterator returned is for the next (later) record. If the time stamp is older than
    ///             the current trim horizon, the iterator returned is for the oldest untrimmed data record
    ///             (TRIM_HORIZON).</p>
    public let timestamp: Date?

    public init (
        shardId: String? = nil,
        shardIteratorType: ShardIteratorType? = nil,
        startingSequenceNumber: String? = nil,
        streamName: String? = nil,
        timestamp: Date? = nil
    )
    {
        self.shardId = shardId
        self.shardIteratorType = shardIteratorType
        self.startingSequenceNumber = startingSequenceNumber
        self.streamName = streamName
        self.timestamp = timestamp
    }
}

struct GetShardIteratorInputBody: Equatable {
    public let streamName: String?
    public let shardId: String?
    public let shardIteratorType: ShardIteratorType?
    public let startingSequenceNumber: String?
    public let timestamp: Date?
}

extension GetShardIteratorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case shardId = "ShardId"
        case shardIteratorType = "ShardIteratorType"
        case startingSequenceNumber = "StartingSequenceNumber"
        case streamName = "StreamName"
        case timestamp = "Timestamp"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let shardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shardId)
        shardId = shardIdDecoded
        let shardIteratorTypeDecoded = try containerValues.decodeIfPresent(ShardIteratorType.self, forKey: .shardIteratorType)
        shardIteratorType = shardIteratorTypeDecoded
        let startingSequenceNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startingSequenceNumber)
        startingSequenceNumber = startingSequenceNumberDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension GetShardIteratorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetShardIteratorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedThroughputExceededException" : self = .provisionedThroughputExceededException(try ProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetShardIteratorOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case provisionedThroughputExceededException(ProvisionedThroughputExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetShardIteratorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetShardIteratorOutputResponse(shardIterator: \(String(describing: shardIterator)))"}
}

extension GetShardIteratorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetShardIteratorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.shardIterator = output.shardIterator
        } else {
            self.shardIterator = nil
        }
    }
}

/// <p>Represents the output for <code>GetShardIterator</code>.</p>
public struct GetShardIteratorOutputResponse: Equatable {
    /// <p>The position in the shard from which to start reading data records sequentially. A
    ///             shard iterator specifies this position using the sequence number of a data record in a
    ///             shard.</p>
    public let shardIterator: String?

    public init (
        shardIterator: String? = nil
    )
    {
        self.shardIterator = shardIterator
    }
}

struct GetShardIteratorOutputResponseBody: Equatable {
    public let shardIterator: String?
}

extension GetShardIteratorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case shardIterator = "ShardIterator"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shardIteratorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shardIterator)
        shardIterator = shardIteratorDecoded
    }
}

extension HashKeyRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endingHashKey = "EndingHashKey"
        case startingHashKey = "StartingHashKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endingHashKey = endingHashKey {
            try encodeContainer.encode(endingHashKey, forKey: .endingHashKey)
        }
        if let startingHashKey = startingHashKey {
            try encodeContainer.encode(startingHashKey, forKey: .startingHashKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startingHashKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startingHashKey)
        startingHashKey = startingHashKeyDecoded
        let endingHashKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endingHashKey)
        endingHashKey = endingHashKeyDecoded
    }
}

extension HashKeyRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HashKeyRange(endingHashKey: \(String(describing: endingHashKey)), startingHashKey: \(String(describing: startingHashKey)))"}
}

/// <p>The range of possible hash key values for the shard, which is a set of ordered
///             contiguous positive integers.</p>
public struct HashKeyRange: Equatable {
    /// <p>The ending hash key of the hash key range.</p>
    public let endingHashKey: String?
    /// <p>The starting hash key of the hash key range.</p>
    public let startingHashKey: String?

    public init (
        endingHashKey: String? = nil,
        startingHashKey: String? = nil
    )
    {
        self.endingHashKey = endingHashKey
        self.startingHashKey = startingHashKey
    }
}

public struct IncreaseStreamRetentionPeriodInputBodyMiddleware: Middleware {
    public let id: String = "IncreaseStreamRetentionPeriodInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<IncreaseStreamRetentionPeriodInput>,
                  next: H) -> Swift.Result<OperationOutput<IncreaseStreamRetentionPeriodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<IncreaseStreamRetentionPeriodInput>
    public typealias MOutput = OperationOutput<IncreaseStreamRetentionPeriodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<IncreaseStreamRetentionPeriodOutputError>
}

extension IncreaseStreamRetentionPeriodInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncreaseStreamRetentionPeriodInput(retentionPeriodHours: \(String(describing: retentionPeriodHours)), streamName: \(String(describing: streamName)))"}
}

extension IncreaseStreamRetentionPeriodInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case retentionPeriodHours = "RetentionPeriodHours"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionPeriodHours = retentionPeriodHours {
            try encodeContainer.encode(retentionPeriodHours, forKey: .retentionPeriodHours)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct IncreaseStreamRetentionPeriodInputHeadersMiddleware: Middleware {
    public let id: String = "IncreaseStreamRetentionPeriodInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<IncreaseStreamRetentionPeriodInput>,
                  next: H) -> Swift.Result<OperationOutput<IncreaseStreamRetentionPeriodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<IncreaseStreamRetentionPeriodInput>
    public typealias MOutput = OperationOutput<IncreaseStreamRetentionPeriodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<IncreaseStreamRetentionPeriodOutputError>
}

public struct IncreaseStreamRetentionPeriodInputQueryItemMiddleware: Middleware {
    public let id: String = "IncreaseStreamRetentionPeriodInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<IncreaseStreamRetentionPeriodInput>,
                  next: H) -> Swift.Result<OperationOutput<IncreaseStreamRetentionPeriodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<IncreaseStreamRetentionPeriodInput>
    public typealias MOutput = OperationOutput<IncreaseStreamRetentionPeriodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<IncreaseStreamRetentionPeriodOutputError>
}

/// <p>Represents the input for <a>IncreaseStreamRetentionPeriod</a>.</p>
public struct IncreaseStreamRetentionPeriodInput: Equatable {
    /// <p>The new retention period of the stream, in hours. Must be more than the current
    ///             retention period.</p>
    public let retentionPeriodHours: Int?
    /// <p>The name of the stream to modify.</p>
    public let streamName: String?

    public init (
        retentionPeriodHours: Int? = nil,
        streamName: String? = nil
    )
    {
        self.retentionPeriodHours = retentionPeriodHours
        self.streamName = streamName
    }
}

struct IncreaseStreamRetentionPeriodInputBody: Equatable {
    public let streamName: String?
    public let retentionPeriodHours: Int?
}

extension IncreaseStreamRetentionPeriodInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case retentionPeriodHours = "RetentionPeriodHours"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let retentionPeriodHoursDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .retentionPeriodHours)
        retentionPeriodHours = retentionPeriodHoursDecoded
    }
}

extension IncreaseStreamRetentionPeriodOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension IncreaseStreamRetentionPeriodOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum IncreaseStreamRetentionPeriodOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension IncreaseStreamRetentionPeriodOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncreaseStreamRetentionPeriodOutputResponse()"}
}

extension IncreaseStreamRetentionPeriodOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct IncreaseStreamRetentionPeriodOutputResponse: Equatable {

    public init() {}
}

struct IncreaseStreamRetentionPeriodOutputResponseBody: Equatable {
}

extension IncreaseStreamRetentionPeriodOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension InternalFailureException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalFailureException(message: \(String(describing: message)))"}
}

/// <p>The processing of the request failed because of an unknown error, exception, or
///             failure.</p>
public struct InternalFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

extension InvalidArgumentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidArgumentException(message: \(String(describing: message)))"}
}

extension InvalidArgumentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A specified parameter exceeds its restrictions, is not supported, or can't be used.
///             For more information, see the returned message.</p>
public struct InvalidArgumentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message that provides information about the error.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentExceptionBody: Equatable {
    public let message: String?
}

extension InvalidArgumentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSAccessDeniedException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSAccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSAccessDeniedException(message: \(String(describing: message)))"}
}

extension KMSAccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KMSAccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The ciphertext references a key that doesn't exist or that you don't have access
///             to.</p>
public struct KMSAccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message that provides information about the error.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSAccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension KMSAccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSDisabledException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSDisabledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSDisabledException(message: \(String(describing: message)))"}
}

extension KMSDisabledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KMSDisabledExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the specified customer master key (CMK) isn't
///             enabled.</p>
public struct KMSDisabledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message that provides information about the error.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSDisabledExceptionBody: Equatable {
    public let message: String?
}

extension KMSDisabledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSInvalidStateException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSInvalidStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSInvalidStateException(message: \(String(describing: message)))"}
}

extension KMSInvalidStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KMSInvalidStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the state of the specified resource isn't valid
///             for this request. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">How Key State Affects Use of a
///                 Customer Master Key</a> in the <i>AWS Key Management Service Developer
///                 Guide</i>.</p>
public struct KMSInvalidStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message that provides information about the error.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSInvalidStateExceptionBody: Equatable {
    public let message: String?
}

extension KMSInvalidStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSNotFoundException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSNotFoundException(message: \(String(describing: message)))"}
}

extension KMSNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KMSNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the specified entity or resource can't be
///             found.</p>
public struct KMSNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message that provides information about the error.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension KMSNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSOptInRequired: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSOptInRequired: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSOptInRequired(message: \(String(describing: message)))"}
}

extension KMSOptInRequired: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KMSOptInRequiredBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The AWS access key ID needs a subscription for the service.</p>
public struct KMSOptInRequired: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message that provides information about the error.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSOptInRequiredBody: Equatable {
    public let message: String?
}

extension KMSOptInRequiredBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSThrottlingException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSThrottlingException(message: \(String(describing: message)))"}
}

extension KMSThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KMSThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to request throttling. For more information about
///             throttling, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/limits.html#requests-per-second">Limits</a> in
///             the <i>AWS Key Management Service Developer Guide</i>.</p>
public struct KMSThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message that provides information about the error.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension KMSThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested resource exceeds the maximum number allowed, or the number of
///             concurrent stream requests exceeds the maximum number allowed. </p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message that provides information about the error.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListShardsInputBodyMiddleware: Middleware {
    public let id: String = "ListShardsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListShardsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListShardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListShardsInput>
    public typealias MOutput = OperationOutput<ListShardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListShardsOutputError>
}

extension ListShardsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListShardsInput(exclusiveStartShardId: \(String(describing: exclusiveStartShardId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), shardFilter: \(String(describing: shardFilter)), streamCreationTimestamp: \(String(describing: streamCreationTimestamp)), streamName: \(String(describing: streamName)))"}
}

extension ListShardsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exclusiveStartShardId = "ExclusiveStartShardId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case shardFilter = "ShardFilter"
        case streamCreationTimestamp = "StreamCreationTimestamp"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusiveStartShardId = exclusiveStartShardId {
            try encodeContainer.encode(exclusiveStartShardId, forKey: .exclusiveStartShardId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let shardFilter = shardFilter {
            try encodeContainer.encode(shardFilter, forKey: .shardFilter)
        }
        if let streamCreationTimestamp = streamCreationTimestamp {
            try encodeContainer.encode(streamCreationTimestamp.timeIntervalSince1970, forKey: .streamCreationTimestamp)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct ListShardsInputHeadersMiddleware: Middleware {
    public let id: String = "ListShardsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListShardsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListShardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListShardsInput>
    public typealias MOutput = OperationOutput<ListShardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListShardsOutputError>
}

public struct ListShardsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListShardsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListShardsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListShardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListShardsInput>
    public typealias MOutput = OperationOutput<ListShardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListShardsOutputError>
}

public struct ListShardsInput: Equatable {
    /// <p>Specify this parameter to indicate that you want to list the shards starting with
    ///             the shard whose ID immediately follows <code>ExclusiveStartShardId</code>.</p>
    ///         <p>If you don't specify this parameter, the default behavior is for
    ///                 <code>ListShards</code> to list the shards starting with the first one in the
    ///             stream.</p>
    ///         <p>You cannot specify this parameter if you specify <code>NextToken</code>.</p>
    public let exclusiveStartShardId: String?
    /// <p>The maximum number of shards to return in a single call to <code>ListShards</code>.
    ///             The minimum value you can specify for this parameter is 1, and the maximum is 10,000,
    ///             which is also the default.</p>
    ///         <p>When the number of shards to be listed is greater than the value of
    ///                 <code>MaxResults</code>, the response contains a <code>NextToken</code> value that
    ///             you can use in a subsequent call to <code>ListShards</code> to list the next set of
    ///             shards.</p>
    public let maxResults: Int?
    /// <p>When the number of shards in the data stream is greater than the default value for
    ///             the <code>MaxResults</code> parameter, or if you explicitly specify a value for
    ///                 <code>MaxResults</code> that is less than the number of shards in the data stream,
    ///             the response includes a pagination token named <code>NextToken</code>. You can specify
    ///             this <code>NextToken</code> value in a subsequent call to <code>ListShards</code> to
    ///             list the next set of shards.</p>
    ///         <p>Don't specify <code>StreamName</code> or <code>StreamCreationTimestamp</code> if
    ///             you specify <code>NextToken</code> because the latter unambiguously identifies the
    ///             stream.</p>
    ///         <p>You can optionally specify a value for the <code>MaxResults</code> parameter when
    ///             you specify <code>NextToken</code>. If you specify a <code>MaxResults</code> value that
    ///             is less than the number of shards that the operation returns if you don't specify
    ///                 <code>MaxResults</code>, the response will contain a new <code>NextToken</code>
    ///             value. You can use the new <code>NextToken</code> value in a subsequent call to the
    ///                 <code>ListShards</code> operation.</p>
    ///         <important>
    ///             <p>Tokens expire after 300 seconds. When you obtain a value for
    ///                     <code>NextToken</code> in the response to a call to <code>ListShards</code>, you
    ///                 have 300 seconds to use that value. If you specify an expired token in a call to
    ///                     <code>ListShards</code>, you get
    ///                 <code>ExpiredNextTokenException</code>.</p>
    ///         </important>
    public let nextToken: String?
    public let shardFilter: ShardFilter?
    /// <p>Specify this input parameter to distinguish data streams that have the same name.
    ///             For example, if you create a data stream and then delete it, and you later create
    ///             another data stream with the same name, you can use this input parameter to specify
    ///             which of the two streams you want to list the shards for.</p>
    ///         <p>You cannot specify this parameter if you specify the <code>NextToken</code>
    ///             parameter.</p>
    public let streamCreationTimestamp: Date?
    /// <p>The name of the data stream whose shards you want to list. </p>
    ///         <p>You cannot specify this parameter if you specify the <code>NextToken</code>
    ///             parameter.</p>
    public let streamName: String?

    public init (
        exclusiveStartShardId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        shardFilter: ShardFilter? = nil,
        streamCreationTimestamp: Date? = nil,
        streamName: String? = nil
    )
    {
        self.exclusiveStartShardId = exclusiveStartShardId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.shardFilter = shardFilter
        self.streamCreationTimestamp = streamCreationTimestamp
        self.streamName = streamName
    }
}

struct ListShardsInputBody: Equatable {
    public let streamName: String?
    public let nextToken: String?
    public let exclusiveStartShardId: String?
    public let maxResults: Int?
    public let streamCreationTimestamp: Date?
    public let shardFilter: ShardFilter?
}

extension ListShardsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exclusiveStartShardId = "ExclusiveStartShardId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case shardFilter = "ShardFilter"
        case streamCreationTimestamp = "StreamCreationTimestamp"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let exclusiveStartShardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exclusiveStartShardId)
        exclusiveStartShardId = exclusiveStartShardIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let streamCreationTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .streamCreationTimestamp)
        streamCreationTimestamp = streamCreationTimestampDecoded
        let shardFilterDecoded = try containerValues.decodeIfPresent(ShardFilter.self, forKey: .shardFilter)
        shardFilter = shardFilterDecoded
    }
}

extension ListShardsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListShardsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ExpiredNextTokenException" : self = .expiredNextTokenException(try ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListShardsOutputError: Equatable {
    case expiredNextTokenException(ExpiredNextTokenException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListShardsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListShardsOutputResponse(nextToken: \(String(describing: nextToken)), shards: \(String(describing: shards)))"}
}

extension ListShardsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListShardsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.shards = output.shards
        } else {
            self.nextToken = nil
            self.shards = nil
        }
    }
}

public struct ListShardsOutputResponse: Equatable {
    /// <p>When the number of shards in the data stream is greater than the default value for
    ///             the <code>MaxResults</code> parameter, or if you explicitly specify a value for
    ///                 <code>MaxResults</code> that is less than the number of shards in the data stream,
    ///             the response includes a pagination token named <code>NextToken</code>. You can specify
    ///             this <code>NextToken</code> value in a subsequent call to <code>ListShards</code> to
    ///             list the next set of shards. For more information about the use of this pagination token
    ///             when calling the <code>ListShards</code> operation, see <a>ListShardsInput$NextToken</a>.</p>
    ///         <important>
    ///             <p>Tokens expire after 300 seconds. When you obtain a value for
    ///                     <code>NextToken</code> in the response to a call to <code>ListShards</code>, you
    ///                 have 300 seconds to use that value. If you specify an expired token in a call to
    ///                     <code>ListShards</code>, you get
    ///                 <code>ExpiredNextTokenException</code>.</p>
    ///         </important>
    public let nextToken: String?
    /// <p>An array of JSON objects. Each object represents one shard and specifies the IDs of
    ///             the shard, the shard's parent, and the shard that's adjacent to the shard's parent. Each
    ///             object also contains the starting and ending hash keys and the starting and ending
    ///             sequence numbers for the shard.</p>
    public let shards: [Shard]?

    public init (
        nextToken: String? = nil,
        shards: [Shard]? = nil
    )
    {
        self.nextToken = nextToken
        self.shards = shards
    }
}

struct ListShardsOutputResponseBody: Equatable {
    public let shards: [Shard]?
    public let nextToken: String?
}

extension ListShardsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case shards = "Shards"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shardsContainer = try containerValues.decodeIfPresent([Shard?].self, forKey: .shards)
        var shardsDecoded0:[Shard]? = nil
        if let shardsContainer = shardsContainer {
            shardsDecoded0 = [Shard]()
            for structure0 in shardsContainer {
                if let structure0 = structure0 {
                    shardsDecoded0?.append(structure0)
                }
            }
        }
        shards = shardsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListStreamConsumersInputBodyMiddleware: Middleware {
    public let id: String = "ListStreamConsumersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamConsumersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamConsumersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamConsumersInput>
    public typealias MOutput = OperationOutput<ListStreamConsumersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamConsumersOutputError>
}

extension ListStreamConsumersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStreamConsumersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), streamARN: \(String(describing: streamARN)), streamCreationTimestamp: \(String(describing: streamCreationTimestamp)))"}
}

extension ListStreamConsumersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case streamARN = "StreamARN"
        case streamCreationTimestamp = "StreamCreationTimestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamCreationTimestamp = streamCreationTimestamp {
            try encodeContainer.encode(streamCreationTimestamp.timeIntervalSince1970, forKey: .streamCreationTimestamp)
        }
    }
}

public struct ListStreamConsumersInputHeadersMiddleware: Middleware {
    public let id: String = "ListStreamConsumersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamConsumersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamConsumersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamConsumersInput>
    public typealias MOutput = OperationOutput<ListStreamConsumersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamConsumersOutputError>
}

public struct ListStreamConsumersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStreamConsumersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamConsumersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamConsumersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamConsumersInput>
    public typealias MOutput = OperationOutput<ListStreamConsumersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamConsumersOutputError>
}

public struct ListStreamConsumersInput: Equatable {
    /// <p>The maximum number of consumers that you want a single call of
    ///                 <code>ListStreamConsumers</code> to return.</p>
    public let maxResults: Int?
    /// <p>When the number of consumers that are registered with the data stream is greater than
    ///             the default value for the <code>MaxResults</code> parameter, or if you explicitly
    ///             specify a value for <code>MaxResults</code> that is less than the number of consumers
    ///             that are registered with the data stream, the response includes a pagination token named
    ///                 <code>NextToken</code>. You can specify this <code>NextToken</code> value in a
    ///             subsequent call to <code>ListStreamConsumers</code> to list the next set of registered
    ///             consumers.</p>
    ///         <p>Don't specify <code>StreamName</code> or <code>StreamCreationTimestamp</code> if you
    ///             specify <code>NextToken</code> because the latter unambiguously identifies the
    ///             stream.</p>
    ///         <p>You can optionally specify a value for the <code>MaxResults</code> parameter when you
    ///             specify <code>NextToken</code>. If you specify a <code>MaxResults</code> value that is
    ///             less than the number of consumers that the operation returns if you don't specify
    ///                 <code>MaxResults</code>, the response will contain a new <code>NextToken</code>
    ///             value. You can use the new <code>NextToken</code> value in a subsequent call to the
    ///                 <code>ListStreamConsumers</code> operation to list the next set of consumers.</p>
    ///         <important>
    ///             <p>Tokens expire after 300 seconds. When you obtain a value for
    ///                     <code>NextToken</code> in the response to a call to
    ///                     <code>ListStreamConsumers</code>, you have 300 seconds to use that value. If you
    ///                 specify an expired token in a call to <code>ListStreamConsumers</code>, you get
    ///                     <code>ExpiredNextTokenException</code>.</p>
    ///         </important>
    public let nextToken: String?
    /// <p>The ARN of the Kinesis data stream for which you want to list the registered
    ///             consumers. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
    public let streamARN: String?
    /// <p>Specify this input parameter to distinguish data streams that have the same name. For
    ///             example, if you create a data stream and then delete it, and you later create another
    ///             data stream with the same name, you can use this input parameter to specify which of the
    ///             two streams you want to list the consumers for. </p>
    ///         <p>You can't specify this parameter if you specify the NextToken parameter. </p>
    public let streamCreationTimestamp: Date?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        streamARN: String? = nil,
        streamCreationTimestamp: Date? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.streamARN = streamARN
        self.streamCreationTimestamp = streamCreationTimestamp
    }
}

struct ListStreamConsumersInputBody: Equatable {
    public let streamARN: String?
    public let nextToken: String?
    public let maxResults: Int?
    public let streamCreationTimestamp: Date?
}

extension ListStreamConsumersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case streamARN = "StreamARN"
        case streamCreationTimestamp = "StreamCreationTimestamp"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let streamCreationTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .streamCreationTimestamp)
        streamCreationTimestamp = streamCreationTimestampDecoded
    }
}

extension ListStreamConsumersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStreamConsumersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ExpiredNextTokenException" : self = .expiredNextTokenException(try ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStreamConsumersOutputError: Equatable {
    case expiredNextTokenException(ExpiredNextTokenException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamConsumersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStreamConsumersOutputResponse(consumers: \(String(describing: consumers)), nextToken: \(String(describing: nextToken)))"}
}

extension ListStreamConsumersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListStreamConsumersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.consumers = output.consumers
            self.nextToken = output.nextToken
        } else {
            self.consumers = nil
            self.nextToken = nil
        }
    }
}

public struct ListStreamConsumersOutputResponse: Equatable {
    /// <p>An array of JSON objects. Each object represents one registered consumer.</p>
    public let consumers: [Consumer]?
    /// <p>When the number of consumers that are registered with the data stream is greater than
    ///             the default value for the <code>MaxResults</code> parameter, or if you explicitly
    ///             specify a value for <code>MaxResults</code> that is less than the number of registered
    ///             consumers, the response includes a pagination token named <code>NextToken</code>. You
    ///             can specify this <code>NextToken</code> value in a subsequent call to
    ///                 <code>ListStreamConsumers</code> to list the next set of registered consumers. For
    ///             more information about the use of this pagination token when calling the
    ///                 <code>ListStreamConsumers</code> operation, see <a>ListStreamConsumersInput$NextToken</a>.</p>
    ///         <important>
    ///             <p>Tokens expire after 300 seconds. When you obtain a value for
    ///                     <code>NextToken</code> in the response to a call to
    ///                     <code>ListStreamConsumers</code>, you have 300 seconds to use that value. If you
    ///                 specify an expired token in a call to <code>ListStreamConsumers</code>, you get
    ///                     <code>ExpiredNextTokenException</code>.</p>
    ///         </important>
    public let nextToken: String?

    public init (
        consumers: [Consumer]? = nil,
        nextToken: String? = nil
    )
    {
        self.consumers = consumers
        self.nextToken = nextToken
    }
}

struct ListStreamConsumersOutputResponseBody: Equatable {
    public let consumers: [Consumer]?
    public let nextToken: String?
}

extension ListStreamConsumersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case consumers = "Consumers"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consumersContainer = try containerValues.decodeIfPresent([Consumer?].self, forKey: .consumers)
        var consumersDecoded0:[Consumer]? = nil
        if let consumersContainer = consumersContainer {
            consumersDecoded0 = [Consumer]()
            for structure0 in consumersContainer {
                if let structure0 = structure0 {
                    consumersDecoded0?.append(structure0)
                }
            }
        }
        consumers = consumersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListStreamsInputBodyMiddleware: Middleware {
    public let id: String = "ListStreamsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamsInput>
    public typealias MOutput = OperationOutput<ListStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamsOutputError>
}

extension ListStreamsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStreamsInput(exclusiveStartStreamName: \(String(describing: exclusiveStartStreamName)), limit: \(String(describing: limit)))"}
}

extension ListStreamsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exclusiveStartStreamName = "ExclusiveStartStreamName"
        case limit = "Limit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusiveStartStreamName = exclusiveStartStreamName {
            try encodeContainer.encode(exclusiveStartStreamName, forKey: .exclusiveStartStreamName)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
    }
}

public struct ListStreamsInputHeadersMiddleware: Middleware {
    public let id: String = "ListStreamsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamsInput>
    public typealias MOutput = OperationOutput<ListStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamsOutputError>
}

public struct ListStreamsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStreamsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamsInput>
    public typealias MOutput = OperationOutput<ListStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamsOutputError>
}

/// <p>Represents the input for <code>ListStreams</code>.</p>
public struct ListStreamsInput: Equatable {
    /// <p>The name of the stream to start the list with.</p>
    public let exclusiveStartStreamName: String?
    /// <p>The maximum number of streams to list.</p>
    public let limit: Int?

    public init (
        exclusiveStartStreamName: String? = nil,
        limit: Int? = nil
    )
    {
        self.exclusiveStartStreamName = exclusiveStartStreamName
        self.limit = limit
    }
}

struct ListStreamsInputBody: Equatable {
    public let limit: Int?
    public let exclusiveStartStreamName: String?
}

extension ListStreamsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exclusiveStartStreamName = "ExclusiveStartStreamName"
        case limit = "Limit"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let exclusiveStartStreamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exclusiveStartStreamName)
        exclusiveStartStreamName = exclusiveStartStreamNameDecoded
    }
}

extension ListStreamsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStreamsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStreamsOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStreamsOutputResponse(hasMoreStreams: \(String(describing: hasMoreStreams)), streamNames: \(String(describing: streamNames)))"}
}

extension ListStreamsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListStreamsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hasMoreStreams = output.hasMoreStreams
            self.streamNames = output.streamNames
        } else {
            self.hasMoreStreams = nil
            self.streamNames = nil
        }
    }
}

/// <p>Represents the output for <code>ListStreams</code>.</p>
public struct ListStreamsOutputResponse: Equatable {
    /// <p>If set to <code>true</code>, there are more streams available to list.</p>
    public let hasMoreStreams: Bool?
    /// <p>The names of the streams that are associated with the AWS account making the
    ///                 <code>ListStreams</code> request.</p>
    public let streamNames: [String]?

    public init (
        hasMoreStreams: Bool? = nil,
        streamNames: [String]? = nil
    )
    {
        self.hasMoreStreams = hasMoreStreams
        self.streamNames = streamNames
    }
}

struct ListStreamsOutputResponseBody: Equatable {
    public let streamNames: [String]?
    public let hasMoreStreams: Bool?
}

extension ListStreamsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hasMoreStreams = "HasMoreStreams"
        case streamNames = "StreamNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .streamNames)
        var streamNamesDecoded0:[String]? = nil
        if let streamNamesContainer = streamNamesContainer {
            streamNamesDecoded0 = [String]()
            for string0 in streamNamesContainer {
                if let string0 = string0 {
                    streamNamesDecoded0?.append(string0)
                }
            }
        }
        streamNames = streamNamesDecoded0
        let hasMoreStreamsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .hasMoreStreams)
        hasMoreStreams = hasMoreStreamsDecoded
    }
}

public struct ListTagsForStreamInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForStreamInput>
    public typealias MOutput = OperationOutput<ListTagsForStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForStreamOutputError>
}

extension ListTagsForStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForStreamInput(exclusiveStartTagKey: \(String(describing: exclusiveStartTagKey)), limit: \(String(describing: limit)), streamName: \(String(describing: streamName)))"}
}

extension ListTagsForStreamInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exclusiveStartTagKey = "ExclusiveStartTagKey"
        case limit = "Limit"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusiveStartTagKey = exclusiveStartTagKey {
            try encodeContainer.encode(exclusiveStartTagKey, forKey: .exclusiveStartTagKey)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct ListTagsForStreamInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForStreamInput>
    public typealias MOutput = OperationOutput<ListTagsForStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForStreamOutputError>
}

public struct ListTagsForStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForStreamInput>
    public typealias MOutput = OperationOutput<ListTagsForStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForStreamOutputError>
}

/// <p>Represents the input for <code>ListTagsForStream</code>.</p>
public struct ListTagsForStreamInput: Equatable {
    /// <p>The key to use as the starting point for the list of tags. If this parameter is
    ///             set, <code>ListTagsForStream</code> gets all tags that occur after
    ///                 <code>ExclusiveStartTagKey</code>. </p>
    public let exclusiveStartTagKey: String?
    /// <p>The number of tags to return. If this number is less than the total number of tags
    ///             associated with the stream, <code>HasMoreTags</code> is set to <code>true</code>. To
    ///             list additional tags, set <code>ExclusiveStartTagKey</code> to the last key in the
    ///             response.</p>
    public let limit: Int?
    /// <p>The name of the stream.</p>
    public let streamName: String?

    public init (
        exclusiveStartTagKey: String? = nil,
        limit: Int? = nil,
        streamName: String? = nil
    )
    {
        self.exclusiveStartTagKey = exclusiveStartTagKey
        self.limit = limit
        self.streamName = streamName
    }
}

struct ListTagsForStreamInputBody: Equatable {
    public let streamName: String?
    public let exclusiveStartTagKey: String?
    public let limit: Int?
}

extension ListTagsForStreamInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exclusiveStartTagKey = "ExclusiveStartTagKey"
        case limit = "Limit"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let exclusiveStartTagKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exclusiveStartTagKey)
        exclusiveStartTagKey = exclusiveStartTagKeyDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListTagsForStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForStreamOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForStreamOutputResponse(hasMoreTags: \(String(describing: hasMoreTags)), tags: \(String(describing: tags)))"}
}

extension ListTagsForStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForStreamOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hasMoreTags = output.hasMoreTags
            self.tags = output.tags
        } else {
            self.hasMoreTags = nil
            self.tags = nil
        }
    }
}

/// <p>Represents the output for <code>ListTagsForStream</code>.</p>
public struct ListTagsForStreamOutputResponse: Equatable {
    /// <p>If set to <code>true</code>, more tags are available. To request additional tags,
    ///             set <code>ExclusiveStartTagKey</code> to the key of the last tag returned.</p>
    public let hasMoreTags: Bool?
    /// <p>A list of tags associated with <code>StreamName</code>, starting with the first tag
    ///             after <code>ExclusiveStartTagKey</code> and up to the specified <code>Limit</code>.
    ///         </p>
    public let tags: [Tag]?

    public init (
        hasMoreTags: Bool? = nil,
        tags: [Tag]? = nil
    )
    {
        self.hasMoreTags = hasMoreTags
        self.tags = tags
    }
}

struct ListTagsForStreamOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let hasMoreTags: Bool?
}

extension ListTagsForStreamOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hasMoreTags = "HasMoreTags"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let hasMoreTagsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .hasMoreTags)
        hasMoreTags = hasMoreTagsDecoded
    }
}

public struct MergeShardsInputBodyMiddleware: Middleware {
    public let id: String = "MergeShardsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergeShardsInput>,
                  next: H) -> Swift.Result<OperationOutput<MergeShardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergeShardsInput>
    public typealias MOutput = OperationOutput<MergeShardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergeShardsOutputError>
}

extension MergeShardsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MergeShardsInput(adjacentShardToMerge: \(String(describing: adjacentShardToMerge)), shardToMerge: \(String(describing: shardToMerge)), streamName: \(String(describing: streamName)))"}
}

extension MergeShardsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adjacentShardToMerge = "AdjacentShardToMerge"
        case shardToMerge = "ShardToMerge"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adjacentShardToMerge = adjacentShardToMerge {
            try encodeContainer.encode(adjacentShardToMerge, forKey: .adjacentShardToMerge)
        }
        if let shardToMerge = shardToMerge {
            try encodeContainer.encode(shardToMerge, forKey: .shardToMerge)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct MergeShardsInputHeadersMiddleware: Middleware {
    public let id: String = "MergeShardsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergeShardsInput>,
                  next: H) -> Swift.Result<OperationOutput<MergeShardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergeShardsInput>
    public typealias MOutput = OperationOutput<MergeShardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergeShardsOutputError>
}

public struct MergeShardsInputQueryItemMiddleware: Middleware {
    public let id: String = "MergeShardsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergeShardsInput>,
                  next: H) -> Swift.Result<OperationOutput<MergeShardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergeShardsInput>
    public typealias MOutput = OperationOutput<MergeShardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergeShardsOutputError>
}

/// <p>Represents the input for <code>MergeShards</code>.</p>
public struct MergeShardsInput: Equatable {
    /// <p>The shard ID of the adjacent shard for the merge.</p>
    public let adjacentShardToMerge: String?
    /// <p>The shard ID of the shard to combine with the adjacent shard for the
    ///             merge.</p>
    public let shardToMerge: String?
    /// <p>The name of the stream for the merge.</p>
    public let streamName: String?

    public init (
        adjacentShardToMerge: String? = nil,
        shardToMerge: String? = nil,
        streamName: String? = nil
    )
    {
        self.adjacentShardToMerge = adjacentShardToMerge
        self.shardToMerge = shardToMerge
        self.streamName = streamName
    }
}

struct MergeShardsInputBody: Equatable {
    public let streamName: String?
    public let shardToMerge: String?
    public let adjacentShardToMerge: String?
}

extension MergeShardsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adjacentShardToMerge = "AdjacentShardToMerge"
        case shardToMerge = "ShardToMerge"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let shardToMergeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shardToMerge)
        shardToMerge = shardToMergeDecoded
        let adjacentShardToMergeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adjacentShardToMerge)
        adjacentShardToMerge = adjacentShardToMergeDecoded
    }
}

extension MergeShardsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MergeShardsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum MergeShardsOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MergeShardsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MergeShardsOutputResponse()"}
}

extension MergeShardsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct MergeShardsOutputResponse: Equatable {

    public init() {}
}

struct MergeShardsOutputResponseBody: Equatable {
}

extension MergeShardsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum MetricsName {
    case all
    case incomingBytes
    case incomingRecords
    case iteratorAgeMilliseconds
    case outgoingBytes
    case outgoingRecords
    case readProvisionedThroughputExceeded
    case writeProvisionedThroughputExceeded
    case sdkUnknown(String)
}

extension MetricsName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MetricsName] {
        return [
            .all,
            .incomingBytes,
            .incomingRecords,
            .iteratorAgeMilliseconds,
            .outgoingBytes,
            .outgoingRecords,
            .readProvisionedThroughputExceeded,
            .writeProvisionedThroughputExceeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .incomingBytes: return "IncomingBytes"
        case .incomingRecords: return "IncomingRecords"
        case .iteratorAgeMilliseconds: return "IteratorAgeMilliseconds"
        case .outgoingBytes: return "OutgoingBytes"
        case .outgoingRecords: return "OutgoingRecords"
        case .readProvisionedThroughputExceeded: return "ReadProvisionedThroughputExceeded"
        case .writeProvisionedThroughputExceeded: return "WriteProvisionedThroughputExceeded"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MetricsName(rawValue: rawValue) ?? MetricsName.sdkUnknown(rawValue)
    }
}

extension ProvisionedThroughputExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisionedThroughputExceededException(message: \(String(describing: message)))"}
}

extension ProvisionedThroughputExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ProvisionedThroughputExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request rate for the stream is too high, or the requested data is too large for
///             the available throughput. Reduce the frequency or size of your requests. For more
///             information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/service-sizes-and-limits.html">Streams Limits</a> in the
///                 <i>Amazon Kinesis Data Streams Developer Guide</i>, and <a href="https://docs.aws.amazon.com/general/latest/gr/api-retries.html">Error Retries and
///                 Exponential Backoff in AWS</a> in the <i>AWS General
///             Reference</i>.</p>
public struct ProvisionedThroughputExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message that provides information about the error.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ProvisionedThroughputExceededExceptionBody: Equatable {
    public let message: String?
}

extension ProvisionedThroughputExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PutRecordInputBodyMiddleware: Middleware {
    public let id: String = "PutRecordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRecordInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRecordInput>
    public typealias MOutput = OperationOutput<PutRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRecordOutputError>
}

extension PutRecordInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRecordInput(data: \(String(describing: data)), explicitHashKey: \(String(describing: explicitHashKey)), partitionKey: \(String(describing: partitionKey)), sequenceNumberForOrdering: \(String(describing: sequenceNumberForOrdering)), streamName: \(String(describing: streamName)))"}
}

extension PutRecordInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case data = "Data"
        case explicitHashKey = "ExplicitHashKey"
        case partitionKey = "PartitionKey"
        case sequenceNumberForOrdering = "SequenceNumberForOrdering"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
        if let explicitHashKey = explicitHashKey {
            try encodeContainer.encode(explicitHashKey, forKey: .explicitHashKey)
        }
        if let partitionKey = partitionKey {
            try encodeContainer.encode(partitionKey, forKey: .partitionKey)
        }
        if let sequenceNumberForOrdering = sequenceNumberForOrdering {
            try encodeContainer.encode(sequenceNumberForOrdering, forKey: .sequenceNumberForOrdering)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct PutRecordInputHeadersMiddleware: Middleware {
    public let id: String = "PutRecordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRecordInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRecordInput>
    public typealias MOutput = OperationOutput<PutRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRecordOutputError>
}

public struct PutRecordInputQueryItemMiddleware: Middleware {
    public let id: String = "PutRecordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRecordInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRecordInput>
    public typealias MOutput = OperationOutput<PutRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRecordOutputError>
}

/// <p>Represents the input for <code>PutRecord</code>.</p>
public struct PutRecordInput: Equatable {
    /// <p>The data blob to put into the record, which is base64-encoded when the blob is
    ///             serialized. When the data blob (the payload before base64-encoding) is added to the
    ///             partition key size, the total size must not exceed the maximum record size (1
    ///             MiB).</p>
    public let data: Data?
    /// <p>The hash value used to explicitly determine the shard the data record is assigned
    ///             to by overriding the partition key hash.</p>
    public let explicitHashKey: String?
    /// <p>Determines which shard in the stream the data record is assigned to. Partition keys
    ///             are Unicode strings with a maximum length limit of 256 characters for each key. Amazon
    ///             Kinesis Data Streams uses the partition key as input to a hash function that maps the
    ///             partition key and associated data to a specific shard. Specifically, an MD5 hash
    ///             function is used to map partition keys to 128-bit integer values and to map associated
    ///             data records to shards. As a result of this hashing mechanism, all data records with the
    ///             same partition key map to the same shard within the stream.</p>
    public let partitionKey: String?
    /// <p>Guarantees strictly increasing sequence numbers, for puts from the same client and
    ///             to the same partition key. Usage: set the <code>SequenceNumberForOrdering</code> of
    ///             record <i>n</i> to the sequence number of record <i>n-1</i>
    ///             (as returned in the result when putting record <i>n-1</i>). If this
    ///             parameter is not set, records are coarsely ordered based on arrival time.</p>
    public let sequenceNumberForOrdering: String?
    /// <p>The name of the stream to put the data record into.</p>
    public let streamName: String?

    public init (
        data: Data? = nil,
        explicitHashKey: String? = nil,
        partitionKey: String? = nil,
        sequenceNumberForOrdering: String? = nil,
        streamName: String? = nil
    )
    {
        self.data = data
        self.explicitHashKey = explicitHashKey
        self.partitionKey = partitionKey
        self.sequenceNumberForOrdering = sequenceNumberForOrdering
        self.streamName = streamName
    }
}

struct PutRecordInputBody: Equatable {
    public let streamName: String?
    public let data: Data?
    public let partitionKey: String?
    public let explicitHashKey: String?
    public let sequenceNumberForOrdering: String?
}

extension PutRecordInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case data = "Data"
        case explicitHashKey = "ExplicitHashKey"
        case partitionKey = "PartitionKey"
        case sequenceNumberForOrdering = "SequenceNumberForOrdering"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let dataDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .data)
        data = dataDecoded
        let partitionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partitionKey)
        partitionKey = partitionKeyDecoded
        let explicitHashKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .explicitHashKey)
        explicitHashKey = explicitHashKeyDecoded
        let sequenceNumberForOrderingDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sequenceNumberForOrdering)
        sequenceNumberForOrdering = sequenceNumberForOrderingDecoded
    }
}

extension PutRecordOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRecordOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSAccessDeniedException" : self = .kMSAccessDeniedException(try KMSAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabledException" : self = .kMSDisabledException(try KMSDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFoundException" : self = .kMSNotFoundException(try KMSNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSOptInRequired" : self = .kMSOptInRequired(try KMSOptInRequired(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSThrottlingException" : self = .kMSThrottlingException(try KMSThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedThroughputExceededException" : self = .provisionedThroughputExceededException(try ProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRecordOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case kMSAccessDeniedException(KMSAccessDeniedException)
    case kMSDisabledException(KMSDisabledException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case kMSNotFoundException(KMSNotFoundException)
    case kMSOptInRequired(KMSOptInRequired)
    case kMSThrottlingException(KMSThrottlingException)
    case provisionedThroughputExceededException(ProvisionedThroughputExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRecordOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRecordOutputResponse(encryptionType: \(String(describing: encryptionType)), sequenceNumber: \(String(describing: sequenceNumber)), shardId: \(String(describing: shardId)))"}
}

extension PutRecordOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutRecordOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.encryptionType = output.encryptionType
            self.sequenceNumber = output.sequenceNumber
            self.shardId = output.shardId
        } else {
            self.encryptionType = nil
            self.sequenceNumber = nil
            self.shardId = nil
        }
    }
}

/// <p>Represents the output for <code>PutRecord</code>.</p>
public struct PutRecordOutputResponse: Equatable {
    /// <p>The encryption type to use on the record. This parameter can be one of the
    ///             following values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>NONE</code>: Do not encrypt the records in the stream.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>KMS</code>: Use server-side encryption on the records in the stream
    ///                     using a customer-managed AWS KMS key.</p>
    ///             </li>
    ///          </ul>
    public let encryptionType: EncryptionType?
    /// <p>The sequence number identifier that was assigned to the put data record. The
    ///             sequence number for the record is unique across all records in the stream. A sequence
    ///             number is the identifier associated with every record put into the stream.</p>
    public let sequenceNumber: String?
    /// <p>The shard ID of the shard where the data record was placed.</p>
    public let shardId: String?

    public init (
        encryptionType: EncryptionType? = nil,
        sequenceNumber: String? = nil,
        shardId: String? = nil
    )
    {
        self.encryptionType = encryptionType
        self.sequenceNumber = sequenceNumber
        self.shardId = shardId
    }
}

struct PutRecordOutputResponseBody: Equatable {
    public let shardId: String?
    public let sequenceNumber: String?
    public let encryptionType: EncryptionType?
}

extension PutRecordOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case encryptionType = "EncryptionType"
        case sequenceNumber = "SequenceNumber"
        case shardId = "ShardId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shardId)
        shardId = shardIdDecoded
        let sequenceNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sequenceNumber)
        sequenceNumber = sequenceNumberDecoded
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
    }
}

public struct PutRecordsInputBodyMiddleware: Middleware {
    public let id: String = "PutRecordsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRecordsInput>
    public typealias MOutput = OperationOutput<PutRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRecordsOutputError>
}

extension PutRecordsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRecordsInput(records: \(String(describing: records)), streamName: \(String(describing: streamName)))"}
}

extension PutRecordsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case records = "Records"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let records = records {
            var recordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .records)
            for putrecordsrequestentrylist0 in records {
                try recordsContainer.encode(putrecordsrequestentrylist0)
            }
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct PutRecordsInputHeadersMiddleware: Middleware {
    public let id: String = "PutRecordsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRecordsInput>
    public typealias MOutput = OperationOutput<PutRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRecordsOutputError>
}

public struct PutRecordsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutRecordsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRecordsInput>
    public typealias MOutput = OperationOutput<PutRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRecordsOutputError>
}

/// <p>A <code>PutRecords</code> request.</p>
public struct PutRecordsInput: Equatable {
    /// <p>The records associated with the request.</p>
    public let records: [PutRecordsRequestEntry]?
    /// <p>The stream name associated with the request.</p>
    public let streamName: String?

    public init (
        records: [PutRecordsRequestEntry]? = nil,
        streamName: String? = nil
    )
    {
        self.records = records
        self.streamName = streamName
    }
}

struct PutRecordsInputBody: Equatable {
    public let records: [PutRecordsRequestEntry]?
    public let streamName: String?
}

extension PutRecordsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case records = "Records"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([PutRecordsRequestEntry?].self, forKey: .records)
        var recordsDecoded0:[PutRecordsRequestEntry]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [PutRecordsRequestEntry]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
    }
}

extension PutRecordsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRecordsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSAccessDeniedException" : self = .kMSAccessDeniedException(try KMSAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabledException" : self = .kMSDisabledException(try KMSDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFoundException" : self = .kMSNotFoundException(try KMSNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSOptInRequired" : self = .kMSOptInRequired(try KMSOptInRequired(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSThrottlingException" : self = .kMSThrottlingException(try KMSThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedThroughputExceededException" : self = .provisionedThroughputExceededException(try ProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRecordsOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case kMSAccessDeniedException(KMSAccessDeniedException)
    case kMSDisabledException(KMSDisabledException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case kMSNotFoundException(KMSNotFoundException)
    case kMSOptInRequired(KMSOptInRequired)
    case kMSThrottlingException(KMSThrottlingException)
    case provisionedThroughputExceededException(ProvisionedThroughputExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRecordsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRecordsOutputResponse(encryptionType: \(String(describing: encryptionType)), failedRecordCount: \(String(describing: failedRecordCount)), records: \(String(describing: records)))"}
}

extension PutRecordsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutRecordsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.encryptionType = output.encryptionType
            self.failedRecordCount = output.failedRecordCount
            self.records = output.records
        } else {
            self.encryptionType = nil
            self.failedRecordCount = nil
            self.records = nil
        }
    }
}

/// <p>
///             <code>PutRecords</code> results.</p>
public struct PutRecordsOutputResponse: Equatable {
    /// <p>The encryption type used on the records. This parameter can be one of the following
    ///             values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>NONE</code>: Do not encrypt the records.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>KMS</code>: Use server-side encryption on the records using a
    ///                     customer-managed AWS KMS key.</p>
    ///             </li>
    ///          </ul>
    public let encryptionType: EncryptionType?
    /// <p>The number of unsuccessfully processed records in a <code>PutRecords</code>
    ///             request.</p>
    public let failedRecordCount: Int?
    /// <p>An array of successfully and unsuccessfully processed record results, correlated
    ///             with the request by natural ordering. A record that is successfully added to a stream
    ///             includes <code>SequenceNumber</code> and <code>ShardId</code> in the result. A record
    ///             that fails to be added to a stream includes <code>ErrorCode</code> and
    ///                 <code>ErrorMessage</code> in the result.</p>
    public let records: [PutRecordsResultEntry]?

    public init (
        encryptionType: EncryptionType? = nil,
        failedRecordCount: Int? = nil,
        records: [PutRecordsResultEntry]? = nil
    )
    {
        self.encryptionType = encryptionType
        self.failedRecordCount = failedRecordCount
        self.records = records
    }
}

struct PutRecordsOutputResponseBody: Equatable {
    public let failedRecordCount: Int?
    public let records: [PutRecordsResultEntry]?
    public let encryptionType: EncryptionType?
}

extension PutRecordsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case encryptionType = "EncryptionType"
        case failedRecordCount = "FailedRecordCount"
        case records = "Records"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRecordCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .failedRecordCount)
        failedRecordCount = failedRecordCountDecoded
        let recordsContainer = try containerValues.decodeIfPresent([PutRecordsResultEntry?].self, forKey: .records)
        var recordsDecoded0:[PutRecordsResultEntry]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [PutRecordsResultEntry]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
    }
}

extension PutRecordsRequestEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case data = "Data"
        case explicitHashKey = "ExplicitHashKey"
        case partitionKey = "PartitionKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
        if let explicitHashKey = explicitHashKey {
            try encodeContainer.encode(explicitHashKey, forKey: .explicitHashKey)
        }
        if let partitionKey = partitionKey {
            try encodeContainer.encode(partitionKey, forKey: .partitionKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .data)
        data = dataDecoded
        let explicitHashKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .explicitHashKey)
        explicitHashKey = explicitHashKeyDecoded
        let partitionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partitionKey)
        partitionKey = partitionKeyDecoded
    }
}

extension PutRecordsRequestEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRecordsRequestEntry(data: \(String(describing: data)), explicitHashKey: \(String(describing: explicitHashKey)), partitionKey: \(String(describing: partitionKey)))"}
}

/// <p>Represents the output for <code>PutRecords</code>.</p>
public struct PutRecordsRequestEntry: Equatable {
    /// <p>The data blob to put into the record, which is base64-encoded when the blob is
    ///             serialized. When the data blob (the payload before base64-encoding) is added to the
    ///             partition key size, the total size must not exceed the maximum record size (1
    ///             MiB).</p>
    public let data: Data?
    /// <p>The hash value used to determine explicitly the shard that the data record is
    ///             assigned to by overriding the partition key hash.</p>
    public let explicitHashKey: String?
    /// <p>Determines which shard in the stream the data record is assigned to. Partition keys
    ///             are Unicode strings with a maximum length limit of 256 characters for each key. Amazon
    ///             Kinesis Data Streams uses the partition key as input to a hash function that maps the
    ///             partition key and associated data to a specific shard. Specifically, an MD5 hash
    ///             function is used to map partition keys to 128-bit integer values and to map associated
    ///             data records to shards. As a result of this hashing mechanism, all data records with the
    ///             same partition key map to the same shard within the stream.</p>
    public let partitionKey: String?

    public init (
        data: Data? = nil,
        explicitHashKey: String? = nil,
        partitionKey: String? = nil
    )
    {
        self.data = data
        self.explicitHashKey = explicitHashKey
        self.partitionKey = partitionKey
    }
}

extension PutRecordsResultEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case sequenceNumber = "SequenceNumber"
        case shardId = "ShardId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let sequenceNumber = sequenceNumber {
            try encodeContainer.encode(sequenceNumber, forKey: .sequenceNumber)
        }
        if let shardId = shardId {
            try encodeContainer.encode(shardId, forKey: .shardId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sequenceNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sequenceNumber)
        sequenceNumber = sequenceNumberDecoded
        let shardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shardId)
        shardId = shardIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension PutRecordsResultEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRecordsResultEntry(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), sequenceNumber: \(String(describing: sequenceNumber)), shardId: \(String(describing: shardId)))"}
}

/// <p>Represents the result of an individual record from a <code>PutRecords</code>
///             request. A record that is successfully added to a stream includes
///                 <code>SequenceNumber</code> and <code>ShardId</code> in the result. A record that
///             fails to be added to the stream includes <code>ErrorCode</code> and
///                 <code>ErrorMessage</code> in the result.</p>
public struct PutRecordsResultEntry: Equatable {
    /// <p>The error code for an individual record result. <code>ErrorCodes</code> can be
    ///             either <code>ProvisionedThroughputExceededException</code> or
    ///                 <code>InternalFailure</code>.</p>
    public let errorCode: String?
    /// <p>The error message for an individual record result. An <code>ErrorCode</code> value
    ///             of <code>ProvisionedThroughputExceededException</code> has an error message that
    ///             includes the account ID, stream name, and shard ID. An <code>ErrorCode</code> value of
    ///                 <code>InternalFailure</code> has the error message <code>"Internal Service
    ///                 Failure"</code>.</p>
    public let errorMessage: String?
    /// <p>The sequence number for an individual record result.</p>
    public let sequenceNumber: String?
    /// <p>The shard ID for an individual record result.</p>
    public let shardId: String?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil,
        sequenceNumber: String? = nil,
        shardId: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.sequenceNumber = sequenceNumber
        self.shardId = shardId
    }
}

extension Record: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approximateArrivalTimestamp = "ApproximateArrivalTimestamp"
        case data = "Data"
        case encryptionType = "EncryptionType"
        case partitionKey = "PartitionKey"
        case sequenceNumber = "SequenceNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approximateArrivalTimestamp = approximateArrivalTimestamp {
            try encodeContainer.encode(approximateArrivalTimestamp.timeIntervalSince1970, forKey: .approximateArrivalTimestamp)
        }
        if let data = data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let partitionKey = partitionKey {
            try encodeContainer.encode(partitionKey, forKey: .partitionKey)
        }
        if let sequenceNumber = sequenceNumber {
            try encodeContainer.encode(sequenceNumber, forKey: .sequenceNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sequenceNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sequenceNumber)
        sequenceNumber = sequenceNumberDecoded
        let approximateArrivalTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .approximateArrivalTimestamp)
        approximateArrivalTimestamp = approximateArrivalTimestampDecoded
        let dataDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .data)
        data = dataDecoded
        let partitionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partitionKey)
        partitionKey = partitionKeyDecoded
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
    }
}

extension Record: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Record(approximateArrivalTimestamp: \(String(describing: approximateArrivalTimestamp)), data: \(String(describing: data)), encryptionType: \(String(describing: encryptionType)), partitionKey: \(String(describing: partitionKey)), sequenceNumber: \(String(describing: sequenceNumber)))"}
}

/// <p>The unit of data of the Kinesis data stream, which is composed of a sequence
///             number, a partition key, and a data blob.</p>
public struct Record: Equatable {
    /// <p>The approximate time that the record was inserted into the stream.</p>
    public let approximateArrivalTimestamp: Date?
    /// <p>The data blob. The data in the blob is both opaque and immutable to Kinesis Data
    ///             Streams, which does not inspect, interpret, or change the data in the blob in any way.
    ///             When the data blob (the payload before base64-encoding) is added to the partition key
    ///             size, the total size must not exceed the maximum record size (1 MiB).</p>
    public let data: Data?
    /// <p>The encryption type used on the record. This parameter can be one of the following
    ///             values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>NONE</code>: Do not encrypt the records in the stream.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>KMS</code>: Use server-side encryption on the records in the stream
    ///                     using a customer-managed AWS KMS key.</p>
    ///             </li>
    ///          </ul>
    public let encryptionType: EncryptionType?
    /// <p>Identifies which shard in the stream the data record is assigned to.</p>
    public let partitionKey: String?
    /// <p>The unique identifier of the record within its shard.</p>
    public let sequenceNumber: String?

    public init (
        approximateArrivalTimestamp: Date? = nil,
        data: Data? = nil,
        encryptionType: EncryptionType? = nil,
        partitionKey: String? = nil,
        sequenceNumber: String? = nil
    )
    {
        self.approximateArrivalTimestamp = approximateArrivalTimestamp
        self.data = data
        self.encryptionType = encryptionType
        self.partitionKey = partitionKey
        self.sequenceNumber = sequenceNumber
    }
}

public struct RegisterStreamConsumerInputBodyMiddleware: Middleware {
    public let id: String = "RegisterStreamConsumerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterStreamConsumerInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterStreamConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterStreamConsumerInput>
    public typealias MOutput = OperationOutput<RegisterStreamConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterStreamConsumerOutputError>
}

extension RegisterStreamConsumerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterStreamConsumerInput(consumerName: \(String(describing: consumerName)), streamARN: \(String(describing: streamARN)))"}
}

extension RegisterStreamConsumerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case consumerName = "ConsumerName"
        case streamARN = "StreamARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumerName = consumerName {
            try encodeContainer.encode(consumerName, forKey: .consumerName)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
    }
}

public struct RegisterStreamConsumerInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterStreamConsumerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterStreamConsumerInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterStreamConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterStreamConsumerInput>
    public typealias MOutput = OperationOutput<RegisterStreamConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterStreamConsumerOutputError>
}

public struct RegisterStreamConsumerInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterStreamConsumerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterStreamConsumerInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterStreamConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterStreamConsumerInput>
    public typealias MOutput = OperationOutput<RegisterStreamConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterStreamConsumerOutputError>
}

public struct RegisterStreamConsumerInput: Equatable {
    /// <p>For a given Kinesis data stream, each consumer must have a unique name. However,
    ///             consumer names don't have to be unique across data streams.</p>
    public let consumerName: String?
    /// <p>The ARN of the Kinesis data stream that you want to register the consumer with. For
    ///             more info, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
    public let streamARN: String?

    public init (
        consumerName: String? = nil,
        streamARN: String? = nil
    )
    {
        self.consumerName = consumerName
        self.streamARN = streamARN
    }
}

struct RegisterStreamConsumerInputBody: Equatable {
    public let streamARN: String?
    public let consumerName: String?
}

extension RegisterStreamConsumerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case consumerName = "ConsumerName"
        case streamARN = "StreamARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let consumerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .consumerName)
        consumerName = consumerNameDecoded
    }
}

extension RegisterStreamConsumerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterStreamConsumerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterStreamConsumerOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterStreamConsumerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterStreamConsumerOutputResponse(consumer: \(String(describing: consumer)))"}
}

extension RegisterStreamConsumerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterStreamConsumerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.consumer = output.consumer
        } else {
            self.consumer = nil
        }
    }
}

public struct RegisterStreamConsumerOutputResponse: Equatable {
    /// <p>An object that represents the details of the consumer you registered. When you
    ///             register a consumer, it gets an ARN that is generated by Kinesis Data Streams.</p>
    public let consumer: Consumer?

    public init (
        consumer: Consumer? = nil
    )
    {
        self.consumer = consumer
    }
}

struct RegisterStreamConsumerOutputResponseBody: Equatable {
    public let consumer: Consumer?
}

extension RegisterStreamConsumerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case consumer = "Consumer"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consumerDecoded = try containerValues.decodeIfPresent(Consumer.self, forKey: .consumer)
        consumer = consumerDecoded
    }
}

public struct RemoveTagsFromStreamInputBodyMiddleware: Middleware {
    public let id: String = "RemoveTagsFromStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromStreamInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromStreamOutputError>
}

extension RemoveTagsFromStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsFromStreamInput(streamName: \(String(describing: streamName)), tagKeys: \(String(describing: tagKeys)))"}
}

extension RemoveTagsFromStreamInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case streamName = "StreamName"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct RemoveTagsFromStreamInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveTagsFromStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromStreamInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromStreamOutputError>
}

public struct RemoveTagsFromStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveTagsFromStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromStreamInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromStreamOutputError>
}

/// <p>Represents the input for <code>RemoveTagsFromStream</code>.</p>
public struct RemoveTagsFromStreamInput: Equatable {
    /// <p>The name of the stream.</p>
    public let streamName: String?
    /// <p>A list of tag keys. Each corresponding tag is removed from the stream.</p>
    public let tagKeys: [String]?

    public init (
        streamName: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.streamName = streamName
        self.tagKeys = tagKeys
    }
}

struct RemoveTagsFromStreamInputBody: Equatable {
    public let streamName: String?
    public let tagKeys: [String]?
}

extension RemoveTagsFromStreamInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamName = "StreamName"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension RemoveTagsFromStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTagsFromStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsFromStreamOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsFromStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsFromStreamOutputResponse()"}
}

extension RemoveTagsFromStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveTagsFromStreamOutputResponse: Equatable {

    public init() {}
}

struct RemoveTagsFromStreamOutputResponseBody: Equatable {
}

extension RemoveTagsFromStreamOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ResourceInUseException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource is not available for this operation. For successful operation, the
///             resource must be in the <code>ACTIVE</code> state.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message that provides information about the error.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested resource could not be found. The stream might not be specified
///             correctly.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message that provides information about the error.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ScalingType {
    case uniformScaling
    case sdkUnknown(String)
}

extension ScalingType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ScalingType] {
        return [
            .uniformScaling,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .uniformScaling: return "UNIFORM_SCALING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ScalingType(rawValue: rawValue) ?? ScalingType.sdkUnknown(rawValue)
    }
}

extension SequenceNumberRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endingSequenceNumber = "EndingSequenceNumber"
        case startingSequenceNumber = "StartingSequenceNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endingSequenceNumber = endingSequenceNumber {
            try encodeContainer.encode(endingSequenceNumber, forKey: .endingSequenceNumber)
        }
        if let startingSequenceNumber = startingSequenceNumber {
            try encodeContainer.encode(startingSequenceNumber, forKey: .startingSequenceNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startingSequenceNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startingSequenceNumber)
        startingSequenceNumber = startingSequenceNumberDecoded
        let endingSequenceNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endingSequenceNumber)
        endingSequenceNumber = endingSequenceNumberDecoded
    }
}

extension SequenceNumberRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SequenceNumberRange(endingSequenceNumber: \(String(describing: endingSequenceNumber)), startingSequenceNumber: \(String(describing: startingSequenceNumber)))"}
}

/// <p>The range of possible sequence numbers for the shard.</p>
public struct SequenceNumberRange: Equatable {
    /// <p>The ending sequence number for the range. Shards that are in the OPEN state have an
    ///             ending sequence number of <code>null</code>.</p>
    public let endingSequenceNumber: String?
    /// <p>The starting sequence number for the range.</p>
    public let startingSequenceNumber: String?

    public init (
        endingSequenceNumber: String? = nil,
        startingSequenceNumber: String? = nil
    )
    {
        self.endingSequenceNumber = endingSequenceNumber
        self.startingSequenceNumber = startingSequenceNumber
    }
}

extension Shard: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adjacentParentShardId = "AdjacentParentShardId"
        case hashKeyRange = "HashKeyRange"
        case parentShardId = "ParentShardId"
        case sequenceNumberRange = "SequenceNumberRange"
        case shardId = "ShardId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adjacentParentShardId = adjacentParentShardId {
            try encodeContainer.encode(adjacentParentShardId, forKey: .adjacentParentShardId)
        }
        if let hashKeyRange = hashKeyRange {
            try encodeContainer.encode(hashKeyRange, forKey: .hashKeyRange)
        }
        if let parentShardId = parentShardId {
            try encodeContainer.encode(parentShardId, forKey: .parentShardId)
        }
        if let sequenceNumberRange = sequenceNumberRange {
            try encodeContainer.encode(sequenceNumberRange, forKey: .sequenceNumberRange)
        }
        if let shardId = shardId {
            try encodeContainer.encode(shardId, forKey: .shardId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shardId)
        shardId = shardIdDecoded
        let parentShardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentShardId)
        parentShardId = parentShardIdDecoded
        let adjacentParentShardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adjacentParentShardId)
        adjacentParentShardId = adjacentParentShardIdDecoded
        let hashKeyRangeDecoded = try containerValues.decodeIfPresent(HashKeyRange.self, forKey: .hashKeyRange)
        hashKeyRange = hashKeyRangeDecoded
        let sequenceNumberRangeDecoded = try containerValues.decodeIfPresent(SequenceNumberRange.self, forKey: .sequenceNumberRange)
        sequenceNumberRange = sequenceNumberRangeDecoded
    }
}

extension Shard: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Shard(adjacentParentShardId: \(String(describing: adjacentParentShardId)), hashKeyRange: \(String(describing: hashKeyRange)), parentShardId: \(String(describing: parentShardId)), sequenceNumberRange: \(String(describing: sequenceNumberRange)), shardId: \(String(describing: shardId)))"}
}

/// <p>A uniquely identified group of data records in a Kinesis data stream.</p>
public struct Shard: Equatable {
    /// <p>The shard ID of the shard adjacent to the shard's parent.</p>
    public let adjacentParentShardId: String?
    /// <p>The range of possible hash key values for the shard, which is a set of ordered
    ///             contiguous positive integers.</p>
    public let hashKeyRange: HashKeyRange?
    /// <p>The shard ID of the shard's parent.</p>
    public let parentShardId: String?
    /// <p>The range of possible sequence numbers for the shard.</p>
    public let sequenceNumberRange: SequenceNumberRange?
    /// <p>The unique identifier of the shard within the stream.</p>
    public let shardId: String?

    public init (
        adjacentParentShardId: String? = nil,
        hashKeyRange: HashKeyRange? = nil,
        parentShardId: String? = nil,
        sequenceNumberRange: SequenceNumberRange? = nil,
        shardId: String? = nil
    )
    {
        self.adjacentParentShardId = adjacentParentShardId
        self.hashKeyRange = hashKeyRange
        self.parentShardId = parentShardId
        self.sequenceNumberRange = sequenceNumberRange
        self.shardId = shardId
    }
}

extension ShardFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case shardId = "ShardId"
        case timestamp = "Timestamp"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shardId = shardId {
            try encodeContainer.encode(shardId, forKey: .shardId)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ShardFilterType.self, forKey: .type)
        type = typeDecoded
        let shardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shardId)
        shardId = shardIdDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension ShardFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ShardFilter(shardId: \(String(describing: shardId)), timestamp: \(String(describing: timestamp)), type: \(String(describing: type)))"}
}

public struct ShardFilter: Equatable {
    public let shardId: String?
    public let timestamp: Date?
    public let type: ShardFilterType?

    public init (
        shardId: String? = nil,
        timestamp: Date? = nil,
        type: ShardFilterType? = nil
    )
    {
        self.shardId = shardId
        self.timestamp = timestamp
        self.type = type
    }
}

public enum ShardFilterType {
    case afterShardId
    case atLatest
    case atTimestamp
    case atTrimHorizon
    case fromTimestamp
    case fromTrimHorizon
    case sdkUnknown(String)
}

extension ShardFilterType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ShardFilterType] {
        return [
            .afterShardId,
            .atLatest,
            .atTimestamp,
            .atTrimHorizon,
            .fromTimestamp,
            .fromTrimHorizon,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .afterShardId: return "AFTER_SHARD_ID"
        case .atLatest: return "AT_LATEST"
        case .atTimestamp: return "AT_TIMESTAMP"
        case .atTrimHorizon: return "AT_TRIM_HORIZON"
        case .fromTimestamp: return "FROM_TIMESTAMP"
        case .fromTrimHorizon: return "FROM_TRIM_HORIZON"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ShardFilterType(rawValue: rawValue) ?? ShardFilterType.sdkUnknown(rawValue)
    }
}

public enum ShardIteratorType {
    case afterSequenceNumber
    case atSequenceNumber
    case atTimestamp
    case latest
    case trimHorizon
    case sdkUnknown(String)
}

extension ShardIteratorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ShardIteratorType] {
        return [
            .afterSequenceNumber,
            .atSequenceNumber,
            .atTimestamp,
            .latest,
            .trimHorizon,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .afterSequenceNumber: return "AFTER_SEQUENCE_NUMBER"
        case .atSequenceNumber: return "AT_SEQUENCE_NUMBER"
        case .atTimestamp: return "AT_TIMESTAMP"
        case .latest: return "LATEST"
        case .trimHorizon: return "TRIM_HORIZON"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ShardIteratorType(rawValue: rawValue) ?? ShardIteratorType.sdkUnknown(rawValue)
    }
}

public struct SplitShardInputBodyMiddleware: Middleware {
    public let id: String = "SplitShardInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SplitShardInput>,
                  next: H) -> Swift.Result<OperationOutput<SplitShardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SplitShardInput>
    public typealias MOutput = OperationOutput<SplitShardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SplitShardOutputError>
}

extension SplitShardInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SplitShardInput(newStartingHashKey: \(String(describing: newStartingHashKey)), shardToSplit: \(String(describing: shardToSplit)), streamName: \(String(describing: streamName)))"}
}

extension SplitShardInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case newStartingHashKey = "NewStartingHashKey"
        case shardToSplit = "ShardToSplit"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let newStartingHashKey = newStartingHashKey {
            try encodeContainer.encode(newStartingHashKey, forKey: .newStartingHashKey)
        }
        if let shardToSplit = shardToSplit {
            try encodeContainer.encode(shardToSplit, forKey: .shardToSplit)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct SplitShardInputHeadersMiddleware: Middleware {
    public let id: String = "SplitShardInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SplitShardInput>,
                  next: H) -> Swift.Result<OperationOutput<SplitShardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SplitShardInput>
    public typealias MOutput = OperationOutput<SplitShardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SplitShardOutputError>
}

public struct SplitShardInputQueryItemMiddleware: Middleware {
    public let id: String = "SplitShardInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SplitShardInput>,
                  next: H) -> Swift.Result<OperationOutput<SplitShardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SplitShardInput>
    public typealias MOutput = OperationOutput<SplitShardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SplitShardOutputError>
}

/// <p>Represents the input for <code>SplitShard</code>.</p>
public struct SplitShardInput: Equatable {
    /// <p>A hash key value for the starting hash key of one of the child shards created by
    ///             the split. The hash key range for a given shard constitutes a set of ordered contiguous
    ///             positive integers. The value for <code>NewStartingHashKey</code> must be in the range of
    ///             hash keys being mapped into the shard. The <code>NewStartingHashKey</code> hash key
    ///             value and all higher hash key values in hash key range are distributed to one of the
    ///             child shards. All the lower hash key values in the range are distributed to the other
    ///             child shard.</p>
    public let newStartingHashKey: String?
    /// <p>The shard ID of the shard to split.</p>
    public let shardToSplit: String?
    /// <p>The name of the stream for the shard split.</p>
    public let streamName: String?

    public init (
        newStartingHashKey: String? = nil,
        shardToSplit: String? = nil,
        streamName: String? = nil
    )
    {
        self.newStartingHashKey = newStartingHashKey
        self.shardToSplit = shardToSplit
        self.streamName = streamName
    }
}

struct SplitShardInputBody: Equatable {
    public let streamName: String?
    public let shardToSplit: String?
    public let newStartingHashKey: String?
}

extension SplitShardInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case newStartingHashKey = "NewStartingHashKey"
        case shardToSplit = "ShardToSplit"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let shardToSplitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shardToSplit)
        shardToSplit = shardToSplitDecoded
        let newStartingHashKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .newStartingHashKey)
        newStartingHashKey = newStartingHashKeyDecoded
    }
}

extension SplitShardOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SplitShardOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SplitShardOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SplitShardOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SplitShardOutputResponse()"}
}

extension SplitShardOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SplitShardOutputResponse: Equatable {

    public init() {}
}

struct SplitShardOutputResponseBody: Equatable {
}

extension SplitShardOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StartStreamEncryptionInputBodyMiddleware: Middleware {
    public let id: String = "StartStreamEncryptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartStreamEncryptionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartStreamEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartStreamEncryptionInput>
    public typealias MOutput = OperationOutput<StartStreamEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartStreamEncryptionOutputError>
}

extension StartStreamEncryptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartStreamEncryptionInput(encryptionType: \(String(describing: encryptionType)), keyId: \(String(describing: keyId)), streamName: \(String(describing: streamName)))"}
}

extension StartStreamEncryptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionType = "EncryptionType"
        case keyId = "KeyId"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct StartStreamEncryptionInputHeadersMiddleware: Middleware {
    public let id: String = "StartStreamEncryptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartStreamEncryptionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartStreamEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartStreamEncryptionInput>
    public typealias MOutput = OperationOutput<StartStreamEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartStreamEncryptionOutputError>
}

public struct StartStreamEncryptionInputQueryItemMiddleware: Middleware {
    public let id: String = "StartStreamEncryptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartStreamEncryptionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartStreamEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartStreamEncryptionInput>
    public typealias MOutput = OperationOutput<StartStreamEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartStreamEncryptionOutputError>
}

public struct StartStreamEncryptionInput: Equatable {
    /// <p>The encryption type to use. The only valid value is <code>KMS</code>.</p>
    public let encryptionType: EncryptionType?
    /// <p>The GUID for the customer-managed AWS KMS key to use for encryption. This value can
    ///             be a globally unique identifier, a fully specified Amazon Resource Name (ARN) to either
    ///             an alias or a key, or an alias name prefixed by "alias/".You can also use a master key
    ///             owned by Kinesis Data Streams by specifying the alias
    ///             <code>aws/kinesis</code>.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Key ARN example:
    ///                         <code>arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>Alias ARN example:
    ///                         <code>arn:aws:kms:us-east-1:123456789012:alias/MyAliasName</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>Globally unique key ID example:
    ///                         <code>12345678-1234-1234-1234-123456789012</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>Alias name example: <code>alias/MyAliasName</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>Master key owned by Kinesis Data Streams:
    ///                     <code>alias/aws/kinesis</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let keyId: String?
    /// <p>The name of the stream for which to start encrypting records.</p>
    public let streamName: String?

    public init (
        encryptionType: EncryptionType? = nil,
        keyId: String? = nil,
        streamName: String? = nil
    )
    {
        self.encryptionType = encryptionType
        self.keyId = keyId
        self.streamName = streamName
    }
}

struct StartStreamEncryptionInputBody: Equatable {
    public let streamName: String?
    public let encryptionType: EncryptionType?
    public let keyId: String?
}

extension StartStreamEncryptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case encryptionType = "EncryptionType"
        case keyId = "KeyId"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension StartStreamEncryptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartStreamEncryptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSAccessDeniedException" : self = .kMSAccessDeniedException(try KMSAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabledException" : self = .kMSDisabledException(try KMSDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFoundException" : self = .kMSNotFoundException(try KMSNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSOptInRequired" : self = .kMSOptInRequired(try KMSOptInRequired(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSThrottlingException" : self = .kMSThrottlingException(try KMSThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartStreamEncryptionOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case kMSAccessDeniedException(KMSAccessDeniedException)
    case kMSDisabledException(KMSDisabledException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case kMSNotFoundException(KMSNotFoundException)
    case kMSOptInRequired(KMSOptInRequired)
    case kMSThrottlingException(KMSThrottlingException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartStreamEncryptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartStreamEncryptionOutputResponse()"}
}

extension StartStreamEncryptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StartStreamEncryptionOutputResponse: Equatable {

    public init() {}
}

struct StartStreamEncryptionOutputResponseBody: Equatable {
}

extension StartStreamEncryptionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StartingPosition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sequenceNumber = "SequenceNumber"
        case timestamp = "Timestamp"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sequenceNumber = sequenceNumber {
            try encodeContainer.encode(sequenceNumber, forKey: .sequenceNumber)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ShardIteratorType.self, forKey: .type)
        type = typeDecoded
        let sequenceNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sequenceNumber)
        sequenceNumber = sequenceNumberDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension StartingPosition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartingPosition(sequenceNumber: \(String(describing: sequenceNumber)), timestamp: \(String(describing: timestamp)), type: \(String(describing: type)))"}
}

/// <p></p>
public struct StartingPosition: Equatable {
    /// <p>The sequence number of the data record in the shard from which to start streaming. To
    ///             specify a sequence number, set <code>StartingPosition</code> to
    ///                 <code>AT_SEQUENCE_NUMBER</code> or <code>AFTER_SEQUENCE_NUMBER</code>.</p>
    public let sequenceNumber: String?
    /// <p>The time stamp of the data record from which to start reading. To specify a time
    ///             stamp, set <code>StartingPosition</code> to <code>Type AT_TIMESTAMP</code>. A time stamp
    ///             is the Unix epoch date with precision in milliseconds. For example,
    ///                 <code>2016-04-04T19:58:46.480-00:00</code> or <code>1459799926.480</code>. If a
    ///             record with this exact time stamp does not exist, records will be streamed from the next
    ///             (later) record. If the time stamp is older than the current trim horizon, records will
    ///             be streamed from the oldest untrimmed data record (<code>TRIM_HORIZON</code>).</p>
    public let timestamp: Date?
    /// <p>You can set the starting position to one of the following values:</p>
    ///         <p>
    ///             <code>AT_SEQUENCE_NUMBER</code>: Start streaming from the position denoted by the
    ///             sequence number specified in the <code>SequenceNumber</code> field.</p>
    ///         <p>
    ///             <code>AFTER_SEQUENCE_NUMBER</code>: Start streaming right after the position denoted
    ///             by the sequence number specified in the <code>SequenceNumber</code> field.</p>
    ///         <p>
    ///             <code>AT_TIMESTAMP</code>: Start streaming from the position denoted by the time stamp
    ///             specified in the <code>Timestamp</code> field.</p>
    ///         <p>
    ///             <code>TRIM_HORIZON</code>: Start streaming at the last untrimmed record in the shard,
    ///             which is the oldest data record in the shard.</p>
    ///         <p>
    ///             <code>LATEST</code>: Start streaming just after the most recent record in the shard,
    ///             so that you always read the most recent data in the shard.</p>
    public let type: ShardIteratorType?

    public init (
        sequenceNumber: String? = nil,
        timestamp: Date? = nil,
        type: ShardIteratorType? = nil
    )
    {
        self.sequenceNumber = sequenceNumber
        self.timestamp = timestamp
        self.type = type
    }
}

public struct StopStreamEncryptionInputBodyMiddleware: Middleware {
    public let id: String = "StopStreamEncryptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopStreamEncryptionInput>,
                  next: H) -> Swift.Result<OperationOutput<StopStreamEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopStreamEncryptionInput>
    public typealias MOutput = OperationOutput<StopStreamEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopStreamEncryptionOutputError>
}

extension StopStreamEncryptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopStreamEncryptionInput(encryptionType: \(String(describing: encryptionType)), keyId: \(String(describing: keyId)), streamName: \(String(describing: streamName)))"}
}

extension StopStreamEncryptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionType = "EncryptionType"
        case keyId = "KeyId"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct StopStreamEncryptionInputHeadersMiddleware: Middleware {
    public let id: String = "StopStreamEncryptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopStreamEncryptionInput>,
                  next: H) -> Swift.Result<OperationOutput<StopStreamEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopStreamEncryptionInput>
    public typealias MOutput = OperationOutput<StopStreamEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopStreamEncryptionOutputError>
}

public struct StopStreamEncryptionInputQueryItemMiddleware: Middleware {
    public let id: String = "StopStreamEncryptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopStreamEncryptionInput>,
                  next: H) -> Swift.Result<OperationOutput<StopStreamEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopStreamEncryptionInput>
    public typealias MOutput = OperationOutput<StopStreamEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopStreamEncryptionOutputError>
}

public struct StopStreamEncryptionInput: Equatable {
    /// <p>The encryption type. The only valid value is <code>KMS</code>.</p>
    public let encryptionType: EncryptionType?
    /// <p>The GUID for the customer-managed AWS KMS key to use for encryption. This value can
    ///             be a globally unique identifier, a fully specified Amazon Resource Name (ARN) to either
    ///             an alias or a key, or an alias name prefixed by "alias/".You can also use a master key
    ///             owned by Kinesis Data Streams by specifying the alias
    ///             <code>aws/kinesis</code>.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Key ARN example:
    ///                         <code>arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>Alias ARN example:
    ///                         <code>arn:aws:kms:us-east-1:123456789012:alias/MyAliasName</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>Globally unique key ID example:
    ///                         <code>12345678-1234-1234-1234-123456789012</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>Alias name example: <code>alias/MyAliasName</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>Master key owned by Kinesis Data Streams:
    ///                     <code>alias/aws/kinesis</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let keyId: String?
    /// <p>The name of the stream on which to stop encrypting records.</p>
    public let streamName: String?

    public init (
        encryptionType: EncryptionType? = nil,
        keyId: String? = nil,
        streamName: String? = nil
    )
    {
        self.encryptionType = encryptionType
        self.keyId = keyId
        self.streamName = streamName
    }
}

struct StopStreamEncryptionInputBody: Equatable {
    public let streamName: String?
    public let encryptionType: EncryptionType?
    public let keyId: String?
}

extension StopStreamEncryptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case encryptionType = "EncryptionType"
        case keyId = "KeyId"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension StopStreamEncryptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopStreamEncryptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopStreamEncryptionOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopStreamEncryptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopStreamEncryptionOutputResponse()"}
}

extension StopStreamEncryptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopStreamEncryptionOutputResponse: Equatable {

    public init() {}
}

struct StopStreamEncryptionOutputResponseBody: Equatable {
}

extension StopStreamEncryptionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StreamDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionType = "EncryptionType"
        case enhancedMonitoring = "EnhancedMonitoring"
        case hasMoreShards = "HasMoreShards"
        case keyId = "KeyId"
        case retentionPeriodHours = "RetentionPeriodHours"
        case shards = "Shards"
        case streamARN = "StreamARN"
        case streamCreationTimestamp = "StreamCreationTimestamp"
        case streamName = "StreamName"
        case streamStatus = "StreamStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let enhancedMonitoring = enhancedMonitoring {
            var enhancedMonitoringContainer = encodeContainer.nestedUnkeyedContainer(forKey: .enhancedMonitoring)
            for enhancedmonitoringlist0 in enhancedMonitoring {
                try enhancedMonitoringContainer.encode(enhancedmonitoringlist0)
            }
        }
        if let hasMoreShards = hasMoreShards {
            try encodeContainer.encode(hasMoreShards, forKey: .hasMoreShards)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let retentionPeriodHours = retentionPeriodHours {
            try encodeContainer.encode(retentionPeriodHours, forKey: .retentionPeriodHours)
        }
        if let shards = shards {
            var shardsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .shards)
            for shardlist0 in shards {
                try shardsContainer.encode(shardlist0)
            }
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamCreationTimestamp = streamCreationTimestamp {
            try encodeContainer.encode(streamCreationTimestamp.timeIntervalSince1970, forKey: .streamCreationTimestamp)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let streamStatus = streamStatus {
            try encodeContainer.encode(streamStatus.rawValue, forKey: .streamStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let streamStatusDecoded = try containerValues.decodeIfPresent(StreamStatus.self, forKey: .streamStatus)
        streamStatus = streamStatusDecoded
        let shardsContainer = try containerValues.decodeIfPresent([Shard?].self, forKey: .shards)
        var shardsDecoded0:[Shard]? = nil
        if let shardsContainer = shardsContainer {
            shardsDecoded0 = [Shard]()
            for structure0 in shardsContainer {
                if let structure0 = structure0 {
                    shardsDecoded0?.append(structure0)
                }
            }
        }
        shards = shardsDecoded0
        let hasMoreShardsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .hasMoreShards)
        hasMoreShards = hasMoreShardsDecoded
        let retentionPeriodHoursDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .retentionPeriodHours)
        retentionPeriodHours = retentionPeriodHoursDecoded
        let streamCreationTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .streamCreationTimestamp)
        streamCreationTimestamp = streamCreationTimestampDecoded
        let enhancedMonitoringContainer = try containerValues.decodeIfPresent([EnhancedMetrics?].self, forKey: .enhancedMonitoring)
        var enhancedMonitoringDecoded0:[EnhancedMetrics]? = nil
        if let enhancedMonitoringContainer = enhancedMonitoringContainer {
            enhancedMonitoringDecoded0 = [EnhancedMetrics]()
            for structure0 in enhancedMonitoringContainer {
                if let structure0 = structure0 {
                    enhancedMonitoringDecoded0?.append(structure0)
                }
            }
        }
        enhancedMonitoring = enhancedMonitoringDecoded0
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension StreamDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamDescription(encryptionType: \(String(describing: encryptionType)), enhancedMonitoring: \(String(describing: enhancedMonitoring)), hasMoreShards: \(String(describing: hasMoreShards)), keyId: \(String(describing: keyId)), retentionPeriodHours: \(String(describing: retentionPeriodHours)), shards: \(String(describing: shards)), streamARN: \(String(describing: streamARN)), streamCreationTimestamp: \(String(describing: streamCreationTimestamp)), streamName: \(String(describing: streamName)), streamStatus: \(String(describing: streamStatus)))"}
}

/// <p>Represents the output for <a>DescribeStream</a>.</p>
public struct StreamDescription: Equatable {
    /// <p>The server-side encryption type used on the stream. This parameter can be one of
    ///             the following values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>NONE</code>: Do not encrypt the records in the stream.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>KMS</code>: Use server-side encryption on the records in the stream
    ///                     using a customer-managed AWS KMS key.</p>
    ///             </li>
    ///          </ul>
    public let encryptionType: EncryptionType?
    /// <p>Represents the current enhanced monitoring settings of the stream.</p>
    public let enhancedMonitoring: [EnhancedMetrics]?
    /// <p>If set to <code>true</code>, more shards in the stream are available to
    ///             describe.</p>
    public let hasMoreShards: Bool?
    /// <p>The GUID for the customer-managed AWS KMS key to use for encryption. This value can
    ///             be a globally unique identifier, a fully specified ARN to either an alias or a key, or
    ///             an alias name prefixed by "alias/".You can also use a master key owned by Kinesis Data
    ///             Streams by specifying the alias <code>aws/kinesis</code>.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Key ARN example:
    ///                         <code>arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>Alias ARN example:
    ///                         <code>arn:aws:kms:us-east-1:123456789012:alias/MyAliasName</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>Globally unique key ID example:
    ///                         <code>12345678-1234-1234-1234-123456789012</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>Alias name example: <code>alias/MyAliasName</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>Master key owned by Kinesis Data Streams:
    ///                     <code>alias/aws/kinesis</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let keyId: String?
    /// <p>The current retention period, in hours. Minimum value of 24. Maximum value of
    ///             168.</p>
    public let retentionPeriodHours: Int?
    /// <p>The shards that comprise the stream.</p>
    public let shards: [Shard]?
    /// <p>The Amazon Resource Name (ARN) for the stream being described.</p>
    public let streamARN: String?
    /// <p>The approximate time that the stream was created.</p>
    public let streamCreationTimestamp: Date?
    /// <p>The name of the stream being described.</p>
    public let streamName: String?
    /// <p>The current status of the stream being described. The stream status is one of the
    ///             following states:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>CREATING</code> - The stream is being created. Kinesis Data Streams
    ///                     immediately returns and sets <code>StreamStatus</code> to
    ///                     <code>CREATING</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>DELETING</code> - The stream is being deleted. The specified stream is in
    ///                     the <code>DELETING</code> state until Kinesis Data Streams completes the
    ///                     deletion.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>ACTIVE</code> - The stream exists and is ready for read and write
    ///                     operations or deletion. You should perform read and write operations only on an
    ///                         <code>ACTIVE</code> stream.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>UPDATING</code> - Shards in the stream are being merged or split. Read and
    ///                     write operations continue to work while the stream is in the
    ///                         <code>UPDATING</code> state.</p>
    ///             </li>
    ///          </ul>
    public let streamStatus: StreamStatus?

    public init (
        encryptionType: EncryptionType? = nil,
        enhancedMonitoring: [EnhancedMetrics]? = nil,
        hasMoreShards: Bool? = nil,
        keyId: String? = nil,
        retentionPeriodHours: Int? = nil,
        shards: [Shard]? = nil,
        streamARN: String? = nil,
        streamCreationTimestamp: Date? = nil,
        streamName: String? = nil,
        streamStatus: StreamStatus? = nil
    )
    {
        self.encryptionType = encryptionType
        self.enhancedMonitoring = enhancedMonitoring
        self.hasMoreShards = hasMoreShards
        self.keyId = keyId
        self.retentionPeriodHours = retentionPeriodHours
        self.shards = shards
        self.streamARN = streamARN
        self.streamCreationTimestamp = streamCreationTimestamp
        self.streamName = streamName
        self.streamStatus = streamStatus
    }
}

extension StreamDescriptionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case consumerCount = "ConsumerCount"
        case encryptionType = "EncryptionType"
        case enhancedMonitoring = "EnhancedMonitoring"
        case keyId = "KeyId"
        case openShardCount = "OpenShardCount"
        case retentionPeriodHours = "RetentionPeriodHours"
        case streamARN = "StreamARN"
        case streamCreationTimestamp = "StreamCreationTimestamp"
        case streamName = "StreamName"
        case streamStatus = "StreamStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumerCount = consumerCount {
            try encodeContainer.encode(consumerCount, forKey: .consumerCount)
        }
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let enhancedMonitoring = enhancedMonitoring {
            var enhancedMonitoringContainer = encodeContainer.nestedUnkeyedContainer(forKey: .enhancedMonitoring)
            for enhancedmonitoringlist0 in enhancedMonitoring {
                try enhancedMonitoringContainer.encode(enhancedmonitoringlist0)
            }
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let openShardCount = openShardCount {
            try encodeContainer.encode(openShardCount, forKey: .openShardCount)
        }
        if let retentionPeriodHours = retentionPeriodHours {
            try encodeContainer.encode(retentionPeriodHours, forKey: .retentionPeriodHours)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamCreationTimestamp = streamCreationTimestamp {
            try encodeContainer.encode(streamCreationTimestamp.timeIntervalSince1970, forKey: .streamCreationTimestamp)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let streamStatus = streamStatus {
            try encodeContainer.encode(streamStatus.rawValue, forKey: .streamStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let streamStatusDecoded = try containerValues.decodeIfPresent(StreamStatus.self, forKey: .streamStatus)
        streamStatus = streamStatusDecoded
        let retentionPeriodHoursDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .retentionPeriodHours)
        retentionPeriodHours = retentionPeriodHoursDecoded
        let streamCreationTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .streamCreationTimestamp)
        streamCreationTimestamp = streamCreationTimestampDecoded
        let enhancedMonitoringContainer = try containerValues.decodeIfPresent([EnhancedMetrics?].self, forKey: .enhancedMonitoring)
        var enhancedMonitoringDecoded0:[EnhancedMetrics]? = nil
        if let enhancedMonitoringContainer = enhancedMonitoringContainer {
            enhancedMonitoringDecoded0 = [EnhancedMetrics]()
            for structure0 in enhancedMonitoringContainer {
                if let structure0 = structure0 {
                    enhancedMonitoringDecoded0?.append(structure0)
                }
            }
        }
        enhancedMonitoring = enhancedMonitoringDecoded0
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let openShardCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .openShardCount)
        openShardCount = openShardCountDecoded
        let consumerCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .consumerCount)
        consumerCount = consumerCountDecoded
    }
}

extension StreamDescriptionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamDescriptionSummary(consumerCount: \(String(describing: consumerCount)), encryptionType: \(String(describing: encryptionType)), enhancedMonitoring: \(String(describing: enhancedMonitoring)), keyId: \(String(describing: keyId)), openShardCount: \(String(describing: openShardCount)), retentionPeriodHours: \(String(describing: retentionPeriodHours)), streamARN: \(String(describing: streamARN)), streamCreationTimestamp: \(String(describing: streamCreationTimestamp)), streamName: \(String(describing: streamName)), streamStatus: \(String(describing: streamStatus)))"}
}

/// <p>Represents the output for <a>DescribeStreamSummary</a>
///          </p>
public struct StreamDescriptionSummary: Equatable {
    /// <p>The number of enhanced fan-out consumers registered with the stream.</p>
    public let consumerCount: Int?
    /// <p>The encryption type used. This value is one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>KMS</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>NONE</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let encryptionType: EncryptionType?
    /// <p>Represents the current enhanced monitoring settings of the stream.</p>
    public let enhancedMonitoring: [EnhancedMetrics]?
    /// <p>The GUID for the customer-managed AWS KMS key to use for encryption. This value can
    ///             be a globally unique identifier, a fully specified ARN to either an alias or a key, or
    ///             an alias name prefixed by "alias/".You can also use a master key owned by Kinesis Data
    ///             Streams by specifying the alias <code>aws/kinesis</code>.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Key ARN example:
    ///                         <code>arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>Alias ARN example: <code>
    ///                         arn:aws:kms:us-east-1:123456789012:alias/MyAliasName</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>Globally unique key ID example:
    ///                         <code>12345678-1234-1234-1234-123456789012</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>Alias name example: <code>alias/MyAliasName</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>Master key owned by Kinesis Data Streams:
    ///                     <code>alias/aws/kinesis</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let keyId: String?
    /// <p>The number of open shards in the stream.</p>
    public let openShardCount: Int?
    /// <p>The current retention period, in hours.</p>
    public let retentionPeriodHours: Int?
    /// <p>The Amazon Resource Name (ARN) for the stream being described.</p>
    public let streamARN: String?
    /// <p>The approximate time that the stream was created.</p>
    public let streamCreationTimestamp: Date?
    /// <p>The name of the stream being described.</p>
    public let streamName: String?
    /// <p>The current status of the stream being described. The stream status is one of the
    ///             following states:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>CREATING</code> - The stream is being created. Kinesis Data Streams
    ///                     immediately returns and sets <code>StreamStatus</code> to
    ///                     <code>CREATING</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>DELETING</code> - The stream is being deleted. The specified stream is in
    ///                     the <code>DELETING</code> state until Kinesis Data Streams completes the
    ///                     deletion.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>ACTIVE</code> - The stream exists and is ready for read and write
    ///                     operations or deletion. You should perform read and write operations only on an
    ///                         <code>ACTIVE</code> stream.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>UPDATING</code> - Shards in the stream are being merged or split. Read and
    ///                     write operations continue to work while the stream is in the
    ///                         <code>UPDATING</code> state.</p>
    ///             </li>
    ///          </ul>
    public let streamStatus: StreamStatus?

    public init (
        consumerCount: Int? = nil,
        encryptionType: EncryptionType? = nil,
        enhancedMonitoring: [EnhancedMetrics]? = nil,
        keyId: String? = nil,
        openShardCount: Int? = nil,
        retentionPeriodHours: Int? = nil,
        streamARN: String? = nil,
        streamCreationTimestamp: Date? = nil,
        streamName: String? = nil,
        streamStatus: StreamStatus? = nil
    )
    {
        self.consumerCount = consumerCount
        self.encryptionType = encryptionType
        self.enhancedMonitoring = enhancedMonitoring
        self.keyId = keyId
        self.openShardCount = openShardCount
        self.retentionPeriodHours = retentionPeriodHours
        self.streamARN = streamARN
        self.streamCreationTimestamp = streamCreationTimestamp
        self.streamName = streamName
        self.streamStatus = streamStatus
    }
}

public enum StreamStatus {
    case active
    case creating
    case deleting
    case updating
    case sdkUnknown(String)
}

extension StreamStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StreamStatus] {
        return [
            .active,
            .creating,
            .deleting,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StreamStatus(rawValue: rawValue) ?? StreamStatus.sdkUnknown(rawValue)
    }
}

extension SubscribeToShardEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case childShards = "ChildShards"
        case continuationSequenceNumber = "ContinuationSequenceNumber"
        case millisBehindLatest = "MillisBehindLatest"
        case records = "Records"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childShards = childShards {
            var childShardsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .childShards)
            for childshardlist0 in childShards {
                try childShardsContainer.encode(childshardlist0)
            }
        }
        if let continuationSequenceNumber = continuationSequenceNumber {
            try encodeContainer.encode(continuationSequenceNumber, forKey: .continuationSequenceNumber)
        }
        if let millisBehindLatest = millisBehindLatest {
            try encodeContainer.encode(millisBehindLatest, forKey: .millisBehindLatest)
        }
        if let records = records {
            var recordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .records)
            for recordlist0 in records {
                try recordsContainer.encode(recordlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([Record?].self, forKey: .records)
        var recordsDecoded0:[Record]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [Record]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let continuationSequenceNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .continuationSequenceNumber)
        continuationSequenceNumber = continuationSequenceNumberDecoded
        let millisBehindLatestDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .millisBehindLatest)
        millisBehindLatest = millisBehindLatestDecoded
        let childShardsContainer = try containerValues.decodeIfPresent([ChildShard?].self, forKey: .childShards)
        var childShardsDecoded0:[ChildShard]? = nil
        if let childShardsContainer = childShardsContainer {
            childShardsDecoded0 = [ChildShard]()
            for structure0 in childShardsContainer {
                if let structure0 = structure0 {
                    childShardsDecoded0?.append(structure0)
                }
            }
        }
        childShards = childShardsDecoded0
    }
}

extension SubscribeToShardEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscribeToShardEvent(childShards: \(String(describing: childShards)), continuationSequenceNumber: \(String(describing: continuationSequenceNumber)), millisBehindLatest: \(String(describing: millisBehindLatest)), records: \(String(describing: records)))"}
}

/// <p>After you call <a>SubscribeToShard</a>, Kinesis Data Streams sends events
///             of this type over an HTTP/2 connection to your consumer.</p>
public struct SubscribeToShardEvent: Equatable {
    public let childShards: [ChildShard]?
    /// <p>Use this as <code>SequenceNumber</code> in the next call to <a>SubscribeToShard</a>, with <code>StartingPosition</code> set to
    ///                 <code>AT_SEQUENCE_NUMBER</code> or <code>AFTER_SEQUENCE_NUMBER</code>. Use
    ///                 <code>ContinuationSequenceNumber</code> for checkpointing because it captures your
    ///             shard progress even when no data is written to the shard.</p>
    public let continuationSequenceNumber: String?
    /// <p>The number of milliseconds the read records are from the tip of the stream, indicating
    ///             how far behind current time the consumer is. A value of zero indicates that record
    ///             processing is caught up, and there are no new records to process at this moment.</p>
    public let millisBehindLatest: Int?
    /// <p></p>
    public let records: [Record]?

    public init (
        childShards: [ChildShard]? = nil,
        continuationSequenceNumber: String? = nil,
        millisBehindLatest: Int? = nil,
        records: [Record]? = nil
    )
    {
        self.childShards = childShards
        self.continuationSequenceNumber = continuationSequenceNumber
        self.millisBehindLatest = millisBehindLatest
        self.records = records
    }
}

extension SubscribeToShardEventStream: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case internalFailureException = "InternalFailureException"
        case kMSAccessDeniedException = "KMSAccessDeniedException"
        case kMSDisabledException = "KMSDisabledException"
        case kMSInvalidStateException = "KMSInvalidStateException"
        case kMSNotFoundException = "KMSNotFoundException"
        case kMSOptInRequired = "KMSOptInRequired"
        case kMSThrottlingException = "KMSThrottlingException"
        case resourceInUseException = "ResourceInUseException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case subscribeToShardEvent = "SubscribeToShardEvent"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .internalFailureException(internalFailureException):
                if let internalFailureException = internalFailureException {
                    try container.encode(internalFailureException, forKey: .internalFailureException)
                }
            case let .kMSAccessDeniedException(kMSAccessDeniedException):
                if let kMSAccessDeniedException = kMSAccessDeniedException {
                    try container.encode(kMSAccessDeniedException, forKey: .kMSAccessDeniedException)
                }
            case let .kMSDisabledException(kMSDisabledException):
                if let kMSDisabledException = kMSDisabledException {
                    try container.encode(kMSDisabledException, forKey: .kMSDisabledException)
                }
            case let .kMSInvalidStateException(kMSInvalidStateException):
                if let kMSInvalidStateException = kMSInvalidStateException {
                    try container.encode(kMSInvalidStateException, forKey: .kMSInvalidStateException)
                }
            case let .kMSNotFoundException(kMSNotFoundException):
                if let kMSNotFoundException = kMSNotFoundException {
                    try container.encode(kMSNotFoundException, forKey: .kMSNotFoundException)
                }
            case let .kMSOptInRequired(kMSOptInRequired):
                if let kMSOptInRequired = kMSOptInRequired {
                    try container.encode(kMSOptInRequired, forKey: .kMSOptInRequired)
                }
            case let .kMSThrottlingException(kMSThrottlingException):
                if let kMSThrottlingException = kMSThrottlingException {
                    try container.encode(kMSThrottlingException, forKey: .kMSThrottlingException)
                }
            case let .resourceInUseException(resourceInUseException):
                if let resourceInUseException = resourceInUseException {
                    try container.encode(resourceInUseException, forKey: .resourceInUseException)
                }
            case let .resourceNotFoundException(resourceNotFoundException):
                if let resourceNotFoundException = resourceNotFoundException {
                    try container.encode(resourceNotFoundException, forKey: .resourceNotFoundException)
                }
            case let .subscribeToShardEvent(subscribeToShardEvent):
                if let subscribeToShardEvent = subscribeToShardEvent {
                    try container.encode(subscribeToShardEvent, forKey: .subscribeToShardEvent)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let subscribeToShardEventDecoded = try values.decodeIfPresent(SubscribeToShardEvent.self, forKey: .subscribeToShardEvent)
        if let subscribeToShardEvent = subscribeToShardEventDecoded {
            self = .subscribeToShardEvent(subscribeToShardEvent)
            return
        }
        let resourceNotFoundExceptionDecoded = try values.decodeIfPresent(ResourceNotFoundException.self, forKey: .resourceNotFoundException)
        if let resourceNotFoundException = resourceNotFoundExceptionDecoded {
            self = .resourceNotFoundException(resourceNotFoundException)
            return
        }
        let resourceInUseExceptionDecoded = try values.decodeIfPresent(ResourceInUseException.self, forKey: .resourceInUseException)
        if let resourceInUseException = resourceInUseExceptionDecoded {
            self = .resourceInUseException(resourceInUseException)
            return
        }
        let kMSDisabledExceptionDecoded = try values.decodeIfPresent(KMSDisabledException.self, forKey: .kMSDisabledException)
        if let kMSDisabledException = kMSDisabledExceptionDecoded {
            self = .kMSDisabledException(kMSDisabledException)
            return
        }
        let kMSInvalidStateExceptionDecoded = try values.decodeIfPresent(KMSInvalidStateException.self, forKey: .kMSInvalidStateException)
        if let kMSInvalidStateException = kMSInvalidStateExceptionDecoded {
            self = .kMSInvalidStateException(kMSInvalidStateException)
            return
        }
        let kMSAccessDeniedExceptionDecoded = try values.decodeIfPresent(KMSAccessDeniedException.self, forKey: .kMSAccessDeniedException)
        if let kMSAccessDeniedException = kMSAccessDeniedExceptionDecoded {
            self = .kMSAccessDeniedException(kMSAccessDeniedException)
            return
        }
        let kMSNotFoundExceptionDecoded = try values.decodeIfPresent(KMSNotFoundException.self, forKey: .kMSNotFoundException)
        if let kMSNotFoundException = kMSNotFoundExceptionDecoded {
            self = .kMSNotFoundException(kMSNotFoundException)
            return
        }
        let kMSOptInRequiredDecoded = try values.decodeIfPresent(KMSOptInRequired.self, forKey: .kMSOptInRequired)
        if let kMSOptInRequired = kMSOptInRequiredDecoded {
            self = .kMSOptInRequired(kMSOptInRequired)
            return
        }
        let kMSThrottlingExceptionDecoded = try values.decodeIfPresent(KMSThrottlingException.self, forKey: .kMSThrottlingException)
        if let kMSThrottlingException = kMSThrottlingExceptionDecoded {
            self = .kMSThrottlingException(kMSThrottlingException)
            return
        }
        let internalFailureExceptionDecoded = try values.decodeIfPresent(InternalFailureException.self, forKey: .internalFailureException)
        if let internalFailureException = internalFailureExceptionDecoded {
            self = .internalFailureException(internalFailureException)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>This is a tagged union for all of the types of events an enhanced fan-out consumer can
///             receive over HTTP/2 after a call to <a>SubscribeToShard</a>.</p>
public enum SubscribeToShardEventStream: Equatable {
    /// <p>After you call <a>SubscribeToShard</a>, Kinesis Data Streams sends events
    ///             of this type to your consumer. For an example of how to handle these events, see <a href="/streams/latest/dev/building-enhanced-consumers-api.html">Enhanced Fan-Out
    ///                 Using the Kinesis Data Streams API</a>.</p>
    case subscribeToShardEvent(SubscribeToShardEvent?)
    /// <p>The requested resource could not be found. The stream might not be specified
    ///             correctly.</p>
    case resourceNotFoundException(ResourceNotFoundException?)
    /// <p>The resource is not available for this operation. For successful operation, the
    ///             resource must be in the <code>ACTIVE</code> state.</p>
    case resourceInUseException(ResourceInUseException?)
    /// <p>The request was rejected because the specified customer master key (CMK) isn't
    ///             enabled.</p>
    case kMSDisabledException(KMSDisabledException?)
    /// <p>The request was rejected because the state of the specified resource isn't valid
    ///             for this request. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">How Key State Affects Use of a
    ///                 Customer Master Key</a> in the <i>AWS Key Management Service Developer
    ///                 Guide</i>.</p>
    case kMSInvalidStateException(KMSInvalidStateException?)
    /// <p>The ciphertext references a key that doesn't exist or that you don't have access
    ///             to.</p>
    case kMSAccessDeniedException(KMSAccessDeniedException?)
    /// <p>The request was rejected because the specified entity or resource can't be
    ///             found.</p>
    case kMSNotFoundException(KMSNotFoundException?)
    /// <p>The AWS access key ID needs a subscription for the service.</p>
    case kMSOptInRequired(KMSOptInRequired?)
    /// <p>The request was denied due to request throttling. For more information about
    ///             throttling, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/limits.html#requests-per-second">Limits</a> in
    ///             the <i>AWS Key Management Service Developer Guide</i>.</p>
    case kMSThrottlingException(KMSThrottlingException?)
    /// <p>The processing of the request failed because of an unknown error, exception, or
    ///             failure.</p>
    case internalFailureException(InternalFailureException?)
    case sdkUnknown(String?)
}

public struct SubscribeToShardInputBodyMiddleware: Middleware {
    public let id: String = "SubscribeToShardInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SubscribeToShardInput>,
                  next: H) -> Swift.Result<OperationOutput<SubscribeToShardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SubscribeToShardInput>
    public typealias MOutput = OperationOutput<SubscribeToShardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SubscribeToShardOutputError>
}

extension SubscribeToShardInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscribeToShardInput(consumerARN: \(String(describing: consumerARN)), shardId: \(String(describing: shardId)), startingPosition: \(String(describing: startingPosition)))"}
}

extension SubscribeToShardInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case consumerARN = "ConsumerARN"
        case shardId = "ShardId"
        case startingPosition = "StartingPosition"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumerARN = consumerARN {
            try encodeContainer.encode(consumerARN, forKey: .consumerARN)
        }
        if let shardId = shardId {
            try encodeContainer.encode(shardId, forKey: .shardId)
        }
        if let startingPosition = startingPosition {
            try encodeContainer.encode(startingPosition, forKey: .startingPosition)
        }
    }
}

public struct SubscribeToShardInputHeadersMiddleware: Middleware {
    public let id: String = "SubscribeToShardInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SubscribeToShardInput>,
                  next: H) -> Swift.Result<OperationOutput<SubscribeToShardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SubscribeToShardInput>
    public typealias MOutput = OperationOutput<SubscribeToShardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SubscribeToShardOutputError>
}

public struct SubscribeToShardInputQueryItemMiddleware: Middleware {
    public let id: String = "SubscribeToShardInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SubscribeToShardInput>,
                  next: H) -> Swift.Result<OperationOutput<SubscribeToShardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SubscribeToShardInput>
    public typealias MOutput = OperationOutput<SubscribeToShardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SubscribeToShardOutputError>
}

public struct SubscribeToShardInput: Equatable {
    /// <p>For this parameter, use the value you obtained when you called <a>RegisterStreamConsumer</a>.</p>
    public let consumerARN: String?
    /// <p>The ID of the shard you want to subscribe to. To see a list of all the shards for a
    ///             given stream, use <a>ListShards</a>.</p>
    public let shardId: String?
    /// <p></p>
    public let startingPosition: StartingPosition?

    public init (
        consumerARN: String? = nil,
        shardId: String? = nil,
        startingPosition: StartingPosition? = nil
    )
    {
        self.consumerARN = consumerARN
        self.shardId = shardId
        self.startingPosition = startingPosition
    }
}

struct SubscribeToShardInputBody: Equatable {
    public let consumerARN: String?
    public let shardId: String?
    public let startingPosition: StartingPosition?
}

extension SubscribeToShardInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case consumerARN = "ConsumerARN"
        case shardId = "ShardId"
        case startingPosition = "StartingPosition"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consumerARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .consumerARN)
        consumerARN = consumerARNDecoded
        let shardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shardId)
        shardId = shardIdDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(StartingPosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
    }
}

extension SubscribeToShardOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SubscribeToShardOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SubscribeToShardOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SubscribeToShardOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscribeToShardOutputResponse(eventStream: \(String(describing: eventStream)))"}
}

extension SubscribeToShardOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SubscribeToShardOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventStream = output.eventStream
        } else {
            self.eventStream = nil
        }
    }
}

public struct SubscribeToShardOutputResponse: Equatable {
    /// <p>The event stream that your consumer can use to read records from the shard.</p>
    public let eventStream: SubscribeToShardEventStream?

    public init (
        eventStream: SubscribeToShardEventStream? = nil
    )
    {
        self.eventStream = eventStream
    }
}

struct SubscribeToShardOutputResponseBody: Equatable {
    public let eventStream: SubscribeToShardEventStream?
}

extension SubscribeToShardOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventStream = "EventStream"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventStreamDecoded = try containerValues.decodeIfPresent(SubscribeToShardEventStream.self, forKey: .eventStream)
        eventStream = eventStreamDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Metadata assigned to the stream, consisting of a key-value pair.</p>
public struct Tag: Equatable {
    /// <p>A unique identifier for the tag. Maximum length: 128 characters. Valid characters:
    ///             Unicode letters, digits, white space, _ . / = + - % @</p>
    public let key: String?
    /// <p>An optional string, typically used to describe or define the tag. Maximum length:
    ///             256 characters. Valid characters: Unicode letters, digits, white space, _ . / = + - %
    ///             @</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct UpdateShardCountInputBodyMiddleware: Middleware {
    public let id: String = "UpdateShardCountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateShardCountInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateShardCountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateShardCountInput>
    public typealias MOutput = OperationOutput<UpdateShardCountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateShardCountOutputError>
}

extension UpdateShardCountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateShardCountInput(scalingType: \(String(describing: scalingType)), streamName: \(String(describing: streamName)), targetShardCount: \(String(describing: targetShardCount)))"}
}

extension UpdateShardCountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case scalingType = "ScalingType"
        case streamName = "StreamName"
        case targetShardCount = "TargetShardCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scalingType = scalingType {
            try encodeContainer.encode(scalingType.rawValue, forKey: .scalingType)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let targetShardCount = targetShardCount {
            try encodeContainer.encode(targetShardCount, forKey: .targetShardCount)
        }
    }
}

public struct UpdateShardCountInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateShardCountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateShardCountInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateShardCountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateShardCountInput>
    public typealias MOutput = OperationOutput<UpdateShardCountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateShardCountOutputError>
}

public struct UpdateShardCountInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateShardCountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateShardCountInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateShardCountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateShardCountInput>
    public typealias MOutput = OperationOutput<UpdateShardCountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateShardCountOutputError>
}

public struct UpdateShardCountInput: Equatable {
    /// <p>The scaling type. Uniform scaling creates shards of equal size.</p>
    public let scalingType: ScalingType?
    /// <p>The name of the stream.</p>
    public let streamName: String?
    /// <p>The new number of shards. This value has the following default limits. By default,
    ///             you cannot do the following: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>Set this value to more than double your current shard count for a
    ///                     stream.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Set this value below half your current shard count for a stream.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Set this value to more than 500 shards in a stream (the default limit for
    ///                     shard count per stream is 500 per account per region), unless you request a
    ///                     limit increase.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Scale a stream with more than 500 shards down unless you set this value to
    ///                     less than 500 shards.</p>
    ///             </li>
    ///          </ul>
    public let targetShardCount: Int?

    public init (
        scalingType: ScalingType? = nil,
        streamName: String? = nil,
        targetShardCount: Int? = nil
    )
    {
        self.scalingType = scalingType
        self.streamName = streamName
        self.targetShardCount = targetShardCount
    }
}

struct UpdateShardCountInputBody: Equatable {
    public let streamName: String?
    public let targetShardCount: Int?
    public let scalingType: ScalingType?
}

extension UpdateShardCountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case scalingType = "ScalingType"
        case streamName = "StreamName"
        case targetShardCount = "TargetShardCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let targetShardCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .targetShardCount)
        targetShardCount = targetShardCountDecoded
        let scalingTypeDecoded = try containerValues.decodeIfPresent(ScalingType.self, forKey: .scalingType)
        scalingType = scalingTypeDecoded
    }
}

extension UpdateShardCountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateShardCountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateShardCountOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateShardCountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateShardCountOutputResponse(currentShardCount: \(String(describing: currentShardCount)), streamName: \(String(describing: streamName)), targetShardCount: \(String(describing: targetShardCount)))"}
}

extension UpdateShardCountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateShardCountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.currentShardCount = output.currentShardCount
            self.streamName = output.streamName
            self.targetShardCount = output.targetShardCount
        } else {
            self.currentShardCount = nil
            self.streamName = nil
            self.targetShardCount = nil
        }
    }
}

public struct UpdateShardCountOutputResponse: Equatable {
    /// <p>The current number of shards.</p>
    public let currentShardCount: Int?
    /// <p>The name of the stream.</p>
    public let streamName: String?
    /// <p>The updated number of shards.</p>
    public let targetShardCount: Int?

    public init (
        currentShardCount: Int? = nil,
        streamName: String? = nil,
        targetShardCount: Int? = nil
    )
    {
        self.currentShardCount = currentShardCount
        self.streamName = streamName
        self.targetShardCount = targetShardCount
    }
}

struct UpdateShardCountOutputResponseBody: Equatable {
    public let streamName: String?
    public let currentShardCount: Int?
    public let targetShardCount: Int?
}

extension UpdateShardCountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case currentShardCount = "CurrentShardCount"
        case streamName = "StreamName"
        case targetShardCount = "TargetShardCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let currentShardCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentShardCount)
        currentShardCount = currentShardCountDecoded
        let targetShardCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .targetShardCount)
        targetShardCount = targetShardCountDecoded
    }
}
