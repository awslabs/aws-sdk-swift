// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[DescribeCertificatesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeCertificatesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeCertificatesOutputResponse`
extension RdsClient {
    public func describeCertificatesPaginated(input: DescribeCertificatesInput) -> ClientRuntime.PaginatorSequence<DescribeCertificatesInput, DescribeCertificatesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeCertificatesInput, DescribeCertificatesOutputResponse>(input: input, inputKey: \DescribeCertificatesInput.marker, outputKey: \DescribeCertificatesOutputResponse.marker, paginationFunction: self.describeCertificates(input:))
    }
}

extension DescribeCertificatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeCertificatesInput {
        return DescribeCertificatesInput(
            certificateIdentifier: self.certificateIdentifier,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeCertificatesPaginated`
/// to access the nested member `[RdsClientTypes.Certificate]`
/// - Returns: `[RdsClientTypes.Certificate]`
extension PaginatorSequence where Input == DescribeCertificatesInput, Output == DescribeCertificatesOutputResponse {
    public func certificates() async throws -> [RdsClientTypes.Certificate] {
        return try await self.asyncCompactMap { item in item.certificates }
    }
}

/// Paginate over `[DescribeDBClusterBacktracksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeDBClusterBacktracksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeDBClusterBacktracksOutputResponse`
extension RdsClient {
    public func describeDBClusterBacktracksPaginated(input: DescribeDBClusterBacktracksInput) -> ClientRuntime.PaginatorSequence<DescribeDBClusterBacktracksInput, DescribeDBClusterBacktracksOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDBClusterBacktracksInput, DescribeDBClusterBacktracksOutputResponse>(input: input, inputKey: \DescribeDBClusterBacktracksInput.marker, outputKey: \DescribeDBClusterBacktracksOutputResponse.marker, paginationFunction: self.describeDBClusterBacktracks(input:))
    }
}

extension DescribeDBClusterBacktracksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBClusterBacktracksInput {
        return DescribeDBClusterBacktracksInput(
            backtrackIdentifier: self.backtrackIdentifier,
            dBClusterIdentifier: self.dBClusterIdentifier,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeDBClusterBacktracksPaginated`
/// to access the nested member `[RdsClientTypes.DBClusterBacktrack]`
/// - Returns: `[RdsClientTypes.DBClusterBacktrack]`
extension PaginatorSequence where Input == DescribeDBClusterBacktracksInput, Output == DescribeDBClusterBacktracksOutputResponse {
    public func dBClusterBacktracks() async throws -> [RdsClientTypes.DBClusterBacktrack] {
        return try await self.asyncCompactMap { item in item.dBClusterBacktracks }
    }
}

/// Paginate over `[DescribeDBClusterEndpointsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeDBClusterEndpointsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeDBClusterEndpointsOutputResponse`
extension RdsClient {
    public func describeDBClusterEndpointsPaginated(input: DescribeDBClusterEndpointsInput) -> ClientRuntime.PaginatorSequence<DescribeDBClusterEndpointsInput, DescribeDBClusterEndpointsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDBClusterEndpointsInput, DescribeDBClusterEndpointsOutputResponse>(input: input, inputKey: \DescribeDBClusterEndpointsInput.marker, outputKey: \DescribeDBClusterEndpointsOutputResponse.marker, paginationFunction: self.describeDBClusterEndpoints(input:))
    }
}

extension DescribeDBClusterEndpointsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBClusterEndpointsInput {
        return DescribeDBClusterEndpointsInput(
            dBClusterEndpointIdentifier: self.dBClusterEndpointIdentifier,
            dBClusterIdentifier: self.dBClusterIdentifier,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeDBClusterEndpointsPaginated`
/// to access the nested member `[RdsClientTypes.DBClusterEndpoint]`
/// - Returns: `[RdsClientTypes.DBClusterEndpoint]`
extension PaginatorSequence where Input == DescribeDBClusterEndpointsInput, Output == DescribeDBClusterEndpointsOutputResponse {
    public func dBClusterEndpoints() async throws -> [RdsClientTypes.DBClusterEndpoint] {
        return try await self.asyncCompactMap { item in item.dBClusterEndpoints }
    }
}

/// Paginate over `[DescribeDBClusterParameterGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeDBClusterParameterGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeDBClusterParameterGroupsOutputResponse`
extension RdsClient {
    public func describeDBClusterParameterGroupsPaginated(input: DescribeDBClusterParameterGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeDBClusterParameterGroupsInput, DescribeDBClusterParameterGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDBClusterParameterGroupsInput, DescribeDBClusterParameterGroupsOutputResponse>(input: input, inputKey: \DescribeDBClusterParameterGroupsInput.marker, outputKey: \DescribeDBClusterParameterGroupsOutputResponse.marker, paginationFunction: self.describeDBClusterParameterGroups(input:))
    }
}

extension DescribeDBClusterParameterGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBClusterParameterGroupsInput {
        return DescribeDBClusterParameterGroupsInput(
            dBClusterParameterGroupName: self.dBClusterParameterGroupName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeDBClusterParameterGroupsPaginated`
/// to access the nested member `[RdsClientTypes.DBClusterParameterGroup]`
/// - Returns: `[RdsClientTypes.DBClusterParameterGroup]`
extension PaginatorSequence where Input == DescribeDBClusterParameterGroupsInput, Output == DescribeDBClusterParameterGroupsOutputResponse {
    public func dBClusterParameterGroups() async throws -> [RdsClientTypes.DBClusterParameterGroup] {
        return try await self.asyncCompactMap { item in item.dBClusterParameterGroups }
    }
}

/// Paginate over `[DescribeDBClusterParametersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeDBClusterParametersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeDBClusterParametersOutputResponse`
extension RdsClient {
    public func describeDBClusterParametersPaginated(input: DescribeDBClusterParametersInput) -> ClientRuntime.PaginatorSequence<DescribeDBClusterParametersInput, DescribeDBClusterParametersOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDBClusterParametersInput, DescribeDBClusterParametersOutputResponse>(input: input, inputKey: \DescribeDBClusterParametersInput.marker, outputKey: \DescribeDBClusterParametersOutputResponse.marker, paginationFunction: self.describeDBClusterParameters(input:))
    }
}

extension DescribeDBClusterParametersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBClusterParametersInput {
        return DescribeDBClusterParametersInput(
            dBClusterParameterGroupName: self.dBClusterParameterGroupName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            source: self.source
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeDBClusterParametersPaginated`
/// to access the nested member `[RdsClientTypes.Parameter]`
/// - Returns: `[RdsClientTypes.Parameter]`
extension PaginatorSequence where Input == DescribeDBClusterParametersInput, Output == DescribeDBClusterParametersOutputResponse {
    public func parameters() async throws -> [RdsClientTypes.Parameter] {
        return try await self.asyncCompactMap { item in item.parameters }
    }
}

/// Paginate over `[DescribeDBClustersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeDBClustersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeDBClustersOutputResponse`
extension RdsClient {
    public func describeDBClustersPaginated(input: DescribeDBClustersInput) -> ClientRuntime.PaginatorSequence<DescribeDBClustersInput, DescribeDBClustersOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDBClustersInput, DescribeDBClustersOutputResponse>(input: input, inputKey: \DescribeDBClustersInput.marker, outputKey: \DescribeDBClustersOutputResponse.marker, paginationFunction: self.describeDBClusters(input:))
    }
}

extension DescribeDBClustersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBClustersInput {
        return DescribeDBClustersInput(
            dBClusterIdentifier: self.dBClusterIdentifier,
            filters: self.filters,
            includeShared: self.includeShared,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeDBClustersPaginated`
/// to access the nested member `[RdsClientTypes.DBCluster]`
/// - Returns: `[RdsClientTypes.DBCluster]`
extension PaginatorSequence where Input == DescribeDBClustersInput, Output == DescribeDBClustersOutputResponse {
    public func dBClusters() async throws -> [RdsClientTypes.DBCluster] {
        return try await self.asyncCompactMap { item in item.dBClusters }
    }
}

/// Paginate over `[DescribeDBClusterSnapshotsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeDBClusterSnapshotsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeDBClusterSnapshotsOutputResponse`
extension RdsClient {
    public func describeDBClusterSnapshotsPaginated(input: DescribeDBClusterSnapshotsInput) -> ClientRuntime.PaginatorSequence<DescribeDBClusterSnapshotsInput, DescribeDBClusterSnapshotsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDBClusterSnapshotsInput, DescribeDBClusterSnapshotsOutputResponse>(input: input, inputKey: \DescribeDBClusterSnapshotsInput.marker, outputKey: \DescribeDBClusterSnapshotsOutputResponse.marker, paginationFunction: self.describeDBClusterSnapshots(input:))
    }
}

extension DescribeDBClusterSnapshotsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBClusterSnapshotsInput {
        return DescribeDBClusterSnapshotsInput(
            dBClusterIdentifier: self.dBClusterIdentifier,
            dBClusterSnapshotIdentifier: self.dBClusterSnapshotIdentifier,
            filters: self.filters,
            includePublic: self.includePublic,
            includeShared: self.includeShared,
            marker: token,
            maxRecords: self.maxRecords,
            snapshotType: self.snapshotType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeDBClusterSnapshotsPaginated`
/// to access the nested member `[RdsClientTypes.DBClusterSnapshot]`
/// - Returns: `[RdsClientTypes.DBClusterSnapshot]`
extension PaginatorSequence where Input == DescribeDBClusterSnapshotsInput, Output == DescribeDBClusterSnapshotsOutputResponse {
    public func dBClusterSnapshots() async throws -> [RdsClientTypes.DBClusterSnapshot] {
        return try await self.asyncCompactMap { item in item.dBClusterSnapshots }
    }
}

/// Paginate over `[DescribeDBEngineVersionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeDBEngineVersionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeDBEngineVersionsOutputResponse`
extension RdsClient {
    public func describeDBEngineVersionsPaginated(input: DescribeDBEngineVersionsInput) -> ClientRuntime.PaginatorSequence<DescribeDBEngineVersionsInput, DescribeDBEngineVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDBEngineVersionsInput, DescribeDBEngineVersionsOutputResponse>(input: input, inputKey: \DescribeDBEngineVersionsInput.marker, outputKey: \DescribeDBEngineVersionsOutputResponse.marker, paginationFunction: self.describeDBEngineVersions(input:))
    }
}

extension DescribeDBEngineVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBEngineVersionsInput {
        return DescribeDBEngineVersionsInput(
            dBParameterGroupFamily: self.dBParameterGroupFamily,
            defaultOnly: self.defaultOnly,
            engine: self.engine,
            engineVersion: self.engineVersion,
            filters: self.filters,
            includeAll: self.includeAll,
            listSupportedCharacterSets: self.listSupportedCharacterSets,
            listSupportedTimezones: self.listSupportedTimezones,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeDBEngineVersionsPaginated`
/// to access the nested member `[RdsClientTypes.DBEngineVersion]`
/// - Returns: `[RdsClientTypes.DBEngineVersion]`
extension PaginatorSequence where Input == DescribeDBEngineVersionsInput, Output == DescribeDBEngineVersionsOutputResponse {
    public func dBEngineVersions() async throws -> [RdsClientTypes.DBEngineVersion] {
        return try await self.asyncCompactMap { item in item.dBEngineVersions }
    }
}

/// Paginate over `[DescribeDBInstanceAutomatedBackupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeDBInstanceAutomatedBackupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeDBInstanceAutomatedBackupsOutputResponse`
extension RdsClient {
    public func describeDBInstanceAutomatedBackupsPaginated(input: DescribeDBInstanceAutomatedBackupsInput) -> ClientRuntime.PaginatorSequence<DescribeDBInstanceAutomatedBackupsInput, DescribeDBInstanceAutomatedBackupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDBInstanceAutomatedBackupsInput, DescribeDBInstanceAutomatedBackupsOutputResponse>(input: input, inputKey: \DescribeDBInstanceAutomatedBackupsInput.marker, outputKey: \DescribeDBInstanceAutomatedBackupsOutputResponse.marker, paginationFunction: self.describeDBInstanceAutomatedBackups(input:))
    }
}

extension DescribeDBInstanceAutomatedBackupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBInstanceAutomatedBackupsInput {
        return DescribeDBInstanceAutomatedBackupsInput(
            dBInstanceAutomatedBackupsArn: self.dBInstanceAutomatedBackupsArn,
            dBInstanceIdentifier: self.dBInstanceIdentifier,
            dbiResourceId: self.dbiResourceId,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeDBInstanceAutomatedBackupsPaginated`
/// to access the nested member `[RdsClientTypes.DBInstanceAutomatedBackup]`
/// - Returns: `[RdsClientTypes.DBInstanceAutomatedBackup]`
extension PaginatorSequence where Input == DescribeDBInstanceAutomatedBackupsInput, Output == DescribeDBInstanceAutomatedBackupsOutputResponse {
    public func dBInstanceAutomatedBackups() async throws -> [RdsClientTypes.DBInstanceAutomatedBackup] {
        return try await self.asyncCompactMap { item in item.dBInstanceAutomatedBackups }
    }
}

/// Paginate over `[DescribeDBInstancesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeDBInstancesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeDBInstancesOutputResponse`
extension RdsClient {
    public func describeDBInstancesPaginated(input: DescribeDBInstancesInput) -> ClientRuntime.PaginatorSequence<DescribeDBInstancesInput, DescribeDBInstancesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDBInstancesInput, DescribeDBInstancesOutputResponse>(input: input, inputKey: \DescribeDBInstancesInput.marker, outputKey: \DescribeDBInstancesOutputResponse.marker, paginationFunction: self.describeDBInstances(input:))
    }
}

extension DescribeDBInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBInstancesInput {
        return DescribeDBInstancesInput(
            dBInstanceIdentifier: self.dBInstanceIdentifier,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeDBInstancesPaginated`
/// to access the nested member `[RdsClientTypes.DBInstance]`
/// - Returns: `[RdsClientTypes.DBInstance]`
extension PaginatorSequence where Input == DescribeDBInstancesInput, Output == DescribeDBInstancesOutputResponse {
    public func dBInstances() async throws -> [RdsClientTypes.DBInstance] {
        return try await self.asyncCompactMap { item in item.dBInstances }
    }
}

/// Paginate over `[DescribeDBLogFilesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeDBLogFilesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeDBLogFilesOutputResponse`
extension RdsClient {
    public func describeDBLogFilesPaginated(input: DescribeDBLogFilesInput) -> ClientRuntime.PaginatorSequence<DescribeDBLogFilesInput, DescribeDBLogFilesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDBLogFilesInput, DescribeDBLogFilesOutputResponse>(input: input, inputKey: \DescribeDBLogFilesInput.marker, outputKey: \DescribeDBLogFilesOutputResponse.marker, paginationFunction: self.describeDBLogFiles(input:))
    }
}

extension DescribeDBLogFilesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBLogFilesInput {
        return DescribeDBLogFilesInput(
            dBInstanceIdentifier: self.dBInstanceIdentifier,
            fileLastWritten: self.fileLastWritten,
            fileSize: self.fileSize,
            filenameContains: self.filenameContains,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeDBLogFilesPaginated`
/// to access the nested member `[RdsClientTypes.DescribeDBLogFilesDetails]`
/// - Returns: `[RdsClientTypes.DescribeDBLogFilesDetails]`
extension PaginatorSequence where Input == DescribeDBLogFilesInput, Output == DescribeDBLogFilesOutputResponse {
    public func describeDBLogFiles() async throws -> [RdsClientTypes.DescribeDBLogFilesDetails] {
        return try await self.asyncCompactMap { item in item.describeDBLogFiles }
    }
}

/// Paginate over `[DescribeDBParameterGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeDBParameterGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeDBParameterGroupsOutputResponse`
extension RdsClient {
    public func describeDBParameterGroupsPaginated(input: DescribeDBParameterGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeDBParameterGroupsInput, DescribeDBParameterGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDBParameterGroupsInput, DescribeDBParameterGroupsOutputResponse>(input: input, inputKey: \DescribeDBParameterGroupsInput.marker, outputKey: \DescribeDBParameterGroupsOutputResponse.marker, paginationFunction: self.describeDBParameterGroups(input:))
    }
}

extension DescribeDBParameterGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBParameterGroupsInput {
        return DescribeDBParameterGroupsInput(
            dBParameterGroupName: self.dBParameterGroupName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeDBParameterGroupsPaginated`
/// to access the nested member `[RdsClientTypes.DBParameterGroup]`
/// - Returns: `[RdsClientTypes.DBParameterGroup]`
extension PaginatorSequence where Input == DescribeDBParameterGroupsInput, Output == DescribeDBParameterGroupsOutputResponse {
    public func dBParameterGroups() async throws -> [RdsClientTypes.DBParameterGroup] {
        return try await self.asyncCompactMap { item in item.dBParameterGroups }
    }
}

/// Paginate over `[DescribeDBParametersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeDBParametersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeDBParametersOutputResponse`
extension RdsClient {
    public func describeDBParametersPaginated(input: DescribeDBParametersInput) -> ClientRuntime.PaginatorSequence<DescribeDBParametersInput, DescribeDBParametersOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDBParametersInput, DescribeDBParametersOutputResponse>(input: input, inputKey: \DescribeDBParametersInput.marker, outputKey: \DescribeDBParametersOutputResponse.marker, paginationFunction: self.describeDBParameters(input:))
    }
}

extension DescribeDBParametersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBParametersInput {
        return DescribeDBParametersInput(
            dBParameterGroupName: self.dBParameterGroupName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            source: self.source
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeDBParametersPaginated`
/// to access the nested member `[RdsClientTypes.Parameter]`
/// - Returns: `[RdsClientTypes.Parameter]`
extension PaginatorSequence where Input == DescribeDBParametersInput, Output == DescribeDBParametersOutputResponse {
    public func parameters() async throws -> [RdsClientTypes.Parameter] {
        return try await self.asyncCompactMap { item in item.parameters }
    }
}

/// Paginate over `[DescribeDBProxiesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeDBProxiesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeDBProxiesOutputResponse`
extension RdsClient {
    public func describeDBProxiesPaginated(input: DescribeDBProxiesInput) -> ClientRuntime.PaginatorSequence<DescribeDBProxiesInput, DescribeDBProxiesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDBProxiesInput, DescribeDBProxiesOutputResponse>(input: input, inputKey: \DescribeDBProxiesInput.marker, outputKey: \DescribeDBProxiesOutputResponse.marker, paginationFunction: self.describeDBProxies(input:))
    }
}

extension DescribeDBProxiesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBProxiesInput {
        return DescribeDBProxiesInput(
            dBProxyName: self.dBProxyName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeDBProxiesPaginated`
/// to access the nested member `[RdsClientTypes.DBProxy]`
/// - Returns: `[RdsClientTypes.DBProxy]`
extension PaginatorSequence where Input == DescribeDBProxiesInput, Output == DescribeDBProxiesOutputResponse {
    public func dBProxies() async throws -> [RdsClientTypes.DBProxy] {
        return try await self.asyncCompactMap { item in item.dBProxies }
    }
}

/// Paginate over `[DescribeDBProxyEndpointsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeDBProxyEndpointsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeDBProxyEndpointsOutputResponse`
extension RdsClient {
    public func describeDBProxyEndpointsPaginated(input: DescribeDBProxyEndpointsInput) -> ClientRuntime.PaginatorSequence<DescribeDBProxyEndpointsInput, DescribeDBProxyEndpointsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDBProxyEndpointsInput, DescribeDBProxyEndpointsOutputResponse>(input: input, inputKey: \DescribeDBProxyEndpointsInput.marker, outputKey: \DescribeDBProxyEndpointsOutputResponse.marker, paginationFunction: self.describeDBProxyEndpoints(input:))
    }
}

extension DescribeDBProxyEndpointsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBProxyEndpointsInput {
        return DescribeDBProxyEndpointsInput(
            dBProxyEndpointName: self.dBProxyEndpointName,
            dBProxyName: self.dBProxyName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeDBProxyEndpointsPaginated`
/// to access the nested member `[RdsClientTypes.DBProxyEndpoint]`
/// - Returns: `[RdsClientTypes.DBProxyEndpoint]`
extension PaginatorSequence where Input == DescribeDBProxyEndpointsInput, Output == DescribeDBProxyEndpointsOutputResponse {
    public func dBProxyEndpoints() async throws -> [RdsClientTypes.DBProxyEndpoint] {
        return try await self.asyncCompactMap { item in item.dBProxyEndpoints }
    }
}

/// Paginate over `[DescribeDBProxyTargetGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeDBProxyTargetGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeDBProxyTargetGroupsOutputResponse`
extension RdsClient {
    public func describeDBProxyTargetGroupsPaginated(input: DescribeDBProxyTargetGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeDBProxyTargetGroupsInput, DescribeDBProxyTargetGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDBProxyTargetGroupsInput, DescribeDBProxyTargetGroupsOutputResponse>(input: input, inputKey: \DescribeDBProxyTargetGroupsInput.marker, outputKey: \DescribeDBProxyTargetGroupsOutputResponse.marker, paginationFunction: self.describeDBProxyTargetGroups(input:))
    }
}

extension DescribeDBProxyTargetGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBProxyTargetGroupsInput {
        return DescribeDBProxyTargetGroupsInput(
            dBProxyName: self.dBProxyName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            targetGroupName: self.targetGroupName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeDBProxyTargetGroupsPaginated`
/// to access the nested member `[RdsClientTypes.DBProxyTargetGroup]`
/// - Returns: `[RdsClientTypes.DBProxyTargetGroup]`
extension PaginatorSequence where Input == DescribeDBProxyTargetGroupsInput, Output == DescribeDBProxyTargetGroupsOutputResponse {
    public func targetGroups() async throws -> [RdsClientTypes.DBProxyTargetGroup] {
        return try await self.asyncCompactMap { item in item.targetGroups }
    }
}

/// Paginate over `[DescribeDBProxyTargetsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeDBProxyTargetsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeDBProxyTargetsOutputResponse`
extension RdsClient {
    public func describeDBProxyTargetsPaginated(input: DescribeDBProxyTargetsInput) -> ClientRuntime.PaginatorSequence<DescribeDBProxyTargetsInput, DescribeDBProxyTargetsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDBProxyTargetsInput, DescribeDBProxyTargetsOutputResponse>(input: input, inputKey: \DescribeDBProxyTargetsInput.marker, outputKey: \DescribeDBProxyTargetsOutputResponse.marker, paginationFunction: self.describeDBProxyTargets(input:))
    }
}

extension DescribeDBProxyTargetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBProxyTargetsInput {
        return DescribeDBProxyTargetsInput(
            dBProxyName: self.dBProxyName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            targetGroupName: self.targetGroupName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeDBProxyTargetsPaginated`
/// to access the nested member `[RdsClientTypes.DBProxyTarget]`
/// - Returns: `[RdsClientTypes.DBProxyTarget]`
extension PaginatorSequence where Input == DescribeDBProxyTargetsInput, Output == DescribeDBProxyTargetsOutputResponse {
    public func targets() async throws -> [RdsClientTypes.DBProxyTarget] {
        return try await self.asyncCompactMap { item in item.targets }
    }
}

/// Paginate over `[DescribeDBSecurityGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeDBSecurityGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeDBSecurityGroupsOutputResponse`
extension RdsClient {
    public func describeDBSecurityGroupsPaginated(input: DescribeDBSecurityGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeDBSecurityGroupsInput, DescribeDBSecurityGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDBSecurityGroupsInput, DescribeDBSecurityGroupsOutputResponse>(input: input, inputKey: \DescribeDBSecurityGroupsInput.marker, outputKey: \DescribeDBSecurityGroupsOutputResponse.marker, paginationFunction: self.describeDBSecurityGroups(input:))
    }
}

extension DescribeDBSecurityGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBSecurityGroupsInput {
        return DescribeDBSecurityGroupsInput(
            dBSecurityGroupName: self.dBSecurityGroupName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeDBSecurityGroupsPaginated`
/// to access the nested member `[RdsClientTypes.DBSecurityGroup]`
/// - Returns: `[RdsClientTypes.DBSecurityGroup]`
extension PaginatorSequence where Input == DescribeDBSecurityGroupsInput, Output == DescribeDBSecurityGroupsOutputResponse {
    public func dBSecurityGroups() async throws -> [RdsClientTypes.DBSecurityGroup] {
        return try await self.asyncCompactMap { item in item.dBSecurityGroups }
    }
}

/// Paginate over `[DescribeDBSnapshotsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeDBSnapshotsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeDBSnapshotsOutputResponse`
extension RdsClient {
    public func describeDBSnapshotsPaginated(input: DescribeDBSnapshotsInput) -> ClientRuntime.PaginatorSequence<DescribeDBSnapshotsInput, DescribeDBSnapshotsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDBSnapshotsInput, DescribeDBSnapshotsOutputResponse>(input: input, inputKey: \DescribeDBSnapshotsInput.marker, outputKey: \DescribeDBSnapshotsOutputResponse.marker, paginationFunction: self.describeDBSnapshots(input:))
    }
}

extension DescribeDBSnapshotsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBSnapshotsInput {
        return DescribeDBSnapshotsInput(
            dBInstanceIdentifier: self.dBInstanceIdentifier,
            dBSnapshotIdentifier: self.dBSnapshotIdentifier,
            dbiResourceId: self.dbiResourceId,
            filters: self.filters,
            includePublic: self.includePublic,
            includeShared: self.includeShared,
            marker: token,
            maxRecords: self.maxRecords,
            snapshotType: self.snapshotType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeDBSnapshotsPaginated`
/// to access the nested member `[RdsClientTypes.DBSnapshot]`
/// - Returns: `[RdsClientTypes.DBSnapshot]`
extension PaginatorSequence where Input == DescribeDBSnapshotsInput, Output == DescribeDBSnapshotsOutputResponse {
    public func dBSnapshots() async throws -> [RdsClientTypes.DBSnapshot] {
        return try await self.asyncCompactMap { item in item.dBSnapshots }
    }
}

/// Paginate over `[DescribeDBSubnetGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeDBSubnetGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeDBSubnetGroupsOutputResponse`
extension RdsClient {
    public func describeDBSubnetGroupsPaginated(input: DescribeDBSubnetGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeDBSubnetGroupsInput, DescribeDBSubnetGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDBSubnetGroupsInput, DescribeDBSubnetGroupsOutputResponse>(input: input, inputKey: \DescribeDBSubnetGroupsInput.marker, outputKey: \DescribeDBSubnetGroupsOutputResponse.marker, paginationFunction: self.describeDBSubnetGroups(input:))
    }
}

extension DescribeDBSubnetGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBSubnetGroupsInput {
        return DescribeDBSubnetGroupsInput(
            dBSubnetGroupName: self.dBSubnetGroupName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeDBSubnetGroupsPaginated`
/// to access the nested member `[RdsClientTypes.DBSubnetGroup]`
/// - Returns: `[RdsClientTypes.DBSubnetGroup]`
extension PaginatorSequence where Input == DescribeDBSubnetGroupsInput, Output == DescribeDBSubnetGroupsOutputResponse {
    public func dBSubnetGroups() async throws -> [RdsClientTypes.DBSubnetGroup] {
        return try await self.asyncCompactMap { item in item.dBSubnetGroups }
    }
}

/// Paginate over `[DescribeEngineDefaultParametersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeEngineDefaultParametersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeEngineDefaultParametersOutputResponse`
extension RdsClient {
    public func describeEngineDefaultParametersPaginated(input: DescribeEngineDefaultParametersInput) -> ClientRuntime.PaginatorSequence<DescribeEngineDefaultParametersInput, DescribeEngineDefaultParametersOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeEngineDefaultParametersInput, DescribeEngineDefaultParametersOutputResponse>(input: input, inputKey: \DescribeEngineDefaultParametersInput.marker, outputKey: \DescribeEngineDefaultParametersOutputResponse.engineDefaults?.marker, paginationFunction: self.describeEngineDefaultParameters(input:))
    }
}

extension DescribeEngineDefaultParametersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEngineDefaultParametersInput {
        return DescribeEngineDefaultParametersInput(
            dBParameterGroupFamily: self.dBParameterGroupFamily,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeEngineDefaultParametersPaginated`
/// to access the nested member `[RdsClientTypes.Parameter]`
/// - Returns: `[RdsClientTypes.Parameter]`
extension PaginatorSequence where Input == DescribeEngineDefaultParametersInput, Output == DescribeEngineDefaultParametersOutputResponse {
    public func parameters() async throws -> [RdsClientTypes.Parameter] {
        return try await self.asyncCompactMap { item in item.engineDefaults?.parameters }
    }
}

/// Paginate over `[DescribeEventsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeEventsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeEventsOutputResponse`
extension RdsClient {
    public func describeEventsPaginated(input: DescribeEventsInput) -> ClientRuntime.PaginatorSequence<DescribeEventsInput, DescribeEventsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeEventsInput, DescribeEventsOutputResponse>(input: input, inputKey: \DescribeEventsInput.marker, outputKey: \DescribeEventsOutputResponse.marker, paginationFunction: self.describeEvents(input:))
    }
}

extension DescribeEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEventsInput {
        return DescribeEventsInput(
            duration: self.duration,
            endTime: self.endTime,
            eventCategories: self.eventCategories,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            sourceIdentifier: self.sourceIdentifier,
            sourceType: self.sourceType,
            startTime: self.startTime
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeEventsPaginated`
/// to access the nested member `[RdsClientTypes.Event]`
/// - Returns: `[RdsClientTypes.Event]`
extension PaginatorSequence where Input == DescribeEventsInput, Output == DescribeEventsOutputResponse {
    public func events() async throws -> [RdsClientTypes.Event] {
        return try await self.asyncCompactMap { item in item.events }
    }
}

/// Paginate over `[DescribeEventSubscriptionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeEventSubscriptionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeEventSubscriptionsOutputResponse`
extension RdsClient {
    public func describeEventSubscriptionsPaginated(input: DescribeEventSubscriptionsInput) -> ClientRuntime.PaginatorSequence<DescribeEventSubscriptionsInput, DescribeEventSubscriptionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeEventSubscriptionsInput, DescribeEventSubscriptionsOutputResponse>(input: input, inputKey: \DescribeEventSubscriptionsInput.marker, outputKey: \DescribeEventSubscriptionsOutputResponse.marker, paginationFunction: self.describeEventSubscriptions(input:))
    }
}

extension DescribeEventSubscriptionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEventSubscriptionsInput {
        return DescribeEventSubscriptionsInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            subscriptionName: self.subscriptionName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeEventSubscriptionsPaginated`
/// to access the nested member `[RdsClientTypes.EventSubscription]`
/// - Returns: `[RdsClientTypes.EventSubscription]`
extension PaginatorSequence where Input == DescribeEventSubscriptionsInput, Output == DescribeEventSubscriptionsOutputResponse {
    public func eventSubscriptionsList() async throws -> [RdsClientTypes.EventSubscription] {
        return try await self.asyncCompactMap { item in item.eventSubscriptionsList }
    }
}

/// Paginate over `[DescribeExportTasksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeExportTasksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeExportTasksOutputResponse`
extension RdsClient {
    public func describeExportTasksPaginated(input: DescribeExportTasksInput) -> ClientRuntime.PaginatorSequence<DescribeExportTasksInput, DescribeExportTasksOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeExportTasksInput, DescribeExportTasksOutputResponse>(input: input, inputKey: \DescribeExportTasksInput.marker, outputKey: \DescribeExportTasksOutputResponse.marker, paginationFunction: self.describeExportTasks(input:))
    }
}

extension DescribeExportTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeExportTasksInput {
        return DescribeExportTasksInput(
            exportTaskIdentifier: self.exportTaskIdentifier,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            sourceArn: self.sourceArn,
            sourceType: self.sourceType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeExportTasksPaginated`
/// to access the nested member `[RdsClientTypes.ExportTask]`
/// - Returns: `[RdsClientTypes.ExportTask]`
extension PaginatorSequence where Input == DescribeExportTasksInput, Output == DescribeExportTasksOutputResponse {
    public func exportTasks() async throws -> [RdsClientTypes.ExportTask] {
        return try await self.asyncCompactMap { item in item.exportTasks }
    }
}

/// Paginate over `[DescribeGlobalClustersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeGlobalClustersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeGlobalClustersOutputResponse`
extension RdsClient {
    public func describeGlobalClustersPaginated(input: DescribeGlobalClustersInput) -> ClientRuntime.PaginatorSequence<DescribeGlobalClustersInput, DescribeGlobalClustersOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeGlobalClustersInput, DescribeGlobalClustersOutputResponse>(input: input, inputKey: \DescribeGlobalClustersInput.marker, outputKey: \DescribeGlobalClustersOutputResponse.marker, paginationFunction: self.describeGlobalClusters(input:))
    }
}

extension DescribeGlobalClustersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeGlobalClustersInput {
        return DescribeGlobalClustersInput(
            filters: self.filters,
            globalClusterIdentifier: self.globalClusterIdentifier,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeGlobalClustersPaginated`
/// to access the nested member `[RdsClientTypes.GlobalCluster]`
/// - Returns: `[RdsClientTypes.GlobalCluster]`
extension PaginatorSequence where Input == DescribeGlobalClustersInput, Output == DescribeGlobalClustersOutputResponse {
    public func globalClusters() async throws -> [RdsClientTypes.GlobalCluster] {
        return try await self.asyncCompactMap { item in item.globalClusters }
    }
}

/// Paginate over `[DescribeOptionGroupOptionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeOptionGroupOptionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeOptionGroupOptionsOutputResponse`
extension RdsClient {
    public func describeOptionGroupOptionsPaginated(input: DescribeOptionGroupOptionsInput) -> ClientRuntime.PaginatorSequence<DescribeOptionGroupOptionsInput, DescribeOptionGroupOptionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeOptionGroupOptionsInput, DescribeOptionGroupOptionsOutputResponse>(input: input, inputKey: \DescribeOptionGroupOptionsInput.marker, outputKey: \DescribeOptionGroupOptionsOutputResponse.marker, paginationFunction: self.describeOptionGroupOptions(input:))
    }
}

extension DescribeOptionGroupOptionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeOptionGroupOptionsInput {
        return DescribeOptionGroupOptionsInput(
            engineName: self.engineName,
            filters: self.filters,
            majorEngineVersion: self.majorEngineVersion,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeOptionGroupOptionsPaginated`
/// to access the nested member `[RdsClientTypes.OptionGroupOption]`
/// - Returns: `[RdsClientTypes.OptionGroupOption]`
extension PaginatorSequence where Input == DescribeOptionGroupOptionsInput, Output == DescribeOptionGroupOptionsOutputResponse {
    public func optionGroupOptions() async throws -> [RdsClientTypes.OptionGroupOption] {
        return try await self.asyncCompactMap { item in item.optionGroupOptions }
    }
}

/// Paginate over `[DescribeOptionGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeOptionGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeOptionGroupsOutputResponse`
extension RdsClient {
    public func describeOptionGroupsPaginated(input: DescribeOptionGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeOptionGroupsInput, DescribeOptionGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeOptionGroupsInput, DescribeOptionGroupsOutputResponse>(input: input, inputKey: \DescribeOptionGroupsInput.marker, outputKey: \DescribeOptionGroupsOutputResponse.marker, paginationFunction: self.describeOptionGroups(input:))
    }
}

extension DescribeOptionGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeOptionGroupsInput {
        return DescribeOptionGroupsInput(
            engineName: self.engineName,
            filters: self.filters,
            majorEngineVersion: self.majorEngineVersion,
            marker: token,
            maxRecords: self.maxRecords,
            optionGroupName: self.optionGroupName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeOptionGroupsPaginated`
/// to access the nested member `[RdsClientTypes.OptionGroup]`
/// - Returns: `[RdsClientTypes.OptionGroup]`
extension PaginatorSequence where Input == DescribeOptionGroupsInput, Output == DescribeOptionGroupsOutputResponse {
    public func optionGroupsList() async throws -> [RdsClientTypes.OptionGroup] {
        return try await self.asyncCompactMap { item in item.optionGroupsList }
    }
}

/// Paginate over `[DescribeOrderableDBInstanceOptionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeOrderableDBInstanceOptionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeOrderableDBInstanceOptionsOutputResponse`
extension RdsClient {
    public func describeOrderableDBInstanceOptionsPaginated(input: DescribeOrderableDBInstanceOptionsInput) -> ClientRuntime.PaginatorSequence<DescribeOrderableDBInstanceOptionsInput, DescribeOrderableDBInstanceOptionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeOrderableDBInstanceOptionsInput, DescribeOrderableDBInstanceOptionsOutputResponse>(input: input, inputKey: \DescribeOrderableDBInstanceOptionsInput.marker, outputKey: \DescribeOrderableDBInstanceOptionsOutputResponse.marker, paginationFunction: self.describeOrderableDBInstanceOptions(input:))
    }
}

extension DescribeOrderableDBInstanceOptionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeOrderableDBInstanceOptionsInput {
        return DescribeOrderableDBInstanceOptionsInput(
            availabilityZoneGroup: self.availabilityZoneGroup,
            dBInstanceClass: self.dBInstanceClass,
            engine: self.engine,
            engineVersion: self.engineVersion,
            filters: self.filters,
            licenseModel: self.licenseModel,
            marker: token,
            maxRecords: self.maxRecords,
            vpc: self.vpc
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeOrderableDBInstanceOptionsPaginated`
/// to access the nested member `[RdsClientTypes.OrderableDBInstanceOption]`
/// - Returns: `[RdsClientTypes.OrderableDBInstanceOption]`
extension PaginatorSequence where Input == DescribeOrderableDBInstanceOptionsInput, Output == DescribeOrderableDBInstanceOptionsOutputResponse {
    public func orderableDBInstanceOptions() async throws -> [RdsClientTypes.OrderableDBInstanceOption] {
        return try await self.asyncCompactMap { item in item.orderableDBInstanceOptions }
    }
}

/// Paginate over `[DescribePendingMaintenanceActionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribePendingMaintenanceActionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribePendingMaintenanceActionsOutputResponse`
extension RdsClient {
    public func describePendingMaintenanceActionsPaginated(input: DescribePendingMaintenanceActionsInput) -> ClientRuntime.PaginatorSequence<DescribePendingMaintenanceActionsInput, DescribePendingMaintenanceActionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribePendingMaintenanceActionsInput, DescribePendingMaintenanceActionsOutputResponse>(input: input, inputKey: \DescribePendingMaintenanceActionsInput.marker, outputKey: \DescribePendingMaintenanceActionsOutputResponse.marker, paginationFunction: self.describePendingMaintenanceActions(input:))
    }
}

extension DescribePendingMaintenanceActionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribePendingMaintenanceActionsInput {
        return DescribePendingMaintenanceActionsInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            resourceIdentifier: self.resourceIdentifier
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describePendingMaintenanceActionsPaginated`
/// to access the nested member `[RdsClientTypes.ResourcePendingMaintenanceActions]`
/// - Returns: `[RdsClientTypes.ResourcePendingMaintenanceActions]`
extension PaginatorSequence where Input == DescribePendingMaintenanceActionsInput, Output == DescribePendingMaintenanceActionsOutputResponse {
    public func pendingMaintenanceActions() async throws -> [RdsClientTypes.ResourcePendingMaintenanceActions] {
        return try await self.asyncCompactMap { item in item.pendingMaintenanceActions }
    }
}

/// Paginate over `[DescribeReservedDBInstancesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeReservedDBInstancesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeReservedDBInstancesOutputResponse`
extension RdsClient {
    public func describeReservedDBInstancesPaginated(input: DescribeReservedDBInstancesInput) -> ClientRuntime.PaginatorSequence<DescribeReservedDBInstancesInput, DescribeReservedDBInstancesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeReservedDBInstancesInput, DescribeReservedDBInstancesOutputResponse>(input: input, inputKey: \DescribeReservedDBInstancesInput.marker, outputKey: \DescribeReservedDBInstancesOutputResponse.marker, paginationFunction: self.describeReservedDBInstances(input:))
    }
}

extension DescribeReservedDBInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReservedDBInstancesInput {
        return DescribeReservedDBInstancesInput(
            dBInstanceClass: self.dBInstanceClass,
            duration: self.duration,
            filters: self.filters,
            leaseId: self.leaseId,
            marker: token,
            maxRecords: self.maxRecords,
            multiAZ: self.multiAZ,
            offeringType: self.offeringType,
            productDescription: self.productDescription,
            reservedDBInstanceId: self.reservedDBInstanceId,
            reservedDBInstancesOfferingId: self.reservedDBInstancesOfferingId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeReservedDBInstancesPaginated`
/// to access the nested member `[RdsClientTypes.ReservedDBInstance]`
/// - Returns: `[RdsClientTypes.ReservedDBInstance]`
extension PaginatorSequence where Input == DescribeReservedDBInstancesInput, Output == DescribeReservedDBInstancesOutputResponse {
    public func reservedDBInstances() async throws -> [RdsClientTypes.ReservedDBInstance] {
        return try await self.asyncCompactMap { item in item.reservedDBInstances }
    }
}

/// Paginate over `[DescribeReservedDBInstancesOfferingsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeReservedDBInstancesOfferingsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeReservedDBInstancesOfferingsOutputResponse`
extension RdsClient {
    public func describeReservedDBInstancesOfferingsPaginated(input: DescribeReservedDBInstancesOfferingsInput) -> ClientRuntime.PaginatorSequence<DescribeReservedDBInstancesOfferingsInput, DescribeReservedDBInstancesOfferingsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeReservedDBInstancesOfferingsInput, DescribeReservedDBInstancesOfferingsOutputResponse>(input: input, inputKey: \DescribeReservedDBInstancesOfferingsInput.marker, outputKey: \DescribeReservedDBInstancesOfferingsOutputResponse.marker, paginationFunction: self.describeReservedDBInstancesOfferings(input:))
    }
}

extension DescribeReservedDBInstancesOfferingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReservedDBInstancesOfferingsInput {
        return DescribeReservedDBInstancesOfferingsInput(
            dBInstanceClass: self.dBInstanceClass,
            duration: self.duration,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            multiAZ: self.multiAZ,
            offeringType: self.offeringType,
            productDescription: self.productDescription,
            reservedDBInstancesOfferingId: self.reservedDBInstancesOfferingId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeReservedDBInstancesOfferingsPaginated`
/// to access the nested member `[RdsClientTypes.ReservedDBInstancesOffering]`
/// - Returns: `[RdsClientTypes.ReservedDBInstancesOffering]`
extension PaginatorSequence where Input == DescribeReservedDBInstancesOfferingsInput, Output == DescribeReservedDBInstancesOfferingsOutputResponse {
    public func reservedDBInstancesOfferings() async throws -> [RdsClientTypes.ReservedDBInstancesOffering] {
        return try await self.asyncCompactMap { item in item.reservedDBInstancesOfferings }
    }
}

/// Paginate over `[DescribeSourceRegionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeSourceRegionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeSourceRegionsOutputResponse`
extension RdsClient {
    public func describeSourceRegionsPaginated(input: DescribeSourceRegionsInput) -> ClientRuntime.PaginatorSequence<DescribeSourceRegionsInput, DescribeSourceRegionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeSourceRegionsInput, DescribeSourceRegionsOutputResponse>(input: input, inputKey: \DescribeSourceRegionsInput.marker, outputKey: \DescribeSourceRegionsOutputResponse.marker, paginationFunction: self.describeSourceRegions(input:))
    }
}

extension DescribeSourceRegionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSourceRegionsInput {
        return DescribeSourceRegionsInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            regionName: self.regionName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeSourceRegionsPaginated`
/// to access the nested member `[RdsClientTypes.SourceRegion]`
/// - Returns: `[RdsClientTypes.SourceRegion]`
extension PaginatorSequence where Input == DescribeSourceRegionsInput, Output == DescribeSourceRegionsOutputResponse {
    public func sourceRegions() async throws -> [RdsClientTypes.SourceRegion] {
        return try await self.asyncCompactMap { item in item.sourceRegions }
    }
}

/// Paginate over `[DownloadDBLogFilePortionOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DownloadDBLogFilePortionInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DownloadDBLogFilePortionOutputResponse`
extension RdsClient {
    public func downloadDBLogFilePortionPaginated(input: DownloadDBLogFilePortionInput) -> ClientRuntime.PaginatorSequence<DownloadDBLogFilePortionInput, DownloadDBLogFilePortionOutputResponse> {
        return ClientRuntime.PaginatorSequence<DownloadDBLogFilePortionInput, DownloadDBLogFilePortionOutputResponse>(input: input, inputKey: \DownloadDBLogFilePortionInput.marker, outputKey: \DownloadDBLogFilePortionOutputResponse.marker, paginationFunction: self.downloadDBLogFilePortion(input:))
    }
}

extension DownloadDBLogFilePortionInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DownloadDBLogFilePortionInput {
        return DownloadDBLogFilePortionInput(
            dBInstanceIdentifier: self.dBInstanceIdentifier,
            logFileName: self.logFileName,
            marker: token,
            numberOfLines: self.numberOfLines
        )}
}
