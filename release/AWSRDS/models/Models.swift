// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension RdsClientTypes.AccountQuota: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountQuotaName = "AccountQuotaName"
        case max = "Max"
        case used = "Used"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accountQuotaName = accountQuotaName {
            try container.encode(accountQuotaName, forKey: ClientRuntime.Key("AccountQuotaName"))
        }
        if max != 0 {
            try container.encode(max, forKey: ClientRuntime.Key("Max"))
        }
        if used != 0 {
            try container.encode(used, forKey: ClientRuntime.Key("Used"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountQuotaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountQuotaName)
        accountQuotaName = accountQuotaNameDecoded
        let usedDecoded = try containerValues.decode(Swift.Int.self, forKey: .used)
        used = usedDecoded
        let maxDecoded = try containerValues.decode(Swift.Int.self, forKey: .max)
        max = maxDecoded
    }
}

extension RdsClientTypes {
    /// Describes a quota for an Amazon Web Services account. The following are account quotas:
    ///
    /// * AllocatedStorage - The total allocated storage per account, in GiB. The used value is the total allocated storage in the account, in GiB.
    ///
    /// * AuthorizationsPerDBSecurityGroup - The number of ingress rules per DB security group. The used value is the highest number of ingress rules in a DB security group in the account. Other DB security groups in the account might have a lower number of ingress rules.
    ///
    /// * CustomEndpointsPerDBCluster - The number of custom endpoints per DB cluster. The used value is the highest number of custom endpoints in a DB clusters in the account. Other DB clusters in the account might have a lower number of custom endpoints.
    ///
    /// * DBClusterParameterGroups - The number of DB cluster parameter groups per account, excluding default parameter groups. The used value is the count of nondefault DB cluster parameter groups in the account.
    ///
    /// * DBClusterRoles - The number of associated Amazon Web Services Identity and Access Management (IAM) roles per DB cluster. The used value is the highest number of associated IAM roles for a DB cluster in the account. Other DB clusters in the account might have a lower number of associated IAM roles.
    ///
    /// * DBClusters - The number of DB clusters per account. The used value is the count of DB clusters in the account.
    ///
    /// * DBInstanceRoles - The number of associated IAM roles per DB instance. The used value is the highest number of associated IAM roles for a DB instance in the account. Other DB instances in the account might have a lower number of associated IAM roles.
    ///
    /// * DBInstances - The number of DB instances per account. The used value is the count of the DB instances in the account. Amazon RDS DB instances, Amazon Aurora DB instances, Amazon Neptune instances, and Amazon DocumentDB instances apply to this quota.
    ///
    /// * DBParameterGroups - The number of DB parameter groups per account, excluding default parameter groups. The used value is the count of nondefault DB parameter groups in the account.
    ///
    /// * DBSecurityGroups - The number of DB security groups (not VPC security groups) per account, excluding the default security group. The used value is the count of nondefault DB security groups in the account.
    ///
    /// * DBSubnetGroups - The number of DB subnet groups per account. The used value is the count of the DB subnet groups in the account.
    ///
    /// * EventSubscriptions - The number of event subscriptions per account. The used value is the count of the event subscriptions in the account.
    ///
    /// * ManualClusterSnapshots - The number of manual DB cluster snapshots per account. The used value is the count of the manual DB cluster snapshots in the account.
    ///
    /// * ManualSnapshots - The number of manual DB instance snapshots per account. The used value is the count of the manual DB instance snapshots in the account.
    ///
    /// * OptionGroups - The number of DB option groups per account, excluding default option groups. The used value is the count of nondefault DB option groups in the account.
    ///
    /// * ReadReplicasPerMaster - The number of read replicas per DB instance. The used value is the highest number of read replicas for a DB instance in the account. Other DB instances in the account might have a lower number of read replicas.
    ///
    /// * ReservedDBInstances - The number of reserved DB instances per account. The used value is the count of the active reserved DB instances in the account.
    ///
    /// * SubnetsPerDBSubnetGroup - The number of subnets per DB subnet group. The used value is highest number of subnets for a DB subnet group in the account. Other DB subnet groups in the account might have a lower number of subnets.
    ///
    ///
    /// For more information, see [Quotas for Amazon RDS](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Limits.html) in the Amazon RDS User Guide and [Quotas for Amazon Aurora](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/CHAP_Limits.html) in the Amazon Aurora User Guide.
    public struct AccountQuota: Swift.Equatable {
        /// The name of the Amazon RDS quota for this Amazon Web Services account.
        public var accountQuotaName: Swift.String?
        /// The maximum allowed value for the quota.
        public var max: Swift.Int
        /// The amount currently used toward the quota maximum.
        public var used: Swift.Int

        public init (
            accountQuotaName: Swift.String? = nil,
            max: Swift.Int = 0,
            used: Swift.Int = 0
        )
        {
            self.accountQuotaName = accountQuotaName
            self.max = max
            self.used = used
        }
    }

}

extension RdsClientTypes {
    public enum ActivityStreamMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case async
        case sync
        case sdkUnknown(Swift.String)

        public static var allCases: [ActivityStreamMode] {
            return [
                .async,
                .sync,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .async: return "async"
            case .sync: return "sync"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActivityStreamMode(rawValue: rawValue) ?? ActivityStreamMode.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes {
    public enum ActivityStreamStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case started
        case starting
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ActivityStreamStatus] {
            return [
                .started,
                .starting,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .started: return "started"
            case .starting: return "starting"
            case .stopped: return "stopped"
            case .stopping: return "stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActivityStreamStatus(rawValue: rawValue) ?? ActivityStreamStatus.sdkUnknown(rawValue)
        }
    }
}

extension AddRoleToDBClusterInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let featureName = featureName {
            try container.encode(featureName, forKey: ClientRuntime.Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        try container.encode("AddRoleToDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension AddRoleToDBClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddRoleToDBClusterInput: Swift.Equatable {
    /// The name of the DB cluster to associate the IAM role with.
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// The name of the feature for the DB cluster that the IAM role is to be associated with. For information about supported feature names, see [DBEngineVersion].
    public var featureName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role to associate with the Aurora DB cluster, for example arn:aws:iam::123456789012:role/AuroraAccessRole.
    /// This member is required.
    public var roleArn: Swift.String?

    public init (
        dBClusterIdentifier: Swift.String? = nil,
        featureName: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.featureName = featureName
        self.roleArn = roleArn
    }
}

struct AddRoleToDBClusterInputBody: Swift.Equatable {
    let dBClusterIdentifier: Swift.String?
    let roleArn: Swift.String?
    let featureName: Swift.String?
}

extension AddRoleToDBClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterIdentifier = "DBClusterIdentifier"
        case featureName = "FeatureName"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let featureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureName)
        featureName = featureNameDecoded
    }
}

extension AddRoleToDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddRoleToDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterRoleAlreadyExists" : self = .dBClusterRoleAlreadyExistsFault(try DBClusterRoleAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterRoleQuotaExceeded" : self = .dBClusterRoleQuotaExceededFault(try DBClusterRoleQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddRoleToDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterRoleAlreadyExistsFault(DBClusterRoleAlreadyExistsFault)
    case dBClusterRoleQuotaExceededFault(DBClusterRoleQuotaExceededFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddRoleToDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AddRoleToDBClusterOutputResponse: Swift.Equatable {

}

extension AddRoleToDBInstanceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let featureName = featureName {
            try container.encode(featureName, forKey: ClientRuntime.Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        try container.encode("AddRoleToDBInstance", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension AddRoleToDBInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddRoleToDBInstanceInput: Swift.Equatable {
    /// The name of the DB instance to associate the IAM role with.
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// The name of the feature for the DB instance that the IAM role is to be associated with. For information about supported feature names, see [DBEngineVersion].
    /// This member is required.
    public var featureName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role to associate with the DB instance, for example arn:aws:iam::123456789012:role/AccessRole.
    /// This member is required.
    public var roleArn: Swift.String?

    public init (
        dBInstanceIdentifier: Swift.String? = nil,
        featureName: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.featureName = featureName
        self.roleArn = roleArn
    }
}

struct AddRoleToDBInstanceInputBody: Swift.Equatable {
    let dBInstanceIdentifier: Swift.String?
    let roleArn: Swift.String?
    let featureName: Swift.String?
}

extension AddRoleToDBInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case featureName = "FeatureName"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let featureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureName)
        featureName = featureNameDecoded
    }
}

extension AddRoleToDBInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddRoleToDBInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceRoleAlreadyExists" : self = .dBInstanceRoleAlreadyExistsFault(try DBInstanceRoleAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceRoleQuotaExceeded" : self = .dBInstanceRoleQuotaExceededFault(try DBInstanceRoleQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddRoleToDBInstanceOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBInstanceRoleAlreadyExistsFault(DBInstanceRoleAlreadyExistsFault)
    case dBInstanceRoleQuotaExceededFault(DBInstanceRoleQuotaExceededFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddRoleToDBInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AddRoleToDBInstanceOutputResponse: Swift.Equatable {

}

extension AddSourceIdentifierToSubscriptionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: ClientRuntime.Key("SourceIdentifier"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: ClientRuntime.Key("SubscriptionName"))
        }
        try container.encode("AddSourceIdentifierToSubscription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension AddSourceIdentifierToSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct AddSourceIdentifierToSubscriptionInput: Swift.Equatable {
    /// The identifier of the event source to be added. Constraints:
    ///
    /// * If the source type is a DB instance, a DBInstanceIdentifier value must be supplied.
    ///
    /// * If the source type is a DB cluster, a DBClusterIdentifier value must be supplied.
    ///
    /// * If the source type is a DB parameter group, a DBParameterGroupName value must be supplied.
    ///
    /// * If the source type is a DB security group, a DBSecurityGroupName value must be supplied.
    ///
    /// * If the source type is a DB snapshot, a DBSnapshotIdentifier value must be supplied.
    ///
    /// * If the source type is a DB cluster snapshot, a DBClusterSnapshotIdentifier value must be supplied.
    /// This member is required.
    public var sourceIdentifier: Swift.String?
    /// The name of the RDS event notification subscription you want to add a source identifier to.
    /// This member is required.
    public var subscriptionName: Swift.String?

    public init (
        sourceIdentifier: Swift.String? = nil,
        subscriptionName: Swift.String? = nil
    )
    {
        self.sourceIdentifier = sourceIdentifier
        self.subscriptionName = subscriptionName
    }
}

struct AddSourceIdentifierToSubscriptionInputBody: Swift.Equatable {
    let subscriptionName: Swift.String?
    let sourceIdentifier: Swift.String?
}

extension AddSourceIdentifierToSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceIdentifier = "SourceIdentifier"
        case subscriptionName = "SubscriptionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
    }
}

extension AddSourceIdentifierToSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddSourceIdentifierToSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "SourceNotFound" : self = .sourceNotFoundFault(try SourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFound" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddSourceIdentifierToSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case sourceNotFoundFault(SourceNotFoundFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddSourceIdentifierToSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddSourceIdentifierToSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct AddSourceIdentifierToSubscriptionOutputResponse: Swift.Equatable {
    /// Contains the results of a successful invocation of the DescribeEventSubscriptions action.
    public var eventSubscription: RdsClientTypes.EventSubscription?

    public init (
        eventSubscription: RdsClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct AddSourceIdentifierToSubscriptionOutputResponseBody: Swift.Equatable {
    let eventSubscription: RdsClientTypes.EventSubscription?
}

extension AddSourceIdentifierToSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("AddSourceIdentifierToSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(RdsClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

extension AddTagsToResourceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: ClientRuntime.Key("ResourceName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("AddTagsToResource", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension AddTagsToResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct AddTagsToResourceInput: Swift.Equatable {
    /// The Amazon RDS resource that the tags are added to. This value is an Amazon Resource Name (ARN). For information about creating an ARN, see [ Constructing an RDS Amazon Resource Name (ARN)](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing).
    /// This member is required.
    public var resourceName: Swift.String?
    /// The tags to be assigned to the Amazon RDS resource.
    /// This member is required.
    public var tags: [RdsClientTypes.Tag]?

    public init (
        resourceName: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil
    )
    {
        self.resourceName = resourceName
        self.tags = tags
    }
}

struct AddTagsToResourceInputBody: Swift.Equatable {
    let resourceName: Swift.String?
    let tags: [RdsClientTypes.Tag]?
}

extension AddTagsToResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "ResourceName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension AddTagsToResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddTagsToResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsToResourceOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsToResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AddTagsToResourceOutputResponse: Swift.Equatable {

}

extension RdsClientTypes {
    public enum ApplyMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case immediate
        case pendingReboot
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplyMethod] {
            return [
                .immediate,
                .pendingReboot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .immediate: return "immediate"
            case .pendingReboot: return "pending-reboot"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplyMethod(rawValue: rawValue) ?? ApplyMethod.sdkUnknown(rawValue)
        }
    }
}

extension ApplyPendingMaintenanceActionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let applyAction = applyAction {
            try container.encode(applyAction, forKey: ClientRuntime.Key("ApplyAction"))
        }
        if let optInType = optInType {
            try container.encode(optInType, forKey: ClientRuntime.Key("OptInType"))
        }
        if let resourceIdentifier = resourceIdentifier {
            try container.encode(resourceIdentifier, forKey: ClientRuntime.Key("ResourceIdentifier"))
        }
        try container.encode("ApplyPendingMaintenanceAction", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ApplyPendingMaintenanceActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ApplyPendingMaintenanceActionInput: Swift.Equatable {
    /// The pending maintenance action to apply to this resource. Valid values: system-update, db-upgrade, hardware-maintenance, ca-certificate-rotation
    /// This member is required.
    public var applyAction: Swift.String?
    /// A value that specifies the type of opt-in request, or undoes an opt-in request. An opt-in request of type immediate can't be undone. Valid values:
    ///
    /// * immediate - Apply the maintenance action immediately.
    ///
    /// * next-maintenance - Apply the maintenance action during the next maintenance window for the resource.
    ///
    /// * undo-opt-in - Cancel any existing next-maintenance opt-in requests.
    /// This member is required.
    public var optInType: Swift.String?
    /// The RDS Amazon Resource Name (ARN) of the resource that the pending maintenance action applies to. For information about creating an ARN, see [ Constructing an RDS Amazon Resource Name (ARN)](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing).
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init (
        applyAction: Swift.String? = nil,
        optInType: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.applyAction = applyAction
        self.optInType = optInType
        self.resourceIdentifier = resourceIdentifier
    }
}

struct ApplyPendingMaintenanceActionInputBody: Swift.Equatable {
    let resourceIdentifier: Swift.String?
    let applyAction: Swift.String?
    let optInType: Swift.String?
}

extension ApplyPendingMaintenanceActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyAction = "ApplyAction"
        case optInType = "OptInType"
        case resourceIdentifier = "ResourceIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let applyActionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applyAction)
        applyAction = applyActionDecoded
        let optInTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optInType)
        optInType = optInTypeDecoded
    }
}

extension ApplyPendingMaintenanceActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ApplyPendingMaintenanceActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ApplyPendingMaintenanceActionOutputError: Swift.Error, Swift.Equatable {
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ApplyPendingMaintenanceActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ApplyPendingMaintenanceActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourcePendingMaintenanceActions = output.resourcePendingMaintenanceActions
        } else {
            self.resourcePendingMaintenanceActions = nil
        }
    }
}

public struct ApplyPendingMaintenanceActionOutputResponse: Swift.Equatable {
    /// Describes the pending maintenance actions for a resource.
    public var resourcePendingMaintenanceActions: RdsClientTypes.ResourcePendingMaintenanceActions?

    public init (
        resourcePendingMaintenanceActions: RdsClientTypes.ResourcePendingMaintenanceActions? = nil
    )
    {
        self.resourcePendingMaintenanceActions = resourcePendingMaintenanceActions
    }
}

struct ApplyPendingMaintenanceActionOutputResponseBody: Swift.Equatable {
    let resourcePendingMaintenanceActions: RdsClientTypes.ResourcePendingMaintenanceActions?
}

extension ApplyPendingMaintenanceActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourcePendingMaintenanceActions = "ResourcePendingMaintenanceActions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ApplyPendingMaintenanceActionResult"))
        let resourcePendingMaintenanceActionsDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ResourcePendingMaintenanceActions.self, forKey: .resourcePendingMaintenanceActions)
        resourcePendingMaintenanceActions = resourcePendingMaintenanceActionsDecoded
    }
}

extension RdsClientTypes {
    public enum AuthScheme: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case secrets
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthScheme] {
            return [
                .secrets,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .secrets: return "SECRETS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthScheme(rawValue: rawValue) ?? AuthScheme.sdkUnknown(rawValue)
        }
    }
}

extension AuthorizationAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<AuthorizationAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified CIDR IP range or Amazon EC2 security group is already authorized for the specified DB security group.
public struct AuthorizationAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension AuthorizationAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AuthorizationNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<AuthorizationNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified CIDR IP range or Amazon EC2 security group might not be authorized for the specified DB security group. Or, RDS might not be authorized to perform necessary actions using IAM on your behalf.
public struct AuthorizationNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension AuthorizationNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AuthorizationQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<AuthorizationQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DB security group authorization quota has been reached.
public struct AuthorizationQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension AuthorizationQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AuthorizeDBSecurityGroupIngressInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let cIDRIP = cIDRIP {
            try container.encode(cIDRIP, forKey: ClientRuntime.Key("CIDRIP"))
        }
        if let dBSecurityGroupName = dBSecurityGroupName {
            try container.encode(dBSecurityGroupName, forKey: ClientRuntime.Key("DBSecurityGroupName"))
        }
        if let eC2SecurityGroupId = eC2SecurityGroupId {
            try container.encode(eC2SecurityGroupId, forKey: ClientRuntime.Key("EC2SecurityGroupId"))
        }
        if let eC2SecurityGroupName = eC2SecurityGroupName {
            try container.encode(eC2SecurityGroupName, forKey: ClientRuntime.Key("EC2SecurityGroupName"))
        }
        if let eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId {
            try container.encode(eC2SecurityGroupOwnerId, forKey: ClientRuntime.Key("EC2SecurityGroupOwnerId"))
        }
        try container.encode("AuthorizeDBSecurityGroupIngress", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension AuthorizeDBSecurityGroupIngressInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct AuthorizeDBSecurityGroupIngressInput: Swift.Equatable {
    /// The IP range to authorize.
    public var cIDRIP: Swift.String?
    /// The name of the DB security group to add authorization to.
    /// This member is required.
    public var dBSecurityGroupName: Swift.String?
    /// Id of the EC2 security group to authorize. For VPC DB security groups, EC2SecurityGroupId must be provided. Otherwise, EC2SecurityGroupOwnerId and either EC2SecurityGroupName or EC2SecurityGroupId must be provided.
    public var eC2SecurityGroupId: Swift.String?
    /// Name of the EC2 security group to authorize. For VPC DB security groups, EC2SecurityGroupId must be provided. Otherwise, EC2SecurityGroupOwnerId and either EC2SecurityGroupName or EC2SecurityGroupId must be provided.
    public var eC2SecurityGroupName: Swift.String?
    /// Amazon Web Services account number of the owner of the EC2 security group specified in the EC2SecurityGroupName parameter. The Amazon Web Services access key ID isn't an acceptable value. For VPC DB security groups, EC2SecurityGroupId must be provided. Otherwise, EC2SecurityGroupOwnerId and either EC2SecurityGroupName or EC2SecurityGroupId must be provided.
    public var eC2SecurityGroupOwnerId: Swift.String?

    public init (
        cIDRIP: Swift.String? = nil,
        dBSecurityGroupName: Swift.String? = nil,
        eC2SecurityGroupId: Swift.String? = nil,
        eC2SecurityGroupName: Swift.String? = nil,
        eC2SecurityGroupOwnerId: Swift.String? = nil
    )
    {
        self.cIDRIP = cIDRIP
        self.dBSecurityGroupName = dBSecurityGroupName
        self.eC2SecurityGroupId = eC2SecurityGroupId
        self.eC2SecurityGroupName = eC2SecurityGroupName
        self.eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId
    }
}

struct AuthorizeDBSecurityGroupIngressInputBody: Swift.Equatable {
    let dBSecurityGroupName: Swift.String?
    let cIDRIP: Swift.String?
    let eC2SecurityGroupName: Swift.String?
    let eC2SecurityGroupId: Swift.String?
    let eC2SecurityGroupOwnerId: Swift.String?
}

extension AuthorizeDBSecurityGroupIngressInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cIDRIP = "CIDRIP"
        case dBSecurityGroupName = "DBSecurityGroupName"
        case eC2SecurityGroupId = "EC2SecurityGroupId"
        case eC2SecurityGroupName = "EC2SecurityGroupName"
        case eC2SecurityGroupOwnerId = "EC2SecurityGroupOwnerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSecurityGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSecurityGroupName)
        dBSecurityGroupName = dBSecurityGroupNameDecoded
        let cIDRIPDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cIDRIP)
        cIDRIP = cIDRIPDecoded
        let eC2SecurityGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eC2SecurityGroupName)
        eC2SecurityGroupName = eC2SecurityGroupNameDecoded
        let eC2SecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eC2SecurityGroupId)
        eC2SecurityGroupId = eC2SecurityGroupIdDecoded
        let eC2SecurityGroupOwnerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eC2SecurityGroupOwnerId)
        eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerIdDecoded
    }
}

extension AuthorizeDBSecurityGroupIngressOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AuthorizeDBSecurityGroupIngressOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationAlreadyExists" : self = .authorizationAlreadyExistsFault(try AuthorizationAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationQuotaExceeded" : self = .authorizationQuotaExceededFault(try AuthorizationQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFound" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSecurityGroupState" : self = .invalidDBSecurityGroupStateFault(try InvalidDBSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AuthorizeDBSecurityGroupIngressOutputError: Swift.Error, Swift.Equatable {
    case authorizationAlreadyExistsFault(AuthorizationAlreadyExistsFault)
    case authorizationQuotaExceededFault(AuthorizationQuotaExceededFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case invalidDBSecurityGroupStateFault(InvalidDBSecurityGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AuthorizeDBSecurityGroupIngressOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AuthorizeDBSecurityGroupIngressOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSecurityGroup = output.dBSecurityGroup
        } else {
            self.dBSecurityGroup = nil
        }
    }
}

public struct AuthorizeDBSecurityGroupIngressOutputResponse: Swift.Equatable {
    /// Contains the details for an Amazon RDS DB security group. This data type is used as a response element in the DescribeDBSecurityGroups action.
    public var dBSecurityGroup: RdsClientTypes.DBSecurityGroup?

    public init (
        dBSecurityGroup: RdsClientTypes.DBSecurityGroup? = nil
    )
    {
        self.dBSecurityGroup = dBSecurityGroup
    }
}

struct AuthorizeDBSecurityGroupIngressOutputResponseBody: Swift.Equatable {
    let dBSecurityGroup: RdsClientTypes.DBSecurityGroup?
}

extension AuthorizeDBSecurityGroupIngressOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSecurityGroup = "DBSecurityGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("AuthorizeDBSecurityGroupIngressResult"))
        let dBSecurityGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSecurityGroup.self, forKey: .dBSecurityGroup)
        dBSecurityGroup = dBSecurityGroupDecoded
    }
}

extension RdsClientTypes {
    public enum AutomationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allPaused
        case full
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomationMode] {
            return [
                .allPaused,
                .full,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allPaused: return "all-paused"
            case .full: return "full"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutomationMode(rawValue: rawValue) ?? AutomationMode.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes.AvailabilityZone: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension RdsClientTypes {
    /// Contains Availability Zone information. This data type is used as an element in the OrderableDBInstanceOption data type.
    public struct AvailabilityZone: Swift.Equatable {
        /// The name of the Availability Zone.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension RdsClientTypes.AvailableProcessorFeature: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues = "AllowedValues"
        case defaultValue = "DefaultValue"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allowedValues = allowedValues {
            try container.encode(allowedValues, forKey: ClientRuntime.Key("AllowedValues"))
        }
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let allowedValuesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedValues)
        allowedValues = allowedValuesDecoded
    }
}

extension RdsClientTypes {
    /// Contains the available processor feature information for the DB instance class of a DB instance. For more information, see [Configuring the Processor of the DB Instance Class](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html#USER_ConfigureProcessor) in the Amazon RDS User Guide.
    public struct AvailableProcessorFeature: Swift.Equatable {
        /// The allowed values for the processor feature of the DB instance class.
        public var allowedValues: Swift.String?
        /// The default value for the processor feature of the DB instance class.
        public var defaultValue: Swift.String?
        /// The name of the processor feature. Valid names are coreCount and threadsPerCore.
        public var name: Swift.String?

        public init (
            allowedValues: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.defaultValue = defaultValue
            self.name = name
        }
    }

}

extension BacktrackDBClusterInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let backtrackTo = backtrackTo {
            try container.encode(ClientRuntime.TimestampWrapper(backtrackTo, format: .dateTime), forKey: ClientRuntime.Key("backtrackTo"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let force = force {
            try container.encode(force, forKey: ClientRuntime.Key("Force"))
        }
        if let useEarliestTimeOnPointInTimeUnavailable = useEarliestTimeOnPointInTimeUnavailable {
            try container.encode(useEarliestTimeOnPointInTimeUnavailable, forKey: ClientRuntime.Key("UseEarliestTimeOnPointInTimeUnavailable"))
        }
        try container.encode("BacktrackDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension BacktrackDBClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct BacktrackDBClusterInput: Swift.Equatable {
    /// The timestamp of the time to backtrack the DB cluster to, specified in ISO 8601 format. For more information about ISO 8601, see the [ISO8601 Wikipedia page.](http://en.wikipedia.org/wiki/ISO_8601) If the specified time isn't a consistent time for the DB cluster, Aurora automatically chooses the nearest possible consistent time for the DB cluster. Constraints:
    ///
    /// * Must contain a valid ISO 8601 timestamp.
    ///
    /// * Can't contain a timestamp set in the future.
    ///
    ///
    /// Example: 2017-07-08T18:00Z
    /// This member is required.
    public var backtrackTo: ClientRuntime.Date?
    /// The DB cluster identifier of the DB cluster to be backtracked. This parameter is stored as a lowercase string. Constraints:
    ///
    /// * Must contain from 1 to 63 alphanumeric characters or hyphens.
    ///
    /// * First character must be a letter.
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    /// Example: my-cluster1
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// A value that indicates whether to force the DB cluster to backtrack when binary logging is enabled. Otherwise, an error occurs when binary logging is enabled.
    public var force: Swift.Bool?
    /// A value that indicates whether to backtrack the DB cluster to the earliest possible backtrack time when BacktrackTo is set to a timestamp earlier than the earliest backtrack time. When this parameter is disabled and BacktrackTo is set to a timestamp earlier than the earliest backtrack time, an error occurs.
    public var useEarliestTimeOnPointInTimeUnavailable: Swift.Bool?

    public init (
        backtrackTo: ClientRuntime.Date? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        force: Swift.Bool? = nil,
        useEarliestTimeOnPointInTimeUnavailable: Swift.Bool? = nil
    )
    {
        self.backtrackTo = backtrackTo
        self.dBClusterIdentifier = dBClusterIdentifier
        self.force = force
        self.useEarliestTimeOnPointInTimeUnavailable = useEarliestTimeOnPointInTimeUnavailable
    }
}

struct BacktrackDBClusterInputBody: Swift.Equatable {
    let dBClusterIdentifier: Swift.String?
    let backtrackTo: ClientRuntime.Date?
    let force: Swift.Bool?
    let useEarliestTimeOnPointInTimeUnavailable: Swift.Bool?
}

extension BacktrackDBClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backtrackTo = "BacktrackTo"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case force = "Force"
        case useEarliestTimeOnPointInTimeUnavailable = "UseEarliestTimeOnPointInTimeUnavailable"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let backtrackToDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backtrackTo)
        var backtrackToBuffer:ClientRuntime.Date? = nil
        if let backtrackToDecoded = backtrackToDecoded {
            backtrackToBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(backtrackToDecoded, format: .dateTime)
        }
        backtrackTo = backtrackToBuffer
        let forceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .force)
        force = forceDecoded
        let useEarliestTimeOnPointInTimeUnavailableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useEarliestTimeOnPointInTimeUnavailable)
        useEarliestTimeOnPointInTimeUnavailable = useEarliestTimeOnPointInTimeUnavailableDecoded
    }
}

extension BacktrackDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension BacktrackDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BacktrackDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension BacktrackDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BacktrackDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backtrackIdentifier = output.backtrackIdentifier
            self.backtrackRequestCreationTime = output.backtrackRequestCreationTime
            self.backtrackTo = output.backtrackTo
            self.backtrackedFrom = output.backtrackedFrom
            self.dBClusterIdentifier = output.dBClusterIdentifier
            self.status = output.status
        } else {
            self.backtrackIdentifier = nil
            self.backtrackRequestCreationTime = nil
            self.backtrackTo = nil
            self.backtrackedFrom = nil
            self.dBClusterIdentifier = nil
            self.status = nil
        }
    }
}

/// This data type is used as a response element in the DescribeDBClusterBacktracks action.
public struct BacktrackDBClusterOutputResponse: Swift.Equatable {
    /// Contains the backtrack identifier.
    public var backtrackIdentifier: Swift.String?
    /// The timestamp of the time at which the backtrack was requested.
    public var backtrackRequestCreationTime: ClientRuntime.Date?
    /// The timestamp of the time to which the DB cluster was backtracked.
    public var backtrackTo: ClientRuntime.Date?
    /// The timestamp of the time from which the DB cluster was backtracked.
    public var backtrackedFrom: ClientRuntime.Date?
    /// Contains a user-supplied DB cluster identifier. This identifier is the unique key that identifies a DB cluster.
    public var dBClusterIdentifier: Swift.String?
    /// The status of the backtrack. This property returns one of the following values:
    ///
    /// * applying - The backtrack is currently being applied to or rolled back from the DB cluster.
    ///
    /// * completed - The backtrack has successfully been applied to or rolled back from the DB cluster.
    ///
    /// * failed - An error occurred while the backtrack was applied to or rolled back from the DB cluster.
    ///
    /// * pending - The backtrack is currently pending application to or rollback from the DB cluster.
    public var status: Swift.String?

    public init (
        backtrackIdentifier: Swift.String? = nil,
        backtrackRequestCreationTime: ClientRuntime.Date? = nil,
        backtrackTo: ClientRuntime.Date? = nil,
        backtrackedFrom: ClientRuntime.Date? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.backtrackIdentifier = backtrackIdentifier
        self.backtrackRequestCreationTime = backtrackRequestCreationTime
        self.backtrackTo = backtrackTo
        self.backtrackedFrom = backtrackedFrom
        self.dBClusterIdentifier = dBClusterIdentifier
        self.status = status
    }
}

struct BacktrackDBClusterOutputResponseBody: Swift.Equatable {
    let dBClusterIdentifier: Swift.String?
    let backtrackIdentifier: Swift.String?
    let backtrackTo: ClientRuntime.Date?
    let backtrackedFrom: ClientRuntime.Date?
    let backtrackRequestCreationTime: ClientRuntime.Date?
    let status: Swift.String?
}

extension BacktrackDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backtrackIdentifier = "BacktrackIdentifier"
        case backtrackRequestCreationTime = "BacktrackRequestCreationTime"
        case backtrackTo = "BacktrackTo"
        case backtrackedFrom = "BacktrackedFrom"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("BacktrackDBClusterResult"))
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let backtrackIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backtrackIdentifier)
        backtrackIdentifier = backtrackIdentifierDecoded
        let backtrackToDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backtrackTo)
        var backtrackToBuffer:ClientRuntime.Date? = nil
        if let backtrackToDecoded = backtrackToDecoded {
            backtrackToBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(backtrackToDecoded, format: .dateTime)
        }
        backtrackTo = backtrackToBuffer
        let backtrackedFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backtrackedFrom)
        var backtrackedFromBuffer:ClientRuntime.Date? = nil
        if let backtrackedFromDecoded = backtrackedFromDecoded {
            backtrackedFromBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(backtrackedFromDecoded, format: .dateTime)
        }
        backtrackedFrom = backtrackedFromBuffer
        let backtrackRequestCreationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backtrackRequestCreationTime)
        var backtrackRequestCreationTimeBuffer:ClientRuntime.Date? = nil
        if let backtrackRequestCreationTimeDecoded = backtrackRequestCreationTimeDecoded {
            backtrackRequestCreationTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(backtrackRequestCreationTimeDecoded, format: .dateTime)
        }
        backtrackRequestCreationTime = backtrackRequestCreationTimeBuffer
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension BackupPolicyNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<BackupPolicyNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

@available(*, deprecated, message: "Please avoid using this fault")
public struct BackupPolicyNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BackupPolicyNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension BackupPolicyNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CancelExportTaskInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let exportTaskIdentifier = exportTaskIdentifier {
            try container.encode(exportTaskIdentifier, forKey: ClientRuntime.Key("ExportTaskIdentifier"))
        }
        try container.encode("CancelExportTask", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CancelExportTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CancelExportTaskInput: Swift.Equatable {
    /// The identifier of the snapshot export task to cancel.
    /// This member is required.
    public var exportTaskIdentifier: Swift.String?

    public init (
        exportTaskIdentifier: Swift.String? = nil
    )
    {
        self.exportTaskIdentifier = exportTaskIdentifier
    }
}

struct CancelExportTaskInputBody: Swift.Equatable {
    let exportTaskIdentifier: Swift.String?
}

extension CancelExportTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportTaskIdentifier = "ExportTaskIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportTaskIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportTaskIdentifier)
        exportTaskIdentifier = exportTaskIdentifierDecoded
    }
}

extension CancelExportTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CancelExportTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExportTaskNotFound" : self = .exportTaskNotFoundFault(try ExportTaskNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidExportTaskStateFault" : self = .invalidExportTaskStateFault(try InvalidExportTaskStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelExportTaskOutputError: Swift.Error, Swift.Equatable {
    case exportTaskNotFoundFault(ExportTaskNotFoundFault)
    case invalidExportTaskStateFault(InvalidExportTaskStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelExportTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelExportTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exportOnly = output.exportOnly
            self.exportTaskIdentifier = output.exportTaskIdentifier
            self.failureCause = output.failureCause
            self.iamRoleArn = output.iamRoleArn
            self.kmsKeyId = output.kmsKeyId
            self.percentProgress = output.percentProgress
            self.s3Bucket = output.s3Bucket
            self.s3Prefix = output.s3Prefix
            self.snapshotTime = output.snapshotTime
            self.sourceArn = output.sourceArn
            self.status = output.status
            self.taskEndTime = output.taskEndTime
            self.taskStartTime = output.taskStartTime
            self.totalExtractedDataInGB = output.totalExtractedDataInGB
            self.warningMessage = output.warningMessage
        } else {
            self.exportOnly = nil
            self.exportTaskIdentifier = nil
            self.failureCause = nil
            self.iamRoleArn = nil
            self.kmsKeyId = nil
            self.percentProgress = 0
            self.s3Bucket = nil
            self.s3Prefix = nil
            self.snapshotTime = nil
            self.sourceArn = nil
            self.status = nil
            self.taskEndTime = nil
            self.taskStartTime = nil
            self.totalExtractedDataInGB = 0
            self.warningMessage = nil
        }
    }
}

/// Contains the details of a snapshot export to Amazon S3. This data type is used as a response element in the DescribeExportTasks action.
public struct CancelExportTaskOutputResponse: Swift.Equatable {
    /// The data exported from the snapshot. Valid values are the following:
    ///
    /// * database - Export all the data from a specified database.
    ///
    /// * database.table table-name - Export a table of the snapshot. This format is valid only for RDS for MySQL, RDS for MariaDB, and Aurora MySQL.
    ///
    /// * database.schema schema-name - Export a database schema of the snapshot. This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.
    ///
    /// * database.schema.table table-name - Export a table of the database schema. This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.
    public var exportOnly: [Swift.String]?
    /// A unique identifier for the snapshot export task. This ID isn't an identifier for the Amazon S3 bucket where the snapshot is exported to.
    public var exportTaskIdentifier: Swift.String?
    /// The reason the export failed, if it failed.
    public var failureCause: Swift.String?
    /// The name of the IAM role that is used to write to Amazon S3 when exporting a snapshot.
    public var iamRoleArn: Swift.String?
    /// The key identifier of the Amazon Web Services KMS key that is used to encrypt the snapshot when it's exported to Amazon S3. The KMS key identifier is its key ARN, key ID, alias ARN, or alias name. The IAM role used for the snapshot export must have encryption and decryption permissions to use this KMS key.
    public var kmsKeyId: Swift.String?
    /// The progress of the snapshot export task as a percentage.
    public var percentProgress: Swift.Int
    /// The Amazon S3 bucket that the snapshot is exported to.
    public var s3Bucket: Swift.String?
    /// The Amazon S3 bucket prefix that is the file name and path of the exported snapshot.
    public var s3Prefix: Swift.String?
    /// The time that the snapshot was created.
    public var snapshotTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the snapshot exported to Amazon S3.
    public var sourceArn: Swift.String?
    /// The progress status of the export task.
    public var status: Swift.String?
    /// The time that the snapshot export task completed.
    public var taskEndTime: ClientRuntime.Date?
    /// The time that the snapshot export task started.
    public var taskStartTime: ClientRuntime.Date?
    /// The total amount of data exported, in gigabytes.
    public var totalExtractedDataInGB: Swift.Int
    /// A warning about the snapshot export task.
    public var warningMessage: Swift.String?

    public init (
        exportOnly: [Swift.String]? = nil,
        exportTaskIdentifier: Swift.String? = nil,
        failureCause: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        percentProgress: Swift.Int = 0,
        s3Bucket: Swift.String? = nil,
        s3Prefix: Swift.String? = nil,
        snapshotTime: ClientRuntime.Date? = nil,
        sourceArn: Swift.String? = nil,
        status: Swift.String? = nil,
        taskEndTime: ClientRuntime.Date? = nil,
        taskStartTime: ClientRuntime.Date? = nil,
        totalExtractedDataInGB: Swift.Int = 0,
        warningMessage: Swift.String? = nil
    )
    {
        self.exportOnly = exportOnly
        self.exportTaskIdentifier = exportTaskIdentifier
        self.failureCause = failureCause
        self.iamRoleArn = iamRoleArn
        self.kmsKeyId = kmsKeyId
        self.percentProgress = percentProgress
        self.s3Bucket = s3Bucket
        self.s3Prefix = s3Prefix
        self.snapshotTime = snapshotTime
        self.sourceArn = sourceArn
        self.status = status
        self.taskEndTime = taskEndTime
        self.taskStartTime = taskStartTime
        self.totalExtractedDataInGB = totalExtractedDataInGB
        self.warningMessage = warningMessage
    }
}

struct CancelExportTaskOutputResponseBody: Swift.Equatable {
    let exportTaskIdentifier: Swift.String?
    let sourceArn: Swift.String?
    let exportOnly: [Swift.String]?
    let snapshotTime: ClientRuntime.Date?
    let taskStartTime: ClientRuntime.Date?
    let taskEndTime: ClientRuntime.Date?
    let s3Bucket: Swift.String?
    let s3Prefix: Swift.String?
    let iamRoleArn: Swift.String?
    let kmsKeyId: Swift.String?
    let status: Swift.String?
    let percentProgress: Swift.Int
    let totalExtractedDataInGB: Swift.Int
    let failureCause: Swift.String?
    let warningMessage: Swift.String?
}

extension CancelExportTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportOnly = "ExportOnly"
        case exportTaskIdentifier = "ExportTaskIdentifier"
        case failureCause = "FailureCause"
        case iamRoleArn = "IamRoleArn"
        case kmsKeyId = "KmsKeyId"
        case percentProgress = "PercentProgress"
        case s3Bucket = "S3Bucket"
        case s3Prefix = "S3Prefix"
        case snapshotTime = "SnapshotTime"
        case sourceArn = "SourceArn"
        case status = "Status"
        case taskEndTime = "TaskEndTime"
        case taskStartTime = "TaskStartTime"
        case totalExtractedDataInGB = "TotalExtractedDataInGB"
        case warningMessage = "WarningMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CancelExportTaskResult"))
        let exportTaskIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportTaskIdentifier)
        exportTaskIdentifier = exportTaskIdentifierDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        if containerValues.contains(.exportOnly) {
            struct KeyVal0{struct member{}}
            let exportOnlyWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .exportOnly)
            if let exportOnlyWrappedContainer = exportOnlyWrappedContainer {
                let exportOnlyContainer = try exportOnlyWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var exportOnlyBuffer:[Swift.String]? = nil
                if let exportOnlyContainer = exportOnlyContainer {
                    exportOnlyBuffer = [Swift.String]()
                    for stringContainer0 in exportOnlyContainer {
                        exportOnlyBuffer?.append(stringContainer0)
                    }
                }
                exportOnly = exportOnlyBuffer
            } else {
                exportOnly = []
            }
        } else {
            exportOnly = nil
        }
        let snapshotTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotTime)
        var snapshotTimeBuffer:ClientRuntime.Date? = nil
        if let snapshotTimeDecoded = snapshotTimeDecoded {
            snapshotTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(snapshotTimeDecoded, format: .dateTime)
        }
        snapshotTime = snapshotTimeBuffer
        let taskStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskStartTime)
        var taskStartTimeBuffer:ClientRuntime.Date? = nil
        if let taskStartTimeDecoded = taskStartTimeDecoded {
            taskStartTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(taskStartTimeDecoded, format: .dateTime)
        }
        taskStartTime = taskStartTimeBuffer
        let taskEndTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskEndTime)
        var taskEndTimeBuffer:ClientRuntime.Date? = nil
        if let taskEndTimeDecoded = taskEndTimeDecoded {
            taskEndTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(taskEndTimeDecoded, format: .dateTime)
        }
        taskEndTime = taskEndTimeBuffer
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let percentProgressDecoded = try containerValues.decode(Swift.Int.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let totalExtractedDataInGBDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalExtractedDataInGB)
        totalExtractedDataInGB = totalExtractedDataInGBDecoded
        let failureCauseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCause)
        failureCause = failureCauseDecoded
        let warningMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .warningMessage)
        warningMessage = warningMessageDecoded
    }
}

extension RdsClientTypes.Certificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case certificateIdentifier = "CertificateIdentifier"
        case certificateType = "CertificateType"
        case customerOverride = "CustomerOverride"
        case customerOverrideValidTill = "CustomerOverrideValidTill"
        case thumbprint = "Thumbprint"
        case validFrom = "ValidFrom"
        case validTill = "ValidTill"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateArn = certificateArn {
            try container.encode(certificateArn, forKey: ClientRuntime.Key("CertificateArn"))
        }
        if let certificateIdentifier = certificateIdentifier {
            try container.encode(certificateIdentifier, forKey: ClientRuntime.Key("CertificateIdentifier"))
        }
        if let certificateType = certificateType {
            try container.encode(certificateType, forKey: ClientRuntime.Key("CertificateType"))
        }
        if let customerOverride = customerOverride {
            try container.encode(customerOverride, forKey: ClientRuntime.Key("CustomerOverride"))
        }
        if let customerOverrideValidTill = customerOverrideValidTill {
            try container.encode(ClientRuntime.TimestampWrapper(customerOverrideValidTill, format: .dateTime), forKey: ClientRuntime.Key("customerOverrideValidTill"))
        }
        if let thumbprint = thumbprint {
            try container.encode(thumbprint, forKey: ClientRuntime.Key("Thumbprint"))
        }
        if let validFrom = validFrom {
            try container.encode(ClientRuntime.TimestampWrapper(validFrom, format: .dateTime), forKey: ClientRuntime.Key("validFrom"))
        }
        if let validTill = validTill {
            try container.encode(ClientRuntime.TimestampWrapper(validTill, format: .dateTime), forKey: ClientRuntime.Key("validTill"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateIdentifier)
        certificateIdentifier = certificateIdentifierDecoded
        let certificateTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateType)
        certificateType = certificateTypeDecoded
        let thumbprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thumbprint)
        thumbprint = thumbprintDecoded
        let validFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validFrom)
        var validFromBuffer:ClientRuntime.Date? = nil
        if let validFromDecoded = validFromDecoded {
            validFromBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(validFromDecoded, format: .dateTime)
        }
        validFrom = validFromBuffer
        let validTillDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validTill)
        var validTillBuffer:ClientRuntime.Date? = nil
        if let validTillDecoded = validTillDecoded {
            validTillBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(validTillDecoded, format: .dateTime)
        }
        validTill = validTillBuffer
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let customerOverrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .customerOverride)
        customerOverride = customerOverrideDecoded
        let customerOverrideValidTillDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerOverrideValidTill)
        var customerOverrideValidTillBuffer:ClientRuntime.Date? = nil
        if let customerOverrideValidTillDecoded = customerOverrideValidTillDecoded {
            customerOverrideValidTillBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(customerOverrideValidTillDecoded, format: .dateTime)
        }
        customerOverrideValidTill = customerOverrideValidTillBuffer
    }
}

extension RdsClientTypes {
    /// A CA certificate for an Amazon Web Services account.
    public struct Certificate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the certificate.
        public var certificateArn: Swift.String?
        /// The unique key that identifies a certificate.
        public var certificateIdentifier: Swift.String?
        /// The type of the certificate.
        public var certificateType: Swift.String?
        /// Whether there is an override for the default certificate identifier.
        public var customerOverride: Swift.Bool?
        /// If there is an override for the default certificate identifier, when the override expires.
        public var customerOverrideValidTill: ClientRuntime.Date?
        /// The thumbprint of the certificate.
        public var thumbprint: Swift.String?
        /// The starting date from which the certificate is valid.
        public var validFrom: ClientRuntime.Date?
        /// The final date that the certificate continues to be valid.
        public var validTill: ClientRuntime.Date?

        public init (
            certificateArn: Swift.String? = nil,
            certificateIdentifier: Swift.String? = nil,
            certificateType: Swift.String? = nil,
            customerOverride: Swift.Bool? = nil,
            customerOverrideValidTill: ClientRuntime.Date? = nil,
            thumbprint: Swift.String? = nil,
            validFrom: ClientRuntime.Date? = nil,
            validTill: ClientRuntime.Date? = nil
        )
        {
            self.certificateArn = certificateArn
            self.certificateIdentifier = certificateIdentifier
            self.certificateType = certificateType
            self.customerOverride = customerOverride
            self.customerOverrideValidTill = customerOverrideValidTill
            self.thumbprint = thumbprint
            self.validFrom = validFrom
            self.validTill = validTill
        }
    }

}

extension CertificateNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<CertificateNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// CertificateIdentifier doesn't refer to an existing certificate.
public struct CertificateNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CertificateNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension CertificateNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.CharacterSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case characterSetDescription = "CharacterSetDescription"
        case characterSetName = "CharacterSetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let characterSetDescription = characterSetDescription {
            try container.encode(characterSetDescription, forKey: ClientRuntime.Key("CharacterSetDescription"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: ClientRuntime.Key("CharacterSetName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let characterSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .characterSetName)
        characterSetName = characterSetNameDecoded
        let characterSetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .characterSetDescription)
        characterSetDescription = characterSetDescriptionDecoded
    }
}

extension RdsClientTypes {
    /// This data type is used as a response element in the action DescribeDBEngineVersions.
    public struct CharacterSet: Swift.Equatable {
        /// The description of the character set.
        public var characterSetDescription: Swift.String?
        /// The name of the character set.
        public var characterSetName: Swift.String?

        public init (
            characterSetDescription: Swift.String? = nil,
            characterSetName: Swift.String? = nil
        )
        {
            self.characterSetDescription = characterSetDescription
            self.characterSetName = characterSetName
        }
    }

}

extension RdsClientTypes.CloudwatchLogsExportConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disableLogTypes = "DisableLogTypes"
        case enableLogTypes = "EnableLogTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let disableLogTypes = disableLogTypes {
            var disableLogTypesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DisableLogTypes"))
            for (index0, string0) in disableLogTypes.enumerated() {
                try disableLogTypesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableLogTypes = enableLogTypes {
            var enableLogTypesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableLogTypes"))
            for (index0, string0) in enableLogTypes.enumerated() {
                try enableLogTypesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.enableLogTypes) {
            struct KeyVal0{struct member{}}
            let enableLogTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enableLogTypes)
            if let enableLogTypesWrappedContainer = enableLogTypesWrappedContainer {
                let enableLogTypesContainer = try enableLogTypesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var enableLogTypesBuffer:[Swift.String]? = nil
                if let enableLogTypesContainer = enableLogTypesContainer {
                    enableLogTypesBuffer = [Swift.String]()
                    for stringContainer0 in enableLogTypesContainer {
                        enableLogTypesBuffer?.append(stringContainer0)
                    }
                }
                enableLogTypes = enableLogTypesBuffer
            } else {
                enableLogTypes = []
            }
        } else {
            enableLogTypes = nil
        }
        if containerValues.contains(.disableLogTypes) {
            struct KeyVal0{struct member{}}
            let disableLogTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .disableLogTypes)
            if let disableLogTypesWrappedContainer = disableLogTypesWrappedContainer {
                let disableLogTypesContainer = try disableLogTypesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var disableLogTypesBuffer:[Swift.String]? = nil
                if let disableLogTypesContainer = disableLogTypesContainer {
                    disableLogTypesBuffer = [Swift.String]()
                    for stringContainer0 in disableLogTypesContainer {
                        disableLogTypesBuffer?.append(stringContainer0)
                    }
                }
                disableLogTypes = disableLogTypesBuffer
            } else {
                disableLogTypes = []
            }
        } else {
            disableLogTypes = nil
        }
    }
}

extension RdsClientTypes {
    /// The configuration setting for the log types to be enabled for export to CloudWatch Logs for a specific DB instance or DB cluster. The EnableLogTypes and DisableLogTypes arrays determine which logs will be exported (or not exported) to CloudWatch Logs. The values within these arrays depend on the DB engine being used. For more information about exporting CloudWatch Logs for Amazon RDS DB instances, see [Publishing Database Logs to Amazon CloudWatch Logs ](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch) in the Amazon RDS User Guide. For more information about exporting CloudWatch Logs for Amazon Aurora DB clusters, see [Publishing Database Logs to Amazon CloudWatch Logs](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch) in the Amazon Aurora User Guide.
    public struct CloudwatchLogsExportConfiguration: Swift.Equatable {
        /// The list of log types to disable.
        public var disableLogTypes: [Swift.String]?
        /// The list of log types to enable.
        public var enableLogTypes: [Swift.String]?

        public init (
            disableLogTypes: [Swift.String]? = nil,
            enableLogTypes: [Swift.String]? = nil
        )
        {
            self.disableLogTypes = disableLogTypes
            self.enableLogTypes = enableLogTypes
        }
    }

}

extension RdsClientTypes.ClusterPendingModifiedValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterIdentifier = "DBClusterIdentifier"
        case engineVersion = "EngineVersion"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case masterUserPassword = "MasterUserPassword"
        case pendingCloudwatchLogsExports = "PendingCloudwatchLogsExports"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: ClientRuntime.Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let pendingCloudwatchLogsExports = pendingCloudwatchLogsExports {
            try container.encode(pendingCloudwatchLogsExports, forKey: ClientRuntime.Key("PendingCloudwatchLogsExports"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pendingCloudwatchLogsExportsDecoded = try containerValues.decodeIfPresent(RdsClientTypes.PendingCloudwatchLogsExports.self, forKey: .pendingCloudwatchLogsExports)
        pendingCloudwatchLogsExports = pendingCloudwatchLogsExportsDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let masterUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUserPassword)
        masterUserPassword = masterUserPasswordDecoded
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
    }
}

extension RdsClientTypes {
    /// This data type is used as a response element in the ModifyDBCluster operation and contains changes that will be applied during the next maintenance window.
    public struct ClusterPendingModifiedValues: Swift.Equatable {
        /// The DBClusterIdentifier value for the DB cluster.
        public var dBClusterIdentifier: Swift.String?
        /// The database engine version.
        public var engineVersion: Swift.String?
        /// A value that indicates whether mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled.
        public var iAMDatabaseAuthenticationEnabled: Swift.Bool?
        /// The master credentials for the DB cluster.
        public var masterUserPassword: Swift.String?
        /// A list of the log types whose configuration is still pending. In other words, these log types are in the process of being activated or deactivated.
        public var pendingCloudwatchLogsExports: RdsClientTypes.PendingCloudwatchLogsExports?

        public init (
            dBClusterIdentifier: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            iAMDatabaseAuthenticationEnabled: Swift.Bool? = nil,
            masterUserPassword: Swift.String? = nil,
            pendingCloudwatchLogsExports: RdsClientTypes.PendingCloudwatchLogsExports? = nil
        )
        {
            self.dBClusterIdentifier = dBClusterIdentifier
            self.engineVersion = engineVersion
            self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
            self.masterUserPassword = masterUserPassword
            self.pendingCloudwatchLogsExports = pendingCloudwatchLogsExports
        }
    }

}

extension RdsClientTypes.ConnectionPoolConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionBorrowTimeout = "ConnectionBorrowTimeout"
        case initQuery = "InitQuery"
        case maxConnectionsPercent = "MaxConnectionsPercent"
        case maxIdleConnectionsPercent = "MaxIdleConnectionsPercent"
        case sessionPinningFilters = "SessionPinningFilters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let connectionBorrowTimeout = connectionBorrowTimeout {
            try container.encode(connectionBorrowTimeout, forKey: ClientRuntime.Key("ConnectionBorrowTimeout"))
        }
        if let initQuery = initQuery {
            try container.encode(initQuery, forKey: ClientRuntime.Key("InitQuery"))
        }
        if let maxConnectionsPercent = maxConnectionsPercent {
            try container.encode(maxConnectionsPercent, forKey: ClientRuntime.Key("MaxConnectionsPercent"))
        }
        if let maxIdleConnectionsPercent = maxIdleConnectionsPercent {
            try container.encode(maxIdleConnectionsPercent, forKey: ClientRuntime.Key("MaxIdleConnectionsPercent"))
        }
        if let sessionPinningFilters = sessionPinningFilters {
            var sessionPinningFiltersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SessionPinningFilters"))
            for (index0, string0) in sessionPinningFilters.enumerated() {
                try sessionPinningFiltersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxConnectionsPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConnectionsPercent)
        maxConnectionsPercent = maxConnectionsPercentDecoded
        let maxIdleConnectionsPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxIdleConnectionsPercent)
        maxIdleConnectionsPercent = maxIdleConnectionsPercentDecoded
        let connectionBorrowTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .connectionBorrowTimeout)
        connectionBorrowTimeout = connectionBorrowTimeoutDecoded
        if containerValues.contains(.sessionPinningFilters) {
            struct KeyVal0{struct member{}}
            let sessionPinningFiltersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .sessionPinningFilters)
            if let sessionPinningFiltersWrappedContainer = sessionPinningFiltersWrappedContainer {
                let sessionPinningFiltersContainer = try sessionPinningFiltersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var sessionPinningFiltersBuffer:[Swift.String]? = nil
                if let sessionPinningFiltersContainer = sessionPinningFiltersContainer {
                    sessionPinningFiltersBuffer = [Swift.String]()
                    for stringContainer0 in sessionPinningFiltersContainer {
                        sessionPinningFiltersBuffer?.append(stringContainer0)
                    }
                }
                sessionPinningFilters = sessionPinningFiltersBuffer
            } else {
                sessionPinningFilters = []
            }
        } else {
            sessionPinningFilters = nil
        }
        let initQueryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initQuery)
        initQuery = initQueryDecoded
    }
}

extension RdsClientTypes {
    /// Specifies the settings that control the size and behavior of the connection pool associated with a DBProxyTargetGroup.
    public struct ConnectionPoolConfiguration: Swift.Equatable {
        /// The number of seconds for a proxy to wait for a connection to become available in the connection pool. Only applies when the proxy has opened its maximum number of connections and all connections are busy with client sessions. Default: 120 Constraints: between 1 and 3600, or 0 representing unlimited
        public var connectionBorrowTimeout: Swift.Int?
        /// One or more SQL statements for the proxy to run when opening each new database connection. Typically used with SET statements to make sure that each connection has identical settings such as time zone and character set. For multiple statements, use semicolons as the separator. You can also include multiple variables in a single SET statement, such as SET x=1, y=2. Default: no initialization query
        public var initQuery: Swift.String?
        /// The maximum size of the connection pool for each target in a target group. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group. Default: 100 Constraints: between 1 and 100
        public var maxConnectionsPercent: Swift.Int?
        /// Controls how actively the proxy closes idle database connections in the connection pool. A high value enables the proxy to leave a high percentage of idle connections open. A low value causes the proxy to close idle client connections and return the underlying database connections to the connection pool. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group. Default: 50 Constraints: between 0 and MaxConnectionsPercent
        public var maxIdleConnectionsPercent: Swift.Int?
        /// Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection. Including an item in the list exempts that class of SQL operations from the pinning behavior. Default: no session pinning filters
        public var sessionPinningFilters: [Swift.String]?

        public init (
            connectionBorrowTimeout: Swift.Int? = nil,
            initQuery: Swift.String? = nil,
            maxConnectionsPercent: Swift.Int? = nil,
            maxIdleConnectionsPercent: Swift.Int? = nil,
            sessionPinningFilters: [Swift.String]? = nil
        )
        {
            self.connectionBorrowTimeout = connectionBorrowTimeout
            self.initQuery = initQuery
            self.maxConnectionsPercent = maxConnectionsPercent
            self.maxIdleConnectionsPercent = maxIdleConnectionsPercent
            self.sessionPinningFilters = sessionPinningFilters
        }
    }

}

extension RdsClientTypes.ConnectionPoolConfigurationInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionBorrowTimeout = "ConnectionBorrowTimeout"
        case initQuery = "InitQuery"
        case maxConnectionsPercent = "MaxConnectionsPercent"
        case maxIdleConnectionsPercent = "MaxIdleConnectionsPercent"
        case sessionPinningFilters = "SessionPinningFilters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if connectionBorrowTimeout != 0 {
            try container.encode(connectionBorrowTimeout, forKey: ClientRuntime.Key("ConnectionBorrowTimeout"))
        }
        if let initQuery = initQuery {
            try container.encode(initQuery, forKey: ClientRuntime.Key("InitQuery"))
        }
        if maxConnectionsPercent != 0 {
            try container.encode(maxConnectionsPercent, forKey: ClientRuntime.Key("MaxConnectionsPercent"))
        }
        if maxIdleConnectionsPercent != 0 {
            try container.encode(maxIdleConnectionsPercent, forKey: ClientRuntime.Key("MaxIdleConnectionsPercent"))
        }
        if let sessionPinningFilters = sessionPinningFilters {
            var sessionPinningFiltersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SessionPinningFilters"))
            for (index0, string0) in sessionPinningFilters.enumerated() {
                try sessionPinningFiltersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxConnectionsPercentDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxConnectionsPercent)
        maxConnectionsPercent = maxConnectionsPercentDecoded
        let maxIdleConnectionsPercentDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxIdleConnectionsPercent)
        maxIdleConnectionsPercent = maxIdleConnectionsPercentDecoded
        let connectionBorrowTimeoutDecoded = try containerValues.decode(Swift.Int.self, forKey: .connectionBorrowTimeout)
        connectionBorrowTimeout = connectionBorrowTimeoutDecoded
        if containerValues.contains(.sessionPinningFilters) {
            struct KeyVal0{struct member{}}
            let sessionPinningFiltersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .sessionPinningFilters)
            if let sessionPinningFiltersWrappedContainer = sessionPinningFiltersWrappedContainer {
                let sessionPinningFiltersContainer = try sessionPinningFiltersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var sessionPinningFiltersBuffer:[Swift.String]? = nil
                if let sessionPinningFiltersContainer = sessionPinningFiltersContainer {
                    sessionPinningFiltersBuffer = [Swift.String]()
                    for stringContainer0 in sessionPinningFiltersContainer {
                        sessionPinningFiltersBuffer?.append(stringContainer0)
                    }
                }
                sessionPinningFilters = sessionPinningFiltersBuffer
            } else {
                sessionPinningFilters = []
            }
        } else {
            sessionPinningFilters = nil
        }
        let initQueryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initQuery)
        initQuery = initQueryDecoded
    }
}

extension RdsClientTypes {
    /// Displays the settings that control the size and behavior of the connection pool associated with a DBProxyTarget.
    public struct ConnectionPoolConfigurationInfo: Swift.Equatable {
        /// The number of seconds for a proxy to wait for a connection to become available in the connection pool. Only applies when the proxy has opened its maximum number of connections and all connections are busy with client sessions.
        public var connectionBorrowTimeout: Swift.Int
        /// One or more SQL statements for the proxy to run when opening each new database connection. Typically used with SET statements to make sure that each connection has identical settings such as time zone and character set. This setting is empty by default. For multiple statements, use semicolons as the separator. You can also include multiple variables in a single SET statement, such as SET x=1, y=2.
        public var initQuery: Swift.String?
        /// The maximum size of the connection pool for each target in a target group. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group.
        public var maxConnectionsPercent: Swift.Int
        /// Controls how actively the proxy closes idle database connections in the connection pool. A high value enables the proxy to leave a high percentage of idle connections open. A low value causes the proxy to close idle client connections and return the underlying database connections to the connection pool. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group.
        public var maxIdleConnectionsPercent: Swift.Int
        /// Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection. Including an item in the list exempts that class of SQL operations from the pinning behavior. Currently, the only allowed value is EXCLUDE_VARIABLE_SETS.
        public var sessionPinningFilters: [Swift.String]?

        public init (
            connectionBorrowTimeout: Swift.Int = 0,
            initQuery: Swift.String? = nil,
            maxConnectionsPercent: Swift.Int = 0,
            maxIdleConnectionsPercent: Swift.Int = 0,
            sessionPinningFilters: [Swift.String]? = nil
        )
        {
            self.connectionBorrowTimeout = connectionBorrowTimeout
            self.initQuery = initQuery
            self.maxConnectionsPercent = maxConnectionsPercent
            self.maxIdleConnectionsPercent = maxIdleConnectionsPercent
            self.sessionPinningFilters = sessionPinningFilters
        }
    }

}

extension CopyDBClusterParameterGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sourceDBClusterParameterGroupIdentifier = sourceDBClusterParameterGroupIdentifier {
            try container.encode(sourceDBClusterParameterGroupIdentifier, forKey: ClientRuntime.Key("SourceDBClusterParameterGroupIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetDBClusterParameterGroupDescription = targetDBClusterParameterGroupDescription {
            try container.encode(targetDBClusterParameterGroupDescription, forKey: ClientRuntime.Key("TargetDBClusterParameterGroupDescription"))
        }
        if let targetDBClusterParameterGroupIdentifier = targetDBClusterParameterGroupIdentifier {
            try container.encode(targetDBClusterParameterGroupIdentifier, forKey: ClientRuntime.Key("TargetDBClusterParameterGroupIdentifier"))
        }
        try container.encode("CopyDBClusterParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CopyDBClusterParameterGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CopyDBClusterParameterGroupInput: Swift.Equatable {
    /// The identifier or Amazon Resource Name (ARN) for the source DB cluster parameter group. For information about creating an ARN, see [ Constructing an ARN for Amazon RDS](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing) in the Amazon Aurora User Guide. Constraints:
    ///
    /// * Must specify a valid DB cluster parameter group.
    /// This member is required.
    public var sourceDBClusterParameterGroupIdentifier: Swift.String?
    /// A list of tags. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
    public var tags: [RdsClientTypes.Tag]?
    /// A description for the copied DB cluster parameter group.
    /// This member is required.
    public var targetDBClusterParameterGroupDescription: Swift.String?
    /// The identifier for the copied DB cluster parameter group. Constraints:
    ///
    /// * Can't be null, empty, or blank
    ///
    /// * Must contain from 1 to 255 letters, numbers, or hyphens
    ///
    /// * First character must be a letter
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    /// Example: my-cluster-param-group1
    /// This member is required.
    public var targetDBClusterParameterGroupIdentifier: Swift.String?

    public init (
        sourceDBClusterParameterGroupIdentifier: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        targetDBClusterParameterGroupDescription: Swift.String? = nil,
        targetDBClusterParameterGroupIdentifier: Swift.String? = nil
    )
    {
        self.sourceDBClusterParameterGroupIdentifier = sourceDBClusterParameterGroupIdentifier
        self.tags = tags
        self.targetDBClusterParameterGroupDescription = targetDBClusterParameterGroupDescription
        self.targetDBClusterParameterGroupIdentifier = targetDBClusterParameterGroupIdentifier
    }
}

struct CopyDBClusterParameterGroupInputBody: Swift.Equatable {
    let sourceDBClusterParameterGroupIdentifier: Swift.String?
    let targetDBClusterParameterGroupIdentifier: Swift.String?
    let targetDBClusterParameterGroupDescription: Swift.String?
    let tags: [RdsClientTypes.Tag]?
}

extension CopyDBClusterParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceDBClusterParameterGroupIdentifier = "SourceDBClusterParameterGroupIdentifier"
        case tags = "Tags"
        case targetDBClusterParameterGroupDescription = "TargetDBClusterParameterGroupDescription"
        case targetDBClusterParameterGroupIdentifier = "TargetDBClusterParameterGroupIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDBClusterParameterGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDBClusterParameterGroupIdentifier)
        sourceDBClusterParameterGroupIdentifier = sourceDBClusterParameterGroupIdentifierDecoded
        let targetDBClusterParameterGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetDBClusterParameterGroupIdentifier)
        targetDBClusterParameterGroupIdentifier = targetDBClusterParameterGroupIdentifierDecoded
        let targetDBClusterParameterGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetDBClusterParameterGroupDescription)
        targetDBClusterParameterGroupDescription = targetDBClusterParameterGroupDescriptionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CopyDBClusterParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyDBClusterParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupAlreadyExists" : self = .dBParameterGroupAlreadyExistsFault(try DBParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupQuotaExceeded" : self = .dBParameterGroupQuotaExceededFault(try DBParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyDBClusterParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupAlreadyExistsFault(DBParameterGroupAlreadyExistsFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBParameterGroupQuotaExceededFault(DBParameterGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyDBClusterParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CopyDBClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterParameterGroup = output.dBClusterParameterGroup
        } else {
            self.dBClusterParameterGroup = nil
        }
    }
}

public struct CopyDBClusterParameterGroupOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB cluster parameter group. This data type is used as a response element in the DescribeDBClusterParameterGroups action.
    public var dBClusterParameterGroup: RdsClientTypes.DBClusterParameterGroup?

    public init (
        dBClusterParameterGroup: RdsClientTypes.DBClusterParameterGroup? = nil
    )
    {
        self.dBClusterParameterGroup = dBClusterParameterGroup
    }
}

struct CopyDBClusterParameterGroupOutputResponseBody: Swift.Equatable {
    let dBClusterParameterGroup: RdsClientTypes.DBClusterParameterGroup?
}

extension CopyDBClusterParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroup = "DBClusterParameterGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CopyDBClusterParameterGroupResult"))
        let dBClusterParameterGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBClusterParameterGroup.self, forKey: .dBClusterParameterGroup)
        dBClusterParameterGroup = dBClusterParameterGroupDecoded
    }
}

extension CopyDBClusterSnapshotInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let copyTags = copyTags {
            try container.encode(copyTags, forKey: ClientRuntime.Key("CopyTags"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let preSignedUrl = preSignedUrl {
            try container.encode(preSignedUrl, forKey: ClientRuntime.Key("PreSignedUrl"))
        }
        if let sourceDBClusterSnapshotIdentifier = sourceDBClusterSnapshotIdentifier {
            try container.encode(sourceDBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("SourceDBClusterSnapshotIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetDBClusterSnapshotIdentifier = targetDBClusterSnapshotIdentifier {
            try container.encode(targetDBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("TargetDBClusterSnapshotIdentifier"))
        }
        try container.encode("CopyDBClusterSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CopyDBClusterSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CopyDBClusterSnapshotInput: Swift.Equatable {
    /// A value that indicates whether to copy all tags from the source DB cluster snapshot to the target DB cluster snapshot. By default, tags are not copied.
    public var copyTags: Swift.Bool?
    /// The Amazon Web Services KMS key identifier for an encrypted DB cluster snapshot. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS key. If you copy an encrypted DB cluster snapshot from your Amazon Web Services account, you can specify a value for KmsKeyId to encrypt the copy with a new KMS key. If you don't specify a value for KmsKeyId, then the copy of the DB cluster snapshot is encrypted with the same KMS key as the source DB cluster snapshot. If you copy an encrypted DB cluster snapshot that is shared from another Amazon Web Services account, then you must specify a value for KmsKeyId. To copy an encrypted DB cluster snapshot to another Amazon Web Services Region, you must set KmsKeyId to the Amazon Web Services KMS key identifier you want to use to encrypt the copy of the DB cluster snapshot in the destination Amazon Web Services Region. KMS keys are specific to the Amazon Web Services Region that they are created in, and you can't use KMS keys from one Amazon Web Services Region in another Amazon Web Services Region. If you copy an unencrypted DB cluster snapshot and specify a value for the KmsKeyId parameter, an error is returned.
    public var kmsKeyId: Swift.String?
    /// The URL that contains a Signature Version 4 signed request for the CopyDBClusterSnapshot API action in the Amazon Web Services Region that contains the source DB cluster snapshot to copy. The PreSignedUrl parameter must be used when copying an encrypted DB cluster snapshot from another Amazon Web Services Region. Don't specify PreSignedUrl when you are copying an encrypted DB cluster snapshot in the same Amazon Web Services Region. The pre-signed URL must be a valid request for the CopyDBClusterSnapshot API action that can be executed in the source Amazon Web Services Region that contains the encrypted DB cluster snapshot to be copied. The pre-signed URL request must contain the following parameter values:
    ///
    /// * KmsKeyId - The Amazon Web Services KMS key identifier for the KMS key to use to encrypt the copy of the DB cluster snapshot in the destination Amazon Web Services Region. This is the same identifier for both the CopyDBClusterSnapshot action that is called in the destination Amazon Web Services Region, and the action contained in the pre-signed URL.
    ///
    /// * DestinationRegion - The name of the Amazon Web Services Region that the DB cluster snapshot is to be created in.
    ///
    /// * SourceDBClusterSnapshotIdentifier - The DB cluster snapshot identifier for the encrypted DB cluster snapshot to be copied. This identifier must be in the Amazon Resource Name (ARN) format for the source Amazon Web Services Region. For example, if you are copying an encrypted DB cluster snapshot from the us-west-2 Amazon Web Services Region, then your SourceDBClusterSnapshotIdentifier looks like the following example: arn:aws:rds:us-west-2:123456789012:cluster-snapshot:aurora-cluster1-snapshot-20161115.
    ///
    ///
    /// To learn how to generate a Signature Version 4 signed request, see [ Authenticating Requests: Using Query Parameters (Amazon Web Services Signature Version 4)](https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html) and [ Signature Version 4 Signing Process](https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html). If you are using an Amazon Web Services SDK tool or the CLI, you can specify SourceRegion (or --source-region for the CLI) instead of specifying PreSignedUrl manually. Specifying SourceRegion autogenerates a pre-signed URL that is a valid request for the operation that can be executed in the source Amazon Web Services Region.
    public var preSignedUrl: Swift.String?
    /// The identifier of the DB cluster snapshot to copy. This parameter isn't case-sensitive. You can't copy an encrypted, shared DB cluster snapshot from one Amazon Web Services Region to another. Constraints:
    ///
    /// * Must specify a valid system snapshot in the "available" state.
    ///
    /// * If the source snapshot is in the same Amazon Web Services Region as the copy, specify a valid DB snapshot identifier.
    ///
    /// * If the source snapshot is in a different Amazon Web Services Region than the copy, specify a valid DB cluster snapshot ARN. For more information, go to [ Copying Snapshots Across Amazon Web Services Regions](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_CopySnapshot.html#USER_CopySnapshot.AcrossRegions) in the Amazon Aurora User Guide.
    ///
    ///
    /// Example: my-cluster-snapshot1
    /// This member is required.
    public var sourceDBClusterSnapshotIdentifier: Swift.String?
    /// A list of tags. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
    public var tags: [RdsClientTypes.Tag]?
    /// The identifier of the new DB cluster snapshot to create from the source DB cluster snapshot. This parameter isn't case-sensitive. Constraints:
    ///
    /// * Must contain from 1 to 63 letters, numbers, or hyphens.
    ///
    /// * First character must be a letter.
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    /// Example: my-cluster-snapshot2
    /// This member is required.
    public var targetDBClusterSnapshotIdentifier: Swift.String?

    public init (
        copyTags: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        preSignedUrl: Swift.String? = nil,
        sourceDBClusterSnapshotIdentifier: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        targetDBClusterSnapshotIdentifier: Swift.String? = nil
    )
    {
        self.copyTags = copyTags
        self.kmsKeyId = kmsKeyId
        self.preSignedUrl = preSignedUrl
        self.sourceDBClusterSnapshotIdentifier = sourceDBClusterSnapshotIdentifier
        self.tags = tags
        self.targetDBClusterSnapshotIdentifier = targetDBClusterSnapshotIdentifier
    }
}

struct CopyDBClusterSnapshotInputBody: Swift.Equatable {
    let sourceDBClusterSnapshotIdentifier: Swift.String?
    let targetDBClusterSnapshotIdentifier: Swift.String?
    let kmsKeyId: Swift.String?
    let preSignedUrl: Swift.String?
    let copyTags: Swift.Bool?
    let tags: [RdsClientTypes.Tag]?
}

extension CopyDBClusterSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyTags = "CopyTags"
        case kmsKeyId = "KmsKeyId"
        case preSignedUrl = "PreSignedUrl"
        case sourceDBClusterSnapshotIdentifier = "SourceDBClusterSnapshotIdentifier"
        case tags = "Tags"
        case targetDBClusterSnapshotIdentifier = "TargetDBClusterSnapshotIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDBClusterSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDBClusterSnapshotIdentifier)
        sourceDBClusterSnapshotIdentifier = sourceDBClusterSnapshotIdentifierDecoded
        let targetDBClusterSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetDBClusterSnapshotIdentifier)
        targetDBClusterSnapshotIdentifier = targetDBClusterSnapshotIdentifierDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let preSignedUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preSignedUrl)
        preSignedUrl = preSignedUrlDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CopyDBClusterSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyDBClusterSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotAlreadyExistsFault" : self = .dBClusterSnapshotAlreadyExistsFault(try DBClusterSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceeded" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyDBClusterSnapshotOutputError: Swift.Error, Swift.Equatable {
    case dBClusterSnapshotAlreadyExistsFault(DBClusterSnapshotAlreadyExistsFault)
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyDBClusterSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CopyDBClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterSnapshot = output.dBClusterSnapshot
        } else {
            self.dBClusterSnapshot = nil
        }
    }
}

public struct CopyDBClusterSnapshotOutputResponse: Swift.Equatable {
    /// Contains the details for an Amazon RDS DB cluster snapshot This data type is used as a response element in the DescribeDBClusterSnapshots action.
    public var dBClusterSnapshot: RdsClientTypes.DBClusterSnapshot?

    public init (
        dBClusterSnapshot: RdsClientTypes.DBClusterSnapshot? = nil
    )
    {
        self.dBClusterSnapshot = dBClusterSnapshot
    }
}

struct CopyDBClusterSnapshotOutputResponseBody: Swift.Equatable {
    let dBClusterSnapshot: RdsClientTypes.DBClusterSnapshot?
}

extension CopyDBClusterSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterSnapshot = "DBClusterSnapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CopyDBClusterSnapshotResult"))
        let dBClusterSnapshotDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBClusterSnapshot.self, forKey: .dBClusterSnapshot)
        dBClusterSnapshot = dBClusterSnapshotDecoded
    }
}

extension CopyDBParameterGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sourceDBParameterGroupIdentifier = sourceDBParameterGroupIdentifier {
            try container.encode(sourceDBParameterGroupIdentifier, forKey: ClientRuntime.Key("SourceDBParameterGroupIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetDBParameterGroupDescription = targetDBParameterGroupDescription {
            try container.encode(targetDBParameterGroupDescription, forKey: ClientRuntime.Key("TargetDBParameterGroupDescription"))
        }
        if let targetDBParameterGroupIdentifier = targetDBParameterGroupIdentifier {
            try container.encode(targetDBParameterGroupIdentifier, forKey: ClientRuntime.Key("TargetDBParameterGroupIdentifier"))
        }
        try container.encode("CopyDBParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CopyDBParameterGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CopyDBParameterGroupInput: Swift.Equatable {
    /// The identifier or ARN for the source DB parameter group. For information about creating an ARN, see [ Constructing an ARN for Amazon RDS](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing) in the Amazon RDS User Guide. Constraints:
    ///
    /// * Must specify a valid DB parameter group.
    /// This member is required.
    public var sourceDBParameterGroupIdentifier: Swift.String?
    /// A list of tags. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
    public var tags: [RdsClientTypes.Tag]?
    /// A description for the copied DB parameter group.
    /// This member is required.
    public var targetDBParameterGroupDescription: Swift.String?
    /// The identifier for the copied DB parameter group. Constraints:
    ///
    /// * Can't be null, empty, or blank
    ///
    /// * Must contain from 1 to 255 letters, numbers, or hyphens
    ///
    /// * First character must be a letter
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    /// Example: my-db-parameter-group
    /// This member is required.
    public var targetDBParameterGroupIdentifier: Swift.String?

    public init (
        sourceDBParameterGroupIdentifier: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        targetDBParameterGroupDescription: Swift.String? = nil,
        targetDBParameterGroupIdentifier: Swift.String? = nil
    )
    {
        self.sourceDBParameterGroupIdentifier = sourceDBParameterGroupIdentifier
        self.tags = tags
        self.targetDBParameterGroupDescription = targetDBParameterGroupDescription
        self.targetDBParameterGroupIdentifier = targetDBParameterGroupIdentifier
    }
}

struct CopyDBParameterGroupInputBody: Swift.Equatable {
    let sourceDBParameterGroupIdentifier: Swift.String?
    let targetDBParameterGroupIdentifier: Swift.String?
    let targetDBParameterGroupDescription: Swift.String?
    let tags: [RdsClientTypes.Tag]?
}

extension CopyDBParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceDBParameterGroupIdentifier = "SourceDBParameterGroupIdentifier"
        case tags = "Tags"
        case targetDBParameterGroupDescription = "TargetDBParameterGroupDescription"
        case targetDBParameterGroupIdentifier = "TargetDBParameterGroupIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDBParameterGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDBParameterGroupIdentifier)
        sourceDBParameterGroupIdentifier = sourceDBParameterGroupIdentifierDecoded
        let targetDBParameterGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetDBParameterGroupIdentifier)
        targetDBParameterGroupIdentifier = targetDBParameterGroupIdentifierDecoded
        let targetDBParameterGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetDBParameterGroupDescription)
        targetDBParameterGroupDescription = targetDBParameterGroupDescriptionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CopyDBParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyDBParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupAlreadyExists" : self = .dBParameterGroupAlreadyExistsFault(try DBParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupQuotaExceeded" : self = .dBParameterGroupQuotaExceededFault(try DBParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyDBParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupAlreadyExistsFault(DBParameterGroupAlreadyExistsFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBParameterGroupQuotaExceededFault(DBParameterGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyDBParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CopyDBParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBParameterGroup = output.dBParameterGroup
        } else {
            self.dBParameterGroup = nil
        }
    }
}

public struct CopyDBParameterGroupOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB parameter group. This data type is used as a response element in the DescribeDBParameterGroups action.
    public var dBParameterGroup: RdsClientTypes.DBParameterGroup?

    public init (
        dBParameterGroup: RdsClientTypes.DBParameterGroup? = nil
    )
    {
        self.dBParameterGroup = dBParameterGroup
    }
}

struct CopyDBParameterGroupOutputResponseBody: Swift.Equatable {
    let dBParameterGroup: RdsClientTypes.DBParameterGroup?
}

extension CopyDBParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroup = "DBParameterGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CopyDBParameterGroupResult"))
        let dBParameterGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBParameterGroup.self, forKey: .dBParameterGroup)
        dBParameterGroup = dBParameterGroupDecoded
    }
}

extension CopyDBSnapshotInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let copyTags = copyTags {
            try container.encode(copyTags, forKey: ClientRuntime.Key("CopyTags"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let preSignedUrl = preSignedUrl {
            try container.encode(preSignedUrl, forKey: ClientRuntime.Key("PreSignedUrl"))
        }
        if let sourceDBSnapshotIdentifier = sourceDBSnapshotIdentifier {
            try container.encode(sourceDBSnapshotIdentifier, forKey: ClientRuntime.Key("SourceDBSnapshotIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetCustomAvailabilityZone = targetCustomAvailabilityZone {
            try container.encode(targetCustomAvailabilityZone, forKey: ClientRuntime.Key("TargetCustomAvailabilityZone"))
        }
        if let targetDBSnapshotIdentifier = targetDBSnapshotIdentifier {
            try container.encode(targetDBSnapshotIdentifier, forKey: ClientRuntime.Key("TargetDBSnapshotIdentifier"))
        }
        try container.encode("CopyDBSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CopyDBSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CopyDBSnapshotInput: Swift.Equatable {
    /// A value that indicates whether to copy all tags from the source DB snapshot to the target DB snapshot. By default, tags are not copied.
    public var copyTags: Swift.Bool?
    /// The Amazon Web Services KMS key identifier for an encrypted DB snapshot. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. If you copy an encrypted DB snapshot from your Amazon Web Services account, you can specify a value for this parameter to encrypt the copy with a new KMS key. If you don't specify a value for this parameter, then the copy of the DB snapshot is encrypted with the same Amazon Web Services KMS key as the source DB snapshot. If you copy an encrypted DB snapshot that is shared from another Amazon Web Services account, then you must specify a value for this parameter. If you specify this parameter when you copy an unencrypted snapshot, the copy is encrypted. If you copy an encrypted snapshot to a different Amazon Web Services Region, then you must specify an Amazon Web Services KMS key identifier for the destination Amazon Web Services Region. KMS keys are specific to the Amazon Web Services Region that they are created in, and you can't use KMS keys from one Amazon Web Services Region in another Amazon Web Services Region.
    public var kmsKeyId: Swift.String?
    /// The name of an option group to associate with the copy of the snapshot. Specify this option if you are copying a snapshot from one Amazon Web Services Region to another, and your DB instance uses a nondefault option group. If your source DB instance uses Transparent Data Encryption for Oracle or Microsoft SQL Server, you must specify this option when copying across Amazon Web Services Regions. For more information, see [Option group considerations](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_CopySnapshot.html#USER_CopySnapshot.Options) in the Amazon RDS User Guide.
    public var optionGroupName: Swift.String?
    /// The URL that contains a Signature Version 4 signed request for the CopyDBSnapshot API action in the source Amazon Web Services Region that contains the source DB snapshot to copy. You must specify this parameter when you copy an encrypted DB snapshot from another Amazon Web Services Region by using the Amazon RDS API. Don't specify PreSignedUrl when you are copying an encrypted DB snapshot in the same Amazon Web Services Region. The presigned URL must be a valid request for the CopyDBSnapshot API action that can be executed in the source Amazon Web Services Region that contains the encrypted DB snapshot to be copied. The presigned URL request must contain the following parameter values:
    ///
    /// * DestinationRegion - The Amazon Web Services Region that the encrypted DB snapshot is copied to. This Amazon Web Services Region is the same one where the CopyDBSnapshot action is called that contains this presigned URL. For example, if you copy an encrypted DB snapshot from the us-west-2 Amazon Web Services Region to the us-east-1 Amazon Web Services Region, then you call the CopyDBSnapshot action in the us-east-1 Amazon Web Services Region and provide a presigned URL that contains a call to the CopyDBSnapshot action in the us-west-2 Amazon Web Services Region. For this example, the DestinationRegion in the presigned URL must be set to the us-east-1 Amazon Web Services Region.
    ///
    /// * KmsKeyId - The Amazon Web Services KMS key identifier for the KMS key to use to encrypt the copy of the DB snapshot in the destination Amazon Web Services Region. This is the same identifier for both the CopyDBSnapshot action that is called in the destination Amazon Web Services Region, and the action contained in the presigned URL.
    ///
    /// * SourceDBSnapshotIdentifier - The DB snapshot identifier for the encrypted snapshot to be copied. This identifier must be in the Amazon Resource Name (ARN) format for the source Amazon Web Services Region. For example, if you are copying an encrypted DB snapshot from the us-west-2 Amazon Web Services Region, then your SourceDBSnapshotIdentifier looks like the following example: arn:aws:rds:us-west-2:123456789012:snapshot:mysql-instance1-snapshot-20161115.
    ///
    ///
    /// To learn how to generate a Signature Version 4 signed request, see [Authenticating Requests: Using Query Parameters (Amazon Web Services Signature Version 4)](https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html) and [Signature Version 4 Signing Process](https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html). If you are using an Amazon Web Services SDK tool or the CLI, you can specify SourceRegion (or --source-region for the CLI) instead of specifying PreSignedUrl manually. Specifying SourceRegion autogenerates a pre-signed URL that is a valid request for the operation that can be executed in the source Amazon Web Services Region.
    public var preSignedUrl: Swift.String?
    /// The identifier for the source DB snapshot. If the source snapshot is in the same Amazon Web Services Region as the copy, specify a valid DB snapshot identifier. For example, you might specify rds:mysql-instance1-snapshot-20130805. If the source snapshot is in a different Amazon Web Services Region than the copy, specify a valid DB snapshot ARN. For example, you might specify arn:aws:rds:us-west-2:123456789012:snapshot:mysql-instance1-snapshot-20130805. If you are copying from a shared manual DB snapshot, this parameter must be the Amazon Resource Name (ARN) of the shared DB snapshot. If you are copying an encrypted snapshot this parameter must be in the ARN format for the source Amazon Web Services Region, and must match the SourceDBSnapshotIdentifier in the PreSignedUrl parameter. Constraints:
    ///
    /// * Must specify a valid system snapshot in the "available" state.
    ///
    ///
    /// Example: rds:mydb-2012-04-02-00-01 Example: arn:aws:rds:us-west-2:123456789012:snapshot:mysql-instance1-snapshot-20130805
    /// This member is required.
    public var sourceDBSnapshotIdentifier: Swift.String?
    /// A list of tags. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
    public var tags: [RdsClientTypes.Tag]?
    /// The external custom Availability Zone (CAZ) identifier for the target CAZ. Example: rds-caz-aiqhTgQv.
    public var targetCustomAvailabilityZone: Swift.String?
    /// The identifier for the copy of the snapshot. Constraints:
    ///
    /// * Can't be null, empty, or blank
    ///
    /// * Must contain from 1 to 255 letters, numbers, or hyphens
    ///
    /// * First character must be a letter
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    /// Example: my-db-snapshot
    /// This member is required.
    public var targetDBSnapshotIdentifier: Swift.String?

    public init (
        copyTags: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        optionGroupName: Swift.String? = nil,
        preSignedUrl: Swift.String? = nil,
        sourceDBSnapshotIdentifier: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        targetCustomAvailabilityZone: Swift.String? = nil,
        targetDBSnapshotIdentifier: Swift.String? = nil
    )
    {
        self.copyTags = copyTags
        self.kmsKeyId = kmsKeyId
        self.optionGroupName = optionGroupName
        self.preSignedUrl = preSignedUrl
        self.sourceDBSnapshotIdentifier = sourceDBSnapshotIdentifier
        self.tags = tags
        self.targetCustomAvailabilityZone = targetCustomAvailabilityZone
        self.targetDBSnapshotIdentifier = targetDBSnapshotIdentifier
    }
}

struct CopyDBSnapshotInputBody: Swift.Equatable {
    let sourceDBSnapshotIdentifier: Swift.String?
    let targetDBSnapshotIdentifier: Swift.String?
    let kmsKeyId: Swift.String?
    let tags: [RdsClientTypes.Tag]?
    let copyTags: Swift.Bool?
    let preSignedUrl: Swift.String?
    let optionGroupName: Swift.String?
    let targetCustomAvailabilityZone: Swift.String?
}

extension CopyDBSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyTags = "CopyTags"
        case kmsKeyId = "KmsKeyId"
        case optionGroupName = "OptionGroupName"
        case preSignedUrl = "PreSignedUrl"
        case sourceDBSnapshotIdentifier = "SourceDBSnapshotIdentifier"
        case tags = "Tags"
        case targetCustomAvailabilityZone = "TargetCustomAvailabilityZone"
        case targetDBSnapshotIdentifier = "TargetDBSnapshotIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDBSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDBSnapshotIdentifier)
        sourceDBSnapshotIdentifier = sourceDBSnapshotIdentifierDecoded
        let targetDBSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetDBSnapshotIdentifier)
        targetDBSnapshotIdentifier = targetDBSnapshotIdentifierDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let preSignedUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preSignedUrl)
        preSignedUrl = preSignedUrlDecoded
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let targetCustomAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetCustomAvailabilityZone)
        targetCustomAvailabilityZone = targetCustomAvailabilityZoneDecoded
    }
}

extension CopyDBSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyDBSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CustomAvailabilityZoneNotFound" : self = .customAvailabilityZoneNotFoundFault(try CustomAvailabilityZoneNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotAlreadyExists" : self = .dBSnapshotAlreadyExistsFault(try DBSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSnapshotState" : self = .invalidDBSnapshotStateFault(try InvalidDBSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceeded" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyDBSnapshotOutputError: Swift.Error, Swift.Equatable {
    case customAvailabilityZoneNotFoundFault(CustomAvailabilityZoneNotFoundFault)
    case dBSnapshotAlreadyExistsFault(DBSnapshotAlreadyExistsFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case invalidDBSnapshotStateFault(InvalidDBSnapshotStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyDBSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CopyDBSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSnapshot = output.dBSnapshot
        } else {
            self.dBSnapshot = nil
        }
    }
}

public struct CopyDBSnapshotOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB snapshot. This data type is used as a response element in the DescribeDBSnapshots action.
    public var dBSnapshot: RdsClientTypes.DBSnapshot?

    public init (
        dBSnapshot: RdsClientTypes.DBSnapshot? = nil
    )
    {
        self.dBSnapshot = dBSnapshot
    }
}

struct CopyDBSnapshotOutputResponseBody: Swift.Equatable {
    let dBSnapshot: RdsClientTypes.DBSnapshot?
}

extension CopyDBSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSnapshot = "DBSnapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CopyDBSnapshotResult"))
        let dBSnapshotDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSnapshot.self, forKey: .dBSnapshot)
        dBSnapshot = dBSnapshotDecoded
    }
}

extension CopyOptionGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sourceOptionGroupIdentifier = sourceOptionGroupIdentifier {
            try container.encode(sourceOptionGroupIdentifier, forKey: ClientRuntime.Key("SourceOptionGroupIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetOptionGroupDescription = targetOptionGroupDescription {
            try container.encode(targetOptionGroupDescription, forKey: ClientRuntime.Key("TargetOptionGroupDescription"))
        }
        if let targetOptionGroupIdentifier = targetOptionGroupIdentifier {
            try container.encode(targetOptionGroupIdentifier, forKey: ClientRuntime.Key("TargetOptionGroupIdentifier"))
        }
        try container.encode("CopyOptionGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CopyOptionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CopyOptionGroupInput: Swift.Equatable {
    /// The identifier for the source option group. Constraints:
    ///
    /// * Must specify a valid option group.
    /// This member is required.
    public var sourceOptionGroupIdentifier: Swift.String?
    /// A list of tags. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
    public var tags: [RdsClientTypes.Tag]?
    /// The description for the copied option group.
    /// This member is required.
    public var targetOptionGroupDescription: Swift.String?
    /// The identifier for the copied option group. Constraints:
    ///
    /// * Can't be null, empty, or blank
    ///
    /// * Must contain from 1 to 255 letters, numbers, or hyphens
    ///
    /// * First character must be a letter
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    /// Example: my-option-group
    /// This member is required.
    public var targetOptionGroupIdentifier: Swift.String?

    public init (
        sourceOptionGroupIdentifier: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        targetOptionGroupDescription: Swift.String? = nil,
        targetOptionGroupIdentifier: Swift.String? = nil
    )
    {
        self.sourceOptionGroupIdentifier = sourceOptionGroupIdentifier
        self.tags = tags
        self.targetOptionGroupDescription = targetOptionGroupDescription
        self.targetOptionGroupIdentifier = targetOptionGroupIdentifier
    }
}

struct CopyOptionGroupInputBody: Swift.Equatable {
    let sourceOptionGroupIdentifier: Swift.String?
    let targetOptionGroupIdentifier: Swift.String?
    let targetOptionGroupDescription: Swift.String?
    let tags: [RdsClientTypes.Tag]?
}

extension CopyOptionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceOptionGroupIdentifier = "SourceOptionGroupIdentifier"
        case tags = "Tags"
        case targetOptionGroupDescription = "TargetOptionGroupDescription"
        case targetOptionGroupIdentifier = "TargetOptionGroupIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceOptionGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceOptionGroupIdentifier)
        sourceOptionGroupIdentifier = sourceOptionGroupIdentifierDecoded
        let targetOptionGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetOptionGroupIdentifier)
        targetOptionGroupIdentifier = targetOptionGroupIdentifierDecoded
        let targetOptionGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetOptionGroupDescription)
        targetOptionGroupDescription = targetOptionGroupDescriptionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CopyOptionGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyOptionGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OptionGroupAlreadyExistsFault" : self = .optionGroupAlreadyExistsFault(try OptionGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupQuotaExceededFault" : self = .optionGroupQuotaExceededFault(try OptionGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyOptionGroupOutputError: Swift.Error, Swift.Equatable {
    case optionGroupAlreadyExistsFault(OptionGroupAlreadyExistsFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case optionGroupQuotaExceededFault(OptionGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyOptionGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CopyOptionGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.optionGroup = output.optionGroup
        } else {
            self.optionGroup = nil
        }
    }
}

public struct CopyOptionGroupOutputResponse: Swift.Equatable {
    ///
    public var optionGroup: RdsClientTypes.OptionGroup?

    public init (
        optionGroup: RdsClientTypes.OptionGroup? = nil
    )
    {
        self.optionGroup = optionGroup
    }
}

struct CopyOptionGroupOutputResponseBody: Swift.Equatable {
    let optionGroup: RdsClientTypes.OptionGroup?
}

extension CopyOptionGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optionGroup = "OptionGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CopyOptionGroupResult"))
        let optionGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.OptionGroup.self, forKey: .optionGroup)
        optionGroup = optionGroupDecoded
    }
}

extension CreateCustomAvailabilityZoneInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let customAvailabilityZoneName = customAvailabilityZoneName {
            try container.encode(customAvailabilityZoneName, forKey: ClientRuntime.Key("CustomAvailabilityZoneName"))
        }
        if let existingVpnId = existingVpnId {
            try container.encode(existingVpnId, forKey: ClientRuntime.Key("ExistingVpnId"))
        }
        if let newVpnTunnelName = newVpnTunnelName {
            try container.encode(newVpnTunnelName, forKey: ClientRuntime.Key("NewVpnTunnelName"))
        }
        if let vpnTunnelOriginatorIP = vpnTunnelOriginatorIP {
            try container.encode(vpnTunnelOriginatorIP, forKey: ClientRuntime.Key("VpnTunnelOriginatorIP"))
        }
        try container.encode("CreateCustomAvailabilityZone", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateCustomAvailabilityZoneInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CreateCustomAvailabilityZoneInput: Swift.Equatable {
    /// The name of the custom Availability Zone (AZ).
    /// This member is required.
    public var customAvailabilityZoneName: Swift.String?
    /// The ID of an existing virtual private network (VPN) between the Amazon RDS website and the VMware vSphere cluster.
    public var existingVpnId: Swift.String?
    /// The name of a new VPN tunnel between the Amazon RDS website and the VMware vSphere cluster. Specify this parameter only if ExistingVpnId isn't specified.
    public var newVpnTunnelName: Swift.String?
    /// The IP address of network traffic from your on-premises data center. A custom AZ receives the network traffic. Specify this parameter only if ExistingVpnId isn't specified.
    public var vpnTunnelOriginatorIP: Swift.String?

    public init (
        customAvailabilityZoneName: Swift.String? = nil,
        existingVpnId: Swift.String? = nil,
        newVpnTunnelName: Swift.String? = nil,
        vpnTunnelOriginatorIP: Swift.String? = nil
    )
    {
        self.customAvailabilityZoneName = customAvailabilityZoneName
        self.existingVpnId = existingVpnId
        self.newVpnTunnelName = newVpnTunnelName
        self.vpnTunnelOriginatorIP = vpnTunnelOriginatorIP
    }
}

struct CreateCustomAvailabilityZoneInputBody: Swift.Equatable {
    let customAvailabilityZoneName: Swift.String?
    let existingVpnId: Swift.String?
    let newVpnTunnelName: Swift.String?
    let vpnTunnelOriginatorIP: Swift.String?
}

extension CreateCustomAvailabilityZoneInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customAvailabilityZoneName = "CustomAvailabilityZoneName"
        case existingVpnId = "ExistingVpnId"
        case newVpnTunnelName = "NewVpnTunnelName"
        case vpnTunnelOriginatorIP = "VpnTunnelOriginatorIP"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customAvailabilityZoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customAvailabilityZoneName)
        customAvailabilityZoneName = customAvailabilityZoneNameDecoded
        let existingVpnIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .existingVpnId)
        existingVpnId = existingVpnIdDecoded
        let newVpnTunnelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newVpnTunnelName)
        newVpnTunnelName = newVpnTunnelNameDecoded
        let vpnTunnelOriginatorIPDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpnTunnelOriginatorIP)
        vpnTunnelOriginatorIP = vpnTunnelOriginatorIPDecoded
    }
}

extension CreateCustomAvailabilityZoneOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateCustomAvailabilityZoneOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CustomAvailabilityZoneAlreadyExists" : self = .customAvailabilityZoneAlreadyExistsFault(try CustomAvailabilityZoneAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CustomAvailabilityZoneQuotaExceeded" : self = .customAvailabilityZoneQuotaExceededFault(try CustomAvailabilityZoneQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCustomAvailabilityZoneOutputError: Swift.Error, Swift.Equatable {
    case customAvailabilityZoneAlreadyExistsFault(CustomAvailabilityZoneAlreadyExistsFault)
    case customAvailabilityZoneQuotaExceededFault(CustomAvailabilityZoneQuotaExceededFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomAvailabilityZoneOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCustomAvailabilityZoneOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customAvailabilityZone = output.customAvailabilityZone
        } else {
            self.customAvailabilityZone = nil
        }
    }
}

public struct CreateCustomAvailabilityZoneOutputResponse: Swift.Equatable {
    /// A custom Availability Zone (AZ) is an on-premises AZ that is integrated with a VMware vSphere cluster. For more information about RDS on VMware, see the [ RDS on VMware User Guide.](https://docs.aws.amazon.com/AmazonRDS/latest/RDSonVMwareUserGuide/rds-on-vmware.html)
    public var customAvailabilityZone: RdsClientTypes.CustomAvailabilityZone?

    public init (
        customAvailabilityZone: RdsClientTypes.CustomAvailabilityZone? = nil
    )
    {
        self.customAvailabilityZone = customAvailabilityZone
    }
}

struct CreateCustomAvailabilityZoneOutputResponseBody: Swift.Equatable {
    let customAvailabilityZone: RdsClientTypes.CustomAvailabilityZone?
}

extension CreateCustomAvailabilityZoneOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customAvailabilityZone = "CustomAvailabilityZone"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateCustomAvailabilityZoneResult"))
        let customAvailabilityZoneDecoded = try containerValues.decodeIfPresent(RdsClientTypes.CustomAvailabilityZone.self, forKey: .customAvailabilityZone)
        customAvailabilityZone = customAvailabilityZoneDecoded
    }
}

extension CreateCustomDBEngineVersionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let databaseInstallationFilesS3BucketName = databaseInstallationFilesS3BucketName {
            try container.encode(databaseInstallationFilesS3BucketName, forKey: ClientRuntime.Key("DatabaseInstallationFilesS3BucketName"))
        }
        if let databaseInstallationFilesS3Prefix = databaseInstallationFilesS3Prefix {
            try container.encode(databaseInstallationFilesS3Prefix, forKey: ClientRuntime.Key("DatabaseInstallationFilesS3Prefix"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let kMSKeyId = kMSKeyId {
            try container.encode(kMSKeyId, forKey: ClientRuntime.Key("KMSKeyId"))
        }
        if let manifest = manifest {
            try container.encode(manifest, forKey: ClientRuntime.Key("Manifest"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateCustomDBEngineVersion", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateCustomDBEngineVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateCustomDBEngineVersionInput: Swift.Equatable {
    /// The name of an Amazon S3 bucket that contains database installation files for your CEV. For example, a valid bucket name is my-custom-installation-files.
    /// This member is required.
    public var databaseInstallationFilesS3BucketName: Swift.String?
    /// The Amazon S3 directory that contains the database installation files for your CEV. For example, a valid bucket name is 123456789012/cev1. If this setting isn't specified, no prefix is assumed.
    public var databaseInstallationFilesS3Prefix: Swift.String?
    /// An optional description of your CEV.
    public var description: Swift.String?
    /// The database engine to use for your custom engine version (CEV). The only supported value is custom-oracle-ee.
    /// This member is required.
    public var engine: Swift.String?
    /// The name of your CEV. The name format is 19.customized_string . For example, a valid name is 19.my_cev1. This setting is required for RDS Custom, but optional for Amazon RDS. The combination of Engine and EngineVersion is unique per customer per Region.
    /// This member is required.
    public var engineVersion: Swift.String?
    /// The Amazon Web Services KMS key identifier for an encrypted CEV. A symmetric KMS key is required for RDS Custom, but optional for Amazon RDS. If you have an existing symmetric KMS key in your account, you can use it with RDS Custom. No further action is necessary. If you don't already have a symmetric KMS key in your account, follow the instructions in [ Creating symmetric KMS keys](https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html#create-symmetric-cmk) in the Amazon Web Services Key Management Service Developer Guide. You can choose the same symmetric key when you create a CEV and a DB instance, or choose different keys.
    /// This member is required.
    public var kMSKeyId: Swift.String?
    /// The CEV manifest, which is a JSON document that describes the installation .zip files stored in Amazon S3. Specify the name/value pairs in a file or a quoted string. RDS Custom applies the patches in the order in which they are listed. The following JSON fields are valid: MediaImportTemplateVersion Version of the CEV manifest. The date is in the format YYYY-MM-DD. databaseInstallationFileNames Ordered list of installation files for the CEV. opatchFileNames Ordered list of OPatch installers used for the Oracle DB engine. psuRuPatchFileNames The PSU and RU patches for this CEV. OtherPatchFileNames The patches that are not in the list of PSU and RU patches. Amazon RDS applies these patches after applying the PSU and RU patches. For more information, see [ Creating the CEV manifest](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/custom-cev.html#custom-cev.preparing.manifest) in the Amazon RDS User Guide.
    /// This member is required.
    public var manifest: Swift.String?
    /// A list of tags. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
    public var tags: [RdsClientTypes.Tag]?

    public init (
        databaseInstallationFilesS3BucketName: Swift.String? = nil,
        databaseInstallationFilesS3Prefix: Swift.String? = nil,
        description: Swift.String? = nil,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        kMSKeyId: Swift.String? = nil,
        manifest: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil
    )
    {
        self.databaseInstallationFilesS3BucketName = databaseInstallationFilesS3BucketName
        self.databaseInstallationFilesS3Prefix = databaseInstallationFilesS3Prefix
        self.description = description
        self.engine = engine
        self.engineVersion = engineVersion
        self.kMSKeyId = kMSKeyId
        self.manifest = manifest
        self.tags = tags
    }
}

struct CreateCustomDBEngineVersionInputBody: Swift.Equatable {
    let engine: Swift.String?
    let engineVersion: Swift.String?
    let databaseInstallationFilesS3BucketName: Swift.String?
    let databaseInstallationFilesS3Prefix: Swift.String?
    let kMSKeyId: Swift.String?
    let description: Swift.String?
    let manifest: Swift.String?
    let tags: [RdsClientTypes.Tag]?
}

extension CreateCustomDBEngineVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseInstallationFilesS3BucketName = "DatabaseInstallationFilesS3BucketName"
        case databaseInstallationFilesS3Prefix = "DatabaseInstallationFilesS3Prefix"
        case description = "Description"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case kMSKeyId = "KMSKeyId"
        case manifest = "Manifest"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let databaseInstallationFilesS3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseInstallationFilesS3BucketName)
        databaseInstallationFilesS3BucketName = databaseInstallationFilesS3BucketNameDecoded
        let databaseInstallationFilesS3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseInstallationFilesS3Prefix)
        databaseInstallationFilesS3Prefix = databaseInstallationFilesS3PrefixDecoded
        let kMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyId)
        kMSKeyId = kMSKeyIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let manifestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifest)
        manifest = manifestDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateCustomDBEngineVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateCustomDBEngineVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CustomDBEngineVersionAlreadyExistsFault" : self = .customDBEngineVersionAlreadyExistsFault(try CustomDBEngineVersionAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CustomDBEngineVersionQuotaExceededFault" : self = .customDBEngineVersionQuotaExceededFault(try CustomDBEngineVersionQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCustomDBEngineVersionOutputError: Swift.Error, Swift.Equatable {
    case customDBEngineVersionAlreadyExistsFault(CustomDBEngineVersionAlreadyExistsFault)
    case customDBEngineVersionQuotaExceededFault(CustomDBEngineVersionQuotaExceededFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomDBEngineVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCustomDBEngineVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.dBEngineDescription = output.dBEngineDescription
            self.dBEngineVersionArn = output.dBEngineVersionArn
            self.dBEngineVersionDescription = output.dBEngineVersionDescription
            self.dBParameterGroupFamily = output.dBParameterGroupFamily
            self.databaseInstallationFilesS3BucketName = output.databaseInstallationFilesS3BucketName
            self.databaseInstallationFilesS3Prefix = output.databaseInstallationFilesS3Prefix
            self.defaultCharacterSet = output.defaultCharacterSet
            self.engine = output.engine
            self.engineVersion = output.engineVersion
            self.exportableLogTypes = output.exportableLogTypes
            self.kMSKeyId = output.kMSKeyId
            self.majorEngineVersion = output.majorEngineVersion
            self.status = output.status
            self.supportedCharacterSets = output.supportedCharacterSets
            self.supportedEngineModes = output.supportedEngineModes
            self.supportedFeatureNames = output.supportedFeatureNames
            self.supportedNcharCharacterSets = output.supportedNcharCharacterSets
            self.supportedTimezones = output.supportedTimezones
            self.supportsGlobalDatabases = output.supportsGlobalDatabases
            self.supportsLogExportsToCloudwatchLogs = output.supportsLogExportsToCloudwatchLogs
            self.supportsParallelQuery = output.supportsParallelQuery
            self.supportsReadReplica = output.supportsReadReplica
            self.tagList = output.tagList
            self.validUpgradeTarget = output.validUpgradeTarget
        } else {
            self.createTime = nil
            self.dBEngineDescription = nil
            self.dBEngineVersionArn = nil
            self.dBEngineVersionDescription = nil
            self.dBParameterGroupFamily = nil
            self.databaseInstallationFilesS3BucketName = nil
            self.databaseInstallationFilesS3Prefix = nil
            self.defaultCharacterSet = nil
            self.engine = nil
            self.engineVersion = nil
            self.exportableLogTypes = nil
            self.kMSKeyId = nil
            self.majorEngineVersion = nil
            self.status = nil
            self.supportedCharacterSets = nil
            self.supportedEngineModes = nil
            self.supportedFeatureNames = nil
            self.supportedNcharCharacterSets = nil
            self.supportedTimezones = nil
            self.supportsGlobalDatabases = false
            self.supportsLogExportsToCloudwatchLogs = false
            self.supportsParallelQuery = false
            self.supportsReadReplica = false
            self.tagList = nil
            self.validUpgradeTarget = nil
        }
    }
}

/// This data type is used as a response element in the action DescribeDBEngineVersions.
public struct CreateCustomDBEngineVersionOutputResponse: Swift.Equatable {
    /// The creation time of the DB engine version.
    public var createTime: ClientRuntime.Date?
    /// The description of the database engine.
    public var dBEngineDescription: Swift.String?
    /// The ARN of the custom engine version.
    public var dBEngineVersionArn: Swift.String?
    /// The description of the database engine version.
    public var dBEngineVersionDescription: Swift.String?
    /// The name of the DB parameter group family for the database engine.
    public var dBParameterGroupFamily: Swift.String?
    /// The name of the Amazon S3 bucket that contains your database installation files.
    public var databaseInstallationFilesS3BucketName: Swift.String?
    /// The Amazon S3 directory that contains the database installation files. If not specified, then no prefix is assumed.
    public var databaseInstallationFilesS3Prefix: Swift.String?
    /// The default character set for new instances of this engine version, if the CharacterSetName parameter of the CreateDBInstance API isn't specified.
    public var defaultCharacterSet: RdsClientTypes.CharacterSet?
    /// The name of the database engine.
    public var engine: Swift.String?
    /// The version number of the database engine.
    public var engineVersion: Swift.String?
    /// The types of logs that the database engine has available for export to CloudWatch Logs.
    public var exportableLogTypes: [Swift.String]?
    /// The Amazon Web Services KMS key identifier for an encrypted CEV. This parameter is required for RDS Custom, but optional for Amazon RDS.
    public var kMSKeyId: Swift.String?
    /// The major engine version of the CEV.
    public var majorEngineVersion: Swift.String?
    /// The status of the DB engine version, either available or deprecated.
    public var status: Swift.String?
    /// A list of the character sets supported by this engine for the CharacterSetName parameter of the CreateDBInstance operation.
    public var supportedCharacterSets: [RdsClientTypes.CharacterSet]?
    /// A list of the supported DB engine modes.
    public var supportedEngineModes: [Swift.String]?
    /// A list of features supported by the DB engine. The supported features vary by DB engine and DB engine version. To determine the supported features for a specific DB engine and DB engine version using the CLI, use the following command: aws rds describe-db-engine-versions --engine --engine-version  For example, to determine the supported features for RDS for PostgreSQL version 13.3 using the CLI, use the following command: aws rds describe-db-engine-versions --engine postgres --engine-version 13.3 The supported features are listed under SupportedFeatureNames in the output.
    public var supportedFeatureNames: [Swift.String]?
    /// A list of the character sets supported by the Oracle DB engine for the NcharCharacterSetName parameter of the CreateDBInstance operation.
    public var supportedNcharCharacterSets: [RdsClientTypes.CharacterSet]?
    /// A list of the time zones supported by this engine for the Timezone parameter of the CreateDBInstance action.
    public var supportedTimezones: [RdsClientTypes.Timezone]?
    /// A value that indicates whether you can use Aurora global databases with a specific DB engine version.
    public var supportsGlobalDatabases: Swift.Bool
    /// A value that indicates whether the engine version supports exporting the log types specified by ExportableLogTypes to CloudWatch Logs.
    public var supportsLogExportsToCloudwatchLogs: Swift.Bool
    /// A value that indicates whether you can use Aurora parallel query with a specific DB engine version.
    public var supportsParallelQuery: Swift.Bool
    /// Indicates whether the database engine version supports read replicas.
    public var supportsReadReplica: Swift.Bool
    /// A list of tags. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
    public var tagList: [RdsClientTypes.Tag]?
    /// A list of engine versions that this database engine version can be upgraded to.
    public var validUpgradeTarget: [RdsClientTypes.UpgradeTarget]?

    public init (
        createTime: ClientRuntime.Date? = nil,
        dBEngineDescription: Swift.String? = nil,
        dBEngineVersionArn: Swift.String? = nil,
        dBEngineVersionDescription: Swift.String? = nil,
        dBParameterGroupFamily: Swift.String? = nil,
        databaseInstallationFilesS3BucketName: Swift.String? = nil,
        databaseInstallationFilesS3Prefix: Swift.String? = nil,
        defaultCharacterSet: RdsClientTypes.CharacterSet? = nil,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        exportableLogTypes: [Swift.String]? = nil,
        kMSKeyId: Swift.String? = nil,
        majorEngineVersion: Swift.String? = nil,
        status: Swift.String? = nil,
        supportedCharacterSets: [RdsClientTypes.CharacterSet]? = nil,
        supportedEngineModes: [Swift.String]? = nil,
        supportedFeatureNames: [Swift.String]? = nil,
        supportedNcharCharacterSets: [RdsClientTypes.CharacterSet]? = nil,
        supportedTimezones: [RdsClientTypes.Timezone]? = nil,
        supportsGlobalDatabases: Swift.Bool = false,
        supportsLogExportsToCloudwatchLogs: Swift.Bool = false,
        supportsParallelQuery: Swift.Bool = false,
        supportsReadReplica: Swift.Bool = false,
        tagList: [RdsClientTypes.Tag]? = nil,
        validUpgradeTarget: [RdsClientTypes.UpgradeTarget]? = nil
    )
    {
        self.createTime = createTime
        self.dBEngineDescription = dBEngineDescription
        self.dBEngineVersionArn = dBEngineVersionArn
        self.dBEngineVersionDescription = dBEngineVersionDescription
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.databaseInstallationFilesS3BucketName = databaseInstallationFilesS3BucketName
        self.databaseInstallationFilesS3Prefix = databaseInstallationFilesS3Prefix
        self.defaultCharacterSet = defaultCharacterSet
        self.engine = engine
        self.engineVersion = engineVersion
        self.exportableLogTypes = exportableLogTypes
        self.kMSKeyId = kMSKeyId
        self.majorEngineVersion = majorEngineVersion
        self.status = status
        self.supportedCharacterSets = supportedCharacterSets
        self.supportedEngineModes = supportedEngineModes
        self.supportedFeatureNames = supportedFeatureNames
        self.supportedNcharCharacterSets = supportedNcharCharacterSets
        self.supportedTimezones = supportedTimezones
        self.supportsGlobalDatabases = supportsGlobalDatabases
        self.supportsLogExportsToCloudwatchLogs = supportsLogExportsToCloudwatchLogs
        self.supportsParallelQuery = supportsParallelQuery
        self.supportsReadReplica = supportsReadReplica
        self.tagList = tagList
        self.validUpgradeTarget = validUpgradeTarget
    }
}

struct CreateCustomDBEngineVersionOutputResponseBody: Swift.Equatable {
    let engine: Swift.String?
    let engineVersion: Swift.String?
    let dBParameterGroupFamily: Swift.String?
    let dBEngineDescription: Swift.String?
    let dBEngineVersionDescription: Swift.String?
    let defaultCharacterSet: RdsClientTypes.CharacterSet?
    let supportedCharacterSets: [RdsClientTypes.CharacterSet]?
    let supportedNcharCharacterSets: [RdsClientTypes.CharacterSet]?
    let validUpgradeTarget: [RdsClientTypes.UpgradeTarget]?
    let supportedTimezones: [RdsClientTypes.Timezone]?
    let exportableLogTypes: [Swift.String]?
    let supportsLogExportsToCloudwatchLogs: Swift.Bool
    let supportsReadReplica: Swift.Bool
    let supportedEngineModes: [Swift.String]?
    let supportedFeatureNames: [Swift.String]?
    let status: Swift.String?
    let supportsParallelQuery: Swift.Bool
    let supportsGlobalDatabases: Swift.Bool
    let majorEngineVersion: Swift.String?
    let databaseInstallationFilesS3BucketName: Swift.String?
    let databaseInstallationFilesS3Prefix: Swift.String?
    let dBEngineVersionArn: Swift.String?
    let kMSKeyId: Swift.String?
    let createTime: ClientRuntime.Date?
    let tagList: [RdsClientTypes.Tag]?
}

extension CreateCustomDBEngineVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case dBEngineDescription = "DBEngineDescription"
        case dBEngineVersionArn = "DBEngineVersionArn"
        case dBEngineVersionDescription = "DBEngineVersionDescription"
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case databaseInstallationFilesS3BucketName = "DatabaseInstallationFilesS3BucketName"
        case databaseInstallationFilesS3Prefix = "DatabaseInstallationFilesS3Prefix"
        case defaultCharacterSet = "DefaultCharacterSet"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case exportableLogTypes = "ExportableLogTypes"
        case kMSKeyId = "KMSKeyId"
        case majorEngineVersion = "MajorEngineVersion"
        case status = "Status"
        case supportedCharacterSets = "SupportedCharacterSets"
        case supportedEngineModes = "SupportedEngineModes"
        case supportedFeatureNames = "SupportedFeatureNames"
        case supportedNcharCharacterSets = "SupportedNcharCharacterSets"
        case supportedTimezones = "SupportedTimezones"
        case supportsGlobalDatabases = "SupportsGlobalDatabases"
        case supportsLogExportsToCloudwatchLogs = "SupportsLogExportsToCloudwatchLogs"
        case supportsParallelQuery = "SupportsParallelQuery"
        case supportsReadReplica = "SupportsReadReplica"
        case tagList = "TagList"
        case validUpgradeTarget = "ValidUpgradeTarget"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateCustomDBEngineVersionResult"))
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let dBEngineDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBEngineDescription)
        dBEngineDescription = dBEngineDescriptionDecoded
        let dBEngineVersionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBEngineVersionDescription)
        dBEngineVersionDescription = dBEngineVersionDescriptionDecoded
        let defaultCharacterSetDecoded = try containerValues.decodeIfPresent(RdsClientTypes.CharacterSet.self, forKey: .defaultCharacterSet)
        defaultCharacterSet = defaultCharacterSetDecoded
        if containerValues.contains(.supportedCharacterSets) {
            struct KeyVal0{struct CharacterSet{}}
            let supportedCharacterSetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CharacterSet>.CodingKeys.self, forKey: .supportedCharacterSets)
            if let supportedCharacterSetsWrappedContainer = supportedCharacterSetsWrappedContainer {
                let supportedCharacterSetsContainer = try supportedCharacterSetsWrappedContainer.decodeIfPresent([RdsClientTypes.CharacterSet].self, forKey: .member)
                var supportedCharacterSetsBuffer:[RdsClientTypes.CharacterSet]? = nil
                if let supportedCharacterSetsContainer = supportedCharacterSetsContainer {
                    supportedCharacterSetsBuffer = [RdsClientTypes.CharacterSet]()
                    for structureContainer0 in supportedCharacterSetsContainer {
                        supportedCharacterSetsBuffer?.append(structureContainer0)
                    }
                }
                supportedCharacterSets = supportedCharacterSetsBuffer
            } else {
                supportedCharacterSets = []
            }
        } else {
            supportedCharacterSets = nil
        }
        if containerValues.contains(.supportedNcharCharacterSets) {
            struct KeyVal0{struct CharacterSet{}}
            let supportedNcharCharacterSetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CharacterSet>.CodingKeys.self, forKey: .supportedNcharCharacterSets)
            if let supportedNcharCharacterSetsWrappedContainer = supportedNcharCharacterSetsWrappedContainer {
                let supportedNcharCharacterSetsContainer = try supportedNcharCharacterSetsWrappedContainer.decodeIfPresent([RdsClientTypes.CharacterSet].self, forKey: .member)
                var supportedNcharCharacterSetsBuffer:[RdsClientTypes.CharacterSet]? = nil
                if let supportedNcharCharacterSetsContainer = supportedNcharCharacterSetsContainer {
                    supportedNcharCharacterSetsBuffer = [RdsClientTypes.CharacterSet]()
                    for structureContainer0 in supportedNcharCharacterSetsContainer {
                        supportedNcharCharacterSetsBuffer?.append(structureContainer0)
                    }
                }
                supportedNcharCharacterSets = supportedNcharCharacterSetsBuffer
            } else {
                supportedNcharCharacterSets = []
            }
        } else {
            supportedNcharCharacterSets = nil
        }
        if containerValues.contains(.validUpgradeTarget) {
            struct KeyVal0{struct UpgradeTarget{}}
            let validUpgradeTargetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.UpgradeTarget>.CodingKeys.self, forKey: .validUpgradeTarget)
            if let validUpgradeTargetWrappedContainer = validUpgradeTargetWrappedContainer {
                let validUpgradeTargetContainer = try validUpgradeTargetWrappedContainer.decodeIfPresent([RdsClientTypes.UpgradeTarget].self, forKey: .member)
                var validUpgradeTargetBuffer:[RdsClientTypes.UpgradeTarget]? = nil
                if let validUpgradeTargetContainer = validUpgradeTargetContainer {
                    validUpgradeTargetBuffer = [RdsClientTypes.UpgradeTarget]()
                    for structureContainer0 in validUpgradeTargetContainer {
                        validUpgradeTargetBuffer?.append(structureContainer0)
                    }
                }
                validUpgradeTarget = validUpgradeTargetBuffer
            } else {
                validUpgradeTarget = []
            }
        } else {
            validUpgradeTarget = nil
        }
        if containerValues.contains(.supportedTimezones) {
            struct KeyVal0{struct Timezone{}}
            let supportedTimezonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Timezone>.CodingKeys.self, forKey: .supportedTimezones)
            if let supportedTimezonesWrappedContainer = supportedTimezonesWrappedContainer {
                let supportedTimezonesContainer = try supportedTimezonesWrappedContainer.decodeIfPresent([RdsClientTypes.Timezone].self, forKey: .member)
                var supportedTimezonesBuffer:[RdsClientTypes.Timezone]? = nil
                if let supportedTimezonesContainer = supportedTimezonesContainer {
                    supportedTimezonesBuffer = [RdsClientTypes.Timezone]()
                    for structureContainer0 in supportedTimezonesContainer {
                        supportedTimezonesBuffer?.append(structureContainer0)
                    }
                }
                supportedTimezones = supportedTimezonesBuffer
            } else {
                supportedTimezones = []
            }
        } else {
            supportedTimezones = nil
        }
        if containerValues.contains(.exportableLogTypes) {
            struct KeyVal0{struct member{}}
            let exportableLogTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .exportableLogTypes)
            if let exportableLogTypesWrappedContainer = exportableLogTypesWrappedContainer {
                let exportableLogTypesContainer = try exportableLogTypesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var exportableLogTypesBuffer:[Swift.String]? = nil
                if let exportableLogTypesContainer = exportableLogTypesContainer {
                    exportableLogTypesBuffer = [Swift.String]()
                    for stringContainer0 in exportableLogTypesContainer {
                        exportableLogTypesBuffer?.append(stringContainer0)
                    }
                }
                exportableLogTypes = exportableLogTypesBuffer
            } else {
                exportableLogTypes = []
            }
        } else {
            exportableLogTypes = nil
        }
        let supportsLogExportsToCloudwatchLogsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsLogExportsToCloudwatchLogs)
        supportsLogExportsToCloudwatchLogs = supportsLogExportsToCloudwatchLogsDecoded
        let supportsReadReplicaDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsReadReplica)
        supportsReadReplica = supportsReadReplicaDecoded
        if containerValues.contains(.supportedEngineModes) {
            struct KeyVal0{struct member{}}
            let supportedEngineModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedEngineModes)
            if let supportedEngineModesWrappedContainer = supportedEngineModesWrappedContainer {
                let supportedEngineModesContainer = try supportedEngineModesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedEngineModesBuffer:[Swift.String]? = nil
                if let supportedEngineModesContainer = supportedEngineModesContainer {
                    supportedEngineModesBuffer = [Swift.String]()
                    for stringContainer0 in supportedEngineModesContainer {
                        supportedEngineModesBuffer?.append(stringContainer0)
                    }
                }
                supportedEngineModes = supportedEngineModesBuffer
            } else {
                supportedEngineModes = []
            }
        } else {
            supportedEngineModes = nil
        }
        if containerValues.contains(.supportedFeatureNames) {
            struct KeyVal0{struct member{}}
            let supportedFeatureNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedFeatureNames)
            if let supportedFeatureNamesWrappedContainer = supportedFeatureNamesWrappedContainer {
                let supportedFeatureNamesContainer = try supportedFeatureNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedFeatureNamesBuffer:[Swift.String]? = nil
                if let supportedFeatureNamesContainer = supportedFeatureNamesContainer {
                    supportedFeatureNamesBuffer = [Swift.String]()
                    for stringContainer0 in supportedFeatureNamesContainer {
                        supportedFeatureNamesBuffer?.append(stringContainer0)
                    }
                }
                supportedFeatureNames = supportedFeatureNamesBuffer
            } else {
                supportedFeatureNames = []
            }
        } else {
            supportedFeatureNames = nil
        }
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let supportsParallelQueryDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsParallelQuery)
        supportsParallelQuery = supportsParallelQueryDecoded
        let supportsGlobalDatabasesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsGlobalDatabases)
        supportsGlobalDatabases = supportsGlobalDatabasesDecoded
        let majorEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorEngineVersion)
        majorEngineVersion = majorEngineVersionDecoded
        let databaseInstallationFilesS3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseInstallationFilesS3BucketName)
        databaseInstallationFilesS3BucketName = databaseInstallationFilesS3BucketNameDecoded
        let databaseInstallationFilesS3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseInstallationFilesS3Prefix)
        databaseInstallationFilesS3Prefix = databaseInstallationFilesS3PrefixDecoded
        let dBEngineVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBEngineVersionArn)
        dBEngineVersionArn = dBEngineVersionArnDecoded
        let kMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyId)
        kMSKeyId = kMSKeyIdDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        var createTimeBuffer:ClientRuntime.Date? = nil
        if let createTimeDecoded = createTimeDecoded {
            createTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createTimeDecoded, format: .dateTime)
        }
        createTime = createTimeBuffer
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagListBuffer:[RdsClientTypes.Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
    }
}

extension CreateDBClusterEndpointInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: ClientRuntime.Key("DBClusterEndpointIdentifier"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let endpointType = endpointType {
            try container.encode(endpointType, forKey: ClientRuntime.Key("EndpointType"))
        }
        if let excludedMembers = excludedMembers {
            var excludedMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExcludedMembers"))
            for (index0, string0) in excludedMembers.enumerated() {
                try excludedMembersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let staticMembers = staticMembers {
            var staticMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("StaticMembers"))
            for (index0, string0) in staticMembers.enumerated() {
                try staticMembersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBClusterEndpoint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateDBClusterEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDBClusterEndpointInput: Swift.Equatable {
    /// The identifier to use for the new endpoint. This parameter is stored as a lowercase string.
    /// This member is required.
    public var dBClusterEndpointIdentifier: Swift.String?
    /// The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is stored as a lowercase string.
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// The type of the endpoint, one of: READER, WRITER, ANY.
    /// This member is required.
    public var endpointType: Swift.String?
    /// List of DB instance identifiers that aren't part of the custom endpoint group. All other eligible instances are reachable through the custom endpoint. This parameter is relevant only if the list of static members is empty.
    public var excludedMembers: [Swift.String]?
    /// List of DB instance identifiers that are part of the custom endpoint group.
    public var staticMembers: [Swift.String]?
    /// The tags to be assigned to the Amazon RDS resource.
    public var tags: [RdsClientTypes.Tag]?

    public init (
        dBClusterEndpointIdentifier: Swift.String? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        endpointType: Swift.String? = nil,
        excludedMembers: [Swift.String]? = nil,
        staticMembers: [Swift.String]? = nil,
        tags: [RdsClientTypes.Tag]? = nil
    )
    {
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
        self.tags = tags
    }
}

struct CreateDBClusterEndpointInputBody: Swift.Equatable {
    let dBClusterIdentifier: Swift.String?
    let dBClusterEndpointIdentifier: Swift.String?
    let endpointType: Swift.String?
    let staticMembers: [Swift.String]?
    let excludedMembers: [Swift.String]?
    let tags: [RdsClientTypes.Tag]?
}

extension CreateDBClusterEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case endpointType = "EndpointType"
        case excludedMembers = "ExcludedMembers"
        case staticMembers = "StaticMembers"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        if containerValues.contains(.staticMembers) {
            struct KeyVal0{struct member{}}
            let staticMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .staticMembers)
            if let staticMembersWrappedContainer = staticMembersWrappedContainer {
                let staticMembersContainer = try staticMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var staticMembersBuffer:[Swift.String]? = nil
                if let staticMembersContainer = staticMembersContainer {
                    staticMembersBuffer = [Swift.String]()
                    for stringContainer0 in staticMembersContainer {
                        staticMembersBuffer?.append(stringContainer0)
                    }
                }
                staticMembers = staticMembersBuffer
            } else {
                staticMembers = []
            }
        } else {
            staticMembers = nil
        }
        if containerValues.contains(.excludedMembers) {
            struct KeyVal0{struct member{}}
            let excludedMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .excludedMembers)
            if let excludedMembersWrappedContainer = excludedMembersWrappedContainer {
                let excludedMembersContainer = try excludedMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var excludedMembersBuffer:[Swift.String]? = nil
                if let excludedMembersContainer = excludedMembersContainer {
                    excludedMembersBuffer = [Swift.String]()
                    for stringContainer0 in excludedMembersContainer {
                        excludedMembersBuffer?.append(stringContainer0)
                    }
                }
                excludedMembers = excludedMembersBuffer
            } else {
                excludedMembers = []
            }
        } else {
            excludedMembers = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateDBClusterEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBClusterEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterEndpointAlreadyExistsFault" : self = .dBClusterEndpointAlreadyExistsFault(try DBClusterEndpointAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterEndpointQuotaExceededFault" : self = .dBClusterEndpointQuotaExceededFault(try DBClusterEndpointQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBClusterEndpointOutputError: Swift.Error, Swift.Equatable {
    case dBClusterEndpointAlreadyExistsFault(DBClusterEndpointAlreadyExistsFault)
    case dBClusterEndpointQuotaExceededFault(DBClusterEndpointQuotaExceededFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBClusterEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBClusterEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customEndpointType = output.customEndpointType
            self.dBClusterEndpointArn = output.dBClusterEndpointArn
            self.dBClusterEndpointIdentifier = output.dBClusterEndpointIdentifier
            self.dBClusterEndpointResourceIdentifier = output.dBClusterEndpointResourceIdentifier
            self.dBClusterIdentifier = output.dBClusterIdentifier
            self.endpoint = output.endpoint
            self.endpointType = output.endpointType
            self.excludedMembers = output.excludedMembers
            self.staticMembers = output.staticMembers
            self.status = output.status
        } else {
            self.customEndpointType = nil
            self.dBClusterEndpointArn = nil
            self.dBClusterEndpointIdentifier = nil
            self.dBClusterEndpointResourceIdentifier = nil
            self.dBClusterIdentifier = nil
            self.endpoint = nil
            self.endpointType = nil
            self.excludedMembers = nil
            self.staticMembers = nil
            self.status = nil
        }
    }
}

/// This data type represents the information you need to connect to an Amazon Aurora DB cluster. This data type is used as a response element in the following actions:
///
/// * CreateDBClusterEndpoint
///
/// * DescribeDBClusterEndpoints
///
/// * ModifyDBClusterEndpoint
///
/// * DeleteDBClusterEndpoint
///
///
/// For the data structure that represents Amazon RDS DB instance endpoints, see Endpoint.
public struct CreateDBClusterEndpointOutputResponse: Swift.Equatable {
    /// The type associated with a custom endpoint. One of: READER, WRITER, ANY.
    public var customEndpointType: Swift.String?
    /// The Amazon Resource Name (ARN) for the endpoint.
    public var dBClusterEndpointArn: Swift.String?
    /// The identifier associated with the endpoint. This parameter is stored as a lowercase string.
    public var dBClusterEndpointIdentifier: Swift.String?
    /// A unique system-generated identifier for an endpoint. It remains the same for the whole life of the endpoint.
    public var dBClusterEndpointResourceIdentifier: Swift.String?
    /// The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is stored as a lowercase string.
    public var dBClusterIdentifier: Swift.String?
    /// The DNS address of the endpoint.
    public var endpoint: Swift.String?
    /// The type of the endpoint. One of: READER, WRITER, CUSTOM.
    public var endpointType: Swift.String?
    /// List of DB instance identifiers that aren't part of the custom endpoint group. All other eligible instances are reachable through the custom endpoint. Only relevant if the list of static members is empty.
    public var excludedMembers: [Swift.String]?
    /// List of DB instance identifiers that are part of the custom endpoint group.
    public var staticMembers: [Swift.String]?
    /// The current status of the endpoint. One of: creating, available, deleting, inactive, modifying. The inactive state applies to an endpoint that can't be used for a certain kind of cluster, such as a writer endpoint for a read-only secondary cluster in a global database.
    public var status: Swift.String?

    public init (
        customEndpointType: Swift.String? = nil,
        dBClusterEndpointArn: Swift.String? = nil,
        dBClusterEndpointIdentifier: Swift.String? = nil,
        dBClusterEndpointResourceIdentifier: Swift.String? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        endpoint: Swift.String? = nil,
        endpointType: Swift.String? = nil,
        excludedMembers: [Swift.String]? = nil,
        staticMembers: [Swift.String]? = nil,
        status: Swift.String? = nil
    )
    {
        self.customEndpointType = customEndpointType
        self.dBClusterEndpointArn = dBClusterEndpointArn
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.endpoint = endpoint
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
        self.status = status
    }
}

struct CreateDBClusterEndpointOutputResponseBody: Swift.Equatable {
    let dBClusterEndpointIdentifier: Swift.String?
    let dBClusterIdentifier: Swift.String?
    let dBClusterEndpointResourceIdentifier: Swift.String?
    let endpoint: Swift.String?
    let status: Swift.String?
    let endpointType: Swift.String?
    let customEndpointType: Swift.String?
    let staticMembers: [Swift.String]?
    let excludedMembers: [Swift.String]?
    let dBClusterEndpointArn: Swift.String?
}

extension CreateDBClusterEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customEndpointType = "CustomEndpointType"
        case dBClusterEndpointArn = "DBClusterEndpointArn"
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        case dBClusterEndpointResourceIdentifier = "DBClusterEndpointResourceIdentifier"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case endpoint = "Endpoint"
        case endpointType = "EndpointType"
        case excludedMembers = "ExcludedMembers"
        case staticMembers = "StaticMembers"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBClusterEndpointResult"))
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterEndpointResourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointResourceIdentifier)
        dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifierDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let customEndpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customEndpointType)
        customEndpointType = customEndpointTypeDecoded
        if containerValues.contains(.staticMembers) {
            struct KeyVal0{struct member{}}
            let staticMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .staticMembers)
            if let staticMembersWrappedContainer = staticMembersWrappedContainer {
                let staticMembersContainer = try staticMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var staticMembersBuffer:[Swift.String]? = nil
                if let staticMembersContainer = staticMembersContainer {
                    staticMembersBuffer = [Swift.String]()
                    for stringContainer0 in staticMembersContainer {
                        staticMembersBuffer?.append(stringContainer0)
                    }
                }
                staticMembers = staticMembersBuffer
            } else {
                staticMembers = []
            }
        } else {
            staticMembers = nil
        }
        if containerValues.contains(.excludedMembers) {
            struct KeyVal0{struct member{}}
            let excludedMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .excludedMembers)
            if let excludedMembersWrappedContainer = excludedMembersWrappedContainer {
                let excludedMembersContainer = try excludedMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var excludedMembersBuffer:[Swift.String]? = nil
                if let excludedMembersContainer = excludedMembersContainer {
                    excludedMembersBuffer = [Swift.String]()
                    for stringContainer0 in excludedMembersContainer {
                        excludedMembersBuffer?.append(stringContainer0)
                    }
                }
                excludedMembers = excludedMembersBuffer
            } else {
                excludedMembers = []
            }
        } else {
            excludedMembers = nil
        }
        let dBClusterEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointArn)
        dBClusterEndpointArn = dBClusterEndpointArnDecoded
    }
}

extension CreateDBClusterInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: ClientRuntime.Key("AutoMinorVersionUpgrade"))
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: ClientRuntime.Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let backtrackWindow = backtrackWindow {
            try container.encode(backtrackWindow, forKey: ClientRuntime.Key("BacktrackWindow"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: ClientRuntime.Key("CharacterSetName"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterInstanceClass = dBClusterInstanceClass {
            try container.encode(dBClusterInstanceClass, forKey: ClientRuntime.Key("DBClusterInstanceClass"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: ClientRuntime.Key("DatabaseName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: ClientRuntime.Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableGlobalWriteForwarding = enableGlobalWriteForwarding {
            try container.encode(enableGlobalWriteForwarding, forKey: ClientRuntime.Key("EnableGlobalWriteForwarding"))
        }
        if let enableHttpEndpoint = enableHttpEndpoint {
            try container.encode(enableHttpEndpoint, forKey: ClientRuntime.Key("EnableHttpEndpoint"))
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let enablePerformanceInsights = enablePerformanceInsights {
            try container.encode(enablePerformanceInsights, forKey: ClientRuntime.Key("EnablePerformanceInsights"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineMode = engineMode {
            try container.encode(engineMode, forKey: ClientRuntime.Key("EngineMode"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: ClientRuntime.Key("GlobalClusterIdentifier"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: ClientRuntime.Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: ClientRuntime.Key("MonitoringRoleArn"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: ClientRuntime.Key("PerformanceInsightsKMSKeyId"))
        }
        if let performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod {
            try container.encode(performanceInsightsRetentionPeriod, forKey: ClientRuntime.Key("PerformanceInsightsRetentionPeriod"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let preSignedUrl = preSignedUrl {
            try container.encode(preSignedUrl, forKey: ClientRuntime.Key("PreSignedUrl"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let replicationSourceIdentifier = replicationSourceIdentifier {
            try container.encode(replicationSourceIdentifier, forKey: ClientRuntime.Key("ReplicationSourceIdentifier"))
        }
        if let scalingConfiguration = scalingConfiguration {
            try container.encode(scalingConfiguration, forKey: ClientRuntime.Key("ScalingConfiguration"))
        }
        if let storageEncrypted = storageEncrypted {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateDBClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CreateDBClusterInput: Swift.Equatable {
    /// The amount of storage in gibibytes (GiB) to allocate to each DB instance in the Multi-AZ DB cluster. This setting is required to create a Multi-AZ DB cluster. Valid for: Multi-AZ DB clusters only
    public var allocatedStorage: Swift.Int?
    /// A value that indicates whether minor engine upgrades are applied automatically to the DB cluster during the maintenance window. By default, minor engine upgrades are applied automatically. Valid for: Multi-AZ DB clusters only
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// A list of Availability Zones (AZs) where DB instances in the DB cluster can be created. For information on Amazon Web Services Regions and Availability Zones, see [Choosing the Regions and Availability Zones](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Concepts.RegionsAndAvailabilityZones.html) in the Amazon Aurora User Guide. Valid for: Aurora DB clusters only
    public var availabilityZones: [Swift.String]?
    /// The target backtrack window, in seconds. To disable backtracking, set this value to 0. Default: 0 Constraints:
    ///
    /// * If specified, this value must be set to a number from 0 to 259,200 (72 hours).
    ///
    ///
    /// Valid for: Aurora MySQL DB clusters only
    public var backtrackWindow: Swift.Int?
    /// The number of days for which automated backups are retained. Default: 1 Constraints:
    ///
    /// * Must be a value from 1 to 35
    ///
    ///
    /// Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var backupRetentionPeriod: Swift.Int?
    /// A value that indicates that the DB cluster should be associated with the specified CharacterSet. Valid for: Aurora DB clusters only
    public var characterSetName: Swift.String?
    /// A value that indicates whether to copy all tags from the DB cluster to snapshots of the DB cluster. The default is not to copy them. Valid for: Aurora DB clusters only
    public var copyTagsToSnapshot: Swift.Bool?
    /// The DB cluster identifier. This parameter is stored as a lowercase string. Constraints:
    ///
    /// * Must contain from 1 to 63 letters, numbers, or hyphens.
    ///
    /// * First character must be a letter.
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    /// Example: my-cluster1 Valid for: Aurora DB clusters and Multi-AZ DB clusters
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// The compute and memory capacity of each DB instance in the Multi-AZ DB cluster, for example db.m6g.xlarge. Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines. For the full list of DB instance classes and availability for your engine, see [DB instance class](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html) in the Amazon RDS User Guide. This setting is required to create a Multi-AZ DB cluster. Valid for: Multi-AZ DB clusters only
    public var dBClusterInstanceClass: Swift.String?
    /// The name of the DB cluster parameter group to associate with this DB cluster. If you do not specify a value, then the default DB cluster parameter group for the specified DB engine and version is used. Constraints:
    ///
    /// * If supplied, must match the name of an existing DB cluster parameter group.
    ///
    ///
    /// Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var dBClusterParameterGroupName: Swift.String?
    /// A DB subnet group to associate with this DB cluster. This setting is required to create a Multi-AZ DB cluster. Constraints: Must match the name of an existing DBSubnetGroup. Must not be default. Example: mySubnetgroup Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var dBSubnetGroupName: Swift.String?
    /// The name for your database of up to 64 alphanumeric characters. If you do not provide a name, Amazon RDS doesn't create a database in the DB cluster you are creating. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var databaseName: Swift.String?
    /// A value that indicates whether the DB cluster has deletion protection enabled. The database can't be deleted when deletion protection is enabled. By default, deletion protection isn't enabled. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var deletionProtection: Swift.Bool?
    /// The Active Directory directory ID to create the DB cluster in. For Amazon Aurora DB clusters, Amazon RDS can use Kerberos authentication to authenticate users that connect to the DB cluster. For more information, see [Kerberos authentication](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/kerberos-authentication.html) in the Amazon Aurora User Guide. Valid for: Aurora DB clusters only
    public var domain: Swift.String?
    /// Specify the name of the IAM role to be used when making API calls to the Directory Service. Valid for: Aurora DB clusters only
    public var domainIAMRoleName: Swift.String?
    /// The list of log types that need to be enabled for exporting to CloudWatch Logs. The values in the list depend on the DB engine being used. For more information, see [Publishing Database Logs to Amazon CloudWatch Logs](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch) in the Amazon Aurora User Guide. Aurora MySQL Possible values are audit, error, general, and slowquery. Aurora PostgreSQL Possible value is postgresql. Valid for: Aurora DB clusters only
    public var enableCloudwatchLogsExports: [Swift.String]?
    /// A value that indicates whether to enable this DB cluster to forward write operations to the primary cluster of an Aurora global database ([GlobalCluster]). By default, write operations are not allowed on Aurora DB clusters that are secondary clusters in an Aurora global database. You can set this value only on Aurora DB clusters that are members of an Aurora global database. With this parameter enabled, a secondary cluster can forward writes to the current primary cluster and the resulting changes are replicated back to this cluster. For the primary DB cluster of an Aurora global database, this value is used immediately if the primary is demoted by the [FailoverGlobalCluster] API operation, but it does nothing until then. Valid for: Aurora DB clusters only
    public var enableGlobalWriteForwarding: Swift.Bool?
    /// A value that indicates whether to enable the HTTP endpoint for an Aurora Serverless DB cluster. By default, the HTTP endpoint is disabled. When enabled, the HTTP endpoint provides a connectionless web service API for running SQL queries on the Aurora Serverless DB cluster. You can also query your database from inside the RDS console with the query editor. For more information, see [Using the Data API for Aurora Serverless](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html) in the Amazon Aurora User Guide. Valid for: Aurora DB clusters only
    public var enableHttpEndpoint: Swift.Bool?
    /// A value that indicates whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping isn't enabled. For more information, see [ IAM Database Authentication](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.IAMDBAuth.html) in the Amazon Aurora User Guide. Valid for: Aurora DB clusters only
    public var enableIAMDatabaseAuthentication: Swift.Bool?
    /// A value that indicates whether to turn on Performance Insights for the DB cluster. For more information, see [ Using Amazon Performance Insights](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html) in the Amazon RDS User Guide. Valid for: Multi-AZ DB clusters only
    public var enablePerformanceInsights: Swift.Bool?
    /// The name of the database engine to be used for this DB cluster. Valid Values:
    ///
    /// * aurora (for MySQL 5.6-compatible Aurora)
    ///
    /// * aurora-mysql (for MySQL 5.7-compatible Aurora)
    ///
    /// * aurora-postgresql
    ///
    /// * mysql
    ///
    /// * postgres
    ///
    ///
    /// Valid for: Aurora DB clusters and Multi-AZ DB clusters
    /// This member is required.
    public var engine: Swift.String?
    /// The DB engine mode of the DB cluster, either provisioned, serverless, parallelquery, global, or multimaster. The parallelquery engine mode isn't required for Aurora MySQL version 1.23 and higher 1.x versions, and version 2.09 and higher 2.x versions. The global engine mode isn't required for Aurora MySQL version 1.22 and higher 1.x versions, and global engine mode isn't required for any 2.x versions. The multimaster engine mode only applies for DB clusters created with Aurora MySQL version 5.6.10a. For Aurora PostgreSQL, the global engine mode isn't required, and both the parallelquery and the multimaster engine modes currently aren't supported. Limitations and requirements apply to some DB engine modes. For more information, see the following sections in the Amazon Aurora User Guide:
    ///
    /// * [Limitations of Aurora Serverless](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html#aurora-serverless.limitations)
    ///
    /// * [ Limitations of Parallel Query](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-mysql-parallel-query.html#aurora-mysql-parallel-query-limitations)
    ///
    /// * [ Limitations of Aurora Global Databases](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-global-database.html#aurora-global-database.limitations)
    ///
    /// * [ Limitations of Multi-Master Clusters](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-multi-master.html#aurora-multi-master-limitations)
    ///
    ///
    /// Valid for: Aurora DB clusters only
    public var engineMode: Swift.String?
    /// The version number of the database engine to use. To list all of the available engine versions for MySQL 5.6-compatible Aurora, use the following command: aws rds describe-db-engine-versions --engine aurora --query "DBEngineVersions[].EngineVersion" To list all of the available engine versions for MySQL 5.7-compatible Aurora, use the following command: aws rds describe-db-engine-versions --engine aurora-mysql --query "DBEngineVersions[].EngineVersion" To list all of the available engine versions for Aurora PostgreSQL, use the following command: aws rds describe-db-engine-versions --engine aurora-postgresql --query "DBEngineVersions[].EngineVersion" To list all of the available engine versions for RDS for MySQL, use the following command: aws rds describe-db-engine-versions --engine mysql --query "DBEngineVersions[].EngineVersion" To list all of the available engine versions for RDS for PostgreSQL, use the following command: aws rds describe-db-engine-versions --engine postgres --query "DBEngineVersions[].EngineVersion" Aurora MySQL For information, see [MySQL on Amazon RDS Versions](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Updates.html) in the Amazon Aurora User Guide. Aurora PostgreSQL For information, see [Amazon Aurora PostgreSQL releases and engine versions](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraPostgreSQL.Updates.20180305.html) in the Amazon Aurora User Guide. MySQL For information, see [MySQL on Amazon RDS Versions](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html#MySQL.Concepts.VersionMgmt) in the Amazon RDS User Guide. PostgreSQL For information, see [Amazon RDS for PostgreSQL versions and extensions](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_PostgreSQL.html#PostgreSQL.Concepts) in the Amazon RDS User Guide. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var engineVersion: Swift.String?
    /// The global cluster ID of an Aurora cluster that becomes the primary cluster in the new global database cluster. Valid for: Aurora DB clusters only
    public var globalClusterIdentifier: Swift.String?
    /// The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for each DB instance in the Multi-AZ DB cluster. For information about valid Iops values, see [Amazon RDS Provisioned IOPS storage to improve performance](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#USER_PIOPS) in the Amazon RDS User Guide. This setting is required to create a Multi-AZ DB cluster. Constraints: Must be a multiple between .5 and 50 of the storage amount for the DB cluster. Valid for: Multi-AZ DB clusters only
    public var iops: Swift.Int?
    /// The Amazon Web Services KMS key identifier for an encrypted DB cluster. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN. When a KMS key isn't specified in KmsKeyId:
    ///
    /// * If ReplicationSourceIdentifier identifies an encrypted source, then Amazon RDS will use the KMS key used to encrypt the source. Otherwise, Amazon RDS will use your default KMS key.
    ///
    /// * If the StorageEncrypted parameter is enabled and ReplicationSourceIdentifier isn't specified, then Amazon RDS will use your default KMS key.
    ///
    ///
    /// There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region. If you create a read replica of an encrypted DB cluster in another Amazon Web Services Region, you must set KmsKeyId to a KMS key identifier that is valid in the destination Amazon Web Services Region. This KMS key is used to encrypt the read replica in that Amazon Web Services Region. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var kmsKeyId: Swift.String?
    /// The password for the master database user. This password can contain any printable ASCII character except "/", """, or "@". Constraints: Must contain from 8 to 41 characters. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var masterUserPassword: Swift.String?
    /// The name of the master user for the DB cluster. Constraints:
    ///
    /// * Must be 1 to 16 letters or numbers.
    ///
    /// * First character must be a letter.
    ///
    /// * Can't be a reserved word for the chosen database engine.
    ///
    ///
    /// Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var masterUsername: Swift.String?
    /// The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB cluster. To turn off collecting Enhanced Monitoring metrics, specify 0. The default is 0. If MonitoringRoleArn is specified, also set MonitoringInterval to a value other than 0. Valid Values: 0, 1, 5, 10, 15, 30, 60 Valid for: Multi-AZ DB clusters only
    public var monitoringInterval: Swift.Int?
    /// The Amazon Resource Name (ARN) for the IAM role that permits RDS to send Enhanced Monitoring metrics to Amazon CloudWatch Logs. An example is arn:aws:iam:123456789012:role/emaccess. For information on creating a monitoring role, see [Setting up and enabling Enhanced Monitoring](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.OS.html#USER_Monitoring.OS.Enabling) in the Amazon RDS User Guide. If MonitoringInterval is set to a value other than 0, supply a MonitoringRoleArn value. Valid for: Multi-AZ DB clusters only
    public var monitoringRoleArn: Swift.String?
    /// A value that indicates that the DB cluster should be associated with the specified option group. DB clusters are associated with a default option group that can't be modified.
    public var optionGroupName: Swift.String?
    /// The Amazon Web Services KMS key identifier for encryption of Performance Insights data. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. If you don't specify a value for PerformanceInsightsKMSKeyId, then Amazon RDS uses your default KMS key. There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region. Valid for: Multi-AZ DB clusters only
    public var performanceInsightsKMSKeyId: Swift.String?
    /// The amount of time, in days, to retain Performance Insights data. Valid values are 7 or 731 (2 years). Valid for: Multi-AZ DB clusters only
    public var performanceInsightsRetentionPeriod: Swift.Int?
    /// The port number on which the instances in the DB cluster accept connections. RDS for MySQL and Aurora MySQL Default: 3306 Valid values: 1150-65535 RDS for PostgreSQL and Aurora PostgreSQL Default: 5432 Valid values: 1150-65535 Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var port: Swift.Int?
    /// A URL that contains a Signature Version 4 signed request for the CreateDBCluster action to be called in the source Amazon Web Services Region where the DB cluster is replicated from. Specify PreSignedUrl only when you are performing cross-Region replication from an encrypted DB cluster. The pre-signed URL must be a valid request for the CreateDBCluster API action that can be executed in the source Amazon Web Services Region that contains the encrypted DB cluster to be copied. The pre-signed URL request must contain the following parameter values:
    ///
    /// * KmsKeyId - The Amazon Web Services KMS key identifier for the KMS key to use to encrypt the copy of the DB cluster in the destination Amazon Web Services Region. This should refer to the same KMS key for both the CreateDBCluster action that is called in the destination Amazon Web Services Region, and the action contained in the pre-signed URL.
    ///
    /// * DestinationRegion - The name of the Amazon Web Services Region that Aurora read replica will be created in.
    ///
    /// * ReplicationSourceIdentifier - The DB cluster identifier for the encrypted DB cluster to be copied. This identifier must be in the Amazon Resource Name (ARN) format for the source Amazon Web Services Region. For example, if you are copying an encrypted DB cluster from the us-west-2 Amazon Web Services Region, then your ReplicationSourceIdentifier would look like Example: arn:aws:rds:us-west-2:123456789012:cluster:aurora-cluster1.
    ///
    ///
    /// To learn how to generate a Signature Version 4 signed request, see [ Authenticating Requests: Using Query Parameters (Amazon Web Services Signature Version 4)](https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html) and [ Signature Version 4 Signing Process](https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html). If you are using an Amazon Web Services SDK tool or the CLI, you can specify SourceRegion (or --source-region for the CLI) instead of specifying PreSignedUrl manually. Specifying SourceRegion autogenerates a pre-signed URL that is a valid request for the operation that can be executed in the source Amazon Web Services Region. Valid for: Aurora DB clusters only
    public var preSignedUrl: Swift.String?
    /// The daily time range during which automated backups are created if automated backups are enabled using the BackupRetentionPeriod parameter. The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region. To view the time blocks available, see [ Backup window](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.Backups.BackupWindow) in the Amazon Aurora User Guide. Constraints:
    ///
    /// * Must be in the format hh24:mi-hh24:mi.
    ///
    /// * Must be in Universal Coordinated Time (UTC).
    ///
    /// * Must not conflict with the preferred maintenance window.
    ///
    /// * Must be at least 30 minutes.
    ///
    ///
    /// Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var preferredBackupWindow: Swift.String?
    /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Format: ddd:hh24:mi-ddd:hh24:mi The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region, occurring on a random day of the week. To see the time blocks available, see [ Adjusting the Preferred DB Cluster Maintenance Window](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow.Aurora) in the Amazon Aurora User Guide. Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun. Constraints: Minimum 30-minute window. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var preferredMaintenanceWindow: Swift.String?
    /// A value that indicates whether the DB cluster is publicly accessible. When the DB cluster is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB cluster's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB cluster's VPC. Access to the DB cluster is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB cluster doesn't permit it. When the DB cluster isn't publicly accessible, it is an internal DB cluster with a DNS name that resolves to a private IP address. Default: The default behavior varies depending on whether DBSubnetGroupName is specified. If DBSubnetGroupName isn't specified, and PubliclyAccessible isn't specified, the following applies:
    ///
    /// * If the default VPC in the target Region doesnt have an internet gateway attached to it, the DB cluster is private.
    ///
    /// * If the default VPC in the target Region has an internet gateway attached to it, the DB cluster is public.
    ///
    ///
    /// If DBSubnetGroupName is specified, and PubliclyAccessible isn't specified, the following applies:
    ///
    /// * If the subnets are part of a VPC that doesnt have an internet gateway attached to it, the DB cluster is private.
    ///
    /// * If the subnets are part of a VPC that has an internet gateway attached to it, the DB cluster is public.
    ///
    ///
    /// Valid for: Multi-AZ DB clusters only
    public var publiclyAccessible: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the source DB instance or DB cluster if this DB cluster is created as a read replica. Valid for: Aurora DB clusters only
    public var replicationSourceIdentifier: Swift.String?
    /// For DB clusters in serverless DB engine mode, the scaling properties of the DB cluster. Valid for: Aurora DB clusters only
    public var scalingConfiguration: RdsClientTypes.ScalingConfiguration?
    /// A value that indicates whether the DB cluster is encrypted. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var storageEncrypted: Swift.Bool?
    /// Specifies the storage type to be associated with the DB cluster. This setting is required to create a Multi-AZ DB cluster. Valid values: standard | gp2 | io1 If you specify io1, also include a value for the Iops parameter. Default: io1 if the Iops parameter is specified, otherwise gp2 Valid for: Multi-AZ DB clusters only
    public var storageType: Swift.String?
    /// Tags to assign to the DB cluster. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var tags: [RdsClientTypes.Tag]?
    /// A list of EC2 VPC security groups to associate with this DB cluster. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        allocatedStorage: Swift.Int? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        availabilityZones: [Swift.String]? = nil,
        backtrackWindow: Swift.Int? = nil,
        backupRetentionPeriod: Swift.Int? = nil,
        characterSetName: Swift.String? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        dBClusterInstanceClass: Swift.String? = nil,
        dBClusterParameterGroupName: Swift.String? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        domainIAMRoleName: Swift.String? = nil,
        enableCloudwatchLogsExports: [Swift.String]? = nil,
        enableGlobalWriteForwarding: Swift.Bool? = nil,
        enableHttpEndpoint: Swift.Bool? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        enablePerformanceInsights: Swift.Bool? = nil,
        engine: Swift.String? = nil,
        engineMode: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        globalClusterIdentifier: Swift.String? = nil,
        iops: Swift.Int? = nil,
        kmsKeyId: Swift.String? = nil,
        masterUserPassword: Swift.String? = nil,
        masterUsername: Swift.String? = nil,
        monitoringInterval: Swift.Int? = nil,
        monitoringRoleArn: Swift.String? = nil,
        optionGroupName: Swift.String? = nil,
        performanceInsightsKMSKeyId: Swift.String? = nil,
        performanceInsightsRetentionPeriod: Swift.Int? = nil,
        port: Swift.Int? = nil,
        preSignedUrl: Swift.String? = nil,
        preferredBackupWindow: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        replicationSourceIdentifier: Swift.String? = nil,
        scalingConfiguration: RdsClientTypes.ScalingConfiguration? = nil,
        storageEncrypted: Swift.Bool? = nil,
        storageType: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZones = availabilityZones
        self.backtrackWindow = backtrackWindow
        self.backupRetentionPeriod = backupRetentionPeriod
        self.characterSetName = characterSetName
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterInstanceClass = dBClusterInstanceClass
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.databaseName = databaseName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableGlobalWriteForwarding = enableGlobalWriteForwarding
        self.enableHttpEndpoint = enableHttpEndpoint
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.enablePerformanceInsights = enablePerformanceInsights
        self.engine = engine
        self.engineMode = engineMode
        self.engineVersion = engineVersion
        self.globalClusterIdentifier = globalClusterIdentifier
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.masterUserPassword = masterUserPassword
        self.masterUsername = masterUsername
        self.monitoringInterval = monitoringInterval
        self.monitoringRoleArn = monitoringRoleArn
        self.optionGroupName = optionGroupName
        self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
        self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
        self.port = port
        self.preSignedUrl = preSignedUrl
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.publiclyAccessible = publiclyAccessible
        self.replicationSourceIdentifier = replicationSourceIdentifier
        self.scalingConfiguration = scalingConfiguration
        self.storageEncrypted = storageEncrypted
        self.storageType = storageType
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct CreateDBClusterInputBody: Swift.Equatable {
    let availabilityZones: [Swift.String]?
    let backupRetentionPeriod: Swift.Int?
    let characterSetName: Swift.String?
    let databaseName: Swift.String?
    let dBClusterIdentifier: Swift.String?
    let dBClusterParameterGroupName: Swift.String?
    let vpcSecurityGroupIds: [Swift.String]?
    let dBSubnetGroupName: Swift.String?
    let engine: Swift.String?
    let engineVersion: Swift.String?
    let port: Swift.Int?
    let masterUsername: Swift.String?
    let masterUserPassword: Swift.String?
    let optionGroupName: Swift.String?
    let preferredBackupWindow: Swift.String?
    let preferredMaintenanceWindow: Swift.String?
    let replicationSourceIdentifier: Swift.String?
    let tags: [RdsClientTypes.Tag]?
    let storageEncrypted: Swift.Bool?
    let kmsKeyId: Swift.String?
    let preSignedUrl: Swift.String?
    let enableIAMDatabaseAuthentication: Swift.Bool?
    let backtrackWindow: Swift.Int?
    let enableCloudwatchLogsExports: [Swift.String]?
    let engineMode: Swift.String?
    let scalingConfiguration: RdsClientTypes.ScalingConfiguration?
    let deletionProtection: Swift.Bool?
    let globalClusterIdentifier: Swift.String?
    let enableHttpEndpoint: Swift.Bool?
    let copyTagsToSnapshot: Swift.Bool?
    let domain: Swift.String?
    let domainIAMRoleName: Swift.String?
    let enableGlobalWriteForwarding: Swift.Bool?
    let dBClusterInstanceClass: Swift.String?
    let allocatedStorage: Swift.Int?
    let storageType: Swift.String?
    let iops: Swift.Int?
    let publiclyAccessible: Swift.Bool?
    let autoMinorVersionUpgrade: Swift.Bool?
    let monitoringInterval: Swift.Int?
    let monitoringRoleArn: Swift.String?
    let enablePerformanceInsights: Swift.Bool?
    let performanceInsightsKMSKeyId: Swift.String?
    let performanceInsightsRetentionPeriod: Swift.Int?
}

extension CreateDBClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityZones = "AvailabilityZones"
        case backtrackWindow = "BacktrackWindow"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case characterSetName = "CharacterSetName"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBClusterInstanceClass = "DBClusterInstanceClass"
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case databaseName = "DatabaseName"
        case deletionProtection = "DeletionProtection"
        case domain = "Domain"
        case domainIAMRoleName = "DomainIAMRoleName"
        case enableCloudwatchLogsExports = "EnableCloudwatchLogsExports"
        case enableGlobalWriteForwarding = "EnableGlobalWriteForwarding"
        case enableHttpEndpoint = "EnableHttpEndpoint"
        case enableIAMDatabaseAuthentication = "EnableIAMDatabaseAuthentication"
        case enablePerformanceInsights = "EnablePerformanceInsights"
        case engine = "Engine"
        case engineMode = "EngineMode"
        case engineVersion = "EngineVersion"
        case globalClusterIdentifier = "GlobalClusterIdentifier"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case masterUserPassword = "MasterUserPassword"
        case masterUsername = "MasterUsername"
        case monitoringInterval = "MonitoringInterval"
        case monitoringRoleArn = "MonitoringRoleArn"
        case optionGroupName = "OptionGroupName"
        case performanceInsightsKMSKeyId = "PerformanceInsightsKMSKeyId"
        case performanceInsightsRetentionPeriod = "PerformanceInsightsRetentionPeriod"
        case port = "Port"
        case preSignedUrl = "PreSignedUrl"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case publiclyAccessible = "PubliclyAccessible"
        case replicationSourceIdentifier = "ReplicationSourceIdentifier"
        case scalingConfiguration = "ScalingConfiguration"
        case storageEncrypted = "StorageEncrypted"
        case storageType = "StorageType"
        case tags = "Tags"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var availabilityZonesBuffer:[Swift.String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [Swift.String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let characterSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .characterSetName)
        characterSetName = characterSetNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
        if containerValues.contains(.vpcSecurityGroupIds) {
            struct KeyVal0{struct VpcSecurityGroupId{}}
            let vpcSecurityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupId>.CodingKeys.self, forKey: .vpcSecurityGroupIds)
            if let vpcSecurityGroupIdsWrappedContainer = vpcSecurityGroupIdsWrappedContainer {
                let vpcSecurityGroupIdsContainer = try vpcSecurityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSecurityGroupIdsBuffer:[Swift.String]? = nil
                if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
                    vpcSecurityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSecurityGroupIdsContainer {
                        vpcSecurityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupIds = vpcSecurityGroupIdsBuffer
            } else {
                vpcSecurityGroupIds = []
            }
        } else {
            vpcSecurityGroupIds = nil
        }
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let masterUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUserPassword)
        masterUserPassword = masterUserPasswordDecoded
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let replicationSourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSourceIdentifier)
        replicationSourceIdentifier = replicationSourceIdentifierDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let storageEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let preSignedUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preSignedUrl)
        preSignedUrl = preSignedUrlDecoded
        let enableIAMDatabaseAuthenticationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableIAMDatabaseAuthentication)
        enableIAMDatabaseAuthentication = enableIAMDatabaseAuthenticationDecoded
        let backtrackWindowDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backtrackWindow)
        backtrackWindow = backtrackWindowDecoded
        if containerValues.contains(.enableCloudwatchLogsExports) {
            struct KeyVal0{struct member{}}
            let enableCloudwatchLogsExportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enableCloudwatchLogsExports)
            if let enableCloudwatchLogsExportsWrappedContainer = enableCloudwatchLogsExportsWrappedContainer {
                let enableCloudwatchLogsExportsContainer = try enableCloudwatchLogsExportsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var enableCloudwatchLogsExportsBuffer:[Swift.String]? = nil
                if let enableCloudwatchLogsExportsContainer = enableCloudwatchLogsExportsContainer {
                    enableCloudwatchLogsExportsBuffer = [Swift.String]()
                    for stringContainer0 in enableCloudwatchLogsExportsContainer {
                        enableCloudwatchLogsExportsBuffer?.append(stringContainer0)
                    }
                }
                enableCloudwatchLogsExports = enableCloudwatchLogsExportsBuffer
            } else {
                enableCloudwatchLogsExports = []
            }
        } else {
            enableCloudwatchLogsExports = nil
        }
        let engineModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineMode)
        engineMode = engineModeDecoded
        let scalingConfigurationDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ScalingConfiguration.self, forKey: .scalingConfiguration)
        scalingConfiguration = scalingConfigurationDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let globalClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalClusterIdentifier)
        globalClusterIdentifier = globalClusterIdentifierDecoded
        let enableHttpEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableHttpEndpoint)
        enableHttpEndpoint = enableHttpEndpointDecoded
        let copyTagsToSnapshotDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let domainIAMRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainIAMRoleName)
        domainIAMRoleName = domainIAMRoleNameDecoded
        let enableGlobalWriteForwardingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableGlobalWriteForwarding)
        enableGlobalWriteForwarding = enableGlobalWriteForwardingDecoded
        let dBClusterInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterInstanceClass)
        dBClusterInstanceClass = dBClusterInstanceClassDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let monitoringIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monitoringInterval)
        monitoringInterval = monitoringIntervalDecoded
        let monitoringRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitoringRoleArn)
        monitoringRoleArn = monitoringRoleArnDecoded
        let enablePerformanceInsightsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enablePerformanceInsights)
        enablePerformanceInsights = enablePerformanceInsightsDecoded
        let performanceInsightsKMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .performanceInsightsKMSKeyId)
        performanceInsightsKMSKeyId = performanceInsightsKMSKeyIdDecoded
        let performanceInsightsRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .performanceInsightsRetentionPeriod)
        performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriodDecoded
    }
}

extension CreateDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterAlreadyExistsFault" : self = .dBClusterAlreadyExistsFault(try DBClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterParameterGroupNotFound" : self = .dBClusterParameterGroupNotFoundFault(try DBClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterQuotaExceededFault" : self = .dBClusterQuotaExceededFault(try DBClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlobalClusterNotFoundFault" : self = .globalClusterNotFoundFault(try GlobalClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientStorageClusterCapacity" : self = .insufficientStorageClusterCapacityFault(try InsufficientStorageClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetGroupStateFault" : self = .invalidDBSubnetGroupStateFault(try InvalidDBSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGlobalClusterStateFault" : self = .invalidGlobalClusterStateFault(try InvalidGlobalClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceeded" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterAlreadyExistsFault(DBClusterAlreadyExistsFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterParameterGroupNotFoundFault(DBClusterParameterGroupNotFoundFault)
    case dBClusterQuotaExceededFault(DBClusterQuotaExceededFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case globalClusterNotFoundFault(GlobalClusterNotFoundFault)
    case insufficientStorageClusterCapacityFault(InsufficientStorageClusterCapacityFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidDBSubnetGroupStateFault(InvalidDBSubnetGroupStateFault)
    case invalidGlobalClusterStateFault(InvalidGlobalClusterStateFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct CreateDBClusterOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon Aurora DB cluster or Multi-AZ DB cluster. For an Amazon Aurora DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, PromoteReadReplicaDBCluster, RestoreDBClusterFromS3, RestoreDBClusterFromSnapshot, RestoreDBClusterToPointInTime, StartDBCluster, and StopDBCluster. For a Multi-AZ DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, RebootDBCluster, RestoreDBClusterFromSnapshot, and RestoreDBClusterToPointInTime. For more information on Amazon Aurora DB clusters, see [ What is Amazon Aurora?](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/CHAP_AuroraOverview.html) in the Amazon Aurora User Guide. For more information on Multi-AZ DB clusters, see [ Multi-AZ deployments with two readable standby DB instances](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/multi-az-db-clusters-concepts.html) in the Amazon RDS User Guide. The Multi-AZ DB clusters feature is in preview and is subject to change.
    public var dBCluster: RdsClientTypes.DBCluster?

    public init (
        dBCluster: RdsClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct CreateDBClusterOutputResponseBody: Swift.Equatable {
    let dBCluster: RdsClientTypes.DBCluster?
}

extension CreateDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

extension CreateDBClusterParameterGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBClusterParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateDBClusterParameterGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CreateDBClusterParameterGroupInput: Swift.Equatable {
    /// The name of the DB cluster parameter group. Constraints:
    ///
    /// * Must not match the name of an existing DB cluster parameter group.
    ///
    ///
    /// This value is stored as a lowercase string.
    /// This member is required.
    public var dBClusterParameterGroupName: Swift.String?
    /// The DB cluster parameter group family name. A DB cluster parameter group can be associated with one and only one DB cluster parameter group family, and can be applied only to a DB cluster running a database engine and engine version compatible with that DB cluster parameter group family. Aurora MySQL Example: aurora5.6, aurora-mysql5.7 Aurora PostgreSQL Example: aurora-postgresql9.6 RDS for MySQL Example: mysql8.0 RDS for PostgreSQL Example: postgres12 To list all of the available parameter group families for a DB engine, use the following command: aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily" --engine  For example, to list all of the available parameter group families for the Aurora PostgreSQL DB engine, use the following command: aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily" --engine aurora-postgresql The output contains duplicates. The following are the valid DB engine values:
    ///
    /// * aurora (for MySQL 5.6-compatible Aurora)
    ///
    /// * aurora-mysql (for MySQL 5.7-compatible Aurora)
    ///
    /// * aurora-postgresql
    ///
    /// * mysql
    ///
    /// * postgres
    /// This member is required.
    public var dBParameterGroupFamily: Swift.String?
    /// The description for the DB cluster parameter group.
    /// This member is required.
    public var description: Swift.String?
    /// Tags to assign to the DB cluster parameter group.
    public var tags: [RdsClientTypes.Tag]?

    public init (
        dBClusterParameterGroupName: Swift.String? = nil,
        dBParameterGroupFamily: Swift.String? = nil,
        description: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.description = description
        self.tags = tags
    }
}

struct CreateDBClusterParameterGroupInputBody: Swift.Equatable {
    let dBClusterParameterGroupName: Swift.String?
    let dBParameterGroupFamily: Swift.String?
    let description: Swift.String?
    let tags: [RdsClientTypes.Tag]?
}

extension CreateDBClusterParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case description = "Description"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateDBClusterParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBClusterParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupAlreadyExists" : self = .dBParameterGroupAlreadyExistsFault(try DBParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupQuotaExceeded" : self = .dBParameterGroupQuotaExceededFault(try DBParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBClusterParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupAlreadyExistsFault(DBParameterGroupAlreadyExistsFault)
    case dBParameterGroupQuotaExceededFault(DBParameterGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBClusterParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterParameterGroup = output.dBClusterParameterGroup
        } else {
            self.dBClusterParameterGroup = nil
        }
    }
}

public struct CreateDBClusterParameterGroupOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB cluster parameter group. This data type is used as a response element in the DescribeDBClusterParameterGroups action.
    public var dBClusterParameterGroup: RdsClientTypes.DBClusterParameterGroup?

    public init (
        dBClusterParameterGroup: RdsClientTypes.DBClusterParameterGroup? = nil
    )
    {
        self.dBClusterParameterGroup = dBClusterParameterGroup
    }
}

struct CreateDBClusterParameterGroupOutputResponseBody: Swift.Equatable {
    let dBClusterParameterGroup: RdsClientTypes.DBClusterParameterGroup?
}

extension CreateDBClusterParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroup = "DBClusterParameterGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBClusterParameterGroupResult"))
        let dBClusterParameterGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBClusterParameterGroup.self, forKey: .dBClusterParameterGroup)
        dBClusterParameterGroup = dBClusterParameterGroupDecoded
    }
}

extension CreateDBClusterSnapshotInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("DBClusterSnapshotIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBClusterSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateDBClusterSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CreateDBClusterSnapshotInput: Swift.Equatable {
    /// The identifier of the DB cluster to create a snapshot for. This parameter isn't case-sensitive. Constraints:
    ///
    /// * Must match the identifier of an existing DBCluster.
    ///
    ///
    /// Example: my-cluster1
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// The identifier of the DB cluster snapshot. This parameter is stored as a lowercase string. Constraints:
    ///
    /// * Must contain from 1 to 63 letters, numbers, or hyphens.
    ///
    /// * First character must be a letter.
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    /// Example: my-cluster1-snapshot1
    /// This member is required.
    public var dBClusterSnapshotIdentifier: Swift.String?
    /// The tags to be assigned to the DB cluster snapshot.
    public var tags: [RdsClientTypes.Tag]?

    public init (
        dBClusterIdentifier: Swift.String? = nil,
        dBClusterSnapshotIdentifier: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
        self.tags = tags
    }
}

struct CreateDBClusterSnapshotInputBody: Swift.Equatable {
    let dBClusterSnapshotIdentifier: Swift.String?
    let dBClusterIdentifier: Swift.String?
    let tags: [RdsClientTypes.Tag]?
}

extension CreateDBClusterSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBClusterSnapshotIdentifier = "DBClusterSnapshotIdentifier"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterSnapshotIdentifier)
        dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateDBClusterSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBClusterSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotAlreadyExistsFault" : self = .dBClusterSnapshotAlreadyExistsFault(try DBClusterSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceeded" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBClusterSnapshotOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterSnapshotAlreadyExistsFault(DBClusterSnapshotAlreadyExistsFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBClusterSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterSnapshot = output.dBClusterSnapshot
        } else {
            self.dBClusterSnapshot = nil
        }
    }
}

public struct CreateDBClusterSnapshotOutputResponse: Swift.Equatable {
    /// Contains the details for an Amazon RDS DB cluster snapshot This data type is used as a response element in the DescribeDBClusterSnapshots action.
    public var dBClusterSnapshot: RdsClientTypes.DBClusterSnapshot?

    public init (
        dBClusterSnapshot: RdsClientTypes.DBClusterSnapshot? = nil
    )
    {
        self.dBClusterSnapshot = dBClusterSnapshot
    }
}

struct CreateDBClusterSnapshotOutputResponseBody: Swift.Equatable {
    let dBClusterSnapshot: RdsClientTypes.DBClusterSnapshot?
}

extension CreateDBClusterSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterSnapshot = "DBClusterSnapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBClusterSnapshotResult"))
        let dBClusterSnapshotDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBClusterSnapshot.self, forKey: .dBClusterSnapshot)
        dBClusterSnapshot = dBClusterSnapshotDecoded
    }
}

extension CreateDBInstanceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: ClientRuntime.Key("AutoMinorVersionUpgrade"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let backupTarget = backupTarget {
            try container.encode(backupTarget, forKey: ClientRuntime.Key("BackupTarget"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: ClientRuntime.Key("CharacterSetName"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let customIamInstanceProfile = customIamInstanceProfile {
            try container.encode(customIamInstanceProfile, forKey: ClientRuntime.Key("CustomIamInstanceProfile"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: ClientRuntime.Key("DBName"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let dBSecurityGroups = dBSecurityGroups {
            var dBSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBSecurityGroups"))
            for (index0, string0) in dBSecurityGroups.enumerated() {
                try dBSecurityGroupsContainer.encode(string0, forKey: ClientRuntime.Key("DBSecurityGroupName.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: ClientRuntime.Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableCustomerOwnedIp = enableCustomerOwnedIp {
            try container.encode(enableCustomerOwnedIp, forKey: ClientRuntime.Key("EnableCustomerOwnedIp"))
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let enablePerformanceInsights = enablePerformanceInsights {
            try container.encode(enablePerformanceInsights, forKey: ClientRuntime.Key("EnablePerformanceInsights"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let maxAllocatedStorage = maxAllocatedStorage {
            try container.encode(maxAllocatedStorage, forKey: ClientRuntime.Key("MaxAllocatedStorage"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: ClientRuntime.Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: ClientRuntime.Key("MonitoringRoleArn"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let ncharCharacterSetName = ncharCharacterSetName {
            try container.encode(ncharCharacterSetName, forKey: ClientRuntime.Key("NcharCharacterSetName"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: ClientRuntime.Key("PerformanceInsightsKMSKeyId"))
        }
        if let performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod {
            try container.encode(performanceInsightsRetentionPeriod, forKey: ClientRuntime.Key("PerformanceInsightsRetentionPeriod"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: ClientRuntime.Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let promotionTier = promotionTier {
            try container.encode(promotionTier, forKey: ClientRuntime.Key("PromotionTier"))
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let storageEncrypted = storageEncrypted {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: ClientRuntime.Key("TdeCredentialArn"))
        }
        if let tdeCredentialPassword = tdeCredentialPassword {
            try container.encode(tdeCredentialPassword, forKey: ClientRuntime.Key("TdeCredentialPassword"))
        }
        if let timezone = timezone {
            try container.encode(timezone, forKey: ClientRuntime.Key("Timezone"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBInstance", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateDBInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CreateDBInstanceInput: Swift.Equatable {
    /// The amount of storage in gibibytes (GiB) to allocate for the DB instance. Type: Integer Amazon Aurora Not applicable. Aurora cluster volumes automatically grow as the amount of data in your database increases, though you are only charged for the space that you use in an Aurora cluster volume. Amazon RDS Custom Constraints to the amount of storage for each storage type are the following:
    ///
    /// * General Purpose (SSD) storage (gp2): Must be an integer from 40 to 65536.
    ///
    /// * Provisioned IOPS storage (io1): Must be an integer from 40 to 65536.
    ///
    ///
    /// MySQL Constraints to the amount of storage for each storage type are the following:
    ///
    /// * General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.
    ///
    /// * Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.
    ///
    /// * Magnetic storage (standard): Must be an integer from 5 to 3072.
    ///
    ///
    /// MariaDB Constraints to the amount of storage for each storage type are the following:
    ///
    /// * General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.
    ///
    /// * Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.
    ///
    /// * Magnetic storage (standard): Must be an integer from 5 to 3072.
    ///
    ///
    /// PostgreSQL Constraints to the amount of storage for each storage type are the following:
    ///
    /// * General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.
    ///
    /// * Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.
    ///
    /// * Magnetic storage (standard): Must be an integer from 5 to 3072.
    ///
    ///
    /// Oracle Constraints to the amount of storage for each storage type are the following:
    ///
    /// * General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.
    ///
    /// * Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.
    ///
    /// * Magnetic storage (standard): Must be an integer from 10 to 3072.
    ///
    ///
    /// SQL Server Constraints to the amount of storage for each storage type are the following:
    ///
    /// * General Purpose (SSD) storage (gp2):
    ///
    /// * Enterprise and Standard editions: Must be an integer from 200 to 16384.
    ///
    /// * Web and Express editions: Must be an integer from 20 to 16384.
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * Provisioned IOPS storage (io1):
    ///
    /// * Enterprise and Standard editions: Must be an integer from 200 to 16384.
    ///
    /// * Web and Express editions: Must be an integer from 100 to 16384.
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * Magnetic storage (standard):
    ///
    /// * Enterprise and Standard editions: Must be an integer from 200 to 1024.
    ///
    /// * Web and Express editions: Must be an integer from 20 to 1024.
    public var allocatedStorage: Swift.Int?
    /// A value that indicates whether minor engine upgrades are applied automatically to the DB instance during the maintenance window. By default, minor engine upgrades are applied automatically. If you create an RDS Custom DB instance, you must set AutoMinorVersionUpgrade to false.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The Availability Zone (AZ) where the database will be created. For information on Amazon Web Services Regions and Availability Zones, see [Regions and Availability Zones](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html). Default: A random, system-chosen Availability Zone in the endpoint's Amazon Web Services Region. Example: us-east-1d Constraint: The AvailabilityZone parameter can't be specified if the DB instance is a Multi-AZ deployment. The specified Availability Zone must be in the same Amazon Web Services Region as the current endpoint. If you're creating a DB instance in an RDS on VMware environment, specify the identifier of the custom Availability Zone to create the DB instance in. For more information about RDS on VMware, see the [ RDS on VMware User Guide.](https://docs.aws.amazon.com/AmazonRDS/latest/RDSonVMwareUserGuide/rds-on-vmware.html)
    public var availabilityZone: Swift.String?
    /// The number of days for which automated backups are retained. Setting this parameter to a positive number enables backups. Setting this parameter to 0 disables automated backups. Amazon Aurora Not applicable. The retention period for automated backups is managed by the DB cluster. Default: 1 Constraints:
    ///
    /// * Must be a value from 0 to 35
    ///
    /// * Can't be set to 0 if the DB instance is a source to read replicas
    ///
    /// * Can't be set to 0 or 35 for an RDS Custom DB instance
    public var backupRetentionPeriod: Swift.Int?
    /// Specifies where automated backups and manual snapshots are stored. Possible values are outposts (Amazon Web Services Outposts) and region (Amazon Web Services Region). The default is region. For more information, see [Working with Amazon RDS on Amazon Web Services Outposts](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html) in the Amazon RDS User Guide.
    public var backupTarget: Swift.String?
    /// For supported engines, this value indicates that the DB instance should be associated with the specified CharacterSet. This setting doesn't apply to RDS Custom. However, if you need to change the character set, you can change it on the database itself. Amazon Aurora Not applicable. The character set is managed by the DB cluster. For more information, see CreateDBCluster.
    public var characterSetName: Swift.String?
    /// A value that indicates whether to copy tags from the DB instance to snapshots of the DB instance. By default, tags are not copied. Amazon Aurora Not applicable. Copying tags to snapshots is managed by the DB cluster. Setting this value for an Aurora DB instance has no effect on the DB cluster setting.
    public var copyTagsToSnapshot: Swift.Bool?
    /// The instance profile associated with the underlying Amazon EC2 instance of an RDS Custom DB instance. The instance profile must meet the following requirements:
    ///
    /// * The profile must exist in your account.
    ///
    /// * The profile must have an IAM role that Amazon EC2 has permissions to assume.
    ///
    /// * The instance profile name and the associated IAM role name must start with the prefix AWSRDSCustom.
    ///
    ///
    /// For the list of permissions required for the IAM role, see [ Configure IAM and your VPC](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/custom-setup-orcl.html#custom-setup-orcl.iam-vpc) in the Amazon Relational Database Service User Guide. This setting is required for RDS Custom.
    public var customIamInstanceProfile: Swift.String?
    /// The identifier of the DB cluster that the instance will belong to. This setting doesn't apply to RDS Custom.
    public var dBClusterIdentifier: Swift.String?
    /// The compute and memory capacity of the DB instance, for example db.m4.large. Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines. For the full list of DB instance classes, and availability for your engine, see [DB Instance Class](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html) in the Amazon RDS User Guide.
    /// This member is required.
    public var dBInstanceClass: Swift.String?
    /// The DB instance identifier. This parameter is stored as a lowercase string. Constraints:
    ///
    /// * Must contain from 1 to 63 letters, numbers, or hyphens.
    ///
    /// * First character must be a letter.
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    /// Example: mydbinstance
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// The meaning of this parameter differs according to the database engine you use. MySQL The name of the database to create when the DB instance is created. If this parameter isn't specified, no database is created in the DB instance. Constraints:
    ///
    /// * Must contain 1 to 64 letters or numbers.
    ///
    /// * Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9).
    ///
    /// * Can't be a word reserved by the specified database engine
    ///
    ///
    /// MariaDB The name of the database to create when the DB instance is created. If this parameter isn't specified, no database is created in the DB instance. Constraints:
    ///
    /// * Must contain 1 to 64 letters or numbers.
    ///
    /// * Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9).
    ///
    /// * Can't be a word reserved by the specified database engine
    ///
    ///
    /// PostgreSQL The name of the database to create when the DB instance is created. If this parameter isn't specified, a database named postgres is created in the DB instance. Constraints:
    ///
    /// * Must contain 1 to 63 letters, numbers, or underscores.
    ///
    /// * Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9).
    ///
    /// * Can't be a word reserved by the specified database engine
    ///
    ///
    /// Oracle The Oracle System ID (SID) of the created DB instance. If you specify null, the default value ORCL is used. You can't specify the string NULL, or any other reserved word, for DBName. Default: ORCL Constraints:
    ///
    /// * Can't be longer than 8 characters
    ///
    ///
    /// Amazon RDS Custom The Oracle System ID (SID) of the created RDS Custom DB instance. If you don't specify a value, the default value is ORCL. Default: ORCL Constraints:
    ///
    /// * It must contain 1 to 8 alphanumeric characters.
    ///
    /// * It must contain a letter.
    ///
    /// * It can't be a word reserved by the database engine.
    ///
    ///
    /// SQL Server Not applicable. Must be null. Amazon Aurora MySQL The name of the database to create when the primary DB instance of the Aurora MySQL DB cluster is created. If this parameter isn't specified for an Aurora MySQL DB cluster, no database is created in the DB cluster. Constraints:
    ///
    /// * It must contain 1 to 64 alphanumeric characters.
    ///
    /// * It can't be a word reserved by the database engine.
    ///
    ///
    /// Amazon Aurora PostgreSQL The name of the database to create when the primary DB instance of the Aurora PostgreSQL DB cluster is created. If this parameter isn't specified for an Aurora PostgreSQL DB cluster, a database named postgres is created in the DB cluster. Constraints:
    ///
    /// * It must contain 1 to 63 alphanumeric characters.
    ///
    /// * It must begin with a letter or an underscore. Subsequent characters can be letters, underscores, or digits (0 to 9).
    ///
    /// * It can't be a word reserved by the database engine.
    public var dBName: Swift.String?
    /// The name of the DB parameter group to associate with this DB instance. If you do not specify a value, then the default DB parameter group for the specified DB engine and version is used. This setting doesn't apply to RDS Custom. Constraints:
    ///
    /// * Must be 1 to 255 letters, numbers, or hyphens.
    ///
    /// * First character must be a letter
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens
    public var dBParameterGroupName: Swift.String?
    /// A list of DB security groups to associate with this DB instance. Default: The default DB security group for the database engine.
    public var dBSecurityGroups: [Swift.String]?
    /// A DB subnet group to associate with this DB instance. If there is no DB subnet group, then it is a non-VPC DB instance.
    public var dBSubnetGroupName: Swift.String?
    /// A value that indicates whether the DB instance has deletion protection enabled. The database can't be deleted when deletion protection is enabled. By default, deletion protection isn't enabled. For more information, see [ Deleting a DB Instance](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html). Amazon Aurora Not applicable. You can enable or disable deletion protection for the DB cluster. For more information, see CreateDBCluster. DB instances in a DB cluster can be deleted even when deletion protection is enabled for the DB cluster.
    public var deletionProtection: Swift.Bool?
    /// The Active Directory directory ID to create the DB instance in. Currently, only MySQL, Microsoft SQL Server, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain. For more information, see [ Kerberos Authentication](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html) in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom.
    public var domain: Swift.String?
    /// Specify the name of the IAM role to be used when making API calls to the Directory Service. This setting doesn't apply to RDS Custom.
    public var domainIAMRoleName: Swift.String?
    /// The list of log types that need to be enabled for exporting to CloudWatch Logs. The values in the list depend on the DB engine. For more information, see [Publishing Database Logs to Amazon CloudWatch Logs](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch) in the Amazon Relational Database Service User Guide. Amazon Aurora Not applicable. CloudWatch Logs exports are managed by the DB cluster. RDS Custom Not applicable. MariaDB Possible values are audit, error, general, and slowquery. Microsoft SQL Server Possible values are agent and error. MySQL Possible values are audit, error, general, and slowquery. Oracle Possible values are alert, audit, listener, trace, and oemagent. PostgreSQL Possible values are postgresql and upgrade.
    public var enableCloudwatchLogsExports: [Swift.String]?
    /// A value that indicates whether to enable a customer-owned IP address (CoIP) for an RDS on Outposts DB instance. A CoIP provides local or external connectivity to resources in your Outpost subnets through your on-premises network. For some use cases, a CoIP can provide lower latency for connections to the DB instance from outside of its virtual private cloud (VPC) on your local network. For more information about RDS on Outposts, see [Working with Amazon RDS on Amazon Web Services Outposts](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html) in the Amazon RDS User Guide. For more information about CoIPs, see [Customer-owned IP addresses](https://docs.aws.amazon.com/outposts/latest/userguide/outposts-networking-components.html#ip-addressing) in the Amazon Web Services Outposts User Guide.
    public var enableCustomerOwnedIp: Swift.Bool?
    /// A value that indicates whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping isn't enabled. This setting doesn't apply to RDS Custom or Amazon Aurora. In Aurora, mapping Amazon Web Services IAM accounts to database accounts is managed by the DB cluster. For more information, see [ IAM Database Authentication for MySQL and PostgreSQL](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html) in the Amazon RDS User Guide.
    public var enableIAMDatabaseAuthentication: Swift.Bool?
    /// A value that indicates whether to enable Performance Insights for the DB instance. For more information, see [Using Amazon Performance Insights](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html) in the Amazon Relational Database Service User Guide. This setting doesn't apply to RDS Custom.
    public var enablePerformanceInsights: Swift.Bool?
    /// The name of the database engine to be used for this instance. Not every database engine is available for every Amazon Web Services Region. Valid Values:
    ///
    /// * aurora (for MySQL 5.6-compatible Aurora)
    ///
    /// * aurora-mysql (for MySQL 5.7-compatible Aurora)
    ///
    /// * aurora-postgresql
    ///
    /// * custom-oracle-ee (for RDS Custom instances)
    ///
    /// * mariadb
    ///
    /// * mysql
    ///
    /// * oracle-ee
    ///
    /// * oracle-ee-cdb
    ///
    /// * oracle-se2
    ///
    /// * oracle-se2-cdb
    ///
    /// * postgres
    ///
    /// * sqlserver-ee
    ///
    /// * sqlserver-se
    ///
    /// * sqlserver-ex
    ///
    /// * sqlserver-web
    /// This member is required.
    public var engine: Swift.String?
    /// The version number of the database engine to use. For a list of valid engine versions, use the DescribeDBEngineVersions action. The following are the database engines and links to information about the major and minor versions that are available with Amazon RDS. Not every database engine is available for every Amazon Web Services Region. Amazon Aurora Not applicable. The version number of the database engine to be used by the DB instance is managed by the DB cluster. Amazon RDS Custom A custom engine version (CEV) that you have previously created. This setting is required for RDS Custom. The CEV name has the following format: 19.customized_string . An example identifier is 19.my_cev1. For more information, see [ Creating an RDS Custom DB instance](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/custom-creating.html#custom-creating.create) in the Amazon RDS User Guide.. MariaDB For information, see [MariaDB on Amazon RDS Versions](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MariaDB.html#MariaDB.Concepts.VersionMgmt) in the Amazon RDS User Guide. Microsoft SQL Server For information, see [Microsoft SQL Server Versions on Amazon RDS](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.VersionSupport) in the Amazon RDS User Guide. MySQL For information, see [MySQL on Amazon RDS Versions](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html#MySQL.Concepts.VersionMgmt) in the Amazon RDS User Guide. Oracle For information, see [Oracle Database Engine Release Notes](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Appendix.Oracle.PatchComposition.html) in the Amazon RDS User Guide. PostgreSQL For information, see [Amazon RDS for PostgreSQL versions and extensions](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_PostgreSQL.html#PostgreSQL.Concepts) in the Amazon RDS User Guide.
    public var engineVersion: Swift.String?
    /// The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for the DB instance. For information about valid Iops values, see [Amazon RDS Provisioned IOPS storage to improve performance](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#USER_PIOPS) in the Amazon RDS User Guide. Constraints: For MariaDB, MySQL, Oracle, and PostgreSQL DB instances, must be a multiple between .5 and 50 of the storage amount for the DB instance. For SQL Server DB instances, must be a multiple between 1 and 50 of the storage amount for the DB instance.
    public var iops: Swift.Int?
    /// The Amazon Web Services KMS key identifier for an encrypted DB instance. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN. Amazon Aurora Not applicable. The Amazon Web Services KMS key identifier is managed by the DB cluster. For more information, see CreateDBCluster. If StorageEncrypted is enabled, and you do not specify a value for the KmsKeyId parameter, then Amazon RDS uses your default KMS key. There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region. Amazon RDS Custom A KMS key is required for RDS Custom Oracle instances. For most RDS engines, if you leave this parameter empty while enabling StorageEncrypted, the engine uses the default KMS key. However, RDS Custom for Oracle doesn't use the default key when this parameter is empty. You must explicitly specify a key.
    public var kmsKeyId: Swift.String?
    /// License model information for this DB instance. Valid values: license-included | bring-your-own-license | general-public-license This setting doesn't apply to RDS Custom.
    public var licenseModel: Swift.String?
    /// The password for the master user. The password can include any printable ASCII character except "/", """, or "@". Amazon Aurora Not applicable. The password for the master user is managed by the DB cluster. MariaDB Constraints: Must contain from 8 to 41 characters. Microsoft SQL Server Constraints: Must contain from 8 to 128 characters. MySQL Constraints: Must contain from 8 to 41 characters. Oracle Constraints: Must contain from 8 to 30 characters. PostgreSQL Constraints: Must contain from 8 to 128 characters.
    public var masterUserPassword: Swift.String?
    /// The name for the master user. Amazon Aurora Not applicable. The name for the master user is managed by the DB cluster. Amazon RDS Constraints:
    ///
    /// * Required.
    ///
    /// * Must be 1 to 16 letters, numbers, or underscores.
    ///
    /// * First character must be a letter.
    ///
    /// * Can't be a reserved word for the chosen database engine.
    public var masterUsername: Swift.String?
    /// The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance. For more information about this setting, including limitations that apply to it, see [ Managing capacity automatically with Amazon RDS storage autoscaling](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling) in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom.
    public var maxAllocatedStorage: Swift.Int?
    /// The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance. To disable collection of Enhanced Monitoring metrics, specify 0. The default is 0. If MonitoringRoleArn is specified, then you must set MonitoringInterval to a value other than 0. This setting doesn't apply to RDS Custom. Valid Values: 0, 1, 5, 10, 15, 30, 60
    public var monitoringInterval: Swift.Int?
    /// The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs. For example, arn:aws:iam:123456789012:role/emaccess. For information on creating a monitoring role, see [Setting Up and Enabling Enhanced Monitoring](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.OS.html#USER_Monitoring.OS.Enabling) in the Amazon RDS User Guide. If MonitoringInterval is set to a value other than 0, then you must supply a MonitoringRoleArn value. This setting doesn't apply to RDS Custom.
    public var monitoringRoleArn: Swift.String?
    /// A value that indicates whether the DB instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the DB instance is a Multi-AZ deployment. This setting doesn't apply to RDS Custom.
    public var multiAZ: Swift.Bool?
    /// The name of the NCHAR character set for the Oracle DB instance. This parameter doesn't apply to RDS Custom.
    public var ncharCharacterSetName: Swift.String?
    /// A value that indicates that the DB instance should be associated with the specified option group. Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option group. Also, that option group can't be removed from a DB instance after it is associated with a DB instance. This setting doesn't apply to RDS Custom.
    public var optionGroupName: Swift.String?
    /// The Amazon Web Services KMS key identifier for encryption of Performance Insights data. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. If you do not specify a value for PerformanceInsightsKMSKeyId, then Amazon RDS uses your default KMS key. There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region. This setting doesn't apply to RDS Custom.
    public var performanceInsightsKMSKeyId: Swift.String?
    /// The amount of time, in days, to retain Performance Insights data. Valid values are 7 or 731 (2 years). This setting doesn't apply to RDS Custom.
    public var performanceInsightsRetentionPeriod: Swift.Int?
    /// The port number on which the database accepts connections. MySQL Default: 3306 Valid values: 1150-65535 Type: Integer MariaDB Default: 3306 Valid values: 1150-65535 Type: Integer PostgreSQL Default: 5432 Valid values: 1150-65535 Type: Integer Oracle Default: 1521 Valid values: 1150-65535 SQL Server Default: 1433 Valid values: 1150-65535 except 1234, 1434, 3260, 3343, 3389, 47001, and 49152-49156. Amazon Aurora Default: 3306 Valid values: 1150-65535 Type: Integer
    public var port: Swift.Int?
    /// The daily time range during which automated backups are created if automated backups are enabled, using the BackupRetentionPeriod parameter. The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region. For more information, see [Backup window](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow) in the Amazon RDS User Guide. Amazon Aurora Not applicable. The daily time range for creating automated backups is managed by the DB cluster. Constraints:
    ///
    /// * Must be in the format hh24:mi-hh24:mi.
    ///
    /// * Must be in Universal Coordinated Time (UTC).
    ///
    /// * Must not conflict with the preferred maintenance window.
    ///
    /// * Must be at least 30 minutes.
    public var preferredBackupWindow: Swift.String?
    /// The time range each week during which system maintenance can occur, in Universal Coordinated Time (UTC). For more information, see [Amazon RDS Maintenance Window](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance). Format: ddd:hh24:mi-ddd:hh24:mi The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region, occurring on a random day of the week. Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun. Constraints: Minimum 30-minute window.
    public var preferredMaintenanceWindow: Swift.String?
    /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance. This setting doesn't apply to RDS Custom.
    public var processorFeatures: [RdsClientTypes.ProcessorFeature]?
    /// A value that specifies the order in which an Aurora Replica is promoted to the primary instance after a failure of the existing primary instance. For more information, see [ Fault Tolerance for an Aurora DB Cluster](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.FaultTolerance) in the Amazon Aurora User Guide. This setting doesn't apply to RDS Custom. Default: 1 Valid Values: 0 - 15
    public var promotionTier: Swift.Int?
    /// A value that indicates whether the DB instance is publicly accessible. When the DB instance is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB instance's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB instance's VPC. Access to the DB instance is ultimately controlled by the security group it uses. That public access is not permitted if the security group assigned to the DB instance doesn't permit it. When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address. Default: The default behavior varies depending on whether DBSubnetGroupName is specified. If DBSubnetGroupName isn't specified, and PubliclyAccessible isn't specified, the following applies:
    ///
    /// * If the default VPC in the target Region doesnt have an internet gateway attached to it, the DB instance is private.
    ///
    /// * If the default VPC in the target Region has an internet gateway attached to it, the DB instance is public.
    ///
    ///
    /// If DBSubnetGroupName is specified, and PubliclyAccessible isn't specified, the following applies:
    ///
    /// * If the subnets are part of a VPC that doesnt have an internet gateway attached to it, the DB instance is private.
    ///
    /// * If the subnets are part of a VPC that has an internet gateway attached to it, the DB instance is public.
    public var publiclyAccessible: Swift.Bool?
    /// A value that indicates whether the DB instance is encrypted. By default, it isn't encrypted. For RDS Custom Oracle instances, either set this parameter to true or leave it unset. If you set this parameter to false, RDS reports an error. Amazon Aurora Not applicable. The encryption for DB instances is managed by the DB cluster.
    public var storageEncrypted: Swift.Bool?
    /// Specifies the storage type to be associated with the DB instance. Valid values: standard | gp2 | io1 If you specify io1, you must also include a value for the Iops parameter. Default: io1 if the Iops parameter is specified, otherwise gp2
    public var storageType: Swift.String?
    /// Tags to assign to the DB instance.
    public var tags: [RdsClientTypes.Tag]?
    /// The ARN from the key store with which to associate the instance for TDE encryption. This setting doesn't apply to RDS Custom.
    public var tdeCredentialArn: Swift.String?
    /// The password for the given ARN from the key store in order to access the device. This setting doesn't apply to RDS Custom.
    public var tdeCredentialPassword: Swift.String?
    /// The time zone of the DB instance. The time zone parameter is currently supported only by [Microsoft SQL Server](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.TimeZone).
    public var timezone: Swift.String?
    /// A list of Amazon EC2 VPC security groups to associate with this DB instance. Amazon Aurora Not applicable. The associated list of EC2 VPC security groups is managed by the DB cluster. Default: The default EC2 VPC security group for the DB subnet group's VPC.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        allocatedStorage: Swift.Int? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        availabilityZone: Swift.String? = nil,
        backupRetentionPeriod: Swift.Int? = nil,
        backupTarget: Swift.String? = nil,
        characterSetName: Swift.String? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        customIamInstanceProfile: Swift.String? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        dBInstanceClass: Swift.String? = nil,
        dBInstanceIdentifier: Swift.String? = nil,
        dBName: Swift.String? = nil,
        dBParameterGroupName: Swift.String? = nil,
        dBSecurityGroups: [Swift.String]? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        domainIAMRoleName: Swift.String? = nil,
        enableCloudwatchLogsExports: [Swift.String]? = nil,
        enableCustomerOwnedIp: Swift.Bool? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        enablePerformanceInsights: Swift.Bool? = nil,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        iops: Swift.Int? = nil,
        kmsKeyId: Swift.String? = nil,
        licenseModel: Swift.String? = nil,
        masterUserPassword: Swift.String? = nil,
        masterUsername: Swift.String? = nil,
        maxAllocatedStorage: Swift.Int? = nil,
        monitoringInterval: Swift.Int? = nil,
        monitoringRoleArn: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil,
        ncharCharacterSetName: Swift.String? = nil,
        optionGroupName: Swift.String? = nil,
        performanceInsightsKMSKeyId: Swift.String? = nil,
        performanceInsightsRetentionPeriod: Swift.Int? = nil,
        port: Swift.Int? = nil,
        preferredBackupWindow: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        processorFeatures: [RdsClientTypes.ProcessorFeature]? = nil,
        promotionTier: Swift.Int? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        storageEncrypted: Swift.Bool? = nil,
        storageType: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        tdeCredentialArn: Swift.String? = nil,
        tdeCredentialPassword: Swift.String? = nil,
        timezone: Swift.String? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.backupRetentionPeriod = backupRetentionPeriod
        self.backupTarget = backupTarget
        self.characterSetName = characterSetName
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.customIamInstanceProfile = customIamInstanceProfile
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBName = dBName
        self.dBParameterGroupName = dBParameterGroupName
        self.dBSecurityGroups = dBSecurityGroups
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableCustomerOwnedIp = enableCustomerOwnedIp
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.enablePerformanceInsights = enablePerformanceInsights
        self.engine = engine
        self.engineVersion = engineVersion
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.licenseModel = licenseModel
        self.masterUserPassword = masterUserPassword
        self.masterUsername = masterUsername
        self.maxAllocatedStorage = maxAllocatedStorage
        self.monitoringInterval = monitoringInterval
        self.monitoringRoleArn = monitoringRoleArn
        self.multiAZ = multiAZ
        self.ncharCharacterSetName = ncharCharacterSetName
        self.optionGroupName = optionGroupName
        self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
        self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
        self.port = port
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.processorFeatures = processorFeatures
        self.promotionTier = promotionTier
        self.publiclyAccessible = publiclyAccessible
        self.storageEncrypted = storageEncrypted
        self.storageType = storageType
        self.tags = tags
        self.tdeCredentialArn = tdeCredentialArn
        self.tdeCredentialPassword = tdeCredentialPassword
        self.timezone = timezone
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct CreateDBInstanceInputBody: Swift.Equatable {
    let dBName: Swift.String?
    let dBInstanceIdentifier: Swift.String?
    let allocatedStorage: Swift.Int?
    let dBInstanceClass: Swift.String?
    let engine: Swift.String?
    let masterUsername: Swift.String?
    let masterUserPassword: Swift.String?
    let dBSecurityGroups: [Swift.String]?
    let vpcSecurityGroupIds: [Swift.String]?
    let availabilityZone: Swift.String?
    let dBSubnetGroupName: Swift.String?
    let preferredMaintenanceWindow: Swift.String?
    let dBParameterGroupName: Swift.String?
    let backupRetentionPeriod: Swift.Int?
    let preferredBackupWindow: Swift.String?
    let port: Swift.Int?
    let multiAZ: Swift.Bool?
    let engineVersion: Swift.String?
    let autoMinorVersionUpgrade: Swift.Bool?
    let licenseModel: Swift.String?
    let iops: Swift.Int?
    let optionGroupName: Swift.String?
    let characterSetName: Swift.String?
    let ncharCharacterSetName: Swift.String?
    let publiclyAccessible: Swift.Bool?
    let tags: [RdsClientTypes.Tag]?
    let dBClusterIdentifier: Swift.String?
    let storageType: Swift.String?
    let tdeCredentialArn: Swift.String?
    let tdeCredentialPassword: Swift.String?
    let storageEncrypted: Swift.Bool?
    let kmsKeyId: Swift.String?
    let domain: Swift.String?
    let copyTagsToSnapshot: Swift.Bool?
    let monitoringInterval: Swift.Int?
    let monitoringRoleArn: Swift.String?
    let domainIAMRoleName: Swift.String?
    let promotionTier: Swift.Int?
    let timezone: Swift.String?
    let enableIAMDatabaseAuthentication: Swift.Bool?
    let enablePerformanceInsights: Swift.Bool?
    let performanceInsightsKMSKeyId: Swift.String?
    let performanceInsightsRetentionPeriod: Swift.Int?
    let enableCloudwatchLogsExports: [Swift.String]?
    let processorFeatures: [RdsClientTypes.ProcessorFeature]?
    let deletionProtection: Swift.Bool?
    let maxAllocatedStorage: Swift.Int?
    let enableCustomerOwnedIp: Swift.Bool?
    let customIamInstanceProfile: Swift.String?
    let backupTarget: Swift.String?
}

extension CreateDBInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityZone = "AvailabilityZone"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case backupTarget = "BackupTarget"
        case characterSetName = "CharacterSetName"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case customIamInstanceProfile = "CustomIamInstanceProfile"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBInstanceClass = "DBInstanceClass"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dBName = "DBName"
        case dBParameterGroupName = "DBParameterGroupName"
        case dBSecurityGroups = "DBSecurityGroups"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case deletionProtection = "DeletionProtection"
        case domain = "Domain"
        case domainIAMRoleName = "DomainIAMRoleName"
        case enableCloudwatchLogsExports = "EnableCloudwatchLogsExports"
        case enableCustomerOwnedIp = "EnableCustomerOwnedIp"
        case enableIAMDatabaseAuthentication = "EnableIAMDatabaseAuthentication"
        case enablePerformanceInsights = "EnablePerformanceInsights"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case licenseModel = "LicenseModel"
        case masterUserPassword = "MasterUserPassword"
        case masterUsername = "MasterUsername"
        case maxAllocatedStorage = "MaxAllocatedStorage"
        case monitoringInterval = "MonitoringInterval"
        case monitoringRoleArn = "MonitoringRoleArn"
        case multiAZ = "MultiAZ"
        case ncharCharacterSetName = "NcharCharacterSetName"
        case optionGroupName = "OptionGroupName"
        case performanceInsightsKMSKeyId = "PerformanceInsightsKMSKeyId"
        case performanceInsightsRetentionPeriod = "PerformanceInsightsRetentionPeriod"
        case port = "Port"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case processorFeatures = "ProcessorFeatures"
        case promotionTier = "PromotionTier"
        case publiclyAccessible = "PubliclyAccessible"
        case storageEncrypted = "StorageEncrypted"
        case storageType = "StorageType"
        case tags = "Tags"
        case tdeCredentialArn = "TdeCredentialArn"
        case tdeCredentialPassword = "TdeCredentialPassword"
        case timezone = "Timezone"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBName)
        dBName = dBNameDecoded
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let masterUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUserPassword)
        masterUserPassword = masterUserPasswordDecoded
        if containerValues.contains(.dBSecurityGroups) {
            struct KeyVal0{struct DBSecurityGroupName{}}
            let dBSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSecurityGroupName>.CodingKeys.self, forKey: .dBSecurityGroups)
            if let dBSecurityGroupsWrappedContainer = dBSecurityGroupsWrappedContainer {
                let dBSecurityGroupsContainer = try dBSecurityGroupsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var dBSecurityGroupsBuffer:[Swift.String]? = nil
                if let dBSecurityGroupsContainer = dBSecurityGroupsContainer {
                    dBSecurityGroupsBuffer = [Swift.String]()
                    for stringContainer0 in dBSecurityGroupsContainer {
                        dBSecurityGroupsBuffer?.append(stringContainer0)
                    }
                }
                dBSecurityGroups = dBSecurityGroupsBuffer
            } else {
                dBSecurityGroups = []
            }
        } else {
            dBSecurityGroups = nil
        }
        if containerValues.contains(.vpcSecurityGroupIds) {
            struct KeyVal0{struct VpcSecurityGroupId{}}
            let vpcSecurityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupId>.CodingKeys.self, forKey: .vpcSecurityGroupIds)
            if let vpcSecurityGroupIdsWrappedContainer = vpcSecurityGroupIdsWrappedContainer {
                let vpcSecurityGroupIdsContainer = try vpcSecurityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSecurityGroupIdsBuffer:[Swift.String]? = nil
                if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
                    vpcSecurityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSecurityGroupIdsContainer {
                        vpcSecurityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupIds = vpcSecurityGroupIdsBuffer
            } else {
                vpcSecurityGroupIds = []
            }
        } else {
            vpcSecurityGroupIds = nil
        }
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let characterSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .characterSetName)
        characterSetName = characterSetNameDecoded
        let ncharCharacterSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ncharCharacterSetName)
        ncharCharacterSetName = ncharCharacterSetNameDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let tdeCredentialArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tdeCredentialArn)
        tdeCredentialArn = tdeCredentialArnDecoded
        let tdeCredentialPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tdeCredentialPassword)
        tdeCredentialPassword = tdeCredentialPasswordDecoded
        let storageEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let copyTagsToSnapshotDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let monitoringIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monitoringInterval)
        monitoringInterval = monitoringIntervalDecoded
        let monitoringRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitoringRoleArn)
        monitoringRoleArn = monitoringRoleArnDecoded
        let domainIAMRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainIAMRoleName)
        domainIAMRoleName = domainIAMRoleNameDecoded
        let promotionTierDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .promotionTier)
        promotionTier = promotionTierDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let enableIAMDatabaseAuthenticationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableIAMDatabaseAuthentication)
        enableIAMDatabaseAuthentication = enableIAMDatabaseAuthenticationDecoded
        let enablePerformanceInsightsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enablePerformanceInsights)
        enablePerformanceInsights = enablePerformanceInsightsDecoded
        let performanceInsightsKMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .performanceInsightsKMSKeyId)
        performanceInsightsKMSKeyId = performanceInsightsKMSKeyIdDecoded
        let performanceInsightsRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .performanceInsightsRetentionPeriod)
        performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriodDecoded
        if containerValues.contains(.enableCloudwatchLogsExports) {
            struct KeyVal0{struct member{}}
            let enableCloudwatchLogsExportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enableCloudwatchLogsExports)
            if let enableCloudwatchLogsExportsWrappedContainer = enableCloudwatchLogsExportsWrappedContainer {
                let enableCloudwatchLogsExportsContainer = try enableCloudwatchLogsExportsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var enableCloudwatchLogsExportsBuffer:[Swift.String]? = nil
                if let enableCloudwatchLogsExportsContainer = enableCloudwatchLogsExportsContainer {
                    enableCloudwatchLogsExportsBuffer = [Swift.String]()
                    for stringContainer0 in enableCloudwatchLogsExportsContainer {
                        enableCloudwatchLogsExportsBuffer?.append(stringContainer0)
                    }
                }
                enableCloudwatchLogsExports = enableCloudwatchLogsExportsBuffer
            } else {
                enableCloudwatchLogsExports = []
            }
        } else {
            enableCloudwatchLogsExports = nil
        }
        if containerValues.contains(.processorFeatures) {
            struct KeyVal0{struct ProcessorFeature{}}
            let processorFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ProcessorFeature>.CodingKeys.self, forKey: .processorFeatures)
            if let processorFeaturesWrappedContainer = processorFeaturesWrappedContainer {
                let processorFeaturesContainer = try processorFeaturesWrappedContainer.decodeIfPresent([RdsClientTypes.ProcessorFeature].self, forKey: .member)
                var processorFeaturesBuffer:[RdsClientTypes.ProcessorFeature]? = nil
                if let processorFeaturesContainer = processorFeaturesContainer {
                    processorFeaturesBuffer = [RdsClientTypes.ProcessorFeature]()
                    for structureContainer0 in processorFeaturesContainer {
                        processorFeaturesBuffer?.append(structureContainer0)
                    }
                }
                processorFeatures = processorFeaturesBuffer
            } else {
                processorFeatures = []
            }
        } else {
            processorFeatures = nil
        }
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let maxAllocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAllocatedStorage)
        maxAllocatedStorage = maxAllocatedStorageDecoded
        let enableCustomerOwnedIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableCustomerOwnedIp)
        enableCustomerOwnedIp = enableCustomerOwnedIpDecoded
        let customIamInstanceProfileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customIamInstanceProfile)
        customIamInstanceProfile = customIamInstanceProfileDecoded
        let backupTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupTarget)
        backupTarget = backupTargetDecoded
    }
}

extension CreateDBInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFound" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BackupPolicyNotFoundFault" : self = .backupPolicyNotFoundFault(try BackupPolicyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceAlreadyExists" : self = .dBInstanceAlreadyExistsFault(try DBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFound" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceQuotaExceeded" : self = .instanceQuotaExceededFault(try InstanceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacity" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedIopsNotAvailableInAZFault" : self = .provisionedIopsNotAvailableInAZFault(try ProvisionedIopsNotAvailableInAZFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceeded" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupported" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBInstanceOutputError: Swift.Error, Swift.Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case backupPolicyNotFoundFault(BackupPolicyNotFoundFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceAlreadyExistsFault(DBInstanceAlreadyExistsFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case instanceQuotaExceededFault(InstanceQuotaExceededFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case provisionedIopsNotAvailableInAZFault(ProvisionedIopsNotAvailableInAZFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct CreateDBInstanceOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB instance. This data type is used as a response element in the operations CreateDBInstance, CreateDBInstanceReadReplica, DeleteDBInstance, DescribeDBInstances, ModifyDBInstance, PromoteReadReplica, RebootDBInstance, RestoreDBInstanceFromDBSnapshot, RestoreDBInstanceFromS3, RestoreDBInstanceToPointInTime, StartDBInstance, and StopDBInstance.
    public var dBInstance: RdsClientTypes.DBInstance?

    public init (
        dBInstance: RdsClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct CreateDBInstanceOutputResponseBody: Swift.Equatable {
    let dBInstance: RdsClientTypes.DBInstance?
}

extension CreateDBInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

extension CreateDBInstanceReadReplicaInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: ClientRuntime.Key("AutoMinorVersionUpgrade"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let customIamInstanceProfile = customIamInstanceProfile {
            try container.encode(customIamInstanceProfile, forKey: ClientRuntime.Key("CustomIamInstanceProfile"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: ClientRuntime.Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let enablePerformanceInsights = enablePerformanceInsights {
            try container.encode(enablePerformanceInsights, forKey: ClientRuntime.Key("EnablePerformanceInsights"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let maxAllocatedStorage = maxAllocatedStorage {
            try container.encode(maxAllocatedStorage, forKey: ClientRuntime.Key("MaxAllocatedStorage"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: ClientRuntime.Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: ClientRuntime.Key("MonitoringRoleArn"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: ClientRuntime.Key("PerformanceInsightsKMSKeyId"))
        }
        if let performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod {
            try container.encode(performanceInsightsRetentionPeriod, forKey: ClientRuntime.Key("PerformanceInsightsRetentionPeriod"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let preSignedUrl = preSignedUrl {
            try container.encode(preSignedUrl, forKey: ClientRuntime.Key("PreSignedUrl"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: ClientRuntime.Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let replicaMode = replicaMode {
            try container.encode(replicaMode, forKey: ClientRuntime.Key("ReplicaMode"))
        }
        if let sourceDBInstanceIdentifier = sourceDBInstanceIdentifier {
            try container.encode(sourceDBInstanceIdentifier, forKey: ClientRuntime.Key("SourceDBInstanceIdentifier"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let useDefaultProcessorFeatures = useDefaultProcessorFeatures {
            try container.encode(useDefaultProcessorFeatures, forKey: ClientRuntime.Key("UseDefaultProcessorFeatures"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBInstanceReadReplica", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateDBInstanceReadReplicaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDBInstanceReadReplicaInput: Swift.Equatable {
    /// A value that indicates whether minor engine upgrades are applied automatically to the read replica during the maintenance window. This setting doesn't apply to RDS Custom. Default: Inherits from the source DB instance
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The Availability Zone (AZ) where the read replica will be created. Default: A random, system-chosen Availability Zone in the endpoint's Amazon Web Services Region. Example: us-east-1d
    public var availabilityZone: Swift.String?
    /// A value that indicates whether to copy all tags from the read replica to snapshots of the read replica. By default, tags are not copied.
    public var copyTagsToSnapshot: Swift.Bool?
    /// The instance profile associated with the underlying Amazon EC2 instance of an RDS Custom DB instance. The instance profile must meet the following requirements:
    ///
    /// * The profile must exist in your account.
    ///
    /// * The profile must have an IAM role that Amazon EC2 has permissions to assume.
    ///
    /// * The instance profile name and the associated IAM role name must start with the prefix AWSRDSCustom.
    ///
    ///
    /// For the list of permissions required for the IAM role, see [ Configure IAM and your VPC](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/custom-setup-orcl.html#custom-setup-orcl.iam-vpc) in the Amazon Relational Database Service User Guide. This setting is required for RDS Custom.
    public var customIamInstanceProfile: Swift.String?
    /// The compute and memory capacity of the read replica, for example db.m4.large. Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines. For the full list of DB instance classes, and availability for your engine, see [DB Instance Class](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html) in the Amazon RDS User Guide. Default: Inherits from the source DB instance.
    public var dBInstanceClass: Swift.String?
    /// The DB instance identifier of the read replica. This identifier is the unique key that identifies a DB instance. This parameter is stored as a lowercase string.
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// The name of the DB parameter group to associate with this DB instance. If you do not specify a value for DBParameterGroupName, then Amazon RDS uses the DBParameterGroup of source DB instance for a same Region read replica, or the default DBParameterGroup for the specified DB engine for a cross-Region read replica. Specifying a parameter group for this operation is only supported for Oracle DB instances. It isn't supported for RDS Custom. Constraints:
    ///
    /// * Must be 1 to 255 letters, numbers, or hyphens.
    ///
    /// * First character must be a letter
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens
    public var dBParameterGroupName: Swift.String?
    /// Specifies a DB subnet group for the DB instance. The new DB instance is created in the VPC associated with the DB subnet group. If no DB subnet group is specified, then the new DB instance isn't created in a VPC. Constraints:
    ///
    /// * Can only be specified if the source DB instance identifier specifies a DB instance in another Amazon Web Services Region.
    ///
    /// * If supplied, must match the name of an existing DBSubnetGroup.
    ///
    /// * The specified DB subnet group must be in the same Amazon Web Services Region in which the operation is running.
    ///
    /// * All read replicas in one Amazon Web Services Region that are created from the same source DB instance must either:>
    ///
    /// * Specify DB subnet groups from the same VPC. All these read replicas are created in the same VPC.
    ///
    /// * Not specify a DB subnet group. All these read replicas are created outside of any VPC.
    ///
    ///
    ///
    ///
    ///
    /// Example: mySubnetgroup
    public var dBSubnetGroupName: Swift.String?
    /// A value that indicates whether the DB instance has deletion protection enabled. The database can't be deleted when deletion protection is enabled. By default, deletion protection isn't enabled. For more information, see [ Deleting a DB Instance](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html).
    public var deletionProtection: Swift.Bool?
    /// The Active Directory directory ID to create the DB instance in. Currently, only MySQL, Microsoft SQL Server, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain. For more information, see [ Kerberos Authentication](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html) in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom.
    public var domain: Swift.String?
    /// Specify the name of the IAM role to be used when making API calls to the Directory Service. This setting doesn't apply to RDS Custom.
    public var domainIAMRoleName: Swift.String?
    /// The list of logs that the new DB instance is to export to CloudWatch Logs. The values in the list depend on the DB engine being used. For more information, see [Publishing Database Logs to Amazon CloudWatch Logs ](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch) in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom.
    public var enableCloudwatchLogsExports: [Swift.String]?
    /// A value that indicates whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping isn't enabled. For more information about IAM database authentication, see [ IAM Database Authentication for MySQL and PostgreSQL](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html) in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom.
    public var enableIAMDatabaseAuthentication: Swift.Bool?
    /// A value that indicates whether to enable Performance Insights for the read replica. For more information, see [Using Amazon Performance Insights](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html) in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom.
    public var enablePerformanceInsights: Swift.Bool?
    /// The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for the DB instance.
    public var iops: Swift.Int?
    /// The Amazon Web Services KMS key identifier for an encrypted read replica. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. If you create an encrypted read replica in the same Amazon Web Services Region as the source DB instance, then do not specify a value for this parameter. A read replica in the same Amazon Web Services Region is always encrypted with the same KMS key as the source DB instance. If you create an encrypted read replica in a different Amazon Web Services Region, then you must specify a KMS key identifier for the destination Amazon Web Services Region. KMS keys are specific to the Amazon Web Services Region that they are created in, and you can't use KMS keys from one Amazon Web Services Region in another Amazon Web Services Region. You can't create an encrypted read replica from an unencrypted DB instance. This setting doesn't apply to RDS Custom, which uses the same KMS key as the primary replica.
    public var kmsKeyId: Swift.String?
    /// The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance. For more information about this setting, including limitations that apply to it, see [ Managing capacity automatically with Amazon RDS storage autoscaling](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling) in the Amazon RDS User Guide.
    public var maxAllocatedStorage: Swift.Int?
    /// The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the read replica. To disable collecting Enhanced Monitoring metrics, specify 0. The default is 0. If MonitoringRoleArn is specified, then you must also set MonitoringInterval to a value other than 0. This setting doesn't apply to RDS Custom. Valid Values: 0, 1, 5, 10, 15, 30, 60
    public var monitoringInterval: Swift.Int?
    /// The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs. For example, arn:aws:iam:123456789012:role/emaccess. For information on creating a monitoring role, go to [To create an IAM role for Amazon RDS Enhanced Monitoring](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.html#USER_Monitoring.OS.IAMRole) in the Amazon RDS User Guide. If MonitoringInterval is set to a value other than 0, then you must supply a MonitoringRoleArn value. This setting doesn't apply to RDS Custom.
    public var monitoringRoleArn: Swift.String?
    /// A value that indicates whether the read replica is in a Multi-AZ deployment. You can create a read replica as a Multi-AZ DB instance. RDS creates a standby of your replica in another Availability Zone for failover support for the replica. Creating your read replica as a Multi-AZ DB instance is independent of whether the source database is a Multi-AZ DB instance. This setting doesn't apply to RDS Custom.
    public var multiAZ: Swift.Bool?
    /// The option group the DB instance is associated with. If omitted, the option group associated with the source instance is used. For SQL Server, you must use the option group associated with the source instance. This setting doesn't apply to RDS Custom.
    public var optionGroupName: Swift.String?
    /// The Amazon Web Services KMS key identifier for encryption of Performance Insights data. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. If you do not specify a value for PerformanceInsightsKMSKeyId, then Amazon RDS uses your default KMS key. There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region. This setting doesn't apply to RDS Custom.
    public var performanceInsightsKMSKeyId: Swift.String?
    /// The amount of time, in days, to retain Performance Insights data. Valid values are 7 or 731 (2 years). This setting doesn't apply to RDS Custom.
    public var performanceInsightsRetentionPeriod: Swift.Int?
    /// The port number that the DB instance uses for connections. Default: Inherits from the source DB instance Valid Values: 1150-65535
    public var port: Swift.Int?
    /// The URL that contains a Signature Version 4 signed request for the CreateDBInstanceReadReplica API action in the source Amazon Web Services Region that contains the source DB instance. You must specify this parameter when you create an encrypted read replica from another Amazon Web Services Region by using the Amazon RDS API. Don't specify PreSignedUrl when you are creating an encrypted read replica in the same Amazon Web Services Region. The presigned URL must be a valid request for the CreateDBInstanceReadReplica API action that can be executed in the source Amazon Web Services Region that contains the encrypted source DB instance. The presigned URL request must contain the following parameter values:
    ///
    /// * DestinationRegion - The Amazon Web Services Region that the encrypted read replica is created in. This Amazon Web Services Region is the same one where the CreateDBInstanceReadReplica action is called that contains this presigned URL. For example, if you create an encrypted DB instance in the us-west-1 Amazon Web Services Region, from a source DB instance in the us-east-2 Amazon Web Services Region, then you call the CreateDBInstanceReadReplica action in the us-east-1 Amazon Web Services Region and provide a presigned URL that contains a call to the CreateDBInstanceReadReplica action in the us-west-2 Amazon Web Services Region. For this example, the DestinationRegion in the presigned URL must be set to the us-east-1 Amazon Web Services Region.
    ///
    /// * KmsKeyId - The Amazon Web Services KMS key identifier for the key to use to encrypt the read replica in the destination Amazon Web Services Region. This is the same identifier for both the CreateDBInstanceReadReplica action that is called in the destination Amazon Web Services Region, and the action contained in the presigned URL.
    ///
    /// * SourceDBInstanceIdentifier - The DB instance identifier for the encrypted DB instance to be replicated. This identifier must be in the Amazon Resource Name (ARN) format for the source Amazon Web Services Region. For example, if you are creating an encrypted read replica from a DB instance in the us-west-2 Amazon Web Services Region, then your SourceDBInstanceIdentifier looks like the following example: arn:aws:rds:us-west-2:123456789012:instance:mysql-instance1-20161115.
    ///
    ///
    /// To learn how to generate a Signature Version 4 signed request, see [Authenticating Requests: Using Query Parameters (Amazon Web Services Signature Version 4)](https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html) and [Signature Version 4 Signing Process](https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html). If you are using an Amazon Web Services SDK tool or the CLI, you can specify SourceRegion (or --source-region for the CLI) instead of specifying PreSignedUrl manually. Specifying SourceRegion autogenerates a presigned URL that is a valid request for the operation that can be executed in the source Amazon Web Services Region. SourceRegion isn't supported for SQL Server, because SQL Server on Amazon RDS doesn't support cross-Region read replicas. This setting doesn't apply to RDS Custom.
    public var preSignedUrl: Swift.String?
    /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance. This setting doesn't apply to RDS Custom.
    public var processorFeatures: [RdsClientTypes.ProcessorFeature]?
    /// A value that indicates whether the DB instance is publicly accessible. When the DB cluster is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB cluster's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB cluster's VPC. Access to the DB cluster is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB cluster doesn't permit it. When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address. For more information, see [CreateDBInstance].
    public var publiclyAccessible: Swift.Bool?
    /// The open mode of the replica database: mounted or read-only. This parameter is only supported for Oracle DB instances. Mounted DB replicas are included in Oracle Database Enterprise Edition. The main use case for mounted replicas is cross-Region disaster recovery. The primary database doesn't use Active Data Guard to transmit information to the mounted replica. Because it doesn't accept user connections, a mounted replica can't serve a read-only workload. You can create a combination of mounted and read-only DB replicas for the same primary DB instance. For more information, see [Working with Oracle Read Replicas for Amazon RDS](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-read-replicas.html) in the Amazon RDS User Guide. For RDS Custom, you must specify this parameter and set it to mounted. The value won't be set by default. After replica creation, you can manage the open mode manually.
    public var replicaMode: RdsClientTypes.ReplicaMode?
    /// The identifier of the DB instance that will act as the source for the read replica. Each DB instance can have up to five read replicas. Constraints:
    ///
    /// * Must be the identifier of an existing MySQL, MariaDB, Oracle, PostgreSQL, or SQL Server DB instance.
    ///
    /// * Can specify a DB instance that is a MySQL read replica only if the source is running MySQL 5.6 or later.
    ///
    /// * For the limitations of Oracle read replicas, see [Read Replica Limitations with Oracle](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-read-replicas.html) in the Amazon RDS User Guide.
    ///
    /// * For the limitations of SQL Server read replicas, see [Read Replica Limitations with Microsoft SQL Server](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/SQLServer.ReadReplicas.Limitations.html) in the Amazon RDS User Guide.
    ///
    /// * Can specify a PostgreSQL DB instance only if the source is running PostgreSQL 9.3.5 or later (9.4.7 and higher for cross-Region replication).
    ///
    /// * The specified DB instance must have automatic backups enabled, that is, its backup retention period must be greater than 0.
    ///
    /// * If the source DB instance is in the same Amazon Web Services Region as the read replica, specify a valid DB instance identifier.
    ///
    /// * If the source DB instance is in a different Amazon Web Services Region from the read replica, specify a valid DB instance ARN. For more information, see [Constructing an ARN for Amazon RDS](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing) in the Amazon RDS User Guide. This doesn't apply to SQL Server or RDS Custom, which don't support cross-Region replicas.
    /// This member is required.
    public var sourceDBInstanceIdentifier: Swift.String?
    /// Specifies the storage type to be associated with the read replica. Valid values: standard | gp2 | io1 If you specify io1, you must also include a value for the Iops parameter. Default: io1 if the Iops parameter is specified, otherwise gp2
    public var storageType: Swift.String?
    /// A list of tags. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
    public var tags: [RdsClientTypes.Tag]?
    /// A value that indicates whether the DB instance class of the DB instance uses its default processor features. This setting doesn't apply to RDS Custom.
    public var useDefaultProcessorFeatures: Swift.Bool?
    /// A list of Amazon EC2 VPC security groups to associate with the read replica. This setting doesn't apply to RDS Custom. Default: The default EC2 VPC security group for the DB subnet group's VPC.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        availabilityZone: Swift.String? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        customIamInstanceProfile: Swift.String? = nil,
        dBInstanceClass: Swift.String? = nil,
        dBInstanceIdentifier: Swift.String? = nil,
        dBParameterGroupName: Swift.String? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        domainIAMRoleName: Swift.String? = nil,
        enableCloudwatchLogsExports: [Swift.String]? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        enablePerformanceInsights: Swift.Bool? = nil,
        iops: Swift.Int? = nil,
        kmsKeyId: Swift.String? = nil,
        maxAllocatedStorage: Swift.Int? = nil,
        monitoringInterval: Swift.Int? = nil,
        monitoringRoleArn: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil,
        optionGroupName: Swift.String? = nil,
        performanceInsightsKMSKeyId: Swift.String? = nil,
        performanceInsightsRetentionPeriod: Swift.Int? = nil,
        port: Swift.Int? = nil,
        preSignedUrl: Swift.String? = nil,
        processorFeatures: [RdsClientTypes.ProcessorFeature]? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        replicaMode: RdsClientTypes.ReplicaMode? = nil,
        sourceDBInstanceIdentifier: Swift.String? = nil,
        storageType: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        useDefaultProcessorFeatures: Swift.Bool? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.customIamInstanceProfile = customIamInstanceProfile
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBParameterGroupName = dBParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.enablePerformanceInsights = enablePerformanceInsights
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.maxAllocatedStorage = maxAllocatedStorage
        self.monitoringInterval = monitoringInterval
        self.monitoringRoleArn = monitoringRoleArn
        self.multiAZ = multiAZ
        self.optionGroupName = optionGroupName
        self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
        self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
        self.port = port
        self.preSignedUrl = preSignedUrl
        self.processorFeatures = processorFeatures
        self.publiclyAccessible = publiclyAccessible
        self.replicaMode = replicaMode
        self.sourceDBInstanceIdentifier = sourceDBInstanceIdentifier
        self.storageType = storageType
        self.tags = tags
        self.useDefaultProcessorFeatures = useDefaultProcessorFeatures
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct CreateDBInstanceReadReplicaInputBody: Swift.Equatable {
    let dBInstanceIdentifier: Swift.String?
    let sourceDBInstanceIdentifier: Swift.String?
    let dBInstanceClass: Swift.String?
    let availabilityZone: Swift.String?
    let port: Swift.Int?
    let multiAZ: Swift.Bool?
    let autoMinorVersionUpgrade: Swift.Bool?
    let iops: Swift.Int?
    let optionGroupName: Swift.String?
    let dBParameterGroupName: Swift.String?
    let publiclyAccessible: Swift.Bool?
    let tags: [RdsClientTypes.Tag]?
    let dBSubnetGroupName: Swift.String?
    let vpcSecurityGroupIds: [Swift.String]?
    let storageType: Swift.String?
    let copyTagsToSnapshot: Swift.Bool?
    let monitoringInterval: Swift.Int?
    let monitoringRoleArn: Swift.String?
    let kmsKeyId: Swift.String?
    let preSignedUrl: Swift.String?
    let enableIAMDatabaseAuthentication: Swift.Bool?
    let enablePerformanceInsights: Swift.Bool?
    let performanceInsightsKMSKeyId: Swift.String?
    let performanceInsightsRetentionPeriod: Swift.Int?
    let enableCloudwatchLogsExports: [Swift.String]?
    let processorFeatures: [RdsClientTypes.ProcessorFeature]?
    let useDefaultProcessorFeatures: Swift.Bool?
    let deletionProtection: Swift.Bool?
    let domain: Swift.String?
    let domainIAMRoleName: Swift.String?
    let replicaMode: RdsClientTypes.ReplicaMode?
    let maxAllocatedStorage: Swift.Int?
    let customIamInstanceProfile: Swift.String?
}

extension CreateDBInstanceReadReplicaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityZone = "AvailabilityZone"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case customIamInstanceProfile = "CustomIamInstanceProfile"
        case dBInstanceClass = "DBInstanceClass"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dBParameterGroupName = "DBParameterGroupName"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case deletionProtection = "DeletionProtection"
        case domain = "Domain"
        case domainIAMRoleName = "DomainIAMRoleName"
        case enableCloudwatchLogsExports = "EnableCloudwatchLogsExports"
        case enableIAMDatabaseAuthentication = "EnableIAMDatabaseAuthentication"
        case enablePerformanceInsights = "EnablePerformanceInsights"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case maxAllocatedStorage = "MaxAllocatedStorage"
        case monitoringInterval = "MonitoringInterval"
        case monitoringRoleArn = "MonitoringRoleArn"
        case multiAZ = "MultiAZ"
        case optionGroupName = "OptionGroupName"
        case performanceInsightsKMSKeyId = "PerformanceInsightsKMSKeyId"
        case performanceInsightsRetentionPeriod = "PerformanceInsightsRetentionPeriod"
        case port = "Port"
        case preSignedUrl = "PreSignedUrl"
        case processorFeatures = "ProcessorFeatures"
        case publiclyAccessible = "PubliclyAccessible"
        case replicaMode = "ReplicaMode"
        case sourceDBInstanceIdentifier = "SourceDBInstanceIdentifier"
        case storageType = "StorageType"
        case tags = "Tags"
        case useDefaultProcessorFeatures = "UseDefaultProcessorFeatures"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let sourceDBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDBInstanceIdentifier)
        sourceDBInstanceIdentifier = sourceDBInstanceIdentifierDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        if containerValues.contains(.vpcSecurityGroupIds) {
            struct KeyVal0{struct VpcSecurityGroupId{}}
            let vpcSecurityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupId>.CodingKeys.self, forKey: .vpcSecurityGroupIds)
            if let vpcSecurityGroupIdsWrappedContainer = vpcSecurityGroupIdsWrappedContainer {
                let vpcSecurityGroupIdsContainer = try vpcSecurityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSecurityGroupIdsBuffer:[Swift.String]? = nil
                if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
                    vpcSecurityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSecurityGroupIdsContainer {
                        vpcSecurityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupIds = vpcSecurityGroupIdsBuffer
            } else {
                vpcSecurityGroupIds = []
            }
        } else {
            vpcSecurityGroupIds = nil
        }
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let copyTagsToSnapshotDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let monitoringIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monitoringInterval)
        monitoringInterval = monitoringIntervalDecoded
        let monitoringRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitoringRoleArn)
        monitoringRoleArn = monitoringRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let preSignedUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preSignedUrl)
        preSignedUrl = preSignedUrlDecoded
        let enableIAMDatabaseAuthenticationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableIAMDatabaseAuthentication)
        enableIAMDatabaseAuthentication = enableIAMDatabaseAuthenticationDecoded
        let enablePerformanceInsightsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enablePerformanceInsights)
        enablePerformanceInsights = enablePerformanceInsightsDecoded
        let performanceInsightsKMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .performanceInsightsKMSKeyId)
        performanceInsightsKMSKeyId = performanceInsightsKMSKeyIdDecoded
        let performanceInsightsRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .performanceInsightsRetentionPeriod)
        performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriodDecoded
        if containerValues.contains(.enableCloudwatchLogsExports) {
            struct KeyVal0{struct member{}}
            let enableCloudwatchLogsExportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enableCloudwatchLogsExports)
            if let enableCloudwatchLogsExportsWrappedContainer = enableCloudwatchLogsExportsWrappedContainer {
                let enableCloudwatchLogsExportsContainer = try enableCloudwatchLogsExportsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var enableCloudwatchLogsExportsBuffer:[Swift.String]? = nil
                if let enableCloudwatchLogsExportsContainer = enableCloudwatchLogsExportsContainer {
                    enableCloudwatchLogsExportsBuffer = [Swift.String]()
                    for stringContainer0 in enableCloudwatchLogsExportsContainer {
                        enableCloudwatchLogsExportsBuffer?.append(stringContainer0)
                    }
                }
                enableCloudwatchLogsExports = enableCloudwatchLogsExportsBuffer
            } else {
                enableCloudwatchLogsExports = []
            }
        } else {
            enableCloudwatchLogsExports = nil
        }
        if containerValues.contains(.processorFeatures) {
            struct KeyVal0{struct ProcessorFeature{}}
            let processorFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ProcessorFeature>.CodingKeys.self, forKey: .processorFeatures)
            if let processorFeaturesWrappedContainer = processorFeaturesWrappedContainer {
                let processorFeaturesContainer = try processorFeaturesWrappedContainer.decodeIfPresent([RdsClientTypes.ProcessorFeature].self, forKey: .member)
                var processorFeaturesBuffer:[RdsClientTypes.ProcessorFeature]? = nil
                if let processorFeaturesContainer = processorFeaturesContainer {
                    processorFeaturesBuffer = [RdsClientTypes.ProcessorFeature]()
                    for structureContainer0 in processorFeaturesContainer {
                        processorFeaturesBuffer?.append(structureContainer0)
                    }
                }
                processorFeatures = processorFeaturesBuffer
            } else {
                processorFeatures = []
            }
        } else {
            processorFeatures = nil
        }
        let useDefaultProcessorFeaturesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaultProcessorFeatures)
        useDefaultProcessorFeatures = useDefaultProcessorFeaturesDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let domainIAMRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainIAMRoleName)
        domainIAMRoleName = domainIAMRoleNameDecoded
        let replicaModeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ReplicaMode.self, forKey: .replicaMode)
        replicaMode = replicaModeDecoded
        let maxAllocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAllocatedStorage)
        maxAllocatedStorage = maxAllocatedStorageDecoded
        let customIamInstanceProfileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customIamInstanceProfile)
        customIamInstanceProfile = customIamInstanceProfileDecoded
    }
}

extension CreateDBInstanceReadReplicaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBInstanceReadReplicaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceAlreadyExists" : self = .dBInstanceAlreadyExistsFault(try DBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFound" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotAllowedFault" : self = .dBSubnetGroupNotAllowedFault(try DBSubnetGroupNotAllowedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceQuotaExceeded" : self = .instanceQuotaExceededFault(try InstanceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacity" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetGroupFault" : self = .invalidDBSubnetGroupFault(try InvalidDBSubnetGroupFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedIopsNotAvailableInAZFault" : self = .provisionedIopsNotAvailableInAZFault(try ProvisionedIopsNotAvailableInAZFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceeded" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupported" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBInstanceReadReplicaOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceAlreadyExistsFault(DBInstanceAlreadyExistsFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotAllowedFault(DBSubnetGroupNotAllowedFault)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case instanceQuotaExceededFault(InstanceQuotaExceededFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidDBSubnetGroupFault(InvalidDBSubnetGroupFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case provisionedIopsNotAvailableInAZFault(ProvisionedIopsNotAvailableInAZFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBInstanceReadReplicaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBInstanceReadReplicaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct CreateDBInstanceReadReplicaOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB instance. This data type is used as a response element in the operations CreateDBInstance, CreateDBInstanceReadReplica, DeleteDBInstance, DescribeDBInstances, ModifyDBInstance, PromoteReadReplica, RebootDBInstance, RestoreDBInstanceFromDBSnapshot, RestoreDBInstanceFromS3, RestoreDBInstanceToPointInTime, StartDBInstance, and StopDBInstance.
    public var dBInstance: RdsClientTypes.DBInstance?

    public init (
        dBInstance: RdsClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct CreateDBInstanceReadReplicaOutputResponseBody: Swift.Equatable {
    let dBInstance: RdsClientTypes.DBInstance?
}

extension CreateDBInstanceReadReplicaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBInstanceReadReplicaResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

extension CreateDBParameterGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateDBParameterGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CreateDBParameterGroupInput: Swift.Equatable {
    /// The DB parameter group family name. A DB parameter group can be associated with one and only one DB parameter group family, and can be applied only to a DB instance running a database engine and engine version compatible with that DB parameter group family. To list all of the available parameter group families for a DB engine, use the following command: aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily" --engine  For example, to list all of the available parameter group families for the MySQL DB engine, use the following command: aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily" --engine mysql The output contains duplicates. The following are the valid DB engine values:
    ///
    /// * aurora (for MySQL 5.6-compatible Aurora)
    ///
    /// * aurora-mysql (for MySQL 5.7-compatible Aurora)
    ///
    /// * aurora-postgresql
    ///
    /// * mariadb
    ///
    /// * mysql
    ///
    /// * oracle-ee
    ///
    /// * oracle-ee-cdb
    ///
    /// * oracle-se2
    ///
    /// * oracle-se2-cdb
    ///
    /// * postgres
    ///
    /// * sqlserver-ee
    ///
    /// * sqlserver-se
    ///
    /// * sqlserver-ex
    ///
    /// * sqlserver-web
    /// This member is required.
    public var dBParameterGroupFamily: Swift.String?
    /// The name of the DB parameter group. Constraints:
    ///
    /// * Must be 1 to 255 letters, numbers, or hyphens.
    ///
    /// * First character must be a letter
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    /// This value is stored as a lowercase string.
    /// This member is required.
    public var dBParameterGroupName: Swift.String?
    /// The description for the DB parameter group.
    /// This member is required.
    public var description: Swift.String?
    /// Tags to assign to the DB parameter group.
    public var tags: [RdsClientTypes.Tag]?

    public init (
        dBParameterGroupFamily: Swift.String? = nil,
        dBParameterGroupName: Swift.String? = nil,
        description: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil
    )
    {
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.dBParameterGroupName = dBParameterGroupName
        self.description = description
        self.tags = tags
    }
}

struct CreateDBParameterGroupInputBody: Swift.Equatable {
    let dBParameterGroupName: Swift.String?
    let dBParameterGroupFamily: Swift.String?
    let description: Swift.String?
    let tags: [RdsClientTypes.Tag]?
}

extension CreateDBParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case dBParameterGroupName = "DBParameterGroupName"
        case description = "Description"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateDBParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupAlreadyExists" : self = .dBParameterGroupAlreadyExistsFault(try DBParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupQuotaExceeded" : self = .dBParameterGroupQuotaExceededFault(try DBParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupAlreadyExistsFault(DBParameterGroupAlreadyExistsFault)
    case dBParameterGroupQuotaExceededFault(DBParameterGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBParameterGroup = output.dBParameterGroup
        } else {
            self.dBParameterGroup = nil
        }
    }
}

public struct CreateDBParameterGroupOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB parameter group. This data type is used as a response element in the DescribeDBParameterGroups action.
    public var dBParameterGroup: RdsClientTypes.DBParameterGroup?

    public init (
        dBParameterGroup: RdsClientTypes.DBParameterGroup? = nil
    )
    {
        self.dBParameterGroup = dBParameterGroup
    }
}

struct CreateDBParameterGroupOutputResponseBody: Swift.Equatable {
    let dBParameterGroup: RdsClientTypes.DBParameterGroup?
}

extension CreateDBParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroup = "DBParameterGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBParameterGroupResult"))
        let dBParameterGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBParameterGroup.self, forKey: .dBParameterGroup)
        dBParameterGroup = dBParameterGroupDecoded
    }
}

extension CreateDBProxyEndpointInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBProxyEndpointName = dBProxyEndpointName {
            try container.encode(dBProxyEndpointName, forKey: ClientRuntime.Key("DBProxyEndpointName"))
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetRole = targetRole {
            try container.encode(targetRole, forKey: ClientRuntime.Key("TargetRole"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSubnetIds = vpcSubnetIds {
            var vpcSubnetIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSubnetIds"))
            for (index0, string0) in vpcSubnetIds.enumerated() {
                try vpcSubnetIdsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBProxyEndpoint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateDBProxyEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDBProxyEndpointInput: Swift.Equatable {
    /// The name of the DB proxy endpoint to create.
    /// This member is required.
    public var dBProxyEndpointName: Swift.String?
    /// The name of the DB proxy associated with the DB proxy endpoint that you create.
    /// This member is required.
    public var dBProxyName: Swift.String?
    /// A list of tags. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
    public var tags: [RdsClientTypes.Tag]?
    /// A value that indicates whether the DB proxy endpoint can be used for read/write or read-only operations. The default is READ_WRITE.
    public var targetRole: RdsClientTypes.DBProxyEndpointTargetRole?
    /// The VPC security group IDs for the DB proxy endpoint that you create. You can specify a different set of security group IDs than for the original DB proxy. The default is the default security group for the VPC.
    public var vpcSecurityGroupIds: [Swift.String]?
    /// The VPC subnet IDs for the DB proxy endpoint that you create. You can specify a different set of subnet IDs than for the original DB proxy.
    /// This member is required.
    public var vpcSubnetIds: [Swift.String]?

    public init (
        dBProxyEndpointName: Swift.String? = nil,
        dBProxyName: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        targetRole: RdsClientTypes.DBProxyEndpointTargetRole? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil,
        vpcSubnetIds: [Swift.String]? = nil
    )
    {
        self.dBProxyEndpointName = dBProxyEndpointName
        self.dBProxyName = dBProxyName
        self.tags = tags
        self.targetRole = targetRole
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
        self.vpcSubnetIds = vpcSubnetIds
    }
}

struct CreateDBProxyEndpointInputBody: Swift.Equatable {
    let dBProxyName: Swift.String?
    let dBProxyEndpointName: Swift.String?
    let vpcSubnetIds: [Swift.String]?
    let vpcSecurityGroupIds: [Swift.String]?
    let targetRole: RdsClientTypes.DBProxyEndpointTargetRole?
    let tags: [RdsClientTypes.Tag]?
}

extension CreateDBProxyEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxyEndpointName = "DBProxyEndpointName"
        case dBProxyName = "DBProxyName"
        case tags = "Tags"
        case targetRole = "TargetRole"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        case vpcSubnetIds = "VpcSubnetIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBProxyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyName)
        dBProxyName = dBProxyNameDecoded
        let dBProxyEndpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyEndpointName)
        dBProxyEndpointName = dBProxyEndpointNameDecoded
        if containerValues.contains(.vpcSubnetIds) {
            struct KeyVal0{struct member{}}
            let vpcSubnetIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .vpcSubnetIds)
            if let vpcSubnetIdsWrappedContainer = vpcSubnetIdsWrappedContainer {
                let vpcSubnetIdsContainer = try vpcSubnetIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSubnetIdsBuffer:[Swift.String]? = nil
                if let vpcSubnetIdsContainer = vpcSubnetIdsContainer {
                    vpcSubnetIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSubnetIdsContainer {
                        vpcSubnetIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSubnetIds = vpcSubnetIdsBuffer
            } else {
                vpcSubnetIds = []
            }
        } else {
            vpcSubnetIds = nil
        }
        if containerValues.contains(.vpcSecurityGroupIds) {
            struct KeyVal0{struct member{}}
            let vpcSecurityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .vpcSecurityGroupIds)
            if let vpcSecurityGroupIdsWrappedContainer = vpcSecurityGroupIdsWrappedContainer {
                let vpcSecurityGroupIdsContainer = try vpcSecurityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSecurityGroupIdsBuffer:[Swift.String]? = nil
                if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
                    vpcSecurityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSecurityGroupIdsContainer {
                        vpcSecurityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupIds = vpcSecurityGroupIdsBuffer
            } else {
                vpcSecurityGroupIds = []
            }
        } else {
            vpcSecurityGroupIds = nil
        }
        let targetRoleDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBProxyEndpointTargetRole.self, forKey: .targetRole)
        targetRole = targetRoleDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateDBProxyEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBProxyEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyEndpointAlreadyExistsFault" : self = .dBProxyEndpointAlreadyExistsFault(try DBProxyEndpointAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyEndpointQuotaExceededFault" : self = .dBProxyEndpointQuotaExceededFault(try DBProxyEndpointQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBProxyEndpointOutputError: Swift.Error, Swift.Equatable {
    case dBProxyEndpointAlreadyExistsFault(DBProxyEndpointAlreadyExistsFault)
    case dBProxyEndpointQuotaExceededFault(DBProxyEndpointQuotaExceededFault)
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case invalidSubnet(InvalidSubnet)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBProxyEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBProxyEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBProxyEndpoint = output.dBProxyEndpoint
        } else {
            self.dBProxyEndpoint = nil
        }
    }
}

public struct CreateDBProxyEndpointOutputResponse: Swift.Equatable {
    /// The DBProxyEndpoint object that is created by the API operation. The DB proxy endpoint that you create might provide capabilities such as read/write or read-only operations, or using a different VPC than the proxy's default VPC.
    public var dBProxyEndpoint: RdsClientTypes.DBProxyEndpoint?

    public init (
        dBProxyEndpoint: RdsClientTypes.DBProxyEndpoint? = nil
    )
    {
        self.dBProxyEndpoint = dBProxyEndpoint
    }
}

struct CreateDBProxyEndpointOutputResponseBody: Swift.Equatable {
    let dBProxyEndpoint: RdsClientTypes.DBProxyEndpoint?
}

extension CreateDBProxyEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxyEndpoint = "DBProxyEndpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBProxyEndpointResult"))
        let dBProxyEndpointDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBProxyEndpoint.self, forKey: .dBProxyEndpoint)
        dBProxyEndpoint = dBProxyEndpointDecoded
    }
}

extension CreateDBProxyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let auth = auth {
            var authContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Auth"))
            for (index0, userauthconfig0) in auth.enumerated() {
                try authContainer.encode(userauthconfig0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if debugLogging != false {
            try container.encode(debugLogging, forKey: ClientRuntime.Key("DebugLogging"))
        }
        if let engineFamily = engineFamily {
            try container.encode(engineFamily, forKey: ClientRuntime.Key("EngineFamily"))
        }
        if let idleClientTimeout = idleClientTimeout {
            try container.encode(idleClientTimeout, forKey: ClientRuntime.Key("IdleClientTimeout"))
        }
        if requireTLS != false {
            try container.encode(requireTLS, forKey: ClientRuntime.Key("RequireTLS"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSubnetIds = vpcSubnetIds {
            var vpcSubnetIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSubnetIds"))
            for (index0, string0) in vpcSubnetIds.enumerated() {
                try vpcSubnetIdsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBProxy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateDBProxyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDBProxyInput: Swift.Equatable {
    /// The authorization mechanism that the proxy uses.
    /// This member is required.
    public var auth: [RdsClientTypes.UserAuthConfig]?
    /// The identifier for the proxy. This name must be unique for all proxies owned by your Amazon Web Services account in the specified Amazon Web Services Region. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var dBProxyName: Swift.String?
    /// Whether the proxy includes detailed information about SQL statements in its logs. This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections. The debug information includes the text of SQL statements that you submit through the proxy. Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive information that appears in the logs.
    public var debugLogging: Swift.Bool
    /// The kinds of databases that the proxy can connect to. This value determines which database network protocol the proxy recognizes when it interprets network traffic to and from the database. The engine family applies to MySQL and PostgreSQL for both RDS and Aurora.
    /// This member is required.
    public var engineFamily: RdsClientTypes.EngineFamily?
    /// The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it. You can set this value higher or lower than the connection timeout limit for the associated database.
    public var idleClientTimeout: Swift.Int?
    /// A Boolean parameter that specifies whether Transport Layer Security (TLS) encryption is required for connections to the proxy. By enabling this setting, you can enforce encrypted TLS connections to the proxy.
    public var requireTLS: Swift.Bool
    /// The Amazon Resource Name (ARN) of the IAM role that the proxy uses to access secrets in Amazon Web Services Secrets Manager.
    /// This member is required.
    public var roleArn: Swift.String?
    /// An optional set of key-value pairs to associate arbitrary data of your choosing with the proxy.
    public var tags: [RdsClientTypes.Tag]?
    /// One or more VPC security group IDs to associate with the new proxy.
    public var vpcSecurityGroupIds: [Swift.String]?
    /// One or more VPC subnet IDs to associate with the new proxy.
    /// This member is required.
    public var vpcSubnetIds: [Swift.String]?

    public init (
        auth: [RdsClientTypes.UserAuthConfig]? = nil,
        dBProxyName: Swift.String? = nil,
        debugLogging: Swift.Bool = false,
        engineFamily: RdsClientTypes.EngineFamily? = nil,
        idleClientTimeout: Swift.Int? = nil,
        requireTLS: Swift.Bool = false,
        roleArn: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil,
        vpcSubnetIds: [Swift.String]? = nil
    )
    {
        self.auth = auth
        self.dBProxyName = dBProxyName
        self.debugLogging = debugLogging
        self.engineFamily = engineFamily
        self.idleClientTimeout = idleClientTimeout
        self.requireTLS = requireTLS
        self.roleArn = roleArn
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
        self.vpcSubnetIds = vpcSubnetIds
    }
}

struct CreateDBProxyInputBody: Swift.Equatable {
    let dBProxyName: Swift.String?
    let engineFamily: RdsClientTypes.EngineFamily?
    let auth: [RdsClientTypes.UserAuthConfig]?
    let roleArn: Swift.String?
    let vpcSubnetIds: [Swift.String]?
    let vpcSecurityGroupIds: [Swift.String]?
    let requireTLS: Swift.Bool
    let idleClientTimeout: Swift.Int?
    let debugLogging: Swift.Bool
    let tags: [RdsClientTypes.Tag]?
}

extension CreateDBProxyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auth = "Auth"
        case dBProxyName = "DBProxyName"
        case debugLogging = "DebugLogging"
        case engineFamily = "EngineFamily"
        case idleClientTimeout = "IdleClientTimeout"
        case requireTLS = "RequireTLS"
        case roleArn = "RoleArn"
        case tags = "Tags"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        case vpcSubnetIds = "VpcSubnetIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBProxyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyName)
        dBProxyName = dBProxyNameDecoded
        let engineFamilyDecoded = try containerValues.decodeIfPresent(RdsClientTypes.EngineFamily.self, forKey: .engineFamily)
        engineFamily = engineFamilyDecoded
        if containerValues.contains(.auth) {
            struct KeyVal0{struct member{}}
            let authWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .auth)
            if let authWrappedContainer = authWrappedContainer {
                let authContainer = try authWrappedContainer.decodeIfPresent([RdsClientTypes.UserAuthConfig].self, forKey: .member)
                var authBuffer:[RdsClientTypes.UserAuthConfig]? = nil
                if let authContainer = authContainer {
                    authBuffer = [RdsClientTypes.UserAuthConfig]()
                    for structureContainer0 in authContainer {
                        authBuffer?.append(structureContainer0)
                    }
                }
                auth = authBuffer
            } else {
                auth = []
            }
        } else {
            auth = nil
        }
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        if containerValues.contains(.vpcSubnetIds) {
            struct KeyVal0{struct member{}}
            let vpcSubnetIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .vpcSubnetIds)
            if let vpcSubnetIdsWrappedContainer = vpcSubnetIdsWrappedContainer {
                let vpcSubnetIdsContainer = try vpcSubnetIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSubnetIdsBuffer:[Swift.String]? = nil
                if let vpcSubnetIdsContainer = vpcSubnetIdsContainer {
                    vpcSubnetIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSubnetIdsContainer {
                        vpcSubnetIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSubnetIds = vpcSubnetIdsBuffer
            } else {
                vpcSubnetIds = []
            }
        } else {
            vpcSubnetIds = nil
        }
        if containerValues.contains(.vpcSecurityGroupIds) {
            struct KeyVal0{struct member{}}
            let vpcSecurityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .vpcSecurityGroupIds)
            if let vpcSecurityGroupIdsWrappedContainer = vpcSecurityGroupIdsWrappedContainer {
                let vpcSecurityGroupIdsContainer = try vpcSecurityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSecurityGroupIdsBuffer:[Swift.String]? = nil
                if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
                    vpcSecurityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSecurityGroupIdsContainer {
                        vpcSecurityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupIds = vpcSecurityGroupIdsBuffer
            } else {
                vpcSecurityGroupIds = []
            }
        } else {
            vpcSecurityGroupIds = nil
        }
        let requireTLSDecoded = try containerValues.decode(Swift.Bool.self, forKey: .requireTLS)
        requireTLS = requireTLSDecoded
        let idleClientTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleClientTimeout)
        idleClientTimeout = idleClientTimeoutDecoded
        let debugLoggingDecoded = try containerValues.decode(Swift.Bool.self, forKey: .debugLogging)
        debugLogging = debugLoggingDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateDBProxyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBProxyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyAlreadyExistsFault" : self = .dBProxyAlreadyExistsFault(try DBProxyAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyQuotaExceededFault" : self = .dBProxyQuotaExceededFault(try DBProxyQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBProxyOutputError: Swift.Error, Swift.Equatable {
    case dBProxyAlreadyExistsFault(DBProxyAlreadyExistsFault)
    case dBProxyQuotaExceededFault(DBProxyQuotaExceededFault)
    case invalidSubnet(InvalidSubnet)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBProxyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBProxyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBProxy = output.dBProxy
        } else {
            self.dBProxy = nil
        }
    }
}

public struct CreateDBProxyOutputResponse: Swift.Equatable {
    /// The DBProxy structure corresponding to the new proxy.
    public var dBProxy: RdsClientTypes.DBProxy?

    public init (
        dBProxy: RdsClientTypes.DBProxy? = nil
    )
    {
        self.dBProxy = dBProxy
    }
}

struct CreateDBProxyOutputResponseBody: Swift.Equatable {
    let dBProxy: RdsClientTypes.DBProxy?
}

extension CreateDBProxyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxy = "DBProxy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBProxyResult"))
        let dBProxyDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBProxy.self, forKey: .dBProxy)
        dBProxy = dBProxyDecoded
    }
}

extension CreateDBSecurityGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSecurityGroupDescription = dBSecurityGroupDescription {
            try container.encode(dBSecurityGroupDescription, forKey: ClientRuntime.Key("DBSecurityGroupDescription"))
        }
        if let dBSecurityGroupName = dBSecurityGroupName {
            try container.encode(dBSecurityGroupName, forKey: ClientRuntime.Key("DBSecurityGroupName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBSecurityGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateDBSecurityGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CreateDBSecurityGroupInput: Swift.Equatable {
    /// The description for the DB security group.
    /// This member is required.
    public var dBSecurityGroupDescription: Swift.String?
    /// The name for the DB security group. This value is stored as a lowercase string. Constraints:
    ///
    /// * Must be 1 to 255 letters, numbers, or hyphens.
    ///
    /// * First character must be a letter
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens
    ///
    /// * Must not be "Default"
    ///
    ///
    /// Example: mysecuritygroup
    /// This member is required.
    public var dBSecurityGroupName: Swift.String?
    /// Tags to assign to the DB security group.
    public var tags: [RdsClientTypes.Tag]?

    public init (
        dBSecurityGroupDescription: Swift.String? = nil,
        dBSecurityGroupName: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil
    )
    {
        self.dBSecurityGroupDescription = dBSecurityGroupDescription
        self.dBSecurityGroupName = dBSecurityGroupName
        self.tags = tags
    }
}

struct CreateDBSecurityGroupInputBody: Swift.Equatable {
    let dBSecurityGroupName: Swift.String?
    let dBSecurityGroupDescription: Swift.String?
    let tags: [RdsClientTypes.Tag]?
}

extension CreateDBSecurityGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSecurityGroupDescription = "DBSecurityGroupDescription"
        case dBSecurityGroupName = "DBSecurityGroupName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSecurityGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSecurityGroupName)
        dBSecurityGroupName = dBSecurityGroupNameDecoded
        let dBSecurityGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSecurityGroupDescription)
        dBSecurityGroupDescription = dBSecurityGroupDescriptionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateDBSecurityGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBSecurityGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSecurityGroupAlreadyExists" : self = .dBSecurityGroupAlreadyExistsFault(try DBSecurityGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotSupported" : self = .dBSecurityGroupNotSupportedFault(try DBSecurityGroupNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QuotaExceeded.DBSecurityGroup" : self = .dBSecurityGroupQuotaExceededFault(try DBSecurityGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBSecurityGroupOutputError: Swift.Error, Swift.Equatable {
    case dBSecurityGroupAlreadyExistsFault(DBSecurityGroupAlreadyExistsFault)
    case dBSecurityGroupNotSupportedFault(DBSecurityGroupNotSupportedFault)
    case dBSecurityGroupQuotaExceededFault(DBSecurityGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBSecurityGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBSecurityGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSecurityGroup = output.dBSecurityGroup
        } else {
            self.dBSecurityGroup = nil
        }
    }
}

public struct CreateDBSecurityGroupOutputResponse: Swift.Equatable {
    /// Contains the details for an Amazon RDS DB security group. This data type is used as a response element in the DescribeDBSecurityGroups action.
    public var dBSecurityGroup: RdsClientTypes.DBSecurityGroup?

    public init (
        dBSecurityGroup: RdsClientTypes.DBSecurityGroup? = nil
    )
    {
        self.dBSecurityGroup = dBSecurityGroup
    }
}

struct CreateDBSecurityGroupOutputResponseBody: Swift.Equatable {
    let dBSecurityGroup: RdsClientTypes.DBSecurityGroup?
}

extension CreateDBSecurityGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSecurityGroup = "DBSecurityGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBSecurityGroupResult"))
        let dBSecurityGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSecurityGroup.self, forKey: .dBSecurityGroup)
        dBSecurityGroup = dBSecurityGroupDecoded
    }
}

extension CreateDBSnapshotInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: ClientRuntime.Key("DBSnapshotIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateDBSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CreateDBSnapshotInput: Swift.Equatable {
    /// The identifier of the DB instance that you want to create the snapshot of. Constraints:
    ///
    /// * Must match the identifier of an existing DBInstance.
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// The identifier for the DB snapshot. Constraints:
    ///
    /// * Can't be null, empty, or blank
    ///
    /// * Must contain from 1 to 255 letters, numbers, or hyphens
    ///
    /// * First character must be a letter
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    /// Example: my-snapshot-id
    /// This member is required.
    public var dBSnapshotIdentifier: Swift.String?
    /// A list of tags. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
    public var tags: [RdsClientTypes.Tag]?

    public init (
        dBInstanceIdentifier: Swift.String? = nil,
        dBSnapshotIdentifier: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
        self.tags = tags
    }
}

struct CreateDBSnapshotInputBody: Swift.Equatable {
    let dBSnapshotIdentifier: Swift.String?
    let dBInstanceIdentifier: Swift.String?
    let tags: [RdsClientTypes.Tag]?
}

extension CreateDBSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dBSnapshotIdentifier = "DBSnapshotIdentifier"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSnapshotIdentifier)
        dBSnapshotIdentifier = dBSnapshotIdentifierDecoded
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateDBSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotAlreadyExists" : self = .dBSnapshotAlreadyExistsFault(try DBSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceeded" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBSnapshotOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSnapshotAlreadyExistsFault(DBSnapshotAlreadyExistsFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSnapshot = output.dBSnapshot
        } else {
            self.dBSnapshot = nil
        }
    }
}

public struct CreateDBSnapshotOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB snapshot. This data type is used as a response element in the DescribeDBSnapshots action.
    public var dBSnapshot: RdsClientTypes.DBSnapshot?

    public init (
        dBSnapshot: RdsClientTypes.DBSnapshot? = nil
    )
    {
        self.dBSnapshot = dBSnapshot
    }
}

struct CreateDBSnapshotOutputResponseBody: Swift.Equatable {
    let dBSnapshot: RdsClientTypes.DBSnapshot?
}

extension CreateDBSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSnapshot = "DBSnapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBSnapshotResult"))
        let dBSnapshotDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSnapshot.self, forKey: .dBSnapshot)
        dBSnapshot = dBSnapshotDecoded
    }
}

extension CreateDBSubnetGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSubnetGroupDescription = dBSubnetGroupDescription {
            try container.encode(dBSubnetGroupDescription, forKey: ClientRuntime.Key("DBSubnetGroupDescription"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SubnetIds"))
            for (index0, string0) in subnetIds.enumerated() {
                try subnetIdsContainer.encode(string0, forKey: ClientRuntime.Key("SubnetIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBSubnetGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateDBSubnetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CreateDBSubnetGroupInput: Swift.Equatable {
    /// The description for the DB subnet group.
    /// This member is required.
    public var dBSubnetGroupDescription: Swift.String?
    /// The name for the DB subnet group. This value is stored as a lowercase string. Constraints: Must contain no more than 255 letters, numbers, periods, underscores, spaces, or hyphens. Must not be default. Example: mySubnetgroup
    /// This member is required.
    public var dBSubnetGroupName: Swift.String?
    /// The EC2 Subnet IDs for the DB subnet group.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// Tags to assign to the DB subnet group.
    public var tags: [RdsClientTypes.Tag]?

    public init (
        dBSubnetGroupDescription: Swift.String? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [RdsClientTypes.Tag]? = nil
    )
    {
        self.dBSubnetGroupDescription = dBSubnetGroupDescription
        self.dBSubnetGroupName = dBSubnetGroupName
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

struct CreateDBSubnetGroupInputBody: Swift.Equatable {
    let dBSubnetGroupName: Swift.String?
    let dBSubnetGroupDescription: Swift.String?
    let subnetIds: [Swift.String]?
    let tags: [RdsClientTypes.Tag]?
}

extension CreateDBSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSubnetGroupDescription = "DBSubnetGroupDescription"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        let dBSubnetGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupDescription)
        dBSubnetGroupDescription = dBSubnetGroupDescriptionDecoded
        if containerValues.contains(.subnetIds) {
            struct KeyVal0{struct SubnetIdentifier{}}
            let subnetIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SubnetIdentifier>.CodingKeys.self, forKey: .subnetIds)
            if let subnetIdsWrappedContainer = subnetIdsWrappedContainer {
                let subnetIdsContainer = try subnetIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var subnetIdsBuffer:[Swift.String]? = nil
                if let subnetIdsContainer = subnetIdsContainer {
                    subnetIdsBuffer = [Swift.String]()
                    for stringContainer0 in subnetIdsContainer {
                        subnetIdsBuffer?.append(stringContainer0)
                    }
                }
                subnetIds = subnetIdsBuffer
            } else {
                subnetIds = []
            }
        } else {
            subnetIds = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateDBSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSubnetGroupAlreadyExists" : self = .dBSubnetGroupAlreadyExistsFault(try DBSubnetGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupQuotaExceeded" : self = .dBSubnetGroupQuotaExceededFault(try DBSubnetGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetQuotaExceededFault" : self = .dBSubnetQuotaExceededFault(try DBSubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case dBSubnetGroupAlreadyExistsFault(DBSubnetGroupAlreadyExistsFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupQuotaExceededFault(DBSubnetGroupQuotaExceededFault)
    case dBSubnetQuotaExceededFault(DBSubnetQuotaExceededFault)
    case invalidSubnet(InvalidSubnet)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSubnetGroup = output.dBSubnetGroup
        } else {
            self.dBSubnetGroup = nil
        }
    }
}

public struct CreateDBSubnetGroupOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB subnet group. This data type is used as a response element in the DescribeDBSubnetGroups action.
    public var dBSubnetGroup: RdsClientTypes.DBSubnetGroup?

    public init (
        dBSubnetGroup: RdsClientTypes.DBSubnetGroup? = nil
    )
    {
        self.dBSubnetGroup = dBSubnetGroup
    }
}

struct CreateDBSubnetGroupOutputResponseBody: Swift.Equatable {
    let dBSubnetGroup: RdsClientTypes.DBSubnetGroup?
}

extension CreateDBSubnetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSubnetGroup = "DBSubnetGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBSubnetGroupResult"))
        let dBSubnetGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSubnetGroup.self, forKey: .dBSubnetGroup)
        dBSubnetGroup = dBSubnetGroupDecoded
    }
}

extension CreateEventSubscriptionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: ClientRuntime.Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let snsTopicArn = snsTopicArn {
            try container.encode(snsTopicArn, forKey: ClientRuntime.Key("SnsTopicArn"))
        }
        if let sourceIds = sourceIds {
            var sourceIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SourceIds"))
            for (index0, string0) in sourceIds.enumerated() {
                try sourceIdsContainer.encode(string0, forKey: ClientRuntime.Key("SourceId.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: ClientRuntime.Key("SubscriptionName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateEventSubscription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateEventSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CreateEventSubscriptionInput: Swift.Equatable {
    /// A value that indicates whether to activate the subscription. If the event notification subscription isn't activated, the subscription is created but not active.
    public var enabled: Swift.Bool?
    /// A list of event categories for a particular source type (SourceType) that you want to subscribe to. You can see a list of the categories for a given source type in [Events](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Events.html) in the Amazon RDS User Guide or by using the DescribeEventCategories operation.
    public var eventCategories: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
    /// This member is required.
    public var snsTopicArn: Swift.String?
    /// The list of identifiers of the event sources for which events are returned. If not specified, then all sources are included in the response. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens. It can't end with a hyphen or contain two consecutive hyphens. Constraints:
    ///
    /// * If SourceIds are supplied, SourceType must also be provided.
    ///
    /// * If the source type is a DB instance, a DBInstanceIdentifier value must be supplied.
    ///
    /// * If the source type is a DB cluster, a DBClusterIdentifier value must be supplied.
    ///
    /// * If the source type is a DB parameter group, a DBParameterGroupName value must be supplied.
    ///
    /// * If the source type is a DB security group, a DBSecurityGroupName value must be supplied.
    ///
    /// * If the source type is a DB snapshot, a DBSnapshotIdentifier value must be supplied.
    ///
    /// * If the source type is a DB cluster snapshot, a DBClusterSnapshotIdentifier value must be supplied.
    public var sourceIds: [Swift.String]?
    /// The type of source that is generating the events. For example, if you want to be notified of events generated by a DB instance, you set this parameter to db-instance. If this value isn't specified, all events are returned. Valid values: db-instance | db-cluster | db-parameter-group | db-security-group | db-snapshot | db-cluster-snapshot
    public var sourceType: Swift.String?
    /// The name of the subscription. Constraints: The name must be less than 255 characters.
    /// This member is required.
    public var subscriptionName: Swift.String?
    /// A list of tags. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
    public var tags: [RdsClientTypes.Tag]?

    public init (
        enabled: Swift.Bool? = nil,
        eventCategories: [Swift.String]? = nil,
        snsTopicArn: Swift.String? = nil,
        sourceIds: [Swift.String]? = nil,
        sourceType: Swift.String? = nil,
        subscriptionName: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.snsTopicArn = snsTopicArn
        self.sourceIds = sourceIds
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
        self.tags = tags
    }
}

struct CreateEventSubscriptionInputBody: Swift.Equatable {
    let subscriptionName: Swift.String?
    let snsTopicArn: Swift.String?
    let sourceType: Swift.String?
    let eventCategories: [Swift.String]?
    let sourceIds: [Swift.String]?
    let enabled: Swift.Bool?
    let tags: [RdsClientTypes.Tag]?
}

extension CreateEventSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case eventCategories = "EventCategories"
        case snsTopicArn = "SnsTopicArn"
        case sourceIds = "SourceIds"
        case sourceType = "SourceType"
        case subscriptionName = "SubscriptionName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        if containerValues.contains(.eventCategories) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategories)
            if let eventCategoriesWrappedContainer = eventCategoriesWrappedContainer {
                let eventCategoriesContainer = try eventCategoriesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var eventCategoriesBuffer:[Swift.String]? = nil
                if let eventCategoriesContainer = eventCategoriesContainer {
                    eventCategoriesBuffer = [Swift.String]()
                    for stringContainer0 in eventCategoriesContainer {
                        eventCategoriesBuffer?.append(stringContainer0)
                    }
                }
                eventCategories = eventCategoriesBuffer
            } else {
                eventCategories = []
            }
        } else {
            eventCategories = nil
        }
        if containerValues.contains(.sourceIds) {
            struct KeyVal0{struct SourceId{}}
            let sourceIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SourceId>.CodingKeys.self, forKey: .sourceIds)
            if let sourceIdsWrappedContainer = sourceIdsWrappedContainer {
                let sourceIdsContainer = try sourceIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var sourceIdsBuffer:[Swift.String]? = nil
                if let sourceIdsContainer = sourceIdsContainer {
                    sourceIdsBuffer = [Swift.String]()
                    for stringContainer0 in sourceIdsContainer {
                        sourceIdsBuffer?.append(stringContainer0)
                    }
                }
                sourceIds = sourceIdsBuffer
            } else {
                sourceIds = []
            }
        } else {
            sourceIds = nil
        }
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateEventSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateEventSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EventSubscriptionQuotaExceeded" : self = .eventSubscriptionQuotaExceededFault(try EventSubscriptionQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSInvalidTopic" : self = .sNSInvalidTopicFault(try SNSInvalidTopicFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSNoAuthorization" : self = .sNSNoAuthorizationFault(try SNSNoAuthorizationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSTopicArnNotFound" : self = .sNSTopicArnNotFoundFault(try SNSTopicArnNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SourceNotFound" : self = .sourceNotFoundFault(try SourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionAlreadyExist" : self = .subscriptionAlreadyExistFault(try SubscriptionAlreadyExistFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionCategoryNotFound" : self = .subscriptionCategoryNotFoundFault(try SubscriptionCategoryNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEventSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case eventSubscriptionQuotaExceededFault(EventSubscriptionQuotaExceededFault)
    case sNSInvalidTopicFault(SNSInvalidTopicFault)
    case sNSNoAuthorizationFault(SNSNoAuthorizationFault)
    case sNSTopicArnNotFoundFault(SNSTopicArnNotFoundFault)
    case sourceNotFoundFault(SourceNotFoundFault)
    case subscriptionAlreadyExistFault(SubscriptionAlreadyExistFault)
    case subscriptionCategoryNotFoundFault(SubscriptionCategoryNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEventSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct CreateEventSubscriptionOutputResponse: Swift.Equatable {
    /// Contains the results of a successful invocation of the DescribeEventSubscriptions action.
    public var eventSubscription: RdsClientTypes.EventSubscription?

    public init (
        eventSubscription: RdsClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct CreateEventSubscriptionOutputResponseBody: Swift.Equatable {
    let eventSubscription: RdsClientTypes.EventSubscription?
}

extension CreateEventSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateEventSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(RdsClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

extension CreateGlobalClusterInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: ClientRuntime.Key("DatabaseName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: ClientRuntime.Key("GlobalClusterIdentifier"))
        }
        if let sourceDBClusterIdentifier = sourceDBClusterIdentifier {
            try container.encode(sourceDBClusterIdentifier, forKey: ClientRuntime.Key("SourceDBClusterIdentifier"))
        }
        if let storageEncrypted = storageEncrypted {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
        try container.encode("CreateGlobalCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateGlobalClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateGlobalClusterInput: Swift.Equatable {
    /// The name for your database of up to 64 alpha-numeric characters. If you do not provide a name, Amazon Aurora will not create a database in the global database cluster you are creating.
    public var databaseName: Swift.String?
    /// The deletion protection setting for the new global database. The global database can't be deleted when deletion protection is enabled.
    public var deletionProtection: Swift.Bool?
    /// The name of the database engine to be used for this DB cluster.
    public var engine: Swift.String?
    /// The engine version of the Aurora global database.
    public var engineVersion: Swift.String?
    /// The cluster identifier of the new global database cluster.
    public var globalClusterIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) to use as the primary cluster of the global database. This parameter is optional.
    public var sourceDBClusterIdentifier: Swift.String?
    /// The storage encryption setting for the new global database cluster.
    public var storageEncrypted: Swift.Bool?

    public init (
        databaseName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        globalClusterIdentifier: Swift.String? = nil,
        sourceDBClusterIdentifier: Swift.String? = nil,
        storageEncrypted: Swift.Bool? = nil
    )
    {
        self.databaseName = databaseName
        self.deletionProtection = deletionProtection
        self.engine = engine
        self.engineVersion = engineVersion
        self.globalClusterIdentifier = globalClusterIdentifier
        self.sourceDBClusterIdentifier = sourceDBClusterIdentifier
        self.storageEncrypted = storageEncrypted
    }
}

struct CreateGlobalClusterInputBody: Swift.Equatable {
    let globalClusterIdentifier: Swift.String?
    let sourceDBClusterIdentifier: Swift.String?
    let engine: Swift.String?
    let engineVersion: Swift.String?
    let deletionProtection: Swift.Bool?
    let databaseName: Swift.String?
    let storageEncrypted: Swift.Bool?
}

extension CreateGlobalClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case deletionProtection = "DeletionProtection"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case globalClusterIdentifier = "GlobalClusterIdentifier"
        case sourceDBClusterIdentifier = "SourceDBClusterIdentifier"
        case storageEncrypted = "StorageEncrypted"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalClusterIdentifier)
        globalClusterIdentifier = globalClusterIdentifierDecoded
        let sourceDBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDBClusterIdentifier)
        sourceDBClusterIdentifier = sourceDBClusterIdentifierDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let storageEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
    }
}

extension CreateGlobalClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateGlobalClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlobalClusterAlreadyExistsFault" : self = .globalClusterAlreadyExistsFault(try GlobalClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlobalClusterQuotaExceededFault" : self = .globalClusterQuotaExceededFault(try GlobalClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGlobalClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case globalClusterAlreadyExistsFault(GlobalClusterAlreadyExistsFault)
    case globalClusterQuotaExceededFault(GlobalClusterQuotaExceededFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGlobalClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateGlobalClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalCluster = output.globalCluster
        } else {
            self.globalCluster = nil
        }
    }
}

public struct CreateGlobalClusterOutputResponse: Swift.Equatable {
    /// A data type representing an Aurora global database.
    public var globalCluster: RdsClientTypes.GlobalCluster?

    public init (
        globalCluster: RdsClientTypes.GlobalCluster? = nil
    )
    {
        self.globalCluster = globalCluster
    }
}

struct CreateGlobalClusterOutputResponseBody: Swift.Equatable {
    let globalCluster: RdsClientTypes.GlobalCluster?
}

extension CreateGlobalClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalCluster = "GlobalCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateGlobalClusterResult"))
        let globalClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.GlobalCluster.self, forKey: .globalCluster)
        globalCluster = globalClusterDecoded
    }
}

extension CreateOptionGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let engineName = engineName {
            try container.encode(engineName, forKey: ClientRuntime.Key("EngineName"))
        }
        if let majorEngineVersion = majorEngineVersion {
            try container.encode(majorEngineVersion, forKey: ClientRuntime.Key("MajorEngineVersion"))
        }
        if let optionGroupDescription = optionGroupDescription {
            try container.encode(optionGroupDescription, forKey: ClientRuntime.Key("OptionGroupDescription"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateOptionGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateOptionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CreateOptionGroupInput: Swift.Equatable {
    /// Specifies the name of the engine that this option group should be associated with. Valid Values:
    ///
    /// * mariadb
    ///
    /// * mysql
    ///
    /// * oracle-ee
    ///
    /// * oracle-ee-cdb
    ///
    /// * oracle-se2
    ///
    /// * oracle-se2-cdb
    ///
    /// * postgres
    ///
    /// * sqlserver-ee
    ///
    /// * sqlserver-se
    ///
    /// * sqlserver-ex
    ///
    /// * sqlserver-web
    /// This member is required.
    public var engineName: Swift.String?
    /// Specifies the major version of the engine that this option group should be associated with.
    /// This member is required.
    public var majorEngineVersion: Swift.String?
    /// The description of the option group.
    /// This member is required.
    public var optionGroupDescription: Swift.String?
    /// Specifies the name of the option group to be created. Constraints:
    ///
    /// * Must be 1 to 255 letters, numbers, or hyphens
    ///
    /// * First character must be a letter
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    /// Example: myoptiongroup
    /// This member is required.
    public var optionGroupName: Swift.String?
    /// Tags to assign to the option group.
    public var tags: [RdsClientTypes.Tag]?

    public init (
        engineName: Swift.String? = nil,
        majorEngineVersion: Swift.String? = nil,
        optionGroupDescription: Swift.String? = nil,
        optionGroupName: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil
    )
    {
        self.engineName = engineName
        self.majorEngineVersion = majorEngineVersion
        self.optionGroupDescription = optionGroupDescription
        self.optionGroupName = optionGroupName
        self.tags = tags
    }
}

struct CreateOptionGroupInputBody: Swift.Equatable {
    let optionGroupName: Swift.String?
    let engineName: Swift.String?
    let majorEngineVersion: Swift.String?
    let optionGroupDescription: Swift.String?
    let tags: [RdsClientTypes.Tag]?
}

extension CreateOptionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineName = "EngineName"
        case majorEngineVersion = "MajorEngineVersion"
        case optionGroupDescription = "OptionGroupDescription"
        case optionGroupName = "OptionGroupName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let majorEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorEngineVersion)
        majorEngineVersion = majorEngineVersionDecoded
        let optionGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupDescription)
        optionGroupDescription = optionGroupDescriptionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateOptionGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateOptionGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OptionGroupAlreadyExistsFault" : self = .optionGroupAlreadyExistsFault(try OptionGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupQuotaExceededFault" : self = .optionGroupQuotaExceededFault(try OptionGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOptionGroupOutputError: Swift.Error, Swift.Equatable {
    case optionGroupAlreadyExistsFault(OptionGroupAlreadyExistsFault)
    case optionGroupQuotaExceededFault(OptionGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOptionGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateOptionGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.optionGroup = output.optionGroup
        } else {
            self.optionGroup = nil
        }
    }
}

public struct CreateOptionGroupOutputResponse: Swift.Equatable {
    ///
    public var optionGroup: RdsClientTypes.OptionGroup?

    public init (
        optionGroup: RdsClientTypes.OptionGroup? = nil
    )
    {
        self.optionGroup = optionGroup
    }
}

struct CreateOptionGroupOutputResponseBody: Swift.Equatable {
    let optionGroup: RdsClientTypes.OptionGroup?
}

extension CreateOptionGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optionGroup = "OptionGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateOptionGroupResult"))
        let optionGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.OptionGroup.self, forKey: .optionGroup)
        optionGroup = optionGroupDecoded
    }
}

extension RdsClientTypes.CustomAvailabilityZone: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customAvailabilityZoneId = "CustomAvailabilityZoneId"
        case customAvailabilityZoneName = "CustomAvailabilityZoneName"
        case customAvailabilityZoneStatus = "CustomAvailabilityZoneStatus"
        case vpnDetails = "VpnDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let customAvailabilityZoneId = customAvailabilityZoneId {
            try container.encode(customAvailabilityZoneId, forKey: ClientRuntime.Key("CustomAvailabilityZoneId"))
        }
        if let customAvailabilityZoneName = customAvailabilityZoneName {
            try container.encode(customAvailabilityZoneName, forKey: ClientRuntime.Key("CustomAvailabilityZoneName"))
        }
        if let customAvailabilityZoneStatus = customAvailabilityZoneStatus {
            try container.encode(customAvailabilityZoneStatus, forKey: ClientRuntime.Key("CustomAvailabilityZoneStatus"))
        }
        if let vpnDetails = vpnDetails {
            try container.encode(vpnDetails, forKey: ClientRuntime.Key("VpnDetails"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customAvailabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customAvailabilityZoneId)
        customAvailabilityZoneId = customAvailabilityZoneIdDecoded
        let customAvailabilityZoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customAvailabilityZoneName)
        customAvailabilityZoneName = customAvailabilityZoneNameDecoded
        let customAvailabilityZoneStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customAvailabilityZoneStatus)
        customAvailabilityZoneStatus = customAvailabilityZoneStatusDecoded
        let vpnDetailsDecoded = try containerValues.decodeIfPresent(RdsClientTypes.VpnDetails.self, forKey: .vpnDetails)
        vpnDetails = vpnDetailsDecoded
    }
}

extension RdsClientTypes {
    /// A custom Availability Zone (AZ) is an on-premises AZ that is integrated with a VMware vSphere cluster. For more information about RDS on VMware, see the [ RDS on VMware User Guide.](https://docs.aws.amazon.com/AmazonRDS/latest/RDSonVMwareUserGuide/rds-on-vmware.html)
    public struct CustomAvailabilityZone: Swift.Equatable {
        /// The identifier of the custom AZ. Amazon RDS generates a unique identifier when a custom AZ is created.
        public var customAvailabilityZoneId: Swift.String?
        /// The name of the custom AZ.
        public var customAvailabilityZoneName: Swift.String?
        /// The status of the custom AZ.
        public var customAvailabilityZoneStatus: Swift.String?
        /// Information about the virtual private network (VPN) between the VMware vSphere cluster and the Amazon Web Services website.
        public var vpnDetails: RdsClientTypes.VpnDetails?

        public init (
            customAvailabilityZoneId: Swift.String? = nil,
            customAvailabilityZoneName: Swift.String? = nil,
            customAvailabilityZoneStatus: Swift.String? = nil,
            vpnDetails: RdsClientTypes.VpnDetails? = nil
        )
        {
            self.customAvailabilityZoneId = customAvailabilityZoneId
            self.customAvailabilityZoneName = customAvailabilityZoneName
            self.customAvailabilityZoneStatus = customAvailabilityZoneStatus
            self.vpnDetails = vpnDetails
        }
    }

}

extension CustomAvailabilityZoneAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<CustomAvailabilityZoneAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// CustomAvailabilityZoneName is already used by an existing custom Availability Zone.
public struct CustomAvailabilityZoneAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CustomAvailabilityZoneAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension CustomAvailabilityZoneAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CustomAvailabilityZoneNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<CustomAvailabilityZoneNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// CustomAvailabilityZoneId doesn't refer to an existing custom Availability Zone identifier.
public struct CustomAvailabilityZoneNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CustomAvailabilityZoneNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension CustomAvailabilityZoneNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CustomAvailabilityZoneQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<CustomAvailabilityZoneQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the maximum number of custom Availability Zones.
public struct CustomAvailabilityZoneQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CustomAvailabilityZoneQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension CustomAvailabilityZoneQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CustomDBEngineVersionAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<CustomDBEngineVersionAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A CEV with the specified name already exists.
public struct CustomDBEngineVersionAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CustomDBEngineVersionAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension CustomDBEngineVersionAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CustomDBEngineVersionNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<CustomDBEngineVersionNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified CEV was not found.
public struct CustomDBEngineVersionNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CustomDBEngineVersionNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension CustomDBEngineVersionNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CustomDBEngineVersionQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<CustomDBEngineVersionQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded your CEV quota.
public struct CustomDBEngineVersionQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CustomDBEngineVersionQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension CustomDBEngineVersionQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes {
    public enum CustomEngineVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case inactive
        case inactiveExceptRestore
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomEngineVersionStatus] {
            return [
                .available,
                .inactive,
                .inactiveExceptRestore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "available"
            case .inactive: return "inactive"
            case .inactiveExceptRestore: return "inactive-except-restore"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomEngineVersionStatus(rawValue: rawValue) ?? CustomEngineVersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes.DBCluster: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activityStreamKinesisStreamName = "ActivityStreamKinesisStreamName"
        case activityStreamKmsKeyId = "ActivityStreamKmsKeyId"
        case activityStreamMode = "ActivityStreamMode"
        case activityStreamStatus = "ActivityStreamStatus"
        case allocatedStorage = "AllocatedStorage"
        case associatedRoles = "AssociatedRoles"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case automaticRestartTime = "AutomaticRestartTime"
        case availabilityZones = "AvailabilityZones"
        case backtrackConsumedChangeRecords = "BacktrackConsumedChangeRecords"
        case backtrackWindow = "BacktrackWindow"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case capacity = "Capacity"
        case characterSetName = "CharacterSetName"
        case cloneGroupId = "CloneGroupId"
        case clusterCreateTime = "ClusterCreateTime"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case crossAccountClone = "CrossAccountClone"
        case customEndpoints = "CustomEndpoints"
        case dBClusterArn = "DBClusterArn"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBClusterInstanceClass = "DBClusterInstanceClass"
        case dBClusterMembers = "DBClusterMembers"
        case dBClusterOptionGroupMemberships = "DBClusterOptionGroupMemberships"
        case dBClusterParameterGroup = "DBClusterParameterGroup"
        case dBSubnetGroup = "DBSubnetGroup"
        case databaseName = "DatabaseName"
        case dbClusterResourceId = "DbClusterResourceId"
        case deletionProtection = "DeletionProtection"
        case domainMemberships = "DomainMemberships"
        case earliestBacktrackTime = "EarliestBacktrackTime"
        case earliestRestorableTime = "EarliestRestorableTime"
        case enabledCloudwatchLogsExports = "EnabledCloudwatchLogsExports"
        case endpoint = "Endpoint"
        case engine = "Engine"
        case engineMode = "EngineMode"
        case engineVersion = "EngineVersion"
        case globalWriteForwardingRequested = "GlobalWriteForwardingRequested"
        case globalWriteForwardingStatus = "GlobalWriteForwardingStatus"
        case hostedZoneId = "HostedZoneId"
        case httpEndpointEnabled = "HttpEndpointEnabled"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case latestRestorableTime = "LatestRestorableTime"
        case masterUsername = "MasterUsername"
        case monitoringInterval = "MonitoringInterval"
        case monitoringRoleArn = "MonitoringRoleArn"
        case multiAZ = "MultiAZ"
        case pendingModifiedValues = "PendingModifiedValues"
        case percentProgress = "PercentProgress"
        case performanceInsightsEnabled = "PerformanceInsightsEnabled"
        case performanceInsightsKMSKeyId = "PerformanceInsightsKMSKeyId"
        case performanceInsightsRetentionPeriod = "PerformanceInsightsRetentionPeriod"
        case port = "Port"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case publiclyAccessible = "PubliclyAccessible"
        case readReplicaIdentifiers = "ReadReplicaIdentifiers"
        case readerEndpoint = "ReaderEndpoint"
        case replicationSourceIdentifier = "ReplicationSourceIdentifier"
        case scalingConfigurationInfo = "ScalingConfigurationInfo"
        case status = "Status"
        case storageEncrypted = "StorageEncrypted"
        case storageType = "StorageType"
        case tagList = "TagList"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let activityStreamKinesisStreamName = activityStreamKinesisStreamName {
            try container.encode(activityStreamKinesisStreamName, forKey: ClientRuntime.Key("ActivityStreamKinesisStreamName"))
        }
        if let activityStreamKmsKeyId = activityStreamKmsKeyId {
            try container.encode(activityStreamKmsKeyId, forKey: ClientRuntime.Key("ActivityStreamKmsKeyId"))
        }
        if let activityStreamMode = activityStreamMode {
            try container.encode(activityStreamMode, forKey: ClientRuntime.Key("ActivityStreamMode"))
        }
        if let activityStreamStatus = activityStreamStatus {
            try container.encode(activityStreamStatus, forKey: ClientRuntime.Key("ActivityStreamStatus"))
        }
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if let associatedRoles = associatedRoles {
            var associatedRolesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AssociatedRoles"))
            for (index0, dbclusterrole0) in associatedRoles.enumerated() {
                try associatedRolesContainer.encode(dbclusterrole0, forKey: ClientRuntime.Key("DBClusterRole.\(index0.advanced(by: 1))"))
            }
        }
        if autoMinorVersionUpgrade != false {
            try container.encode(autoMinorVersionUpgrade, forKey: ClientRuntime.Key("AutoMinorVersionUpgrade"))
        }
        if let automaticRestartTime = automaticRestartTime {
            try container.encode(ClientRuntime.TimestampWrapper(automaticRestartTime, format: .dateTime), forKey: ClientRuntime.Key("automaticRestartTime"))
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: ClientRuntime.Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let backtrackConsumedChangeRecords = backtrackConsumedChangeRecords {
            try container.encode(backtrackConsumedChangeRecords, forKey: ClientRuntime.Key("BacktrackConsumedChangeRecords"))
        }
        if let backtrackWindow = backtrackWindow {
            try container.encode(backtrackWindow, forKey: ClientRuntime.Key("BacktrackWindow"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let capacity = capacity {
            try container.encode(capacity, forKey: ClientRuntime.Key("Capacity"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: ClientRuntime.Key("CharacterSetName"))
        }
        if let cloneGroupId = cloneGroupId {
            try container.encode(cloneGroupId, forKey: ClientRuntime.Key("CloneGroupId"))
        }
        if let clusterCreateTime = clusterCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(clusterCreateTime, format: .dateTime), forKey: ClientRuntime.Key("clusterCreateTime"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let crossAccountClone = crossAccountClone {
            try container.encode(crossAccountClone, forKey: ClientRuntime.Key("CrossAccountClone"))
        }
        if let customEndpoints = customEndpoints {
            var customEndpointsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("CustomEndpoints"))
            for (index0, string0) in customEndpoints.enumerated() {
                try customEndpointsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterArn = dBClusterArn {
            try container.encode(dBClusterArn, forKey: ClientRuntime.Key("DBClusterArn"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterInstanceClass = dBClusterInstanceClass {
            try container.encode(dBClusterInstanceClass, forKey: ClientRuntime.Key("DBClusterInstanceClass"))
        }
        if let dBClusterMembers = dBClusterMembers {
            var dBClusterMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBClusterMembers"))
            for (index0, dbclustermember0) in dBClusterMembers.enumerated() {
                try dBClusterMembersContainer.encode(dbclustermember0, forKey: ClientRuntime.Key("DBClusterMember.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterOptionGroupMemberships = dBClusterOptionGroupMemberships {
            var dBClusterOptionGroupMembershipsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBClusterOptionGroupMemberships"))
            for (index0, dbclusteroptiongroupstatus0) in dBClusterOptionGroupMemberships.enumerated() {
                try dBClusterOptionGroupMembershipsContainer.encode(dbclusteroptiongroupstatus0, forKey: ClientRuntime.Key("DBClusterOptionGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterParameterGroup = dBClusterParameterGroup {
            try container.encode(dBClusterParameterGroup, forKey: ClientRuntime.Key("DBClusterParameterGroup"))
        }
        if let dBSubnetGroup = dBSubnetGroup {
            try container.encode(dBSubnetGroup, forKey: ClientRuntime.Key("DBSubnetGroup"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: ClientRuntime.Key("DatabaseName"))
        }
        if let dbClusterResourceId = dbClusterResourceId {
            try container.encode(dbClusterResourceId, forKey: ClientRuntime.Key("DbClusterResourceId"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domainMemberships = domainMemberships {
            var domainMembershipsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DomainMemberships"))
            for (index0, domainmembership0) in domainMemberships.enumerated() {
                try domainMembershipsContainer.encode(domainmembership0, forKey: ClientRuntime.Key("DomainMembership.\(index0.advanced(by: 1))"))
            }
        }
        if let earliestBacktrackTime = earliestBacktrackTime {
            try container.encode(ClientRuntime.TimestampWrapper(earliestBacktrackTime, format: .dateTime), forKey: ClientRuntime.Key("earliestBacktrackTime"))
        }
        if let earliestRestorableTime = earliestRestorableTime {
            try container.encode(ClientRuntime.TimestampWrapper(earliestRestorableTime, format: .dateTime), forKey: ClientRuntime.Key("earliestRestorableTime"))
        }
        if let enabledCloudwatchLogsExports = enabledCloudwatchLogsExports {
            var enabledCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnabledCloudwatchLogsExports"))
            for (index0, string0) in enabledCloudwatchLogsExports.enumerated() {
                try enabledCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineMode = engineMode {
            try container.encode(engineMode, forKey: ClientRuntime.Key("EngineMode"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let globalWriteForwardingRequested = globalWriteForwardingRequested {
            try container.encode(globalWriteForwardingRequested, forKey: ClientRuntime.Key("GlobalWriteForwardingRequested"))
        }
        if let globalWriteForwardingStatus = globalWriteForwardingStatus {
            try container.encode(globalWriteForwardingStatus, forKey: ClientRuntime.Key("GlobalWriteForwardingStatus"))
        }
        if let hostedZoneId = hostedZoneId {
            try container.encode(hostedZoneId, forKey: ClientRuntime.Key("HostedZoneId"))
        }
        if let httpEndpointEnabled = httpEndpointEnabled {
            try container.encode(httpEndpointEnabled, forKey: ClientRuntime.Key("HttpEndpointEnabled"))
        }
        if let iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: ClientRuntime.Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let latestRestorableTime = latestRestorableTime {
            try container.encode(ClientRuntime.TimestampWrapper(latestRestorableTime, format: .dateTime), forKey: ClientRuntime.Key("latestRestorableTime"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: ClientRuntime.Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: ClientRuntime.Key("MonitoringRoleArn"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let pendingModifiedValues = pendingModifiedValues {
            try container.encode(pendingModifiedValues, forKey: ClientRuntime.Key("PendingModifiedValues"))
        }
        if let percentProgress = percentProgress {
            try container.encode(percentProgress, forKey: ClientRuntime.Key("PercentProgress"))
        }
        if let performanceInsightsEnabled = performanceInsightsEnabled {
            try container.encode(performanceInsightsEnabled, forKey: ClientRuntime.Key("PerformanceInsightsEnabled"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: ClientRuntime.Key("PerformanceInsightsKMSKeyId"))
        }
        if let performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod {
            try container.encode(performanceInsightsRetentionPeriod, forKey: ClientRuntime.Key("PerformanceInsightsRetentionPeriod"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let readReplicaIdentifiers = readReplicaIdentifiers {
            var readReplicaIdentifiersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ReadReplicaIdentifiers"))
            for (index0, string0) in readReplicaIdentifiers.enumerated() {
                try readReplicaIdentifiersContainer.encode(string0, forKey: ClientRuntime.Key("ReadReplicaIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let readerEndpoint = readerEndpoint {
            try container.encode(readerEndpoint, forKey: ClientRuntime.Key("ReaderEndpoint"))
        }
        if let replicationSourceIdentifier = replicationSourceIdentifier {
            try container.encode(replicationSourceIdentifier, forKey: ClientRuntime.Key("ReplicationSourceIdentifier"))
        }
        if let scalingConfigurationInfo = scalingConfigurationInfo {
            try container.encode(scalingConfigurationInfo, forKey: ClientRuntime.Key("ScalingConfigurationInfo"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if storageEncrypted != false {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tagList = tagList {
            var tagListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagList"))
            for (index0, tag0) in tagList.enumerated() {
                try tagListContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroups"))
            for (index0, vpcsecuritygroupmembership0) in vpcSecurityGroups.enumerated() {
                try vpcSecurityGroupsContainer.encode(vpcsecuritygroupmembership0, forKey: ClientRuntime.Key("VpcSecurityGroupMembership.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var availabilityZonesBuffer:[Swift.String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [Swift.String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let characterSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .characterSetName)
        characterSetName = characterSetNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterParameterGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroup)
        dBClusterParameterGroup = dBClusterParameterGroupDecoded
        let dBSubnetGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroup)
        dBSubnetGroup = dBSubnetGroupDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let automaticRestartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automaticRestartTime)
        var automaticRestartTimeBuffer:ClientRuntime.Date? = nil
        if let automaticRestartTimeDecoded = automaticRestartTimeDecoded {
            automaticRestartTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(automaticRestartTimeDecoded, format: .dateTime)
        }
        automaticRestartTime = automaticRestartTimeBuffer
        let percentProgressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let earliestRestorableTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .earliestRestorableTime)
        var earliestRestorableTimeBuffer:ClientRuntime.Date? = nil
        if let earliestRestorableTimeDecoded = earliestRestorableTimeDecoded {
            earliestRestorableTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(earliestRestorableTimeDecoded, format: .dateTime)
        }
        earliestRestorableTime = earliestRestorableTimeBuffer
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let readerEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readerEndpoint)
        readerEndpoint = readerEndpointDecoded
        if containerValues.contains(.customEndpoints) {
            struct KeyVal0{struct member{}}
            let customEndpointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .customEndpoints)
            if let customEndpointsWrappedContainer = customEndpointsWrappedContainer {
                let customEndpointsContainer = try customEndpointsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var customEndpointsBuffer:[Swift.String]? = nil
                if let customEndpointsContainer = customEndpointsContainer {
                    customEndpointsBuffer = [Swift.String]()
                    for stringContainer0 in customEndpointsContainer {
                        customEndpointsBuffer?.append(stringContainer0)
                    }
                }
                customEndpoints = customEndpointsBuffer
            } else {
                customEndpoints = []
            }
        } else {
            customEndpoints = nil
        }
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let latestRestorableTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestRestorableTime)
        var latestRestorableTimeBuffer:ClientRuntime.Date? = nil
        if let latestRestorableTimeDecoded = latestRestorableTimeDecoded {
            latestRestorableTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(latestRestorableTimeDecoded, format: .dateTime)
        }
        latestRestorableTime = latestRestorableTimeBuffer
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        if containerValues.contains(.dBClusterOptionGroupMemberships) {
            struct KeyVal0{struct DBClusterOptionGroup{}}
            let dBClusterOptionGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterOptionGroup>.CodingKeys.self, forKey: .dBClusterOptionGroupMemberships)
            if let dBClusterOptionGroupMembershipsWrappedContainer = dBClusterOptionGroupMembershipsWrappedContainer {
                let dBClusterOptionGroupMembershipsContainer = try dBClusterOptionGroupMembershipsWrappedContainer.decodeIfPresent([RdsClientTypes.DBClusterOptionGroupStatus].self, forKey: .member)
                var dBClusterOptionGroupMembershipsBuffer:[RdsClientTypes.DBClusterOptionGroupStatus]? = nil
                if let dBClusterOptionGroupMembershipsContainer = dBClusterOptionGroupMembershipsContainer {
                    dBClusterOptionGroupMembershipsBuffer = [RdsClientTypes.DBClusterOptionGroupStatus]()
                    for structureContainer0 in dBClusterOptionGroupMembershipsContainer {
                        dBClusterOptionGroupMembershipsBuffer?.append(structureContainer0)
                    }
                }
                dBClusterOptionGroupMemberships = dBClusterOptionGroupMembershipsBuffer
            } else {
                dBClusterOptionGroupMemberships = []
            }
        } else {
            dBClusterOptionGroupMemberships = nil
        }
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let replicationSourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSourceIdentifier)
        replicationSourceIdentifier = replicationSourceIdentifierDecoded
        if containerValues.contains(.readReplicaIdentifiers) {
            struct KeyVal0{struct ReadReplicaIdentifier{}}
            let readReplicaIdentifiersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReadReplicaIdentifier>.CodingKeys.self, forKey: .readReplicaIdentifiers)
            if let readReplicaIdentifiersWrappedContainer = readReplicaIdentifiersWrappedContainer {
                let readReplicaIdentifiersContainer = try readReplicaIdentifiersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var readReplicaIdentifiersBuffer:[Swift.String]? = nil
                if let readReplicaIdentifiersContainer = readReplicaIdentifiersContainer {
                    readReplicaIdentifiersBuffer = [Swift.String]()
                    for stringContainer0 in readReplicaIdentifiersContainer {
                        readReplicaIdentifiersBuffer?.append(stringContainer0)
                    }
                }
                readReplicaIdentifiers = readReplicaIdentifiersBuffer
            } else {
                readReplicaIdentifiers = []
            }
        } else {
            readReplicaIdentifiers = nil
        }
        if containerValues.contains(.dBClusterMembers) {
            struct KeyVal0{struct DBClusterMember{}}
            let dBClusterMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterMember>.CodingKeys.self, forKey: .dBClusterMembers)
            if let dBClusterMembersWrappedContainer = dBClusterMembersWrappedContainer {
                let dBClusterMembersContainer = try dBClusterMembersWrappedContainer.decodeIfPresent([RdsClientTypes.DBClusterMember].self, forKey: .member)
                var dBClusterMembersBuffer:[RdsClientTypes.DBClusterMember]? = nil
                if let dBClusterMembersContainer = dBClusterMembersContainer {
                    dBClusterMembersBuffer = [RdsClientTypes.DBClusterMember]()
                    for structureContainer0 in dBClusterMembersContainer {
                        dBClusterMembersBuffer?.append(structureContainer0)
                    }
                }
                dBClusterMembers = dBClusterMembersBuffer
            } else {
                dBClusterMembers = []
            }
        } else {
            dBClusterMembers = nil
        }
        if containerValues.contains(.vpcSecurityGroups) {
            struct KeyVal0{struct VpcSecurityGroupMembership{}}
            let vpcSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupMembership>.CodingKeys.self, forKey: .vpcSecurityGroups)
            if let vpcSecurityGroupsWrappedContainer = vpcSecurityGroupsWrappedContainer {
                let vpcSecurityGroupsContainer = try vpcSecurityGroupsWrappedContainer.decodeIfPresent([RdsClientTypes.VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupsBuffer:[RdsClientTypes.VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
                    vpcSecurityGroupsBuffer = [RdsClientTypes.VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupsContainer {
                        vpcSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroups = vpcSecurityGroupsBuffer
            } else {
                vpcSecurityGroups = []
            }
        } else {
            vpcSecurityGroups = nil
        }
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
        let storageEncryptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dbClusterResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbClusterResourceId)
        dbClusterResourceId = dbClusterResourceIdDecoded
        let dBClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterArn)
        dBClusterArn = dBClusterArnDecoded
        if containerValues.contains(.associatedRoles) {
            struct KeyVal0{struct DBClusterRole{}}
            let associatedRolesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterRole>.CodingKeys.self, forKey: .associatedRoles)
            if let associatedRolesWrappedContainer = associatedRolesWrappedContainer {
                let associatedRolesContainer = try associatedRolesWrappedContainer.decodeIfPresent([RdsClientTypes.DBClusterRole].self, forKey: .member)
                var associatedRolesBuffer:[RdsClientTypes.DBClusterRole]? = nil
                if let associatedRolesContainer = associatedRolesContainer {
                    associatedRolesBuffer = [RdsClientTypes.DBClusterRole]()
                    for structureContainer0 in associatedRolesContainer {
                        associatedRolesBuffer?.append(structureContainer0)
                    }
                }
                associatedRoles = associatedRolesBuffer
            } else {
                associatedRoles = []
            }
        } else {
            associatedRoles = nil
        }
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        let cloneGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloneGroupId)
        cloneGroupId = cloneGroupIdDecoded
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterCreateTime)
        var clusterCreateTimeBuffer:ClientRuntime.Date? = nil
        if let clusterCreateTimeDecoded = clusterCreateTimeDecoded {
            clusterCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(clusterCreateTimeDecoded, format: .dateTime)
        }
        clusterCreateTime = clusterCreateTimeBuffer
        let earliestBacktrackTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .earliestBacktrackTime)
        var earliestBacktrackTimeBuffer:ClientRuntime.Date? = nil
        if let earliestBacktrackTimeDecoded = earliestBacktrackTimeDecoded {
            earliestBacktrackTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(earliestBacktrackTimeDecoded, format: .dateTime)
        }
        earliestBacktrackTime = earliestBacktrackTimeBuffer
        let backtrackWindowDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backtrackWindow)
        backtrackWindow = backtrackWindowDecoded
        let backtrackConsumedChangeRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backtrackConsumedChangeRecords)
        backtrackConsumedChangeRecords = backtrackConsumedChangeRecordsDecoded
        if containerValues.contains(.enabledCloudwatchLogsExports) {
            struct KeyVal0{struct member{}}
            let enabledCloudwatchLogsExportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enabledCloudwatchLogsExports)
            if let enabledCloudwatchLogsExportsWrappedContainer = enabledCloudwatchLogsExportsWrappedContainer {
                let enabledCloudwatchLogsExportsContainer = try enabledCloudwatchLogsExportsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var enabledCloudwatchLogsExportsBuffer:[Swift.String]? = nil
                if let enabledCloudwatchLogsExportsContainer = enabledCloudwatchLogsExportsContainer {
                    enabledCloudwatchLogsExportsBuffer = [Swift.String]()
                    for stringContainer0 in enabledCloudwatchLogsExportsContainer {
                        enabledCloudwatchLogsExportsBuffer?.append(stringContainer0)
                    }
                }
                enabledCloudwatchLogsExports = enabledCloudwatchLogsExportsBuffer
            } else {
                enabledCloudwatchLogsExports = []
            }
        } else {
            enabledCloudwatchLogsExports = nil
        }
        let capacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .capacity)
        capacity = capacityDecoded
        let engineModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineMode)
        engineMode = engineModeDecoded
        let scalingConfigurationInfoDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ScalingConfigurationInfo.self, forKey: .scalingConfigurationInfo)
        scalingConfigurationInfo = scalingConfigurationInfoDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let httpEndpointEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .httpEndpointEnabled)
        httpEndpointEnabled = httpEndpointEnabledDecoded
        let activityStreamModeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ActivityStreamMode.self, forKey: .activityStreamMode)
        activityStreamMode = activityStreamModeDecoded
        let activityStreamStatusDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ActivityStreamStatus.self, forKey: .activityStreamStatus)
        activityStreamStatus = activityStreamStatusDecoded
        let activityStreamKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activityStreamKmsKeyId)
        activityStreamKmsKeyId = activityStreamKmsKeyIdDecoded
        let activityStreamKinesisStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activityStreamKinesisStreamName)
        activityStreamKinesisStreamName = activityStreamKinesisStreamNameDecoded
        let copyTagsToSnapshotDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let crossAccountCloneDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .crossAccountClone)
        crossAccountClone = crossAccountCloneDecoded
        if containerValues.contains(.domainMemberships) {
            struct KeyVal0{struct DomainMembership{}}
            let domainMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DomainMembership>.CodingKeys.self, forKey: .domainMemberships)
            if let domainMembershipsWrappedContainer = domainMembershipsWrappedContainer {
                let domainMembershipsContainer = try domainMembershipsWrappedContainer.decodeIfPresent([RdsClientTypes.DomainMembership].self, forKey: .member)
                var domainMembershipsBuffer:[RdsClientTypes.DomainMembership]? = nil
                if let domainMembershipsContainer = domainMembershipsContainer {
                    domainMembershipsBuffer = [RdsClientTypes.DomainMembership]()
                    for structureContainer0 in domainMembershipsContainer {
                        domainMembershipsBuffer?.append(structureContainer0)
                    }
                }
                domainMemberships = domainMembershipsBuffer
            } else {
                domainMemberships = []
            }
        } else {
            domainMemberships = nil
        }
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagListBuffer:[RdsClientTypes.Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
        let globalWriteForwardingStatusDecoded = try containerValues.decodeIfPresent(RdsClientTypes.WriteForwardingStatus.self, forKey: .globalWriteForwardingStatus)
        globalWriteForwardingStatus = globalWriteForwardingStatusDecoded
        let globalWriteForwardingRequestedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .globalWriteForwardingRequested)
        globalWriteForwardingRequested = globalWriteForwardingRequestedDecoded
        let pendingModifiedValuesDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ClusterPendingModifiedValues.self, forKey: .pendingModifiedValues)
        pendingModifiedValues = pendingModifiedValuesDecoded
        let dBClusterInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterInstanceClass)
        dBClusterInstanceClass = dBClusterInstanceClassDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let monitoringIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monitoringInterval)
        monitoringInterval = monitoringIntervalDecoded
        let monitoringRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitoringRoleArn)
        monitoringRoleArn = monitoringRoleArnDecoded
        let performanceInsightsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performanceInsightsEnabled)
        performanceInsightsEnabled = performanceInsightsEnabledDecoded
        let performanceInsightsKMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .performanceInsightsKMSKeyId)
        performanceInsightsKMSKeyId = performanceInsightsKMSKeyIdDecoded
        let performanceInsightsRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .performanceInsightsRetentionPeriod)
        performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriodDecoded
    }
}

extension RdsClientTypes {
    /// Contains the details of an Amazon Aurora DB cluster or Multi-AZ DB cluster. For an Amazon Aurora DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, PromoteReadReplicaDBCluster, RestoreDBClusterFromS3, RestoreDBClusterFromSnapshot, RestoreDBClusterToPointInTime, StartDBCluster, and StopDBCluster. For a Multi-AZ DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, RebootDBCluster, RestoreDBClusterFromSnapshot, and RestoreDBClusterToPointInTime. For more information on Amazon Aurora DB clusters, see [ What is Amazon Aurora?](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/CHAP_AuroraOverview.html) in the Amazon Aurora User Guide. For more information on Multi-AZ DB clusters, see [ Multi-AZ deployments with two readable standby DB instances](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/multi-az-db-clusters-concepts.html) in the Amazon RDS User Guide. The Multi-AZ DB clusters feature is in preview and is subject to change.
    public struct DBCluster: Swift.Equatable {
        /// The name of the Amazon Kinesis data stream used for the database activity stream.
        public var activityStreamKinesisStreamName: Swift.String?
        /// The Amazon Web Services KMS key identifier used for encrypting messages in the database activity stream. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        public var activityStreamKmsKeyId: Swift.String?
        /// The mode of the database activity stream. Database events such as a change or access generate an activity stream event. The database session can handle these events either synchronously or asynchronously.
        public var activityStreamMode: RdsClientTypes.ActivityStreamMode?
        /// The status of the database activity stream.
        public var activityStreamStatus: RdsClientTypes.ActivityStreamStatus?
        /// For all database engines except Amazon Aurora, AllocatedStorage specifies the allocated storage size in gibibytes (GiB). For Aurora, AllocatedStorage always returns 1, because Aurora DB cluster storage size isn't fixed, but instead automatically adjusts as needed.
        public var allocatedStorage: Swift.Int?
        /// Provides a list of the Amazon Web Services Identity and Access Management (IAM) roles that are associated with the DB cluster. IAM roles that are associated with a DB cluster grant permission for the DB cluster to access other Amazon Web Services on your behalf.
        public var associatedRoles: [RdsClientTypes.DBClusterRole]?
        /// A value that indicates that minor version patches are applied automatically. This setting is only for non-Aurora Multi-AZ DB clusters.
        public var autoMinorVersionUpgrade: Swift.Bool
        /// The time when a stopped DB cluster is restarted automatically.
        public var automaticRestartTime: ClientRuntime.Date?
        /// Provides the list of Availability Zones (AZs) where instances in the DB cluster can be created.
        public var availabilityZones: [Swift.String]?
        /// The number of change records stored for Backtrack.
        public var backtrackConsumedChangeRecords: Swift.Int?
        /// The target backtrack window, in seconds. If this value is set to 0, backtracking is disabled for the DB cluster. Otherwise, backtracking is enabled.
        public var backtrackWindow: Swift.Int?
        /// Specifies the number of days for which automatic DB snapshots are retained.
        public var backupRetentionPeriod: Swift.Int?
        /// The current capacity of an Aurora Serverless DB cluster. The capacity is 0 (zero) when the cluster is paused. For more information about Aurora Serverless, see [Using Amazon Aurora Serverless](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html) in the Amazon Aurora User Guide.
        public var capacity: Swift.Int?
        /// If present, specifies the name of the character set that this cluster is associated with.
        public var characterSetName: Swift.String?
        /// Identifies the clone group to which the DB cluster is associated.
        public var cloneGroupId: Swift.String?
        /// Specifies the time when the DB cluster was created, in Universal Coordinated Time (UTC).
        public var clusterCreateTime: ClientRuntime.Date?
        /// Specifies whether tags are copied from the DB cluster to snapshots of the DB cluster.
        public var copyTagsToSnapshot: Swift.Bool?
        /// Specifies whether the DB cluster is a clone of a DB cluster owned by a different Amazon Web Services account.
        public var crossAccountClone: Swift.Bool?
        /// Identifies all custom endpoints associated with the cluster.
        public var customEndpoints: [Swift.String]?
        /// The Amazon Resource Name (ARN) for the DB cluster.
        public var dBClusterArn: Swift.String?
        /// Contains a user-supplied DB cluster identifier. This identifier is the unique key that identifies a DB cluster.
        public var dBClusterIdentifier: Swift.String?
        /// The name of the compute and memory capacity class of the DB instance. This setting is only for non-Aurora Multi-AZ DB clusters.
        public var dBClusterInstanceClass: Swift.String?
        /// Provides the list of instances that make up the DB cluster.
        public var dBClusterMembers: [RdsClientTypes.DBClusterMember]?
        /// Provides the list of option group memberships for this DB cluster.
        public var dBClusterOptionGroupMemberships: [RdsClientTypes.DBClusterOptionGroupStatus]?
        /// Specifies the name of the DB cluster parameter group for the DB cluster.
        public var dBClusterParameterGroup: Swift.String?
        /// Specifies information on the subnet group associated with the DB cluster, including the name, description, and subnets in the subnet group.
        public var dBSubnetGroup: Swift.String?
        /// Contains the name of the initial database of this DB cluster that was provided at create time, if one was specified when the DB cluster was created. This same name is returned for the life of the DB cluster.
        public var databaseName: Swift.String?
        /// The Amazon Web Services Region-unique, immutable identifier for the DB cluster. This identifier is found in Amazon Web Services CloudTrail log entries whenever the KMS key for the DB cluster is accessed.
        public var dbClusterResourceId: Swift.String?
        /// Indicates if the DB cluster has deletion protection enabled. The database can't be deleted when deletion protection is enabled.
        public var deletionProtection: Swift.Bool?
        /// The Active Directory Domain membership records associated with the DB cluster.
        public var domainMemberships: [RdsClientTypes.DomainMembership]?
        /// The earliest time to which a DB cluster can be backtracked.
        public var earliestBacktrackTime: ClientRuntime.Date?
        /// The earliest time to which a database can be restored with point-in-time restore.
        public var earliestRestorableTime: ClientRuntime.Date?
        /// A list of log types that this DB cluster is configured to export to CloudWatch Logs. Log types vary by DB engine. For information about the log types for each DB engine, see [Amazon RDS Database Log Files](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html) in the Amazon Aurora User Guide.
        public var enabledCloudwatchLogsExports: [Swift.String]?
        /// Specifies the connection endpoint for the primary instance of the DB cluster.
        public var endpoint: Swift.String?
        /// The name of the database engine to be used for this DB cluster.
        public var engine: Swift.String?
        /// The DB engine mode of the DB cluster, either provisioned, serverless, parallelquery, global, or multimaster. For more information, see [ CreateDBCluster](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_CreateDBCluster.html).
        public var engineMode: Swift.String?
        /// Indicates the database engine version.
        public var engineVersion: Swift.String?
        /// Specifies whether you have requested to enable write forwarding for a secondary cluster in an Aurora global database. Because write forwarding takes time to enable, check the value of GlobalWriteForwardingStatus to confirm that the request has completed before using the write forwarding feature for this cluster.
        public var globalWriteForwardingRequested: Swift.Bool?
        /// Specifies whether a secondary cluster in an Aurora global database has write forwarding enabled, not enabled, or is in the process of enabling it.
        public var globalWriteForwardingStatus: RdsClientTypes.WriteForwardingStatus?
        /// Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.
        public var hostedZoneId: Swift.String?
        /// A value that indicates whether the HTTP endpoint for an Aurora Serverless DB cluster is enabled. When enabled, the HTTP endpoint provides a connectionless web service API for running SQL queries on the Aurora Serverless DB cluster. You can also query your database from inside the RDS console with the query editor. For more information, see [Using the Data API for Aurora Serverless](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html) in the Amazon Aurora User Guide.
        public var httpEndpointEnabled: Swift.Bool?
        /// A value that indicates whether the mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled.
        public var iAMDatabaseAuthenticationEnabled: Swift.Bool?
        /// The Provisioned IOPS (I/O operations per second) value. This setting is only for non-Aurora Multi-AZ DB clusters.
        public var iops: Swift.Int?
        /// If StorageEncrypted is enabled, the Amazon Web Services KMS key identifier for the encrypted DB cluster. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        public var kmsKeyId: Swift.String?
        /// Specifies the latest time to which a database can be restored with point-in-time restore.
        public var latestRestorableTime: ClientRuntime.Date?
        /// Contains the master username for the DB cluster.
        public var masterUsername: Swift.String?
        /// The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB cluster. This setting is only for non-Aurora Multi-AZ DB clusters.
        public var monitoringInterval: Swift.Int?
        /// The ARN for the IAM role that permits RDS to send Enhanced Monitoring metrics to Amazon CloudWatch Logs. This setting is only for non-Aurora Multi-AZ DB clusters.
        public var monitoringRoleArn: Swift.String?
        /// Specifies whether the DB cluster has instances in multiple Availability Zones.
        public var multiAZ: Swift.Bool?
        /// A value that specifies that changes to the DB cluster are pending. This element is only included when changes are pending. Specific changes are identified by subelements.
        public var pendingModifiedValues: RdsClientTypes.ClusterPendingModifiedValues?
        /// Specifies the progress of the operation as a percentage.
        public var percentProgress: Swift.String?
        /// True if Performance Insights is enabled for the DB cluster, and otherwise false. This setting is only for non-Aurora Multi-AZ DB clusters.
        public var performanceInsightsEnabled: Swift.Bool?
        /// The Amazon Web Services KMS key identifier for encryption of Performance Insights data. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. This setting is only for non-Aurora Multi-AZ DB clusters.
        public var performanceInsightsKMSKeyId: Swift.String?
        /// The amount of time, in days, to retain Performance Insights data. Valid values are 7 or 731 (2 years). This setting is only for non-Aurora Multi-AZ DB clusters.
        public var performanceInsightsRetentionPeriod: Swift.Int?
        /// Specifies the port that the database engine is listening on.
        public var port: Swift.Int?
        /// Specifies the daily time range during which automated backups are created if automated backups are enabled, as determined by the BackupRetentionPeriod.
        public var preferredBackupWindow: Swift.String?
        /// Specifies the weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).
        public var preferredMaintenanceWindow: Swift.String?
        /// Specifies the accessibility options for the DB instance. When the DB instance is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB instance's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB instance's VPC. Access to the DB instance is ultimately controlled by the security group it uses. That public access is not permitted if the security group assigned to the DB instance doesn't permit it. When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address. For more information, see [CreateDBInstance]. This setting is only for non-Aurora Multi-AZ DB clusters.
        public var publiclyAccessible: Swift.Bool?
        /// Contains one or more identifiers of the read replicas associated with this DB cluster.
        public var readReplicaIdentifiers: [Swift.String]?
        /// The reader endpoint for the DB cluster. The reader endpoint for a DB cluster load-balances connections across the Aurora Replicas that are available in a DB cluster. As clients request new connections to the reader endpoint, Aurora distributes the connection requests among the Aurora Replicas in the DB cluster. This functionality can help balance your read workload across multiple Aurora Replicas in your DB cluster. If a failover occurs, and the Aurora Replica that you are connected to is promoted to be the primary instance, your connection is dropped. To continue sending your read workload to other Aurora Replicas in the cluster, you can then reconnect to the reader endpoint.
        public var readerEndpoint: Swift.String?
        /// Contains the identifier of the source DB cluster if this DB cluster is a read replica.
        public var replicationSourceIdentifier: Swift.String?
        /// Shows the scaling configuration for an Aurora DB cluster in serverless DB engine mode. For more information, see [Using Amazon Aurora Serverless](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html) in the Amazon Aurora User Guide.
        public var scalingConfigurationInfo: RdsClientTypes.ScalingConfigurationInfo?
        /// Specifies the current state of this DB cluster.
        public var status: Swift.String?
        /// Specifies whether the DB cluster is encrypted.
        public var storageEncrypted: Swift.Bool
        /// The storage type associated with DB instance. This setting is only for non-Aurora Multi-AZ DB clusters.
        public var storageType: Swift.String?
        /// A list of tags. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
        public var tagList: [RdsClientTypes.Tag]?
        /// Provides a list of VPC security groups that the DB cluster belongs to.
        public var vpcSecurityGroups: [RdsClientTypes.VpcSecurityGroupMembership]?

        public init (
            activityStreamKinesisStreamName: Swift.String? = nil,
            activityStreamKmsKeyId: Swift.String? = nil,
            activityStreamMode: RdsClientTypes.ActivityStreamMode? = nil,
            activityStreamStatus: RdsClientTypes.ActivityStreamStatus? = nil,
            allocatedStorage: Swift.Int? = nil,
            associatedRoles: [RdsClientTypes.DBClusterRole]? = nil,
            autoMinorVersionUpgrade: Swift.Bool = false,
            automaticRestartTime: ClientRuntime.Date? = nil,
            availabilityZones: [Swift.String]? = nil,
            backtrackConsumedChangeRecords: Swift.Int? = nil,
            backtrackWindow: Swift.Int? = nil,
            backupRetentionPeriod: Swift.Int? = nil,
            capacity: Swift.Int? = nil,
            characterSetName: Swift.String? = nil,
            cloneGroupId: Swift.String? = nil,
            clusterCreateTime: ClientRuntime.Date? = nil,
            copyTagsToSnapshot: Swift.Bool? = nil,
            crossAccountClone: Swift.Bool? = nil,
            customEndpoints: [Swift.String]? = nil,
            dBClusterArn: Swift.String? = nil,
            dBClusterIdentifier: Swift.String? = nil,
            dBClusterInstanceClass: Swift.String? = nil,
            dBClusterMembers: [RdsClientTypes.DBClusterMember]? = nil,
            dBClusterOptionGroupMemberships: [RdsClientTypes.DBClusterOptionGroupStatus]? = nil,
            dBClusterParameterGroup: Swift.String? = nil,
            dBSubnetGroup: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            dbClusterResourceId: Swift.String? = nil,
            deletionProtection: Swift.Bool? = nil,
            domainMemberships: [RdsClientTypes.DomainMembership]? = nil,
            earliestBacktrackTime: ClientRuntime.Date? = nil,
            earliestRestorableTime: ClientRuntime.Date? = nil,
            enabledCloudwatchLogsExports: [Swift.String]? = nil,
            endpoint: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineMode: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            globalWriteForwardingRequested: Swift.Bool? = nil,
            globalWriteForwardingStatus: RdsClientTypes.WriteForwardingStatus? = nil,
            hostedZoneId: Swift.String? = nil,
            httpEndpointEnabled: Swift.Bool? = nil,
            iAMDatabaseAuthenticationEnabled: Swift.Bool? = nil,
            iops: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            latestRestorableTime: ClientRuntime.Date? = nil,
            masterUsername: Swift.String? = nil,
            monitoringInterval: Swift.Int? = nil,
            monitoringRoleArn: Swift.String? = nil,
            multiAZ: Swift.Bool? = nil,
            pendingModifiedValues: RdsClientTypes.ClusterPendingModifiedValues? = nil,
            percentProgress: Swift.String? = nil,
            performanceInsightsEnabled: Swift.Bool? = nil,
            performanceInsightsKMSKeyId: Swift.String? = nil,
            performanceInsightsRetentionPeriod: Swift.Int? = nil,
            port: Swift.Int? = nil,
            preferredBackupWindow: Swift.String? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            publiclyAccessible: Swift.Bool? = nil,
            readReplicaIdentifiers: [Swift.String]? = nil,
            readerEndpoint: Swift.String? = nil,
            replicationSourceIdentifier: Swift.String? = nil,
            scalingConfigurationInfo: RdsClientTypes.ScalingConfigurationInfo? = nil,
            status: Swift.String? = nil,
            storageEncrypted: Swift.Bool = false,
            storageType: Swift.String? = nil,
            tagList: [RdsClientTypes.Tag]? = nil,
            vpcSecurityGroups: [RdsClientTypes.VpcSecurityGroupMembership]? = nil
        )
        {
            self.activityStreamKinesisStreamName = activityStreamKinesisStreamName
            self.activityStreamKmsKeyId = activityStreamKmsKeyId
            self.activityStreamMode = activityStreamMode
            self.activityStreamStatus = activityStreamStatus
            self.allocatedStorage = allocatedStorage
            self.associatedRoles = associatedRoles
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.automaticRestartTime = automaticRestartTime
            self.availabilityZones = availabilityZones
            self.backtrackConsumedChangeRecords = backtrackConsumedChangeRecords
            self.backtrackWindow = backtrackWindow
            self.backupRetentionPeriod = backupRetentionPeriod
            self.capacity = capacity
            self.characterSetName = characterSetName
            self.cloneGroupId = cloneGroupId
            self.clusterCreateTime = clusterCreateTime
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.crossAccountClone = crossAccountClone
            self.customEndpoints = customEndpoints
            self.dBClusterArn = dBClusterArn
            self.dBClusterIdentifier = dBClusterIdentifier
            self.dBClusterInstanceClass = dBClusterInstanceClass
            self.dBClusterMembers = dBClusterMembers
            self.dBClusterOptionGroupMemberships = dBClusterOptionGroupMemberships
            self.dBClusterParameterGroup = dBClusterParameterGroup
            self.dBSubnetGroup = dBSubnetGroup
            self.databaseName = databaseName
            self.dbClusterResourceId = dbClusterResourceId
            self.deletionProtection = deletionProtection
            self.domainMemberships = domainMemberships
            self.earliestBacktrackTime = earliestBacktrackTime
            self.earliestRestorableTime = earliestRestorableTime
            self.enabledCloudwatchLogsExports = enabledCloudwatchLogsExports
            self.endpoint = endpoint
            self.engine = engine
            self.engineMode = engineMode
            self.engineVersion = engineVersion
            self.globalWriteForwardingRequested = globalWriteForwardingRequested
            self.globalWriteForwardingStatus = globalWriteForwardingStatus
            self.hostedZoneId = hostedZoneId
            self.httpEndpointEnabled = httpEndpointEnabled
            self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.latestRestorableTime = latestRestorableTime
            self.masterUsername = masterUsername
            self.monitoringInterval = monitoringInterval
            self.monitoringRoleArn = monitoringRoleArn
            self.multiAZ = multiAZ
            self.pendingModifiedValues = pendingModifiedValues
            self.percentProgress = percentProgress
            self.performanceInsightsEnabled = performanceInsightsEnabled
            self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
            self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
            self.port = port
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.readReplicaIdentifiers = readReplicaIdentifiers
            self.readerEndpoint = readerEndpoint
            self.replicationSourceIdentifier = replicationSourceIdentifier
            self.scalingConfigurationInfo = scalingConfigurationInfo
            self.status = status
            self.storageEncrypted = storageEncrypted
            self.storageType = storageType
            self.tagList = tagList
            self.vpcSecurityGroups = vpcSecurityGroups
        }
    }

}

extension DBClusterAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user already has a DB cluster with the given identifier.
public struct DBClusterAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBClusterAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBClusterBacktrack: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backtrackIdentifier = "BacktrackIdentifier"
        case backtrackRequestCreationTime = "BacktrackRequestCreationTime"
        case backtrackTo = "BacktrackTo"
        case backtrackedFrom = "BacktrackedFrom"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let backtrackIdentifier = backtrackIdentifier {
            try container.encode(backtrackIdentifier, forKey: ClientRuntime.Key("BacktrackIdentifier"))
        }
        if let backtrackRequestCreationTime = backtrackRequestCreationTime {
            try container.encode(ClientRuntime.TimestampWrapper(backtrackRequestCreationTime, format: .dateTime), forKey: ClientRuntime.Key("backtrackRequestCreationTime"))
        }
        if let backtrackTo = backtrackTo {
            try container.encode(ClientRuntime.TimestampWrapper(backtrackTo, format: .dateTime), forKey: ClientRuntime.Key("backtrackTo"))
        }
        if let backtrackedFrom = backtrackedFrom {
            try container.encode(ClientRuntime.TimestampWrapper(backtrackedFrom, format: .dateTime), forKey: ClientRuntime.Key("backtrackedFrom"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let backtrackIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backtrackIdentifier)
        backtrackIdentifier = backtrackIdentifierDecoded
        let backtrackToDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backtrackTo)
        var backtrackToBuffer:ClientRuntime.Date? = nil
        if let backtrackToDecoded = backtrackToDecoded {
            backtrackToBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(backtrackToDecoded, format: .dateTime)
        }
        backtrackTo = backtrackToBuffer
        let backtrackedFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backtrackedFrom)
        var backtrackedFromBuffer:ClientRuntime.Date? = nil
        if let backtrackedFromDecoded = backtrackedFromDecoded {
            backtrackedFromBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(backtrackedFromDecoded, format: .dateTime)
        }
        backtrackedFrom = backtrackedFromBuffer
        let backtrackRequestCreationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backtrackRequestCreationTime)
        var backtrackRequestCreationTimeBuffer:ClientRuntime.Date? = nil
        if let backtrackRequestCreationTimeDecoded = backtrackRequestCreationTimeDecoded {
            backtrackRequestCreationTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(backtrackRequestCreationTimeDecoded, format: .dateTime)
        }
        backtrackRequestCreationTime = backtrackRequestCreationTimeBuffer
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension RdsClientTypes {
    /// This data type is used as a response element in the DescribeDBClusterBacktracks action.
    public struct DBClusterBacktrack: Swift.Equatable {
        /// Contains the backtrack identifier.
        public var backtrackIdentifier: Swift.String?
        /// The timestamp of the time at which the backtrack was requested.
        public var backtrackRequestCreationTime: ClientRuntime.Date?
        /// The timestamp of the time to which the DB cluster was backtracked.
        public var backtrackTo: ClientRuntime.Date?
        /// The timestamp of the time from which the DB cluster was backtracked.
        public var backtrackedFrom: ClientRuntime.Date?
        /// Contains a user-supplied DB cluster identifier. This identifier is the unique key that identifies a DB cluster.
        public var dBClusterIdentifier: Swift.String?
        /// The status of the backtrack. This property returns one of the following values:
        ///
        /// * applying - The backtrack is currently being applied to or rolled back from the DB cluster.
        ///
        /// * completed - The backtrack has successfully been applied to or rolled back from the DB cluster.
        ///
        /// * failed - An error occurred while the backtrack was applied to or rolled back from the DB cluster.
        ///
        /// * pending - The backtrack is currently pending application to or rollback from the DB cluster.
        public var status: Swift.String?

        public init (
            backtrackIdentifier: Swift.String? = nil,
            backtrackRequestCreationTime: ClientRuntime.Date? = nil,
            backtrackTo: ClientRuntime.Date? = nil,
            backtrackedFrom: ClientRuntime.Date? = nil,
            dBClusterIdentifier: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.backtrackIdentifier = backtrackIdentifier
            self.backtrackRequestCreationTime = backtrackRequestCreationTime
            self.backtrackTo = backtrackTo
            self.backtrackedFrom = backtrackedFrom
            self.dBClusterIdentifier = dBClusterIdentifier
            self.status = status
        }
    }

}

extension DBClusterBacktrackNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterBacktrackNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// BacktrackIdentifier doesn't refer to an existing backtrack.
public struct DBClusterBacktrackNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterBacktrackNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBClusterBacktrackNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBClusterEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customEndpointType = "CustomEndpointType"
        case dBClusterEndpointArn = "DBClusterEndpointArn"
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        case dBClusterEndpointResourceIdentifier = "DBClusterEndpointResourceIdentifier"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case endpoint = "Endpoint"
        case endpointType = "EndpointType"
        case excludedMembers = "ExcludedMembers"
        case staticMembers = "StaticMembers"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let customEndpointType = customEndpointType {
            try container.encode(customEndpointType, forKey: ClientRuntime.Key("CustomEndpointType"))
        }
        if let dBClusterEndpointArn = dBClusterEndpointArn {
            try container.encode(dBClusterEndpointArn, forKey: ClientRuntime.Key("DBClusterEndpointArn"))
        }
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: ClientRuntime.Key("DBClusterEndpointIdentifier"))
        }
        if let dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier {
            try container.encode(dBClusterEndpointResourceIdentifier, forKey: ClientRuntime.Key("DBClusterEndpointResourceIdentifier"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if let endpointType = endpointType {
            try container.encode(endpointType, forKey: ClientRuntime.Key("EndpointType"))
        }
        if let excludedMembers = excludedMembers {
            var excludedMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExcludedMembers"))
            for (index0, string0) in excludedMembers.enumerated() {
                try excludedMembersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let staticMembers = staticMembers {
            var staticMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("StaticMembers"))
            for (index0, string0) in staticMembers.enumerated() {
                try staticMembersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterEndpointResourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointResourceIdentifier)
        dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifierDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let customEndpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customEndpointType)
        customEndpointType = customEndpointTypeDecoded
        if containerValues.contains(.staticMembers) {
            struct KeyVal0{struct member{}}
            let staticMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .staticMembers)
            if let staticMembersWrappedContainer = staticMembersWrappedContainer {
                let staticMembersContainer = try staticMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var staticMembersBuffer:[Swift.String]? = nil
                if let staticMembersContainer = staticMembersContainer {
                    staticMembersBuffer = [Swift.String]()
                    for stringContainer0 in staticMembersContainer {
                        staticMembersBuffer?.append(stringContainer0)
                    }
                }
                staticMembers = staticMembersBuffer
            } else {
                staticMembers = []
            }
        } else {
            staticMembers = nil
        }
        if containerValues.contains(.excludedMembers) {
            struct KeyVal0{struct member{}}
            let excludedMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .excludedMembers)
            if let excludedMembersWrappedContainer = excludedMembersWrappedContainer {
                let excludedMembersContainer = try excludedMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var excludedMembersBuffer:[Swift.String]? = nil
                if let excludedMembersContainer = excludedMembersContainer {
                    excludedMembersBuffer = [Swift.String]()
                    for stringContainer0 in excludedMembersContainer {
                        excludedMembersBuffer?.append(stringContainer0)
                    }
                }
                excludedMembers = excludedMembersBuffer
            } else {
                excludedMembers = []
            }
        } else {
            excludedMembers = nil
        }
        let dBClusterEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointArn)
        dBClusterEndpointArn = dBClusterEndpointArnDecoded
    }
}

extension RdsClientTypes {
    /// This data type represents the information you need to connect to an Amazon Aurora DB cluster. This data type is used as a response element in the following actions:
    ///
    /// * CreateDBClusterEndpoint
    ///
    /// * DescribeDBClusterEndpoints
    ///
    /// * ModifyDBClusterEndpoint
    ///
    /// * DeleteDBClusterEndpoint
    ///
    ///
    /// For the data structure that represents Amazon RDS DB instance endpoints, see Endpoint.
    public struct DBClusterEndpoint: Swift.Equatable {
        /// The type associated with a custom endpoint. One of: READER, WRITER, ANY.
        public var customEndpointType: Swift.String?
        /// The Amazon Resource Name (ARN) for the endpoint.
        public var dBClusterEndpointArn: Swift.String?
        /// The identifier associated with the endpoint. This parameter is stored as a lowercase string.
        public var dBClusterEndpointIdentifier: Swift.String?
        /// A unique system-generated identifier for an endpoint. It remains the same for the whole life of the endpoint.
        public var dBClusterEndpointResourceIdentifier: Swift.String?
        /// The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is stored as a lowercase string.
        public var dBClusterIdentifier: Swift.String?
        /// The DNS address of the endpoint.
        public var endpoint: Swift.String?
        /// The type of the endpoint. One of: READER, WRITER, CUSTOM.
        public var endpointType: Swift.String?
        /// List of DB instance identifiers that aren't part of the custom endpoint group. All other eligible instances are reachable through the custom endpoint. Only relevant if the list of static members is empty.
        public var excludedMembers: [Swift.String]?
        /// List of DB instance identifiers that are part of the custom endpoint group.
        public var staticMembers: [Swift.String]?
        /// The current status of the endpoint. One of: creating, available, deleting, inactive, modifying. The inactive state applies to an endpoint that can't be used for a certain kind of cluster, such as a writer endpoint for a read-only secondary cluster in a global database.
        public var status: Swift.String?

        public init (
            customEndpointType: Swift.String? = nil,
            dBClusterEndpointArn: Swift.String? = nil,
            dBClusterEndpointIdentifier: Swift.String? = nil,
            dBClusterEndpointResourceIdentifier: Swift.String? = nil,
            dBClusterIdentifier: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            endpointType: Swift.String? = nil,
            excludedMembers: [Swift.String]? = nil,
            staticMembers: [Swift.String]? = nil,
            status: Swift.String? = nil
        )
        {
            self.customEndpointType = customEndpointType
            self.dBClusterEndpointArn = dBClusterEndpointArn
            self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
            self.dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier
            self.dBClusterIdentifier = dBClusterIdentifier
            self.endpoint = endpoint
            self.endpointType = endpointType
            self.excludedMembers = excludedMembers
            self.staticMembers = staticMembers
            self.status = status
        }
    }

}

extension DBClusterEndpointAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterEndpointAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified custom endpoint can't be created because it already exists.
public struct DBClusterEndpointAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterEndpointAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBClusterEndpointAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterEndpointNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterEndpointNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified custom endpoint doesn't exist.
public struct DBClusterEndpointNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterEndpointNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBClusterEndpointNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterEndpointQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterEndpointQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The cluster already has the maximum number of custom endpoints.
public struct DBClusterEndpointQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterEndpointQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBClusterEndpointQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBClusterMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroupStatus = "DBClusterParameterGroupStatus"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case isClusterWriter = "IsClusterWriter"
        case promotionTier = "PromotionTier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupStatus = dBClusterParameterGroupStatus {
            try container.encode(dBClusterParameterGroupStatus, forKey: ClientRuntime.Key("DBClusterParameterGroupStatus"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if isClusterWriter != false {
            try container.encode(isClusterWriter, forKey: ClientRuntime.Key("IsClusterWriter"))
        }
        if let promotionTier = promotionTier {
            try container.encode(promotionTier, forKey: ClientRuntime.Key("PromotionTier"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let isClusterWriterDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isClusterWriter)
        isClusterWriter = isClusterWriterDecoded
        let dBClusterParameterGroupStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupStatus)
        dBClusterParameterGroupStatus = dBClusterParameterGroupStatusDecoded
        let promotionTierDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .promotionTier)
        promotionTier = promotionTierDecoded
    }
}

extension RdsClientTypes {
    /// Contains information about an instance that is part of a DB cluster.
    public struct DBClusterMember: Swift.Equatable {
        /// Specifies the status of the DB cluster parameter group for this member of the DB cluster.
        public var dBClusterParameterGroupStatus: Swift.String?
        /// Specifies the instance identifier for this member of the DB cluster.
        public var dBInstanceIdentifier: Swift.String?
        /// Value that is true if the cluster member is the primary instance for the DB cluster and false otherwise.
        public var isClusterWriter: Swift.Bool
        /// A value that specifies the order in which an Aurora Replica is promoted to the primary instance after a failure of the existing primary instance. For more information, see [ Fault Tolerance for an Aurora DB Cluster](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.FaultTolerance) in the Amazon Aurora User Guide.
        public var promotionTier: Swift.Int?

        public init (
            dBClusterParameterGroupStatus: Swift.String? = nil,
            dBInstanceIdentifier: Swift.String? = nil,
            isClusterWriter: Swift.Bool = false,
            promotionTier: Swift.Int? = nil
        )
        {
            self.dBClusterParameterGroupStatus = dBClusterParameterGroupStatus
            self.dBInstanceIdentifier = dBInstanceIdentifier
            self.isClusterWriter = isClusterWriter
            self.promotionTier = promotionTier
        }
    }

}

extension DBClusterNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// DBClusterIdentifier doesn't refer to an existing DB cluster.
public struct DBClusterNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBClusterNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBClusterOptionGroupStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterOptionGroupName = "DBClusterOptionGroupName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterOptionGroupName = dBClusterOptionGroupName {
            try container.encode(dBClusterOptionGroupName, forKey: ClientRuntime.Key("DBClusterOptionGroupName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterOptionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterOptionGroupName)
        dBClusterOptionGroupName = dBClusterOptionGroupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension RdsClientTypes {
    /// Contains status information for a DB cluster option group.
    public struct DBClusterOptionGroupStatus: Swift.Equatable {
        /// Specifies the name of the DB cluster option group.
        public var dBClusterOptionGroupName: Swift.String?
        /// Specifies the status of the DB cluster option group.
        public var status: Swift.String?

        public init (
            dBClusterOptionGroupName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.dBClusterOptionGroupName = dBClusterOptionGroupName
            self.status = status
        }
    }

}

extension RdsClientTypes.DBClusterParameterGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroupArn = "DBClusterParameterGroupArn"
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupArn = dBClusterParameterGroupArn {
            try container.encode(dBClusterParameterGroupArn, forKey: ClientRuntime.Key("DBClusterParameterGroupArn"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dBClusterParameterGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupArn)
        dBClusterParameterGroupArn = dBClusterParameterGroupArnDecoded
    }
}

extension RdsClientTypes {
    /// Contains the details of an Amazon RDS DB cluster parameter group. This data type is used as a response element in the DescribeDBClusterParameterGroups action.
    public struct DBClusterParameterGroup: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the DB cluster parameter group.
        public var dBClusterParameterGroupArn: Swift.String?
        /// The name of the DB cluster parameter group.
        public var dBClusterParameterGroupName: Swift.String?
        /// The name of the DB parameter group family that this DB cluster parameter group is compatible with.
        public var dBParameterGroupFamily: Swift.String?
        /// Provides the customer-specified description for this DB cluster parameter group.
        public var description: Swift.String?

        public init (
            dBClusterParameterGroupArn: Swift.String? = nil,
            dBClusterParameterGroupName: Swift.String? = nil,
            dBParameterGroupFamily: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.dBClusterParameterGroupArn = dBClusterParameterGroupArn
            self.dBClusterParameterGroupName = dBClusterParameterGroupName
            self.dBParameterGroupFamily = dBParameterGroupFamily
            self.description = description
        }
    }

}

extension DBClusterParameterGroupNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterParameterGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// DBClusterParameterGroupName doesn't refer to an existing DB cluster parameter group.
public struct DBClusterParameterGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterParameterGroupNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBClusterParameterGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user attempted to create a new DB cluster and the user has already reached the maximum allowed DB cluster quota.
public struct DBClusterQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBClusterQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBClusterRole: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureName = "FeatureName"
        case roleArn = "RoleArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let featureName = featureName {
            try container.encode(featureName, forKey: ClientRuntime.Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let featureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureName)
        featureName = featureNameDecoded
    }
}

extension RdsClientTypes {
    /// Describes an Amazon Web Services Identity and Access Management (IAM) role that is associated with a DB cluster.
    public struct DBClusterRole: Swift.Equatable {
        /// The name of the feature associated with the Amazon Web Services Identity and Access Management (IAM) role. For information about supported feature names, see [DBEngineVersion].
        public var featureName: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role that is associated with the DB cluster.
        public var roleArn: Swift.String?
        /// Describes the state of association between the IAM role and the DB cluster. The Status property returns one of the following values:
        ///
        /// * ACTIVE - the IAM role ARN is associated with the DB cluster and can be used to access other Amazon Web Services on your behalf.
        ///
        /// * PENDING - the IAM role ARN is being associated with the DB cluster.
        ///
        /// * INVALID - the IAM role ARN is associated with the DB cluster, but the DB cluster is unable to assume the IAM role in order to access other Amazon Web Services on your behalf.
        public var status: Swift.String?

        public init (
            featureName: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.featureName = featureName
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension DBClusterRoleAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterRoleAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified IAM role Amazon Resource Name (ARN) is already associated with the specified DB cluster.
public struct DBClusterRoleAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterRoleAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBClusterRoleAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterRoleNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterRoleNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified IAM role Amazon Resource Name (ARN) isn't associated with the specified DB cluster.
public struct DBClusterRoleNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterRoleNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBClusterRoleNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterRoleQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterRoleQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the maximum number of IAM roles that can be associated with the specified DB cluster.
public struct DBClusterRoleQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterRoleQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBClusterRoleQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBClusterSnapshot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case availabilityZones = "AvailabilityZones"
        case clusterCreateTime = "ClusterCreateTime"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBClusterSnapshotArn = "DBClusterSnapshotArn"
        case dBClusterSnapshotIdentifier = "DBClusterSnapshotIdentifier"
        case engine = "Engine"
        case engineMode = "EngineMode"
        case engineVersion = "EngineVersion"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case kmsKeyId = "KmsKeyId"
        case licenseModel = "LicenseModel"
        case masterUsername = "MasterUsername"
        case percentProgress = "PercentProgress"
        case port = "Port"
        case snapshotCreateTime = "SnapshotCreateTime"
        case snapshotType = "SnapshotType"
        case sourceDBClusterSnapshotArn = "SourceDBClusterSnapshotArn"
        case status = "Status"
        case storageEncrypted = "StorageEncrypted"
        case tagList = "TagList"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allocatedStorage != 0 {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: ClientRuntime.Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterCreateTime = clusterCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(clusterCreateTime, format: .dateTime), forKey: ClientRuntime.Key("clusterCreateTime"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterSnapshotArn = dBClusterSnapshotArn {
            try container.encode(dBClusterSnapshotArn, forKey: ClientRuntime.Key("DBClusterSnapshotArn"))
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("DBClusterSnapshotIdentifier"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineMode = engineMode {
            try container.encode(engineMode, forKey: ClientRuntime.Key("EngineMode"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if iAMDatabaseAuthenticationEnabled != false {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: ClientRuntime.Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if percentProgress != 0 {
            try container.encode(percentProgress, forKey: ClientRuntime.Key("PercentProgress"))
        }
        if port != 0 {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let snapshotCreateTime = snapshotCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(snapshotCreateTime, format: .dateTime), forKey: ClientRuntime.Key("snapshotCreateTime"))
        }
        if let snapshotType = snapshotType {
            try container.encode(snapshotType, forKey: ClientRuntime.Key("SnapshotType"))
        }
        if let sourceDBClusterSnapshotArn = sourceDBClusterSnapshotArn {
            try container.encode(sourceDBClusterSnapshotArn, forKey: ClientRuntime.Key("SourceDBClusterSnapshotArn"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if storageEncrypted != false {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
        if let tagList = tagList {
            var tagListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagList"))
            for (index0, tag0) in tagList.enumerated() {
                try tagListContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var availabilityZonesBuffer:[Swift.String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [Swift.String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let dBClusterSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterSnapshotIdentifier)
        dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotCreateTime)
        var snapshotCreateTimeBuffer:ClientRuntime.Date? = nil
        if let snapshotCreateTimeDecoded = snapshotCreateTimeDecoded {
            snapshotCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(snapshotCreateTimeDecoded, format: .dateTime)
        }
        snapshotCreateTime = snapshotCreateTimeBuffer
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineMode)
        engineMode = engineModeDecoded
        let allocatedStorageDecoded = try containerValues.decode(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterCreateTime)
        var clusterCreateTimeBuffer:ClientRuntime.Date? = nil
        if let clusterCreateTimeDecoded = clusterCreateTimeDecoded {
            clusterCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(clusterCreateTimeDecoded, format: .dateTime)
        }
        clusterCreateTime = clusterCreateTimeBuffer
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let snapshotTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotType)
        snapshotType = snapshotTypeDecoded
        let percentProgressDecoded = try containerValues.decode(Swift.Int.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let storageEncryptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dBClusterSnapshotArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterSnapshotArn)
        dBClusterSnapshotArn = dBClusterSnapshotArnDecoded
        let sourceDBClusterSnapshotArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDBClusterSnapshotArn)
        sourceDBClusterSnapshotArn = sourceDBClusterSnapshotArnDecoded
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagListBuffer:[RdsClientTypes.Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
    }
}

extension RdsClientTypes {
    /// Contains the details for an Amazon RDS DB cluster snapshot This data type is used as a response element in the DescribeDBClusterSnapshots action.
    public struct DBClusterSnapshot: Swift.Equatable {
        /// Specifies the allocated storage size in gibibytes (GiB).
        public var allocatedStorage: Swift.Int
        /// Provides the list of Availability Zones (AZs) where instances in the DB cluster snapshot can be restored.
        public var availabilityZones: [Swift.String]?
        /// Specifies the time when the DB cluster was created, in Universal Coordinated Time (UTC).
        public var clusterCreateTime: ClientRuntime.Date?
        /// Specifies the DB cluster identifier of the DB cluster that this DB cluster snapshot was created from.
        public var dBClusterIdentifier: Swift.String?
        /// The Amazon Resource Name (ARN) for the DB cluster snapshot.
        public var dBClusterSnapshotArn: Swift.String?
        /// Specifies the identifier for the DB cluster snapshot.
        public var dBClusterSnapshotIdentifier: Swift.String?
        /// Specifies the name of the database engine for this DB cluster snapshot.
        public var engine: Swift.String?
        /// Provides the engine mode of the database engine for this DB cluster snapshot.
        public var engineMode: Swift.String?
        /// Provides the version of the database engine for this DB cluster snapshot.
        public var engineVersion: Swift.String?
        /// True if mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled, and otherwise false.
        public var iAMDatabaseAuthenticationEnabled: Swift.Bool
        /// If StorageEncrypted is true, the Amazon Web Services KMS key identifier for the encrypted DB cluster snapshot. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        public var kmsKeyId: Swift.String?
        /// Provides the license model information for this DB cluster snapshot.
        public var licenseModel: Swift.String?
        /// Provides the master username for this DB cluster snapshot.
        public var masterUsername: Swift.String?
        /// Specifies the percentage of the estimated data that has been transferred.
        public var percentProgress: Swift.Int
        /// Specifies the port that the DB cluster was listening on at the time of the snapshot.
        public var port: Swift.Int
        /// Provides the time when the snapshot was taken, in Universal Coordinated Time (UTC).
        public var snapshotCreateTime: ClientRuntime.Date?
        /// Provides the type of the DB cluster snapshot.
        public var snapshotType: Swift.String?
        /// If the DB cluster snapshot was copied from a source DB cluster snapshot, the Amazon Resource Name (ARN) for the source DB cluster snapshot, otherwise, a null value.
        public var sourceDBClusterSnapshotArn: Swift.String?
        /// Specifies the status of this DB cluster snapshot.
        public var status: Swift.String?
        /// Specifies whether the DB cluster snapshot is encrypted.
        public var storageEncrypted: Swift.Bool
        /// A list of tags. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
        public var tagList: [RdsClientTypes.Tag]?
        /// Provides the VPC ID associated with the DB cluster snapshot.
        public var vpcId: Swift.String?

        public init (
            allocatedStorage: Swift.Int = 0,
            availabilityZones: [Swift.String]? = nil,
            clusterCreateTime: ClientRuntime.Date? = nil,
            dBClusterIdentifier: Swift.String? = nil,
            dBClusterSnapshotArn: Swift.String? = nil,
            dBClusterSnapshotIdentifier: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineMode: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            iAMDatabaseAuthenticationEnabled: Swift.Bool = false,
            kmsKeyId: Swift.String? = nil,
            licenseModel: Swift.String? = nil,
            masterUsername: Swift.String? = nil,
            percentProgress: Swift.Int = 0,
            port: Swift.Int = 0,
            snapshotCreateTime: ClientRuntime.Date? = nil,
            snapshotType: Swift.String? = nil,
            sourceDBClusterSnapshotArn: Swift.String? = nil,
            status: Swift.String? = nil,
            storageEncrypted: Swift.Bool = false,
            tagList: [RdsClientTypes.Tag]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.availabilityZones = availabilityZones
            self.clusterCreateTime = clusterCreateTime
            self.dBClusterIdentifier = dBClusterIdentifier
            self.dBClusterSnapshotArn = dBClusterSnapshotArn
            self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
            self.engine = engine
            self.engineMode = engineMode
            self.engineVersion = engineVersion
            self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
            self.kmsKeyId = kmsKeyId
            self.licenseModel = licenseModel
            self.masterUsername = masterUsername
            self.percentProgress = percentProgress
            self.port = port
            self.snapshotCreateTime = snapshotCreateTime
            self.snapshotType = snapshotType
            self.sourceDBClusterSnapshotArn = sourceDBClusterSnapshotArn
            self.status = status
            self.storageEncrypted = storageEncrypted
            self.tagList = tagList
            self.vpcId = vpcId
        }
    }

}

extension DBClusterSnapshotAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterSnapshotAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user already has a DB cluster snapshot with the given identifier.
public struct DBClusterSnapshotAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterSnapshotAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBClusterSnapshotAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBClusterSnapshotAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeValues = "AttributeValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: ClientRuntime.Key("AttributeName"))
        }
        if let attributeValues = attributeValues {
            var attributeValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttributeValues"))
            for (index0, string0) in attributeValues.enumerated() {
                try attributeValuesContainer.encode(string0, forKey: ClientRuntime.Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        if containerValues.contains(.attributeValues) {
            struct KeyVal0{struct AttributeValue{}}
            let attributeValuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AttributeValue>.CodingKeys.self, forKey: .attributeValues)
            if let attributeValuesWrappedContainer = attributeValuesWrappedContainer {
                let attributeValuesContainer = try attributeValuesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var attributeValuesBuffer:[Swift.String]? = nil
                if let attributeValuesContainer = attributeValuesContainer {
                    attributeValuesBuffer = [Swift.String]()
                    for stringContainer0 in attributeValuesContainer {
                        attributeValuesBuffer?.append(stringContainer0)
                    }
                }
                attributeValues = attributeValuesBuffer
            } else {
                attributeValues = []
            }
        } else {
            attributeValues = nil
        }
    }
}

extension RdsClientTypes {
    /// Contains the name and values of a manual DB cluster snapshot attribute. Manual DB cluster snapshot attributes are used to authorize other Amazon Web Services accounts to restore a manual DB cluster snapshot. For more information, see the ModifyDBClusterSnapshotAttribute API action.
    public struct DBClusterSnapshotAttribute: Swift.Equatable {
        /// The name of the manual DB cluster snapshot attribute. The attribute named restore refers to the list of Amazon Web Services accounts that have permission to copy or restore the manual DB cluster snapshot. For more information, see the ModifyDBClusterSnapshotAttribute API action.
        public var attributeName: Swift.String?
        /// The value(s) for the manual DB cluster snapshot attribute. If the AttributeName field is set to restore, then this element returns a list of IDs of the Amazon Web Services accounts that are authorized to copy or restore the manual DB cluster snapshot. If a value of all is in the list, then the manual DB cluster snapshot is public and available for any Amazon Web Services account to copy or restore.
        public var attributeValues: [Swift.String]?

        public init (
            attributeName: Swift.String? = nil,
            attributeValues: [Swift.String]? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeValues = attributeValues
        }
    }

}

extension RdsClientTypes.DBClusterSnapshotAttributesResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterSnapshotAttributes = "DBClusterSnapshotAttributes"
        case dBClusterSnapshotIdentifier = "DBClusterSnapshotIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterSnapshotAttributes = dBClusterSnapshotAttributes {
            var dBClusterSnapshotAttributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBClusterSnapshotAttributes"))
            for (index0, dbclustersnapshotattribute0) in dBClusterSnapshotAttributes.enumerated() {
                try dBClusterSnapshotAttributesContainer.encode(dbclustersnapshotattribute0, forKey: ClientRuntime.Key("DBClusterSnapshotAttribute.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("DBClusterSnapshotIdentifier"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterSnapshotIdentifier)
        dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifierDecoded
        if containerValues.contains(.dBClusterSnapshotAttributes) {
            struct KeyVal0{struct DBClusterSnapshotAttribute{}}
            let dBClusterSnapshotAttributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterSnapshotAttribute>.CodingKeys.self, forKey: .dBClusterSnapshotAttributes)
            if let dBClusterSnapshotAttributesWrappedContainer = dBClusterSnapshotAttributesWrappedContainer {
                let dBClusterSnapshotAttributesContainer = try dBClusterSnapshotAttributesWrappedContainer.decodeIfPresent([RdsClientTypes.DBClusterSnapshotAttribute].self, forKey: .member)
                var dBClusterSnapshotAttributesBuffer:[RdsClientTypes.DBClusterSnapshotAttribute]? = nil
                if let dBClusterSnapshotAttributesContainer = dBClusterSnapshotAttributesContainer {
                    dBClusterSnapshotAttributesBuffer = [RdsClientTypes.DBClusterSnapshotAttribute]()
                    for structureContainer0 in dBClusterSnapshotAttributesContainer {
                        dBClusterSnapshotAttributesBuffer?.append(structureContainer0)
                    }
                }
                dBClusterSnapshotAttributes = dBClusterSnapshotAttributesBuffer
            } else {
                dBClusterSnapshotAttributes = []
            }
        } else {
            dBClusterSnapshotAttributes = nil
        }
    }
}

extension RdsClientTypes {
    /// Contains the results of a successful call to the DescribeDBClusterSnapshotAttributes API action. Manual DB cluster snapshot attributes are used to authorize other Amazon Web Services accounts to copy or restore a manual DB cluster snapshot. For more information, see the ModifyDBClusterSnapshotAttribute API action.
    public struct DBClusterSnapshotAttributesResult: Swift.Equatable {
        /// The list of attributes and values for the manual DB cluster snapshot.
        public var dBClusterSnapshotAttributes: [RdsClientTypes.DBClusterSnapshotAttribute]?
        /// The identifier of the manual DB cluster snapshot that the attributes apply to.
        public var dBClusterSnapshotIdentifier: Swift.String?

        public init (
            dBClusterSnapshotAttributes: [RdsClientTypes.DBClusterSnapshotAttribute]? = nil,
            dBClusterSnapshotIdentifier: Swift.String? = nil
        )
        {
            self.dBClusterSnapshotAttributes = dBClusterSnapshotAttributes
            self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
        }
    }

}

extension DBClusterSnapshotNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterSnapshotNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// DBClusterSnapshotIdentifier doesn't refer to an existing DB cluster snapshot.
public struct DBClusterSnapshotNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterSnapshotNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBClusterSnapshotNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBEngineVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case dBEngineDescription = "DBEngineDescription"
        case dBEngineVersionArn = "DBEngineVersionArn"
        case dBEngineVersionDescription = "DBEngineVersionDescription"
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case databaseInstallationFilesS3BucketName = "DatabaseInstallationFilesS3BucketName"
        case databaseInstallationFilesS3Prefix = "DatabaseInstallationFilesS3Prefix"
        case defaultCharacterSet = "DefaultCharacterSet"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case exportableLogTypes = "ExportableLogTypes"
        case kMSKeyId = "KMSKeyId"
        case majorEngineVersion = "MajorEngineVersion"
        case status = "Status"
        case supportedCharacterSets = "SupportedCharacterSets"
        case supportedEngineModes = "SupportedEngineModes"
        case supportedFeatureNames = "SupportedFeatureNames"
        case supportedNcharCharacterSets = "SupportedNcharCharacterSets"
        case supportedTimezones = "SupportedTimezones"
        case supportsGlobalDatabases = "SupportsGlobalDatabases"
        case supportsLogExportsToCloudwatchLogs = "SupportsLogExportsToCloudwatchLogs"
        case supportsParallelQuery = "SupportsParallelQuery"
        case supportsReadReplica = "SupportsReadReplica"
        case tagList = "TagList"
        case validUpgradeTarget = "ValidUpgradeTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let createTime = createTime {
            try container.encode(ClientRuntime.TimestampWrapper(createTime, format: .dateTime), forKey: ClientRuntime.Key("createTime"))
        }
        if let dBEngineDescription = dBEngineDescription {
            try container.encode(dBEngineDescription, forKey: ClientRuntime.Key("DBEngineDescription"))
        }
        if let dBEngineVersionArn = dBEngineVersionArn {
            try container.encode(dBEngineVersionArn, forKey: ClientRuntime.Key("DBEngineVersionArn"))
        }
        if let dBEngineVersionDescription = dBEngineVersionDescription {
            try container.encode(dBEngineVersionDescription, forKey: ClientRuntime.Key("DBEngineVersionDescription"))
        }
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let databaseInstallationFilesS3BucketName = databaseInstallationFilesS3BucketName {
            try container.encode(databaseInstallationFilesS3BucketName, forKey: ClientRuntime.Key("DatabaseInstallationFilesS3BucketName"))
        }
        if let databaseInstallationFilesS3Prefix = databaseInstallationFilesS3Prefix {
            try container.encode(databaseInstallationFilesS3Prefix, forKey: ClientRuntime.Key("DatabaseInstallationFilesS3Prefix"))
        }
        if let defaultCharacterSet = defaultCharacterSet {
            try container.encode(defaultCharacterSet, forKey: ClientRuntime.Key("DefaultCharacterSet"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let exportableLogTypes = exportableLogTypes {
            var exportableLogTypesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExportableLogTypes"))
            for (index0, string0) in exportableLogTypes.enumerated() {
                try exportableLogTypesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let kMSKeyId = kMSKeyId {
            try container.encode(kMSKeyId, forKey: ClientRuntime.Key("KMSKeyId"))
        }
        if let majorEngineVersion = majorEngineVersion {
            try container.encode(majorEngineVersion, forKey: ClientRuntime.Key("MajorEngineVersion"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let supportedCharacterSets = supportedCharacterSets {
            var supportedCharacterSetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedCharacterSets"))
            for (index0, characterset0) in supportedCharacterSets.enumerated() {
                try supportedCharacterSetsContainer.encode(characterset0, forKey: ClientRuntime.Key("CharacterSet.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedEngineModes = supportedEngineModes {
            var supportedEngineModesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedEngineModes"))
            for (index0, string0) in supportedEngineModes.enumerated() {
                try supportedEngineModesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedFeatureNames = supportedFeatureNames {
            var supportedFeatureNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedFeatureNames"))
            for (index0, string0) in supportedFeatureNames.enumerated() {
                try supportedFeatureNamesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedNcharCharacterSets = supportedNcharCharacterSets {
            var supportedNcharCharacterSetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedNcharCharacterSets"))
            for (index0, characterset0) in supportedNcharCharacterSets.enumerated() {
                try supportedNcharCharacterSetsContainer.encode(characterset0, forKey: ClientRuntime.Key("CharacterSet.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedTimezones = supportedTimezones {
            var supportedTimezonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedTimezones"))
            for (index0, timezone0) in supportedTimezones.enumerated() {
                try supportedTimezonesContainer.encode(timezone0, forKey: ClientRuntime.Key("Timezone.\(index0.advanced(by: 1))"))
            }
        }
        if supportsGlobalDatabases != false {
            try container.encode(supportsGlobalDatabases, forKey: ClientRuntime.Key("SupportsGlobalDatabases"))
        }
        if supportsLogExportsToCloudwatchLogs != false {
            try container.encode(supportsLogExportsToCloudwatchLogs, forKey: ClientRuntime.Key("SupportsLogExportsToCloudwatchLogs"))
        }
        if supportsParallelQuery != false {
            try container.encode(supportsParallelQuery, forKey: ClientRuntime.Key("SupportsParallelQuery"))
        }
        if supportsReadReplica != false {
            try container.encode(supportsReadReplica, forKey: ClientRuntime.Key("SupportsReadReplica"))
        }
        if let tagList = tagList {
            var tagListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagList"))
            for (index0, tag0) in tagList.enumerated() {
                try tagListContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let validUpgradeTarget = validUpgradeTarget {
            var validUpgradeTargetContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ValidUpgradeTarget"))
            for (index0, upgradetarget0) in validUpgradeTarget.enumerated() {
                try validUpgradeTargetContainer.encode(upgradetarget0, forKey: ClientRuntime.Key("UpgradeTarget.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let dBEngineDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBEngineDescription)
        dBEngineDescription = dBEngineDescriptionDecoded
        let dBEngineVersionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBEngineVersionDescription)
        dBEngineVersionDescription = dBEngineVersionDescriptionDecoded
        let defaultCharacterSetDecoded = try containerValues.decodeIfPresent(RdsClientTypes.CharacterSet.self, forKey: .defaultCharacterSet)
        defaultCharacterSet = defaultCharacterSetDecoded
        if containerValues.contains(.supportedCharacterSets) {
            struct KeyVal0{struct CharacterSet{}}
            let supportedCharacterSetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CharacterSet>.CodingKeys.self, forKey: .supportedCharacterSets)
            if let supportedCharacterSetsWrappedContainer = supportedCharacterSetsWrappedContainer {
                let supportedCharacterSetsContainer = try supportedCharacterSetsWrappedContainer.decodeIfPresent([RdsClientTypes.CharacterSet].self, forKey: .member)
                var supportedCharacterSetsBuffer:[RdsClientTypes.CharacterSet]? = nil
                if let supportedCharacterSetsContainer = supportedCharacterSetsContainer {
                    supportedCharacterSetsBuffer = [RdsClientTypes.CharacterSet]()
                    for structureContainer0 in supportedCharacterSetsContainer {
                        supportedCharacterSetsBuffer?.append(structureContainer0)
                    }
                }
                supportedCharacterSets = supportedCharacterSetsBuffer
            } else {
                supportedCharacterSets = []
            }
        } else {
            supportedCharacterSets = nil
        }
        if containerValues.contains(.supportedNcharCharacterSets) {
            struct KeyVal0{struct CharacterSet{}}
            let supportedNcharCharacterSetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CharacterSet>.CodingKeys.self, forKey: .supportedNcharCharacterSets)
            if let supportedNcharCharacterSetsWrappedContainer = supportedNcharCharacterSetsWrappedContainer {
                let supportedNcharCharacterSetsContainer = try supportedNcharCharacterSetsWrappedContainer.decodeIfPresent([RdsClientTypes.CharacterSet].self, forKey: .member)
                var supportedNcharCharacterSetsBuffer:[RdsClientTypes.CharacterSet]? = nil
                if let supportedNcharCharacterSetsContainer = supportedNcharCharacterSetsContainer {
                    supportedNcharCharacterSetsBuffer = [RdsClientTypes.CharacterSet]()
                    for structureContainer0 in supportedNcharCharacterSetsContainer {
                        supportedNcharCharacterSetsBuffer?.append(structureContainer0)
                    }
                }
                supportedNcharCharacterSets = supportedNcharCharacterSetsBuffer
            } else {
                supportedNcharCharacterSets = []
            }
        } else {
            supportedNcharCharacterSets = nil
        }
        if containerValues.contains(.validUpgradeTarget) {
            struct KeyVal0{struct UpgradeTarget{}}
            let validUpgradeTargetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.UpgradeTarget>.CodingKeys.self, forKey: .validUpgradeTarget)
            if let validUpgradeTargetWrappedContainer = validUpgradeTargetWrappedContainer {
                let validUpgradeTargetContainer = try validUpgradeTargetWrappedContainer.decodeIfPresent([RdsClientTypes.UpgradeTarget].self, forKey: .member)
                var validUpgradeTargetBuffer:[RdsClientTypes.UpgradeTarget]? = nil
                if let validUpgradeTargetContainer = validUpgradeTargetContainer {
                    validUpgradeTargetBuffer = [RdsClientTypes.UpgradeTarget]()
                    for structureContainer0 in validUpgradeTargetContainer {
                        validUpgradeTargetBuffer?.append(structureContainer0)
                    }
                }
                validUpgradeTarget = validUpgradeTargetBuffer
            } else {
                validUpgradeTarget = []
            }
        } else {
            validUpgradeTarget = nil
        }
        if containerValues.contains(.supportedTimezones) {
            struct KeyVal0{struct Timezone{}}
            let supportedTimezonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Timezone>.CodingKeys.self, forKey: .supportedTimezones)
            if let supportedTimezonesWrappedContainer = supportedTimezonesWrappedContainer {
                let supportedTimezonesContainer = try supportedTimezonesWrappedContainer.decodeIfPresent([RdsClientTypes.Timezone].self, forKey: .member)
                var supportedTimezonesBuffer:[RdsClientTypes.Timezone]? = nil
                if let supportedTimezonesContainer = supportedTimezonesContainer {
                    supportedTimezonesBuffer = [RdsClientTypes.Timezone]()
                    for structureContainer0 in supportedTimezonesContainer {
                        supportedTimezonesBuffer?.append(structureContainer0)
                    }
                }
                supportedTimezones = supportedTimezonesBuffer
            } else {
                supportedTimezones = []
            }
        } else {
            supportedTimezones = nil
        }
        if containerValues.contains(.exportableLogTypes) {
            struct KeyVal0{struct member{}}
            let exportableLogTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .exportableLogTypes)
            if let exportableLogTypesWrappedContainer = exportableLogTypesWrappedContainer {
                let exportableLogTypesContainer = try exportableLogTypesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var exportableLogTypesBuffer:[Swift.String]? = nil
                if let exportableLogTypesContainer = exportableLogTypesContainer {
                    exportableLogTypesBuffer = [Swift.String]()
                    for stringContainer0 in exportableLogTypesContainer {
                        exportableLogTypesBuffer?.append(stringContainer0)
                    }
                }
                exportableLogTypes = exportableLogTypesBuffer
            } else {
                exportableLogTypes = []
            }
        } else {
            exportableLogTypes = nil
        }
        let supportsLogExportsToCloudwatchLogsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsLogExportsToCloudwatchLogs)
        supportsLogExportsToCloudwatchLogs = supportsLogExportsToCloudwatchLogsDecoded
        let supportsReadReplicaDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsReadReplica)
        supportsReadReplica = supportsReadReplicaDecoded
        if containerValues.contains(.supportedEngineModes) {
            struct KeyVal0{struct member{}}
            let supportedEngineModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedEngineModes)
            if let supportedEngineModesWrappedContainer = supportedEngineModesWrappedContainer {
                let supportedEngineModesContainer = try supportedEngineModesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedEngineModesBuffer:[Swift.String]? = nil
                if let supportedEngineModesContainer = supportedEngineModesContainer {
                    supportedEngineModesBuffer = [Swift.String]()
                    for stringContainer0 in supportedEngineModesContainer {
                        supportedEngineModesBuffer?.append(stringContainer0)
                    }
                }
                supportedEngineModes = supportedEngineModesBuffer
            } else {
                supportedEngineModes = []
            }
        } else {
            supportedEngineModes = nil
        }
        if containerValues.contains(.supportedFeatureNames) {
            struct KeyVal0{struct member{}}
            let supportedFeatureNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedFeatureNames)
            if let supportedFeatureNamesWrappedContainer = supportedFeatureNamesWrappedContainer {
                let supportedFeatureNamesContainer = try supportedFeatureNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedFeatureNamesBuffer:[Swift.String]? = nil
                if let supportedFeatureNamesContainer = supportedFeatureNamesContainer {
                    supportedFeatureNamesBuffer = [Swift.String]()
                    for stringContainer0 in supportedFeatureNamesContainer {
                        supportedFeatureNamesBuffer?.append(stringContainer0)
                    }
                }
                supportedFeatureNames = supportedFeatureNamesBuffer
            } else {
                supportedFeatureNames = []
            }
        } else {
            supportedFeatureNames = nil
        }
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let supportsParallelQueryDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsParallelQuery)
        supportsParallelQuery = supportsParallelQueryDecoded
        let supportsGlobalDatabasesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsGlobalDatabases)
        supportsGlobalDatabases = supportsGlobalDatabasesDecoded
        let majorEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorEngineVersion)
        majorEngineVersion = majorEngineVersionDecoded
        let databaseInstallationFilesS3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseInstallationFilesS3BucketName)
        databaseInstallationFilesS3BucketName = databaseInstallationFilesS3BucketNameDecoded
        let databaseInstallationFilesS3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseInstallationFilesS3Prefix)
        databaseInstallationFilesS3Prefix = databaseInstallationFilesS3PrefixDecoded
        let dBEngineVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBEngineVersionArn)
        dBEngineVersionArn = dBEngineVersionArnDecoded
        let kMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyId)
        kMSKeyId = kMSKeyIdDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        var createTimeBuffer:ClientRuntime.Date? = nil
        if let createTimeDecoded = createTimeDecoded {
            createTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createTimeDecoded, format: .dateTime)
        }
        createTime = createTimeBuffer
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagListBuffer:[RdsClientTypes.Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
    }
}

extension RdsClientTypes {
    /// This data type is used as a response element in the action DescribeDBEngineVersions.
    public struct DBEngineVersion: Swift.Equatable {
        /// The creation time of the DB engine version.
        public var createTime: ClientRuntime.Date?
        /// The description of the database engine.
        public var dBEngineDescription: Swift.String?
        /// The ARN of the custom engine version.
        public var dBEngineVersionArn: Swift.String?
        /// The description of the database engine version.
        public var dBEngineVersionDescription: Swift.String?
        /// The name of the DB parameter group family for the database engine.
        public var dBParameterGroupFamily: Swift.String?
        /// The name of the Amazon S3 bucket that contains your database installation files.
        public var databaseInstallationFilesS3BucketName: Swift.String?
        /// The Amazon S3 directory that contains the database installation files. If not specified, then no prefix is assumed.
        public var databaseInstallationFilesS3Prefix: Swift.String?
        /// The default character set for new instances of this engine version, if the CharacterSetName parameter of the CreateDBInstance API isn't specified.
        public var defaultCharacterSet: RdsClientTypes.CharacterSet?
        /// The name of the database engine.
        public var engine: Swift.String?
        /// The version number of the database engine.
        public var engineVersion: Swift.String?
        /// The types of logs that the database engine has available for export to CloudWatch Logs.
        public var exportableLogTypes: [Swift.String]?
        /// The Amazon Web Services KMS key identifier for an encrypted CEV. This parameter is required for RDS Custom, but optional for Amazon RDS.
        public var kMSKeyId: Swift.String?
        /// The major engine version of the CEV.
        public var majorEngineVersion: Swift.String?
        /// The status of the DB engine version, either available or deprecated.
        public var status: Swift.String?
        /// A list of the character sets supported by this engine for the CharacterSetName parameter of the CreateDBInstance operation.
        public var supportedCharacterSets: [RdsClientTypes.CharacterSet]?
        /// A list of the supported DB engine modes.
        public var supportedEngineModes: [Swift.String]?
        /// A list of features supported by the DB engine. The supported features vary by DB engine and DB engine version. To determine the supported features for a specific DB engine and DB engine version using the CLI, use the following command: aws rds describe-db-engine-versions --engine --engine-version  For example, to determine the supported features for RDS for PostgreSQL version 13.3 using the CLI, use the following command: aws rds describe-db-engine-versions --engine postgres --engine-version 13.3 The supported features are listed under SupportedFeatureNames in the output.
        public var supportedFeatureNames: [Swift.String]?
        /// A list of the character sets supported by the Oracle DB engine for the NcharCharacterSetName parameter of the CreateDBInstance operation.
        public var supportedNcharCharacterSets: [RdsClientTypes.CharacterSet]?
        /// A list of the time zones supported by this engine for the Timezone parameter of the CreateDBInstance action.
        public var supportedTimezones: [RdsClientTypes.Timezone]?
        /// A value that indicates whether you can use Aurora global databases with a specific DB engine version.
        public var supportsGlobalDatabases: Swift.Bool
        /// A value that indicates whether the engine version supports exporting the log types specified by ExportableLogTypes to CloudWatch Logs.
        public var supportsLogExportsToCloudwatchLogs: Swift.Bool
        /// A value that indicates whether you can use Aurora parallel query with a specific DB engine version.
        public var supportsParallelQuery: Swift.Bool
        /// Indicates whether the database engine version supports read replicas.
        public var supportsReadReplica: Swift.Bool
        /// A list of tags. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
        public var tagList: [RdsClientTypes.Tag]?
        /// A list of engine versions that this database engine version can be upgraded to.
        public var validUpgradeTarget: [RdsClientTypes.UpgradeTarget]?

        public init (
            createTime: ClientRuntime.Date? = nil,
            dBEngineDescription: Swift.String? = nil,
            dBEngineVersionArn: Swift.String? = nil,
            dBEngineVersionDescription: Swift.String? = nil,
            dBParameterGroupFamily: Swift.String? = nil,
            databaseInstallationFilesS3BucketName: Swift.String? = nil,
            databaseInstallationFilesS3Prefix: Swift.String? = nil,
            defaultCharacterSet: RdsClientTypes.CharacterSet? = nil,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            exportableLogTypes: [Swift.String]? = nil,
            kMSKeyId: Swift.String? = nil,
            majorEngineVersion: Swift.String? = nil,
            status: Swift.String? = nil,
            supportedCharacterSets: [RdsClientTypes.CharacterSet]? = nil,
            supportedEngineModes: [Swift.String]? = nil,
            supportedFeatureNames: [Swift.String]? = nil,
            supportedNcharCharacterSets: [RdsClientTypes.CharacterSet]? = nil,
            supportedTimezones: [RdsClientTypes.Timezone]? = nil,
            supportsGlobalDatabases: Swift.Bool = false,
            supportsLogExportsToCloudwatchLogs: Swift.Bool = false,
            supportsParallelQuery: Swift.Bool = false,
            supportsReadReplica: Swift.Bool = false,
            tagList: [RdsClientTypes.Tag]? = nil,
            validUpgradeTarget: [RdsClientTypes.UpgradeTarget]? = nil
        )
        {
            self.createTime = createTime
            self.dBEngineDescription = dBEngineDescription
            self.dBEngineVersionArn = dBEngineVersionArn
            self.dBEngineVersionDescription = dBEngineVersionDescription
            self.dBParameterGroupFamily = dBParameterGroupFamily
            self.databaseInstallationFilesS3BucketName = databaseInstallationFilesS3BucketName
            self.databaseInstallationFilesS3Prefix = databaseInstallationFilesS3Prefix
            self.defaultCharacterSet = defaultCharacterSet
            self.engine = engine
            self.engineVersion = engineVersion
            self.exportableLogTypes = exportableLogTypes
            self.kMSKeyId = kMSKeyId
            self.majorEngineVersion = majorEngineVersion
            self.status = status
            self.supportedCharacterSets = supportedCharacterSets
            self.supportedEngineModes = supportedEngineModes
            self.supportedFeatureNames = supportedFeatureNames
            self.supportedNcharCharacterSets = supportedNcharCharacterSets
            self.supportedTimezones = supportedTimezones
            self.supportsGlobalDatabases = supportsGlobalDatabases
            self.supportsLogExportsToCloudwatchLogs = supportsLogExportsToCloudwatchLogs
            self.supportsParallelQuery = supportsParallelQuery
            self.supportsReadReplica = supportsReadReplica
            self.tagList = tagList
            self.validUpgradeTarget = validUpgradeTarget
        }
    }

}

extension RdsClientTypes.DBInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activityStreamEngineNativeAuditFieldsIncluded = "ActivityStreamEngineNativeAuditFieldsIncluded"
        case activityStreamKinesisStreamName = "ActivityStreamKinesisStreamName"
        case activityStreamKmsKeyId = "ActivityStreamKmsKeyId"
        case activityStreamMode = "ActivityStreamMode"
        case activityStreamStatus = "ActivityStreamStatus"
        case allocatedStorage = "AllocatedStorage"
        case associatedRoles = "AssociatedRoles"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case automaticRestartTime = "AutomaticRestartTime"
        case automationMode = "AutomationMode"
        case availabilityZone = "AvailabilityZone"
        case awsBackupRecoveryPointArn = "AwsBackupRecoveryPointArn"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case backupTarget = "BackupTarget"
        case cACertificateIdentifier = "CACertificateIdentifier"
        case characterSetName = "CharacterSetName"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case customIamInstanceProfile = "CustomIamInstanceProfile"
        case customerOwnedIpEnabled = "CustomerOwnedIpEnabled"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBInstanceArn = "DBInstanceArn"
        case dBInstanceAutomatedBackupsReplications = "DBInstanceAutomatedBackupsReplications"
        case dBInstanceClass = "DBInstanceClass"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dBInstanceStatus = "DBInstanceStatus"
        case dBName = "DBName"
        case dBParameterGroups = "DBParameterGroups"
        case dBSecurityGroups = "DBSecurityGroups"
        case dBSubnetGroup = "DBSubnetGroup"
        case dbInstancePort = "DbInstancePort"
        case dbiResourceId = "DbiResourceId"
        case deletionProtection = "DeletionProtection"
        case domainMemberships = "DomainMemberships"
        case enabledCloudwatchLogsExports = "EnabledCloudwatchLogsExports"
        case endpoint = "Endpoint"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case enhancedMonitoringResourceArn = "EnhancedMonitoringResourceArn"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case instanceCreateTime = "InstanceCreateTime"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case latestRestorableTime = "LatestRestorableTime"
        case licenseModel = "LicenseModel"
        case listenerEndpoint = "ListenerEndpoint"
        case masterUsername = "MasterUsername"
        case maxAllocatedStorage = "MaxAllocatedStorage"
        case monitoringInterval = "MonitoringInterval"
        case monitoringRoleArn = "MonitoringRoleArn"
        case multiAZ = "MultiAZ"
        case ncharCharacterSetName = "NcharCharacterSetName"
        case optionGroupMemberships = "OptionGroupMemberships"
        case pendingModifiedValues = "PendingModifiedValues"
        case performanceInsightsEnabled = "PerformanceInsightsEnabled"
        case performanceInsightsKMSKeyId = "PerformanceInsightsKMSKeyId"
        case performanceInsightsRetentionPeriod = "PerformanceInsightsRetentionPeriod"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case processorFeatures = "ProcessorFeatures"
        case promotionTier = "PromotionTier"
        case publiclyAccessible = "PubliclyAccessible"
        case readReplicaDBClusterIdentifiers = "ReadReplicaDBClusterIdentifiers"
        case readReplicaDBInstanceIdentifiers = "ReadReplicaDBInstanceIdentifiers"
        case readReplicaSourceDBInstanceIdentifier = "ReadReplicaSourceDBInstanceIdentifier"
        case replicaMode = "ReplicaMode"
        case resumeFullAutomationModeTime = "ResumeFullAutomationModeTime"
        case secondaryAvailabilityZone = "SecondaryAvailabilityZone"
        case statusInfos = "StatusInfos"
        case storageEncrypted = "StorageEncrypted"
        case storageType = "StorageType"
        case tagList = "TagList"
        case tdeCredentialArn = "TdeCredentialArn"
        case timezone = "Timezone"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let activityStreamEngineNativeAuditFieldsIncluded = activityStreamEngineNativeAuditFieldsIncluded {
            try container.encode(activityStreamEngineNativeAuditFieldsIncluded, forKey: ClientRuntime.Key("ActivityStreamEngineNativeAuditFieldsIncluded"))
        }
        if let activityStreamKinesisStreamName = activityStreamKinesisStreamName {
            try container.encode(activityStreamKinesisStreamName, forKey: ClientRuntime.Key("ActivityStreamKinesisStreamName"))
        }
        if let activityStreamKmsKeyId = activityStreamKmsKeyId {
            try container.encode(activityStreamKmsKeyId, forKey: ClientRuntime.Key("ActivityStreamKmsKeyId"))
        }
        if let activityStreamMode = activityStreamMode {
            try container.encode(activityStreamMode, forKey: ClientRuntime.Key("ActivityStreamMode"))
        }
        if let activityStreamStatus = activityStreamStatus {
            try container.encode(activityStreamStatus, forKey: ClientRuntime.Key("ActivityStreamStatus"))
        }
        if allocatedStorage != 0 {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if let associatedRoles = associatedRoles {
            var associatedRolesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AssociatedRoles"))
            for (index0, dbinstancerole0) in associatedRoles.enumerated() {
                try associatedRolesContainer.encode(dbinstancerole0, forKey: ClientRuntime.Key("DBInstanceRole.\(index0.advanced(by: 1))"))
            }
        }
        if autoMinorVersionUpgrade != false {
            try container.encode(autoMinorVersionUpgrade, forKey: ClientRuntime.Key("AutoMinorVersionUpgrade"))
        }
        if let automaticRestartTime = automaticRestartTime {
            try container.encode(ClientRuntime.TimestampWrapper(automaticRestartTime, format: .dateTime), forKey: ClientRuntime.Key("automaticRestartTime"))
        }
        if let automationMode = automationMode {
            try container.encode(automationMode, forKey: ClientRuntime.Key("AutomationMode"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let awsBackupRecoveryPointArn = awsBackupRecoveryPointArn {
            try container.encode(awsBackupRecoveryPointArn, forKey: ClientRuntime.Key("AwsBackupRecoveryPointArn"))
        }
        if backupRetentionPeriod != 0 {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let backupTarget = backupTarget {
            try container.encode(backupTarget, forKey: ClientRuntime.Key("BackupTarget"))
        }
        if let cACertificateIdentifier = cACertificateIdentifier {
            try container.encode(cACertificateIdentifier, forKey: ClientRuntime.Key("CACertificateIdentifier"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: ClientRuntime.Key("CharacterSetName"))
        }
        if copyTagsToSnapshot != false {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let customIamInstanceProfile = customIamInstanceProfile {
            try container.encode(customIamInstanceProfile, forKey: ClientRuntime.Key("CustomIamInstanceProfile"))
        }
        if let customerOwnedIpEnabled = customerOwnedIpEnabled {
            try container.encode(customerOwnedIpEnabled, forKey: ClientRuntime.Key("CustomerOwnedIpEnabled"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBInstanceArn = dBInstanceArn {
            try container.encode(dBInstanceArn, forKey: ClientRuntime.Key("DBInstanceArn"))
        }
        if let dBInstanceAutomatedBackupsReplications = dBInstanceAutomatedBackupsReplications {
            var dBInstanceAutomatedBackupsReplicationsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBInstanceAutomatedBackupsReplications"))
            for (index0, dbinstanceautomatedbackupsreplication0) in dBInstanceAutomatedBackupsReplications.enumerated() {
                try dBInstanceAutomatedBackupsReplicationsContainer.encode(dbinstanceautomatedbackupsreplication0, forKey: ClientRuntime.Key("DBInstanceAutomatedBackupsReplication.\(index0.advanced(by: 1))"))
            }
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBInstanceStatus = dBInstanceStatus {
            try container.encode(dBInstanceStatus, forKey: ClientRuntime.Key("DBInstanceStatus"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: ClientRuntime.Key("DBName"))
        }
        if let dBParameterGroups = dBParameterGroups {
            var dBParameterGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBParameterGroups"))
            for (index0, dbparametergroupstatus0) in dBParameterGroups.enumerated() {
                try dBParameterGroupsContainer.encode(dbparametergroupstatus0, forKey: ClientRuntime.Key("DBParameterGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSecurityGroups = dBSecurityGroups {
            var dBSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBSecurityGroups"))
            for (index0, dbsecuritygroupmembership0) in dBSecurityGroups.enumerated() {
                try dBSecurityGroupsContainer.encode(dbsecuritygroupmembership0, forKey: ClientRuntime.Key("DBSecurityGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSubnetGroup = dBSubnetGroup {
            try container.encode(dBSubnetGroup, forKey: ClientRuntime.Key("DBSubnetGroup"))
        }
        if dbInstancePort != 0 {
            try container.encode(dbInstancePort, forKey: ClientRuntime.Key("DbInstancePort"))
        }
        if let dbiResourceId = dbiResourceId {
            try container.encode(dbiResourceId, forKey: ClientRuntime.Key("DbiResourceId"))
        }
        if deletionProtection != false {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domainMemberships = domainMemberships {
            var domainMembershipsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DomainMemberships"))
            for (index0, domainmembership0) in domainMemberships.enumerated() {
                try domainMembershipsContainer.encode(domainmembership0, forKey: ClientRuntime.Key("DomainMembership.\(index0.advanced(by: 1))"))
            }
        }
        if let enabledCloudwatchLogsExports = enabledCloudwatchLogsExports {
            var enabledCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnabledCloudwatchLogsExports"))
            for (index0, string0) in enabledCloudwatchLogsExports.enumerated() {
                try enabledCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let enhancedMonitoringResourceArn = enhancedMonitoringResourceArn {
            try container.encode(enhancedMonitoringResourceArn, forKey: ClientRuntime.Key("EnhancedMonitoringResourceArn"))
        }
        if iAMDatabaseAuthenticationEnabled != false {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: ClientRuntime.Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let instanceCreateTime = instanceCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(instanceCreateTime, format: .dateTime), forKey: ClientRuntime.Key("instanceCreateTime"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let latestRestorableTime = latestRestorableTime {
            try container.encode(ClientRuntime.TimestampWrapper(latestRestorableTime, format: .dateTime), forKey: ClientRuntime.Key("latestRestorableTime"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let listenerEndpoint = listenerEndpoint {
            try container.encode(listenerEndpoint, forKey: ClientRuntime.Key("ListenerEndpoint"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let maxAllocatedStorage = maxAllocatedStorage {
            try container.encode(maxAllocatedStorage, forKey: ClientRuntime.Key("MaxAllocatedStorage"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: ClientRuntime.Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: ClientRuntime.Key("MonitoringRoleArn"))
        }
        if multiAZ != false {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let ncharCharacterSetName = ncharCharacterSetName {
            try container.encode(ncharCharacterSetName, forKey: ClientRuntime.Key("NcharCharacterSetName"))
        }
        if let optionGroupMemberships = optionGroupMemberships {
            var optionGroupMembershipsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OptionGroupMemberships"))
            for (index0, optiongroupmembership0) in optionGroupMemberships.enumerated() {
                try optionGroupMembershipsContainer.encode(optiongroupmembership0, forKey: ClientRuntime.Key("OptionGroupMembership.\(index0.advanced(by: 1))"))
            }
        }
        if let pendingModifiedValues = pendingModifiedValues {
            try container.encode(pendingModifiedValues, forKey: ClientRuntime.Key("PendingModifiedValues"))
        }
        if let performanceInsightsEnabled = performanceInsightsEnabled {
            try container.encode(performanceInsightsEnabled, forKey: ClientRuntime.Key("PerformanceInsightsEnabled"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: ClientRuntime.Key("PerformanceInsightsKMSKeyId"))
        }
        if let performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod {
            try container.encode(performanceInsightsRetentionPeriod, forKey: ClientRuntime.Key("PerformanceInsightsRetentionPeriod"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: ClientRuntime.Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let promotionTier = promotionTier {
            try container.encode(promotionTier, forKey: ClientRuntime.Key("PromotionTier"))
        }
        if publiclyAccessible != false {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiers {
            var readReplicaDBClusterIdentifiersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ReadReplicaDBClusterIdentifiers"))
            for (index0, string0) in readReplicaDBClusterIdentifiers.enumerated() {
                try readReplicaDBClusterIdentifiersContainer.encode(string0, forKey: ClientRuntime.Key("ReadReplicaDBClusterIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiers {
            var readReplicaDBInstanceIdentifiersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ReadReplicaDBInstanceIdentifiers"))
            for (index0, string0) in readReplicaDBInstanceIdentifiers.enumerated() {
                try readReplicaDBInstanceIdentifiersContainer.encode(string0, forKey: ClientRuntime.Key("ReadReplicaDBInstanceIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifier {
            try container.encode(readReplicaSourceDBInstanceIdentifier, forKey: ClientRuntime.Key("ReadReplicaSourceDBInstanceIdentifier"))
        }
        if let replicaMode = replicaMode {
            try container.encode(replicaMode, forKey: ClientRuntime.Key("ReplicaMode"))
        }
        if let resumeFullAutomationModeTime = resumeFullAutomationModeTime {
            try container.encode(ClientRuntime.TimestampWrapper(resumeFullAutomationModeTime, format: .dateTime), forKey: ClientRuntime.Key("resumeFullAutomationModeTime"))
        }
        if let secondaryAvailabilityZone = secondaryAvailabilityZone {
            try container.encode(secondaryAvailabilityZone, forKey: ClientRuntime.Key("SecondaryAvailabilityZone"))
        }
        if let statusInfos = statusInfos {
            var statusInfosContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("StatusInfos"))
            for (index0, dbinstancestatusinfo0) in statusInfos.enumerated() {
                try statusInfosContainer.encode(dbinstancestatusinfo0, forKey: ClientRuntime.Key("DBInstanceStatusInfo.\(index0.advanced(by: 1))"))
            }
        }
        if storageEncrypted != false {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tagList = tagList {
            var tagListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagList"))
            for (index0, tag0) in tagList.enumerated() {
                try tagListContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: ClientRuntime.Key("TdeCredentialArn"))
        }
        if let timezone = timezone {
            try container.encode(timezone, forKey: ClientRuntime.Key("Timezone"))
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroups"))
            for (index0, vpcsecuritygroupmembership0) in vpcSecurityGroups.enumerated() {
                try vpcSecurityGroupsContainer.encode(vpcsecuritygroupmembership0, forKey: ClientRuntime.Key("VpcSecurityGroupMembership.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let dBInstanceStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceStatus)
        dBInstanceStatus = dBInstanceStatusDecoded
        let automaticRestartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automaticRestartTime)
        var automaticRestartTimeBuffer:ClientRuntime.Date? = nil
        if let automaticRestartTimeDecoded = automaticRestartTimeDecoded {
            automaticRestartTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(automaticRestartTimeDecoded, format: .dateTime)
        }
        automaticRestartTime = automaticRestartTimeBuffer
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let dBNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBName)
        dBName = dBNameDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(RdsClientTypes.Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let allocatedStorageDecoded = try containerValues.decode(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let instanceCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceCreateTime)
        var instanceCreateTimeBuffer:ClientRuntime.Date? = nil
        if let instanceCreateTimeDecoded = instanceCreateTimeDecoded {
            instanceCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(instanceCreateTimeDecoded, format: .dateTime)
        }
        instanceCreateTime = instanceCreateTimeBuffer
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let backupRetentionPeriodDecoded = try containerValues.decode(Swift.Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        if containerValues.contains(.dBSecurityGroups) {
            struct KeyVal0{struct DBSecurityGroup{}}
            let dBSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSecurityGroup>.CodingKeys.self, forKey: .dBSecurityGroups)
            if let dBSecurityGroupsWrappedContainer = dBSecurityGroupsWrappedContainer {
                let dBSecurityGroupsContainer = try dBSecurityGroupsWrappedContainer.decodeIfPresent([RdsClientTypes.DBSecurityGroupMembership].self, forKey: .member)
                var dBSecurityGroupsBuffer:[RdsClientTypes.DBSecurityGroupMembership]? = nil
                if let dBSecurityGroupsContainer = dBSecurityGroupsContainer {
                    dBSecurityGroupsBuffer = [RdsClientTypes.DBSecurityGroupMembership]()
                    for structureContainer0 in dBSecurityGroupsContainer {
                        dBSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBSecurityGroups = dBSecurityGroupsBuffer
            } else {
                dBSecurityGroups = []
            }
        } else {
            dBSecurityGroups = nil
        }
        if containerValues.contains(.vpcSecurityGroups) {
            struct KeyVal0{struct VpcSecurityGroupMembership{}}
            let vpcSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupMembership>.CodingKeys.self, forKey: .vpcSecurityGroups)
            if let vpcSecurityGroupsWrappedContainer = vpcSecurityGroupsWrappedContainer {
                let vpcSecurityGroupsContainer = try vpcSecurityGroupsWrappedContainer.decodeIfPresent([RdsClientTypes.VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupsBuffer:[RdsClientTypes.VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
                    vpcSecurityGroupsBuffer = [RdsClientTypes.VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupsContainer {
                        vpcSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroups = vpcSecurityGroupsBuffer
            } else {
                vpcSecurityGroups = []
            }
        } else {
            vpcSecurityGroups = nil
        }
        if containerValues.contains(.dBParameterGroups) {
            struct KeyVal0{struct DBParameterGroup{}}
            let dBParameterGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBParameterGroup>.CodingKeys.self, forKey: .dBParameterGroups)
            if let dBParameterGroupsWrappedContainer = dBParameterGroupsWrappedContainer {
                let dBParameterGroupsContainer = try dBParameterGroupsWrappedContainer.decodeIfPresent([RdsClientTypes.DBParameterGroupStatus].self, forKey: .member)
                var dBParameterGroupsBuffer:[RdsClientTypes.DBParameterGroupStatus]? = nil
                if let dBParameterGroupsContainer = dBParameterGroupsContainer {
                    dBParameterGroupsBuffer = [RdsClientTypes.DBParameterGroupStatus]()
                    for structureContainer0 in dBParameterGroupsContainer {
                        dBParameterGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBParameterGroups = dBParameterGroupsBuffer
            } else {
                dBParameterGroups = []
            }
        } else {
            dBParameterGroups = nil
        }
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let dBSubnetGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSubnetGroup.self, forKey: .dBSubnetGroup)
        dBSubnetGroup = dBSubnetGroupDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let pendingModifiedValuesDecoded = try containerValues.decodeIfPresent(RdsClientTypes.PendingModifiedValues.self, forKey: .pendingModifiedValues)
        pendingModifiedValues = pendingModifiedValuesDecoded
        let latestRestorableTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestRestorableTime)
        var latestRestorableTimeBuffer:ClientRuntime.Date? = nil
        if let latestRestorableTimeDecoded = latestRestorableTimeDecoded {
            latestRestorableTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(latestRestorableTimeDecoded, format: .dateTime)
        }
        latestRestorableTime = latestRestorableTimeBuffer
        let multiAZDecoded = try containerValues.decode(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let readReplicaSourceDBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readReplicaSourceDBInstanceIdentifier)
        readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifierDecoded
        if containerValues.contains(.readReplicaDBInstanceIdentifiers) {
            struct KeyVal0{struct ReadReplicaDBInstanceIdentifier{}}
            let readReplicaDBInstanceIdentifiersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReadReplicaDBInstanceIdentifier>.CodingKeys.self, forKey: .readReplicaDBInstanceIdentifiers)
            if let readReplicaDBInstanceIdentifiersWrappedContainer = readReplicaDBInstanceIdentifiersWrappedContainer {
                let readReplicaDBInstanceIdentifiersContainer = try readReplicaDBInstanceIdentifiersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var readReplicaDBInstanceIdentifiersBuffer:[Swift.String]? = nil
                if let readReplicaDBInstanceIdentifiersContainer = readReplicaDBInstanceIdentifiersContainer {
                    readReplicaDBInstanceIdentifiersBuffer = [Swift.String]()
                    for stringContainer0 in readReplicaDBInstanceIdentifiersContainer {
                        readReplicaDBInstanceIdentifiersBuffer?.append(stringContainer0)
                    }
                }
                readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiersBuffer
            } else {
                readReplicaDBInstanceIdentifiers = []
            }
        } else {
            readReplicaDBInstanceIdentifiers = nil
        }
        if containerValues.contains(.readReplicaDBClusterIdentifiers) {
            struct KeyVal0{struct ReadReplicaDBClusterIdentifier{}}
            let readReplicaDBClusterIdentifiersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReadReplicaDBClusterIdentifier>.CodingKeys.self, forKey: .readReplicaDBClusterIdentifiers)
            if let readReplicaDBClusterIdentifiersWrappedContainer = readReplicaDBClusterIdentifiersWrappedContainer {
                let readReplicaDBClusterIdentifiersContainer = try readReplicaDBClusterIdentifiersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var readReplicaDBClusterIdentifiersBuffer:[Swift.String]? = nil
                if let readReplicaDBClusterIdentifiersContainer = readReplicaDBClusterIdentifiersContainer {
                    readReplicaDBClusterIdentifiersBuffer = [Swift.String]()
                    for stringContainer0 in readReplicaDBClusterIdentifiersContainer {
                        readReplicaDBClusterIdentifiersBuffer?.append(stringContainer0)
                    }
                }
                readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiersBuffer
            } else {
                readReplicaDBClusterIdentifiers = []
            }
        } else {
            readReplicaDBClusterIdentifiers = nil
        }
        let replicaModeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ReplicaMode.self, forKey: .replicaMode)
        replicaMode = replicaModeDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        if containerValues.contains(.optionGroupMemberships) {
            struct KeyVal0{struct OptionGroupMembership{}}
            let optionGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionGroupMembership>.CodingKeys.self, forKey: .optionGroupMemberships)
            if let optionGroupMembershipsWrappedContainer = optionGroupMembershipsWrappedContainer {
                let optionGroupMembershipsContainer = try optionGroupMembershipsWrappedContainer.decodeIfPresent([RdsClientTypes.OptionGroupMembership].self, forKey: .member)
                var optionGroupMembershipsBuffer:[RdsClientTypes.OptionGroupMembership]? = nil
                if let optionGroupMembershipsContainer = optionGroupMembershipsContainer {
                    optionGroupMembershipsBuffer = [RdsClientTypes.OptionGroupMembership]()
                    for structureContainer0 in optionGroupMembershipsContainer {
                        optionGroupMembershipsBuffer?.append(structureContainer0)
                    }
                }
                optionGroupMemberships = optionGroupMembershipsBuffer
            } else {
                optionGroupMemberships = []
            }
        } else {
            optionGroupMemberships = nil
        }
        let characterSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .characterSetName)
        characterSetName = characterSetNameDecoded
        let ncharCharacterSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ncharCharacterSetName)
        ncharCharacterSetName = ncharCharacterSetNameDecoded
        let secondaryAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secondaryAvailabilityZone)
        secondaryAvailabilityZone = secondaryAvailabilityZoneDecoded
        let publiclyAccessibleDecoded = try containerValues.decode(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        if containerValues.contains(.statusInfos) {
            struct KeyVal0{struct DBInstanceStatusInfo{}}
            let statusInfosWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBInstanceStatusInfo>.CodingKeys.self, forKey: .statusInfos)
            if let statusInfosWrappedContainer = statusInfosWrappedContainer {
                let statusInfosContainer = try statusInfosWrappedContainer.decodeIfPresent([RdsClientTypes.DBInstanceStatusInfo].self, forKey: .member)
                var statusInfosBuffer:[RdsClientTypes.DBInstanceStatusInfo]? = nil
                if let statusInfosContainer = statusInfosContainer {
                    statusInfosBuffer = [RdsClientTypes.DBInstanceStatusInfo]()
                    for structureContainer0 in statusInfosContainer {
                        statusInfosBuffer?.append(structureContainer0)
                    }
                }
                statusInfos = statusInfosBuffer
            } else {
                statusInfos = []
            }
        } else {
            statusInfos = nil
        }
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let tdeCredentialArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tdeCredentialArn)
        tdeCredentialArn = tdeCredentialArnDecoded
        let dbInstancePortDecoded = try containerValues.decode(Swift.Int.self, forKey: .dbInstancePort)
        dbInstancePort = dbInstancePortDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let storageEncryptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dbiResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbiResourceId)
        dbiResourceId = dbiResourceIdDecoded
        let cACertificateIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cACertificateIdentifier)
        cACertificateIdentifier = cACertificateIdentifierDecoded
        if containerValues.contains(.domainMemberships) {
            struct KeyVal0{struct DomainMembership{}}
            let domainMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DomainMembership>.CodingKeys.self, forKey: .domainMemberships)
            if let domainMembershipsWrappedContainer = domainMembershipsWrappedContainer {
                let domainMembershipsContainer = try domainMembershipsWrappedContainer.decodeIfPresent([RdsClientTypes.DomainMembership].self, forKey: .member)
                var domainMembershipsBuffer:[RdsClientTypes.DomainMembership]? = nil
                if let domainMembershipsContainer = domainMembershipsContainer {
                    domainMembershipsBuffer = [RdsClientTypes.DomainMembership]()
                    for structureContainer0 in domainMembershipsContainer {
                        domainMembershipsBuffer?.append(structureContainer0)
                    }
                }
                domainMemberships = domainMembershipsBuffer
            } else {
                domainMemberships = []
            }
        } else {
            domainMemberships = nil
        }
        let copyTagsToSnapshotDecoded = try containerValues.decode(Swift.Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let monitoringIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monitoringInterval)
        monitoringInterval = monitoringIntervalDecoded
        let enhancedMonitoringResourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .enhancedMonitoringResourceArn)
        enhancedMonitoringResourceArn = enhancedMonitoringResourceArnDecoded
        let monitoringRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitoringRoleArn)
        monitoringRoleArn = monitoringRoleArnDecoded
        let promotionTierDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .promotionTier)
        promotionTier = promotionTierDecoded
        let dBInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceArn)
        dBInstanceArn = dBInstanceArnDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        let performanceInsightsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performanceInsightsEnabled)
        performanceInsightsEnabled = performanceInsightsEnabledDecoded
        let performanceInsightsKMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .performanceInsightsKMSKeyId)
        performanceInsightsKMSKeyId = performanceInsightsKMSKeyIdDecoded
        let performanceInsightsRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .performanceInsightsRetentionPeriod)
        performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriodDecoded
        if containerValues.contains(.enabledCloudwatchLogsExports) {
            struct KeyVal0{struct member{}}
            let enabledCloudwatchLogsExportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enabledCloudwatchLogsExports)
            if let enabledCloudwatchLogsExportsWrappedContainer = enabledCloudwatchLogsExportsWrappedContainer {
                let enabledCloudwatchLogsExportsContainer = try enabledCloudwatchLogsExportsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var enabledCloudwatchLogsExportsBuffer:[Swift.String]? = nil
                if let enabledCloudwatchLogsExportsContainer = enabledCloudwatchLogsExportsContainer {
                    enabledCloudwatchLogsExportsBuffer = [Swift.String]()
                    for stringContainer0 in enabledCloudwatchLogsExportsContainer {
                        enabledCloudwatchLogsExportsBuffer?.append(stringContainer0)
                    }
                }
                enabledCloudwatchLogsExports = enabledCloudwatchLogsExportsBuffer
            } else {
                enabledCloudwatchLogsExports = []
            }
        } else {
            enabledCloudwatchLogsExports = nil
        }
        if containerValues.contains(.processorFeatures) {
            struct KeyVal0{struct ProcessorFeature{}}
            let processorFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ProcessorFeature>.CodingKeys.self, forKey: .processorFeatures)
            if let processorFeaturesWrappedContainer = processorFeaturesWrappedContainer {
                let processorFeaturesContainer = try processorFeaturesWrappedContainer.decodeIfPresent([RdsClientTypes.ProcessorFeature].self, forKey: .member)
                var processorFeaturesBuffer:[RdsClientTypes.ProcessorFeature]? = nil
                if let processorFeaturesContainer = processorFeaturesContainer {
                    processorFeaturesBuffer = [RdsClientTypes.ProcessorFeature]()
                    for structureContainer0 in processorFeaturesContainer {
                        processorFeaturesBuffer?.append(structureContainer0)
                    }
                }
                processorFeatures = processorFeaturesBuffer
            } else {
                processorFeatures = []
            }
        } else {
            processorFeatures = nil
        }
        let deletionProtectionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        if containerValues.contains(.associatedRoles) {
            struct KeyVal0{struct DBInstanceRole{}}
            let associatedRolesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBInstanceRole>.CodingKeys.self, forKey: .associatedRoles)
            if let associatedRolesWrappedContainer = associatedRolesWrappedContainer {
                let associatedRolesContainer = try associatedRolesWrappedContainer.decodeIfPresent([RdsClientTypes.DBInstanceRole].self, forKey: .member)
                var associatedRolesBuffer:[RdsClientTypes.DBInstanceRole]? = nil
                if let associatedRolesContainer = associatedRolesContainer {
                    associatedRolesBuffer = [RdsClientTypes.DBInstanceRole]()
                    for structureContainer0 in associatedRolesContainer {
                        associatedRolesBuffer?.append(structureContainer0)
                    }
                }
                associatedRoles = associatedRolesBuffer
            } else {
                associatedRoles = []
            }
        } else {
            associatedRoles = nil
        }
        let listenerEndpointDecoded = try containerValues.decodeIfPresent(RdsClientTypes.Endpoint.self, forKey: .listenerEndpoint)
        listenerEndpoint = listenerEndpointDecoded
        let maxAllocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAllocatedStorage)
        maxAllocatedStorage = maxAllocatedStorageDecoded
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagListBuffer:[RdsClientTypes.Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
        if containerValues.contains(.dBInstanceAutomatedBackupsReplications) {
            struct KeyVal0{struct DBInstanceAutomatedBackupsReplication{}}
            let dBInstanceAutomatedBackupsReplicationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBInstanceAutomatedBackupsReplication>.CodingKeys.self, forKey: .dBInstanceAutomatedBackupsReplications)
            if let dBInstanceAutomatedBackupsReplicationsWrappedContainer = dBInstanceAutomatedBackupsReplicationsWrappedContainer {
                let dBInstanceAutomatedBackupsReplicationsContainer = try dBInstanceAutomatedBackupsReplicationsWrappedContainer.decodeIfPresent([RdsClientTypes.DBInstanceAutomatedBackupsReplication].self, forKey: .member)
                var dBInstanceAutomatedBackupsReplicationsBuffer:[RdsClientTypes.DBInstanceAutomatedBackupsReplication]? = nil
                if let dBInstanceAutomatedBackupsReplicationsContainer = dBInstanceAutomatedBackupsReplicationsContainer {
                    dBInstanceAutomatedBackupsReplicationsBuffer = [RdsClientTypes.DBInstanceAutomatedBackupsReplication]()
                    for structureContainer0 in dBInstanceAutomatedBackupsReplicationsContainer {
                        dBInstanceAutomatedBackupsReplicationsBuffer?.append(structureContainer0)
                    }
                }
                dBInstanceAutomatedBackupsReplications = dBInstanceAutomatedBackupsReplicationsBuffer
            } else {
                dBInstanceAutomatedBackupsReplications = []
            }
        } else {
            dBInstanceAutomatedBackupsReplications = nil
        }
        let customerOwnedIpEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .customerOwnedIpEnabled)
        customerOwnedIpEnabled = customerOwnedIpEnabledDecoded
        let awsBackupRecoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsBackupRecoveryPointArn)
        awsBackupRecoveryPointArn = awsBackupRecoveryPointArnDecoded
        let activityStreamStatusDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ActivityStreamStatus.self, forKey: .activityStreamStatus)
        activityStreamStatus = activityStreamStatusDecoded
        let activityStreamKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activityStreamKmsKeyId)
        activityStreamKmsKeyId = activityStreamKmsKeyIdDecoded
        let activityStreamKinesisStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activityStreamKinesisStreamName)
        activityStreamKinesisStreamName = activityStreamKinesisStreamNameDecoded
        let activityStreamModeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ActivityStreamMode.self, forKey: .activityStreamMode)
        activityStreamMode = activityStreamModeDecoded
        let activityStreamEngineNativeAuditFieldsIncludedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .activityStreamEngineNativeAuditFieldsIncluded)
        activityStreamEngineNativeAuditFieldsIncluded = activityStreamEngineNativeAuditFieldsIncludedDecoded
        let automationModeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.AutomationMode.self, forKey: .automationMode)
        automationMode = automationModeDecoded
        let resumeFullAutomationModeTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resumeFullAutomationModeTime)
        var resumeFullAutomationModeTimeBuffer:ClientRuntime.Date? = nil
        if let resumeFullAutomationModeTimeDecoded = resumeFullAutomationModeTimeDecoded {
            resumeFullAutomationModeTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(resumeFullAutomationModeTimeDecoded, format: .dateTime)
        }
        resumeFullAutomationModeTime = resumeFullAutomationModeTimeBuffer
        let customIamInstanceProfileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customIamInstanceProfile)
        customIamInstanceProfile = customIamInstanceProfileDecoded
        let backupTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupTarget)
        backupTarget = backupTargetDecoded
    }
}

extension RdsClientTypes {
    /// Contains the details of an Amazon RDS DB instance. This data type is used as a response element in the operations CreateDBInstance, CreateDBInstanceReadReplica, DeleteDBInstance, DescribeDBInstances, ModifyDBInstance, PromoteReadReplica, RebootDBInstance, RestoreDBInstanceFromDBSnapshot, RestoreDBInstanceFromS3, RestoreDBInstanceToPointInTime, StartDBInstance, and StopDBInstance.
    public struct DBInstance: Swift.Equatable {
        /// Indicates whether engine-native audit fields are included in the database activity stream.
        public var activityStreamEngineNativeAuditFieldsIncluded: Swift.Bool?
        /// The name of the Amazon Kinesis data stream used for the database activity stream.
        public var activityStreamKinesisStreamName: Swift.String?
        /// The Amazon Web Services KMS key identifier used for encrypting messages in the database activity stream. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        public var activityStreamKmsKeyId: Swift.String?
        /// The mode of the database activity stream. Database events such as a change or access generate an activity stream event. RDS for Oracle always handles these events asynchronously.
        public var activityStreamMode: RdsClientTypes.ActivityStreamMode?
        /// The status of the database activity stream.
        public var activityStreamStatus: RdsClientTypes.ActivityStreamStatus?
        /// Specifies the allocated storage size specified in gibibytes (GiB).
        public var allocatedStorage: Swift.Int
        /// The Amazon Web Services Identity and Access Management (IAM) roles associated with the DB instance.
        public var associatedRoles: [RdsClientTypes.DBInstanceRole]?
        /// A value that indicates that minor version patches are applied automatically.
        public var autoMinorVersionUpgrade: Swift.Bool
        /// The time when a stopped DB instance is restarted automatically.
        public var automaticRestartTime: ClientRuntime.Date?
        /// The automation mode of the RDS Custom DB instance: full or all paused. If full, the DB instance automates monitoring and instance recovery. If all paused, the instance pauses automation for the duration set by --resume-full-automation-mode-minutes.
        public var automationMode: RdsClientTypes.AutomationMode?
        /// Specifies the name of the Availability Zone the DB instance is located in.
        public var availabilityZone: Swift.String?
        /// The Amazon Resource Name (ARN) of the recovery point in Amazon Web Services Backup.
        public var awsBackupRecoveryPointArn: Swift.String?
        /// Specifies the number of days for which automatic DB snapshots are retained.
        public var backupRetentionPeriod: Swift.Int
        /// Specifies where automated backups and manual snapshots are stored: Amazon Web Services Outposts or the Amazon Web Services Region.
        public var backupTarget: Swift.String?
        /// The identifier of the CA certificate for this DB instance.
        public var cACertificateIdentifier: Swift.String?
        /// If present, specifies the name of the character set that this instance is associated with.
        public var characterSetName: Swift.String?
        /// Specifies whether tags are copied from the DB instance to snapshots of the DB instance. Amazon Aurora Not applicable. Copying tags to snapshots is managed by the DB cluster. Setting this value for an Aurora DB instance has no effect on the DB cluster setting. For more information, see DBCluster.
        public var copyTagsToSnapshot: Swift.Bool
        /// The instance profile associated with the underlying Amazon EC2 instance of an RDS Custom DB instance. The instance profile must meet the following requirements:
        ///
        /// * The profile must exist in your account.
        ///
        /// * The profile must have an IAM role that Amazon EC2 has permissions to assume.
        ///
        /// * The instance profile name and the associated IAM role name must start with the prefix AWSRDSCustom.
        ///
        ///
        /// For the list of permissions required for the IAM role, see [ Configure IAM and your VPC](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/custom-setup-orcl.html#custom-setup-orcl.iam-vpc) in the Amazon Relational Database Service User Guide.
        public var customIamInstanceProfile: Swift.String?
        /// Specifies whether a customer-owned IP address (CoIP) is enabled for an RDS on Outposts DB instance. A CoIP provides local or external connectivity to resources in your Outpost subnets through your on-premises network. For some use cases, a CoIP can provide lower latency for connections to the DB instance from outside of its virtual private cloud (VPC) on your local network. For more information about RDS on Outposts, see [Working with Amazon RDS on Amazon Web Services Outposts](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html) in the Amazon RDS User Guide. For more information about CoIPs, see [Customer-owned IP addresses](https://docs.aws.amazon.com/outposts/latest/userguide/outposts-networking-components.html#ip-addressing) in the Amazon Web Services Outposts User Guide.
        public var customerOwnedIpEnabled: Swift.Bool?
        /// If the DB instance is a member of a DB cluster, contains the name of the DB cluster that the DB instance is a member of.
        public var dBClusterIdentifier: Swift.String?
        /// The Amazon Resource Name (ARN) for the DB instance.
        public var dBInstanceArn: Swift.String?
        /// The list of replicated automated backups associated with the DB instance.
        public var dBInstanceAutomatedBackupsReplications: [RdsClientTypes.DBInstanceAutomatedBackupsReplication]?
        /// Contains the name of the compute and memory capacity class of the DB instance.
        public var dBInstanceClass: Swift.String?
        /// Contains a user-supplied database identifier. This identifier is the unique key that identifies a DB instance.
        public var dBInstanceIdentifier: Swift.String?
        /// Specifies the current state of this database. For information about DB instance statuses, see [Viewing DB instance status](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/accessing-monitoring.html#Overview.DBInstance.Status) in the Amazon RDS User Guide.
        public var dBInstanceStatus: Swift.String?
        /// The meaning of this parameter differs according to the database engine you use. MySQL, MariaDB, SQL Server, PostgreSQL Contains the name of the initial database of this instance that was provided at create time, if one was specified when the DB instance was created. This same name is returned for the life of the DB instance. Type: String Oracle Contains the Oracle System ID (SID) of the created DB instance. Not shown when the returned parameters do not apply to an Oracle DB instance.
        public var dBName: Swift.String?
        /// Provides the list of DB parameter groups applied to this DB instance.
        public var dBParameterGroups: [RdsClientTypes.DBParameterGroupStatus]?
        /// A list of DB security group elements containing DBSecurityGroup.Name and DBSecurityGroup.Status subelements.
        public var dBSecurityGroups: [RdsClientTypes.DBSecurityGroupMembership]?
        /// Specifies information on the subnet group associated with the DB instance, including the name, description, and subnets in the subnet group.
        public var dBSubnetGroup: RdsClientTypes.DBSubnetGroup?
        /// Specifies the port that the DB instance listens on. If the DB instance is part of a DB cluster, this can be a different port than the DB cluster port.
        public var dbInstancePort: Swift.Int
        /// The Amazon Web Services Region-unique, immutable identifier for the DB instance. This identifier is found in Amazon Web Services CloudTrail log entries whenever the Amazon Web Services KMS key for the DB instance is accessed.
        public var dbiResourceId: Swift.String?
        /// Indicates if the DB instance has deletion protection enabled. The database can't be deleted when deletion protection is enabled. For more information, see [ Deleting a DB Instance](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html).
        public var deletionProtection: Swift.Bool
        /// The Active Directory Domain membership records associated with the DB instance.
        public var domainMemberships: [RdsClientTypes.DomainMembership]?
        /// A list of log types that this DB instance is configured to export to CloudWatch Logs. Log types vary by DB engine. For information about the log types for each DB engine, see [Amazon RDS Database Log Files](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html) in the Amazon RDS User Guide.
        public var enabledCloudwatchLogsExports: [Swift.String]?
        /// Specifies the connection endpoint. The endpoint might not be shown for instances whose status is creating.
        public var endpoint: RdsClientTypes.Endpoint?
        /// The name of the database engine to be used for this DB instance.
        public var engine: Swift.String?
        /// Indicates the database engine version.
        public var engineVersion: Swift.String?
        /// The Amazon Resource Name (ARN) of the Amazon CloudWatch Logs log stream that receives the Enhanced Monitoring metrics data for the DB instance.
        public var enhancedMonitoringResourceArn: Swift.String?
        /// True if mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled, and otherwise false. IAM database authentication can be enabled for the following database engines
        ///
        /// * For MySQL 5.6, minor version 5.6.34 or higher
        ///
        /// * For MySQL 5.7, minor version 5.7.16 or higher
        ///
        /// * Aurora 5.6 or higher. To enable IAM database authentication for Aurora, see DBCluster Type.
        public var iAMDatabaseAuthenticationEnabled: Swift.Bool
        /// Provides the date and time the DB instance was created.
        public var instanceCreateTime: ClientRuntime.Date?
        /// Specifies the Provisioned IOPS (I/O operations per second) value.
        public var iops: Swift.Int?
        /// If StorageEncrypted is true, the Amazon Web Services KMS key identifier for the encrypted DB instance. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        public var kmsKeyId: Swift.String?
        /// Specifies the latest time to which a database can be restored with point-in-time restore.
        public var latestRestorableTime: ClientRuntime.Date?
        /// License model information for this DB instance. This setting doesn't apply to RDS Custom.
        public var licenseModel: Swift.String?
        /// Specifies the listener connection endpoint for SQL Server Always On.
        public var listenerEndpoint: RdsClientTypes.Endpoint?
        /// Contains the master username for the DB instance.
        public var masterUsername: Swift.String?
        /// The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance.
        public var maxAllocatedStorage: Swift.Int?
        /// The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance.
        public var monitoringInterval: Swift.Int?
        /// The ARN for the IAM role that permits RDS to send Enhanced Monitoring metrics to Amazon CloudWatch Logs.
        public var monitoringRoleArn: Swift.String?
        /// Specifies if the DB instance is a Multi-AZ deployment. This setting doesn't apply to RDS Custom.
        public var multiAZ: Swift.Bool
        /// The name of the NCHAR character set for the Oracle DB instance. This character set specifies the Unicode encoding for data stored in table columns of type NCHAR, NCLOB, or NVARCHAR2.
        public var ncharCharacterSetName: Swift.String?
        /// Provides the list of option group memberships for this DB instance.
        public var optionGroupMemberships: [RdsClientTypes.OptionGroupMembership]?
        /// A value that specifies that changes to the DB instance are pending. This element is only included when changes are pending. Specific changes are identified by subelements.
        public var pendingModifiedValues: RdsClientTypes.PendingModifiedValues?
        /// True if Performance Insights is enabled for the DB instance, and otherwise false.
        public var performanceInsightsEnabled: Swift.Bool?
        /// The Amazon Web Services KMS key identifier for encryption of Performance Insights data. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        public var performanceInsightsKMSKeyId: Swift.String?
        /// The amount of time, in days, to retain Performance Insights data. Valid values are 7 or 731 (2 years).
        public var performanceInsightsRetentionPeriod: Swift.Int?
        /// Specifies the daily time range during which automated backups are created if automated backups are enabled, as determined by the BackupRetentionPeriod.
        public var preferredBackupWindow: Swift.String?
        /// Specifies the weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).
        public var preferredMaintenanceWindow: Swift.String?
        /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.
        public var processorFeatures: [RdsClientTypes.ProcessorFeature]?
        /// A value that specifies the order in which an Aurora Replica is promoted to the primary instance after a failure of the existing primary instance. For more information, see [ Fault Tolerance for an Aurora DB Cluster](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.FaultTolerance) in the Amazon Aurora User Guide.
        public var promotionTier: Swift.Int?
        /// Specifies the accessibility options for the DB instance. When the DB cluster is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB cluster's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB cluster's VPC. Access to the DB cluster is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB cluster doesn't permit it. When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address. For more information, see [CreateDBInstance].
        public var publiclyAccessible: Swift.Bool
        /// Contains one or more identifiers of Aurora DB clusters to which the RDS DB instance is replicated as a read replica. For example, when you create an Aurora read replica of an RDS for MySQL DB instance, the Aurora MySQL DB cluster for the Aurora read replica is shown. This output doesn't contain information about cross-Region Aurora read replicas. Currently, each RDS DB instance can have only one Aurora read replica.
        public var readReplicaDBClusterIdentifiers: [Swift.String]?
        /// Contains one or more identifiers of the read replicas associated with this DB instance.
        public var readReplicaDBInstanceIdentifiers: [Swift.String]?
        /// Contains the identifier of the source DB instance if this DB instance is a read replica.
        public var readReplicaSourceDBInstanceIdentifier: Swift.String?
        /// The open mode of an Oracle read replica. The default is open-read-only. For more information, see [Working with Oracle Read Replicas for Amazon RDS](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-read-replicas.html) in the Amazon RDS User Guide. This attribute is only supported in RDS for Oracle.
        public var replicaMode: RdsClientTypes.ReplicaMode?
        /// The number of minutes to pause the automation. When the time period ends, RDS Custom resumes full automation. The minimum value is 60 (default). The maximum value is 1,440.
        public var resumeFullAutomationModeTime: ClientRuntime.Date?
        /// If present, specifies the name of the secondary Availability Zone for a DB instance with multi-AZ support.
        public var secondaryAvailabilityZone: Swift.String?
        /// The status of a read replica. If the instance isn't a read replica, this is blank.
        public var statusInfos: [RdsClientTypes.DBInstanceStatusInfo]?
        /// Specifies whether the DB instance is encrypted.
        public var storageEncrypted: Swift.Bool
        /// Specifies the storage type associated with DB instance.
        public var storageType: Swift.String?
        /// A list of tags. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
        public var tagList: [RdsClientTypes.Tag]?
        /// The ARN from the key store with which the instance is associated for TDE encryption.
        public var tdeCredentialArn: Swift.String?
        /// The time zone of the DB instance. In most cases, the Timezone element is empty. Timezone content appears only for Microsoft SQL Server DB instances that were created with a time zone specified.
        public var timezone: Swift.String?
        /// Provides a list of VPC security group elements that the DB instance belongs to.
        public var vpcSecurityGroups: [RdsClientTypes.VpcSecurityGroupMembership]?

        public init (
            activityStreamEngineNativeAuditFieldsIncluded: Swift.Bool? = nil,
            activityStreamKinesisStreamName: Swift.String? = nil,
            activityStreamKmsKeyId: Swift.String? = nil,
            activityStreamMode: RdsClientTypes.ActivityStreamMode? = nil,
            activityStreamStatus: RdsClientTypes.ActivityStreamStatus? = nil,
            allocatedStorage: Swift.Int = 0,
            associatedRoles: [RdsClientTypes.DBInstanceRole]? = nil,
            autoMinorVersionUpgrade: Swift.Bool = false,
            automaticRestartTime: ClientRuntime.Date? = nil,
            automationMode: RdsClientTypes.AutomationMode? = nil,
            availabilityZone: Swift.String? = nil,
            awsBackupRecoveryPointArn: Swift.String? = nil,
            backupRetentionPeriod: Swift.Int = 0,
            backupTarget: Swift.String? = nil,
            cACertificateIdentifier: Swift.String? = nil,
            characterSetName: Swift.String? = nil,
            copyTagsToSnapshot: Swift.Bool = false,
            customIamInstanceProfile: Swift.String? = nil,
            customerOwnedIpEnabled: Swift.Bool? = nil,
            dBClusterIdentifier: Swift.String? = nil,
            dBInstanceArn: Swift.String? = nil,
            dBInstanceAutomatedBackupsReplications: [RdsClientTypes.DBInstanceAutomatedBackupsReplication]? = nil,
            dBInstanceClass: Swift.String? = nil,
            dBInstanceIdentifier: Swift.String? = nil,
            dBInstanceStatus: Swift.String? = nil,
            dBName: Swift.String? = nil,
            dBParameterGroups: [RdsClientTypes.DBParameterGroupStatus]? = nil,
            dBSecurityGroups: [RdsClientTypes.DBSecurityGroupMembership]? = nil,
            dBSubnetGroup: RdsClientTypes.DBSubnetGroup? = nil,
            dbInstancePort: Swift.Int = 0,
            dbiResourceId: Swift.String? = nil,
            deletionProtection: Swift.Bool = false,
            domainMemberships: [RdsClientTypes.DomainMembership]? = nil,
            enabledCloudwatchLogsExports: [Swift.String]? = nil,
            endpoint: RdsClientTypes.Endpoint? = nil,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            enhancedMonitoringResourceArn: Swift.String? = nil,
            iAMDatabaseAuthenticationEnabled: Swift.Bool = false,
            instanceCreateTime: ClientRuntime.Date? = nil,
            iops: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            latestRestorableTime: ClientRuntime.Date? = nil,
            licenseModel: Swift.String? = nil,
            listenerEndpoint: RdsClientTypes.Endpoint? = nil,
            masterUsername: Swift.String? = nil,
            maxAllocatedStorage: Swift.Int? = nil,
            monitoringInterval: Swift.Int? = nil,
            monitoringRoleArn: Swift.String? = nil,
            multiAZ: Swift.Bool = false,
            ncharCharacterSetName: Swift.String? = nil,
            optionGroupMemberships: [RdsClientTypes.OptionGroupMembership]? = nil,
            pendingModifiedValues: RdsClientTypes.PendingModifiedValues? = nil,
            performanceInsightsEnabled: Swift.Bool? = nil,
            performanceInsightsKMSKeyId: Swift.String? = nil,
            performanceInsightsRetentionPeriod: Swift.Int? = nil,
            preferredBackupWindow: Swift.String? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            processorFeatures: [RdsClientTypes.ProcessorFeature]? = nil,
            promotionTier: Swift.Int? = nil,
            publiclyAccessible: Swift.Bool = false,
            readReplicaDBClusterIdentifiers: [Swift.String]? = nil,
            readReplicaDBInstanceIdentifiers: [Swift.String]? = nil,
            readReplicaSourceDBInstanceIdentifier: Swift.String? = nil,
            replicaMode: RdsClientTypes.ReplicaMode? = nil,
            resumeFullAutomationModeTime: ClientRuntime.Date? = nil,
            secondaryAvailabilityZone: Swift.String? = nil,
            statusInfos: [RdsClientTypes.DBInstanceStatusInfo]? = nil,
            storageEncrypted: Swift.Bool = false,
            storageType: Swift.String? = nil,
            tagList: [RdsClientTypes.Tag]? = nil,
            tdeCredentialArn: Swift.String? = nil,
            timezone: Swift.String? = nil,
            vpcSecurityGroups: [RdsClientTypes.VpcSecurityGroupMembership]? = nil
        )
        {
            self.activityStreamEngineNativeAuditFieldsIncluded = activityStreamEngineNativeAuditFieldsIncluded
            self.activityStreamKinesisStreamName = activityStreamKinesisStreamName
            self.activityStreamKmsKeyId = activityStreamKmsKeyId
            self.activityStreamMode = activityStreamMode
            self.activityStreamStatus = activityStreamStatus
            self.allocatedStorage = allocatedStorage
            self.associatedRoles = associatedRoles
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.automaticRestartTime = automaticRestartTime
            self.automationMode = automationMode
            self.availabilityZone = availabilityZone
            self.awsBackupRecoveryPointArn = awsBackupRecoveryPointArn
            self.backupRetentionPeriod = backupRetentionPeriod
            self.backupTarget = backupTarget
            self.cACertificateIdentifier = cACertificateIdentifier
            self.characterSetName = characterSetName
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.customIamInstanceProfile = customIamInstanceProfile
            self.customerOwnedIpEnabled = customerOwnedIpEnabled
            self.dBClusterIdentifier = dBClusterIdentifier
            self.dBInstanceArn = dBInstanceArn
            self.dBInstanceAutomatedBackupsReplications = dBInstanceAutomatedBackupsReplications
            self.dBInstanceClass = dBInstanceClass
            self.dBInstanceIdentifier = dBInstanceIdentifier
            self.dBInstanceStatus = dBInstanceStatus
            self.dBName = dBName
            self.dBParameterGroups = dBParameterGroups
            self.dBSecurityGroups = dBSecurityGroups
            self.dBSubnetGroup = dBSubnetGroup
            self.dbInstancePort = dbInstancePort
            self.dbiResourceId = dbiResourceId
            self.deletionProtection = deletionProtection
            self.domainMemberships = domainMemberships
            self.enabledCloudwatchLogsExports = enabledCloudwatchLogsExports
            self.endpoint = endpoint
            self.engine = engine
            self.engineVersion = engineVersion
            self.enhancedMonitoringResourceArn = enhancedMonitoringResourceArn
            self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
            self.instanceCreateTime = instanceCreateTime
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.latestRestorableTime = latestRestorableTime
            self.licenseModel = licenseModel
            self.listenerEndpoint = listenerEndpoint
            self.masterUsername = masterUsername
            self.maxAllocatedStorage = maxAllocatedStorage
            self.monitoringInterval = monitoringInterval
            self.monitoringRoleArn = monitoringRoleArn
            self.multiAZ = multiAZ
            self.ncharCharacterSetName = ncharCharacterSetName
            self.optionGroupMemberships = optionGroupMemberships
            self.pendingModifiedValues = pendingModifiedValues
            self.performanceInsightsEnabled = performanceInsightsEnabled
            self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
            self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.processorFeatures = processorFeatures
            self.promotionTier = promotionTier
            self.publiclyAccessible = publiclyAccessible
            self.readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiers
            self.readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiers
            self.readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifier
            self.replicaMode = replicaMode
            self.resumeFullAutomationModeTime = resumeFullAutomationModeTime
            self.secondaryAvailabilityZone = secondaryAvailabilityZone
            self.statusInfos = statusInfos
            self.storageEncrypted = storageEncrypted
            self.storageType = storageType
            self.tagList = tagList
            self.tdeCredentialArn = tdeCredentialArn
            self.timezone = timezone
            self.vpcSecurityGroups = vpcSecurityGroups
        }
    }

}

extension DBInstanceAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBInstanceAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user already has a DB instance with the given identifier.
public struct DBInstanceAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBInstanceAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBInstanceAutomatedBackup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case availabilityZone = "AvailabilityZone"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case backupTarget = "BackupTarget"
        case dBInstanceArn = "DBInstanceArn"
        case dBInstanceAutomatedBackupsArn = "DBInstanceAutomatedBackupsArn"
        case dBInstanceAutomatedBackupsReplications = "DBInstanceAutomatedBackupsReplications"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dbiResourceId = "DbiResourceId"
        case encrypted = "Encrypted"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case instanceCreateTime = "InstanceCreateTime"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case licenseModel = "LicenseModel"
        case masterUsername = "MasterUsername"
        case optionGroupName = "OptionGroupName"
        case port = "Port"
        case region = "Region"
        case restoreWindow = "RestoreWindow"
        case status = "Status"
        case storageType = "StorageType"
        case tdeCredentialArn = "TdeCredentialArn"
        case timezone = "Timezone"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allocatedStorage != 0 {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let backupTarget = backupTarget {
            try container.encode(backupTarget, forKey: ClientRuntime.Key("BackupTarget"))
        }
        if let dBInstanceArn = dBInstanceArn {
            try container.encode(dBInstanceArn, forKey: ClientRuntime.Key("DBInstanceArn"))
        }
        if let dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn {
            try container.encode(dBInstanceAutomatedBackupsArn, forKey: ClientRuntime.Key("DBInstanceAutomatedBackupsArn"))
        }
        if let dBInstanceAutomatedBackupsReplications = dBInstanceAutomatedBackupsReplications {
            var dBInstanceAutomatedBackupsReplicationsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBInstanceAutomatedBackupsReplications"))
            for (index0, dbinstanceautomatedbackupsreplication0) in dBInstanceAutomatedBackupsReplications.enumerated() {
                try dBInstanceAutomatedBackupsReplicationsContainer.encode(dbinstanceautomatedbackupsreplication0, forKey: ClientRuntime.Key("DBInstanceAutomatedBackupsReplication.\(index0.advanced(by: 1))"))
            }
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dbiResourceId = dbiResourceId {
            try container.encode(dbiResourceId, forKey: ClientRuntime.Key("DbiResourceId"))
        }
        if encrypted != false {
            try container.encode(encrypted, forKey: ClientRuntime.Key("Encrypted"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if iAMDatabaseAuthenticationEnabled != false {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: ClientRuntime.Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let instanceCreateTime = instanceCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(instanceCreateTime, format: .dateTime), forKey: ClientRuntime.Key("instanceCreateTime"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if port != 0 {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let region = region {
            try container.encode(region, forKey: ClientRuntime.Key("Region"))
        }
        if let restoreWindow = restoreWindow {
            try container.encode(restoreWindow, forKey: ClientRuntime.Key("RestoreWindow"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: ClientRuntime.Key("TdeCredentialArn"))
        }
        if let timezone = timezone {
            try container.encode(timezone, forKey: ClientRuntime.Key("Timezone"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceArn)
        dBInstanceArn = dBInstanceArnDecoded
        let dbiResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbiResourceId)
        dbiResourceId = dbiResourceIdDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let restoreWindowDecoded = try containerValues.decodeIfPresent(RdsClientTypes.RestoreWindow.self, forKey: .restoreWindow)
        restoreWindow = restoreWindowDecoded
        let allocatedStorageDecoded = try containerValues.decode(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let instanceCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceCreateTime)
        var instanceCreateTimeBuffer:ClientRuntime.Date? = nil
        if let instanceCreateTimeDecoded = instanceCreateTimeDecoded {
            instanceCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(instanceCreateTimeDecoded, format: .dateTime)
        }
        instanceCreateTime = instanceCreateTimeBuffer
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let tdeCredentialArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tdeCredentialArn)
        tdeCredentialArn = tdeCredentialArnDecoded
        let encryptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let dBInstanceAutomatedBackupsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceAutomatedBackupsArn)
        dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArnDecoded
        if containerValues.contains(.dBInstanceAutomatedBackupsReplications) {
            struct KeyVal0{struct DBInstanceAutomatedBackupsReplication{}}
            let dBInstanceAutomatedBackupsReplicationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBInstanceAutomatedBackupsReplication>.CodingKeys.self, forKey: .dBInstanceAutomatedBackupsReplications)
            if let dBInstanceAutomatedBackupsReplicationsWrappedContainer = dBInstanceAutomatedBackupsReplicationsWrappedContainer {
                let dBInstanceAutomatedBackupsReplicationsContainer = try dBInstanceAutomatedBackupsReplicationsWrappedContainer.decodeIfPresent([RdsClientTypes.DBInstanceAutomatedBackupsReplication].self, forKey: .member)
                var dBInstanceAutomatedBackupsReplicationsBuffer:[RdsClientTypes.DBInstanceAutomatedBackupsReplication]? = nil
                if let dBInstanceAutomatedBackupsReplicationsContainer = dBInstanceAutomatedBackupsReplicationsContainer {
                    dBInstanceAutomatedBackupsReplicationsBuffer = [RdsClientTypes.DBInstanceAutomatedBackupsReplication]()
                    for structureContainer0 in dBInstanceAutomatedBackupsReplicationsContainer {
                        dBInstanceAutomatedBackupsReplicationsBuffer?.append(structureContainer0)
                    }
                }
                dBInstanceAutomatedBackupsReplications = dBInstanceAutomatedBackupsReplicationsBuffer
            } else {
                dBInstanceAutomatedBackupsReplications = []
            }
        } else {
            dBInstanceAutomatedBackupsReplications = nil
        }
        let backupTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupTarget)
        backupTarget = backupTargetDecoded
    }
}

extension RdsClientTypes {
    /// An automated backup of a DB instance. It consists of system backups, transaction logs, and the database instance properties that existed at the time you deleted the source instance.
    public struct DBInstanceAutomatedBackup: Swift.Equatable {
        /// Specifies the allocated storage size in gibibytes (GiB).
        public var allocatedStorage: Swift.Int
        /// The Availability Zone that the automated backup was created in. For information on Amazon Web Services Regions and Availability Zones, see [Regions and Availability Zones](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html).
        public var availabilityZone: Swift.String?
        /// The retention period for the automated backups.
        public var backupRetentionPeriod: Swift.Int?
        /// Specifies where automated backups are stored: Amazon Web Services Outposts or the Amazon Web Services Region.
        public var backupTarget: Swift.String?
        /// The Amazon Resource Name (ARN) for the automated backups.
        public var dBInstanceArn: Swift.String?
        /// The Amazon Resource Name (ARN) for the replicated automated backups.
        public var dBInstanceAutomatedBackupsArn: Swift.String?
        /// The list of replications to different Amazon Web Services Regions associated with the automated backup.
        public var dBInstanceAutomatedBackupsReplications: [RdsClientTypes.DBInstanceAutomatedBackupsReplication]?
        /// The customer id of the instance that is/was associated with the automated backup.
        public var dBInstanceIdentifier: Swift.String?
        /// The identifier for the source DB instance, which can't be changed and which is unique to an Amazon Web Services Region.
        public var dbiResourceId: Swift.String?
        /// Specifies whether the automated backup is encrypted.
        public var encrypted: Swift.Bool
        /// The name of the database engine for this automated backup.
        public var engine: Swift.String?
        /// The version of the database engine for the automated backup.
        public var engineVersion: Swift.String?
        /// True if mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled, and otherwise false.
        public var iAMDatabaseAuthenticationEnabled: Swift.Bool
        /// Provides the date and time that the DB instance was created.
        public var instanceCreateTime: ClientRuntime.Date?
        /// The IOPS (I/O operations per second) value for the automated backup.
        public var iops: Swift.Int?
        /// The Amazon Web Services KMS key ID for an automated backup. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        public var kmsKeyId: Swift.String?
        /// License model information for the automated backup.
        public var licenseModel: Swift.String?
        /// The license model of an automated backup.
        public var masterUsername: Swift.String?
        /// The option group the automated backup is associated with. If omitted, the default option group for the engine specified is used.
        public var optionGroupName: Swift.String?
        /// The port number that the automated backup used for connections. Default: Inherits from the source DB instance Valid Values: 1150-65535
        public var port: Swift.Int
        /// The Amazon Web Services Region associated with the automated backup.
        public var region: Swift.String?
        /// Earliest and latest time an instance can be restored to.
        public var restoreWindow: RdsClientTypes.RestoreWindow?
        /// Provides a list of status information for an automated backup:
        ///
        /// * active - automated backups for current instances
        ///
        /// * retained - automated backups for deleted instances
        ///
        /// * creating - automated backups that are waiting for the first automated snapshot to be available.
        public var status: Swift.String?
        /// Specifies the storage type associated with the automated backup.
        public var storageType: Swift.String?
        /// The ARN from the key store with which the automated backup is associated for TDE encryption.
        public var tdeCredentialArn: Swift.String?
        /// The time zone of the automated backup. In most cases, the Timezone element is empty. Timezone content appears only for Microsoft SQL Server DB instances that were created with a time zone specified.
        public var timezone: Swift.String?
        /// Provides the VPC ID associated with the DB instance
        public var vpcId: Swift.String?

        public init (
            allocatedStorage: Swift.Int = 0,
            availabilityZone: Swift.String? = nil,
            backupRetentionPeriod: Swift.Int? = nil,
            backupTarget: Swift.String? = nil,
            dBInstanceArn: Swift.String? = nil,
            dBInstanceAutomatedBackupsArn: Swift.String? = nil,
            dBInstanceAutomatedBackupsReplications: [RdsClientTypes.DBInstanceAutomatedBackupsReplication]? = nil,
            dBInstanceIdentifier: Swift.String? = nil,
            dbiResourceId: Swift.String? = nil,
            encrypted: Swift.Bool = false,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            iAMDatabaseAuthenticationEnabled: Swift.Bool = false,
            instanceCreateTime: ClientRuntime.Date? = nil,
            iops: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            licenseModel: Swift.String? = nil,
            masterUsername: Swift.String? = nil,
            optionGroupName: Swift.String? = nil,
            port: Swift.Int = 0,
            region: Swift.String? = nil,
            restoreWindow: RdsClientTypes.RestoreWindow? = nil,
            status: Swift.String? = nil,
            storageType: Swift.String? = nil,
            tdeCredentialArn: Swift.String? = nil,
            timezone: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.availabilityZone = availabilityZone
            self.backupRetentionPeriod = backupRetentionPeriod
            self.backupTarget = backupTarget
            self.dBInstanceArn = dBInstanceArn
            self.dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn
            self.dBInstanceAutomatedBackupsReplications = dBInstanceAutomatedBackupsReplications
            self.dBInstanceIdentifier = dBInstanceIdentifier
            self.dbiResourceId = dbiResourceId
            self.encrypted = encrypted
            self.engine = engine
            self.engineVersion = engineVersion
            self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
            self.instanceCreateTime = instanceCreateTime
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.licenseModel = licenseModel
            self.masterUsername = masterUsername
            self.optionGroupName = optionGroupName
            self.port = port
            self.region = region
            self.restoreWindow = restoreWindow
            self.status = status
            self.storageType = storageType
            self.tdeCredentialArn = tdeCredentialArn
            self.timezone = timezone
            self.vpcId = vpcId
        }
    }

}

extension DBInstanceAutomatedBackupNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBInstanceAutomatedBackupNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// No automated backup for this DB instance was found.
public struct DBInstanceAutomatedBackupNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceAutomatedBackupNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBInstanceAutomatedBackupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBInstanceAutomatedBackupQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBInstanceAutomatedBackupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The quota for retained automated backups was exceeded. This prevents you from retaining any additional automated backups. The retained automated backups quota is the same as your DB Instance quota.
public struct DBInstanceAutomatedBackupQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceAutomatedBackupQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBInstanceAutomatedBackupQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBInstanceAutomatedBackupsReplication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceAutomatedBackupsArn = "DBInstanceAutomatedBackupsArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn {
            try container.encode(dBInstanceAutomatedBackupsArn, forKey: ClientRuntime.Key("DBInstanceAutomatedBackupsArn"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceAutomatedBackupsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceAutomatedBackupsArn)
        dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArnDecoded
    }
}

extension RdsClientTypes {
    /// Automated backups of a DB instance replicated to another Amazon Web Services Region. They consist of system backups, transaction logs, and database instance properties.
    public struct DBInstanceAutomatedBackupsReplication: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the replicated automated backups.
        public var dBInstanceAutomatedBackupsArn: Swift.String?

        public init (
            dBInstanceAutomatedBackupsArn: Swift.String? = nil
        )
        {
            self.dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn
        }
    }

}

extension DBInstanceNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBInstanceNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// DBInstanceIdentifier doesn't refer to an existing DB instance.
public struct DBInstanceNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBInstanceNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBInstanceRole: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureName = "FeatureName"
        case roleArn = "RoleArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let featureName = featureName {
            try container.encode(featureName, forKey: ClientRuntime.Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let featureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureName)
        featureName = featureNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension RdsClientTypes {
    /// Describes an Amazon Web Services Identity and Access Management (IAM) role that is associated with a DB instance.
    public struct DBInstanceRole: Swift.Equatable {
        /// The name of the feature associated with the Amazon Web Services Identity and Access Management (IAM) role. For information about supported feature names, see DBEngineVersion.
        public var featureName: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role that is associated with the DB instance.
        public var roleArn: Swift.String?
        /// Describes the state of association between the IAM role and the DB instance. The Status property returns one of the following values:
        ///
        /// * ACTIVE - the IAM role ARN is associated with the DB instance and can be used to access other Amazon Web Services services on your behalf.
        ///
        /// * PENDING - the IAM role ARN is being associated with the DB instance.
        ///
        /// * INVALID - the IAM role ARN is associated with the DB instance, but the DB instance is unable to assume the IAM role in order to access other Amazon Web Services services on your behalf.
        public var status: Swift.String?

        public init (
            featureName: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.featureName = featureName
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension DBInstanceRoleAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBInstanceRoleAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified RoleArn or FeatureName value is already associated with the DB instance.
public struct DBInstanceRoleAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceRoleAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBInstanceRoleAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBInstanceRoleNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBInstanceRoleNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified RoleArn value doesn't match the specified feature for the DB instance.
public struct DBInstanceRoleNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceRoleNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBInstanceRoleNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBInstanceRoleQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBInstanceRoleQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can't associate any more Amazon Web Services Identity and Access Management (IAM) roles with the DB instance because the quota has been reached.
public struct DBInstanceRoleQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceRoleQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBInstanceRoleQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBInstanceStatusInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case normal = "Normal"
        case status = "Status"
        case statusType = "StatusType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let message = message {
            try container.encode(message, forKey: ClientRuntime.Key("Message"))
        }
        if normal != false {
            try container.encode(normal, forKey: ClientRuntime.Key("Normal"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let statusType = statusType {
            try container.encode(statusType, forKey: ClientRuntime.Key("StatusType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusType)
        statusType = statusTypeDecoded
        let normalDecoded = try containerValues.decode(Swift.Bool.self, forKey: .normal)
        normal = normalDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes {
    /// Provides a list of status information for a DB instance.
    public struct DBInstanceStatusInfo: Swift.Equatable {
        /// Details of the error if there is an error for the instance. If the instance isn't in an error state, this value is blank.
        public var message: Swift.String?
        /// Boolean value that is true if the instance is operating normally, or false if the instance is in an error state.
        public var normal: Swift.Bool
        /// Status of the DB instance. For a StatusType of read replica, the values can be replicating, replication stop point set, replication stop point reached, error, stopped, or terminated.
        public var status: Swift.String?
        /// This value is currently "read replication."
        public var statusType: Swift.String?

        public init (
            message: Swift.String? = nil,
            normal: Swift.Bool = false,
            status: Swift.String? = nil,
            statusType: Swift.String? = nil
        )
        {
            self.message = message
            self.normal = normal
            self.status = status
            self.statusType = statusType
        }
    }

}

extension DBLogFileNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBLogFileNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// LogFileName doesn't refer to an existing DB log file.
public struct DBLogFileNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBLogFileNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBLogFileNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBParameterGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupArn = "DBParameterGroupArn"
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case dBParameterGroupName = "DBParameterGroupName"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupArn = dBParameterGroupArn {
            try container.encode(dBParameterGroupArn, forKey: ClientRuntime.Key("DBParameterGroupArn"))
        }
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dBParameterGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupArn)
        dBParameterGroupArn = dBParameterGroupArnDecoded
    }
}

extension RdsClientTypes {
    /// Contains the details of an Amazon RDS DB parameter group. This data type is used as a response element in the DescribeDBParameterGroups action.
    public struct DBParameterGroup: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the DB parameter group.
        public var dBParameterGroupArn: Swift.String?
        /// The name of the DB parameter group family that this DB parameter group is compatible with.
        public var dBParameterGroupFamily: Swift.String?
        /// The name of the DB parameter group.
        public var dBParameterGroupName: Swift.String?
        /// Provides the customer-specified description for this DB parameter group.
        public var description: Swift.String?

        public init (
            dBParameterGroupArn: Swift.String? = nil,
            dBParameterGroupFamily: Swift.String? = nil,
            dBParameterGroupName: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.dBParameterGroupArn = dBParameterGroupArn
            self.dBParameterGroupFamily = dBParameterGroupFamily
            self.dBParameterGroupName = dBParameterGroupName
            self.description = description
        }
    }

}

extension DBParameterGroupAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBParameterGroupAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A DB parameter group with the same name exists.
public struct DBParameterGroupAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBParameterGroupAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBParameterGroupAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBParameterGroupNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBParameterGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// DBParameterGroupName doesn't refer to an existing DB parameter group.
public struct DBParameterGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBParameterGroupNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBParameterGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBParameterGroupQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBParameterGroupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would result in the user exceeding the allowed number of DB parameter groups.
public struct DBParameterGroupQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBParameterGroupQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBParameterGroupQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBParameterGroupStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupName = "DBParameterGroupName"
        case parameterApplyStatus = "ParameterApplyStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let parameterApplyStatus = parameterApplyStatus {
            try container.encode(parameterApplyStatus, forKey: ClientRuntime.Key("ParameterApplyStatus"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
        let parameterApplyStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterApplyStatus)
        parameterApplyStatus = parameterApplyStatusDecoded
    }
}

extension RdsClientTypes {
    /// The status of the DB parameter group. This data type is used as a response element in the following actions:
    ///
    /// * CreateDBInstance
    ///
    /// * CreateDBInstanceReadReplica
    ///
    /// * DeleteDBInstance
    ///
    /// * ModifyDBInstance
    ///
    /// * RebootDBInstance
    ///
    /// * RestoreDBInstanceFromDBSnapshot
    public struct DBParameterGroupStatus: Swift.Equatable {
        /// The name of the DB parameter group.
        public var dBParameterGroupName: Swift.String?
        /// The status of parameter updates.
        public var parameterApplyStatus: Swift.String?

        public init (
            dBParameterGroupName: Swift.String? = nil,
            parameterApplyStatus: Swift.String? = nil
        )
        {
            self.dBParameterGroupName = dBParameterGroupName
            self.parameterApplyStatus = parameterApplyStatus
        }
    }

}

extension RdsClientTypes.DBProxy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auth = "Auth"
        case createdDate = "CreatedDate"
        case dBProxyArn = "DBProxyArn"
        case dBProxyName = "DBProxyName"
        case debugLogging = "DebugLogging"
        case endpoint = "Endpoint"
        case engineFamily = "EngineFamily"
        case idleClientTimeout = "IdleClientTimeout"
        case requireTLS = "RequireTLS"
        case roleArn = "RoleArn"
        case status = "Status"
        case updatedDate = "UpdatedDate"
        case vpcId = "VpcId"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        case vpcSubnetIds = "VpcSubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let auth = auth {
            var authContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Auth"))
            for (index0, userauthconfiginfo0) in auth.enumerated() {
                try authContainer.encode(userauthconfiginfo0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let createdDate = createdDate {
            try container.encode(ClientRuntime.TimestampWrapper(createdDate, format: .dateTime), forKey: ClientRuntime.Key("createdDate"))
        }
        if let dBProxyArn = dBProxyArn {
            try container.encode(dBProxyArn, forKey: ClientRuntime.Key("DBProxyArn"))
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if debugLogging != false {
            try container.encode(debugLogging, forKey: ClientRuntime.Key("DebugLogging"))
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if let engineFamily = engineFamily {
            try container.encode(engineFamily, forKey: ClientRuntime.Key("EngineFamily"))
        }
        if idleClientTimeout != 0 {
            try container.encode(idleClientTimeout, forKey: ClientRuntime.Key("IdleClientTimeout"))
        }
        if requireTLS != false {
            try container.encode(requireTLS, forKey: ClientRuntime.Key("RequireTLS"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let updatedDate = updatedDate {
            try container.encode(ClientRuntime.TimestampWrapper(updatedDate, format: .dateTime), forKey: ClientRuntime.Key("updatedDate"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSubnetIds = vpcSubnetIds {
            var vpcSubnetIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSubnetIds"))
            for (index0, string0) in vpcSubnetIds.enumerated() {
                try vpcSubnetIdsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBProxyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyName)
        dBProxyName = dBProxyNameDecoded
        let dBProxyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyArn)
        dBProxyArn = dBProxyArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBProxyStatus.self, forKey: .status)
        status = statusDecoded
        let engineFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineFamily)
        engineFamily = engineFamilyDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        if containerValues.contains(.vpcSecurityGroupIds) {
            struct KeyVal0{struct member{}}
            let vpcSecurityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .vpcSecurityGroupIds)
            if let vpcSecurityGroupIdsWrappedContainer = vpcSecurityGroupIdsWrappedContainer {
                let vpcSecurityGroupIdsContainer = try vpcSecurityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSecurityGroupIdsBuffer:[Swift.String]? = nil
                if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
                    vpcSecurityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSecurityGroupIdsContainer {
                        vpcSecurityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupIds = vpcSecurityGroupIdsBuffer
            } else {
                vpcSecurityGroupIds = []
            }
        } else {
            vpcSecurityGroupIds = nil
        }
        if containerValues.contains(.vpcSubnetIds) {
            struct KeyVal0{struct member{}}
            let vpcSubnetIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .vpcSubnetIds)
            if let vpcSubnetIdsWrappedContainer = vpcSubnetIdsWrappedContainer {
                let vpcSubnetIdsContainer = try vpcSubnetIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSubnetIdsBuffer:[Swift.String]? = nil
                if let vpcSubnetIdsContainer = vpcSubnetIdsContainer {
                    vpcSubnetIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSubnetIdsContainer {
                        vpcSubnetIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSubnetIds = vpcSubnetIdsBuffer
            } else {
                vpcSubnetIds = []
            }
        } else {
            vpcSubnetIds = nil
        }
        if containerValues.contains(.auth) {
            struct KeyVal0{struct member{}}
            let authWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .auth)
            if let authWrappedContainer = authWrappedContainer {
                let authContainer = try authWrappedContainer.decodeIfPresent([RdsClientTypes.UserAuthConfigInfo].self, forKey: .member)
                var authBuffer:[RdsClientTypes.UserAuthConfigInfo]? = nil
                if let authContainer = authContainer {
                    authBuffer = [RdsClientTypes.UserAuthConfigInfo]()
                    for structureContainer0 in authContainer {
                        authBuffer?.append(structureContainer0)
                    }
                }
                auth = authBuffer
            } else {
                auth = []
            }
        } else {
            auth = nil
        }
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let requireTLSDecoded = try containerValues.decode(Swift.Bool.self, forKey: .requireTLS)
        requireTLS = requireTLSDecoded
        let idleClientTimeoutDecoded = try containerValues.decode(Swift.Int.self, forKey: .idleClientTimeout)
        idleClientTimeout = idleClientTimeoutDecoded
        let debugLoggingDecoded = try containerValues.decode(Swift.Bool.self, forKey: .debugLogging)
        debugLogging = debugLoggingDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        var createdDateBuffer:ClientRuntime.Date? = nil
        if let createdDateDecoded = createdDateDecoded {
            createdDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createdDateDecoded, format: .dateTime)
        }
        createdDate = createdDateBuffer
        let updatedDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedDate)
        var updatedDateBuffer:ClientRuntime.Date? = nil
        if let updatedDateDecoded = updatedDateDecoded {
            updatedDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(updatedDateDecoded, format: .dateTime)
        }
        updatedDate = updatedDateBuffer
    }
}

extension RdsClientTypes {
    /// The data structure representing a proxy managed by the RDS Proxy. This data type is used as a response element in the DescribeDBProxies action.
    public struct DBProxy: Swift.Equatable {
        /// One or more data structures specifying the authorization mechanism to connect to the associated RDS DB instance or Aurora DB cluster.
        public var auth: [RdsClientTypes.UserAuthConfigInfo]?
        /// The date and time when the proxy was first created.
        public var createdDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) for the proxy.
        public var dBProxyArn: Swift.String?
        /// The identifier for the proxy. This name must be unique for all proxies owned by your Amazon Web Services account in the specified Amazon Web Services Region.
        public var dBProxyName: Swift.String?
        /// Whether the proxy includes detailed information about SQL statements in its logs. This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections. The debug information includes the text of SQL statements that you submit through the proxy. Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive information that appears in the logs.
        public var debugLogging: Swift.Bool
        /// The endpoint that you can use to connect to the DB proxy. You include the endpoint value in the connection string for a database client application.
        public var endpoint: Swift.String?
        /// The engine family applies to MySQL and PostgreSQL for both RDS and Aurora.
        public var engineFamily: Swift.String?
        /// The number of seconds a connection to the proxy can have no activity before the proxy drops the client connection. The proxy keeps the underlying database connection open and puts it back into the connection pool for reuse by later connection requests. Default: 1800 (30 minutes) Constraints: 1 to 28,800
        public var idleClientTimeout: Swift.Int
        /// Indicates whether Transport Layer Security (TLS) encryption is required for connections to the proxy.
        public var requireTLS: Swift.Bool
        /// The Amazon Resource Name (ARN) for the IAM role that the proxy uses to access Amazon Secrets Manager.
        public var roleArn: Swift.String?
        /// The current status of this proxy. A status of available means the proxy is ready to handle requests. Other values indicate that you must wait for the proxy to be ready, or take some action to resolve an issue.
        public var status: RdsClientTypes.DBProxyStatus?
        /// The date and time when the proxy was last updated.
        public var updatedDate: ClientRuntime.Date?
        /// Provides the VPC ID of the DB proxy.
        public var vpcId: Swift.String?
        /// Provides a list of VPC security groups that the proxy belongs to.
        public var vpcSecurityGroupIds: [Swift.String]?
        /// The EC2 subnet IDs for the proxy.
        public var vpcSubnetIds: [Swift.String]?

        public init (
            auth: [RdsClientTypes.UserAuthConfigInfo]? = nil,
            createdDate: ClientRuntime.Date? = nil,
            dBProxyArn: Swift.String? = nil,
            dBProxyName: Swift.String? = nil,
            debugLogging: Swift.Bool = false,
            endpoint: Swift.String? = nil,
            engineFamily: Swift.String? = nil,
            idleClientTimeout: Swift.Int = 0,
            requireTLS: Swift.Bool = false,
            roleArn: Swift.String? = nil,
            status: RdsClientTypes.DBProxyStatus? = nil,
            updatedDate: ClientRuntime.Date? = nil,
            vpcId: Swift.String? = nil,
            vpcSecurityGroupIds: [Swift.String]? = nil,
            vpcSubnetIds: [Swift.String]? = nil
        )
        {
            self.auth = auth
            self.createdDate = createdDate
            self.dBProxyArn = dBProxyArn
            self.dBProxyName = dBProxyName
            self.debugLogging = debugLogging
            self.endpoint = endpoint
            self.engineFamily = engineFamily
            self.idleClientTimeout = idleClientTimeout
            self.requireTLS = requireTLS
            self.roleArn = roleArn
            self.status = status
            self.updatedDate = updatedDate
            self.vpcId = vpcId
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
            self.vpcSubnetIds = vpcSubnetIds
        }
    }

}

extension DBProxyAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBProxyAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified proxy name must be unique for all proxies owned by your Amazon Web Services account in the specified Amazon Web Services Region.
public struct DBProxyAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBProxyAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBProxyEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case dBProxyEndpointArn = "DBProxyEndpointArn"
        case dBProxyEndpointName = "DBProxyEndpointName"
        case dBProxyName = "DBProxyName"
        case endpoint = "Endpoint"
        case isDefault = "IsDefault"
        case status = "Status"
        case targetRole = "TargetRole"
        case vpcId = "VpcId"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        case vpcSubnetIds = "VpcSubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let createdDate = createdDate {
            try container.encode(ClientRuntime.TimestampWrapper(createdDate, format: .dateTime), forKey: ClientRuntime.Key("createdDate"))
        }
        if let dBProxyEndpointArn = dBProxyEndpointArn {
            try container.encode(dBProxyEndpointArn, forKey: ClientRuntime.Key("DBProxyEndpointArn"))
        }
        if let dBProxyEndpointName = dBProxyEndpointName {
            try container.encode(dBProxyEndpointName, forKey: ClientRuntime.Key("DBProxyEndpointName"))
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if isDefault != false {
            try container.encode(isDefault, forKey: ClientRuntime.Key("IsDefault"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let targetRole = targetRole {
            try container.encode(targetRole, forKey: ClientRuntime.Key("TargetRole"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSubnetIds = vpcSubnetIds {
            var vpcSubnetIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSubnetIds"))
            for (index0, string0) in vpcSubnetIds.enumerated() {
                try vpcSubnetIdsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBProxyEndpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyEndpointName)
        dBProxyEndpointName = dBProxyEndpointNameDecoded
        let dBProxyEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyEndpointArn)
        dBProxyEndpointArn = dBProxyEndpointArnDecoded
        let dBProxyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyName)
        dBProxyName = dBProxyNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBProxyEndpointStatus.self, forKey: .status)
        status = statusDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        if containerValues.contains(.vpcSecurityGroupIds) {
            struct KeyVal0{struct member{}}
            let vpcSecurityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .vpcSecurityGroupIds)
            if let vpcSecurityGroupIdsWrappedContainer = vpcSecurityGroupIdsWrappedContainer {
                let vpcSecurityGroupIdsContainer = try vpcSecurityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSecurityGroupIdsBuffer:[Swift.String]? = nil
                if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
                    vpcSecurityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSecurityGroupIdsContainer {
                        vpcSecurityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupIds = vpcSecurityGroupIdsBuffer
            } else {
                vpcSecurityGroupIds = []
            }
        } else {
            vpcSecurityGroupIds = nil
        }
        if containerValues.contains(.vpcSubnetIds) {
            struct KeyVal0{struct member{}}
            let vpcSubnetIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .vpcSubnetIds)
            if let vpcSubnetIdsWrappedContainer = vpcSubnetIdsWrappedContainer {
                let vpcSubnetIdsContainer = try vpcSubnetIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSubnetIdsBuffer:[Swift.String]? = nil
                if let vpcSubnetIdsContainer = vpcSubnetIdsContainer {
                    vpcSubnetIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSubnetIdsContainer {
                        vpcSubnetIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSubnetIds = vpcSubnetIdsBuffer
            } else {
                vpcSubnetIds = []
            }
        } else {
            vpcSubnetIds = nil
        }
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        var createdDateBuffer:ClientRuntime.Date? = nil
        if let createdDateDecoded = createdDateDecoded {
            createdDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createdDateDecoded, format: .dateTime)
        }
        createdDate = createdDateBuffer
        let targetRoleDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBProxyEndpointTargetRole.self, forKey: .targetRole)
        targetRole = targetRoleDecoded
        let isDefaultDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
    }
}

extension RdsClientTypes {
    /// The data structure representing an endpoint associated with a DB proxy. RDS automatically creates one endpoint for each DB proxy. For Aurora DB clusters, you can associate additional endpoints with the same DB proxy. These endpoints can be read/write or read-only. They can also reside in different VPCs than the associated DB proxy. This data type is used as a response element in the DescribeDBProxyEndpoints operation.
    public struct DBProxyEndpoint: Swift.Equatable {
        /// The date and time when the DB proxy endpoint was first created.
        public var createdDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) for the DB proxy endpoint.
        public var dBProxyEndpointArn: Swift.String?
        /// The name for the DB proxy endpoint. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens.
        public var dBProxyEndpointName: Swift.String?
        /// The identifier for the DB proxy that is associated with this DB proxy endpoint.
        public var dBProxyName: Swift.String?
        /// The endpoint that you can use to connect to the DB proxy. You include the endpoint value in the connection string for a database client application.
        public var endpoint: Swift.String?
        /// A value that indicates whether this endpoint is the default endpoint for the associated DB proxy. Default DB proxy endpoints always have read/write capability. Other endpoints that you associate with the DB proxy can be either read/write or read-only.
        public var isDefault: Swift.Bool
        /// The current status of this DB proxy endpoint. A status of available means the endpoint is ready to handle requests. Other values indicate that you must wait for the endpoint to be ready, or take some action to resolve an issue.
        public var status: RdsClientTypes.DBProxyEndpointStatus?
        /// A value that indicates whether the DB proxy endpoint can be used for read/write or read-only operations.
        public var targetRole: RdsClientTypes.DBProxyEndpointTargetRole?
        /// Provides the VPC ID of the DB proxy endpoint.
        public var vpcId: Swift.String?
        /// Provides a list of VPC security groups that the DB proxy endpoint belongs to.
        public var vpcSecurityGroupIds: [Swift.String]?
        /// The EC2 subnet IDs for the DB proxy endpoint.
        public var vpcSubnetIds: [Swift.String]?

        public init (
            createdDate: ClientRuntime.Date? = nil,
            dBProxyEndpointArn: Swift.String? = nil,
            dBProxyEndpointName: Swift.String? = nil,
            dBProxyName: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            isDefault: Swift.Bool = false,
            status: RdsClientTypes.DBProxyEndpointStatus? = nil,
            targetRole: RdsClientTypes.DBProxyEndpointTargetRole? = nil,
            vpcId: Swift.String? = nil,
            vpcSecurityGroupIds: [Swift.String]? = nil,
            vpcSubnetIds: [Swift.String]? = nil
        )
        {
            self.createdDate = createdDate
            self.dBProxyEndpointArn = dBProxyEndpointArn
            self.dBProxyEndpointName = dBProxyEndpointName
            self.dBProxyName = dBProxyName
            self.endpoint = endpoint
            self.isDefault = isDefault
            self.status = status
            self.targetRole = targetRole
            self.vpcId = vpcId
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
            self.vpcSubnetIds = vpcSubnetIds
        }
    }

}

extension DBProxyEndpointAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBProxyEndpointAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified DB proxy endpoint name must be unique for all DB proxy endpoints owned by your Amazon Web Services account in the specified Amazon Web Services Region.
public struct DBProxyEndpointAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyEndpointAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBProxyEndpointAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBProxyEndpointNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBProxyEndpointNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DB proxy endpoint doesn't exist.
public struct DBProxyEndpointNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyEndpointNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBProxyEndpointNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBProxyEndpointQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBProxyEndpointQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DB proxy already has the maximum number of endpoints.
public struct DBProxyEndpointQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyEndpointQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBProxyEndpointQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes {
    public enum DBProxyEndpointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case incompatibleNetwork
        case insufficientResourceLimits
        case modifying
        case sdkUnknown(Swift.String)

        public static var allCases: [DBProxyEndpointStatus] {
            return [
                .available,
                .creating,
                .deleting,
                .incompatibleNetwork,
                .insufficientResourceLimits,
                .modifying,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "available"
            case .creating: return "creating"
            case .deleting: return "deleting"
            case .incompatibleNetwork: return "incompatible-network"
            case .insufficientResourceLimits: return "insufficient-resource-limits"
            case .modifying: return "modifying"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DBProxyEndpointStatus(rawValue: rawValue) ?? DBProxyEndpointStatus.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes {
    public enum DBProxyEndpointTargetRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case readOnly
        case readWrite
        case sdkUnknown(Swift.String)

        public static var allCases: [DBProxyEndpointTargetRole] {
            return [
                .readOnly,
                .readWrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .readOnly: return "READ_ONLY"
            case .readWrite: return "READ_WRITE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DBProxyEndpointTargetRole(rawValue: rawValue) ?? DBProxyEndpointTargetRole.sdkUnknown(rawValue)
        }
    }
}

extension DBProxyNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBProxyNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified proxy name doesn't correspond to a proxy owned by your Amazon Web Services account in the specified Amazon Web Services Region.
public struct DBProxyNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBProxyNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBProxyQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBProxyQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your Amazon Web Services account already has the maximum number of proxies in the specified Amazon Web Services Region.
public struct DBProxyQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBProxyQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes {
    public enum DBProxyStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case incompatibleNetwork
        case insufficientResourceLimits
        case modifying
        case reactivating
        case suspended
        case suspending
        case sdkUnknown(Swift.String)

        public static var allCases: [DBProxyStatus] {
            return [
                .available,
                .creating,
                .deleting,
                .incompatibleNetwork,
                .insufficientResourceLimits,
                .modifying,
                .reactivating,
                .suspended,
                .suspending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "available"
            case .creating: return "creating"
            case .deleting: return "deleting"
            case .incompatibleNetwork: return "incompatible-network"
            case .insufficientResourceLimits: return "insufficient-resource-limits"
            case .modifying: return "modifying"
            case .reactivating: return "reactivating"
            case .suspended: return "suspended"
            case .suspending: return "suspending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DBProxyStatus(rawValue: rawValue) ?? DBProxyStatus.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes.DBProxyTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
        case port = "Port"
        case rdsResourceId = "RdsResourceId"
        case role = "Role"
        case targetArn = "TargetArn"
        case targetHealth = "TargetHealth"
        case trackedClusterId = "TrackedClusterId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if port != 0 {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let rdsResourceId = rdsResourceId {
            try container.encode(rdsResourceId, forKey: ClientRuntime.Key("RdsResourceId"))
        }
        if let role = role {
            try container.encode(role, forKey: ClientRuntime.Key("Role"))
        }
        if let targetArn = targetArn {
            try container.encode(targetArn, forKey: ClientRuntime.Key("TargetArn"))
        }
        if let targetHealth = targetHealth {
            try container.encode(targetHealth, forKey: ClientRuntime.Key("TargetHealth"))
        }
        if let trackedClusterId = trackedClusterId {
            try container.encode(trackedClusterId, forKey: ClientRuntime.Key("TrackedClusterId"))
        }
        if let type = type {
            try container.encode(type, forKey: ClientRuntime.Key("Type"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let trackedClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackedClusterId)
        trackedClusterId = trackedClusterIdDecoded
        let rdsResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rdsResourceId)
        rdsResourceId = rdsResourceIdDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let typeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.TargetType.self, forKey: .type)
        type = typeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(RdsClientTypes.TargetRole.self, forKey: .role)
        role = roleDecoded
        let targetHealthDecoded = try containerValues.decodeIfPresent(RdsClientTypes.TargetHealth.self, forKey: .targetHealth)
        targetHealth = targetHealthDecoded
    }
}

extension RdsClientTypes {
    /// Contains the details for an RDS Proxy target. It represents an RDS DB instance or Aurora DB cluster that the proxy can connect to. One or more targets are associated with an RDS Proxy target group. This data type is used as a response element in the DescribeDBProxyTargets action.
    public struct DBProxyTarget: Swift.Equatable {
        /// The writer endpoint for the RDS DB instance or Aurora DB cluster.
        public var endpoint: Swift.String?
        /// The port that the RDS Proxy uses to connect to the target RDS DB instance or Aurora DB cluster.
        public var port: Swift.Int
        /// The identifier representing the target. It can be the instance identifier for an RDS DB instance, or the cluster identifier for an Aurora DB cluster.
        public var rdsResourceId: Swift.String?
        /// A value that indicates whether the target of the proxy can be used for read/write or read-only operations.
        public var role: RdsClientTypes.TargetRole?
        /// The Amazon Resource Name (ARN) for the RDS DB instance or Aurora DB cluster.
        public var targetArn: Swift.String?
        /// Information about the connection health of the RDS Proxy target.
        public var targetHealth: RdsClientTypes.TargetHealth?
        /// The DB cluster identifier when the target represents an Aurora DB cluster. This field is blank when the target represents an RDS DB instance.
        public var trackedClusterId: Swift.String?
        /// Specifies the kind of database, such as an RDS DB instance or an Aurora DB cluster, that the target represents.
        public var type: RdsClientTypes.TargetType?

        public init (
            endpoint: Swift.String? = nil,
            port: Swift.Int = 0,
            rdsResourceId: Swift.String? = nil,
            role: RdsClientTypes.TargetRole? = nil,
            targetArn: Swift.String? = nil,
            targetHealth: RdsClientTypes.TargetHealth? = nil,
            trackedClusterId: Swift.String? = nil,
            type: RdsClientTypes.TargetType? = nil
        )
        {
            self.endpoint = endpoint
            self.port = port
            self.rdsResourceId = rdsResourceId
            self.role = role
            self.targetArn = targetArn
            self.targetHealth = targetHealth
            self.trackedClusterId = trackedClusterId
            self.type = type
        }
    }

}

extension DBProxyTargetAlreadyRegisteredFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBProxyTargetAlreadyRegisteredFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The proxy is already associated with the specified RDS DB instance or Aurora DB cluster.
public struct DBProxyTargetAlreadyRegisteredFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyTargetAlreadyRegisteredFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBProxyTargetAlreadyRegisteredFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBProxyTargetGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionPoolConfig = "ConnectionPoolConfig"
        case createdDate = "CreatedDate"
        case dBProxyName = "DBProxyName"
        case isDefault = "IsDefault"
        case status = "Status"
        case targetGroupArn = "TargetGroupArn"
        case targetGroupName = "TargetGroupName"
        case updatedDate = "UpdatedDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let connectionPoolConfig = connectionPoolConfig {
            try container.encode(connectionPoolConfig, forKey: ClientRuntime.Key("ConnectionPoolConfig"))
        }
        if let createdDate = createdDate {
            try container.encode(ClientRuntime.TimestampWrapper(createdDate, format: .dateTime), forKey: ClientRuntime.Key("createdDate"))
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if isDefault != false {
            try container.encode(isDefault, forKey: ClientRuntime.Key("IsDefault"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let targetGroupArn = targetGroupArn {
            try container.encode(targetGroupArn, forKey: ClientRuntime.Key("TargetGroupArn"))
        }
        if let targetGroupName = targetGroupName {
            try container.encode(targetGroupName, forKey: ClientRuntime.Key("TargetGroupName"))
        }
        if let updatedDate = updatedDate {
            try container.encode(ClientRuntime.TimestampWrapper(updatedDate, format: .dateTime), forKey: ClientRuntime.Key("updatedDate"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBProxyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyName)
        dBProxyName = dBProxyNameDecoded
        let targetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetGroupName)
        targetGroupName = targetGroupNameDecoded
        let targetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetGroupArn)
        targetGroupArn = targetGroupArnDecoded
        let isDefaultDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let connectionPoolConfigDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ConnectionPoolConfigurationInfo.self, forKey: .connectionPoolConfig)
        connectionPoolConfig = connectionPoolConfigDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        var createdDateBuffer:ClientRuntime.Date? = nil
        if let createdDateDecoded = createdDateDecoded {
            createdDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createdDateDecoded, format: .dateTime)
        }
        createdDate = createdDateBuffer
        let updatedDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedDate)
        var updatedDateBuffer:ClientRuntime.Date? = nil
        if let updatedDateDecoded = updatedDateDecoded {
            updatedDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(updatedDateDecoded, format: .dateTime)
        }
        updatedDate = updatedDateBuffer
    }
}

extension RdsClientTypes {
    /// Represents a set of RDS DB instances, Aurora DB clusters, or both that a proxy can connect to. Currently, each target group is associated with exactly one RDS DB instance or Aurora DB cluster. This data type is used as a response element in the DescribeDBProxyTargetGroups action.
    public struct DBProxyTargetGroup: Swift.Equatable {
        /// The settings that determine the size and behavior of the connection pool for the target group.
        public var connectionPoolConfig: RdsClientTypes.ConnectionPoolConfigurationInfo?
        /// The date and time when the target group was first created.
        public var createdDate: ClientRuntime.Date?
        /// The identifier for the RDS proxy associated with this target group.
        public var dBProxyName: Swift.String?
        /// Whether this target group is the first one used for connection requests by the associated proxy. Because each proxy is currently associated with a single target group, currently this setting is always true.
        public var isDefault: Swift.Bool
        /// The current status of this target group. A status of available means the target group is correctly associated with a database. Other values indicate that you must wait for the target group to be ready, or take some action to resolve an issue.
        public var status: Swift.String?
        /// The Amazon Resource Name (ARN) representing the target group.
        public var targetGroupArn: Swift.String?
        /// The identifier for the target group. This name must be unique for all target groups owned by your Amazon Web Services account in the specified Amazon Web Services Region.
        public var targetGroupName: Swift.String?
        /// The date and time when the target group was last updated.
        public var updatedDate: ClientRuntime.Date?

        public init (
            connectionPoolConfig: RdsClientTypes.ConnectionPoolConfigurationInfo? = nil,
            createdDate: ClientRuntime.Date? = nil,
            dBProxyName: Swift.String? = nil,
            isDefault: Swift.Bool = false,
            status: Swift.String? = nil,
            targetGroupArn: Swift.String? = nil,
            targetGroupName: Swift.String? = nil,
            updatedDate: ClientRuntime.Date? = nil
        )
        {
            self.connectionPoolConfig = connectionPoolConfig
            self.createdDate = createdDate
            self.dBProxyName = dBProxyName
            self.isDefault = isDefault
            self.status = status
            self.targetGroupArn = targetGroupArn
            self.targetGroupName = targetGroupName
            self.updatedDate = updatedDate
        }
    }

}

extension DBProxyTargetGroupNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBProxyTargetGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified target group isn't available for a proxy owned by your Amazon Web Services account in the specified Amazon Web Services Region.
public struct DBProxyTargetGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyTargetGroupNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBProxyTargetGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBProxyTargetNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBProxyTargetNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified RDS DB instance or Aurora DB cluster isn't available for a proxy owned by your Amazon Web Services account in the specified Amazon Web Services Region.
public struct DBProxyTargetNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyTargetNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBProxyTargetNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBSecurityGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSecurityGroupArn = "DBSecurityGroupArn"
        case dBSecurityGroupDescription = "DBSecurityGroupDescription"
        case dBSecurityGroupName = "DBSecurityGroupName"
        case eC2SecurityGroups = "EC2SecurityGroups"
        case iPRanges = "IPRanges"
        case ownerId = "OwnerId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSecurityGroupArn = dBSecurityGroupArn {
            try container.encode(dBSecurityGroupArn, forKey: ClientRuntime.Key("DBSecurityGroupArn"))
        }
        if let dBSecurityGroupDescription = dBSecurityGroupDescription {
            try container.encode(dBSecurityGroupDescription, forKey: ClientRuntime.Key("DBSecurityGroupDescription"))
        }
        if let dBSecurityGroupName = dBSecurityGroupName {
            try container.encode(dBSecurityGroupName, forKey: ClientRuntime.Key("DBSecurityGroupName"))
        }
        if let eC2SecurityGroups = eC2SecurityGroups {
            var eC2SecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EC2SecurityGroups"))
            for (index0, ec2securitygroup0) in eC2SecurityGroups.enumerated() {
                try eC2SecurityGroupsContainer.encode(ec2securitygroup0, forKey: ClientRuntime.Key("EC2SecurityGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let iPRanges = iPRanges {
            var iPRangesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("IPRanges"))
            for (index0, iprange0) in iPRanges.enumerated() {
                try iPRangesContainer.encode(iprange0, forKey: ClientRuntime.Key("IPRange.\(index0.advanced(by: 1))"))
            }
        }
        if let ownerId = ownerId {
            try container.encode(ownerId, forKey: ClientRuntime.Key("OwnerId"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let dBSecurityGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSecurityGroupName)
        dBSecurityGroupName = dBSecurityGroupNameDecoded
        let dBSecurityGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSecurityGroupDescription)
        dBSecurityGroupDescription = dBSecurityGroupDescriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        if containerValues.contains(.eC2SecurityGroups) {
            struct KeyVal0{struct EC2SecurityGroup{}}
            let eC2SecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EC2SecurityGroup>.CodingKeys.self, forKey: .eC2SecurityGroups)
            if let eC2SecurityGroupsWrappedContainer = eC2SecurityGroupsWrappedContainer {
                let eC2SecurityGroupsContainer = try eC2SecurityGroupsWrappedContainer.decodeIfPresent([RdsClientTypes.EC2SecurityGroup].self, forKey: .member)
                var eC2SecurityGroupsBuffer:[RdsClientTypes.EC2SecurityGroup]? = nil
                if let eC2SecurityGroupsContainer = eC2SecurityGroupsContainer {
                    eC2SecurityGroupsBuffer = [RdsClientTypes.EC2SecurityGroup]()
                    for structureContainer0 in eC2SecurityGroupsContainer {
                        eC2SecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                eC2SecurityGroups = eC2SecurityGroupsBuffer
            } else {
                eC2SecurityGroups = []
            }
        } else {
            eC2SecurityGroups = nil
        }
        if containerValues.contains(.iPRanges) {
            struct KeyVal0{struct IPRange{}}
            let iPRangesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.IPRange>.CodingKeys.self, forKey: .iPRanges)
            if let iPRangesWrappedContainer = iPRangesWrappedContainer {
                let iPRangesContainer = try iPRangesWrappedContainer.decodeIfPresent([RdsClientTypes.IPRange].self, forKey: .member)
                var iPRangesBuffer:[RdsClientTypes.IPRange]? = nil
                if let iPRangesContainer = iPRangesContainer {
                    iPRangesBuffer = [RdsClientTypes.IPRange]()
                    for structureContainer0 in iPRangesContainer {
                        iPRangesBuffer?.append(structureContainer0)
                    }
                }
                iPRanges = iPRangesBuffer
            } else {
                iPRanges = []
            }
        } else {
            iPRanges = nil
        }
        let dBSecurityGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSecurityGroupArn)
        dBSecurityGroupArn = dBSecurityGroupArnDecoded
    }
}

extension RdsClientTypes {
    /// Contains the details for an Amazon RDS DB security group. This data type is used as a response element in the DescribeDBSecurityGroups action.
    public struct DBSecurityGroup: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the DB security group.
        public var dBSecurityGroupArn: Swift.String?
        /// Provides the description of the DB security group.
        public var dBSecurityGroupDescription: Swift.String?
        /// Specifies the name of the DB security group.
        public var dBSecurityGroupName: Swift.String?
        /// Contains a list of EC2SecurityGroup elements.
        public var eC2SecurityGroups: [RdsClientTypes.EC2SecurityGroup]?
        /// Contains a list of IPRange elements.
        public var iPRanges: [RdsClientTypes.IPRange]?
        /// Provides the Amazon Web Services ID of the owner of a specific DB security group.
        public var ownerId: Swift.String?
        /// Provides the VpcId of the DB security group.
        public var vpcId: Swift.String?

        public init (
            dBSecurityGroupArn: Swift.String? = nil,
            dBSecurityGroupDescription: Swift.String? = nil,
            dBSecurityGroupName: Swift.String? = nil,
            eC2SecurityGroups: [RdsClientTypes.EC2SecurityGroup]? = nil,
            iPRanges: [RdsClientTypes.IPRange]? = nil,
            ownerId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.dBSecurityGroupArn = dBSecurityGroupArn
            self.dBSecurityGroupDescription = dBSecurityGroupDescription
            self.dBSecurityGroupName = dBSecurityGroupName
            self.eC2SecurityGroups = eC2SecurityGroups
            self.iPRanges = iPRanges
            self.ownerId = ownerId
            self.vpcId = vpcId
        }
    }

}

extension DBSecurityGroupAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSecurityGroupAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A DB security group with the name specified in DBSecurityGroupName already exists.
public struct DBSecurityGroupAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSecurityGroupAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBSecurityGroupAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBSecurityGroupMembership: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSecurityGroupName = "DBSecurityGroupName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSecurityGroupName = dBSecurityGroupName {
            try container.encode(dBSecurityGroupName, forKey: ClientRuntime.Key("DBSecurityGroupName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSecurityGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSecurityGroupName)
        dBSecurityGroupName = dBSecurityGroupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension RdsClientTypes {
    /// This data type is used as a response element in the following actions:
    ///
    /// * ModifyDBInstance
    ///
    /// * RebootDBInstance
    ///
    /// * RestoreDBInstanceFromDBSnapshot
    ///
    /// * RestoreDBInstanceToPointInTime
    public struct DBSecurityGroupMembership: Swift.Equatable {
        /// The name of the DB security group.
        public var dBSecurityGroupName: Swift.String?
        /// The status of the DB security group.
        public var status: Swift.String?

        public init (
            dBSecurityGroupName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.dBSecurityGroupName = dBSecurityGroupName
            self.status = status
        }
    }

}

extension DBSecurityGroupNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSecurityGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// DBSecurityGroupName doesn't refer to an existing DB security group.
public struct DBSecurityGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSecurityGroupNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBSecurityGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSecurityGroupNotSupportedFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSecurityGroupNotSupportedFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A DB security group isn't allowed for this action.
public struct DBSecurityGroupNotSupportedFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSecurityGroupNotSupportedFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBSecurityGroupNotSupportedFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSecurityGroupQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSecurityGroupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would result in the user exceeding the allowed number of DB security groups.
public struct DBSecurityGroupQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSecurityGroupQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBSecurityGroupQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBSnapshot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case availabilityZone = "AvailabilityZone"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dBSnapshotArn = "DBSnapshotArn"
        case dBSnapshotIdentifier = "DBSnapshotIdentifier"
        case dbiResourceId = "DbiResourceId"
        case encrypted = "Encrypted"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case instanceCreateTime = "InstanceCreateTime"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case licenseModel = "LicenseModel"
        case masterUsername = "MasterUsername"
        case optionGroupName = "OptionGroupName"
        case originalSnapshotCreateTime = "OriginalSnapshotCreateTime"
        case percentProgress = "PercentProgress"
        case port = "Port"
        case processorFeatures = "ProcessorFeatures"
        case snapshotCreateTime = "SnapshotCreateTime"
        case snapshotTarget = "SnapshotTarget"
        case snapshotType = "SnapshotType"
        case sourceDBSnapshotIdentifier = "SourceDBSnapshotIdentifier"
        case sourceRegion = "SourceRegion"
        case status = "Status"
        case storageType = "StorageType"
        case tagList = "TagList"
        case tdeCredentialArn = "TdeCredentialArn"
        case timezone = "Timezone"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allocatedStorage != 0 {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBSnapshotArn = dBSnapshotArn {
            try container.encode(dBSnapshotArn, forKey: ClientRuntime.Key("DBSnapshotArn"))
        }
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: ClientRuntime.Key("DBSnapshotIdentifier"))
        }
        if let dbiResourceId = dbiResourceId {
            try container.encode(dbiResourceId, forKey: ClientRuntime.Key("DbiResourceId"))
        }
        if encrypted != false {
            try container.encode(encrypted, forKey: ClientRuntime.Key("Encrypted"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if iAMDatabaseAuthenticationEnabled != false {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: ClientRuntime.Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let instanceCreateTime = instanceCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(instanceCreateTime, format: .dateTime), forKey: ClientRuntime.Key("instanceCreateTime"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let originalSnapshotCreateTime = originalSnapshotCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(originalSnapshotCreateTime, format: .dateTime), forKey: ClientRuntime.Key("originalSnapshotCreateTime"))
        }
        if percentProgress != 0 {
            try container.encode(percentProgress, forKey: ClientRuntime.Key("PercentProgress"))
        }
        if port != 0 {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: ClientRuntime.Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let snapshotCreateTime = snapshotCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(snapshotCreateTime, format: .dateTime), forKey: ClientRuntime.Key("snapshotCreateTime"))
        }
        if let snapshotTarget = snapshotTarget {
            try container.encode(snapshotTarget, forKey: ClientRuntime.Key("SnapshotTarget"))
        }
        if let snapshotType = snapshotType {
            try container.encode(snapshotType, forKey: ClientRuntime.Key("SnapshotType"))
        }
        if let sourceDBSnapshotIdentifier = sourceDBSnapshotIdentifier {
            try container.encode(sourceDBSnapshotIdentifier, forKey: ClientRuntime.Key("SourceDBSnapshotIdentifier"))
        }
        if let sourceRegion = sourceRegion {
            try container.encode(sourceRegion, forKey: ClientRuntime.Key("SourceRegion"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tagList = tagList {
            var tagListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagList"))
            for (index0, tag0) in tagList.enumerated() {
                try tagListContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: ClientRuntime.Key("TdeCredentialArn"))
        }
        if let timezone = timezone {
            try container.encode(timezone, forKey: ClientRuntime.Key("Timezone"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSnapshotIdentifier)
        dBSnapshotIdentifier = dBSnapshotIdentifierDecoded
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotCreateTime)
        var snapshotCreateTimeBuffer:ClientRuntime.Date? = nil
        if let snapshotCreateTimeDecoded = snapshotCreateTimeDecoded {
            snapshotCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(snapshotCreateTimeDecoded, format: .dateTime)
        }
        snapshotCreateTime = snapshotCreateTimeBuffer
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let allocatedStorageDecoded = try containerValues.decode(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let instanceCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceCreateTime)
        var instanceCreateTimeBuffer:ClientRuntime.Date? = nil
        if let instanceCreateTimeDecoded = instanceCreateTimeDecoded {
            instanceCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(instanceCreateTimeDecoded, format: .dateTime)
        }
        instanceCreateTime = instanceCreateTimeBuffer
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let snapshotTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotType)
        snapshotType = snapshotTypeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let percentProgressDecoded = try containerValues.decode(Swift.Int.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let sourceRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceRegion)
        sourceRegion = sourceRegionDecoded
        let sourceDBSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDBSnapshotIdentifier)
        sourceDBSnapshotIdentifier = sourceDBSnapshotIdentifierDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let tdeCredentialArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tdeCredentialArn)
        tdeCredentialArn = tdeCredentialArnDecoded
        let encryptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dBSnapshotArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSnapshotArn)
        dBSnapshotArn = dBSnapshotArnDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        if containerValues.contains(.processorFeatures) {
            struct KeyVal0{struct ProcessorFeature{}}
            let processorFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ProcessorFeature>.CodingKeys.self, forKey: .processorFeatures)
            if let processorFeaturesWrappedContainer = processorFeaturesWrappedContainer {
                let processorFeaturesContainer = try processorFeaturesWrappedContainer.decodeIfPresent([RdsClientTypes.ProcessorFeature].self, forKey: .member)
                var processorFeaturesBuffer:[RdsClientTypes.ProcessorFeature]? = nil
                if let processorFeaturesContainer = processorFeaturesContainer {
                    processorFeaturesBuffer = [RdsClientTypes.ProcessorFeature]()
                    for structureContainer0 in processorFeaturesContainer {
                        processorFeaturesBuffer?.append(structureContainer0)
                    }
                }
                processorFeatures = processorFeaturesBuffer
            } else {
                processorFeatures = []
            }
        } else {
            processorFeatures = nil
        }
        let dbiResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbiResourceId)
        dbiResourceId = dbiResourceIdDecoded
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagListBuffer:[RdsClientTypes.Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
        let originalSnapshotCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originalSnapshotCreateTime)
        var originalSnapshotCreateTimeBuffer:ClientRuntime.Date? = nil
        if let originalSnapshotCreateTimeDecoded = originalSnapshotCreateTimeDecoded {
            originalSnapshotCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(originalSnapshotCreateTimeDecoded, format: .dateTime)
        }
        originalSnapshotCreateTime = originalSnapshotCreateTimeBuffer
        let snapshotTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotTarget)
        snapshotTarget = snapshotTargetDecoded
    }
}

extension RdsClientTypes {
    /// Contains the details of an Amazon RDS DB snapshot. This data type is used as a response element in the DescribeDBSnapshots action.
    public struct DBSnapshot: Swift.Equatable {
        /// Specifies the allocated storage size in gibibytes (GiB).
        public var allocatedStorage: Swift.Int
        /// Specifies the name of the Availability Zone the DB instance was located in at the time of the DB snapshot.
        public var availabilityZone: Swift.String?
        /// Specifies the DB instance identifier of the DB instance this DB snapshot was created from.
        public var dBInstanceIdentifier: Swift.String?
        /// The Amazon Resource Name (ARN) for the DB snapshot.
        public var dBSnapshotArn: Swift.String?
        /// Specifies the identifier for the DB snapshot.
        public var dBSnapshotIdentifier: Swift.String?
        /// The identifier for the source DB instance, which can't be changed and which is unique to an Amazon Web Services Region.
        public var dbiResourceId: Swift.String?
        /// Specifies whether the DB snapshot is encrypted.
        public var encrypted: Swift.Bool
        /// Specifies the name of the database engine.
        public var engine: Swift.String?
        /// Specifies the version of the database engine.
        public var engineVersion: Swift.String?
        /// True if mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled, and otherwise false.
        public var iAMDatabaseAuthenticationEnabled: Swift.Bool
        /// Specifies the time in Coordinated Universal Time (UTC) when the DB instance, from which the snapshot was taken, was created.
        public var instanceCreateTime: ClientRuntime.Date?
        /// Specifies the Provisioned IOPS (I/O operations per second) value of the DB instance at the time of the snapshot.
        public var iops: Swift.Int?
        /// If Encrypted is true, the Amazon Web Services KMS key identifier for the encrypted DB snapshot. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        public var kmsKeyId: Swift.String?
        /// License model information for the restored DB instance.
        public var licenseModel: Swift.String?
        /// Provides the master username for the DB snapshot.
        public var masterUsername: Swift.String?
        /// Provides the option group name for the DB snapshot.
        public var optionGroupName: Swift.String?
        /// Specifies the time of the CreateDBSnapshot operation in Coordinated Universal Time (UTC). Doesn't change when the snapshot is copied.
        public var originalSnapshotCreateTime: ClientRuntime.Date?
        /// The percentage of the estimated data that has been transferred.
        public var percentProgress: Swift.Int
        /// Specifies the port that the database engine was listening on at the time of the snapshot.
        public var port: Swift.Int
        /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance when the DB snapshot was created.
        public var processorFeatures: [RdsClientTypes.ProcessorFeature]?
        /// Specifies when the snapshot was taken in Coordinated Universal Time (UTC). Changes for the copy when the snapshot is copied.
        public var snapshotCreateTime: ClientRuntime.Date?
        /// Specifies where manual snapshots are stored: Amazon Web Services Outposts or the Amazon Web Services Region.
        public var snapshotTarget: Swift.String?
        /// Provides the type of the DB snapshot.
        public var snapshotType: Swift.String?
        /// The DB snapshot Amazon Resource Name (ARN) that the DB snapshot was copied from. It only has a value in the case of a cross-account or cross-Region copy.
        public var sourceDBSnapshotIdentifier: Swift.String?
        /// The Amazon Web Services Region that the DB snapshot was created in or copied from.
        public var sourceRegion: Swift.String?
        /// Specifies the status of this DB snapshot.
        public var status: Swift.String?
        /// Specifies the storage type associated with DB snapshot.
        public var storageType: Swift.String?
        /// A list of tags. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
        public var tagList: [RdsClientTypes.Tag]?
        /// The ARN from the key store with which to associate the instance for TDE encryption.
        public var tdeCredentialArn: Swift.String?
        /// The time zone of the DB snapshot. In most cases, the Timezone element is empty. Timezone content appears only for snapshots taken from Microsoft SQL Server DB instances that were created with a time zone specified.
        public var timezone: Swift.String?
        /// Provides the VPC ID associated with the DB snapshot.
        public var vpcId: Swift.String?

        public init (
            allocatedStorage: Swift.Int = 0,
            availabilityZone: Swift.String? = nil,
            dBInstanceIdentifier: Swift.String? = nil,
            dBSnapshotArn: Swift.String? = nil,
            dBSnapshotIdentifier: Swift.String? = nil,
            dbiResourceId: Swift.String? = nil,
            encrypted: Swift.Bool = false,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            iAMDatabaseAuthenticationEnabled: Swift.Bool = false,
            instanceCreateTime: ClientRuntime.Date? = nil,
            iops: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            licenseModel: Swift.String? = nil,
            masterUsername: Swift.String? = nil,
            optionGroupName: Swift.String? = nil,
            originalSnapshotCreateTime: ClientRuntime.Date? = nil,
            percentProgress: Swift.Int = 0,
            port: Swift.Int = 0,
            processorFeatures: [RdsClientTypes.ProcessorFeature]? = nil,
            snapshotCreateTime: ClientRuntime.Date? = nil,
            snapshotTarget: Swift.String? = nil,
            snapshotType: Swift.String? = nil,
            sourceDBSnapshotIdentifier: Swift.String? = nil,
            sourceRegion: Swift.String? = nil,
            status: Swift.String? = nil,
            storageType: Swift.String? = nil,
            tagList: [RdsClientTypes.Tag]? = nil,
            tdeCredentialArn: Swift.String? = nil,
            timezone: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.availabilityZone = availabilityZone
            self.dBInstanceIdentifier = dBInstanceIdentifier
            self.dBSnapshotArn = dBSnapshotArn
            self.dBSnapshotIdentifier = dBSnapshotIdentifier
            self.dbiResourceId = dbiResourceId
            self.encrypted = encrypted
            self.engine = engine
            self.engineVersion = engineVersion
            self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
            self.instanceCreateTime = instanceCreateTime
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.licenseModel = licenseModel
            self.masterUsername = masterUsername
            self.optionGroupName = optionGroupName
            self.originalSnapshotCreateTime = originalSnapshotCreateTime
            self.percentProgress = percentProgress
            self.port = port
            self.processorFeatures = processorFeatures
            self.snapshotCreateTime = snapshotCreateTime
            self.snapshotTarget = snapshotTarget
            self.snapshotType = snapshotType
            self.sourceDBSnapshotIdentifier = sourceDBSnapshotIdentifier
            self.sourceRegion = sourceRegion
            self.status = status
            self.storageType = storageType
            self.tagList = tagList
            self.tdeCredentialArn = tdeCredentialArn
            self.timezone = timezone
            self.vpcId = vpcId
        }
    }

}

extension DBSnapshotAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSnapshotAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// DBSnapshotIdentifier is already used by an existing snapshot.
public struct DBSnapshotAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSnapshotAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBSnapshotAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBSnapshotAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeValues = "AttributeValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: ClientRuntime.Key("AttributeName"))
        }
        if let attributeValues = attributeValues {
            var attributeValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttributeValues"))
            for (index0, string0) in attributeValues.enumerated() {
                try attributeValuesContainer.encode(string0, forKey: ClientRuntime.Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        if containerValues.contains(.attributeValues) {
            struct KeyVal0{struct AttributeValue{}}
            let attributeValuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AttributeValue>.CodingKeys.self, forKey: .attributeValues)
            if let attributeValuesWrappedContainer = attributeValuesWrappedContainer {
                let attributeValuesContainer = try attributeValuesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var attributeValuesBuffer:[Swift.String]? = nil
                if let attributeValuesContainer = attributeValuesContainer {
                    attributeValuesBuffer = [Swift.String]()
                    for stringContainer0 in attributeValuesContainer {
                        attributeValuesBuffer?.append(stringContainer0)
                    }
                }
                attributeValues = attributeValuesBuffer
            } else {
                attributeValues = []
            }
        } else {
            attributeValues = nil
        }
    }
}

extension RdsClientTypes {
    /// Contains the name and values of a manual DB snapshot attribute Manual DB snapshot attributes are used to authorize other Amazon Web Services accounts to restore a manual DB snapshot. For more information, see the ModifyDBSnapshotAttribute API.
    public struct DBSnapshotAttribute: Swift.Equatable {
        /// The name of the manual DB snapshot attribute. The attribute named restore refers to the list of Amazon Web Services accounts that have permission to copy or restore the manual DB cluster snapshot. For more information, see the ModifyDBSnapshotAttribute API action.
        public var attributeName: Swift.String?
        /// The value or values for the manual DB snapshot attribute. If the AttributeName field is set to restore, then this element returns a list of IDs of the Amazon Web Services accounts that are authorized to copy or restore the manual DB snapshot. If a value of all is in the list, then the manual DB snapshot is public and available for any Amazon Web Services account to copy or restore.
        public var attributeValues: [Swift.String]?

        public init (
            attributeName: Swift.String? = nil,
            attributeValues: [Swift.String]? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeValues = attributeValues
        }
    }

}

extension RdsClientTypes.DBSnapshotAttributesResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSnapshotAttributes = "DBSnapshotAttributes"
        case dBSnapshotIdentifier = "DBSnapshotIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSnapshotAttributes = dBSnapshotAttributes {
            var dBSnapshotAttributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBSnapshotAttributes"))
            for (index0, dbsnapshotattribute0) in dBSnapshotAttributes.enumerated() {
                try dBSnapshotAttributesContainer.encode(dbsnapshotattribute0, forKey: ClientRuntime.Key("DBSnapshotAttribute.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: ClientRuntime.Key("DBSnapshotIdentifier"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSnapshotIdentifier)
        dBSnapshotIdentifier = dBSnapshotIdentifierDecoded
        if containerValues.contains(.dBSnapshotAttributes) {
            struct KeyVal0{struct DBSnapshotAttribute{}}
            let dBSnapshotAttributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSnapshotAttribute>.CodingKeys.self, forKey: .dBSnapshotAttributes)
            if let dBSnapshotAttributesWrappedContainer = dBSnapshotAttributesWrappedContainer {
                let dBSnapshotAttributesContainer = try dBSnapshotAttributesWrappedContainer.decodeIfPresent([RdsClientTypes.DBSnapshotAttribute].self, forKey: .member)
                var dBSnapshotAttributesBuffer:[RdsClientTypes.DBSnapshotAttribute]? = nil
                if let dBSnapshotAttributesContainer = dBSnapshotAttributesContainer {
                    dBSnapshotAttributesBuffer = [RdsClientTypes.DBSnapshotAttribute]()
                    for structureContainer0 in dBSnapshotAttributesContainer {
                        dBSnapshotAttributesBuffer?.append(structureContainer0)
                    }
                }
                dBSnapshotAttributes = dBSnapshotAttributesBuffer
            } else {
                dBSnapshotAttributes = []
            }
        } else {
            dBSnapshotAttributes = nil
        }
    }
}

extension RdsClientTypes {
    /// Contains the results of a successful call to the DescribeDBSnapshotAttributes API action. Manual DB snapshot attributes are used to authorize other Amazon Web Services accounts to copy or restore a manual DB snapshot. For more information, see the ModifyDBSnapshotAttribute API action.
    public struct DBSnapshotAttributesResult: Swift.Equatable {
        /// The list of attributes and values for the manual DB snapshot.
        public var dBSnapshotAttributes: [RdsClientTypes.DBSnapshotAttribute]?
        /// The identifier of the manual DB snapshot that the attributes apply to.
        public var dBSnapshotIdentifier: Swift.String?

        public init (
            dBSnapshotAttributes: [RdsClientTypes.DBSnapshotAttribute]? = nil,
            dBSnapshotIdentifier: Swift.String? = nil
        )
        {
            self.dBSnapshotAttributes = dBSnapshotAttributes
            self.dBSnapshotIdentifier = dBSnapshotIdentifier
        }
    }

}

extension DBSnapshotNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSnapshotNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// DBSnapshotIdentifier doesn't refer to an existing DB snapshot.
public struct DBSnapshotNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSnapshotNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBSnapshotNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBSubnetGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSubnetGroupArn = "DBSubnetGroupArn"
        case dBSubnetGroupDescription = "DBSubnetGroupDescription"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case subnetGroupStatus = "SubnetGroupStatus"
        case subnets = "Subnets"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSubnetGroupArn = dBSubnetGroupArn {
            try container.encode(dBSubnetGroupArn, forKey: ClientRuntime.Key("DBSubnetGroupArn"))
        }
        if let dBSubnetGroupDescription = dBSubnetGroupDescription {
            try container.encode(dBSubnetGroupDescription, forKey: ClientRuntime.Key("DBSubnetGroupDescription"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let subnetGroupStatus = subnetGroupStatus {
            try container.encode(subnetGroupStatus, forKey: ClientRuntime.Key("SubnetGroupStatus"))
        }
        if let subnets = subnets {
            var subnetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Subnets"))
            for (index0, subnet0) in subnets.enumerated() {
                try subnetsContainer.encode(subnet0, forKey: ClientRuntime.Key("Subnet.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        let dBSubnetGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupDescription)
        dBSubnetGroupDescription = dBSubnetGroupDescriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetGroupStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupStatus)
        subnetGroupStatus = subnetGroupStatusDecoded
        if containerValues.contains(.subnets) {
            struct KeyVal0{struct Subnet{}}
            let subnetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Subnet>.CodingKeys.self, forKey: .subnets)
            if let subnetsWrappedContainer = subnetsWrappedContainer {
                let subnetsContainer = try subnetsWrappedContainer.decodeIfPresent([RdsClientTypes.Subnet].self, forKey: .member)
                var subnetsBuffer:[RdsClientTypes.Subnet]? = nil
                if let subnetsContainer = subnetsContainer {
                    subnetsBuffer = [RdsClientTypes.Subnet]()
                    for structureContainer0 in subnetsContainer {
                        subnetsBuffer?.append(structureContainer0)
                    }
                }
                subnets = subnetsBuffer
            } else {
                subnets = []
            }
        } else {
            subnets = nil
        }
        let dBSubnetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupArn)
        dBSubnetGroupArn = dBSubnetGroupArnDecoded
    }
}

extension RdsClientTypes {
    /// Contains the details of an Amazon RDS DB subnet group. This data type is used as a response element in the DescribeDBSubnetGroups action.
    public struct DBSubnetGroup: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the DB subnet group.
        public var dBSubnetGroupArn: Swift.String?
        /// Provides the description of the DB subnet group.
        public var dBSubnetGroupDescription: Swift.String?
        /// The name of the DB subnet group.
        public var dBSubnetGroupName: Swift.String?
        /// Provides the status of the DB subnet group.
        public var subnetGroupStatus: Swift.String?
        /// Contains a list of Subnet elements.
        public var subnets: [RdsClientTypes.Subnet]?
        /// Provides the VpcId of the DB subnet group.
        public var vpcId: Swift.String?

        public init (
            dBSubnetGroupArn: Swift.String? = nil,
            dBSubnetGroupDescription: Swift.String? = nil,
            dBSubnetGroupName: Swift.String? = nil,
            subnetGroupStatus: Swift.String? = nil,
            subnets: [RdsClientTypes.Subnet]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.dBSubnetGroupArn = dBSubnetGroupArn
            self.dBSubnetGroupDescription = dBSubnetGroupDescription
            self.dBSubnetGroupName = dBSubnetGroupName
            self.subnetGroupStatus = subnetGroupStatus
            self.subnets = subnets
            self.vpcId = vpcId
        }
    }

}

extension DBSubnetGroupAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSubnetGroupAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// DBSubnetGroupName is already used by an existing DB subnet group.
public struct DBSubnetGroupAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetGroupAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBSubnetGroupAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetGroupDoesNotCoverEnoughAZs {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSubnetGroupDoesNotCoverEnoughAZsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Subnets in the DB subnet group should cover at least two Availability Zones unless there is only one Availability Zone.
public struct DBSubnetGroupDoesNotCoverEnoughAZs: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetGroupDoesNotCoverEnoughAZsBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBSubnetGroupDoesNotCoverEnoughAZsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetGroupNotAllowedFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSubnetGroupNotAllowedFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DBSubnetGroup shouldn't be specified while creating read replicas that lie in the same region as the source instance.
public struct DBSubnetGroupNotAllowedFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetGroupNotAllowedFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBSubnetGroupNotAllowedFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetGroupNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSubnetGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// DBSubnetGroupName doesn't refer to an existing DB subnet group.
public struct DBSubnetGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetGroupNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBSubnetGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetGroupQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSubnetGroupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would result in the user exceeding the allowed number of DB subnet groups.
public struct DBSubnetGroupQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetGroupQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBSubnetGroupQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSubnetQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would result in the user exceeding the allowed number of subnets in a DB subnet groups.
public struct DBSubnetQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBSubnetQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBUpgradeDependencyFailureFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBUpgradeDependencyFailureFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DB upgrade failed because a resource the DB depends on can't be modified.
public struct DBUpgradeDependencyFailureFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBUpgradeDependencyFailureFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DBUpgradeDependencyFailureFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteCustomAvailabilityZoneInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let customAvailabilityZoneId = customAvailabilityZoneId {
            try container.encode(customAvailabilityZoneId, forKey: ClientRuntime.Key("CustomAvailabilityZoneId"))
        }
        try container.encode("DeleteCustomAvailabilityZone", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteCustomAvailabilityZoneInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCustomAvailabilityZoneInput: Swift.Equatable {
    /// The custom AZ identifier.
    /// This member is required.
    public var customAvailabilityZoneId: Swift.String?

    public init (
        customAvailabilityZoneId: Swift.String? = nil
    )
    {
        self.customAvailabilityZoneId = customAvailabilityZoneId
    }
}

struct DeleteCustomAvailabilityZoneInputBody: Swift.Equatable {
    let customAvailabilityZoneId: Swift.String?
}

extension DeleteCustomAvailabilityZoneInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customAvailabilityZoneId = "CustomAvailabilityZoneId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customAvailabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customAvailabilityZoneId)
        customAvailabilityZoneId = customAvailabilityZoneIdDecoded
    }
}

extension DeleteCustomAvailabilityZoneOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteCustomAvailabilityZoneOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CustomAvailabilityZoneNotFound" : self = .customAvailabilityZoneNotFoundFault(try CustomAvailabilityZoneNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCustomAvailabilityZoneOutputError: Swift.Error, Swift.Equatable {
    case customAvailabilityZoneNotFoundFault(CustomAvailabilityZoneNotFoundFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomAvailabilityZoneOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteCustomAvailabilityZoneOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customAvailabilityZone = output.customAvailabilityZone
        } else {
            self.customAvailabilityZone = nil
        }
    }
}

public struct DeleteCustomAvailabilityZoneOutputResponse: Swift.Equatable {
    /// A custom Availability Zone (AZ) is an on-premises AZ that is integrated with a VMware vSphere cluster. For more information about RDS on VMware, see the [ RDS on VMware User Guide.](https://docs.aws.amazon.com/AmazonRDS/latest/RDSonVMwareUserGuide/rds-on-vmware.html)
    public var customAvailabilityZone: RdsClientTypes.CustomAvailabilityZone?

    public init (
        customAvailabilityZone: RdsClientTypes.CustomAvailabilityZone? = nil
    )
    {
        self.customAvailabilityZone = customAvailabilityZone
    }
}

struct DeleteCustomAvailabilityZoneOutputResponseBody: Swift.Equatable {
    let customAvailabilityZone: RdsClientTypes.CustomAvailabilityZone?
}

extension DeleteCustomAvailabilityZoneOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customAvailabilityZone = "CustomAvailabilityZone"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteCustomAvailabilityZoneResult"))
        let customAvailabilityZoneDecoded = try containerValues.decodeIfPresent(RdsClientTypes.CustomAvailabilityZone.self, forKey: .customAvailabilityZone)
        customAvailabilityZone = customAvailabilityZoneDecoded
    }
}

extension DeleteCustomDBEngineVersionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        try container.encode("DeleteCustomDBEngineVersion", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteCustomDBEngineVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCustomDBEngineVersionInput: Swift.Equatable {
    /// The database engine. The only supported engine is custom-oracle-ee.
    /// This member is required.
    public var engine: Swift.String?
    /// The custom engine version (CEV) for your DB instance. This option is required for RDS Custom, but optional for Amazon RDS. The combination of Engine and EngineVersion is unique per customer per Amazon Web Services Region.
    /// This member is required.
    public var engineVersion: Swift.String?

    public init (
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil
    )
    {
        self.engine = engine
        self.engineVersion = engineVersion
    }
}

struct DeleteCustomDBEngineVersionInputBody: Swift.Equatable {
    let engine: Swift.String?
    let engineVersion: Swift.String?
}

extension DeleteCustomDBEngineVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engine = "Engine"
        case engineVersion = "EngineVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
    }
}

extension DeleteCustomDBEngineVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteCustomDBEngineVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CustomDBEngineVersionNotFoundFault" : self = .customDBEngineVersionNotFoundFault(try CustomDBEngineVersionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCustomDBEngineVersionStateFault" : self = .invalidCustomDBEngineVersionStateFault(try InvalidCustomDBEngineVersionStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCustomDBEngineVersionOutputError: Swift.Error, Swift.Equatable {
    case customDBEngineVersionNotFoundFault(CustomDBEngineVersionNotFoundFault)
    case invalidCustomDBEngineVersionStateFault(InvalidCustomDBEngineVersionStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomDBEngineVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteCustomDBEngineVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.dBEngineDescription = output.dBEngineDescription
            self.dBEngineVersionArn = output.dBEngineVersionArn
            self.dBEngineVersionDescription = output.dBEngineVersionDescription
            self.dBParameterGroupFamily = output.dBParameterGroupFamily
            self.databaseInstallationFilesS3BucketName = output.databaseInstallationFilesS3BucketName
            self.databaseInstallationFilesS3Prefix = output.databaseInstallationFilesS3Prefix
            self.defaultCharacterSet = output.defaultCharacterSet
            self.engine = output.engine
            self.engineVersion = output.engineVersion
            self.exportableLogTypes = output.exportableLogTypes
            self.kMSKeyId = output.kMSKeyId
            self.majorEngineVersion = output.majorEngineVersion
            self.status = output.status
            self.supportedCharacterSets = output.supportedCharacterSets
            self.supportedEngineModes = output.supportedEngineModes
            self.supportedFeatureNames = output.supportedFeatureNames
            self.supportedNcharCharacterSets = output.supportedNcharCharacterSets
            self.supportedTimezones = output.supportedTimezones
            self.supportsGlobalDatabases = output.supportsGlobalDatabases
            self.supportsLogExportsToCloudwatchLogs = output.supportsLogExportsToCloudwatchLogs
            self.supportsParallelQuery = output.supportsParallelQuery
            self.supportsReadReplica = output.supportsReadReplica
            self.tagList = output.tagList
            self.validUpgradeTarget = output.validUpgradeTarget
        } else {
            self.createTime = nil
            self.dBEngineDescription = nil
            self.dBEngineVersionArn = nil
            self.dBEngineVersionDescription = nil
            self.dBParameterGroupFamily = nil
            self.databaseInstallationFilesS3BucketName = nil
            self.databaseInstallationFilesS3Prefix = nil
            self.defaultCharacterSet = nil
            self.engine = nil
            self.engineVersion = nil
            self.exportableLogTypes = nil
            self.kMSKeyId = nil
            self.majorEngineVersion = nil
            self.status = nil
            self.supportedCharacterSets = nil
            self.supportedEngineModes = nil
            self.supportedFeatureNames = nil
            self.supportedNcharCharacterSets = nil
            self.supportedTimezones = nil
            self.supportsGlobalDatabases = false
            self.supportsLogExportsToCloudwatchLogs = false
            self.supportsParallelQuery = false
            self.supportsReadReplica = false
            self.tagList = nil
            self.validUpgradeTarget = nil
        }
    }
}

/// This data type is used as a response element in the action DescribeDBEngineVersions.
public struct DeleteCustomDBEngineVersionOutputResponse: Swift.Equatable {
    /// The creation time of the DB engine version.
    public var createTime: ClientRuntime.Date?
    /// The description of the database engine.
    public var dBEngineDescription: Swift.String?
    /// The ARN of the custom engine version.
    public var dBEngineVersionArn: Swift.String?
    /// The description of the database engine version.
    public var dBEngineVersionDescription: Swift.String?
    /// The name of the DB parameter group family for the database engine.
    public var dBParameterGroupFamily: Swift.String?
    /// The name of the Amazon S3 bucket that contains your database installation files.
    public var databaseInstallationFilesS3BucketName: Swift.String?
    /// The Amazon S3 directory that contains the database installation files. If not specified, then no prefix is assumed.
    public var databaseInstallationFilesS3Prefix: Swift.String?
    /// The default character set for new instances of this engine version, if the CharacterSetName parameter of the CreateDBInstance API isn't specified.
    public var defaultCharacterSet: RdsClientTypes.CharacterSet?
    /// The name of the database engine.
    public var engine: Swift.String?
    /// The version number of the database engine.
    public var engineVersion: Swift.String?
    /// The types of logs that the database engine has available for export to CloudWatch Logs.
    public var exportableLogTypes: [Swift.String]?
    /// The Amazon Web Services KMS key identifier for an encrypted CEV. This parameter is required for RDS Custom, but optional for Amazon RDS.
    public var kMSKeyId: Swift.String?
    /// The major engine version of the CEV.
    public var majorEngineVersion: Swift.String?
    /// The status of the DB engine version, either available or deprecated.
    public var status: Swift.String?
    /// A list of the character sets supported by this engine for the CharacterSetName parameter of the CreateDBInstance operation.
    public var supportedCharacterSets: [RdsClientTypes.CharacterSet]?
    /// A list of the supported DB engine modes.
    public var supportedEngineModes: [Swift.String]?
    /// A list of features supported by the DB engine. The supported features vary by DB engine and DB engine version. To determine the supported features for a specific DB engine and DB engine version using the CLI, use the following command: aws rds describe-db-engine-versions --engine --engine-version  For example, to determine the supported features for RDS for PostgreSQL version 13.3 using the CLI, use the following command: aws rds describe-db-engine-versions --engine postgres --engine-version 13.3 The supported features are listed under SupportedFeatureNames in the output.
    public var supportedFeatureNames: [Swift.String]?
    /// A list of the character sets supported by the Oracle DB engine for the NcharCharacterSetName parameter of the CreateDBInstance operation.
    public var supportedNcharCharacterSets: [RdsClientTypes.CharacterSet]?
    /// A list of the time zones supported by this engine for the Timezone parameter of the CreateDBInstance action.
    public var supportedTimezones: [RdsClientTypes.Timezone]?
    /// A value that indicates whether you can use Aurora global databases with a specific DB engine version.
    public var supportsGlobalDatabases: Swift.Bool
    /// A value that indicates whether the engine version supports exporting the log types specified by ExportableLogTypes to CloudWatch Logs.
    public var supportsLogExportsToCloudwatchLogs: Swift.Bool
    /// A value that indicates whether you can use Aurora parallel query with a specific DB engine version.
    public var supportsParallelQuery: Swift.Bool
    /// Indicates whether the database engine version supports read replicas.
    public var supportsReadReplica: Swift.Bool
    /// A list of tags. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
    public var tagList: [RdsClientTypes.Tag]?
    /// A list of engine versions that this database engine version can be upgraded to.
    public var validUpgradeTarget: [RdsClientTypes.UpgradeTarget]?

    public init (
        createTime: ClientRuntime.Date? = nil,
        dBEngineDescription: Swift.String? = nil,
        dBEngineVersionArn: Swift.String? = nil,
        dBEngineVersionDescription: Swift.String? = nil,
        dBParameterGroupFamily: Swift.String? = nil,
        databaseInstallationFilesS3BucketName: Swift.String? = nil,
        databaseInstallationFilesS3Prefix: Swift.String? = nil,
        defaultCharacterSet: RdsClientTypes.CharacterSet? = nil,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        exportableLogTypes: [Swift.String]? = nil,
        kMSKeyId: Swift.String? = nil,
        majorEngineVersion: Swift.String? = nil,
        status: Swift.String? = nil,
        supportedCharacterSets: [RdsClientTypes.CharacterSet]? = nil,
        supportedEngineModes: [Swift.String]? = nil,
        supportedFeatureNames: [Swift.String]? = nil,
        supportedNcharCharacterSets: [RdsClientTypes.CharacterSet]? = nil,
        supportedTimezones: [RdsClientTypes.Timezone]? = nil,
        supportsGlobalDatabases: Swift.Bool = false,
        supportsLogExportsToCloudwatchLogs: Swift.Bool = false,
        supportsParallelQuery: Swift.Bool = false,
        supportsReadReplica: Swift.Bool = false,
        tagList: [RdsClientTypes.Tag]? = nil,
        validUpgradeTarget: [RdsClientTypes.UpgradeTarget]? = nil
    )
    {
        self.createTime = createTime
        self.dBEngineDescription = dBEngineDescription
        self.dBEngineVersionArn = dBEngineVersionArn
        self.dBEngineVersionDescription = dBEngineVersionDescription
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.databaseInstallationFilesS3BucketName = databaseInstallationFilesS3BucketName
        self.databaseInstallationFilesS3Prefix = databaseInstallationFilesS3Prefix
        self.defaultCharacterSet = defaultCharacterSet
        self.engine = engine
        self.engineVersion = engineVersion
        self.exportableLogTypes = exportableLogTypes
        self.kMSKeyId = kMSKeyId
        self.majorEngineVersion = majorEngineVersion
        self.status = status
        self.supportedCharacterSets = supportedCharacterSets
        self.supportedEngineModes = supportedEngineModes
        self.supportedFeatureNames = supportedFeatureNames
        self.supportedNcharCharacterSets = supportedNcharCharacterSets
        self.supportedTimezones = supportedTimezones
        self.supportsGlobalDatabases = supportsGlobalDatabases
        self.supportsLogExportsToCloudwatchLogs = supportsLogExportsToCloudwatchLogs
        self.supportsParallelQuery = supportsParallelQuery
        self.supportsReadReplica = supportsReadReplica
        self.tagList = tagList
        self.validUpgradeTarget = validUpgradeTarget
    }
}

struct DeleteCustomDBEngineVersionOutputResponseBody: Swift.Equatable {
    let engine: Swift.String?
    let engineVersion: Swift.String?
    let dBParameterGroupFamily: Swift.String?
    let dBEngineDescription: Swift.String?
    let dBEngineVersionDescription: Swift.String?
    let defaultCharacterSet: RdsClientTypes.CharacterSet?
    let supportedCharacterSets: [RdsClientTypes.CharacterSet]?
    let supportedNcharCharacterSets: [RdsClientTypes.CharacterSet]?
    let validUpgradeTarget: [RdsClientTypes.UpgradeTarget]?
    let supportedTimezones: [RdsClientTypes.Timezone]?
    let exportableLogTypes: [Swift.String]?
    let supportsLogExportsToCloudwatchLogs: Swift.Bool
    let supportsReadReplica: Swift.Bool
    let supportedEngineModes: [Swift.String]?
    let supportedFeatureNames: [Swift.String]?
    let status: Swift.String?
    let supportsParallelQuery: Swift.Bool
    let supportsGlobalDatabases: Swift.Bool
    let majorEngineVersion: Swift.String?
    let databaseInstallationFilesS3BucketName: Swift.String?
    let databaseInstallationFilesS3Prefix: Swift.String?
    let dBEngineVersionArn: Swift.String?
    let kMSKeyId: Swift.String?
    let createTime: ClientRuntime.Date?
    let tagList: [RdsClientTypes.Tag]?
}

extension DeleteCustomDBEngineVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case dBEngineDescription = "DBEngineDescription"
        case dBEngineVersionArn = "DBEngineVersionArn"
        case dBEngineVersionDescription = "DBEngineVersionDescription"
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case databaseInstallationFilesS3BucketName = "DatabaseInstallationFilesS3BucketName"
        case databaseInstallationFilesS3Prefix = "DatabaseInstallationFilesS3Prefix"
        case defaultCharacterSet = "DefaultCharacterSet"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case exportableLogTypes = "ExportableLogTypes"
        case kMSKeyId = "KMSKeyId"
        case majorEngineVersion = "MajorEngineVersion"
        case status = "Status"
        case supportedCharacterSets = "SupportedCharacterSets"
        case supportedEngineModes = "SupportedEngineModes"
        case supportedFeatureNames = "SupportedFeatureNames"
        case supportedNcharCharacterSets = "SupportedNcharCharacterSets"
        case supportedTimezones = "SupportedTimezones"
        case supportsGlobalDatabases = "SupportsGlobalDatabases"
        case supportsLogExportsToCloudwatchLogs = "SupportsLogExportsToCloudwatchLogs"
        case supportsParallelQuery = "SupportsParallelQuery"
        case supportsReadReplica = "SupportsReadReplica"
        case tagList = "TagList"
        case validUpgradeTarget = "ValidUpgradeTarget"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteCustomDBEngineVersionResult"))
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let dBEngineDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBEngineDescription)
        dBEngineDescription = dBEngineDescriptionDecoded
        let dBEngineVersionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBEngineVersionDescription)
        dBEngineVersionDescription = dBEngineVersionDescriptionDecoded
        let defaultCharacterSetDecoded = try containerValues.decodeIfPresent(RdsClientTypes.CharacterSet.self, forKey: .defaultCharacterSet)
        defaultCharacterSet = defaultCharacterSetDecoded
        if containerValues.contains(.supportedCharacterSets) {
            struct KeyVal0{struct CharacterSet{}}
            let supportedCharacterSetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CharacterSet>.CodingKeys.self, forKey: .supportedCharacterSets)
            if let supportedCharacterSetsWrappedContainer = supportedCharacterSetsWrappedContainer {
                let supportedCharacterSetsContainer = try supportedCharacterSetsWrappedContainer.decodeIfPresent([RdsClientTypes.CharacterSet].self, forKey: .member)
                var supportedCharacterSetsBuffer:[RdsClientTypes.CharacterSet]? = nil
                if let supportedCharacterSetsContainer = supportedCharacterSetsContainer {
                    supportedCharacterSetsBuffer = [RdsClientTypes.CharacterSet]()
                    for structureContainer0 in supportedCharacterSetsContainer {
                        supportedCharacterSetsBuffer?.append(structureContainer0)
                    }
                }
                supportedCharacterSets = supportedCharacterSetsBuffer
            } else {
                supportedCharacterSets = []
            }
        } else {
            supportedCharacterSets = nil
        }
        if containerValues.contains(.supportedNcharCharacterSets) {
            struct KeyVal0{struct CharacterSet{}}
            let supportedNcharCharacterSetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CharacterSet>.CodingKeys.self, forKey: .supportedNcharCharacterSets)
            if let supportedNcharCharacterSetsWrappedContainer = supportedNcharCharacterSetsWrappedContainer {
                let supportedNcharCharacterSetsContainer = try supportedNcharCharacterSetsWrappedContainer.decodeIfPresent([RdsClientTypes.CharacterSet].self, forKey: .member)
                var supportedNcharCharacterSetsBuffer:[RdsClientTypes.CharacterSet]? = nil
                if let supportedNcharCharacterSetsContainer = supportedNcharCharacterSetsContainer {
                    supportedNcharCharacterSetsBuffer = [RdsClientTypes.CharacterSet]()
                    for structureContainer0 in supportedNcharCharacterSetsContainer {
                        supportedNcharCharacterSetsBuffer?.append(structureContainer0)
                    }
                }
                supportedNcharCharacterSets = supportedNcharCharacterSetsBuffer
            } else {
                supportedNcharCharacterSets = []
            }
        } else {
            supportedNcharCharacterSets = nil
        }
        if containerValues.contains(.validUpgradeTarget) {
            struct KeyVal0{struct UpgradeTarget{}}
            let validUpgradeTargetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.UpgradeTarget>.CodingKeys.self, forKey: .validUpgradeTarget)
            if let validUpgradeTargetWrappedContainer = validUpgradeTargetWrappedContainer {
                let validUpgradeTargetContainer = try validUpgradeTargetWrappedContainer.decodeIfPresent([RdsClientTypes.UpgradeTarget].self, forKey: .member)
                var validUpgradeTargetBuffer:[RdsClientTypes.UpgradeTarget]? = nil
                if let validUpgradeTargetContainer = validUpgradeTargetContainer {
                    validUpgradeTargetBuffer = [RdsClientTypes.UpgradeTarget]()
                    for structureContainer0 in validUpgradeTargetContainer {
                        validUpgradeTargetBuffer?.append(structureContainer0)
                    }
                }
                validUpgradeTarget = validUpgradeTargetBuffer
            } else {
                validUpgradeTarget = []
            }
        } else {
            validUpgradeTarget = nil
        }
        if containerValues.contains(.supportedTimezones) {
            struct KeyVal0{struct Timezone{}}
            let supportedTimezonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Timezone>.CodingKeys.self, forKey: .supportedTimezones)
            if let supportedTimezonesWrappedContainer = supportedTimezonesWrappedContainer {
                let supportedTimezonesContainer = try supportedTimezonesWrappedContainer.decodeIfPresent([RdsClientTypes.Timezone].self, forKey: .member)
                var supportedTimezonesBuffer:[RdsClientTypes.Timezone]? = nil
                if let supportedTimezonesContainer = supportedTimezonesContainer {
                    supportedTimezonesBuffer = [RdsClientTypes.Timezone]()
                    for structureContainer0 in supportedTimezonesContainer {
                        supportedTimezonesBuffer?.append(structureContainer0)
                    }
                }
                supportedTimezones = supportedTimezonesBuffer
            } else {
                supportedTimezones = []
            }
        } else {
            supportedTimezones = nil
        }
        if containerValues.contains(.exportableLogTypes) {
            struct KeyVal0{struct member{}}
            let exportableLogTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .exportableLogTypes)
            if let exportableLogTypesWrappedContainer = exportableLogTypesWrappedContainer {
                let exportableLogTypesContainer = try exportableLogTypesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var exportableLogTypesBuffer:[Swift.String]? = nil
                if let exportableLogTypesContainer = exportableLogTypesContainer {
                    exportableLogTypesBuffer = [Swift.String]()
                    for stringContainer0 in exportableLogTypesContainer {
                        exportableLogTypesBuffer?.append(stringContainer0)
                    }
                }
                exportableLogTypes = exportableLogTypesBuffer
            } else {
                exportableLogTypes = []
            }
        } else {
            exportableLogTypes = nil
        }
        let supportsLogExportsToCloudwatchLogsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsLogExportsToCloudwatchLogs)
        supportsLogExportsToCloudwatchLogs = supportsLogExportsToCloudwatchLogsDecoded
        let supportsReadReplicaDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsReadReplica)
        supportsReadReplica = supportsReadReplicaDecoded
        if containerValues.contains(.supportedEngineModes) {
            struct KeyVal0{struct member{}}
            let supportedEngineModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedEngineModes)
            if let supportedEngineModesWrappedContainer = supportedEngineModesWrappedContainer {
                let supportedEngineModesContainer = try supportedEngineModesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedEngineModesBuffer:[Swift.String]? = nil
                if let supportedEngineModesContainer = supportedEngineModesContainer {
                    supportedEngineModesBuffer = [Swift.String]()
                    for stringContainer0 in supportedEngineModesContainer {
                        supportedEngineModesBuffer?.append(stringContainer0)
                    }
                }
                supportedEngineModes = supportedEngineModesBuffer
            } else {
                supportedEngineModes = []
            }
        } else {
            supportedEngineModes = nil
        }
        if containerValues.contains(.supportedFeatureNames) {
            struct KeyVal0{struct member{}}
            let supportedFeatureNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedFeatureNames)
            if let supportedFeatureNamesWrappedContainer = supportedFeatureNamesWrappedContainer {
                let supportedFeatureNamesContainer = try supportedFeatureNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedFeatureNamesBuffer:[Swift.String]? = nil
                if let supportedFeatureNamesContainer = supportedFeatureNamesContainer {
                    supportedFeatureNamesBuffer = [Swift.String]()
                    for stringContainer0 in supportedFeatureNamesContainer {
                        supportedFeatureNamesBuffer?.append(stringContainer0)
                    }
                }
                supportedFeatureNames = supportedFeatureNamesBuffer
            } else {
                supportedFeatureNames = []
            }
        } else {
            supportedFeatureNames = nil
        }
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let supportsParallelQueryDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsParallelQuery)
        supportsParallelQuery = supportsParallelQueryDecoded
        let supportsGlobalDatabasesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsGlobalDatabases)
        supportsGlobalDatabases = supportsGlobalDatabasesDecoded
        let majorEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorEngineVersion)
        majorEngineVersion = majorEngineVersionDecoded
        let databaseInstallationFilesS3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseInstallationFilesS3BucketName)
        databaseInstallationFilesS3BucketName = databaseInstallationFilesS3BucketNameDecoded
        let databaseInstallationFilesS3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseInstallationFilesS3Prefix)
        databaseInstallationFilesS3Prefix = databaseInstallationFilesS3PrefixDecoded
        let dBEngineVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBEngineVersionArn)
        dBEngineVersionArn = dBEngineVersionArnDecoded
        let kMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyId)
        kMSKeyId = kMSKeyIdDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        var createTimeBuffer:ClientRuntime.Date? = nil
        if let createTimeDecoded = createTimeDecoded {
            createTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createTimeDecoded, format: .dateTime)
        }
        createTime = createTimeBuffer
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagListBuffer:[RdsClientTypes.Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
    }
}

extension DeleteDBClusterEndpointInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: ClientRuntime.Key("DBClusterEndpointIdentifier"))
        }
        try container.encode("DeleteDBClusterEndpoint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteDBClusterEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDBClusterEndpointInput: Swift.Equatable {
    /// The identifier associated with the custom endpoint. This parameter is stored as a lowercase string.
    /// This member is required.
    public var dBClusterEndpointIdentifier: Swift.String?

    public init (
        dBClusterEndpointIdentifier: Swift.String? = nil
    )
    {
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
    }
}

struct DeleteDBClusterEndpointInputBody: Swift.Equatable {
    let dBClusterEndpointIdentifier: Swift.String?
}

extension DeleteDBClusterEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
    }
}

extension DeleteDBClusterEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBClusterEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterEndpointNotFoundFault" : self = .dBClusterEndpointNotFoundFault(try DBClusterEndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterEndpointStateFault" : self = .invalidDBClusterEndpointStateFault(try InvalidDBClusterEndpointStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBClusterEndpointOutputError: Swift.Error, Swift.Equatable {
    case dBClusterEndpointNotFoundFault(DBClusterEndpointNotFoundFault)
    case invalidDBClusterEndpointStateFault(InvalidDBClusterEndpointStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBClusterEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDBClusterEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customEndpointType = output.customEndpointType
            self.dBClusterEndpointArn = output.dBClusterEndpointArn
            self.dBClusterEndpointIdentifier = output.dBClusterEndpointIdentifier
            self.dBClusterEndpointResourceIdentifier = output.dBClusterEndpointResourceIdentifier
            self.dBClusterIdentifier = output.dBClusterIdentifier
            self.endpoint = output.endpoint
            self.endpointType = output.endpointType
            self.excludedMembers = output.excludedMembers
            self.staticMembers = output.staticMembers
            self.status = output.status
        } else {
            self.customEndpointType = nil
            self.dBClusterEndpointArn = nil
            self.dBClusterEndpointIdentifier = nil
            self.dBClusterEndpointResourceIdentifier = nil
            self.dBClusterIdentifier = nil
            self.endpoint = nil
            self.endpointType = nil
            self.excludedMembers = nil
            self.staticMembers = nil
            self.status = nil
        }
    }
}

/// This data type represents the information you need to connect to an Amazon Aurora DB cluster. This data type is used as a response element in the following actions:
///
/// * CreateDBClusterEndpoint
///
/// * DescribeDBClusterEndpoints
///
/// * ModifyDBClusterEndpoint
///
/// * DeleteDBClusterEndpoint
///
///
/// For the data structure that represents Amazon RDS DB instance endpoints, see Endpoint.
public struct DeleteDBClusterEndpointOutputResponse: Swift.Equatable {
    /// The type associated with a custom endpoint. One of: READER, WRITER, ANY.
    public var customEndpointType: Swift.String?
    /// The Amazon Resource Name (ARN) for the endpoint.
    public var dBClusterEndpointArn: Swift.String?
    /// The identifier associated with the endpoint. This parameter is stored as a lowercase string.
    public var dBClusterEndpointIdentifier: Swift.String?
    /// A unique system-generated identifier for an endpoint. It remains the same for the whole life of the endpoint.
    public var dBClusterEndpointResourceIdentifier: Swift.String?
    /// The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is stored as a lowercase string.
    public var dBClusterIdentifier: Swift.String?
    /// The DNS address of the endpoint.
    public var endpoint: Swift.String?
    /// The type of the endpoint. One of: READER, WRITER, CUSTOM.
    public var endpointType: Swift.String?
    /// List of DB instance identifiers that aren't part of the custom endpoint group. All other eligible instances are reachable through the custom endpoint. Only relevant if the list of static members is empty.
    public var excludedMembers: [Swift.String]?
    /// List of DB instance identifiers that are part of the custom endpoint group.
    public var staticMembers: [Swift.String]?
    /// The current status of the endpoint. One of: creating, available, deleting, inactive, modifying. The inactive state applies to an endpoint that can't be used for a certain kind of cluster, such as a writer endpoint for a read-only secondary cluster in a global database.
    public var status: Swift.String?

    public init (
        customEndpointType: Swift.String? = nil,
        dBClusterEndpointArn: Swift.String? = nil,
        dBClusterEndpointIdentifier: Swift.String? = nil,
        dBClusterEndpointResourceIdentifier: Swift.String? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        endpoint: Swift.String? = nil,
        endpointType: Swift.String? = nil,
        excludedMembers: [Swift.String]? = nil,
        staticMembers: [Swift.String]? = nil,
        status: Swift.String? = nil
    )
    {
        self.customEndpointType = customEndpointType
        self.dBClusterEndpointArn = dBClusterEndpointArn
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.endpoint = endpoint
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
        self.status = status
    }
}

struct DeleteDBClusterEndpointOutputResponseBody: Swift.Equatable {
    let dBClusterEndpointIdentifier: Swift.String?
    let dBClusterIdentifier: Swift.String?
    let dBClusterEndpointResourceIdentifier: Swift.String?
    let endpoint: Swift.String?
    let status: Swift.String?
    let endpointType: Swift.String?
    let customEndpointType: Swift.String?
    let staticMembers: [Swift.String]?
    let excludedMembers: [Swift.String]?
    let dBClusterEndpointArn: Swift.String?
}

extension DeleteDBClusterEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customEndpointType = "CustomEndpointType"
        case dBClusterEndpointArn = "DBClusterEndpointArn"
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        case dBClusterEndpointResourceIdentifier = "DBClusterEndpointResourceIdentifier"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case endpoint = "Endpoint"
        case endpointType = "EndpointType"
        case excludedMembers = "ExcludedMembers"
        case staticMembers = "StaticMembers"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteDBClusterEndpointResult"))
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterEndpointResourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointResourceIdentifier)
        dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifierDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let customEndpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customEndpointType)
        customEndpointType = customEndpointTypeDecoded
        if containerValues.contains(.staticMembers) {
            struct KeyVal0{struct member{}}
            let staticMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .staticMembers)
            if let staticMembersWrappedContainer = staticMembersWrappedContainer {
                let staticMembersContainer = try staticMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var staticMembersBuffer:[Swift.String]? = nil
                if let staticMembersContainer = staticMembersContainer {
                    staticMembersBuffer = [Swift.String]()
                    for stringContainer0 in staticMembersContainer {
                        staticMembersBuffer?.append(stringContainer0)
                    }
                }
                staticMembers = staticMembersBuffer
            } else {
                staticMembers = []
            }
        } else {
            staticMembers = nil
        }
        if containerValues.contains(.excludedMembers) {
            struct KeyVal0{struct member{}}
            let excludedMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .excludedMembers)
            if let excludedMembersWrappedContainer = excludedMembersWrappedContainer {
                let excludedMembersContainer = try excludedMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var excludedMembersBuffer:[Swift.String]? = nil
                if let excludedMembersContainer = excludedMembersContainer {
                    excludedMembersBuffer = [Swift.String]()
                    for stringContainer0 in excludedMembersContainer {
                        excludedMembersBuffer?.append(stringContainer0)
                    }
                }
                excludedMembers = excludedMembersBuffer
            } else {
                excludedMembers = []
            }
        } else {
            excludedMembers = nil
        }
        let dBClusterEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointArn)
        dBClusterEndpointArn = dBClusterEndpointArnDecoded
    }
}

extension DeleteDBClusterInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let finalDBSnapshotIdentifier = finalDBSnapshotIdentifier {
            try container.encode(finalDBSnapshotIdentifier, forKey: ClientRuntime.Key("FinalDBSnapshotIdentifier"))
        }
        if skipFinalSnapshot != false {
            try container.encode(skipFinalSnapshot, forKey: ClientRuntime.Key("SkipFinalSnapshot"))
        }
        try container.encode("DeleteDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteDBClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteDBClusterInput: Swift.Equatable {
    /// The DB cluster identifier for the DB cluster to be deleted. This parameter isn't case-sensitive. Constraints:
    ///
    /// * Must match an existing DBClusterIdentifier.
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// The DB cluster snapshot identifier of the new DB cluster snapshot created when SkipFinalSnapshot is disabled. Specifying this parameter and also skipping the creation of a final DB cluster snapshot with the SkipFinalShapshot parameter results in an error. Constraints:
    ///
    /// * Must be 1 to 255 letters, numbers, or hyphens.
    ///
    /// * First character must be a letter
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens
    public var finalDBSnapshotIdentifier: Swift.String?
    /// A value that indicates whether to skip the creation of a final DB cluster snapshot before the DB cluster is deleted. If skip is specified, no DB cluster snapshot is created. If skip isn't specified, a DB cluster snapshot is created before the DB cluster is deleted. By default, skip isn't specified, and the DB cluster snapshot is created. By default, this parameter is disabled. You must specify a FinalDBSnapshotIdentifier parameter if SkipFinalSnapshot is disabled.
    public var skipFinalSnapshot: Swift.Bool

    public init (
        dBClusterIdentifier: Swift.String? = nil,
        finalDBSnapshotIdentifier: Swift.String? = nil,
        skipFinalSnapshot: Swift.Bool = false
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.finalDBSnapshotIdentifier = finalDBSnapshotIdentifier
        self.skipFinalSnapshot = skipFinalSnapshot
    }
}

struct DeleteDBClusterInputBody: Swift.Equatable {
    let dBClusterIdentifier: Swift.String?
    let skipFinalSnapshot: Swift.Bool
    let finalDBSnapshotIdentifier: Swift.String?
}

extension DeleteDBClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterIdentifier = "DBClusterIdentifier"
        case finalDBSnapshotIdentifier = "FinalDBSnapshotIdentifier"
        case skipFinalSnapshot = "SkipFinalSnapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let skipFinalSnapshotDecoded = try containerValues.decode(Swift.Bool.self, forKey: .skipFinalSnapshot)
        skipFinalSnapshot = skipFinalSnapshotDecoded
        let finalDBSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .finalDBSnapshotIdentifier)
        finalDBSnapshotIdentifier = finalDBSnapshotIdentifierDecoded
    }
}

extension DeleteDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotAlreadyExistsFault" : self = .dBClusterSnapshotAlreadyExistsFault(try DBClusterSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceeded" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterSnapshotAlreadyExistsFault(DBClusterSnapshotAlreadyExistsFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct DeleteDBClusterOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon Aurora DB cluster or Multi-AZ DB cluster. For an Amazon Aurora DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, PromoteReadReplicaDBCluster, RestoreDBClusterFromS3, RestoreDBClusterFromSnapshot, RestoreDBClusterToPointInTime, StartDBCluster, and StopDBCluster. For a Multi-AZ DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, RebootDBCluster, RestoreDBClusterFromSnapshot, and RestoreDBClusterToPointInTime. For more information on Amazon Aurora DB clusters, see [ What is Amazon Aurora?](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/CHAP_AuroraOverview.html) in the Amazon Aurora User Guide. For more information on Multi-AZ DB clusters, see [ Multi-AZ deployments with two readable standby DB instances](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/multi-az-db-clusters-concepts.html) in the Amazon RDS User Guide. The Multi-AZ DB clusters feature is in preview and is subject to change.
    public var dBCluster: RdsClientTypes.DBCluster?

    public init (
        dBCluster: RdsClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct DeleteDBClusterOutputResponseBody: Swift.Equatable {
    let dBCluster: RdsClientTypes.DBCluster?
}

extension DeleteDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

extension DeleteDBClusterParameterGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        try container.encode("DeleteDBClusterParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteDBClusterParameterGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteDBClusterParameterGroupInput: Swift.Equatable {
    /// The name of the DB cluster parameter group. Constraints:
    ///
    /// * Must be the name of an existing DB cluster parameter group.
    ///
    /// * You can't delete a default DB cluster parameter group.
    ///
    /// * Can't be associated with any DB clusters.
    /// This member is required.
    public var dBClusterParameterGroupName: Swift.String?

    public init (
        dBClusterParameterGroupName: Swift.String? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
    }
}

struct DeleteDBClusterParameterGroupInputBody: Swift.Equatable {
    let dBClusterParameterGroupName: Swift.String?
}

extension DeleteDBClusterParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
    }
}

extension DeleteDBClusterParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBClusterParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupState" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBClusterParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBClusterParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDBClusterParameterGroupOutputResponse: Swift.Equatable {

}

extension DeleteDBClusterSnapshotInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("DBClusterSnapshotIdentifier"))
        }
        try container.encode("DeleteDBClusterSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteDBClusterSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteDBClusterSnapshotInput: Swift.Equatable {
    /// The identifier of the DB cluster snapshot to delete. Constraints: Must be the name of an existing DB cluster snapshot in the available state.
    /// This member is required.
    public var dBClusterSnapshotIdentifier: Swift.String?

    public init (
        dBClusterSnapshotIdentifier: Swift.String? = nil
    )
    {
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
    }
}

struct DeleteDBClusterSnapshotInputBody: Swift.Equatable {
    let dBClusterSnapshotIdentifier: Swift.String?
}

extension DeleteDBClusterSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterSnapshotIdentifier = "DBClusterSnapshotIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterSnapshotIdentifier)
        dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifierDecoded
    }
}

extension DeleteDBClusterSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBClusterSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBClusterSnapshotOutputError: Swift.Error, Swift.Equatable {
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBClusterSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDBClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterSnapshot = output.dBClusterSnapshot
        } else {
            self.dBClusterSnapshot = nil
        }
    }
}

public struct DeleteDBClusterSnapshotOutputResponse: Swift.Equatable {
    /// Contains the details for an Amazon RDS DB cluster snapshot This data type is used as a response element in the DescribeDBClusterSnapshots action.
    public var dBClusterSnapshot: RdsClientTypes.DBClusterSnapshot?

    public init (
        dBClusterSnapshot: RdsClientTypes.DBClusterSnapshot? = nil
    )
    {
        self.dBClusterSnapshot = dBClusterSnapshot
    }
}

struct DeleteDBClusterSnapshotOutputResponseBody: Swift.Equatable {
    let dBClusterSnapshot: RdsClientTypes.DBClusterSnapshot?
}

extension DeleteDBClusterSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterSnapshot = "DBClusterSnapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteDBClusterSnapshotResult"))
        let dBClusterSnapshotDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBClusterSnapshot.self, forKey: .dBClusterSnapshot)
        dBClusterSnapshot = dBClusterSnapshotDecoded
    }
}

extension DeleteDBInstanceAutomatedBackupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn {
            try container.encode(dBInstanceAutomatedBackupsArn, forKey: ClientRuntime.Key("DBInstanceAutomatedBackupsArn"))
        }
        if let dbiResourceId = dbiResourceId {
            try container.encode(dbiResourceId, forKey: ClientRuntime.Key("DbiResourceId"))
        }
        try container.encode("DeleteDBInstanceAutomatedBackup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteDBInstanceAutomatedBackupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Parameter input for the DeleteDBInstanceAutomatedBackup operation.
public struct DeleteDBInstanceAutomatedBackupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the automated backups to delete, for example, arn:aws:rds:us-east-1:123456789012:auto-backup:ab-L2IJCEXJP7XQ7HOJ4SIEXAMPLE. This setting doesn't apply to RDS Custom.
    public var dBInstanceAutomatedBackupsArn: Swift.String?
    /// The identifier for the source DB instance, which can't be changed and which is unique to an Amazon Web Services Region.
    public var dbiResourceId: Swift.String?

    public init (
        dBInstanceAutomatedBackupsArn: Swift.String? = nil,
        dbiResourceId: Swift.String? = nil
    )
    {
        self.dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn
        self.dbiResourceId = dbiResourceId
    }
}

struct DeleteDBInstanceAutomatedBackupInputBody: Swift.Equatable {
    let dbiResourceId: Swift.String?
    let dBInstanceAutomatedBackupsArn: Swift.String?
}

extension DeleteDBInstanceAutomatedBackupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceAutomatedBackupsArn = "DBInstanceAutomatedBackupsArn"
        case dbiResourceId = "DbiResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dbiResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbiResourceId)
        dbiResourceId = dbiResourceIdDecoded
        let dBInstanceAutomatedBackupsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceAutomatedBackupsArn)
        dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArnDecoded
    }
}

extension DeleteDBInstanceAutomatedBackupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBInstanceAutomatedBackupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceAutomatedBackupNotFound" : self = .dBInstanceAutomatedBackupNotFoundFault(try DBInstanceAutomatedBackupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceAutomatedBackupState" : self = .invalidDBInstanceAutomatedBackupStateFault(try InvalidDBInstanceAutomatedBackupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBInstanceAutomatedBackupOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceAutomatedBackupNotFoundFault(DBInstanceAutomatedBackupNotFoundFault)
    case invalidDBInstanceAutomatedBackupStateFault(InvalidDBInstanceAutomatedBackupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBInstanceAutomatedBackupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDBInstanceAutomatedBackupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstanceAutomatedBackup = output.dBInstanceAutomatedBackup
        } else {
            self.dBInstanceAutomatedBackup = nil
        }
    }
}

public struct DeleteDBInstanceAutomatedBackupOutputResponse: Swift.Equatable {
    /// An automated backup of a DB instance. It consists of system backups, transaction logs, and the database instance properties that existed at the time you deleted the source instance.
    public var dBInstanceAutomatedBackup: RdsClientTypes.DBInstanceAutomatedBackup?

    public init (
        dBInstanceAutomatedBackup: RdsClientTypes.DBInstanceAutomatedBackup? = nil
    )
    {
        self.dBInstanceAutomatedBackup = dBInstanceAutomatedBackup
    }
}

struct DeleteDBInstanceAutomatedBackupOutputResponseBody: Swift.Equatable {
    let dBInstanceAutomatedBackup: RdsClientTypes.DBInstanceAutomatedBackup?
}

extension DeleteDBInstanceAutomatedBackupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceAutomatedBackup = "DBInstanceAutomatedBackup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteDBInstanceAutomatedBackupResult"))
        let dBInstanceAutomatedBackupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstanceAutomatedBackup.self, forKey: .dBInstanceAutomatedBackup)
        dBInstanceAutomatedBackup = dBInstanceAutomatedBackupDecoded
    }
}

extension DeleteDBInstanceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let deleteAutomatedBackups = deleteAutomatedBackups {
            try container.encode(deleteAutomatedBackups, forKey: ClientRuntime.Key("DeleteAutomatedBackups"))
        }
        if let finalDBSnapshotIdentifier = finalDBSnapshotIdentifier {
            try container.encode(finalDBSnapshotIdentifier, forKey: ClientRuntime.Key("FinalDBSnapshotIdentifier"))
        }
        if skipFinalSnapshot != false {
            try container.encode(skipFinalSnapshot, forKey: ClientRuntime.Key("SkipFinalSnapshot"))
        }
        try container.encode("DeleteDBInstance", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteDBInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteDBInstanceInput: Swift.Equatable {
    /// The DB instance identifier for the DB instance to be deleted. This parameter isn't case-sensitive. Constraints:
    ///
    /// * Must match the name of an existing DB instance.
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// A value that indicates whether to remove automated backups immediately after the DB instance is deleted. This parameter isn't case-sensitive. The default is to remove automated backups immediately after the DB instance is deleted.
    public var deleteAutomatedBackups: Swift.Bool?
    /// The DBSnapshotIdentifier of the new DBSnapshot created when the SkipFinalSnapshot parameter is disabled. If you enable this parameter and also enable SkipFinalShapshot, the command results in an error. This setting doesn't apply to RDS Custom. Constraints:
    ///
    /// * Must be 1 to 255 letters or numbers.
    ///
    /// * First character must be a letter.
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens.
    ///
    /// * Can't be specified when deleting a read replica.
    public var finalDBSnapshotIdentifier: Swift.String?
    /// A value that indicates whether to skip the creation of a final DB snapshot before deleting the instance. If you enable this parameter, RDS doesn't create a DB snapshot. If you don't enable this parameter, RDS creates a DB snapshot before the DB instance is deleted. By default, skip isn't enabled, and the DB snapshot is created. If you don't enable this parameter, you must specify the FinalDBSnapshotIdentifier parameter. When a DB instance is in a failure state and has a status of failed, incompatible-restore, or incompatible-network, RDS can delete the instance only if you enable this parameter. If you delete a read replica or an RDS Custom instance, you must enable this setting. This setting is required for RDS Custom.
    public var skipFinalSnapshot: Swift.Bool

    public init (
        dBInstanceIdentifier: Swift.String? = nil,
        deleteAutomatedBackups: Swift.Bool? = nil,
        finalDBSnapshotIdentifier: Swift.String? = nil,
        skipFinalSnapshot: Swift.Bool = false
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.deleteAutomatedBackups = deleteAutomatedBackups
        self.finalDBSnapshotIdentifier = finalDBSnapshotIdentifier
        self.skipFinalSnapshot = skipFinalSnapshot
    }
}

struct DeleteDBInstanceInputBody: Swift.Equatable {
    let dBInstanceIdentifier: Swift.String?
    let skipFinalSnapshot: Swift.Bool
    let finalDBSnapshotIdentifier: Swift.String?
    let deleteAutomatedBackups: Swift.Bool?
}

extension DeleteDBInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case deleteAutomatedBackups = "DeleteAutomatedBackups"
        case finalDBSnapshotIdentifier = "FinalDBSnapshotIdentifier"
        case skipFinalSnapshot = "SkipFinalSnapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let skipFinalSnapshotDecoded = try containerValues.decode(Swift.Bool.self, forKey: .skipFinalSnapshot)
        skipFinalSnapshot = skipFinalSnapshotDecoded
        let finalDBSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .finalDBSnapshotIdentifier)
        finalDBSnapshotIdentifier = finalDBSnapshotIdentifierDecoded
        let deleteAutomatedBackupsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteAutomatedBackups)
        deleteAutomatedBackups = deleteAutomatedBackupsDecoded
    }
}

extension DeleteDBInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceAutomatedBackupQuotaExceeded" : self = .dBInstanceAutomatedBackupQuotaExceededFault(try DBInstanceAutomatedBackupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotAlreadyExists" : self = .dBSnapshotAlreadyExistsFault(try DBSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceeded" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBInstanceOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceAutomatedBackupQuotaExceededFault(DBInstanceAutomatedBackupQuotaExceededFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSnapshotAlreadyExistsFault(DBSnapshotAlreadyExistsFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct DeleteDBInstanceOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB instance. This data type is used as a response element in the operations CreateDBInstance, CreateDBInstanceReadReplica, DeleteDBInstance, DescribeDBInstances, ModifyDBInstance, PromoteReadReplica, RebootDBInstance, RestoreDBInstanceFromDBSnapshot, RestoreDBInstanceFromS3, RestoreDBInstanceToPointInTime, StartDBInstance, and StopDBInstance.
    public var dBInstance: RdsClientTypes.DBInstance?

    public init (
        dBInstance: RdsClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct DeleteDBInstanceOutputResponseBody: Swift.Equatable {
    let dBInstance: RdsClientTypes.DBInstance?
}

extension DeleteDBInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

extension DeleteDBParameterGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        try container.encode("DeleteDBParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteDBParameterGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteDBParameterGroupInput: Swift.Equatable {
    /// The name of the DB parameter group. Constraints:
    ///
    /// * Must be the name of an existing DB parameter group
    ///
    /// * You can't delete a default DB parameter group
    ///
    /// * Can't be associated with any DB instances
    /// This member is required.
    public var dBParameterGroupName: Swift.String?

    public init (
        dBParameterGroupName: Swift.String? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
    }
}

struct DeleteDBParameterGroupInputBody: Swift.Equatable {
    let dBParameterGroupName: Swift.String?
}

extension DeleteDBParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupName = "DBParameterGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
    }
}

extension DeleteDBParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupState" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDBParameterGroupOutputResponse: Swift.Equatable {

}

extension DeleteDBProxyEndpointInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBProxyEndpointName = dBProxyEndpointName {
            try container.encode(dBProxyEndpointName, forKey: ClientRuntime.Key("DBProxyEndpointName"))
        }
        try container.encode("DeleteDBProxyEndpoint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteDBProxyEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDBProxyEndpointInput: Swift.Equatable {
    /// The name of the DB proxy endpoint to delete.
    /// This member is required.
    public var dBProxyEndpointName: Swift.String?

    public init (
        dBProxyEndpointName: Swift.String? = nil
    )
    {
        self.dBProxyEndpointName = dBProxyEndpointName
    }
}

struct DeleteDBProxyEndpointInputBody: Swift.Equatable {
    let dBProxyEndpointName: Swift.String?
}

extension DeleteDBProxyEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxyEndpointName = "DBProxyEndpointName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBProxyEndpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyEndpointName)
        dBProxyEndpointName = dBProxyEndpointNameDecoded
    }
}

extension DeleteDBProxyEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBProxyEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyEndpointNotFoundFault" : self = .dBProxyEndpointNotFoundFault(try DBProxyEndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyEndpointStateFault" : self = .invalidDBProxyEndpointStateFault(try InvalidDBProxyEndpointStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBProxyEndpointOutputError: Swift.Error, Swift.Equatable {
    case dBProxyEndpointNotFoundFault(DBProxyEndpointNotFoundFault)
    case invalidDBProxyEndpointStateFault(InvalidDBProxyEndpointStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBProxyEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDBProxyEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBProxyEndpoint = output.dBProxyEndpoint
        } else {
            self.dBProxyEndpoint = nil
        }
    }
}

public struct DeleteDBProxyEndpointOutputResponse: Swift.Equatable {
    /// The data structure representing the details of the DB proxy endpoint that you delete.
    public var dBProxyEndpoint: RdsClientTypes.DBProxyEndpoint?

    public init (
        dBProxyEndpoint: RdsClientTypes.DBProxyEndpoint? = nil
    )
    {
        self.dBProxyEndpoint = dBProxyEndpoint
    }
}

struct DeleteDBProxyEndpointOutputResponseBody: Swift.Equatable {
    let dBProxyEndpoint: RdsClientTypes.DBProxyEndpoint?
}

extension DeleteDBProxyEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxyEndpoint = "DBProxyEndpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteDBProxyEndpointResult"))
        let dBProxyEndpointDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBProxyEndpoint.self, forKey: .dBProxyEndpoint)
        dBProxyEndpoint = dBProxyEndpointDecoded
    }
}

extension DeleteDBProxyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        try container.encode("DeleteDBProxy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteDBProxyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDBProxyInput: Swift.Equatable {
    /// The name of the DB proxy to delete.
    /// This member is required.
    public var dBProxyName: Swift.String?

    public init (
        dBProxyName: Swift.String? = nil
    )
    {
        self.dBProxyName = dBProxyName
    }
}

struct DeleteDBProxyInputBody: Swift.Equatable {
    let dBProxyName: Swift.String?
}

extension DeleteDBProxyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxyName = "DBProxyName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBProxyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyName)
        dBProxyName = dBProxyNameDecoded
    }
}

extension DeleteDBProxyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBProxyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBProxyOutputError: Swift.Error, Swift.Equatable {
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBProxyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDBProxyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBProxy = output.dBProxy
        } else {
            self.dBProxy = nil
        }
    }
}

public struct DeleteDBProxyOutputResponse: Swift.Equatable {
    /// The data structure representing the details of the DB proxy that you delete.
    public var dBProxy: RdsClientTypes.DBProxy?

    public init (
        dBProxy: RdsClientTypes.DBProxy? = nil
    )
    {
        self.dBProxy = dBProxy
    }
}

struct DeleteDBProxyOutputResponseBody: Swift.Equatable {
    let dBProxy: RdsClientTypes.DBProxy?
}

extension DeleteDBProxyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxy = "DBProxy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteDBProxyResult"))
        let dBProxyDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBProxy.self, forKey: .dBProxy)
        dBProxy = dBProxyDecoded
    }
}

extension DeleteDBSecurityGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSecurityGroupName = dBSecurityGroupName {
            try container.encode(dBSecurityGroupName, forKey: ClientRuntime.Key("DBSecurityGroupName"))
        }
        try container.encode("DeleteDBSecurityGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteDBSecurityGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteDBSecurityGroupInput: Swift.Equatable {
    /// The name of the DB security group to delete. You can't delete the default DB security group. Constraints:
    ///
    /// * Must be 1 to 255 letters, numbers, or hyphens.
    ///
    /// * First character must be a letter
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens
    ///
    /// * Must not be "Default"
    /// This member is required.
    public var dBSecurityGroupName: Swift.String?

    public init (
        dBSecurityGroupName: Swift.String? = nil
    )
    {
        self.dBSecurityGroupName = dBSecurityGroupName
    }
}

struct DeleteDBSecurityGroupInputBody: Swift.Equatable {
    let dBSecurityGroupName: Swift.String?
}

extension DeleteDBSecurityGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSecurityGroupName = "DBSecurityGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSecurityGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSecurityGroupName)
        dBSecurityGroupName = dBSecurityGroupNameDecoded
    }
}

extension DeleteDBSecurityGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBSecurityGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSecurityGroupNotFound" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSecurityGroupState" : self = .invalidDBSecurityGroupStateFault(try InvalidDBSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBSecurityGroupOutputError: Swift.Error, Swift.Equatable {
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case invalidDBSecurityGroupStateFault(InvalidDBSecurityGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBSecurityGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDBSecurityGroupOutputResponse: Swift.Equatable {

}

extension DeleteDBSnapshotInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: ClientRuntime.Key("DBSnapshotIdentifier"))
        }
        try container.encode("DeleteDBSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteDBSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteDBSnapshotInput: Swift.Equatable {
    /// The DB snapshot identifier. Constraints: Must be the name of an existing DB snapshot in the available state.
    /// This member is required.
    public var dBSnapshotIdentifier: Swift.String?

    public init (
        dBSnapshotIdentifier: Swift.String? = nil
    )
    {
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
    }
}

struct DeleteDBSnapshotInputBody: Swift.Equatable {
    let dBSnapshotIdentifier: Swift.String?
}

extension DeleteDBSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSnapshotIdentifier = "DBSnapshotIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSnapshotIdentifier)
        dBSnapshotIdentifier = dBSnapshotIdentifierDecoded
    }
}

extension DeleteDBSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSnapshotState" : self = .invalidDBSnapshotStateFault(try InvalidDBSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBSnapshotOutputError: Swift.Error, Swift.Equatable {
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case invalidDBSnapshotStateFault(InvalidDBSnapshotStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDBSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSnapshot = output.dBSnapshot
        } else {
            self.dBSnapshot = nil
        }
    }
}

public struct DeleteDBSnapshotOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB snapshot. This data type is used as a response element in the DescribeDBSnapshots action.
    public var dBSnapshot: RdsClientTypes.DBSnapshot?

    public init (
        dBSnapshot: RdsClientTypes.DBSnapshot? = nil
    )
    {
        self.dBSnapshot = dBSnapshot
    }
}

struct DeleteDBSnapshotOutputResponseBody: Swift.Equatable {
    let dBSnapshot: RdsClientTypes.DBSnapshot?
}

extension DeleteDBSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSnapshot = "DBSnapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteDBSnapshotResult"))
        let dBSnapshotDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSnapshot.self, forKey: .dBSnapshot)
        dBSnapshot = dBSnapshotDecoded
    }
}

extension DeleteDBSubnetGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        try container.encode("DeleteDBSubnetGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteDBSubnetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteDBSubnetGroupInput: Swift.Equatable {
    /// The name of the database subnet group to delete. You can't delete the default subnet group. Constraints: Constraints: Must match the name of an existing DBSubnetGroup. Must not be default. Example: mySubnetgroup
    /// This member is required.
    public var dBSubnetGroupName: Swift.String?

    public init (
        dBSubnetGroupName: Swift.String? = nil
    )
    {
        self.dBSubnetGroupName = dBSubnetGroupName
    }
}

struct DeleteDBSubnetGroupInputBody: Swift.Equatable {
    let dBSubnetGroupName: Swift.String?
}

extension DeleteDBSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSubnetGroupName = "DBSubnetGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
    }
}

extension DeleteDBSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetGroupStateFault" : self = .invalidDBSubnetGroupStateFault(try InvalidDBSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetStateFault" : self = .invalidDBSubnetStateFault(try InvalidDBSubnetStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case invalidDBSubnetGroupStateFault(InvalidDBSubnetGroupStateFault)
    case invalidDBSubnetStateFault(InvalidDBSubnetStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDBSubnetGroupOutputResponse: Swift.Equatable {

}

extension DeleteEventSubscriptionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: ClientRuntime.Key("SubscriptionName"))
        }
        try container.encode("DeleteEventSubscription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteEventSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteEventSubscriptionInput: Swift.Equatable {
    /// The name of the RDS event notification subscription you want to delete.
    /// This member is required.
    public var subscriptionName: Swift.String?

    public init (
        subscriptionName: Swift.String? = nil
    )
    {
        self.subscriptionName = subscriptionName
    }
}

struct DeleteEventSubscriptionInputBody: Swift.Equatable {
    let subscriptionName: Swift.String?
}

extension DeleteEventSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionName = "SubscriptionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
    }
}

extension DeleteEventSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteEventSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidEventSubscriptionState" : self = .invalidEventSubscriptionStateFault(try InvalidEventSubscriptionStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFound" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case invalidEventSubscriptionStateFault(InvalidEventSubscriptionStateFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct DeleteEventSubscriptionOutputResponse: Swift.Equatable {
    /// Contains the results of a successful invocation of the DescribeEventSubscriptions action.
    public var eventSubscription: RdsClientTypes.EventSubscription?

    public init (
        eventSubscription: RdsClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct DeleteEventSubscriptionOutputResponseBody: Swift.Equatable {
    let eventSubscription: RdsClientTypes.EventSubscription?
}

extension DeleteEventSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteEventSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(RdsClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

extension DeleteGlobalClusterInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: ClientRuntime.Key("GlobalClusterIdentifier"))
        }
        try container.encode("DeleteGlobalCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteGlobalClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteGlobalClusterInput: Swift.Equatable {
    /// The cluster identifier of the global database cluster being deleted.
    /// This member is required.
    public var globalClusterIdentifier: Swift.String?

    public init (
        globalClusterIdentifier: Swift.String? = nil
    )
    {
        self.globalClusterIdentifier = globalClusterIdentifier
    }
}

struct DeleteGlobalClusterInputBody: Swift.Equatable {
    let globalClusterIdentifier: Swift.String?
}

extension DeleteGlobalClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalClusterIdentifier = "GlobalClusterIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalClusterIdentifier)
        globalClusterIdentifier = globalClusterIdentifierDecoded
    }
}

extension DeleteGlobalClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteGlobalClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "GlobalClusterNotFoundFault" : self = .globalClusterNotFoundFault(try GlobalClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGlobalClusterStateFault" : self = .invalidGlobalClusterStateFault(try InvalidGlobalClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGlobalClusterOutputError: Swift.Error, Swift.Equatable {
    case globalClusterNotFoundFault(GlobalClusterNotFoundFault)
    case invalidGlobalClusterStateFault(InvalidGlobalClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGlobalClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteGlobalClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalCluster = output.globalCluster
        } else {
            self.globalCluster = nil
        }
    }
}

public struct DeleteGlobalClusterOutputResponse: Swift.Equatable {
    /// A data type representing an Aurora global database.
    public var globalCluster: RdsClientTypes.GlobalCluster?

    public init (
        globalCluster: RdsClientTypes.GlobalCluster? = nil
    )
    {
        self.globalCluster = globalCluster
    }
}

struct DeleteGlobalClusterOutputResponseBody: Swift.Equatable {
    let globalCluster: RdsClientTypes.GlobalCluster?
}

extension DeleteGlobalClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalCluster = "GlobalCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteGlobalClusterResult"))
        let globalClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.GlobalCluster.self, forKey: .globalCluster)
        globalCluster = globalClusterDecoded
    }
}

extension DeleteInstallationMediaInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let installationMediaId = installationMediaId {
            try container.encode(installationMediaId, forKey: ClientRuntime.Key("InstallationMediaId"))
        }
        try container.encode("DeleteInstallationMedia", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteInstallationMediaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteInstallationMediaInput: Swift.Equatable {
    /// The installation medium ID.
    /// This member is required.
    public var installationMediaId: Swift.String?

    public init (
        installationMediaId: Swift.String? = nil
    )
    {
        self.installationMediaId = installationMediaId
    }
}

struct DeleteInstallationMediaInputBody: Swift.Equatable {
    let installationMediaId: Swift.String?
}

extension DeleteInstallationMediaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case installationMediaId = "InstallationMediaId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let installationMediaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .installationMediaId)
        installationMediaId = installationMediaIdDecoded
    }
}

extension DeleteInstallationMediaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteInstallationMediaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InstallationMediaNotFound" : self = .installationMediaNotFoundFault(try InstallationMediaNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInstallationMediaOutputError: Swift.Error, Swift.Equatable {
    case installationMediaNotFoundFault(InstallationMediaNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInstallationMediaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteInstallationMediaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customAvailabilityZoneId = output.customAvailabilityZoneId
            self.engine = output.engine
            self.engineInstallationMediaPath = output.engineInstallationMediaPath
            self.engineVersion = output.engineVersion
            self.failureCause = output.failureCause
            self.installationMediaId = output.installationMediaId
            self.oSInstallationMediaPath = output.oSInstallationMediaPath
            self.status = output.status
        } else {
            self.customAvailabilityZoneId = nil
            self.engine = nil
            self.engineInstallationMediaPath = nil
            self.engineVersion = nil
            self.failureCause = nil
            self.installationMediaId = nil
            self.oSInstallationMediaPath = nil
            self.status = nil
        }
    }
}

/// Contains the installation media for a DB engine that requires an on-premises customer provided license, such as Microsoft SQL Server.
public struct DeleteInstallationMediaOutputResponse: Swift.Equatable {
    /// The custom Availability Zone (AZ) that contains the installation media.
    public var customAvailabilityZoneId: Swift.String?
    /// The DB engine.
    public var engine: Swift.String?
    /// The path to the installation medium for the DB engine.
    public var engineInstallationMediaPath: Swift.String?
    /// The engine version of the DB engine.
    public var engineVersion: Swift.String?
    /// If an installation media failure occurred, the cause of the failure.
    public var failureCause: RdsClientTypes.InstallationMediaFailureCause?
    /// The installation medium ID.
    public var installationMediaId: Swift.String?
    /// The path to the installation medium for the operating system associated with the DB engine.
    public var oSInstallationMediaPath: Swift.String?
    /// The status of the installation medium.
    public var status: Swift.String?

    public init (
        customAvailabilityZoneId: Swift.String? = nil,
        engine: Swift.String? = nil,
        engineInstallationMediaPath: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        failureCause: RdsClientTypes.InstallationMediaFailureCause? = nil,
        installationMediaId: Swift.String? = nil,
        oSInstallationMediaPath: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.customAvailabilityZoneId = customAvailabilityZoneId
        self.engine = engine
        self.engineInstallationMediaPath = engineInstallationMediaPath
        self.engineVersion = engineVersion
        self.failureCause = failureCause
        self.installationMediaId = installationMediaId
        self.oSInstallationMediaPath = oSInstallationMediaPath
        self.status = status
    }
}

struct DeleteInstallationMediaOutputResponseBody: Swift.Equatable {
    let installationMediaId: Swift.String?
    let customAvailabilityZoneId: Swift.String?
    let engine: Swift.String?
    let engineVersion: Swift.String?
    let engineInstallationMediaPath: Swift.String?
    let oSInstallationMediaPath: Swift.String?
    let status: Swift.String?
    let failureCause: RdsClientTypes.InstallationMediaFailureCause?
}

extension DeleteInstallationMediaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customAvailabilityZoneId = "CustomAvailabilityZoneId"
        case engine = "Engine"
        case engineInstallationMediaPath = "EngineInstallationMediaPath"
        case engineVersion = "EngineVersion"
        case failureCause = "FailureCause"
        case installationMediaId = "InstallationMediaId"
        case oSInstallationMediaPath = "OSInstallationMediaPath"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteInstallationMediaResult"))
        let installationMediaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .installationMediaId)
        installationMediaId = installationMediaIdDecoded
        let customAvailabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customAvailabilityZoneId)
        customAvailabilityZoneId = customAvailabilityZoneIdDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let engineInstallationMediaPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineInstallationMediaPath)
        engineInstallationMediaPath = engineInstallationMediaPathDecoded
        let oSInstallationMediaPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oSInstallationMediaPath)
        oSInstallationMediaPath = oSInstallationMediaPathDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let failureCauseDecoded = try containerValues.decodeIfPresent(RdsClientTypes.InstallationMediaFailureCause.self, forKey: .failureCause)
        failureCause = failureCauseDecoded
    }
}

extension DeleteOptionGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        try container.encode("DeleteOptionGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteOptionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteOptionGroupInput: Swift.Equatable {
    /// The name of the option group to be deleted. You can't delete default option groups.
    /// This member is required.
    public var optionGroupName: Swift.String?

    public init (
        optionGroupName: Swift.String? = nil
    )
    {
        self.optionGroupName = optionGroupName
    }
}

struct DeleteOptionGroupInputBody: Swift.Equatable {
    let optionGroupName: Swift.String?
}

extension DeleteOptionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optionGroupName = "OptionGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
    }
}

extension DeleteOptionGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteOptionGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidOptionGroupStateFault" : self = .invalidOptionGroupStateFault(try InvalidOptionGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteOptionGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidOptionGroupStateFault(InvalidOptionGroupStateFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOptionGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOptionGroupOutputResponse: Swift.Equatable {

}

extension DeregisterDBProxyTargetsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifiers = dBClusterIdentifiers {
            var dBClusterIdentifiersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBClusterIdentifiers"))
            for (index0, string0) in dBClusterIdentifiers.enumerated() {
                try dBClusterIdentifiersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dBInstanceIdentifiers = dBInstanceIdentifiers {
            var dBInstanceIdentifiersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBInstanceIdentifiers"))
            for (index0, string0) in dBInstanceIdentifiers.enumerated() {
                try dBInstanceIdentifiersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if let targetGroupName = targetGroupName {
            try container.encode(targetGroupName, forKey: ClientRuntime.Key("TargetGroupName"))
        }
        try container.encode("DeregisterDBProxyTargets", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeregisterDBProxyTargetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeregisterDBProxyTargetsInput: Swift.Equatable {
    /// One or more DB cluster identifiers.
    public var dBClusterIdentifiers: [Swift.String]?
    /// One or more DB instance identifiers.
    public var dBInstanceIdentifiers: [Swift.String]?
    /// The identifier of the DBProxy that is associated with the DBProxyTargetGroup.
    /// This member is required.
    public var dBProxyName: Swift.String?
    /// The identifier of the DBProxyTargetGroup.
    public var targetGroupName: Swift.String?

    public init (
        dBClusterIdentifiers: [Swift.String]? = nil,
        dBInstanceIdentifiers: [Swift.String]? = nil,
        dBProxyName: Swift.String? = nil,
        targetGroupName: Swift.String? = nil
    )
    {
        self.dBClusterIdentifiers = dBClusterIdentifiers
        self.dBInstanceIdentifiers = dBInstanceIdentifiers
        self.dBProxyName = dBProxyName
        self.targetGroupName = targetGroupName
    }
}

struct DeregisterDBProxyTargetsInputBody: Swift.Equatable {
    let dBProxyName: Swift.String?
    let targetGroupName: Swift.String?
    let dBInstanceIdentifiers: [Swift.String]?
    let dBClusterIdentifiers: [Swift.String]?
}

extension DeregisterDBProxyTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterIdentifiers = "DBClusterIdentifiers"
        case dBInstanceIdentifiers = "DBInstanceIdentifiers"
        case dBProxyName = "DBProxyName"
        case targetGroupName = "TargetGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBProxyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyName)
        dBProxyName = dBProxyNameDecoded
        let targetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetGroupName)
        targetGroupName = targetGroupNameDecoded
        if containerValues.contains(.dBInstanceIdentifiers) {
            struct KeyVal0{struct member{}}
            let dBInstanceIdentifiersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .dBInstanceIdentifiers)
            if let dBInstanceIdentifiersWrappedContainer = dBInstanceIdentifiersWrappedContainer {
                let dBInstanceIdentifiersContainer = try dBInstanceIdentifiersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var dBInstanceIdentifiersBuffer:[Swift.String]? = nil
                if let dBInstanceIdentifiersContainer = dBInstanceIdentifiersContainer {
                    dBInstanceIdentifiersBuffer = [Swift.String]()
                    for stringContainer0 in dBInstanceIdentifiersContainer {
                        dBInstanceIdentifiersBuffer?.append(stringContainer0)
                    }
                }
                dBInstanceIdentifiers = dBInstanceIdentifiersBuffer
            } else {
                dBInstanceIdentifiers = []
            }
        } else {
            dBInstanceIdentifiers = nil
        }
        if containerValues.contains(.dBClusterIdentifiers) {
            struct KeyVal0{struct member{}}
            let dBClusterIdentifiersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .dBClusterIdentifiers)
            if let dBClusterIdentifiersWrappedContainer = dBClusterIdentifiersWrappedContainer {
                let dBClusterIdentifiersContainer = try dBClusterIdentifiersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var dBClusterIdentifiersBuffer:[Swift.String]? = nil
                if let dBClusterIdentifiersContainer = dBClusterIdentifiersContainer {
                    dBClusterIdentifiersBuffer = [Swift.String]()
                    for stringContainer0 in dBClusterIdentifiersContainer {
                        dBClusterIdentifiersBuffer?.append(stringContainer0)
                    }
                }
                dBClusterIdentifiers = dBClusterIdentifiersBuffer
            } else {
                dBClusterIdentifiers = []
            }
        } else {
            dBClusterIdentifiers = nil
        }
    }
}

extension DeregisterDBProxyTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeregisterDBProxyTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetNotFoundFault" : self = .dBProxyTargetNotFoundFault(try DBProxyTargetNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterDBProxyTargetsOutputError: Swift.Error, Swift.Equatable {
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case dBProxyTargetNotFoundFault(DBProxyTargetNotFoundFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterDBProxyTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterDBProxyTargetsOutputResponse: Swift.Equatable {

}

extension DescribeAccountAttributesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("DescribeAccountAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeAccountAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeAccountAttributesInput: Swift.Equatable {

}

extension DescribeAccountAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeAccountAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountAttributesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAccountAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountQuotas = output.accountQuotas
        } else {
            self.accountQuotas = nil
        }
    }
}

/// Data returned by the DescribeAccountAttributes action.
public struct DescribeAccountAttributesOutputResponse: Swift.Equatable {
    /// A list of AccountQuota objects. Within this list, each quota has a name, a count of usage toward the quota maximum, and a maximum value for the quota.
    public var accountQuotas: [RdsClientTypes.AccountQuota]?

    public init (
        accountQuotas: [RdsClientTypes.AccountQuota]? = nil
    )
    {
        self.accountQuotas = accountQuotas
    }
}

struct DescribeAccountAttributesOutputResponseBody: Swift.Equatable {
    let accountQuotas: [RdsClientTypes.AccountQuota]?
}

extension DescribeAccountAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountQuotas = "AccountQuotas"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeAccountAttributesResult"))
        if containerValues.contains(.accountQuotas) {
            struct KeyVal0{struct AccountQuota{}}
            let accountQuotasWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AccountQuota>.CodingKeys.self, forKey: .accountQuotas)
            if let accountQuotasWrappedContainer = accountQuotasWrappedContainer {
                let accountQuotasContainer = try accountQuotasWrappedContainer.decodeIfPresent([RdsClientTypes.AccountQuota].self, forKey: .member)
                var accountQuotasBuffer:[RdsClientTypes.AccountQuota]? = nil
                if let accountQuotasContainer = accountQuotasContainer {
                    accountQuotasBuffer = [RdsClientTypes.AccountQuota]()
                    for structureContainer0 in accountQuotasContainer {
                        accountQuotasBuffer?.append(structureContainer0)
                    }
                }
                accountQuotas = accountQuotasBuffer
            } else {
                accountQuotas = []
            }
        } else {
            accountQuotas = nil
        }
    }
}

extension DescribeCertificatesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateIdentifier = certificateIdentifier {
            try container.encode(certificateIdentifier, forKey: ClientRuntime.Key("CertificateIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeCertificates", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeCertificatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeCertificatesInput: Swift.Equatable {
    /// The user-supplied certificate identifier. If this parameter is specified, information for only the identified certificate is returned. This parameter isn't case-sensitive. Constraints:
    ///
    /// * Must match an existing CertificateIdentifier.
    public var certificateIdentifier: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous DescribeCertificates request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        certificateIdentifier: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.certificateIdentifier = certificateIdentifier
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeCertificatesInputBody: Swift.Equatable {
    let certificateIdentifier: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeCertificatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateIdentifier = "CertificateIdentifier"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateIdentifier)
        certificateIdentifier = certificateIdentifierDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeCertificatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeCertificatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CertificateNotFound" : self = .certificateNotFoundFault(try CertificateNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCertificatesOutputError: Swift.Error, Swift.Equatable {
    case certificateNotFoundFault(CertificateNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCertificatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificates = output.certificates
            self.marker = output.marker
        } else {
            self.certificates = nil
            self.marker = nil
        }
    }
}

/// Data returned by the DescribeCertificates action.
public struct DescribeCertificatesOutputResponse: Swift.Equatable {
    /// The list of Certificate objects for the Amazon Web Services account.
    public var certificates: [RdsClientTypes.Certificate]?
    /// An optional pagination token provided by a previous DescribeCertificates request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords .
    public var marker: Swift.String?

    public init (
        certificates: [RdsClientTypes.Certificate]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.certificates = certificates
        self.marker = marker
    }
}

struct DescribeCertificatesOutputResponseBody: Swift.Equatable {
    let certificates: [RdsClientTypes.Certificate]?
    let marker: Swift.String?
}

extension DescribeCertificatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificates = "Certificates"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeCertificatesResult"))
        if containerValues.contains(.certificates) {
            struct KeyVal0{struct Certificate{}}
            let certificatesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Certificate>.CodingKeys.self, forKey: .certificates)
            if let certificatesWrappedContainer = certificatesWrappedContainer {
                let certificatesContainer = try certificatesWrappedContainer.decodeIfPresent([RdsClientTypes.Certificate].self, forKey: .member)
                var certificatesBuffer:[RdsClientTypes.Certificate]? = nil
                if let certificatesContainer = certificatesContainer {
                    certificatesBuffer = [RdsClientTypes.Certificate]()
                    for structureContainer0 in certificatesContainer {
                        certificatesBuffer?.append(structureContainer0)
                    }
                }
                certificates = certificatesBuffer
            } else {
                certificates = []
            }
        } else {
            certificates = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeCustomAvailabilityZonesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let customAvailabilityZoneId = customAvailabilityZoneId {
            try container.encode(customAvailabilityZoneId, forKey: ClientRuntime.Key("CustomAvailabilityZoneId"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeCustomAvailabilityZones", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeCustomAvailabilityZonesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCustomAvailabilityZonesInput: Swift.Equatable {
    /// The custom AZ identifier. If this parameter is specified, information from only the specific custom AZ is returned.
    public var customAvailabilityZoneId: Swift.String?
    /// A filter that specifies one or more custom AZs to describe.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous DescribeCustomAvailabilityZones request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        customAvailabilityZoneId: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.customAvailabilityZoneId = customAvailabilityZoneId
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeCustomAvailabilityZonesInputBody: Swift.Equatable {
    let customAvailabilityZoneId: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeCustomAvailabilityZonesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customAvailabilityZoneId = "CustomAvailabilityZoneId"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customAvailabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customAvailabilityZoneId)
        customAvailabilityZoneId = customAvailabilityZoneIdDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeCustomAvailabilityZonesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeCustomAvailabilityZonesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CustomAvailabilityZoneNotFound" : self = .customAvailabilityZoneNotFoundFault(try CustomAvailabilityZoneNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCustomAvailabilityZonesOutputError: Swift.Error, Swift.Equatable {
    case customAvailabilityZoneNotFoundFault(CustomAvailabilityZoneNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCustomAvailabilityZonesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCustomAvailabilityZonesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customAvailabilityZones = output.customAvailabilityZones
            self.marker = output.marker
        } else {
            self.customAvailabilityZones = nil
            self.marker = nil
        }
    }
}

public struct DescribeCustomAvailabilityZonesOutputResponse: Swift.Equatable {
    /// The list of [CustomAvailabilityZone] objects for the Amazon Web Services account.
    public var customAvailabilityZones: [RdsClientTypes.CustomAvailabilityZone]?
    /// An optional pagination token provided by a previous DescribeCustomAvailabilityZones request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init (
        customAvailabilityZones: [RdsClientTypes.CustomAvailabilityZone]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.customAvailabilityZones = customAvailabilityZones
        self.marker = marker
    }
}

struct DescribeCustomAvailabilityZonesOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let customAvailabilityZones: [RdsClientTypes.CustomAvailabilityZone]?
}

extension DescribeCustomAvailabilityZonesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customAvailabilityZones = "CustomAvailabilityZones"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeCustomAvailabilityZonesResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.customAvailabilityZones) {
            struct KeyVal0{struct CustomAvailabilityZone{}}
            let customAvailabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CustomAvailabilityZone>.CodingKeys.self, forKey: .customAvailabilityZones)
            if let customAvailabilityZonesWrappedContainer = customAvailabilityZonesWrappedContainer {
                let customAvailabilityZonesContainer = try customAvailabilityZonesWrappedContainer.decodeIfPresent([RdsClientTypes.CustomAvailabilityZone].self, forKey: .member)
                var customAvailabilityZonesBuffer:[RdsClientTypes.CustomAvailabilityZone]? = nil
                if let customAvailabilityZonesContainer = customAvailabilityZonesContainer {
                    customAvailabilityZonesBuffer = [RdsClientTypes.CustomAvailabilityZone]()
                    for structureContainer0 in customAvailabilityZonesContainer {
                        customAvailabilityZonesBuffer?.append(structureContainer0)
                    }
                }
                customAvailabilityZones = customAvailabilityZonesBuffer
            } else {
                customAvailabilityZones = []
            }
        } else {
            customAvailabilityZones = nil
        }
    }
}

extension DescribeDBClusterBacktracksInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let backtrackIdentifier = backtrackIdentifier {
            try container.encode(backtrackIdentifier, forKey: ClientRuntime.Key("BacktrackIdentifier"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBClusterBacktracks", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDBClusterBacktracksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeDBClusterBacktracksInput: Swift.Equatable {
    /// If specified, this value is the backtrack identifier of the backtrack to be described. Constraints:
    ///
    /// * Must contain a valid universally unique identifier (UUID). For more information about UUIDs, see [A Universally Unique Identifier (UUID) URN Namespace](http://www.ietf.org/rfc/rfc4122.txt).
    ///
    ///
    /// Example: 123e4567-e89b-12d3-a456-426655440000
    public var backtrackIdentifier: Swift.String?
    /// The DB cluster identifier of the DB cluster to be described. This parameter is stored as a lowercase string. Constraints:
    ///
    /// * Must contain from 1 to 63 alphanumeric characters or hyphens.
    ///
    /// * First character must be a letter.
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    /// Example: my-cluster1
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// A filter that specifies one or more DB clusters to describe. Supported filters include the following:
    ///
    /// * db-cluster-backtrack-id - Accepts backtrack identifiers. The results list includes information about only the backtracks identified by these identifiers.
    ///
    /// * db-cluster-backtrack-status - Accepts any of the following backtrack status values:
    ///
    /// * applying
    ///
    /// * completed
    ///
    /// * failed
    ///
    /// * pending
    ///
    ///
    /// The results list includes information about only the backtracks identified by these values.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous DescribeDBClusterBacktracks request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        backtrackIdentifier: Swift.String? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.backtrackIdentifier = backtrackIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeDBClusterBacktracksInputBody: Swift.Equatable {
    let dBClusterIdentifier: Swift.String?
    let backtrackIdentifier: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeDBClusterBacktracksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backtrackIdentifier = "BacktrackIdentifier"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let backtrackIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backtrackIdentifier)
        backtrackIdentifier = backtrackIdentifierDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeDBClusterBacktracksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterBacktracksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterBacktrackNotFoundFault" : self = .dBClusterBacktrackNotFoundFault(try DBClusterBacktrackNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterBacktracksOutputError: Swift.Error, Swift.Equatable {
    case dBClusterBacktrackNotFoundFault(DBClusterBacktrackNotFoundFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterBacktracksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBClusterBacktracksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterBacktracks = output.dBClusterBacktracks
            self.marker = output.marker
        } else {
            self.dBClusterBacktracks = nil
            self.marker = nil
        }
    }
}

/// Contains the result of a successful invocation of the DescribeDBClusterBacktracks action.
public struct DescribeDBClusterBacktracksOutputResponse: Swift.Equatable {
    /// Contains a list of backtracks for the user.
    public var dBClusterBacktracks: [RdsClientTypes.DBClusterBacktrack]?
    /// A pagination token that can be used in a later DescribeDBClusterBacktracks request.
    public var marker: Swift.String?

    public init (
        dBClusterBacktracks: [RdsClientTypes.DBClusterBacktrack]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBClusterBacktracks = dBClusterBacktracks
        self.marker = marker
    }
}

struct DescribeDBClusterBacktracksOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let dBClusterBacktracks: [RdsClientTypes.DBClusterBacktrack]?
}

extension DescribeDBClusterBacktracksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterBacktracks = "DBClusterBacktracks"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBClusterBacktracksResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBClusterBacktracks) {
            struct KeyVal0{struct DBClusterBacktrack{}}
            let dBClusterBacktracksWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterBacktrack>.CodingKeys.self, forKey: .dBClusterBacktracks)
            if let dBClusterBacktracksWrappedContainer = dBClusterBacktracksWrappedContainer {
                let dBClusterBacktracksContainer = try dBClusterBacktracksWrappedContainer.decodeIfPresent([RdsClientTypes.DBClusterBacktrack].self, forKey: .member)
                var dBClusterBacktracksBuffer:[RdsClientTypes.DBClusterBacktrack]? = nil
                if let dBClusterBacktracksContainer = dBClusterBacktracksContainer {
                    dBClusterBacktracksBuffer = [RdsClientTypes.DBClusterBacktrack]()
                    for structureContainer0 in dBClusterBacktracksContainer {
                        dBClusterBacktracksBuffer?.append(structureContainer0)
                    }
                }
                dBClusterBacktracks = dBClusterBacktracksBuffer
            } else {
                dBClusterBacktracks = []
            }
        } else {
            dBClusterBacktracks = nil
        }
    }
}

extension DescribeDBClusterEndpointsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: ClientRuntime.Key("DBClusterEndpointIdentifier"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBClusterEndpoints", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDBClusterEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDBClusterEndpointsInput: Swift.Equatable {
    /// The identifier of the endpoint to describe. This parameter is stored as a lowercase string.
    public var dBClusterEndpointIdentifier: Swift.String?
    /// The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is stored as a lowercase string.
    public var dBClusterIdentifier: Swift.String?
    /// A set of name-value pairs that define which endpoints to include in the output. The filters are specified as name-value pairs, in the format Name=endpoint_type,Values=endpoint_type1,endpoint_type2,.... Name can be one of: db-cluster-endpoint-type, db-cluster-endpoint-custom-type, db-cluster-endpoint-id, db-cluster-endpoint-status. Values for the  db-cluster-endpoint-type filter can be one or more of: reader, writer, custom. Values for the db-cluster-endpoint-custom-type filter can be one or more of: reader, any. Values for the db-cluster-endpoint-status filter can be one or more of: available, creating, deleting, inactive, modifying.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous DescribeDBClusterEndpoints request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBClusterEndpointIdentifier: Swift.String? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeDBClusterEndpointsInputBody: Swift.Equatable {
    let dBClusterIdentifier: Swift.String?
    let dBClusterEndpointIdentifier: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeDBClusterEndpointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeDBClusterEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterEndpointsOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBClusterEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterEndpoints = output.dBClusterEndpoints
            self.marker = output.marker
        } else {
            self.dBClusterEndpoints = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBClusterEndpointsOutputResponse: Swift.Equatable {
    /// Contains the details of the endpoints associated with the cluster and matching any filter conditions.
    public var dBClusterEndpoints: [RdsClientTypes.DBClusterEndpoint]?
    /// An optional pagination token provided by a previous DescribeDBClusterEndpoints request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init (
        dBClusterEndpoints: [RdsClientTypes.DBClusterEndpoint]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBClusterEndpoints = dBClusterEndpoints
        self.marker = marker
    }
}

struct DescribeDBClusterEndpointsOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let dBClusterEndpoints: [RdsClientTypes.DBClusterEndpoint]?
}

extension DescribeDBClusterEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterEndpoints = "DBClusterEndpoints"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBClusterEndpointsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBClusterEndpoints) {
            struct KeyVal0{struct DBClusterEndpointList{}}
            let dBClusterEndpointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterEndpointList>.CodingKeys.self, forKey: .dBClusterEndpoints)
            if let dBClusterEndpointsWrappedContainer = dBClusterEndpointsWrappedContainer {
                let dBClusterEndpointsContainer = try dBClusterEndpointsWrappedContainer.decodeIfPresent([RdsClientTypes.DBClusterEndpoint].self, forKey: .member)
                var dBClusterEndpointsBuffer:[RdsClientTypes.DBClusterEndpoint]? = nil
                if let dBClusterEndpointsContainer = dBClusterEndpointsContainer {
                    dBClusterEndpointsBuffer = [RdsClientTypes.DBClusterEndpoint]()
                    for structureContainer0 in dBClusterEndpointsContainer {
                        dBClusterEndpointsBuffer?.append(structureContainer0)
                    }
                }
                dBClusterEndpoints = dBClusterEndpointsBuffer
            } else {
                dBClusterEndpoints = []
            }
        } else {
            dBClusterEndpoints = nil
        }
    }
}

extension DescribeDBClusterParameterGroupsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBClusterParameterGroups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDBClusterParameterGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeDBClusterParameterGroupsInput: Swift.Equatable {
    /// The name of a specific DB cluster parameter group to return details for. Constraints:
    ///
    /// * If supplied, must match the name of an existing DBClusterParameterGroup.
    public var dBClusterParameterGroupName: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous DescribeDBClusterParameterGroups request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBClusterParameterGroupName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeDBClusterParameterGroupsInputBody: Swift.Equatable {
    let dBClusterParameterGroupName: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeDBClusterParameterGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeDBClusterParameterGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterParameterGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterParameterGroupsOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterParameterGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBClusterParameterGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterParameterGroups = output.dBClusterParameterGroups
            self.marker = output.marker
        } else {
            self.dBClusterParameterGroups = nil
            self.marker = nil
        }
    }
}

///
public struct DescribeDBClusterParameterGroupsOutputResponse: Swift.Equatable {
    /// A list of DB cluster parameter groups.
    public var dBClusterParameterGroups: [RdsClientTypes.DBClusterParameterGroup]?
    /// An optional pagination token provided by a previous DescribeDBClusterParameterGroups request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init (
        dBClusterParameterGroups: [RdsClientTypes.DBClusterParameterGroup]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBClusterParameterGroups = dBClusterParameterGroups
        self.marker = marker
    }
}

struct DescribeDBClusterParameterGroupsOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let dBClusterParameterGroups: [RdsClientTypes.DBClusterParameterGroup]?
}

extension DescribeDBClusterParameterGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroups = "DBClusterParameterGroups"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBClusterParameterGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBClusterParameterGroups) {
            struct KeyVal0{struct DBClusterParameterGroup{}}
            let dBClusterParameterGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterParameterGroup>.CodingKeys.self, forKey: .dBClusterParameterGroups)
            if let dBClusterParameterGroupsWrappedContainer = dBClusterParameterGroupsWrappedContainer {
                let dBClusterParameterGroupsContainer = try dBClusterParameterGroupsWrappedContainer.decodeIfPresent([RdsClientTypes.DBClusterParameterGroup].self, forKey: .member)
                var dBClusterParameterGroupsBuffer:[RdsClientTypes.DBClusterParameterGroup]? = nil
                if let dBClusterParameterGroupsContainer = dBClusterParameterGroupsContainer {
                    dBClusterParameterGroupsBuffer = [RdsClientTypes.DBClusterParameterGroup]()
                    for structureContainer0 in dBClusterParameterGroupsContainer {
                        dBClusterParameterGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBClusterParameterGroups = dBClusterParameterGroupsBuffer
            } else {
                dBClusterParameterGroups = []
            }
        } else {
            dBClusterParameterGroups = nil
        }
    }
}

extension DescribeDBClusterParametersInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let source = source {
            try container.encode(source, forKey: ClientRuntime.Key("Source"))
        }
        try container.encode("DescribeDBClusterParameters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDBClusterParametersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeDBClusterParametersInput: Swift.Equatable {
    /// The name of a specific DB cluster parameter group to return parameter details for. Constraints:
    ///
    /// * If supplied, must match the name of an existing DBClusterParameterGroup.
    /// This member is required.
    public var dBClusterParameterGroupName: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous DescribeDBClusterParameters request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// A value that indicates to return only parameters for a specific source. Parameter sources can be engine, service, or customer.
    public var source: Swift.String?

    public init (
        dBClusterParameterGroupName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        source: Swift.String? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.source = source
    }
}

struct DescribeDBClusterParametersInputBody: Swift.Equatable {
    let dBClusterParameterGroupName: Swift.String?
    let source: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeDBClusterParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case source = "Source"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeDBClusterParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterParametersOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBClusterParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.parameters = output.parameters
        } else {
            self.marker = nil
            self.parameters = nil
        }
    }
}

/// Provides details about a DB cluster parameter group including the parameters in the DB cluster parameter group.
public struct DescribeDBClusterParametersOutputResponse: Swift.Equatable {
    /// An optional pagination token provided by a previous DescribeDBClusterParameters request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords .
    public var marker: Swift.String?
    /// Provides a list of parameters for the DB cluster parameter group.
    public var parameters: [RdsClientTypes.Parameter]?

    public init (
        marker: Swift.String? = nil,
        parameters: [RdsClientTypes.Parameter]? = nil
    )
    {
        self.marker = marker
        self.parameters = parameters
    }
}

struct DescribeDBClusterParametersOutputResponseBody: Swift.Equatable {
    let parameters: [RdsClientTypes.Parameter]?
    let marker: Swift.String?
}

extension DescribeDBClusterParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBClusterParametersResult"))
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct Parameter{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Parameter>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([RdsClientTypes.Parameter].self, forKey: .member)
                var parametersBuffer:[RdsClientTypes.Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [RdsClientTypes.Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeDBClusterSnapshotAttributesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("DBClusterSnapshotIdentifier"))
        }
        try container.encode("DescribeDBClusterSnapshotAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDBClusterSnapshotAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeDBClusterSnapshotAttributesInput: Swift.Equatable {
    /// The identifier for the DB cluster snapshot to describe the attributes for.
    /// This member is required.
    public var dBClusterSnapshotIdentifier: Swift.String?

    public init (
        dBClusterSnapshotIdentifier: Swift.String? = nil
    )
    {
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
    }
}

struct DescribeDBClusterSnapshotAttributesInputBody: Swift.Equatable {
    let dBClusterSnapshotIdentifier: Swift.String?
}

extension DescribeDBClusterSnapshotAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterSnapshotIdentifier = "DBClusterSnapshotIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterSnapshotIdentifier)
        dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifierDecoded
    }
}

extension DescribeDBClusterSnapshotAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterSnapshotAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterSnapshotAttributesOutputError: Swift.Error, Swift.Equatable {
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterSnapshotAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBClusterSnapshotAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterSnapshotAttributesResult = output.dBClusterSnapshotAttributesResult
        } else {
            self.dBClusterSnapshotAttributesResult = nil
        }
    }
}

public struct DescribeDBClusterSnapshotAttributesOutputResponse: Swift.Equatable {
    /// Contains the results of a successful call to the DescribeDBClusterSnapshotAttributes API action. Manual DB cluster snapshot attributes are used to authorize other Amazon Web Services accounts to copy or restore a manual DB cluster snapshot. For more information, see the ModifyDBClusterSnapshotAttribute API action.
    public var dBClusterSnapshotAttributesResult: RdsClientTypes.DBClusterSnapshotAttributesResult?

    public init (
        dBClusterSnapshotAttributesResult: RdsClientTypes.DBClusterSnapshotAttributesResult? = nil
    )
    {
        self.dBClusterSnapshotAttributesResult = dBClusterSnapshotAttributesResult
    }
}

struct DescribeDBClusterSnapshotAttributesOutputResponseBody: Swift.Equatable {
    let dBClusterSnapshotAttributesResult: RdsClientTypes.DBClusterSnapshotAttributesResult?
}

extension DescribeDBClusterSnapshotAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterSnapshotAttributesResult = "DBClusterSnapshotAttributesResult"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBClusterSnapshotAttributesResult"))
        let dBClusterSnapshotAttributesResultDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBClusterSnapshotAttributesResult.self, forKey: .dBClusterSnapshotAttributesResult)
        dBClusterSnapshotAttributesResult = dBClusterSnapshotAttributesResultDecoded
    }
}

extension DescribeDBClusterSnapshotsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("DBClusterSnapshotIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if includePublic != false {
            try container.encode(includePublic, forKey: ClientRuntime.Key("IncludePublic"))
        }
        if includeShared != false {
            try container.encode(includeShared, forKey: ClientRuntime.Key("IncludeShared"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let snapshotType = snapshotType {
            try container.encode(snapshotType, forKey: ClientRuntime.Key("SnapshotType"))
        }
        try container.encode("DescribeDBClusterSnapshots", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDBClusterSnapshotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeDBClusterSnapshotsInput: Swift.Equatable {
    /// The ID of the DB cluster to retrieve the list of DB cluster snapshots for. This parameter can't be used in conjunction with the DBClusterSnapshotIdentifier parameter. This parameter isn't case-sensitive. Constraints:
    ///
    /// * If supplied, must match the identifier of an existing DBCluster.
    public var dBClusterIdentifier: Swift.String?
    /// A specific DB cluster snapshot identifier to describe. This parameter can't be used in conjunction with the DBClusterIdentifier parameter. This value is stored as a lowercase string. Constraints:
    ///
    /// * If supplied, must match the identifier of an existing DBClusterSnapshot.
    ///
    /// * If this identifier is for an automated snapshot, the SnapshotType parameter must also be specified.
    public var dBClusterSnapshotIdentifier: Swift.String?
    /// A filter that specifies one or more DB cluster snapshots to describe. Supported filters:
    ///
    /// * db-cluster-id - Accepts DB cluster identifiers and DB cluster Amazon Resource Names (ARNs).
    ///
    /// * db-cluster-snapshot-id - Accepts DB cluster snapshot identifiers.
    ///
    /// * snapshot-type - Accepts types of DB cluster snapshots.
    ///
    /// * engine - Accepts names of database engines.
    public var filters: [RdsClientTypes.Filter]?
    /// A value that indicates whether to include manual DB cluster snapshots that are public and can be copied or restored by any Amazon Web Services account. By default, the public snapshots are not included. You can share a manual DB cluster snapshot as public by using the [ModifyDBClusterSnapshotAttribute] API action.
    public var includePublic: Swift.Bool
    /// A value that indicates whether to include shared manual DB cluster snapshots from other Amazon Web Services accounts that this Amazon Web Services account has been given permission to copy or restore. By default, these snapshots are not included. You can give an Amazon Web Services account permission to restore a manual DB cluster snapshot from another Amazon Web Services account by the ModifyDBClusterSnapshotAttribute API action.
    public var includeShared: Swift.Bool
    /// An optional pagination token provided by a previous DescribeDBClusterSnapshots request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The type of DB cluster snapshots to be returned. You can specify one of the following values:
    ///
    /// * automated - Return all DB cluster snapshots that have been automatically taken by Amazon RDS for my Amazon Web Services account.
    ///
    /// * manual - Return all DB cluster snapshots that have been taken by my Amazon Web Services account.
    ///
    /// * shared - Return all manual DB cluster snapshots that have been shared to my Amazon Web Services account.
    ///
    /// * public - Return all DB cluster snapshots that have been marked as public.
    ///
    ///
    /// If you don't specify a SnapshotType value, then both automated and manual DB cluster snapshots are returned. You can include shared DB cluster snapshots with these results by enabling the IncludeShared parameter. You can include public DB cluster snapshots with these results by enabling the IncludePublic parameter. The IncludeShared and IncludePublic parameters don't apply for SnapshotType values of manual or automated. The IncludePublic parameter doesn't apply when SnapshotType is set to shared. The IncludeShared parameter doesn't apply when SnapshotType is set to public.
    public var snapshotType: Swift.String?

    public init (
        dBClusterIdentifier: Swift.String? = nil,
        dBClusterSnapshotIdentifier: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        includePublic: Swift.Bool = false,
        includeShared: Swift.Bool = false,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        snapshotType: Swift.String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
        self.filters = filters
        self.includePublic = includePublic
        self.includeShared = includeShared
        self.marker = marker
        self.maxRecords = maxRecords
        self.snapshotType = snapshotType
    }
}

struct DescribeDBClusterSnapshotsInputBody: Swift.Equatable {
    let dBClusterIdentifier: Swift.String?
    let dBClusterSnapshotIdentifier: Swift.String?
    let snapshotType: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
    let includeShared: Swift.Bool
    let includePublic: Swift.Bool
}

extension DescribeDBClusterSnapshotsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBClusterSnapshotIdentifier = "DBClusterSnapshotIdentifier"
        case filters = "Filters"
        case includePublic = "IncludePublic"
        case includeShared = "IncludeShared"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case snapshotType = "SnapshotType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterSnapshotIdentifier)
        dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifierDecoded
        let snapshotTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotType)
        snapshotType = snapshotTypeDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let includeSharedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeShared)
        includeShared = includeSharedDecoded
        let includePublicDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includePublic)
        includePublic = includePublicDecoded
    }
}

extension DescribeDBClusterSnapshotsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterSnapshotsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterSnapshotsOutputError: Swift.Error, Swift.Equatable {
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterSnapshotsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBClusterSnapshotsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterSnapshots = output.dBClusterSnapshots
            self.marker = output.marker
        } else {
            self.dBClusterSnapshots = nil
            self.marker = nil
        }
    }
}

/// Provides a list of DB cluster snapshots for the user as the result of a call to the DescribeDBClusterSnapshots action.
public struct DescribeDBClusterSnapshotsOutputResponse: Swift.Equatable {
    /// Provides a list of DB cluster snapshots for the user.
    public var dBClusterSnapshots: [RdsClientTypes.DBClusterSnapshot]?
    /// An optional pagination token provided by a previous DescribeDBClusterSnapshots request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init (
        dBClusterSnapshots: [RdsClientTypes.DBClusterSnapshot]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBClusterSnapshots = dBClusterSnapshots
        self.marker = marker
    }
}

struct DescribeDBClusterSnapshotsOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let dBClusterSnapshots: [RdsClientTypes.DBClusterSnapshot]?
}

extension DescribeDBClusterSnapshotsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterSnapshots = "DBClusterSnapshots"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBClusterSnapshotsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBClusterSnapshots) {
            struct KeyVal0{struct DBClusterSnapshot{}}
            let dBClusterSnapshotsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterSnapshot>.CodingKeys.self, forKey: .dBClusterSnapshots)
            if let dBClusterSnapshotsWrappedContainer = dBClusterSnapshotsWrappedContainer {
                let dBClusterSnapshotsContainer = try dBClusterSnapshotsWrappedContainer.decodeIfPresent([RdsClientTypes.DBClusterSnapshot].self, forKey: .member)
                var dBClusterSnapshotsBuffer:[RdsClientTypes.DBClusterSnapshot]? = nil
                if let dBClusterSnapshotsContainer = dBClusterSnapshotsContainer {
                    dBClusterSnapshotsBuffer = [RdsClientTypes.DBClusterSnapshot]()
                    for structureContainer0 in dBClusterSnapshotsContainer {
                        dBClusterSnapshotsBuffer?.append(structureContainer0)
                    }
                }
                dBClusterSnapshots = dBClusterSnapshotsBuffer
            } else {
                dBClusterSnapshots = []
            }
        } else {
            dBClusterSnapshots = nil
        }
    }
}

extension DescribeDBClustersInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if includeShared != false {
            try container.encode(includeShared, forKey: ClientRuntime.Key("IncludeShared"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBClusters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDBClustersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeDBClustersInput: Swift.Equatable {
    /// The user-supplied DB cluster identifier. If this parameter is specified, information from only the specific DB cluster is returned. This parameter isn't case-sensitive. Constraints:
    ///
    /// * If supplied, must match an existing DBClusterIdentifier.
    public var dBClusterIdentifier: Swift.String?
    /// A filter that specifies one or more DB clusters to describe. Supported filters:
    ///
    /// * clone-group-id - Accepts clone group identifiers. The results list will only include information about the DB clusters associated with these clone groups.
    ///
    /// * db-cluster-id - Accepts DB cluster identifiers and DB cluster Amazon Resource Names (ARNs). The results list will only include information about the DB clusters identified by these ARNs.
    ///
    /// * domain - Accepts Active Directory directory IDs. The results list will only include information about the DB clusters associated with these domains.
    ///
    /// * engine - Accepts engine names. The results list will only include information about the DB clusters for these engines.
    public var filters: [RdsClientTypes.Filter]?
    /// Optional Boolean parameter that specifies whether the output includes information about clusters shared from other Amazon Web Services accounts.
    public var includeShared: Swift.Bool
    /// An optional pagination token provided by a previous DescribeDBClusters request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBClusterIdentifier: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        includeShared: Swift.Bool = false,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.filters = filters
        self.includeShared = includeShared
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeDBClustersInputBody: Swift.Equatable {
    let dBClusterIdentifier: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
    let includeShared: Swift.Bool
}

extension DescribeDBClustersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterIdentifier = "DBClusterIdentifier"
        case filters = "Filters"
        case includeShared = "IncludeShared"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let includeSharedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeShared)
        includeShared = includeSharedDecoded
    }
}

extension DescribeDBClustersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClustersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClustersOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClustersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBClustersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusters = output.dBClusters
            self.marker = output.marker
        } else {
            self.dBClusters = nil
            self.marker = nil
        }
    }
}

/// Contains the result of a successful invocation of the DescribeDBClusters action.
public struct DescribeDBClustersOutputResponse: Swift.Equatable {
    /// Contains a list of DB clusters for the user.
    public var dBClusters: [RdsClientTypes.DBCluster]?
    /// A pagination token that can be used in a later DescribeDBClusters request.
    public var marker: Swift.String?

    public init (
        dBClusters: [RdsClientTypes.DBCluster]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBClusters = dBClusters
        self.marker = marker
    }
}

struct DescribeDBClustersOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let dBClusters: [RdsClientTypes.DBCluster]?
}

extension DescribeDBClustersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusters = "DBClusters"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBClustersResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBClusters) {
            struct KeyVal0{struct DBCluster{}}
            let dBClustersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBCluster>.CodingKeys.self, forKey: .dBClusters)
            if let dBClustersWrappedContainer = dBClustersWrappedContainer {
                let dBClustersContainer = try dBClustersWrappedContainer.decodeIfPresent([RdsClientTypes.DBCluster].self, forKey: .member)
                var dBClustersBuffer:[RdsClientTypes.DBCluster]? = nil
                if let dBClustersContainer = dBClustersContainer {
                    dBClustersBuffer = [RdsClientTypes.DBCluster]()
                    for structureContainer0 in dBClustersContainer {
                        dBClustersBuffer?.append(structureContainer0)
                    }
                }
                dBClusters = dBClustersBuffer
            } else {
                dBClusters = []
            }
        } else {
            dBClusters = nil
        }
    }
}

extension DescribeDBEngineVersionsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if defaultOnly != false {
            try container.encode(defaultOnly, forKey: ClientRuntime.Key("DefaultOnly"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let includeAll = includeAll {
            try container.encode(includeAll, forKey: ClientRuntime.Key("IncludeAll"))
        }
        if let listSupportedCharacterSets = listSupportedCharacterSets {
            try container.encode(listSupportedCharacterSets, forKey: ClientRuntime.Key("ListSupportedCharacterSets"))
        }
        if let listSupportedTimezones = listSupportedTimezones {
            try container.encode(listSupportedTimezones, forKey: ClientRuntime.Key("ListSupportedTimezones"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBEngineVersions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDBEngineVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDBEngineVersionsInput: Swift.Equatable {
    /// The name of a specific DB parameter group family to return details for. Constraints:
    ///
    /// * If supplied, must match an existing DBParameterGroupFamily.
    public var dBParameterGroupFamily: Swift.String?
    /// A value that indicates whether only the default version of the specified engine or engine and major version combination is returned.
    public var defaultOnly: Swift.Bool
    /// The database engine to return. Valid Values:
    ///
    /// * aurora (for MySQL 5.6-compatible Aurora)
    ///
    /// * aurora-mysql (for MySQL 5.7-compatible Aurora)
    ///
    /// * aurora-postgresql
    ///
    /// * mariadb
    ///
    /// * mysql
    ///
    /// * oracle-ee
    ///
    /// * oracle-ee-cdb
    ///
    /// * oracle-se2
    ///
    /// * oracle-se2-cdb
    ///
    /// * postgres
    ///
    /// * sqlserver-ee
    ///
    /// * sqlserver-se
    ///
    /// * sqlserver-ex
    ///
    /// * sqlserver-web
    public var engine: Swift.String?
    /// The database engine version to return. Example: 5.1.49
    public var engineVersion: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// A value that indicates whether to include engine versions that aren't available in the list. The default is to list only available engine versions.
    public var includeAll: Swift.Bool?
    /// A value that indicates whether to list the supported character sets for each engine version. If this parameter is enabled and the requested engine supports the CharacterSetName parameter for CreateDBInstance, the response includes a list of supported character sets for each engine version. For RDS Custom, the default is not to list supported character sets. If you set ListSupportedCharacterSets to true, RDS Custom returns no results.
    public var listSupportedCharacterSets: Swift.Bool?
    /// A value that indicates whether to list the supported time zones for each engine version. If this parameter is enabled and the requested engine supports the TimeZone parameter for CreateDBInstance, the response includes a list of supported time zones for each engine version. For RDS Custom, the default is not to list supported time zones. If you set ListSupportedTimezones to true, RDS Custom returns no results.
    public var listSupportedTimezones: Swift.Bool?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more than the MaxRecords value is available, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBParameterGroupFamily: Swift.String? = nil,
        defaultOnly: Swift.Bool = false,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        includeAll: Swift.Bool? = nil,
        listSupportedCharacterSets: Swift.Bool? = nil,
        listSupportedTimezones: Swift.Bool? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.defaultOnly = defaultOnly
        self.engine = engine
        self.engineVersion = engineVersion
        self.filters = filters
        self.includeAll = includeAll
        self.listSupportedCharacterSets = listSupportedCharacterSets
        self.listSupportedTimezones = listSupportedTimezones
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeDBEngineVersionsInputBody: Swift.Equatable {
    let engine: Swift.String?
    let engineVersion: Swift.String?
    let dBParameterGroupFamily: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
    let defaultOnly: Swift.Bool
    let listSupportedCharacterSets: Swift.Bool?
    let listSupportedTimezones: Swift.Bool?
    let includeAll: Swift.Bool?
}

extension DescribeDBEngineVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case defaultOnly = "DefaultOnly"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case filters = "Filters"
        case includeAll = "IncludeAll"
        case listSupportedCharacterSets = "ListSupportedCharacterSets"
        case listSupportedTimezones = "ListSupportedTimezones"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let defaultOnlyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .defaultOnly)
        defaultOnly = defaultOnlyDecoded
        let listSupportedCharacterSetsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .listSupportedCharacterSets)
        listSupportedCharacterSets = listSupportedCharacterSetsDecoded
        let listSupportedTimezonesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .listSupportedTimezones)
        listSupportedTimezones = listSupportedTimezonesDecoded
        let includeAllDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeAll)
        includeAll = includeAllDecoded
    }
}

extension DescribeDBEngineVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBEngineVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBEngineVersionsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBEngineVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBEngineVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBEngineVersions = output.dBEngineVersions
            self.marker = output.marker
        } else {
            self.dBEngineVersions = nil
            self.marker = nil
        }
    }
}

/// Contains the result of a successful invocation of the DescribeDBEngineVersions action.
public struct DescribeDBEngineVersionsOutputResponse: Swift.Equatable {
    /// A list of DBEngineVersion elements.
    public var dBEngineVersions: [RdsClientTypes.DBEngineVersion]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init (
        dBEngineVersions: [RdsClientTypes.DBEngineVersion]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBEngineVersions = dBEngineVersions
        self.marker = marker
    }
}

struct DescribeDBEngineVersionsOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let dBEngineVersions: [RdsClientTypes.DBEngineVersion]?
}

extension DescribeDBEngineVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBEngineVersions = "DBEngineVersions"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBEngineVersionsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBEngineVersions) {
            struct KeyVal0{struct DBEngineVersion{}}
            let dBEngineVersionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBEngineVersion>.CodingKeys.self, forKey: .dBEngineVersions)
            if let dBEngineVersionsWrappedContainer = dBEngineVersionsWrappedContainer {
                let dBEngineVersionsContainer = try dBEngineVersionsWrappedContainer.decodeIfPresent([RdsClientTypes.DBEngineVersion].self, forKey: .member)
                var dBEngineVersionsBuffer:[RdsClientTypes.DBEngineVersion]? = nil
                if let dBEngineVersionsContainer = dBEngineVersionsContainer {
                    dBEngineVersionsBuffer = [RdsClientTypes.DBEngineVersion]()
                    for structureContainer0 in dBEngineVersionsContainer {
                        dBEngineVersionsBuffer?.append(structureContainer0)
                    }
                }
                dBEngineVersions = dBEngineVersionsBuffer
            } else {
                dBEngineVersions = []
            }
        } else {
            dBEngineVersions = nil
        }
    }
}

extension DescribeDBInstanceAutomatedBackupsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn {
            try container.encode(dBInstanceAutomatedBackupsArn, forKey: ClientRuntime.Key("DBInstanceAutomatedBackupsArn"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dbiResourceId = dbiResourceId {
            try container.encode(dbiResourceId, forKey: ClientRuntime.Key("DbiResourceId"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBInstanceAutomatedBackups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDBInstanceAutomatedBackupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Parameter input for DescribeDBInstanceAutomatedBackups.
public struct DescribeDBInstanceAutomatedBackupsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the replicated automated backups, for example, arn:aws:rds:us-east-1:123456789012:auto-backup:ab-L2IJCEXJP7XQ7HOJ4SIEXAMPLE. This setting doesn't apply to RDS Custom.
    public var dBInstanceAutomatedBackupsArn: Swift.String?
    /// (Optional) The user-supplied instance identifier. If this parameter is specified, it must match the identifier of an existing DB instance. It returns information from the specific DB instance' automated backup. This parameter isn't case-sensitive.
    public var dBInstanceIdentifier: Swift.String?
    /// The resource ID of the DB instance that is the source of the automated backup. This parameter isn't case-sensitive.
    public var dbiResourceId: Swift.String?
    /// A filter that specifies which resources to return based on status. Supported filters are the following:
    ///
    /// * status
    ///
    /// * active - automated backups for current instances
    ///
    /// * retained - automated backups for deleted instances and after backup replication is stopped
    ///
    /// * creating - automated backups that are waiting for the first automated snapshot to be available
    ///
    ///
    ///
    ///
    /// * db-instance-id - Accepts DB instance identifiers and Amazon Resource Names (ARNs). The results list includes only information about the DB instance automated backups identified by these ARNs.
    ///
    /// * dbi-resource-id - Accepts DB resource identifiers and Amazon Resource Names (ARNs). The results list includes only information about the DB instance resources identified by these ARNs.
    ///
    ///
    /// Returns all resources by default. The status for each resource is specified in the response.
    public var filters: [RdsClientTypes.Filter]?
    /// The pagination token provided in the previous request. If this parameter is specified the response includes only records beyond the marker, up to MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results.
    public var maxRecords: Swift.Int?

    public init (
        dBInstanceAutomatedBackupsArn: Swift.String? = nil,
        dBInstanceIdentifier: Swift.String? = nil,
        dbiResourceId: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dbiResourceId = dbiResourceId
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeDBInstanceAutomatedBackupsInputBody: Swift.Equatable {
    let dbiResourceId: Swift.String?
    let dBInstanceIdentifier: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
    let dBInstanceAutomatedBackupsArn: Swift.String?
}

extension DescribeDBInstanceAutomatedBackupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceAutomatedBackupsArn = "DBInstanceAutomatedBackupsArn"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dbiResourceId = "DbiResourceId"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dbiResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbiResourceId)
        dbiResourceId = dbiResourceIdDecoded
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let dBInstanceAutomatedBackupsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceAutomatedBackupsArn)
        dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArnDecoded
    }
}

extension DescribeDBInstanceAutomatedBackupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBInstanceAutomatedBackupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceAutomatedBackupNotFound" : self = .dBInstanceAutomatedBackupNotFoundFault(try DBInstanceAutomatedBackupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBInstanceAutomatedBackupsOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceAutomatedBackupNotFoundFault(DBInstanceAutomatedBackupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBInstanceAutomatedBackupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBInstanceAutomatedBackupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstanceAutomatedBackups = output.dBInstanceAutomatedBackups
            self.marker = output.marker
        } else {
            self.dBInstanceAutomatedBackups = nil
            self.marker = nil
        }
    }
}

/// Contains the result of a successful invocation of the DescribeDBInstanceAutomatedBackups action.
public struct DescribeDBInstanceAutomatedBackupsOutputResponse: Swift.Equatable {
    /// A list of DBInstanceAutomatedBackup instances.
    public var dBInstanceAutomatedBackups: [RdsClientTypes.DBInstanceAutomatedBackup]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords .
    public var marker: Swift.String?

    public init (
        dBInstanceAutomatedBackups: [RdsClientTypes.DBInstanceAutomatedBackup]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBInstanceAutomatedBackups = dBInstanceAutomatedBackups
        self.marker = marker
    }
}

struct DescribeDBInstanceAutomatedBackupsOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let dBInstanceAutomatedBackups: [RdsClientTypes.DBInstanceAutomatedBackup]?
}

extension DescribeDBInstanceAutomatedBackupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceAutomatedBackups = "DBInstanceAutomatedBackups"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBInstanceAutomatedBackupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBInstanceAutomatedBackups) {
            struct KeyVal0{struct DBInstanceAutomatedBackup{}}
            let dBInstanceAutomatedBackupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBInstanceAutomatedBackup>.CodingKeys.self, forKey: .dBInstanceAutomatedBackups)
            if let dBInstanceAutomatedBackupsWrappedContainer = dBInstanceAutomatedBackupsWrappedContainer {
                let dBInstanceAutomatedBackupsContainer = try dBInstanceAutomatedBackupsWrappedContainer.decodeIfPresent([RdsClientTypes.DBInstanceAutomatedBackup].self, forKey: .member)
                var dBInstanceAutomatedBackupsBuffer:[RdsClientTypes.DBInstanceAutomatedBackup]? = nil
                if let dBInstanceAutomatedBackupsContainer = dBInstanceAutomatedBackupsContainer {
                    dBInstanceAutomatedBackupsBuffer = [RdsClientTypes.DBInstanceAutomatedBackup]()
                    for structureContainer0 in dBInstanceAutomatedBackupsContainer {
                        dBInstanceAutomatedBackupsBuffer?.append(structureContainer0)
                    }
                }
                dBInstanceAutomatedBackups = dBInstanceAutomatedBackupsBuffer
            } else {
                dBInstanceAutomatedBackups = []
            }
        } else {
            dBInstanceAutomatedBackups = nil
        }
    }
}

extension DescribeDBInstancesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBInstances", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDBInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeDBInstancesInput: Swift.Equatable {
    /// The user-supplied instance identifier. If this parameter is specified, information from only the specific DB instance is returned. This parameter isn't case-sensitive. Constraints:
    ///
    /// * If supplied, must match the identifier of an existing DBInstance.
    public var dBInstanceIdentifier: Swift.String?
    /// A filter that specifies one or more DB instances to describe. Supported filters:
    ///
    /// * db-cluster-id - Accepts DB cluster identifiers and DB cluster Amazon Resource Names (ARNs). The results list will only include information about the DB instances associated with the DB clusters identified by these ARNs.
    ///
    /// * db-instance-id - Accepts DB instance identifiers and DB instance Amazon Resource Names (ARNs). The results list will only include information about the DB instances identified by these ARNs.
    ///
    /// * dbi-resource-id - Accepts DB instance resource identifiers. The results list will only include information about the DB instances identified by these DB instance resource identifiers.
    ///
    /// * domain - Accepts Active Directory directory IDs. The results list will only include information about the DB instances associated with these domains.
    ///
    /// * engine - Accepts engine names. The results list will only include information about the DB instances for these engines.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous DescribeDBInstances request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBInstanceIdentifier: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeDBInstancesInputBody: Swift.Equatable {
    let dBInstanceIdentifier: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeDBInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeDBInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBInstancesOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstances = output.dBInstances
            self.marker = output.marker
        } else {
            self.dBInstances = nil
            self.marker = nil
        }
    }
}

/// Contains the result of a successful invocation of the DescribeDBInstances action.
public struct DescribeDBInstancesOutputResponse: Swift.Equatable {
    /// A list of DBInstance instances.
    public var dBInstances: [RdsClientTypes.DBInstance]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords .
    public var marker: Swift.String?

    public init (
        dBInstances: [RdsClientTypes.DBInstance]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBInstances = dBInstances
        self.marker = marker
    }
}

struct DescribeDBInstancesOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let dBInstances: [RdsClientTypes.DBInstance]?
}

extension DescribeDBInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstances = "DBInstances"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBInstancesResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBInstances) {
            struct KeyVal0{struct DBInstance{}}
            let dBInstancesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBInstance>.CodingKeys.self, forKey: .dBInstances)
            if let dBInstancesWrappedContainer = dBInstancesWrappedContainer {
                let dBInstancesContainer = try dBInstancesWrappedContainer.decodeIfPresent([RdsClientTypes.DBInstance].self, forKey: .member)
                var dBInstancesBuffer:[RdsClientTypes.DBInstance]? = nil
                if let dBInstancesContainer = dBInstancesContainer {
                    dBInstancesBuffer = [RdsClientTypes.DBInstance]()
                    for structureContainer0 in dBInstancesContainer {
                        dBInstancesBuffer?.append(structureContainer0)
                    }
                }
                dBInstances = dBInstancesBuffer
            } else {
                dBInstances = []
            }
        } else {
            dBInstances = nil
        }
    }
}

extension RdsClientTypes.DescribeDBLogFilesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastWritten = "LastWritten"
        case logFileName = "LogFileName"
        case size = "Size"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if lastWritten != 0 {
            try container.encode(lastWritten, forKey: ClientRuntime.Key("LastWritten"))
        }
        if let logFileName = logFileName {
            try container.encode(logFileName, forKey: ClientRuntime.Key("LogFileName"))
        }
        if size != 0 {
            try container.encode(size, forKey: ClientRuntime.Key("Size"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logFileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logFileName)
        logFileName = logFileNameDecoded
        let lastWrittenDecoded = try containerValues.decode(Swift.Int.self, forKey: .lastWritten)
        lastWritten = lastWrittenDecoded
        let sizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .size)
        size = sizeDecoded
    }
}

extension RdsClientTypes {
    /// This data type is used as a response element to DescribeDBLogFiles.
    public struct DescribeDBLogFilesDetails: Swift.Equatable {
        /// A POSIX timestamp when the last log entry was written.
        public var lastWritten: Swift.Int
        /// The name of the log file for the specified DB instance.
        public var logFileName: Swift.String?
        /// The size, in bytes, of the log file for the specified DB instance.
        public var size: Swift.Int

        public init (
            lastWritten: Swift.Int = 0,
            logFileName: Swift.String? = nil,
            size: Swift.Int = 0
        )
        {
            self.lastWritten = lastWritten
            self.logFileName = logFileName
            self.size = size
        }
    }

}

extension DescribeDBLogFilesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if fileLastWritten != 0 {
            try container.encode(fileLastWritten, forKey: ClientRuntime.Key("FileLastWritten"))
        }
        if fileSize != 0 {
            try container.encode(fileSize, forKey: ClientRuntime.Key("FileSize"))
        }
        if let filenameContains = filenameContains {
            try container.encode(filenameContains, forKey: ClientRuntime.Key("FilenameContains"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBLogFiles", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDBLogFilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeDBLogFilesInput: Swift.Equatable {
    /// The customer-assigned name of the DB instance that contains the log files you want to list. Constraints:
    ///
    /// * Must match the identifier of an existing DBInstance.
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// Filters the available log files for files written since the specified date, in POSIX timestamp format with milliseconds.
    public var fileLastWritten: Swift.Int
    /// Filters the available log files for files larger than the specified size.
    public var fileSize: Swift.Int
    /// Filters the available log files for log file names that contain the specified string.
    public var filenameContains: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// The pagination token provided in the previous request. If this parameter is specified the response includes only records beyond the marker, up to MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results.
    public var maxRecords: Swift.Int?

    public init (
        dBInstanceIdentifier: Swift.String? = nil,
        fileLastWritten: Swift.Int = 0,
        fileSize: Swift.Int = 0,
        filenameContains: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.fileLastWritten = fileLastWritten
        self.fileSize = fileSize
        self.filenameContains = filenameContains
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeDBLogFilesInputBody: Swift.Equatable {
    let dBInstanceIdentifier: Swift.String?
    let filenameContains: Swift.String?
    let fileLastWritten: Swift.Int
    let fileSize: Swift.Int
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeDBLogFilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case fileLastWritten = "FileLastWritten"
        case fileSize = "FileSize"
        case filenameContains = "FilenameContains"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let filenameContainsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filenameContains)
        filenameContains = filenameContainsDecoded
        let fileLastWrittenDecoded = try containerValues.decode(Swift.Int.self, forKey: .fileLastWritten)
        fileLastWritten = fileLastWrittenDecoded
        let fileSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .fileSize)
        fileSize = fileSizeDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeDBLogFilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBLogFilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBLogFilesOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBLogFilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBLogFilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.describeDBLogFiles = output.describeDBLogFiles
            self.marker = output.marker
        } else {
            self.describeDBLogFiles = nil
            self.marker = nil
        }
    }
}

/// The response from a call to DescribeDBLogFiles.
public struct DescribeDBLogFilesOutputResponse: Swift.Equatable {
    /// The DB log files returned.
    public var describeDBLogFiles: [RdsClientTypes.DescribeDBLogFilesDetails]?
    /// A pagination token that can be used in a later DescribeDBLogFiles request.
    public var marker: Swift.String?

    public init (
        describeDBLogFiles: [RdsClientTypes.DescribeDBLogFilesDetails]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.describeDBLogFiles = describeDBLogFiles
        self.marker = marker
    }
}

struct DescribeDBLogFilesOutputResponseBody: Swift.Equatable {
    let describeDBLogFiles: [RdsClientTypes.DescribeDBLogFilesDetails]?
    let marker: Swift.String?
}

extension DescribeDBLogFilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case describeDBLogFiles = "DescribeDBLogFiles"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBLogFilesResult"))
        if containerValues.contains(.describeDBLogFiles) {
            struct KeyVal0{struct DescribeDBLogFilesDetails{}}
            let describeDBLogFilesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DescribeDBLogFilesDetails>.CodingKeys.self, forKey: .describeDBLogFiles)
            if let describeDBLogFilesWrappedContainer = describeDBLogFilesWrappedContainer {
                let describeDBLogFilesContainer = try describeDBLogFilesWrappedContainer.decodeIfPresent([RdsClientTypes.DescribeDBLogFilesDetails].self, forKey: .member)
                var describeDBLogFilesBuffer:[RdsClientTypes.DescribeDBLogFilesDetails]? = nil
                if let describeDBLogFilesContainer = describeDBLogFilesContainer {
                    describeDBLogFilesBuffer = [RdsClientTypes.DescribeDBLogFilesDetails]()
                    for structureContainer0 in describeDBLogFilesContainer {
                        describeDBLogFilesBuffer?.append(structureContainer0)
                    }
                }
                describeDBLogFiles = describeDBLogFilesBuffer
            } else {
                describeDBLogFiles = []
            }
        } else {
            describeDBLogFiles = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeDBParameterGroupsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBParameterGroups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDBParameterGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeDBParameterGroupsInput: Swift.Equatable {
    /// The name of a specific DB parameter group to return details for. Constraints:
    ///
    /// * If supplied, must match the name of an existing DBClusterParameterGroup.
    public var dBParameterGroupName: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous DescribeDBParameterGroups request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBParameterGroupName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeDBParameterGroupsInputBody: Swift.Equatable {
    let dBParameterGroupName: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeDBParameterGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupName = "DBParameterGroupName"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeDBParameterGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBParameterGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBParameterGroupsOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBParameterGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBParameterGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBParameterGroups = output.dBParameterGroups
            self.marker = output.marker
        } else {
            self.dBParameterGroups = nil
            self.marker = nil
        }
    }
}

/// Contains the result of a successful invocation of the DescribeDBParameterGroups action.
public struct DescribeDBParameterGroupsOutputResponse: Swift.Equatable {
    /// A list of DBParameterGroup instances.
    public var dBParameterGroups: [RdsClientTypes.DBParameterGroup]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init (
        dBParameterGroups: [RdsClientTypes.DBParameterGroup]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBParameterGroups = dBParameterGroups
        self.marker = marker
    }
}

struct DescribeDBParameterGroupsOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let dBParameterGroups: [RdsClientTypes.DBParameterGroup]?
}

extension DescribeDBParameterGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroups = "DBParameterGroups"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBParameterGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBParameterGroups) {
            struct KeyVal0{struct DBParameterGroup{}}
            let dBParameterGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBParameterGroup>.CodingKeys.self, forKey: .dBParameterGroups)
            if let dBParameterGroupsWrappedContainer = dBParameterGroupsWrappedContainer {
                let dBParameterGroupsContainer = try dBParameterGroupsWrappedContainer.decodeIfPresent([RdsClientTypes.DBParameterGroup].self, forKey: .member)
                var dBParameterGroupsBuffer:[RdsClientTypes.DBParameterGroup]? = nil
                if let dBParameterGroupsContainer = dBParameterGroupsContainer {
                    dBParameterGroupsBuffer = [RdsClientTypes.DBParameterGroup]()
                    for structureContainer0 in dBParameterGroupsContainer {
                        dBParameterGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBParameterGroups = dBParameterGroupsBuffer
            } else {
                dBParameterGroups = []
            }
        } else {
            dBParameterGroups = nil
        }
    }
}

extension DescribeDBParametersInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let source = source {
            try container.encode(source, forKey: ClientRuntime.Key("Source"))
        }
        try container.encode("DescribeDBParameters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDBParametersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDBParametersInput: Swift.Equatable {
    /// The name of a specific DB parameter group to return details for. Constraints:
    ///
    /// * If supplied, must match the name of an existing DBParameterGroup.
    /// This member is required.
    public var dBParameterGroupName: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous DescribeDBParameters request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The parameter types to return. Default: All parameter types returned Valid Values: user | system | engine-default
    public var source: Swift.String?

    public init (
        dBParameterGroupName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        source: Swift.String? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.source = source
    }
}

struct DescribeDBParametersInputBody: Swift.Equatable {
    let dBParameterGroupName: Swift.String?
    let source: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeDBParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupName = "DBParameterGroupName"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case source = "Source"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeDBParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBParametersOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.parameters = output.parameters
        } else {
            self.marker = nil
            self.parameters = nil
        }
    }
}

/// Contains the result of a successful invocation of the DescribeDBParameters action.
public struct DescribeDBParametersOutputResponse: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// A list of Parameter values.
    public var parameters: [RdsClientTypes.Parameter]?

    public init (
        marker: Swift.String? = nil,
        parameters: [RdsClientTypes.Parameter]? = nil
    )
    {
        self.marker = marker
        self.parameters = parameters
    }
}

struct DescribeDBParametersOutputResponseBody: Swift.Equatable {
    let parameters: [RdsClientTypes.Parameter]?
    let marker: Swift.String?
}

extension DescribeDBParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBParametersResult"))
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct Parameter{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Parameter>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([RdsClientTypes.Parameter].self, forKey: .member)
                var parametersBuffer:[RdsClientTypes.Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [RdsClientTypes.Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeDBProxiesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBProxies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDBProxiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDBProxiesInput: Swift.Equatable {
    /// The name of the DB proxy. If you omit this parameter, the output includes information about all DB proxies owned by your Amazon Web Services account ID.
    public var dBProxyName: Swift.String?
    /// This parameter is not currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBProxyName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBProxyName = dBProxyName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeDBProxiesInputBody: Swift.Equatable {
    let dBProxyName: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let marker: Swift.String?
    let maxRecords: Swift.Int?
}

extension DescribeDBProxiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxyName = "DBProxyName"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBProxyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyName)
        dBProxyName = dBProxyNameDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
    }
}

extension DescribeDBProxiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBProxiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBProxiesOutputError: Swift.Error, Swift.Equatable {
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBProxiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBProxiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBProxies = output.dBProxies
            self.marker = output.marker
        } else {
            self.dBProxies = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBProxiesOutputResponse: Swift.Equatable {
    /// A return value representing an arbitrary number of DBProxy data structures.
    public var dBProxies: [RdsClientTypes.DBProxy]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init (
        dBProxies: [RdsClientTypes.DBProxy]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBProxies = dBProxies
        self.marker = marker
    }
}

struct DescribeDBProxiesOutputResponseBody: Swift.Equatable {
    let dBProxies: [RdsClientTypes.DBProxy]?
    let marker: Swift.String?
}

extension DescribeDBProxiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxies = "DBProxies"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBProxiesResult"))
        if containerValues.contains(.dBProxies) {
            struct KeyVal0{struct member{}}
            let dBProxiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .dBProxies)
            if let dBProxiesWrappedContainer = dBProxiesWrappedContainer {
                let dBProxiesContainer = try dBProxiesWrappedContainer.decodeIfPresent([RdsClientTypes.DBProxy].self, forKey: .member)
                var dBProxiesBuffer:[RdsClientTypes.DBProxy]? = nil
                if let dBProxiesContainer = dBProxiesContainer {
                    dBProxiesBuffer = [RdsClientTypes.DBProxy]()
                    for structureContainer0 in dBProxiesContainer {
                        dBProxiesBuffer?.append(structureContainer0)
                    }
                }
                dBProxies = dBProxiesBuffer
            } else {
                dBProxies = []
            }
        } else {
            dBProxies = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeDBProxyEndpointsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBProxyEndpointName = dBProxyEndpointName {
            try container.encode(dBProxyEndpointName, forKey: ClientRuntime.Key("DBProxyEndpointName"))
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBProxyEndpoints", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDBProxyEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDBProxyEndpointsInput: Swift.Equatable {
    /// The name of a DB proxy endpoint to describe. If you omit this parameter, the output includes information about all DB proxy endpoints associated with the specified proxy.
    public var dBProxyEndpointName: Swift.String?
    /// The name of the DB proxy whose endpoints you want to describe. If you omit this parameter, the output includes information about all DB proxy endpoints associated with all your DB proxies.
    public var dBProxyName: Swift.String?
    /// This parameter is not currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBProxyEndpointName: Swift.String? = nil,
        dBProxyName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBProxyEndpointName = dBProxyEndpointName
        self.dBProxyName = dBProxyName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeDBProxyEndpointsInputBody: Swift.Equatable {
    let dBProxyName: Swift.String?
    let dBProxyEndpointName: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let marker: Swift.String?
    let maxRecords: Swift.Int?
}

extension DescribeDBProxyEndpointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxyEndpointName = "DBProxyEndpointName"
        case dBProxyName = "DBProxyName"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBProxyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyName)
        dBProxyName = dBProxyNameDecoded
        let dBProxyEndpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyEndpointName)
        dBProxyEndpointName = dBProxyEndpointNameDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
    }
}

extension DescribeDBProxyEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBProxyEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyEndpointNotFoundFault" : self = .dBProxyEndpointNotFoundFault(try DBProxyEndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBProxyEndpointsOutputError: Swift.Error, Swift.Equatable {
    case dBProxyEndpointNotFoundFault(DBProxyEndpointNotFoundFault)
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBProxyEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBProxyEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBProxyEndpoints = output.dBProxyEndpoints
            self.marker = output.marker
        } else {
            self.dBProxyEndpoints = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBProxyEndpointsOutputResponse: Swift.Equatable {
    /// The list of ProxyEndpoint objects returned by the API operation.
    public var dBProxyEndpoints: [RdsClientTypes.DBProxyEndpoint]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init (
        dBProxyEndpoints: [RdsClientTypes.DBProxyEndpoint]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBProxyEndpoints = dBProxyEndpoints
        self.marker = marker
    }
}

struct DescribeDBProxyEndpointsOutputResponseBody: Swift.Equatable {
    let dBProxyEndpoints: [RdsClientTypes.DBProxyEndpoint]?
    let marker: Swift.String?
}

extension DescribeDBProxyEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxyEndpoints = "DBProxyEndpoints"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBProxyEndpointsResult"))
        if containerValues.contains(.dBProxyEndpoints) {
            struct KeyVal0{struct member{}}
            let dBProxyEndpointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .dBProxyEndpoints)
            if let dBProxyEndpointsWrappedContainer = dBProxyEndpointsWrappedContainer {
                let dBProxyEndpointsContainer = try dBProxyEndpointsWrappedContainer.decodeIfPresent([RdsClientTypes.DBProxyEndpoint].self, forKey: .member)
                var dBProxyEndpointsBuffer:[RdsClientTypes.DBProxyEndpoint]? = nil
                if let dBProxyEndpointsContainer = dBProxyEndpointsContainer {
                    dBProxyEndpointsBuffer = [RdsClientTypes.DBProxyEndpoint]()
                    for structureContainer0 in dBProxyEndpointsContainer {
                        dBProxyEndpointsBuffer?.append(structureContainer0)
                    }
                }
                dBProxyEndpoints = dBProxyEndpointsBuffer
            } else {
                dBProxyEndpoints = []
            }
        } else {
            dBProxyEndpoints = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeDBProxyTargetGroupsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let targetGroupName = targetGroupName {
            try container.encode(targetGroupName, forKey: ClientRuntime.Key("TargetGroupName"))
        }
        try container.encode("DescribeDBProxyTargetGroups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDBProxyTargetGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDBProxyTargetGroupsInput: Swift.Equatable {
    /// The identifier of the DBProxy associated with the target group.
    /// This member is required.
    public var dBProxyName: Swift.String?
    /// This parameter is not currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The identifier of the DBProxyTargetGroup to describe.
    public var targetGroupName: Swift.String?

    public init (
        dBProxyName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        targetGroupName: Swift.String? = nil
    )
    {
        self.dBProxyName = dBProxyName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.targetGroupName = targetGroupName
    }
}

struct DescribeDBProxyTargetGroupsInputBody: Swift.Equatable {
    let dBProxyName: Swift.String?
    let targetGroupName: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let marker: Swift.String?
    let maxRecords: Swift.Int?
}

extension DescribeDBProxyTargetGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxyName = "DBProxyName"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case targetGroupName = "TargetGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBProxyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyName)
        dBProxyName = dBProxyNameDecoded
        let targetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetGroupName)
        targetGroupName = targetGroupNameDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
    }
}

extension DescribeDBProxyTargetGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBProxyTargetGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBProxyTargetGroupsOutputError: Swift.Error, Swift.Equatable {
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBProxyTargetGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBProxyTargetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.targetGroups = output.targetGroups
        } else {
            self.marker = nil
            self.targetGroups = nil
        }
    }
}

public struct DescribeDBProxyTargetGroupsOutputResponse: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// An arbitrary number of DBProxyTargetGroup objects, containing details of the corresponding target groups.
    public var targetGroups: [RdsClientTypes.DBProxyTargetGroup]?

    public init (
        marker: Swift.String? = nil,
        targetGroups: [RdsClientTypes.DBProxyTargetGroup]? = nil
    )
    {
        self.marker = marker
        self.targetGroups = targetGroups
    }
}

struct DescribeDBProxyTargetGroupsOutputResponseBody: Swift.Equatable {
    let targetGroups: [RdsClientTypes.DBProxyTargetGroup]?
    let marker: Swift.String?
}

extension DescribeDBProxyTargetGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case targetGroups = "TargetGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBProxyTargetGroupsResult"))
        if containerValues.contains(.targetGroups) {
            struct KeyVal0{struct member{}}
            let targetGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .targetGroups)
            if let targetGroupsWrappedContainer = targetGroupsWrappedContainer {
                let targetGroupsContainer = try targetGroupsWrappedContainer.decodeIfPresent([RdsClientTypes.DBProxyTargetGroup].self, forKey: .member)
                var targetGroupsBuffer:[RdsClientTypes.DBProxyTargetGroup]? = nil
                if let targetGroupsContainer = targetGroupsContainer {
                    targetGroupsBuffer = [RdsClientTypes.DBProxyTargetGroup]()
                    for structureContainer0 in targetGroupsContainer {
                        targetGroupsBuffer?.append(structureContainer0)
                    }
                }
                targetGroups = targetGroupsBuffer
            } else {
                targetGroups = []
            }
        } else {
            targetGroups = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeDBProxyTargetsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let targetGroupName = targetGroupName {
            try container.encode(targetGroupName, forKey: ClientRuntime.Key("TargetGroupName"))
        }
        try container.encode("DescribeDBProxyTargets", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDBProxyTargetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDBProxyTargetsInput: Swift.Equatable {
    /// The identifier of the DBProxyTarget to describe.
    /// This member is required.
    public var dBProxyName: Swift.String?
    /// This parameter is not currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The identifier of the DBProxyTargetGroup to describe.
    public var targetGroupName: Swift.String?

    public init (
        dBProxyName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        targetGroupName: Swift.String? = nil
    )
    {
        self.dBProxyName = dBProxyName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.targetGroupName = targetGroupName
    }
}

struct DescribeDBProxyTargetsInputBody: Swift.Equatable {
    let dBProxyName: Swift.String?
    let targetGroupName: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let marker: Swift.String?
    let maxRecords: Swift.Int?
}

extension DescribeDBProxyTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxyName = "DBProxyName"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case targetGroupName = "TargetGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBProxyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyName)
        dBProxyName = dBProxyNameDecoded
        let targetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetGroupName)
        targetGroupName = targetGroupNameDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
    }
}

extension DescribeDBProxyTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBProxyTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetNotFoundFault" : self = .dBProxyTargetNotFoundFault(try DBProxyTargetNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBProxyTargetsOutputError: Swift.Error, Swift.Equatable {
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case dBProxyTargetNotFoundFault(DBProxyTargetNotFoundFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBProxyTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBProxyTargetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.targets = output.targets
        } else {
            self.marker = nil
            self.targets = nil
        }
    }
}

public struct DescribeDBProxyTargetsOutputResponse: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// An arbitrary number of DBProxyTarget objects, containing details of the corresponding targets.
    public var targets: [RdsClientTypes.DBProxyTarget]?

    public init (
        marker: Swift.String? = nil,
        targets: [RdsClientTypes.DBProxyTarget]? = nil
    )
    {
        self.marker = marker
        self.targets = targets
    }
}

struct DescribeDBProxyTargetsOutputResponseBody: Swift.Equatable {
    let targets: [RdsClientTypes.DBProxyTarget]?
    let marker: Swift.String?
}

extension DescribeDBProxyTargetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case targets = "Targets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBProxyTargetsResult"))
        if containerValues.contains(.targets) {
            struct KeyVal0{struct member{}}
            let targetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .targets)
            if let targetsWrappedContainer = targetsWrappedContainer {
                let targetsContainer = try targetsWrappedContainer.decodeIfPresent([RdsClientTypes.DBProxyTarget].self, forKey: .member)
                var targetsBuffer:[RdsClientTypes.DBProxyTarget]? = nil
                if let targetsContainer = targetsContainer {
                    targetsBuffer = [RdsClientTypes.DBProxyTarget]()
                    for structureContainer0 in targetsContainer {
                        targetsBuffer?.append(structureContainer0)
                    }
                }
                targets = targetsBuffer
            } else {
                targets = []
            }
        } else {
            targets = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeDBSecurityGroupsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSecurityGroupName = dBSecurityGroupName {
            try container.encode(dBSecurityGroupName, forKey: ClientRuntime.Key("DBSecurityGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBSecurityGroups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDBSecurityGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeDBSecurityGroupsInput: Swift.Equatable {
    /// The name of the DB security group to return details for.
    public var dBSecurityGroupName: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous DescribeDBSecurityGroups request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBSecurityGroupName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBSecurityGroupName = dBSecurityGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeDBSecurityGroupsInputBody: Swift.Equatable {
    let dBSecurityGroupName: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeDBSecurityGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSecurityGroupName = "DBSecurityGroupName"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSecurityGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSecurityGroupName)
        dBSecurityGroupName = dBSecurityGroupNameDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeDBSecurityGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBSecurityGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSecurityGroupNotFound" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBSecurityGroupsOutputError: Swift.Error, Swift.Equatable {
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBSecurityGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBSecurityGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSecurityGroups = output.dBSecurityGroups
            self.marker = output.marker
        } else {
            self.dBSecurityGroups = nil
            self.marker = nil
        }
    }
}

/// Contains the result of a successful invocation of the DescribeDBSecurityGroups action.
public struct DescribeDBSecurityGroupsOutputResponse: Swift.Equatable {
    /// A list of DBSecurityGroup instances.
    public var dBSecurityGroups: [RdsClientTypes.DBSecurityGroup]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init (
        dBSecurityGroups: [RdsClientTypes.DBSecurityGroup]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBSecurityGroups = dBSecurityGroups
        self.marker = marker
    }
}

struct DescribeDBSecurityGroupsOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let dBSecurityGroups: [RdsClientTypes.DBSecurityGroup]?
}

extension DescribeDBSecurityGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSecurityGroups = "DBSecurityGroups"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBSecurityGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBSecurityGroups) {
            struct KeyVal0{struct DBSecurityGroup{}}
            let dBSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSecurityGroup>.CodingKeys.self, forKey: .dBSecurityGroups)
            if let dBSecurityGroupsWrappedContainer = dBSecurityGroupsWrappedContainer {
                let dBSecurityGroupsContainer = try dBSecurityGroupsWrappedContainer.decodeIfPresent([RdsClientTypes.DBSecurityGroup].self, forKey: .member)
                var dBSecurityGroupsBuffer:[RdsClientTypes.DBSecurityGroup]? = nil
                if let dBSecurityGroupsContainer = dBSecurityGroupsContainer {
                    dBSecurityGroupsBuffer = [RdsClientTypes.DBSecurityGroup]()
                    for structureContainer0 in dBSecurityGroupsContainer {
                        dBSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBSecurityGroups = dBSecurityGroupsBuffer
            } else {
                dBSecurityGroups = []
            }
        } else {
            dBSecurityGroups = nil
        }
    }
}

extension DescribeDBSnapshotAttributesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: ClientRuntime.Key("DBSnapshotIdentifier"))
        }
        try container.encode("DescribeDBSnapshotAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDBSnapshotAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeDBSnapshotAttributesInput: Swift.Equatable {
    /// The identifier for the DB snapshot to describe the attributes for.
    /// This member is required.
    public var dBSnapshotIdentifier: Swift.String?

    public init (
        dBSnapshotIdentifier: Swift.String? = nil
    )
    {
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
    }
}

struct DescribeDBSnapshotAttributesInputBody: Swift.Equatable {
    let dBSnapshotIdentifier: Swift.String?
}

extension DescribeDBSnapshotAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSnapshotIdentifier = "DBSnapshotIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSnapshotIdentifier)
        dBSnapshotIdentifier = dBSnapshotIdentifierDecoded
    }
}

extension DescribeDBSnapshotAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBSnapshotAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBSnapshotAttributesOutputError: Swift.Error, Swift.Equatable {
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBSnapshotAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBSnapshotAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSnapshotAttributesResult = output.dBSnapshotAttributesResult
        } else {
            self.dBSnapshotAttributesResult = nil
        }
    }
}

public struct DescribeDBSnapshotAttributesOutputResponse: Swift.Equatable {
    /// Contains the results of a successful call to the DescribeDBSnapshotAttributes API action. Manual DB snapshot attributes are used to authorize other Amazon Web Services accounts to copy or restore a manual DB snapshot. For more information, see the ModifyDBSnapshotAttribute API action.
    public var dBSnapshotAttributesResult: RdsClientTypes.DBSnapshotAttributesResult?

    public init (
        dBSnapshotAttributesResult: RdsClientTypes.DBSnapshotAttributesResult? = nil
    )
    {
        self.dBSnapshotAttributesResult = dBSnapshotAttributesResult
    }
}

struct DescribeDBSnapshotAttributesOutputResponseBody: Swift.Equatable {
    let dBSnapshotAttributesResult: RdsClientTypes.DBSnapshotAttributesResult?
}

extension DescribeDBSnapshotAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSnapshotAttributesResult = "DBSnapshotAttributesResult"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBSnapshotAttributesResult"))
        let dBSnapshotAttributesResultDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSnapshotAttributesResult.self, forKey: .dBSnapshotAttributesResult)
        dBSnapshotAttributesResult = dBSnapshotAttributesResultDecoded
    }
}

extension DescribeDBSnapshotsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: ClientRuntime.Key("DBSnapshotIdentifier"))
        }
        if let dbiResourceId = dbiResourceId {
            try container.encode(dbiResourceId, forKey: ClientRuntime.Key("DbiResourceId"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if includePublic != false {
            try container.encode(includePublic, forKey: ClientRuntime.Key("IncludePublic"))
        }
        if includeShared != false {
            try container.encode(includeShared, forKey: ClientRuntime.Key("IncludeShared"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let snapshotType = snapshotType {
            try container.encode(snapshotType, forKey: ClientRuntime.Key("SnapshotType"))
        }
        try container.encode("DescribeDBSnapshots", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDBSnapshotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeDBSnapshotsInput: Swift.Equatable {
    /// The ID of the DB instance to retrieve the list of DB snapshots for. This parameter can't be used in conjunction with DBSnapshotIdentifier. This parameter isn't case-sensitive. Constraints:
    ///
    /// * If supplied, must match the identifier of an existing DBInstance.
    public var dBInstanceIdentifier: Swift.String?
    /// A specific DB snapshot identifier to describe. This parameter can't be used in conjunction with DBInstanceIdentifier. This value is stored as a lowercase string. Constraints:
    ///
    /// * If supplied, must match the identifier of an existing DBSnapshot.
    ///
    /// * If this identifier is for an automated snapshot, the SnapshotType parameter must also be specified.
    public var dBSnapshotIdentifier: Swift.String?
    /// A specific DB resource ID to describe.
    public var dbiResourceId: Swift.String?
    /// A filter that specifies one or more DB snapshots to describe. Supported filters:
    ///
    /// * db-instance-id - Accepts DB instance identifiers and DB instance Amazon Resource Names (ARNs).
    ///
    /// * db-snapshot-id - Accepts DB snapshot identifiers.
    ///
    /// * dbi-resource-id - Accepts identifiers of source DB instances.
    ///
    /// * snapshot-type - Accepts types of DB snapshots.
    ///
    /// * engine - Accepts names of database engines.
    public var filters: [RdsClientTypes.Filter]?
    /// A value that indicates whether to include manual DB cluster snapshots that are public and can be copied or restored by any Amazon Web Services account. By default, the public snapshots are not included. You can share a manual DB snapshot as public by using the [ModifyDBSnapshotAttribute] API. This setting doesn't apply to RDS Custom.
    public var includePublic: Swift.Bool
    /// A value that indicates whether to include shared manual DB cluster snapshots from other Amazon Web Services accounts that this Amazon Web Services account has been given permission to copy or restore. By default, these snapshots are not included. You can give an Amazon Web Services account permission to restore a manual DB snapshot from another Amazon Web Services account by using the ModifyDBSnapshotAttribute API action. This setting doesn't apply to RDS Custom.
    public var includeShared: Swift.Bool
    /// An optional pagination token provided by a previous DescribeDBSnapshots request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The type of snapshots to be returned. You can specify one of the following values:
    ///
    /// * automated - Return all DB snapshots that have been automatically taken by Amazon RDS for my Amazon Web Services account.
    ///
    /// * manual - Return all DB snapshots that have been taken by my Amazon Web Services account.
    ///
    /// * shared - Return all manual DB snapshots that have been shared to my Amazon Web Services account.
    ///
    /// * public - Return all DB snapshots that have been marked as public.
    ///
    /// * awsbackup - Return the DB snapshots managed by the Amazon Web Services Backup service. For information about Amazon Web Services Backup, see the [ Amazon Web Services Backup Developer Guide. ](https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html) The awsbackup type does not apply to Aurora.
    ///
    ///
    /// If you don't specify a SnapshotType value, then both automated and manual snapshots are returned. Shared and public DB snapshots are not included in the returned results by default. You can include shared snapshots with these results by enabling the IncludeShared parameter. You can include public snapshots with these results by enabling the IncludePublic parameter. The IncludeShared and IncludePublic parameters don't apply for SnapshotType values of manual or automated. The IncludePublic parameter doesn't apply when SnapshotType is set to shared. The IncludeShared parameter doesn't apply when SnapshotType is set to public.
    public var snapshotType: Swift.String?

    public init (
        dBInstanceIdentifier: Swift.String? = nil,
        dBSnapshotIdentifier: Swift.String? = nil,
        dbiResourceId: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        includePublic: Swift.Bool = false,
        includeShared: Swift.Bool = false,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        snapshotType: Swift.String? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
        self.dbiResourceId = dbiResourceId
        self.filters = filters
        self.includePublic = includePublic
        self.includeShared = includeShared
        self.marker = marker
        self.maxRecords = maxRecords
        self.snapshotType = snapshotType
    }
}

struct DescribeDBSnapshotsInputBody: Swift.Equatable {
    let dBInstanceIdentifier: Swift.String?
    let dBSnapshotIdentifier: Swift.String?
    let snapshotType: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
    let includeShared: Swift.Bool
    let includePublic: Swift.Bool
    let dbiResourceId: Swift.String?
}

extension DescribeDBSnapshotsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dBSnapshotIdentifier = "DBSnapshotIdentifier"
        case dbiResourceId = "DbiResourceId"
        case filters = "Filters"
        case includePublic = "IncludePublic"
        case includeShared = "IncludeShared"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case snapshotType = "SnapshotType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let dBSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSnapshotIdentifier)
        dBSnapshotIdentifier = dBSnapshotIdentifierDecoded
        let snapshotTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotType)
        snapshotType = snapshotTypeDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let includeSharedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeShared)
        includeShared = includeSharedDecoded
        let includePublicDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includePublic)
        includePublic = includePublicDecoded
        let dbiResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbiResourceId)
        dbiResourceId = dbiResourceIdDecoded
    }
}

extension DescribeDBSnapshotsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBSnapshotsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBSnapshotsOutputError: Swift.Error, Swift.Equatable {
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBSnapshotsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBSnapshotsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSnapshots = output.dBSnapshots
            self.marker = output.marker
        } else {
            self.dBSnapshots = nil
            self.marker = nil
        }
    }
}

/// Contains the result of a successful invocation of the DescribeDBSnapshots action.
public struct DescribeDBSnapshotsOutputResponse: Swift.Equatable {
    /// A list of DBSnapshot instances.
    public var dBSnapshots: [RdsClientTypes.DBSnapshot]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init (
        dBSnapshots: [RdsClientTypes.DBSnapshot]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBSnapshots = dBSnapshots
        self.marker = marker
    }
}

struct DescribeDBSnapshotsOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let dBSnapshots: [RdsClientTypes.DBSnapshot]?
}

extension DescribeDBSnapshotsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSnapshots = "DBSnapshots"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBSnapshotsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBSnapshots) {
            struct KeyVal0{struct DBSnapshot{}}
            let dBSnapshotsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSnapshot>.CodingKeys.self, forKey: .dBSnapshots)
            if let dBSnapshotsWrappedContainer = dBSnapshotsWrappedContainer {
                let dBSnapshotsContainer = try dBSnapshotsWrappedContainer.decodeIfPresent([RdsClientTypes.DBSnapshot].self, forKey: .member)
                var dBSnapshotsBuffer:[RdsClientTypes.DBSnapshot]? = nil
                if let dBSnapshotsContainer = dBSnapshotsContainer {
                    dBSnapshotsBuffer = [RdsClientTypes.DBSnapshot]()
                    for structureContainer0 in dBSnapshotsContainer {
                        dBSnapshotsBuffer?.append(structureContainer0)
                    }
                }
                dBSnapshots = dBSnapshotsBuffer
            } else {
                dBSnapshots = []
            }
        } else {
            dBSnapshots = nil
        }
    }
}

extension DescribeDBSubnetGroupsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBSubnetGroups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDBSubnetGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeDBSubnetGroupsInput: Swift.Equatable {
    /// The name of the DB subnet group to return details for.
    public var dBSubnetGroupName: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous DescribeDBSubnetGroups request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBSubnetGroupName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBSubnetGroupName = dBSubnetGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeDBSubnetGroupsInputBody: Swift.Equatable {
    let dBSubnetGroupName: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeDBSubnetGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSubnetGroupName = "DBSubnetGroupName"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeDBSubnetGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBSubnetGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBSubnetGroupsOutputError: Swift.Error, Swift.Equatable {
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBSubnetGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBSubnetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSubnetGroups = output.dBSubnetGroups
            self.marker = output.marker
        } else {
            self.dBSubnetGroups = nil
            self.marker = nil
        }
    }
}

/// Contains the result of a successful invocation of the DescribeDBSubnetGroups action.
public struct DescribeDBSubnetGroupsOutputResponse: Swift.Equatable {
    /// A list of DBSubnetGroup instances.
    public var dBSubnetGroups: [RdsClientTypes.DBSubnetGroup]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init (
        dBSubnetGroups: [RdsClientTypes.DBSubnetGroup]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBSubnetGroups = dBSubnetGroups
        self.marker = marker
    }
}

struct DescribeDBSubnetGroupsOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let dBSubnetGroups: [RdsClientTypes.DBSubnetGroup]?
}

extension DescribeDBSubnetGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSubnetGroups = "DBSubnetGroups"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBSubnetGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBSubnetGroups) {
            struct KeyVal0{struct DBSubnetGroup{}}
            let dBSubnetGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSubnetGroup>.CodingKeys.self, forKey: .dBSubnetGroups)
            if let dBSubnetGroupsWrappedContainer = dBSubnetGroupsWrappedContainer {
                let dBSubnetGroupsContainer = try dBSubnetGroupsWrappedContainer.decodeIfPresent([RdsClientTypes.DBSubnetGroup].self, forKey: .member)
                var dBSubnetGroupsBuffer:[RdsClientTypes.DBSubnetGroup]? = nil
                if let dBSubnetGroupsContainer = dBSubnetGroupsContainer {
                    dBSubnetGroupsBuffer = [RdsClientTypes.DBSubnetGroup]()
                    for structureContainer0 in dBSubnetGroupsContainer {
                        dBSubnetGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBSubnetGroups = dBSubnetGroupsBuffer
            } else {
                dBSubnetGroups = []
            }
        } else {
            dBSubnetGroups = nil
        }
    }
}

extension DescribeEngineDefaultClusterParametersInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeEngineDefaultClusterParameters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeEngineDefaultClusterParametersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeEngineDefaultClusterParametersInput: Swift.Equatable {
    /// The name of the DB cluster parameter group family to return engine parameter information for.
    /// This member is required.
    public var dBParameterGroupFamily: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous DescribeEngineDefaultClusterParameters request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBParameterGroupFamily: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeEngineDefaultClusterParametersInputBody: Swift.Equatable {
    let dBParameterGroupFamily: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeEngineDefaultClusterParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEngineDefaultClusterParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEngineDefaultClusterParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEngineDefaultClusterParametersOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEngineDefaultClusterParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEngineDefaultClusterParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.engineDefaults = output.engineDefaults
        } else {
            self.engineDefaults = nil
        }
    }
}

public struct DescribeEngineDefaultClusterParametersOutputResponse: Swift.Equatable {
    /// Contains the result of a successful invocation of the DescribeEngineDefaultParameters action.
    public var engineDefaults: RdsClientTypes.EngineDefaults?

    public init (
        engineDefaults: RdsClientTypes.EngineDefaults? = nil
    )
    {
        self.engineDefaults = engineDefaults
    }
}

struct DescribeEngineDefaultClusterParametersOutputResponseBody: Swift.Equatable {
    let engineDefaults: RdsClientTypes.EngineDefaults?
}

extension DescribeEngineDefaultClusterParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineDefaults = "EngineDefaults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeEngineDefaultClusterParametersResult"))
        let engineDefaultsDecoded = try containerValues.decodeIfPresent(RdsClientTypes.EngineDefaults.self, forKey: .engineDefaults)
        engineDefaults = engineDefaultsDecoded
    }
}

extension DescribeEngineDefaultParametersInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeEngineDefaultParameters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeEngineDefaultParametersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeEngineDefaultParametersInput: Swift.Equatable {
    /// The name of the DB parameter group family.
    /// This member is required.
    public var dBParameterGroupFamily: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous DescribeEngineDefaultParameters request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBParameterGroupFamily: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeEngineDefaultParametersInputBody: Swift.Equatable {
    let dBParameterGroupFamily: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeEngineDefaultParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEngineDefaultParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEngineDefaultParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEngineDefaultParametersOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEngineDefaultParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEngineDefaultParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.engineDefaults = output.engineDefaults
        } else {
            self.engineDefaults = nil
        }
    }
}

public struct DescribeEngineDefaultParametersOutputResponse: Swift.Equatable {
    /// Contains the result of a successful invocation of the DescribeEngineDefaultParameters action.
    public var engineDefaults: RdsClientTypes.EngineDefaults?

    public init (
        engineDefaults: RdsClientTypes.EngineDefaults? = nil
    )
    {
        self.engineDefaults = engineDefaults
    }
}

struct DescribeEngineDefaultParametersOutputResponseBody: Swift.Equatable {
    let engineDefaults: RdsClientTypes.EngineDefaults?
}

extension DescribeEngineDefaultParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineDefaults = "EngineDefaults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeEngineDefaultParametersResult"))
        let engineDefaultsDecoded = try containerValues.decodeIfPresent(RdsClientTypes.EngineDefaults.self, forKey: .engineDefaults)
        engineDefaults = engineDefaultsDecoded
    }
}

extension DescribeEventCategoriesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
        try container.encode("DescribeEventCategories", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeEventCategoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeEventCategoriesInput: Swift.Equatable {
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// The type of source that is generating the events. Valid values: db-instance | db-cluster | db-parameter-group | db-security-group | db-snapshot | db-cluster-snapshot
    public var sourceType: Swift.String?

    public init (
        filters: [RdsClientTypes.Filter]? = nil,
        sourceType: Swift.String? = nil
    )
    {
        self.filters = filters
        self.sourceType = sourceType
    }
}

struct DescribeEventCategoriesInputBody: Swift.Equatable {
    let sourceType: Swift.String?
    let filters: [RdsClientTypes.Filter]?
}

extension DescribeEventCategoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case sourceType = "SourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
    }
}

extension DescribeEventCategoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEventCategoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventCategoriesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventCategoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEventCategoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventCategoriesMapList = output.eventCategoriesMapList
        } else {
            self.eventCategoriesMapList = nil
        }
    }
}

/// Data returned from the DescribeEventCategories operation.
public struct DescribeEventCategoriesOutputResponse: Swift.Equatable {
    /// A list of EventCategoriesMap data types.
    public var eventCategoriesMapList: [RdsClientTypes.EventCategoriesMap]?

    public init (
        eventCategoriesMapList: [RdsClientTypes.EventCategoriesMap]? = nil
    )
    {
        self.eventCategoriesMapList = eventCategoriesMapList
    }
}

struct DescribeEventCategoriesOutputResponseBody: Swift.Equatable {
    let eventCategoriesMapList: [RdsClientTypes.EventCategoriesMap]?
}

extension DescribeEventCategoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventCategoriesMapList = "EventCategoriesMapList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeEventCategoriesResult"))
        if containerValues.contains(.eventCategoriesMapList) {
            struct KeyVal0{struct EventCategoriesMap{}}
            let eventCategoriesMapListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategoriesMap>.CodingKeys.self, forKey: .eventCategoriesMapList)
            if let eventCategoriesMapListWrappedContainer = eventCategoriesMapListWrappedContainer {
                let eventCategoriesMapListContainer = try eventCategoriesMapListWrappedContainer.decodeIfPresent([RdsClientTypes.EventCategoriesMap].self, forKey: .member)
                var eventCategoriesMapListBuffer:[RdsClientTypes.EventCategoriesMap]? = nil
                if let eventCategoriesMapListContainer = eventCategoriesMapListContainer {
                    eventCategoriesMapListBuffer = [RdsClientTypes.EventCategoriesMap]()
                    for structureContainer0 in eventCategoriesMapListContainer {
                        eventCategoriesMapListBuffer?.append(structureContainer0)
                    }
                }
                eventCategoriesMapList = eventCategoriesMapListBuffer
            } else {
                eventCategoriesMapList = []
            }
        } else {
            eventCategoriesMapList = nil
        }
    }
}

extension DescribeEventSubscriptionsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: ClientRuntime.Key("SubscriptionName"))
        }
        try container.encode("DescribeEventSubscriptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeEventSubscriptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeEventSubscriptionsInput: Swift.Equatable {
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous DescribeOrderableDBInstanceOptions request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords .
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The name of the RDS event notification subscription you want to describe.
    public var subscriptionName: Swift.String?

    public init (
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        subscriptionName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.subscriptionName = subscriptionName
    }
}

struct DescribeEventSubscriptionsInputBody: Swift.Equatable {
    let subscriptionName: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeEventSubscriptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case subscriptionName = "SubscriptionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEventSubscriptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEventSubscriptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "SubscriptionNotFound" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventSubscriptionsOutputError: Swift.Error, Swift.Equatable {
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventSubscriptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEventSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscriptionsList = output.eventSubscriptionsList
            self.marker = output.marker
        } else {
            self.eventSubscriptionsList = nil
            self.marker = nil
        }
    }
}

/// Data returned by the DescribeEventSubscriptions action.
public struct DescribeEventSubscriptionsOutputResponse: Swift.Equatable {
    /// A list of EventSubscriptions data types.
    public var eventSubscriptionsList: [RdsClientTypes.EventSubscription]?
    /// An optional pagination token provided by a previous DescribeOrderableDBInstanceOptions request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init (
        eventSubscriptionsList: [RdsClientTypes.EventSubscription]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.eventSubscriptionsList = eventSubscriptionsList
        self.marker = marker
    }
}

struct DescribeEventSubscriptionsOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let eventSubscriptionsList: [RdsClientTypes.EventSubscription]?
}

extension DescribeEventSubscriptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscriptionsList = "EventSubscriptionsList"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeEventSubscriptionsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.eventSubscriptionsList) {
            struct KeyVal0{struct EventSubscription{}}
            let eventSubscriptionsListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventSubscription>.CodingKeys.self, forKey: .eventSubscriptionsList)
            if let eventSubscriptionsListWrappedContainer = eventSubscriptionsListWrappedContainer {
                let eventSubscriptionsListContainer = try eventSubscriptionsListWrappedContainer.decodeIfPresent([RdsClientTypes.EventSubscription].self, forKey: .member)
                var eventSubscriptionsListBuffer:[RdsClientTypes.EventSubscription]? = nil
                if let eventSubscriptionsListContainer = eventSubscriptionsListContainer {
                    eventSubscriptionsListBuffer = [RdsClientTypes.EventSubscription]()
                    for structureContainer0 in eventSubscriptionsListContainer {
                        eventSubscriptionsListBuffer?.append(structureContainer0)
                    }
                }
                eventSubscriptionsList = eventSubscriptionsListBuffer
            } else {
                eventSubscriptionsList = []
            }
        } else {
            eventSubscriptionsList = nil
        }
    }
}

extension DescribeEventsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let duration = duration {
            try container.encode(duration, forKey: ClientRuntime.Key("Duration"))
        }
        if let endTime = endTime {
            try container.encode(ClientRuntime.TimestampWrapper(endTime, format: .dateTime), forKey: ClientRuntime.Key("endTime"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: ClientRuntime.Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: ClientRuntime.Key("SourceIdentifier"))
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
        if let startTime = startTime {
            try container.encode(ClientRuntime.TimestampWrapper(startTime, format: .dateTime), forKey: ClientRuntime.Key("startTime"))
        }
        try container.encode("DescribeEvents", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeEventsInput: Swift.Equatable {
    /// The number of minutes to retrieve events for. Default: 60
    public var duration: Swift.Int?
    /// The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the [ISO8601 Wikipedia page.](http://en.wikipedia.org/wiki/ISO_8601) Example: 2009-07-08T18:00Z
    public var endTime: ClientRuntime.Date?
    /// A list of event categories that trigger notifications for a event notification subscription.
    public var eventCategories: [Swift.String]?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous DescribeEvents request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The identifier of the event source for which events are returned. If not specified, then all sources are included in the response. Constraints:
    ///
    /// * If SourceIdentifier is supplied, SourceType must also be provided.
    ///
    /// * If the source type is a DB instance, a DBInstanceIdentifier value must be supplied.
    ///
    /// * If the source type is a DB cluster, a DBClusterIdentifier value must be supplied.
    ///
    /// * If the source type is a DB parameter group, a DBParameterGroupName value must be supplied.
    ///
    /// * If the source type is a DB security group, a DBSecurityGroupName value must be supplied.
    ///
    /// * If the source type is a DB snapshot, a DBSnapshotIdentifier value must be supplied.
    ///
    /// * If the source type is a DB cluster snapshot, a DBClusterSnapshotIdentifier value must be supplied.
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens.
    public var sourceIdentifier: Swift.String?
    /// The event source to retrieve events for. If no value is specified, all events are returned.
    public var sourceType: RdsClientTypes.SourceType?
    /// The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the [ISO8601 Wikipedia page.](http://en.wikipedia.org/wiki/ISO_8601) Example: 2009-07-08T18:00Z
    public var startTime: ClientRuntime.Date?

    public init (
        duration: Swift.Int? = nil,
        endTime: ClientRuntime.Date? = nil,
        eventCategories: [Swift.String]? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        sourceIdentifier: Swift.String? = nil,
        sourceType: RdsClientTypes.SourceType? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.duration = duration
        self.endTime = endTime
        self.eventCategories = eventCategories
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.sourceIdentifier = sourceIdentifier
        self.sourceType = sourceType
        self.startTime = startTime
    }
}

struct DescribeEventsInputBody: Swift.Equatable {
    let sourceIdentifier: Swift.String?
    let sourceType: RdsClientTypes.SourceType?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let duration: Swift.Int?
    let eventCategories: [Swift.String]?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration = "Duration"
        case endTime = "EndTime"
        case eventCategories = "EventCategories"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case sourceIdentifier = "SourceIdentifier"
        case sourceType = "SourceType"
        case startTime = "StartTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        var startTimeBuffer:ClientRuntime.Date? = nil
        if let startTimeDecoded = startTimeDecoded {
            startTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(startTimeDecoded, format: .dateTime)
        }
        startTime = startTimeBuffer
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        var endTimeBuffer:ClientRuntime.Date? = nil
        if let endTimeDecoded = endTimeDecoded {
            endTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(endTimeDecoded, format: .dateTime)
        }
        endTime = endTimeBuffer
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        if containerValues.contains(.eventCategories) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategories)
            if let eventCategoriesWrappedContainer = eventCategoriesWrappedContainer {
                let eventCategoriesContainer = try eventCategoriesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var eventCategoriesBuffer:[Swift.String]? = nil
                if let eventCategoriesContainer = eventCategoriesContainer {
                    eventCategoriesBuffer = [Swift.String]()
                    for stringContainer0 in eventCategoriesContainer {
                        eventCategoriesBuffer?.append(stringContainer0)
                    }
                }
                eventCategories = eventCategoriesBuffer
            } else {
                eventCategories = []
            }
        } else {
            eventCategories = nil
        }
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.marker = output.marker
        } else {
            self.events = nil
            self.marker = nil
        }
    }
}

/// Contains the result of a successful invocation of the DescribeEvents action.
public struct DescribeEventsOutputResponse: Swift.Equatable {
    /// A list of Event instances.
    public var events: [RdsClientTypes.Event]?
    /// An optional pagination token provided by a previous Events request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords .
    public var marker: Swift.String?

    public init (
        events: [RdsClientTypes.Event]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.events = events
        self.marker = marker
    }
}

struct DescribeEventsOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let events: [RdsClientTypes.Event]?
}

extension DescribeEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeEventsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.events) {
            struct KeyVal0{struct Event{}}
            let eventsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Event>.CodingKeys.self, forKey: .events)
            if let eventsWrappedContainer = eventsWrappedContainer {
                let eventsContainer = try eventsWrappedContainer.decodeIfPresent([RdsClientTypes.Event].self, forKey: .member)
                var eventsBuffer:[RdsClientTypes.Event]? = nil
                if let eventsContainer = eventsContainer {
                    eventsBuffer = [RdsClientTypes.Event]()
                    for structureContainer0 in eventsContainer {
                        eventsBuffer?.append(structureContainer0)
                    }
                }
                events = eventsBuffer
            } else {
                events = []
            }
        } else {
            events = nil
        }
    }
}

extension DescribeExportTasksInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let exportTaskIdentifier = exportTaskIdentifier {
            try container.encode(exportTaskIdentifier, forKey: ClientRuntime.Key("ExportTaskIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let sourceArn = sourceArn {
            try container.encode(sourceArn, forKey: ClientRuntime.Key("SourceArn"))
        }
        try container.encode("DescribeExportTasks", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeExportTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeExportTasksInput: Swift.Equatable {
    /// The identifier of the snapshot export task to be described.
    public var exportTaskIdentifier: Swift.String?
    /// Filters specify one or more snapshot exports to describe. The filters are specified as name-value pairs that define what to include in the output. Filter names and values are case-sensitive. Supported filters include the following:
    ///
    /// * export-task-identifier - An identifier for the snapshot export task.
    ///
    /// * s3-bucket - The Amazon S3 bucket the snapshot is exported to.
    ///
    /// * source-arn - The Amazon Resource Name (ARN) of the snapshot exported to Amazon S3
    ///
    /// * status - The status of the export task. Must be lowercase. Valid statuses are the following:
    ///
    /// * canceled
    ///
    /// * canceling
    ///
    /// * complete
    ///
    /// * failed
    ///
    /// * in_progress
    ///
    /// * starting
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous DescribeExportTasks request. If you specify this parameter, the response includes only records beyond the marker, up to the value specified by the MaxRecords parameter.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified value, a pagination token called a marker is included in the response. You can use the marker in a later DescribeExportTasks request to retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The Amazon Resource Name (ARN) of the snapshot exported to Amazon S3.
    public var sourceArn: Swift.String?

    public init (
        exportTaskIdentifier: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        sourceArn: Swift.String? = nil
    )
    {
        self.exportTaskIdentifier = exportTaskIdentifier
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.sourceArn = sourceArn
    }
}

struct DescribeExportTasksInputBody: Swift.Equatable {
    let exportTaskIdentifier: Swift.String?
    let sourceArn: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let marker: Swift.String?
    let maxRecords: Swift.Int?
}

extension DescribeExportTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportTaskIdentifier = "ExportTaskIdentifier"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case sourceArn = "SourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportTaskIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportTaskIdentifier)
        exportTaskIdentifier = exportTaskIdentifierDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
    }
}

extension DescribeExportTasksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeExportTasksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExportTaskNotFound" : self = .exportTaskNotFoundFault(try ExportTaskNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeExportTasksOutputError: Swift.Error, Swift.Equatable {
    case exportTaskNotFoundFault(ExportTaskNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeExportTasksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeExportTasksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exportTasks = output.exportTasks
            self.marker = output.marker
        } else {
            self.exportTasks = nil
            self.marker = nil
        }
    }
}

public struct DescribeExportTasksOutputResponse: Swift.Equatable {
    /// Information about an export of a snapshot to Amazon S3.
    public var exportTasks: [RdsClientTypes.ExportTask]?
    /// A pagination token that can be used in a later DescribeExportTasks request. A marker is used for pagination to identify the location to begin output for the next response of DescribeExportTasks.
    public var marker: Swift.String?

    public init (
        exportTasks: [RdsClientTypes.ExportTask]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.exportTasks = exportTasks
        self.marker = marker
    }
}

struct DescribeExportTasksOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let exportTasks: [RdsClientTypes.ExportTask]?
}

extension DescribeExportTasksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportTasks = "ExportTasks"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeExportTasksResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.exportTasks) {
            struct KeyVal0{struct ExportTask{}}
            let exportTasksWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ExportTask>.CodingKeys.self, forKey: .exportTasks)
            if let exportTasksWrappedContainer = exportTasksWrappedContainer {
                let exportTasksContainer = try exportTasksWrappedContainer.decodeIfPresent([RdsClientTypes.ExportTask].self, forKey: .member)
                var exportTasksBuffer:[RdsClientTypes.ExportTask]? = nil
                if let exportTasksContainer = exportTasksContainer {
                    exportTasksBuffer = [RdsClientTypes.ExportTask]()
                    for structureContainer0 in exportTasksContainer {
                        exportTasksBuffer?.append(structureContainer0)
                    }
                }
                exportTasks = exportTasksBuffer
            } else {
                exportTasks = []
            }
        } else {
            exportTasks = nil
        }
    }
}

extension DescribeGlobalClustersInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: ClientRuntime.Key("GlobalClusterIdentifier"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeGlobalClusters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeGlobalClustersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeGlobalClustersInput: Swift.Equatable {
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// The user-supplied DB cluster identifier. If this parameter is specified, information from only the specific DB cluster is returned. This parameter isn't case-sensitive. Constraints:
    ///
    /// * If supplied, must match an existing DBClusterIdentifier.
    public var globalClusterIdentifier: Swift.String?
    /// An optional pagination token provided by a previous DescribeGlobalClusters request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        filters: [RdsClientTypes.Filter]? = nil,
        globalClusterIdentifier: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.globalClusterIdentifier = globalClusterIdentifier
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeGlobalClustersInputBody: Swift.Equatable {
    let globalClusterIdentifier: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeGlobalClustersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case globalClusterIdentifier = "GlobalClusterIdentifier"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalClusterIdentifier)
        globalClusterIdentifier = globalClusterIdentifierDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeGlobalClustersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeGlobalClustersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "GlobalClusterNotFoundFault" : self = .globalClusterNotFoundFault(try GlobalClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeGlobalClustersOutputError: Swift.Error, Swift.Equatable {
    case globalClusterNotFoundFault(GlobalClusterNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGlobalClustersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeGlobalClustersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalClusters = output.globalClusters
            self.marker = output.marker
        } else {
            self.globalClusters = nil
            self.marker = nil
        }
    }
}

public struct DescribeGlobalClustersOutputResponse: Swift.Equatable {
    /// The list of global clusters returned by this request.
    public var globalClusters: [RdsClientTypes.GlobalCluster]?
    /// An optional pagination token provided by a previous DescribeGlobalClusters request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init (
        globalClusters: [RdsClientTypes.GlobalCluster]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.globalClusters = globalClusters
        self.marker = marker
    }
}

struct DescribeGlobalClustersOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let globalClusters: [RdsClientTypes.GlobalCluster]?
}

extension DescribeGlobalClustersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalClusters = "GlobalClusters"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeGlobalClustersResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.globalClusters) {
            struct KeyVal0{struct GlobalClusterMember{}}
            let globalClustersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.GlobalClusterMember>.CodingKeys.self, forKey: .globalClusters)
            if let globalClustersWrappedContainer = globalClustersWrappedContainer {
                let globalClustersContainer = try globalClustersWrappedContainer.decodeIfPresent([RdsClientTypes.GlobalCluster].self, forKey: .member)
                var globalClustersBuffer:[RdsClientTypes.GlobalCluster]? = nil
                if let globalClustersContainer = globalClustersContainer {
                    globalClustersBuffer = [RdsClientTypes.GlobalCluster]()
                    for structureContainer0 in globalClustersContainer {
                        globalClustersBuffer?.append(structureContainer0)
                    }
                }
                globalClusters = globalClustersBuffer
            } else {
                globalClusters = []
            }
        } else {
            globalClusters = nil
        }
    }
}

extension DescribeInstallationMediaInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let installationMediaId = installationMediaId {
            try container.encode(installationMediaId, forKey: ClientRuntime.Key("InstallationMediaId"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeInstallationMedia", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeInstallationMediaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeInstallationMediaInput: Swift.Equatable {
    /// A filter that specifies one or more installation media to describe. Supported filters include the following:
    ///
    /// * custom-availability-zone-id - Accepts custom Availability Zone (AZ) identifiers. The results list includes information about only the custom AZs identified by these identifiers.
    ///
    /// * engine - Accepts database engines. The results list includes information about only the database engines identified by these identifiers. For more information about the valid engines for installation media, see [ImportInstallationMedia].
    public var filters: [RdsClientTypes.Filter]?
    /// The installation medium ID.
    public var installationMediaId: Swift.String?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// An optional pagination token provided by a previous DescribeInstallationMedia request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var maxRecords: Swift.Int?

    public init (
        filters: [RdsClientTypes.Filter]? = nil,
        installationMediaId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.installationMediaId = installationMediaId
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeInstallationMediaInputBody: Swift.Equatable {
    let installationMediaId: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeInstallationMediaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case installationMediaId = "InstallationMediaId"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let installationMediaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .installationMediaId)
        installationMediaId = installationMediaIdDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeInstallationMediaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeInstallationMediaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InstallationMediaNotFound" : self = .installationMediaNotFoundFault(try InstallationMediaNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstallationMediaOutputError: Swift.Error, Swift.Equatable {
    case installationMediaNotFoundFault(InstallationMediaNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstallationMediaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInstallationMediaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.installationMedia = output.installationMedia
            self.marker = output.marker
        } else {
            self.installationMedia = nil
            self.marker = nil
        }
    }
}

public struct DescribeInstallationMediaOutputResponse: Swift.Equatable {
    /// The list of [InstallationMedia] objects for the Amazon Web Services account.
    public var installationMedia: [RdsClientTypes.InstallationMedia]?
    /// An optional pagination token provided by a previous [DescribeInstallationMedia] request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init (
        installationMedia: [RdsClientTypes.InstallationMedia]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.installationMedia = installationMedia
        self.marker = marker
    }
}

struct DescribeInstallationMediaOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let installationMedia: [RdsClientTypes.InstallationMedia]?
}

extension DescribeInstallationMediaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case installationMedia = "InstallationMedia"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeInstallationMediaResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.installationMedia) {
            struct KeyVal0{struct InstallationMedia{}}
            let installationMediaWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.InstallationMedia>.CodingKeys.self, forKey: .installationMedia)
            if let installationMediaWrappedContainer = installationMediaWrappedContainer {
                let installationMediaContainer = try installationMediaWrappedContainer.decodeIfPresent([RdsClientTypes.InstallationMedia].self, forKey: .member)
                var installationMediaBuffer:[RdsClientTypes.InstallationMedia]? = nil
                if let installationMediaContainer = installationMediaContainer {
                    installationMediaBuffer = [RdsClientTypes.InstallationMedia]()
                    for structureContainer0 in installationMediaContainer {
                        installationMediaBuffer?.append(structureContainer0)
                    }
                }
                installationMedia = installationMediaBuffer
            } else {
                installationMedia = []
            }
        } else {
            installationMedia = nil
        }
    }
}

extension DescribeOptionGroupOptionsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let engineName = engineName {
            try container.encode(engineName, forKey: ClientRuntime.Key("EngineName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let majorEngineVersion = majorEngineVersion {
            try container.encode(majorEngineVersion, forKey: ClientRuntime.Key("MajorEngineVersion"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeOptionGroupOptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeOptionGroupOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeOptionGroupOptionsInput: Swift.Equatable {
    /// A required parameter. Options available for the given engine name are described. Valid Values:
    ///
    /// * mariadb
    ///
    /// * mysql
    ///
    /// * oracle-ee
    ///
    /// * oracle-ee-cdb
    ///
    /// * oracle-se2
    ///
    /// * oracle-se2-cdb
    ///
    /// * postgres
    ///
    /// * sqlserver-ee
    ///
    /// * sqlserver-se
    ///
    /// * sqlserver-ex
    ///
    /// * sqlserver-web
    /// This member is required.
    public var engineName: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// If specified, filters the results to include only options for the specified major engine version.
    public var majorEngineVersion: Swift.String?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        engineName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        majorEngineVersion: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.engineName = engineName
        self.filters = filters
        self.majorEngineVersion = majorEngineVersion
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeOptionGroupOptionsInputBody: Swift.Equatable {
    let engineName: Swift.String?
    let majorEngineVersion: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeOptionGroupOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineName = "EngineName"
        case filters = "Filters"
        case majorEngineVersion = "MajorEngineVersion"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let majorEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorEngineVersion)
        majorEngineVersion = majorEngineVersionDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeOptionGroupOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeOptionGroupOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOptionGroupOptionsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOptionGroupOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeOptionGroupOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.optionGroupOptions = output.optionGroupOptions
        } else {
            self.marker = nil
            self.optionGroupOptions = nil
        }
    }
}

///
public struct DescribeOptionGroupOptionsOutputResponse: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// List of available option group options.
    public var optionGroupOptions: [RdsClientTypes.OptionGroupOption]?

    public init (
        marker: Swift.String? = nil,
        optionGroupOptions: [RdsClientTypes.OptionGroupOption]? = nil
    )
    {
        self.marker = marker
        self.optionGroupOptions = optionGroupOptions
    }
}

struct DescribeOptionGroupOptionsOutputResponseBody: Swift.Equatable {
    let optionGroupOptions: [RdsClientTypes.OptionGroupOption]?
    let marker: Swift.String?
}

extension DescribeOptionGroupOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case optionGroupOptions = "OptionGroupOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeOptionGroupOptionsResult"))
        if containerValues.contains(.optionGroupOptions) {
            struct KeyVal0{struct OptionGroupOption{}}
            let optionGroupOptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionGroupOption>.CodingKeys.self, forKey: .optionGroupOptions)
            if let optionGroupOptionsWrappedContainer = optionGroupOptionsWrappedContainer {
                let optionGroupOptionsContainer = try optionGroupOptionsWrappedContainer.decodeIfPresent([RdsClientTypes.OptionGroupOption].self, forKey: .member)
                var optionGroupOptionsBuffer:[RdsClientTypes.OptionGroupOption]? = nil
                if let optionGroupOptionsContainer = optionGroupOptionsContainer {
                    optionGroupOptionsBuffer = [RdsClientTypes.OptionGroupOption]()
                    for structureContainer0 in optionGroupOptionsContainer {
                        optionGroupOptionsBuffer?.append(structureContainer0)
                    }
                }
                optionGroupOptions = optionGroupOptionsBuffer
            } else {
                optionGroupOptions = []
            }
        } else {
            optionGroupOptions = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeOptionGroupsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let engineName = engineName {
            try container.encode(engineName, forKey: ClientRuntime.Key("EngineName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let majorEngineVersion = majorEngineVersion {
            try container.encode(majorEngineVersion, forKey: ClientRuntime.Key("MajorEngineVersion"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        try container.encode("DescribeOptionGroups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeOptionGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeOptionGroupsInput: Swift.Equatable {
    /// Filters the list of option groups to only include groups associated with a specific database engine. Valid Values:
    ///
    /// * mariadb
    ///
    /// * mysql
    ///
    /// * oracle-ee
    ///
    /// * oracle-ee-cdb
    ///
    /// * oracle-se2
    ///
    /// * oracle-se2-cdb
    ///
    /// * postgres
    ///
    /// * sqlserver-ee
    ///
    /// * sqlserver-se
    ///
    /// * sqlserver-ex
    ///
    /// * sqlserver-web
    public var engineName: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// Filters the list of option groups to only include groups associated with a specific database engine version. If specified, then EngineName must also be specified.
    public var majorEngineVersion: Swift.String?
    /// An optional pagination token provided by a previous DescribeOptionGroups request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The name of the option group to describe. Can't be supplied together with EngineName or MajorEngineVersion.
    public var optionGroupName: Swift.String?

    public init (
        engineName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        majorEngineVersion: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        optionGroupName: Swift.String? = nil
    )
    {
        self.engineName = engineName
        self.filters = filters
        self.majorEngineVersion = majorEngineVersion
        self.marker = marker
        self.maxRecords = maxRecords
        self.optionGroupName = optionGroupName
    }
}

struct DescribeOptionGroupsInputBody: Swift.Equatable {
    let optionGroupName: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let marker: Swift.String?
    let maxRecords: Swift.Int?
    let engineName: Swift.String?
    let majorEngineVersion: Swift.String?
}

extension DescribeOptionGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineName = "EngineName"
        case filters = "Filters"
        case majorEngineVersion = "MajorEngineVersion"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case optionGroupName = "OptionGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let majorEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorEngineVersion)
        majorEngineVersion = majorEngineVersionDecoded
    }
}

extension DescribeOptionGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeOptionGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOptionGroupsOutputError: Swift.Error, Swift.Equatable {
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOptionGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeOptionGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.optionGroupsList = output.optionGroupsList
        } else {
            self.marker = nil
            self.optionGroupsList = nil
        }
    }
}

/// List of option groups.
public struct DescribeOptionGroupsOutputResponse: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// List of option groups.
    public var optionGroupsList: [RdsClientTypes.OptionGroup]?

    public init (
        marker: Swift.String? = nil,
        optionGroupsList: [RdsClientTypes.OptionGroup]? = nil
    )
    {
        self.marker = marker
        self.optionGroupsList = optionGroupsList
    }
}

struct DescribeOptionGroupsOutputResponseBody: Swift.Equatable {
    let optionGroupsList: [RdsClientTypes.OptionGroup]?
    let marker: Swift.String?
}

extension DescribeOptionGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case optionGroupsList = "OptionGroupsList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeOptionGroupsResult"))
        if containerValues.contains(.optionGroupsList) {
            struct KeyVal0{struct OptionGroup{}}
            let optionGroupsListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionGroup>.CodingKeys.self, forKey: .optionGroupsList)
            if let optionGroupsListWrappedContainer = optionGroupsListWrappedContainer {
                let optionGroupsListContainer = try optionGroupsListWrappedContainer.decodeIfPresent([RdsClientTypes.OptionGroup].self, forKey: .member)
                var optionGroupsListBuffer:[RdsClientTypes.OptionGroup]? = nil
                if let optionGroupsListContainer = optionGroupsListContainer {
                    optionGroupsListBuffer = [RdsClientTypes.OptionGroup]()
                    for structureContainer0 in optionGroupsListContainer {
                        optionGroupsListBuffer?.append(structureContainer0)
                    }
                }
                optionGroupsList = optionGroupsListBuffer
            } else {
                optionGroupsList = []
            }
        } else {
            optionGroupsList = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeOrderableDBInstanceOptionsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZoneGroup = availabilityZoneGroup {
            try container.encode(availabilityZoneGroup, forKey: ClientRuntime.Key("AvailabilityZoneGroup"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let vpc = vpc {
            try container.encode(vpc, forKey: ClientRuntime.Key("Vpc"))
        }
        try container.encode("DescribeOrderableDBInstanceOptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeOrderableDBInstanceOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeOrderableDBInstanceOptionsInput: Swift.Equatable {
    /// The Availability Zone group associated with a Local Zone. Specify this parameter to retrieve available offerings for the Local Zones in the group. Omit this parameter to show the available offerings in the specified Amazon Web Services Region. This setting doesn't apply to RDS Custom.
    public var availabilityZoneGroup: Swift.String?
    /// The DB instance class filter value. Specify this parameter to show only the available offerings matching the specified DB instance class.
    public var dBInstanceClass: Swift.String?
    /// The name of the engine to retrieve DB instance options for. Valid Values:
    ///
    /// * aurora (for MySQL 5.6-compatible Aurora)
    ///
    /// * aurora-mysql (for MySQL 5.7-compatible Aurora)
    ///
    /// * aurora-postgresql
    ///
    /// * mariadb
    ///
    /// * mysql
    ///
    /// * oracle-ee
    ///
    /// * oracle-ee-cdb
    ///
    /// * oracle-se2
    ///
    /// * oracle-se2-cdb
    ///
    /// * postgres
    ///
    /// * sqlserver-ee
    ///
    /// * sqlserver-se
    ///
    /// * sqlserver-ex
    ///
    /// * sqlserver-web
    /// This member is required.
    public var engine: Swift.String?
    /// The engine version filter value. Specify this parameter to show only the available offerings matching the specified engine version.
    public var engineVersion: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// The license model filter value. Specify this parameter to show only the available offerings matching the specified license model. RDS Custom supports only the BYOL licensing model.
    public var licenseModel: Swift.String?
    /// An optional pagination token provided by a previous DescribeOrderableDBInstanceOptions request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords .
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// A value that indicates whether to show only VPC or non-VPC offerings. RDS Custom supports only VPC offerings. RDS Custom supports only VPC offerings. If you describe non-VPC offerings for RDS Custom, the output shows VPC offerings.
    public var vpc: Swift.Bool?

    public init (
        availabilityZoneGroup: Swift.String? = nil,
        dBInstanceClass: Swift.String? = nil,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        licenseModel: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        vpc: Swift.Bool? = nil
    )
    {
        self.availabilityZoneGroup = availabilityZoneGroup
        self.dBInstanceClass = dBInstanceClass
        self.engine = engine
        self.engineVersion = engineVersion
        self.filters = filters
        self.licenseModel = licenseModel
        self.marker = marker
        self.maxRecords = maxRecords
        self.vpc = vpc
    }
}

struct DescribeOrderableDBInstanceOptionsInputBody: Swift.Equatable {
    let engine: Swift.String?
    let engineVersion: Swift.String?
    let dBInstanceClass: Swift.String?
    let licenseModel: Swift.String?
    let availabilityZoneGroup: Swift.String?
    let vpc: Swift.Bool?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeOrderableDBInstanceOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneGroup = "AvailabilityZoneGroup"
        case dBInstanceClass = "DBInstanceClass"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case filters = "Filters"
        case licenseModel = "LicenseModel"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case vpc = "Vpc"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let availabilityZoneGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneGroup)
        availabilityZoneGroup = availabilityZoneGroupDecoded
        let vpcDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .vpc)
        vpc = vpcDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeOrderableDBInstanceOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeOrderableDBInstanceOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOrderableDBInstanceOptionsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrderableDBInstanceOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeOrderableDBInstanceOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.orderableDBInstanceOptions = output.orderableDBInstanceOptions
        } else {
            self.marker = nil
            self.orderableDBInstanceOptions = nil
        }
    }
}

/// Contains the result of a successful invocation of the DescribeOrderableDBInstanceOptions action.
public struct DescribeOrderableDBInstanceOptionsOutputResponse: Swift.Equatable {
    /// An optional pagination token provided by a previous OrderableDBInstanceOptions request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords .
    public var marker: Swift.String?
    /// An OrderableDBInstanceOption structure containing information about orderable options for the DB instance.
    public var orderableDBInstanceOptions: [RdsClientTypes.OrderableDBInstanceOption]?

    public init (
        marker: Swift.String? = nil,
        orderableDBInstanceOptions: [RdsClientTypes.OrderableDBInstanceOption]? = nil
    )
    {
        self.marker = marker
        self.orderableDBInstanceOptions = orderableDBInstanceOptions
    }
}

struct DescribeOrderableDBInstanceOptionsOutputResponseBody: Swift.Equatable {
    let orderableDBInstanceOptions: [RdsClientTypes.OrderableDBInstanceOption]?
    let marker: Swift.String?
}

extension DescribeOrderableDBInstanceOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case orderableDBInstanceOptions = "OrderableDBInstanceOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeOrderableDBInstanceOptionsResult"))
        if containerValues.contains(.orderableDBInstanceOptions) {
            struct KeyVal0{struct OrderableDBInstanceOption{}}
            let orderableDBInstanceOptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OrderableDBInstanceOption>.CodingKeys.self, forKey: .orderableDBInstanceOptions)
            if let orderableDBInstanceOptionsWrappedContainer = orderableDBInstanceOptionsWrappedContainer {
                let orderableDBInstanceOptionsContainer = try orderableDBInstanceOptionsWrappedContainer.decodeIfPresent([RdsClientTypes.OrderableDBInstanceOption].self, forKey: .member)
                var orderableDBInstanceOptionsBuffer:[RdsClientTypes.OrderableDBInstanceOption]? = nil
                if let orderableDBInstanceOptionsContainer = orderableDBInstanceOptionsContainer {
                    orderableDBInstanceOptionsBuffer = [RdsClientTypes.OrderableDBInstanceOption]()
                    for structureContainer0 in orderableDBInstanceOptionsContainer {
                        orderableDBInstanceOptionsBuffer?.append(structureContainer0)
                    }
                }
                orderableDBInstanceOptions = orderableDBInstanceOptionsBuffer
            } else {
                orderableDBInstanceOptions = []
            }
        } else {
            orderableDBInstanceOptions = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribePendingMaintenanceActionsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let resourceIdentifier = resourceIdentifier {
            try container.encode(resourceIdentifier, forKey: ClientRuntime.Key("ResourceIdentifier"))
        }
        try container.encode("DescribePendingMaintenanceActions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribePendingMaintenanceActionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribePendingMaintenanceActionsInput: Swift.Equatable {
    /// A filter that specifies one or more resources to return pending maintenance actions for. Supported filters:
    ///
    /// * db-cluster-id - Accepts DB cluster identifiers and DB cluster Amazon Resource Names (ARNs). The results list will only include pending maintenance actions for the DB clusters identified by these ARNs.
    ///
    /// * db-instance-id - Accepts DB instance identifiers and DB instance ARNs. The results list will only include pending maintenance actions for the DB instances identified by these ARNs.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous DescribePendingMaintenanceActions request. If this parameter is specified, the response includes only records beyond the marker, up to a number of records specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The ARN of a resource to return pending maintenance actions for.
    public var resourceIdentifier: Swift.String?

    public init (
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.resourceIdentifier = resourceIdentifier
    }
}

struct DescribePendingMaintenanceActionsInputBody: Swift.Equatable {
    let resourceIdentifier: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let marker: Swift.String?
    let maxRecords: Swift.Int?
}

extension DescribePendingMaintenanceActionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case resourceIdentifier = "ResourceIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
    }
}

extension DescribePendingMaintenanceActionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribePendingMaintenanceActionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePendingMaintenanceActionsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePendingMaintenanceActionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePendingMaintenanceActionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.pendingMaintenanceActions = output.pendingMaintenanceActions
        } else {
            self.marker = nil
            self.pendingMaintenanceActions = nil
        }
    }
}

/// Data returned from the DescribePendingMaintenanceActions action.
public struct DescribePendingMaintenanceActionsOutputResponse: Swift.Equatable {
    /// An optional pagination token provided by a previous DescribePendingMaintenanceActions request. If this parameter is specified, the response includes only records beyond the marker, up to a number of records specified by MaxRecords.
    public var marker: Swift.String?
    /// A list of the pending maintenance actions for the resource.
    public var pendingMaintenanceActions: [RdsClientTypes.ResourcePendingMaintenanceActions]?

    public init (
        marker: Swift.String? = nil,
        pendingMaintenanceActions: [RdsClientTypes.ResourcePendingMaintenanceActions]? = nil
    )
    {
        self.marker = marker
        self.pendingMaintenanceActions = pendingMaintenanceActions
    }
}

struct DescribePendingMaintenanceActionsOutputResponseBody: Swift.Equatable {
    let pendingMaintenanceActions: [RdsClientTypes.ResourcePendingMaintenanceActions]?
    let marker: Swift.String?
}

extension DescribePendingMaintenanceActionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case pendingMaintenanceActions = "PendingMaintenanceActions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribePendingMaintenanceActionsResult"))
        if containerValues.contains(.pendingMaintenanceActions) {
            struct KeyVal0{struct ResourcePendingMaintenanceActions{}}
            let pendingMaintenanceActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ResourcePendingMaintenanceActions>.CodingKeys.self, forKey: .pendingMaintenanceActions)
            if let pendingMaintenanceActionsWrappedContainer = pendingMaintenanceActionsWrappedContainer {
                let pendingMaintenanceActionsContainer = try pendingMaintenanceActionsWrappedContainer.decodeIfPresent([RdsClientTypes.ResourcePendingMaintenanceActions].self, forKey: .member)
                var pendingMaintenanceActionsBuffer:[RdsClientTypes.ResourcePendingMaintenanceActions]? = nil
                if let pendingMaintenanceActionsContainer = pendingMaintenanceActionsContainer {
                    pendingMaintenanceActionsBuffer = [RdsClientTypes.ResourcePendingMaintenanceActions]()
                    for structureContainer0 in pendingMaintenanceActionsContainer {
                        pendingMaintenanceActionsBuffer?.append(structureContainer0)
                    }
                }
                pendingMaintenanceActions = pendingMaintenanceActionsBuffer
            } else {
                pendingMaintenanceActions = []
            }
        } else {
            pendingMaintenanceActions = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReservedDBInstancesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let duration = duration {
            try container.encode(duration, forKey: ClientRuntime.Key("Duration"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let leaseId = leaseId {
            try container.encode(leaseId, forKey: ClientRuntime.Key("LeaseId"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let offeringType = offeringType {
            try container.encode(offeringType, forKey: ClientRuntime.Key("OfferingType"))
        }
        if let productDescription = productDescription {
            try container.encode(productDescription, forKey: ClientRuntime.Key("ProductDescription"))
        }
        if let reservedDBInstanceId = reservedDBInstanceId {
            try container.encode(reservedDBInstanceId, forKey: ClientRuntime.Key("ReservedDBInstanceId"))
        }
        if let reservedDBInstancesOfferingId = reservedDBInstancesOfferingId {
            try container.encode(reservedDBInstancesOfferingId, forKey: ClientRuntime.Key("ReservedDBInstancesOfferingId"))
        }
        try container.encode("DescribeReservedDBInstances", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeReservedDBInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeReservedDBInstancesInput: Swift.Equatable {
    /// The DB instance class filter value. Specify this parameter to show only those reservations matching the specified DB instances class.
    public var dBInstanceClass: Swift.String?
    /// The duration filter value, specified in years or seconds. Specify this parameter to show only reservations for this duration. Valid Values: 1 | 3 | 31536000 | 94608000
    public var duration: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// The lease identifier filter value. Specify this parameter to show only the reservation that matches the specified lease ID. Amazon Web Services Support might request the lease ID for an issue related to a reserved DB instance.
    public var leaseId: Swift.String?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more than the MaxRecords value is available, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// A value that indicates whether to show only those reservations that support Multi-AZ.
    public var multiAZ: Swift.Bool?
    /// The offering type filter value. Specify this parameter to show only the available offerings matching the specified offering type. Valid Values: "Partial Upfront" | "All Upfront" | "No Upfront"
    public var offeringType: Swift.String?
    /// The product description filter value. Specify this parameter to show only those reservations matching the specified product description.
    public var productDescription: Swift.String?
    /// The reserved DB instance identifier filter value. Specify this parameter to show only the reservation that matches the specified reservation ID.
    public var reservedDBInstanceId: Swift.String?
    /// The offering identifier filter value. Specify this parameter to show only purchased reservations matching the specified offering identifier.
    public var reservedDBInstancesOfferingId: Swift.String?

    public init (
        dBInstanceClass: Swift.String? = nil,
        duration: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        leaseId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        multiAZ: Swift.Bool? = nil,
        offeringType: Swift.String? = nil,
        productDescription: Swift.String? = nil,
        reservedDBInstanceId: Swift.String? = nil,
        reservedDBInstancesOfferingId: Swift.String? = nil
    )
    {
        self.dBInstanceClass = dBInstanceClass
        self.duration = duration
        self.filters = filters
        self.leaseId = leaseId
        self.marker = marker
        self.maxRecords = maxRecords
        self.multiAZ = multiAZ
        self.offeringType = offeringType
        self.productDescription = productDescription
        self.reservedDBInstanceId = reservedDBInstanceId
        self.reservedDBInstancesOfferingId = reservedDBInstancesOfferingId
    }
}

struct DescribeReservedDBInstancesInputBody: Swift.Equatable {
    let reservedDBInstanceId: Swift.String?
    let reservedDBInstancesOfferingId: Swift.String?
    let dBInstanceClass: Swift.String?
    let duration: Swift.String?
    let productDescription: Swift.String?
    let offeringType: Swift.String?
    let multiAZ: Swift.Bool?
    let leaseId: Swift.String?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeReservedDBInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceClass = "DBInstanceClass"
        case duration = "Duration"
        case filters = "Filters"
        case leaseId = "LeaseId"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case multiAZ = "MultiAZ"
        case offeringType = "OfferingType"
        case productDescription = "ProductDescription"
        case reservedDBInstanceId = "ReservedDBInstanceId"
        case reservedDBInstancesOfferingId = "ReservedDBInstancesOfferingId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedDBInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedDBInstanceId)
        reservedDBInstanceId = reservedDBInstanceIdDecoded
        let reservedDBInstancesOfferingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedDBInstancesOfferingId)
        reservedDBInstancesOfferingId = reservedDBInstancesOfferingIdDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .duration)
        duration = durationDecoded
        let productDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productDescription)
        productDescription = productDescriptionDecoded
        let offeringTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringType)
        offeringType = offeringTypeDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let leaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .leaseId)
        leaseId = leaseIdDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReservedDBInstancesOfferingsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let duration = duration {
            try container.encode(duration, forKey: ClientRuntime.Key("Duration"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let offeringType = offeringType {
            try container.encode(offeringType, forKey: ClientRuntime.Key("OfferingType"))
        }
        if let productDescription = productDescription {
            try container.encode(productDescription, forKey: ClientRuntime.Key("ProductDescription"))
        }
        if let reservedDBInstancesOfferingId = reservedDBInstancesOfferingId {
            try container.encode(reservedDBInstancesOfferingId, forKey: ClientRuntime.Key("ReservedDBInstancesOfferingId"))
        }
        try container.encode("DescribeReservedDBInstancesOfferings", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeReservedDBInstancesOfferingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeReservedDBInstancesOfferingsInput: Swift.Equatable {
    /// The DB instance class filter value. Specify this parameter to show only the available offerings matching the specified DB instance class.
    public var dBInstanceClass: Swift.String?
    /// Duration filter value, specified in years or seconds. Specify this parameter to show only reservations for this duration. Valid Values: 1 | 3 | 31536000 | 94608000
    public var duration: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more than the MaxRecords value is available, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// A value that indicates whether to show only those reservations that support Multi-AZ.
    public var multiAZ: Swift.Bool?
    /// The offering type filter value. Specify this parameter to show only the available offerings matching the specified offering type. Valid Values: "Partial Upfront" | "All Upfront" | "No Upfront"
    public var offeringType: Swift.String?
    /// Product description filter value. Specify this parameter to show only the available offerings that contain the specified product description. The results show offerings that partially match the filter value.
    public var productDescription: Swift.String?
    /// The offering identifier filter value. Specify this parameter to show only the available offering that matches the specified reservation identifier. Example: 438012d3-4052-4cc7-b2e3-8d3372e0e706
    public var reservedDBInstancesOfferingId: Swift.String?

    public init (
        dBInstanceClass: Swift.String? = nil,
        duration: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        multiAZ: Swift.Bool? = nil,
        offeringType: Swift.String? = nil,
        productDescription: Swift.String? = nil,
        reservedDBInstancesOfferingId: Swift.String? = nil
    )
    {
        self.dBInstanceClass = dBInstanceClass
        self.duration = duration
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.multiAZ = multiAZ
        self.offeringType = offeringType
        self.productDescription = productDescription
        self.reservedDBInstancesOfferingId = reservedDBInstancesOfferingId
    }
}

struct DescribeReservedDBInstancesOfferingsInputBody: Swift.Equatable {
    let reservedDBInstancesOfferingId: Swift.String?
    let dBInstanceClass: Swift.String?
    let duration: Swift.String?
    let productDescription: Swift.String?
    let offeringType: Swift.String?
    let multiAZ: Swift.Bool?
    let filters: [RdsClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeReservedDBInstancesOfferingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceClass = "DBInstanceClass"
        case duration = "Duration"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case multiAZ = "MultiAZ"
        case offeringType = "OfferingType"
        case productDescription = "ProductDescription"
        case reservedDBInstancesOfferingId = "ReservedDBInstancesOfferingId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedDBInstancesOfferingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedDBInstancesOfferingId)
        reservedDBInstancesOfferingId = reservedDBInstancesOfferingIdDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .duration)
        duration = durationDecoded
        let productDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productDescription)
        productDescription = productDescriptionDecoded
        let offeringTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringType)
        offeringType = offeringTypeDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReservedDBInstancesOfferingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeReservedDBInstancesOfferingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ReservedDBInstancesOfferingNotFound" : self = .reservedDBInstancesOfferingNotFoundFault(try ReservedDBInstancesOfferingNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReservedDBInstancesOfferingsOutputError: Swift.Error, Swift.Equatable {
    case reservedDBInstancesOfferingNotFoundFault(ReservedDBInstancesOfferingNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReservedDBInstancesOfferingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReservedDBInstancesOfferingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.reservedDBInstancesOfferings = output.reservedDBInstancesOfferings
        } else {
            self.marker = nil
            self.reservedDBInstancesOfferings = nil
        }
    }
}

/// Contains the result of a successful invocation of the DescribeReservedDBInstancesOfferings action.
public struct DescribeReservedDBInstancesOfferingsOutputResponse: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// A list of reserved DB instance offerings.
    public var reservedDBInstancesOfferings: [RdsClientTypes.ReservedDBInstancesOffering]?

    public init (
        marker: Swift.String? = nil,
        reservedDBInstancesOfferings: [RdsClientTypes.ReservedDBInstancesOffering]? = nil
    )
    {
        self.marker = marker
        self.reservedDBInstancesOfferings = reservedDBInstancesOfferings
    }
}

struct DescribeReservedDBInstancesOfferingsOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let reservedDBInstancesOfferings: [RdsClientTypes.ReservedDBInstancesOffering]?
}

extension DescribeReservedDBInstancesOfferingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case reservedDBInstancesOfferings = "ReservedDBInstancesOfferings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeReservedDBInstancesOfferingsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.reservedDBInstancesOfferings) {
            struct KeyVal0{struct ReservedDBInstancesOffering{}}
            let reservedDBInstancesOfferingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReservedDBInstancesOffering>.CodingKeys.self, forKey: .reservedDBInstancesOfferings)
            if let reservedDBInstancesOfferingsWrappedContainer = reservedDBInstancesOfferingsWrappedContainer {
                let reservedDBInstancesOfferingsContainer = try reservedDBInstancesOfferingsWrappedContainer.decodeIfPresent([RdsClientTypes.ReservedDBInstancesOffering].self, forKey: .member)
                var reservedDBInstancesOfferingsBuffer:[RdsClientTypes.ReservedDBInstancesOffering]? = nil
                if let reservedDBInstancesOfferingsContainer = reservedDBInstancesOfferingsContainer {
                    reservedDBInstancesOfferingsBuffer = [RdsClientTypes.ReservedDBInstancesOffering]()
                    for structureContainer0 in reservedDBInstancesOfferingsContainer {
                        reservedDBInstancesOfferingsBuffer?.append(structureContainer0)
                    }
                }
                reservedDBInstancesOfferings = reservedDBInstancesOfferingsBuffer
            } else {
                reservedDBInstancesOfferings = []
            }
        } else {
            reservedDBInstancesOfferings = nil
        }
    }
}

extension DescribeReservedDBInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeReservedDBInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ReservedDBInstanceNotFound" : self = .reservedDBInstanceNotFoundFault(try ReservedDBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReservedDBInstancesOutputError: Swift.Error, Swift.Equatable {
    case reservedDBInstanceNotFoundFault(ReservedDBInstanceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReservedDBInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReservedDBInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.reservedDBInstances = output.reservedDBInstances
        } else {
            self.marker = nil
            self.reservedDBInstances = nil
        }
    }
}

/// Contains the result of a successful invocation of the DescribeReservedDBInstances action.
public struct DescribeReservedDBInstancesOutputResponse: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// A list of reserved DB instances.
    public var reservedDBInstances: [RdsClientTypes.ReservedDBInstance]?

    public init (
        marker: Swift.String? = nil,
        reservedDBInstances: [RdsClientTypes.ReservedDBInstance]? = nil
    )
    {
        self.marker = marker
        self.reservedDBInstances = reservedDBInstances
    }
}

struct DescribeReservedDBInstancesOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let reservedDBInstances: [RdsClientTypes.ReservedDBInstance]?
}

extension DescribeReservedDBInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case reservedDBInstances = "ReservedDBInstances"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeReservedDBInstancesResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.reservedDBInstances) {
            struct KeyVal0{struct ReservedDBInstance{}}
            let reservedDBInstancesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReservedDBInstance>.CodingKeys.self, forKey: .reservedDBInstances)
            if let reservedDBInstancesWrappedContainer = reservedDBInstancesWrappedContainer {
                let reservedDBInstancesContainer = try reservedDBInstancesWrappedContainer.decodeIfPresent([RdsClientTypes.ReservedDBInstance].self, forKey: .member)
                var reservedDBInstancesBuffer:[RdsClientTypes.ReservedDBInstance]? = nil
                if let reservedDBInstancesContainer = reservedDBInstancesContainer {
                    reservedDBInstancesBuffer = [RdsClientTypes.ReservedDBInstance]()
                    for structureContainer0 in reservedDBInstancesContainer {
                        reservedDBInstancesBuffer?.append(structureContainer0)
                    }
                }
                reservedDBInstances = reservedDBInstancesBuffer
            } else {
                reservedDBInstances = []
            }
        } else {
            reservedDBInstances = nil
        }
    }
}

extension DescribeSourceRegionsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let regionName = regionName {
            try container.encode(regionName, forKey: ClientRuntime.Key("RegionName"))
        }
        try container.encode("DescribeSourceRegions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeSourceRegionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeSourceRegionsInput: Swift.Equatable {
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous DescribeSourceRegions request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The source Amazon Web Services Region name. For example, us-east-1. Constraints:
    ///
    /// * Must specify a valid Amazon Web Services Region name.
    public var regionName: Swift.String?

    public init (
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        regionName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.regionName = regionName
    }
}

struct DescribeSourceRegionsInputBody: Swift.Equatable {
    let regionName: Swift.String?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
    let filters: [RdsClientTypes.Filter]?
}

extension DescribeSourceRegionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case regionName = "RegionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionName)
        regionName = regionNameDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
    }
}

extension DescribeSourceRegionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeSourceRegionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSourceRegionsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSourceRegionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSourceRegionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.sourceRegions = output.sourceRegions
        } else {
            self.marker = nil
            self.sourceRegions = nil
        }
    }
}

/// Contains the result of a successful invocation of the DescribeSourceRegions action.
public struct DescribeSourceRegionsOutputResponse: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// A list of SourceRegion instances that contains each source Amazon Web Services Region that the current Amazon Web Services Region can get a read replica or a DB snapshot from.
    public var sourceRegions: [RdsClientTypes.SourceRegion]?

    public init (
        marker: Swift.String? = nil,
        sourceRegions: [RdsClientTypes.SourceRegion]? = nil
    )
    {
        self.marker = marker
        self.sourceRegions = sourceRegions
    }
}

struct DescribeSourceRegionsOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let sourceRegions: [RdsClientTypes.SourceRegion]?
}

extension DescribeSourceRegionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case sourceRegions = "SourceRegions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeSourceRegionsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.sourceRegions) {
            struct KeyVal0{struct SourceRegion{}}
            let sourceRegionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SourceRegion>.CodingKeys.self, forKey: .sourceRegions)
            if let sourceRegionsWrappedContainer = sourceRegionsWrappedContainer {
                let sourceRegionsContainer = try sourceRegionsWrappedContainer.decodeIfPresent([RdsClientTypes.SourceRegion].self, forKey: .member)
                var sourceRegionsBuffer:[RdsClientTypes.SourceRegion]? = nil
                if let sourceRegionsContainer = sourceRegionsContainer {
                    sourceRegionsBuffer = [RdsClientTypes.SourceRegion]()
                    for structureContainer0 in sourceRegionsContainer {
                        sourceRegionsBuffer?.append(structureContainer0)
                    }
                }
                sourceRegions = sourceRegionsBuffer
            } else {
                sourceRegions = []
            }
        } else {
            sourceRegions = nil
        }
    }
}

extension DescribeValidDBInstanceModificationsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        try container.encode("DescribeValidDBInstanceModifications", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeValidDBInstanceModificationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeValidDBInstanceModificationsInput: Swift.Equatable {
    /// The customer identifier or the ARN of your DB instance.
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?

    public init (
        dBInstanceIdentifier: Swift.String? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
    }
}

struct DescribeValidDBInstanceModificationsInputBody: Swift.Equatable {
    let dBInstanceIdentifier: Swift.String?
}

extension DescribeValidDBInstanceModificationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceIdentifier = "DBInstanceIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
    }
}

extension DescribeValidDBInstanceModificationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeValidDBInstanceModificationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeValidDBInstanceModificationsOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeValidDBInstanceModificationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeValidDBInstanceModificationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.validDBInstanceModificationsMessage = output.validDBInstanceModificationsMessage
        } else {
            self.validDBInstanceModificationsMessage = nil
        }
    }
}

public struct DescribeValidDBInstanceModificationsOutputResponse: Swift.Equatable {
    /// Information about valid modifications that you can make to your DB instance. Contains the result of a successful call to the DescribeValidDBInstanceModifications action. You can use this information when you call ModifyDBInstance.
    public var validDBInstanceModificationsMessage: RdsClientTypes.ValidDBInstanceModificationsMessage?

    public init (
        validDBInstanceModificationsMessage: RdsClientTypes.ValidDBInstanceModificationsMessage? = nil
    )
    {
        self.validDBInstanceModificationsMessage = validDBInstanceModificationsMessage
    }
}

struct DescribeValidDBInstanceModificationsOutputResponseBody: Swift.Equatable {
    let validDBInstanceModificationsMessage: RdsClientTypes.ValidDBInstanceModificationsMessage?
}

extension DescribeValidDBInstanceModificationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case validDBInstanceModificationsMessage = "ValidDBInstanceModificationsMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeValidDBInstanceModificationsResult"))
        let validDBInstanceModificationsMessageDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ValidDBInstanceModificationsMessage.self, forKey: .validDBInstanceModificationsMessage)
        validDBInstanceModificationsMessage = validDBInstanceModificationsMessageDecoded
    }
}

extension RdsClientTypes.DomainMembership: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case fQDN = "FQDN"
        case iAMRoleName = "IAMRoleName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let fQDN = fQDN {
            try container.encode(fQDN, forKey: ClientRuntime.Key("FQDN"))
        }
        if let iAMRoleName = iAMRoleName {
            try container.encode(iAMRoleName, forKey: ClientRuntime.Key("IAMRoleName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let fQDNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fQDN)
        fQDN = fQDNDecoded
        let iAMRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iAMRoleName)
        iAMRoleName = iAMRoleNameDecoded
    }
}

extension RdsClientTypes {
    /// An Active Directory Domain membership record associated with the DB instance or cluster.
    public struct DomainMembership: Swift.Equatable {
        /// The identifier of the Active Directory Domain.
        public var domain: Swift.String?
        /// The fully qualified domain name of the Active Directory Domain.
        public var fQDN: Swift.String?
        /// The name of the IAM role to be used when making API calls to the Directory Service.
        public var iAMRoleName: Swift.String?
        /// The status of the Active Directory Domain membership for the DB instance or cluster. Values include joined, pending-join, failed, and so on.
        public var status: Swift.String?

        public init (
            domain: Swift.String? = nil,
            fQDN: Swift.String? = nil,
            iAMRoleName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.domain = domain
            self.fQDN = fQDN
            self.iAMRoleName = iAMRoleName
            self.status = status
        }
    }

}

extension DomainNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DomainNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Domain doesn't refer to an existing Active Directory domain.
public struct DomainNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DomainNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DomainNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DoubleRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case from = "From"
        case to = "To"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if from != 0.0 {
            try container.encode(Swift.String(from), forKey: ClientRuntime.Key("From"))
        }
        if to != 0.0 {
            try container.encode(Swift.String(to), forKey: ClientRuntime.Key("To"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDecoded = try containerValues.decode(Swift.Double.self, forKey: .from)
        from = fromDecoded
        let toDecoded = try containerValues.decode(Swift.Double.self, forKey: .to)
        to = toDecoded
    }
}

extension RdsClientTypes {
    /// A range of double values.
    public struct DoubleRange: Swift.Equatable {
        /// The minimum value in the range.
        public var from: Swift.Double
        /// The maximum value in the range.
        public var to: Swift.Double

        public init (
            from: Swift.Double = 0.0,
            to: Swift.Double = 0.0
        )
        {
            self.from = from
            self.to = to
        }
    }

}

extension DownloadDBLogFilePortionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let logFileName = logFileName {
            try container.encode(logFileName, forKey: ClientRuntime.Key("LogFileName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if numberOfLines != 0 {
            try container.encode(numberOfLines, forKey: ClientRuntime.Key("NumberOfLines"))
        }
        try container.encode("DownloadDBLogFilePortion", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DownloadDBLogFilePortionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DownloadDBLogFilePortionInput: Swift.Equatable {
    /// The customer-assigned name of the DB instance that contains the log files you want to list. Constraints:
    ///
    /// * Must match the identifier of an existing DBInstance.
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// The name of the log file to be downloaded.
    /// This member is required.
    public var logFileName: Swift.String?
    /// The pagination token provided in the previous request or "0". If the Marker parameter is specified the response includes only records beyond the marker until the end of the file or up to NumberOfLines.
    public var marker: Swift.String?
    /// The number of lines to download. If the number of lines specified results in a file over 1 MB in size, the file is truncated at 1 MB in size. If the NumberOfLines parameter is specified, then the block of lines returned can be from the beginning or the end of the log file, depending on the value of the Marker parameter.
    ///
    /// * If neither Marker or NumberOfLines are specified, the entire log file is returned up to a maximum of 10000 lines, starting with the most recent log entries first.
    ///
    /// * If NumberOfLines is specified and Marker isn't specified, then the most recent lines from the end of the log file are returned.
    ///
    /// * If Marker is specified as "0", then the specified number of lines from the beginning of the log file are returned.
    ///
    /// * You can download the log file in blocks of lines by specifying the size of the block using the NumberOfLines parameter, and by specifying a value of "0" for the Marker parameter in your first request. Include the Marker value returned in the response as the Marker value for the next request, continuing until the AdditionalDataPending response element returns false.
    public var numberOfLines: Swift.Int

    public init (
        dBInstanceIdentifier: Swift.String? = nil,
        logFileName: Swift.String? = nil,
        marker: Swift.String? = nil,
        numberOfLines: Swift.Int = 0
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.logFileName = logFileName
        self.marker = marker
        self.numberOfLines = numberOfLines
    }
}

struct DownloadDBLogFilePortionInputBody: Swift.Equatable {
    let dBInstanceIdentifier: Swift.String?
    let logFileName: Swift.String?
    let marker: Swift.String?
    let numberOfLines: Swift.Int
}

extension DownloadDBLogFilePortionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case logFileName = "LogFileName"
        case marker = "Marker"
        case numberOfLines = "NumberOfLines"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let logFileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logFileName)
        logFileName = logFileNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let numberOfLinesDecoded = try containerValues.decode(Swift.Int.self, forKey: .numberOfLines)
        numberOfLines = numberOfLinesDecoded
    }
}

extension DownloadDBLogFilePortionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DownloadDBLogFilePortionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBLogFileNotFoundFault" : self = .dBLogFileNotFoundFault(try DBLogFileNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DownloadDBLogFilePortionOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBLogFileNotFoundFault(DBLogFileNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DownloadDBLogFilePortionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DownloadDBLogFilePortionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.additionalDataPending = output.additionalDataPending
            self.logFileData = output.logFileData
            self.marker = output.marker
        } else {
            self.additionalDataPending = false
            self.logFileData = nil
            self.marker = nil
        }
    }
}

/// This data type is used as a response element to DownloadDBLogFilePortion.
public struct DownloadDBLogFilePortionOutputResponse: Swift.Equatable {
    /// Boolean value that if true, indicates there is more data to be downloaded.
    public var additionalDataPending: Swift.Bool
    /// Entries from the specified log file.
    public var logFileData: Swift.String?
    /// A pagination token that can be used in a later DownloadDBLogFilePortion request.
    public var marker: Swift.String?

    public init (
        additionalDataPending: Swift.Bool = false,
        logFileData: Swift.String? = nil,
        marker: Swift.String? = nil
    )
    {
        self.additionalDataPending = additionalDataPending
        self.logFileData = logFileData
        self.marker = marker
    }
}

struct DownloadDBLogFilePortionOutputResponseBody: Swift.Equatable {
    let logFileData: Swift.String?
    let marker: Swift.String?
    let additionalDataPending: Swift.Bool
}

extension DownloadDBLogFilePortionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalDataPending = "AdditionalDataPending"
        case logFileData = "LogFileData"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DownloadDBLogFilePortionResult"))
        let logFileDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logFileData)
        logFileData = logFileDataDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let additionalDataPendingDecoded = try containerValues.decode(Swift.Bool.self, forKey: .additionalDataPending)
        additionalDataPending = additionalDataPendingDecoded
    }
}

extension RdsClientTypes.EC2SecurityGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eC2SecurityGroupId = "EC2SecurityGroupId"
        case eC2SecurityGroupName = "EC2SecurityGroupName"
        case eC2SecurityGroupOwnerId = "EC2SecurityGroupOwnerId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let eC2SecurityGroupId = eC2SecurityGroupId {
            try container.encode(eC2SecurityGroupId, forKey: ClientRuntime.Key("EC2SecurityGroupId"))
        }
        if let eC2SecurityGroupName = eC2SecurityGroupName {
            try container.encode(eC2SecurityGroupName, forKey: ClientRuntime.Key("EC2SecurityGroupName"))
        }
        if let eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId {
            try container.encode(eC2SecurityGroupOwnerId, forKey: ClientRuntime.Key("EC2SecurityGroupOwnerId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let eC2SecurityGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eC2SecurityGroupName)
        eC2SecurityGroupName = eC2SecurityGroupNameDecoded
        let eC2SecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eC2SecurityGroupId)
        eC2SecurityGroupId = eC2SecurityGroupIdDecoded
        let eC2SecurityGroupOwnerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eC2SecurityGroupOwnerId)
        eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerIdDecoded
    }
}

extension RdsClientTypes {
    /// This data type is used as a response element in the following actions:
    ///
    /// * AuthorizeDBSecurityGroupIngress
    ///
    /// * DescribeDBSecurityGroups
    ///
    /// * RevokeDBSecurityGroupIngress
    public struct EC2SecurityGroup: Swift.Equatable {
        /// Specifies the id of the EC2 security group.
        public var eC2SecurityGroupId: Swift.String?
        /// Specifies the name of the EC2 security group.
        public var eC2SecurityGroupName: Swift.String?
        /// Specifies the Amazon Web Services ID of the owner of the EC2 security group specified in the EC2SecurityGroupName field.
        public var eC2SecurityGroupOwnerId: Swift.String?
        /// Provides the status of the EC2 security group. Status can be "authorizing", "authorized", "revoking", and "revoked".
        public var status: Swift.String?

        public init (
            eC2SecurityGroupId: Swift.String? = nil,
            eC2SecurityGroupName: Swift.String? = nil,
            eC2SecurityGroupOwnerId: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.eC2SecurityGroupId = eC2SecurityGroupId
            self.eC2SecurityGroupName = eC2SecurityGroupName
            self.eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId
            self.status = status
        }
    }

}

extension RdsClientTypes.Endpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case hostedZoneId = "HostedZoneId"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let address = address {
            try container.encode(address, forKey: ClientRuntime.Key("Address"))
        }
        if let hostedZoneId = hostedZoneId {
            try container.encode(hostedZoneId, forKey: ClientRuntime.Key("HostedZoneId"))
        }
        if port != 0 {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
    }
}

extension RdsClientTypes {
    /// This data type represents the information you need to connect to an Amazon RDS DB instance. This data type is used as a response element in the following actions:
    ///
    /// * CreateDBInstance
    ///
    /// * DescribeDBInstances
    ///
    /// * DeleteDBInstance
    ///
    ///
    /// For the data structure that represents Amazon Aurora DB cluster endpoints, see DBClusterEndpoint.
    public struct Endpoint: Swift.Equatable {
        /// Specifies the DNS address of the DB instance.
        public var address: Swift.String?
        /// Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.
        public var hostedZoneId: Swift.String?
        /// Specifies the port that the database engine is listening on.
        public var port: Swift.Int

        public init (
            address: Swift.String? = nil,
            hostedZoneId: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.address = address
            self.hostedZoneId = hostedZoneId
            self.port = port
        }
    }

}

extension RdsClientTypes.EngineDefaults: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case marker = "Marker"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: ClientRuntime.Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct Parameter{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Parameter>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([RdsClientTypes.Parameter].self, forKey: .member)
                var parametersBuffer:[RdsClientTypes.Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [RdsClientTypes.Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
    }
}

extension RdsClientTypes {
    /// Contains the result of a successful invocation of the DescribeEngineDefaultParameters action.
    public struct EngineDefaults: Swift.Equatable {
        /// Specifies the name of the DB parameter group family that the engine default parameters apply to.
        public var dBParameterGroupFamily: Swift.String?
        /// An optional pagination token provided by a previous EngineDefaults request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords .
        public var marker: Swift.String?
        /// Contains a list of engine default parameters.
        public var parameters: [RdsClientTypes.Parameter]?

        public init (
            dBParameterGroupFamily: Swift.String? = nil,
            marker: Swift.String? = nil,
            parameters: [RdsClientTypes.Parameter]? = nil
        )
        {
            self.dBParameterGroupFamily = dBParameterGroupFamily
            self.marker = marker
            self.parameters = parameters
        }
    }

}

extension RdsClientTypes {
    public enum EngineFamily: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mysql
        case postgresql
        case sdkUnknown(Swift.String)

        public static var allCases: [EngineFamily] {
            return [
                .mysql,
                .postgresql,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mysql: return "MYSQL"
            case .postgresql: return "POSTGRESQL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EngineFamily(rawValue: rawValue) ?? EngineFamily.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes.Event: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case date = "Date"
        case eventCategories = "EventCategories"
        case message = "Message"
        case sourceArn = "SourceArn"
        case sourceIdentifier = "SourceIdentifier"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let date = date {
            try container.encode(ClientRuntime.TimestampWrapper(date, format: .dateTime), forKey: ClientRuntime.Key("date"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: ClientRuntime.Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let message = message {
            try container.encode(message, forKey: ClientRuntime.Key("Message"))
        }
        if let sourceArn = sourceArn {
            try container.encode(sourceArn, forKey: ClientRuntime.Key("SourceArn"))
        }
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: ClientRuntime.Key("SourceIdentifier"))
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        if containerValues.contains(.eventCategories) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategories)
            if let eventCategoriesWrappedContainer = eventCategoriesWrappedContainer {
                let eventCategoriesContainer = try eventCategoriesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var eventCategoriesBuffer:[Swift.String]? = nil
                if let eventCategoriesContainer = eventCategoriesContainer {
                    eventCategoriesBuffer = [Swift.String]()
                    for stringContainer0 in eventCategoriesContainer {
                        eventCategoriesBuffer?.append(stringContainer0)
                    }
                }
                eventCategories = eventCategoriesBuffer
            } else {
                eventCategories = []
            }
        } else {
            eventCategories = nil
        }
        let dateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .date)
        var dateBuffer:ClientRuntime.Date? = nil
        if let dateDecoded = dateDecoded {
            dateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(dateDecoded, format: .dateTime)
        }
        date = dateBuffer
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
    }
}

extension RdsClientTypes {
    /// This data type is used as a response element in the DescribeEvents action.
    public struct Event: Swift.Equatable {
        /// Specifies the date and time of the event.
        public var date: ClientRuntime.Date?
        /// Specifies the category for the event.
        public var eventCategories: [Swift.String]?
        /// Provides the text of this event.
        public var message: Swift.String?
        /// The Amazon Resource Name (ARN) for the event.
        public var sourceArn: Swift.String?
        /// Provides the identifier for the source of the event.
        public var sourceIdentifier: Swift.String?
        /// Specifies the source type for this event.
        public var sourceType: RdsClientTypes.SourceType?

        public init (
            date: ClientRuntime.Date? = nil,
            eventCategories: [Swift.String]? = nil,
            message: Swift.String? = nil,
            sourceArn: Swift.String? = nil,
            sourceIdentifier: Swift.String? = nil,
            sourceType: RdsClientTypes.SourceType? = nil
        )
        {
            self.date = date
            self.eventCategories = eventCategories
            self.message = message
            self.sourceArn = sourceArn
            self.sourceIdentifier = sourceIdentifier
            self.sourceType = sourceType
        }
    }

}

extension RdsClientTypes.EventCategoriesMap: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventCategories = "EventCategories"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: ClientRuntime.Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        if containerValues.contains(.eventCategories) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategories)
            if let eventCategoriesWrappedContainer = eventCategoriesWrappedContainer {
                let eventCategoriesContainer = try eventCategoriesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var eventCategoriesBuffer:[Swift.String]? = nil
                if let eventCategoriesContainer = eventCategoriesContainer {
                    eventCategoriesBuffer = [Swift.String]()
                    for stringContainer0 in eventCategoriesContainer {
                        eventCategoriesBuffer?.append(stringContainer0)
                    }
                }
                eventCategories = eventCategoriesBuffer
            } else {
                eventCategories = []
            }
        } else {
            eventCategories = nil
        }
    }
}

extension RdsClientTypes {
    /// Contains the results of a successful invocation of the DescribeEventCategories operation.
    public struct EventCategoriesMap: Swift.Equatable {
        /// The event categories for the specified source type
        public var eventCategories: [Swift.String]?
        /// The source type that the returned categories belong to
        public var sourceType: Swift.String?

        public init (
            eventCategories: [Swift.String]? = nil,
            sourceType: Swift.String? = nil
        )
        {
            self.eventCategories = eventCategories
            self.sourceType = sourceType
        }
    }

}

extension RdsClientTypes.EventSubscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case custSubscriptionId = "CustSubscriptionId"
        case customerAwsId = "CustomerAwsId"
        case enabled = "Enabled"
        case eventCategoriesList = "EventCategoriesList"
        case eventSubscriptionArn = "EventSubscriptionArn"
        case snsTopicArn = "SnsTopicArn"
        case sourceIdsList = "SourceIdsList"
        case sourceType = "SourceType"
        case status = "Status"
        case subscriptionCreationTime = "SubscriptionCreationTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let custSubscriptionId = custSubscriptionId {
            try container.encode(custSubscriptionId, forKey: ClientRuntime.Key("CustSubscriptionId"))
        }
        if let customerAwsId = customerAwsId {
            try container.encode(customerAwsId, forKey: ClientRuntime.Key("CustomerAwsId"))
        }
        if enabled != false {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let eventCategoriesList = eventCategoriesList {
            var eventCategoriesListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EventCategoriesList"))
            for (index0, string0) in eventCategoriesList.enumerated() {
                try eventCategoriesListContainer.encode(string0, forKey: ClientRuntime.Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let eventSubscriptionArn = eventSubscriptionArn {
            try container.encode(eventSubscriptionArn, forKey: ClientRuntime.Key("EventSubscriptionArn"))
        }
        if let snsTopicArn = snsTopicArn {
            try container.encode(snsTopicArn, forKey: ClientRuntime.Key("SnsTopicArn"))
        }
        if let sourceIdsList = sourceIdsList {
            var sourceIdsListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SourceIdsList"))
            for (index0, string0) in sourceIdsList.enumerated() {
                try sourceIdsListContainer.encode(string0, forKey: ClientRuntime.Key("SourceId.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let subscriptionCreationTime = subscriptionCreationTime {
            try container.encode(subscriptionCreationTime, forKey: ClientRuntime.Key("SubscriptionCreationTime"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerAwsIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAwsId)
        customerAwsId = customerAwsIdDecoded
        let custSubscriptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .custSubscriptionId)
        custSubscriptionId = custSubscriptionIdDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let subscriptionCreationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionCreationTime)
        subscriptionCreationTime = subscriptionCreationTimeDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        if containerValues.contains(.sourceIdsList) {
            struct KeyVal0{struct SourceId{}}
            let sourceIdsListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SourceId>.CodingKeys.self, forKey: .sourceIdsList)
            if let sourceIdsListWrappedContainer = sourceIdsListWrappedContainer {
                let sourceIdsListContainer = try sourceIdsListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var sourceIdsListBuffer:[Swift.String]? = nil
                if let sourceIdsListContainer = sourceIdsListContainer {
                    sourceIdsListBuffer = [Swift.String]()
                    for stringContainer0 in sourceIdsListContainer {
                        sourceIdsListBuffer?.append(stringContainer0)
                    }
                }
                sourceIdsList = sourceIdsListBuffer
            } else {
                sourceIdsList = []
            }
        } else {
            sourceIdsList = nil
        }
        if containerValues.contains(.eventCategoriesList) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategoriesList)
            if let eventCategoriesListWrappedContainer = eventCategoriesListWrappedContainer {
                let eventCategoriesListContainer = try eventCategoriesListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var eventCategoriesListBuffer:[Swift.String]? = nil
                if let eventCategoriesListContainer = eventCategoriesListContainer {
                    eventCategoriesListBuffer = [Swift.String]()
                    for stringContainer0 in eventCategoriesListContainer {
                        eventCategoriesListBuffer?.append(stringContainer0)
                    }
                }
                eventCategoriesList = eventCategoriesListBuffer
            } else {
                eventCategoriesList = []
            }
        } else {
            eventCategoriesList = nil
        }
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let eventSubscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSubscriptionArn)
        eventSubscriptionArn = eventSubscriptionArnDecoded
    }
}

extension RdsClientTypes {
    /// Contains the results of a successful invocation of the DescribeEventSubscriptions action.
    public struct EventSubscription: Swift.Equatable {
        /// The RDS event notification subscription Id.
        public var custSubscriptionId: Swift.String?
        /// The Amazon Web Services customer account associated with the RDS event notification subscription.
        public var customerAwsId: Swift.String?
        /// A Boolean value indicating if the subscription is enabled. True indicates the subscription is enabled.
        public var enabled: Swift.Bool
        /// A list of event categories for the RDS event notification subscription.
        public var eventCategoriesList: [Swift.String]?
        /// The Amazon Resource Name (ARN) for the event subscription.
        public var eventSubscriptionArn: Swift.String?
        /// The topic ARN of the RDS event notification subscription.
        public var snsTopicArn: Swift.String?
        /// A list of source IDs for the RDS event notification subscription.
        public var sourceIdsList: [Swift.String]?
        /// The source type for the RDS event notification subscription.
        public var sourceType: Swift.String?
        /// The status of the RDS event notification subscription. Constraints: Can be one of the following: creating | modifying | deleting | active | no-permission | topic-not-exist The status "no-permission" indicates that RDS no longer has permission to post to the SNS topic. The status "topic-not-exist" indicates that the topic was deleted after the subscription was created.
        public var status: Swift.String?
        /// The time the RDS event notification subscription was created.
        public var subscriptionCreationTime: Swift.String?

        public init (
            custSubscriptionId: Swift.String? = nil,
            customerAwsId: Swift.String? = nil,
            enabled: Swift.Bool = false,
            eventCategoriesList: [Swift.String]? = nil,
            eventSubscriptionArn: Swift.String? = nil,
            snsTopicArn: Swift.String? = nil,
            sourceIdsList: [Swift.String]? = nil,
            sourceType: Swift.String? = nil,
            status: Swift.String? = nil,
            subscriptionCreationTime: Swift.String? = nil
        )
        {
            self.custSubscriptionId = custSubscriptionId
            self.customerAwsId = customerAwsId
            self.enabled = enabled
            self.eventCategoriesList = eventCategoriesList
            self.eventSubscriptionArn = eventSubscriptionArn
            self.snsTopicArn = snsTopicArn
            self.sourceIdsList = sourceIdsList
            self.sourceType = sourceType
            self.status = status
            self.subscriptionCreationTime = subscriptionCreationTime
        }
    }

}

extension EventSubscriptionQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<EventSubscriptionQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the maximum number of event subscriptions.
public struct EventSubscriptionQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EventSubscriptionQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension EventSubscriptionQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.ExportTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportOnly = "ExportOnly"
        case exportTaskIdentifier = "ExportTaskIdentifier"
        case failureCause = "FailureCause"
        case iamRoleArn = "IamRoleArn"
        case kmsKeyId = "KmsKeyId"
        case percentProgress = "PercentProgress"
        case s3Bucket = "S3Bucket"
        case s3Prefix = "S3Prefix"
        case snapshotTime = "SnapshotTime"
        case sourceArn = "SourceArn"
        case status = "Status"
        case taskEndTime = "TaskEndTime"
        case taskStartTime = "TaskStartTime"
        case totalExtractedDataInGB = "TotalExtractedDataInGB"
        case warningMessage = "WarningMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let exportOnly = exportOnly {
            var exportOnlyContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExportOnly"))
            for (index0, string0) in exportOnly.enumerated() {
                try exportOnlyContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let exportTaskIdentifier = exportTaskIdentifier {
            try container.encode(exportTaskIdentifier, forKey: ClientRuntime.Key("ExportTaskIdentifier"))
        }
        if let failureCause = failureCause {
            try container.encode(failureCause, forKey: ClientRuntime.Key("FailureCause"))
        }
        if let iamRoleArn = iamRoleArn {
            try container.encode(iamRoleArn, forKey: ClientRuntime.Key("IamRoleArn"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if percentProgress != 0 {
            try container.encode(percentProgress, forKey: ClientRuntime.Key("PercentProgress"))
        }
        if let s3Bucket = s3Bucket {
            try container.encode(s3Bucket, forKey: ClientRuntime.Key("S3Bucket"))
        }
        if let s3Prefix = s3Prefix {
            try container.encode(s3Prefix, forKey: ClientRuntime.Key("S3Prefix"))
        }
        if let snapshotTime = snapshotTime {
            try container.encode(ClientRuntime.TimestampWrapper(snapshotTime, format: .dateTime), forKey: ClientRuntime.Key("snapshotTime"))
        }
        if let sourceArn = sourceArn {
            try container.encode(sourceArn, forKey: ClientRuntime.Key("SourceArn"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let taskEndTime = taskEndTime {
            try container.encode(ClientRuntime.TimestampWrapper(taskEndTime, format: .dateTime), forKey: ClientRuntime.Key("taskEndTime"))
        }
        if let taskStartTime = taskStartTime {
            try container.encode(ClientRuntime.TimestampWrapper(taskStartTime, format: .dateTime), forKey: ClientRuntime.Key("taskStartTime"))
        }
        if totalExtractedDataInGB != 0 {
            try container.encode(totalExtractedDataInGB, forKey: ClientRuntime.Key("TotalExtractedDataInGB"))
        }
        if let warningMessage = warningMessage {
            try container.encode(warningMessage, forKey: ClientRuntime.Key("WarningMessage"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportTaskIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportTaskIdentifier)
        exportTaskIdentifier = exportTaskIdentifierDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        if containerValues.contains(.exportOnly) {
            struct KeyVal0{struct member{}}
            let exportOnlyWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .exportOnly)
            if let exportOnlyWrappedContainer = exportOnlyWrappedContainer {
                let exportOnlyContainer = try exportOnlyWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var exportOnlyBuffer:[Swift.String]? = nil
                if let exportOnlyContainer = exportOnlyContainer {
                    exportOnlyBuffer = [Swift.String]()
                    for stringContainer0 in exportOnlyContainer {
                        exportOnlyBuffer?.append(stringContainer0)
                    }
                }
                exportOnly = exportOnlyBuffer
            } else {
                exportOnly = []
            }
        } else {
            exportOnly = nil
        }
        let snapshotTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotTime)
        var snapshotTimeBuffer:ClientRuntime.Date? = nil
        if let snapshotTimeDecoded = snapshotTimeDecoded {
            snapshotTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(snapshotTimeDecoded, format: .dateTime)
        }
        snapshotTime = snapshotTimeBuffer
        let taskStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskStartTime)
        var taskStartTimeBuffer:ClientRuntime.Date? = nil
        if let taskStartTimeDecoded = taskStartTimeDecoded {
            taskStartTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(taskStartTimeDecoded, format: .dateTime)
        }
        taskStartTime = taskStartTimeBuffer
        let taskEndTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskEndTime)
        var taskEndTimeBuffer:ClientRuntime.Date? = nil
        if let taskEndTimeDecoded = taskEndTimeDecoded {
            taskEndTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(taskEndTimeDecoded, format: .dateTime)
        }
        taskEndTime = taskEndTimeBuffer
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let percentProgressDecoded = try containerValues.decode(Swift.Int.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let totalExtractedDataInGBDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalExtractedDataInGB)
        totalExtractedDataInGB = totalExtractedDataInGBDecoded
        let failureCauseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCause)
        failureCause = failureCauseDecoded
        let warningMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .warningMessage)
        warningMessage = warningMessageDecoded
    }
}

extension RdsClientTypes {
    /// Contains the details of a snapshot export to Amazon S3. This data type is used as a response element in the DescribeExportTasks action.
    public struct ExportTask: Swift.Equatable {
        /// The data exported from the snapshot. Valid values are the following:
        ///
        /// * database - Export all the data from a specified database.
        ///
        /// * database.table table-name - Export a table of the snapshot. This format is valid only for RDS for MySQL, RDS for MariaDB, and Aurora MySQL.
        ///
        /// * database.schema schema-name - Export a database schema of the snapshot. This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.
        ///
        /// * database.schema.table table-name - Export a table of the database schema. This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.
        public var exportOnly: [Swift.String]?
        /// A unique identifier for the snapshot export task. This ID isn't an identifier for the Amazon S3 bucket where the snapshot is exported to.
        public var exportTaskIdentifier: Swift.String?
        /// The reason the export failed, if it failed.
        public var failureCause: Swift.String?
        /// The name of the IAM role that is used to write to Amazon S3 when exporting a snapshot.
        public var iamRoleArn: Swift.String?
        /// The key identifier of the Amazon Web Services KMS key that is used to encrypt the snapshot when it's exported to Amazon S3. The KMS key identifier is its key ARN, key ID, alias ARN, or alias name. The IAM role used for the snapshot export must have encryption and decryption permissions to use this KMS key.
        public var kmsKeyId: Swift.String?
        /// The progress of the snapshot export task as a percentage.
        public var percentProgress: Swift.Int
        /// The Amazon S3 bucket that the snapshot is exported to.
        public var s3Bucket: Swift.String?
        /// The Amazon S3 bucket prefix that is the file name and path of the exported snapshot.
        public var s3Prefix: Swift.String?
        /// The time that the snapshot was created.
        public var snapshotTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the snapshot exported to Amazon S3.
        public var sourceArn: Swift.String?
        /// The progress status of the export task.
        public var status: Swift.String?
        /// The time that the snapshot export task completed.
        public var taskEndTime: ClientRuntime.Date?
        /// The time that the snapshot export task started.
        public var taskStartTime: ClientRuntime.Date?
        /// The total amount of data exported, in gigabytes.
        public var totalExtractedDataInGB: Swift.Int
        /// A warning about the snapshot export task.
        public var warningMessage: Swift.String?

        public init (
            exportOnly: [Swift.String]? = nil,
            exportTaskIdentifier: Swift.String? = nil,
            failureCause: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            percentProgress: Swift.Int = 0,
            s3Bucket: Swift.String? = nil,
            s3Prefix: Swift.String? = nil,
            snapshotTime: ClientRuntime.Date? = nil,
            sourceArn: Swift.String? = nil,
            status: Swift.String? = nil,
            taskEndTime: ClientRuntime.Date? = nil,
            taskStartTime: ClientRuntime.Date? = nil,
            totalExtractedDataInGB: Swift.Int = 0,
            warningMessage: Swift.String? = nil
        )
        {
            self.exportOnly = exportOnly
            self.exportTaskIdentifier = exportTaskIdentifier
            self.failureCause = failureCause
            self.iamRoleArn = iamRoleArn
            self.kmsKeyId = kmsKeyId
            self.percentProgress = percentProgress
            self.s3Bucket = s3Bucket
            self.s3Prefix = s3Prefix
            self.snapshotTime = snapshotTime
            self.sourceArn = sourceArn
            self.status = status
            self.taskEndTime = taskEndTime
            self.taskStartTime = taskStartTime
            self.totalExtractedDataInGB = totalExtractedDataInGB
            self.warningMessage = warningMessage
        }
    }

}

extension ExportTaskAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ExportTaskAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can't start an export task that's already running.
public struct ExportTaskAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ExportTaskAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ExportTaskAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ExportTaskNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ExportTaskNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The export task doesn't exist.
public struct ExportTaskNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ExportTaskNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ExportTaskNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FailoverDBClusterInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let targetDBInstanceIdentifier = targetDBInstanceIdentifier {
            try container.encode(targetDBInstanceIdentifier, forKey: ClientRuntime.Key("TargetDBInstanceIdentifier"))
        }
        try container.encode("FailoverDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension FailoverDBClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct FailoverDBClusterInput: Swift.Equatable {
    /// A DB cluster identifier to force a failover for. This parameter isn't case-sensitive. Constraints:
    ///
    /// * Must match the identifier of an existing DBCluster.
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// The name of the DB instance to promote to the primary DB instance. Specify the DB instance identifier for an Aurora Replica or a Multi-AZ readable standby in the DB cluster, for example mydbcluster-replica1. This setting isn't supported for RDS for MySQL Multi-AZ DB clusters.
    public var targetDBInstanceIdentifier: Swift.String?

    public init (
        dBClusterIdentifier: Swift.String? = nil,
        targetDBInstanceIdentifier: Swift.String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.targetDBInstanceIdentifier = targetDBInstanceIdentifier
    }
}

struct FailoverDBClusterInputBody: Swift.Equatable {
    let dBClusterIdentifier: Swift.String?
    let targetDBInstanceIdentifier: Swift.String?
}

extension FailoverDBClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterIdentifier = "DBClusterIdentifier"
        case targetDBInstanceIdentifier = "TargetDBInstanceIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let targetDBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetDBInstanceIdentifier)
        targetDBInstanceIdentifier = targetDBInstanceIdentifierDecoded
    }
}

extension FailoverDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension FailoverDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum FailoverDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension FailoverDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: FailoverDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct FailoverDBClusterOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon Aurora DB cluster or Multi-AZ DB cluster. For an Amazon Aurora DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, PromoteReadReplicaDBCluster, RestoreDBClusterFromS3, RestoreDBClusterFromSnapshot, RestoreDBClusterToPointInTime, StartDBCluster, and StopDBCluster. For a Multi-AZ DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, RebootDBCluster, RestoreDBClusterFromSnapshot, and RestoreDBClusterToPointInTime. For more information on Amazon Aurora DB clusters, see [ What is Amazon Aurora?](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/CHAP_AuroraOverview.html) in the Amazon Aurora User Guide. For more information on Multi-AZ DB clusters, see [ Multi-AZ deployments with two readable standby DB instances](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/multi-az-db-clusters-concepts.html) in the Amazon RDS User Guide. The Multi-AZ DB clusters feature is in preview and is subject to change.
    public var dBCluster: RdsClientTypes.DBCluster?

    public init (
        dBCluster: RdsClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct FailoverDBClusterOutputResponseBody: Swift.Equatable {
    let dBCluster: RdsClientTypes.DBCluster?
}

extension FailoverDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("FailoverDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

extension FailoverGlobalClusterInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: ClientRuntime.Key("GlobalClusterIdentifier"))
        }
        if let targetDbClusterIdentifier = targetDbClusterIdentifier {
            try container.encode(targetDbClusterIdentifier, forKey: ClientRuntime.Key("TargetDbClusterIdentifier"))
        }
        try container.encode("FailoverGlobalCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension FailoverGlobalClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct FailoverGlobalClusterInput: Swift.Equatable {
    /// Identifier of the Aurora global database ([GlobalCluster]) that should be failed over. The identifier is the unique key assigned by the user when the Aurora global database was created. In other words, it's the name of the Aurora global database that you want to fail over. Constraints:
    ///
    /// * Must match the identifier of an existing [GlobalCluster] (Aurora global database).
    /// This member is required.
    public var globalClusterIdentifier: Swift.String?
    /// Identifier of the secondary Aurora DB cluster that you want to promote to primary for the Aurora global database ([GlobalCluster].) Use the Amazon Resource Name (ARN) for the identifier so that Aurora can locate the cluster in its Amazon Web Services Region.
    /// This member is required.
    public var targetDbClusterIdentifier: Swift.String?

    public init (
        globalClusterIdentifier: Swift.String? = nil,
        targetDbClusterIdentifier: Swift.String? = nil
    )
    {
        self.globalClusterIdentifier = globalClusterIdentifier
        self.targetDbClusterIdentifier = targetDbClusterIdentifier
    }
}

struct FailoverGlobalClusterInputBody: Swift.Equatable {
    let globalClusterIdentifier: Swift.String?
    let targetDbClusterIdentifier: Swift.String?
}

extension FailoverGlobalClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalClusterIdentifier = "GlobalClusterIdentifier"
        case targetDbClusterIdentifier = "TargetDbClusterIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalClusterIdentifier)
        globalClusterIdentifier = globalClusterIdentifierDecoded
        let targetDbClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetDbClusterIdentifier)
        targetDbClusterIdentifier = targetDbClusterIdentifierDecoded
    }
}

extension FailoverGlobalClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension FailoverGlobalClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlobalClusterNotFoundFault" : self = .globalClusterNotFoundFault(try GlobalClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGlobalClusterStateFault" : self = .invalidGlobalClusterStateFault(try InvalidGlobalClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum FailoverGlobalClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case globalClusterNotFoundFault(GlobalClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidGlobalClusterStateFault(InvalidGlobalClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension FailoverGlobalClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: FailoverGlobalClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalCluster = output.globalCluster
        } else {
            self.globalCluster = nil
        }
    }
}

public struct FailoverGlobalClusterOutputResponse: Swift.Equatable {
    /// A data type representing an Aurora global database.
    public var globalCluster: RdsClientTypes.GlobalCluster?

    public init (
        globalCluster: RdsClientTypes.GlobalCluster? = nil
    )
    {
        self.globalCluster = globalCluster
    }
}

struct FailoverGlobalClusterOutputResponseBody: Swift.Equatable {
    let globalCluster: RdsClientTypes.GlobalCluster?
}

extension FailoverGlobalClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalCluster = "GlobalCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("FailoverGlobalClusterResult"))
        let globalClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.GlobalCluster.self, forKey: .globalCluster)
        globalCluster = globalClusterDecoded
    }
}

extension RdsClientTypes.FailoverState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromDbClusterArn = "FromDbClusterArn"
        case status = "Status"
        case toDbClusterArn = "ToDbClusterArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let fromDbClusterArn = fromDbClusterArn {
            try container.encode(fromDbClusterArn, forKey: ClientRuntime.Key("FromDbClusterArn"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let toDbClusterArn = toDbClusterArn {
            try container.encode(toDbClusterArn, forKey: ClientRuntime.Key("ToDbClusterArn"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(RdsClientTypes.FailoverStatus.self, forKey: .status)
        status = statusDecoded
        let fromDbClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromDbClusterArn)
        fromDbClusterArn = fromDbClusterArnDecoded
        let toDbClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .toDbClusterArn)
        toDbClusterArn = toDbClusterArnDecoded
    }
}

extension RdsClientTypes {
    /// Contains the state of scheduled or in-process failover operations on an Aurora global database ([GlobalCluster]). This Data type is empty unless a failover operation is scheduled or is currently underway on the Aurora global database.
    public struct FailoverState: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Aurora DB cluster that is currently being demoted, and which is associated with this state.
        public var fromDbClusterArn: Swift.String?
        /// The current status of the Aurora global database ([GlobalCluster]). Possible values are as follows:
        ///
        /// * pending  A request to fail over the Aurora global database ([GlobalCluster]) has been received by the service. The GlobalCluster's primary DB cluster and the specified secondary DB cluster are being verified before the failover process can start.
        ///
        /// * failing-over  This status covers the range of Aurora internal operations that take place during the failover process, such as demoting the primary Aurora DB cluster, promoting the secondary Aurora DB, and synchronizing replicas.
        ///
        /// * cancelling  The request to fail over the Aurora global database ([GlobalCluster]) was cancelled and the primary Aurora DB cluster and the selected secondary Aurora DB cluster are returning to their previous states.
        public var status: RdsClientTypes.FailoverStatus?
        /// The Amazon Resource Name (ARN) of the Aurora DB cluster that is currently being promoted, and which is associated with this state.
        public var toDbClusterArn: Swift.String?

        public init (
            fromDbClusterArn: Swift.String? = nil,
            status: RdsClientTypes.FailoverStatus? = nil,
            toDbClusterArn: Swift.String? = nil
        )
        {
            self.fromDbClusterArn = fromDbClusterArn
            self.status = status
            self.toDbClusterArn = toDbClusterArn
        }
    }

}

extension RdsClientTypes {
    public enum FailoverStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelling
        case failingOver
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [FailoverStatus] {
            return [
                .cancelling,
                .failingOver,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelling: return "cancelling"
            case .failingOver: return "failing-over"
            case .pending: return "pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailoverStatus(rawValue: rawValue) ?? FailoverStatus.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Values"))
            for (index0, string0) in values.enumerated() {
                try valuesContainer.encode(string0, forKey: ClientRuntime.Key("Value.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        if containerValues.contains(.values) {
            struct KeyVal0{struct Value{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Value>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var valuesBuffer:[Swift.String]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [Swift.String]()
                    for stringContainer0 in valuesContainer {
                        valuesBuffer?.append(stringContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
    }
}

extension RdsClientTypes {
    /// A filter name and value pair that is used to return a more specific list of results from a describe operation. Filters can be used to match a set of resources by specific criteria, such as IDs. The filters supported by a describe operation are documented with the describe operation. Currently, wildcards are not supported in filters. The following actions can be filtered:
    ///
    /// * DescribeDBClusterBacktracks
    ///
    /// * DescribeDBClusterEndpoints
    ///
    /// * DescribeDBClusters
    ///
    /// * DescribeDBInstances
    ///
    /// * DescribePendingMaintenanceActions
    public struct Filter: Swift.Equatable {
        /// The name of the filter. Filter names are case-sensitive.
        /// This member is required.
        public var name: Swift.String?
        /// One or more filter values. Filter values are case-sensitive.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension RdsClientTypes.GlobalCluster: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case deletionProtection = "DeletionProtection"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case failoverState = "FailoverState"
        case globalClusterArn = "GlobalClusterArn"
        case globalClusterIdentifier = "GlobalClusterIdentifier"
        case globalClusterMembers = "GlobalClusterMembers"
        case globalClusterResourceId = "GlobalClusterResourceId"
        case status = "Status"
        case storageEncrypted = "StorageEncrypted"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: ClientRuntime.Key("DatabaseName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let failoverState = failoverState {
            try container.encode(failoverState, forKey: ClientRuntime.Key("FailoverState"))
        }
        if let globalClusterArn = globalClusterArn {
            try container.encode(globalClusterArn, forKey: ClientRuntime.Key("GlobalClusterArn"))
        }
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: ClientRuntime.Key("GlobalClusterIdentifier"))
        }
        if let globalClusterMembers = globalClusterMembers {
            var globalClusterMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("GlobalClusterMembers"))
            for (index0, globalclustermember0) in globalClusterMembers.enumerated() {
                try globalClusterMembersContainer.encode(globalclustermember0, forKey: ClientRuntime.Key("GlobalClusterMember.\(index0.advanced(by: 1))"))
            }
        }
        if let globalClusterResourceId = globalClusterResourceId {
            try container.encode(globalClusterResourceId, forKey: ClientRuntime.Key("GlobalClusterResourceId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let storageEncrypted = storageEncrypted {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalClusterIdentifier)
        globalClusterIdentifier = globalClusterIdentifierDecoded
        let globalClusterResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalClusterResourceId)
        globalClusterResourceId = globalClusterResourceIdDecoded
        let globalClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalClusterArn)
        globalClusterArn = globalClusterArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let storageEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        if containerValues.contains(.globalClusterMembers) {
            struct KeyVal0{struct GlobalClusterMember{}}
            let globalClusterMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.GlobalClusterMember>.CodingKeys.self, forKey: .globalClusterMembers)
            if let globalClusterMembersWrappedContainer = globalClusterMembersWrappedContainer {
                let globalClusterMembersContainer = try globalClusterMembersWrappedContainer.decodeIfPresent([RdsClientTypes.GlobalClusterMember].self, forKey: .member)
                var globalClusterMembersBuffer:[RdsClientTypes.GlobalClusterMember]? = nil
                if let globalClusterMembersContainer = globalClusterMembersContainer {
                    globalClusterMembersBuffer = [RdsClientTypes.GlobalClusterMember]()
                    for structureContainer0 in globalClusterMembersContainer {
                        globalClusterMembersBuffer?.append(structureContainer0)
                    }
                }
                globalClusterMembers = globalClusterMembersBuffer
            } else {
                globalClusterMembers = []
            }
        } else {
            globalClusterMembers = nil
        }
        let failoverStateDecoded = try containerValues.decodeIfPresent(RdsClientTypes.FailoverState.self, forKey: .failoverState)
        failoverState = failoverStateDecoded
    }
}

extension RdsClientTypes {
    /// A data type representing an Aurora global database.
    public struct GlobalCluster: Swift.Equatable {
        /// The default database name within the new global database cluster.
        public var databaseName: Swift.String?
        /// The deletion protection setting for the new global database cluster.
        public var deletionProtection: Swift.Bool?
        /// The Aurora database engine used by the global database cluster.
        public var engine: Swift.String?
        /// Indicates the database engine version.
        public var engineVersion: Swift.String?
        /// A data object containing all properties for the current state of an in-process or pending failover process for this Aurora global database. This object is empty unless the [FailoverGlobalCluster] API operation has been called on this Aurora global database ([GlobalCluster]).
        public var failoverState: RdsClientTypes.FailoverState?
        /// The Amazon Resource Name (ARN) for the global database cluster.
        public var globalClusterArn: Swift.String?
        /// Contains a user-supplied global database cluster identifier. This identifier is the unique key that identifies a global database cluster.
        public var globalClusterIdentifier: Swift.String?
        /// The list of cluster IDs for secondary clusters within the global database cluster. Currently limited to 1 item.
        public var globalClusterMembers: [RdsClientTypes.GlobalClusterMember]?
        /// The Amazon Web Services Region-unique, immutable identifier for the global database cluster. This identifier is found in Amazon Web Services CloudTrail log entries whenever the Amazon Web Services KMS key for the DB cluster is accessed.
        public var globalClusterResourceId: Swift.String?
        /// Specifies the current state of this global database cluster.
        public var status: Swift.String?
        /// The storage encryption setting for the global database cluster.
        public var storageEncrypted: Swift.Bool?

        public init (
            databaseName: Swift.String? = nil,
            deletionProtection: Swift.Bool? = nil,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            failoverState: RdsClientTypes.FailoverState? = nil,
            globalClusterArn: Swift.String? = nil,
            globalClusterIdentifier: Swift.String? = nil,
            globalClusterMembers: [RdsClientTypes.GlobalClusterMember]? = nil,
            globalClusterResourceId: Swift.String? = nil,
            status: Swift.String? = nil,
            storageEncrypted: Swift.Bool? = nil
        )
        {
            self.databaseName = databaseName
            self.deletionProtection = deletionProtection
            self.engine = engine
            self.engineVersion = engineVersion
            self.failoverState = failoverState
            self.globalClusterArn = globalClusterArn
            self.globalClusterIdentifier = globalClusterIdentifier
            self.globalClusterMembers = globalClusterMembers
            self.globalClusterResourceId = globalClusterResourceId
            self.status = status
            self.storageEncrypted = storageEncrypted
        }
    }

}

extension GlobalClusterAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<GlobalClusterAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The GlobalClusterIdentifier already exists. Choose a new global database identifier (unique name) to create a new global database cluster.
public struct GlobalClusterAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct GlobalClusterAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension GlobalClusterAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.GlobalClusterMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterArn = "DBClusterArn"
        case globalWriteForwardingStatus = "GlobalWriteForwardingStatus"
        case isWriter = "IsWriter"
        case readers = "Readers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterArn = dBClusterArn {
            try container.encode(dBClusterArn, forKey: ClientRuntime.Key("DBClusterArn"))
        }
        if let globalWriteForwardingStatus = globalWriteForwardingStatus {
            try container.encode(globalWriteForwardingStatus, forKey: ClientRuntime.Key("GlobalWriteForwardingStatus"))
        }
        if isWriter != false {
            try container.encode(isWriter, forKey: ClientRuntime.Key("IsWriter"))
        }
        if let readers = readers {
            var readersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Readers"))
            for (index0, string0) in readers.enumerated() {
                try readersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterArn)
        dBClusterArn = dBClusterArnDecoded
        if containerValues.contains(.readers) {
            struct KeyVal0{struct member{}}
            let readersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .readers)
            if let readersWrappedContainer = readersWrappedContainer {
                let readersContainer = try readersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var readersBuffer:[Swift.String]? = nil
                if let readersContainer = readersContainer {
                    readersBuffer = [Swift.String]()
                    for stringContainer0 in readersContainer {
                        readersBuffer?.append(stringContainer0)
                    }
                }
                readers = readersBuffer
            } else {
                readers = []
            }
        } else {
            readers = nil
        }
        let isWriterDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isWriter)
        isWriter = isWriterDecoded
        let globalWriteForwardingStatusDecoded = try containerValues.decodeIfPresent(RdsClientTypes.WriteForwardingStatus.self, forKey: .globalWriteForwardingStatus)
        globalWriteForwardingStatus = globalWriteForwardingStatusDecoded
    }
}

extension RdsClientTypes {
    /// A data structure with information about any primary and secondary clusters associated with an Aurora global database.
    public struct GlobalClusterMember: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for each Aurora cluster.
        public var dBClusterArn: Swift.String?
        /// Specifies whether a secondary cluster in an Aurora global database has write forwarding enabled, not enabled, or is in the process of enabling it.
        public var globalWriteForwardingStatus: RdsClientTypes.WriteForwardingStatus?
        /// Specifies whether the Aurora cluster is the primary cluster (that is, has read-write capability) for the Aurora global database with which it is associated.
        public var isWriter: Swift.Bool
        /// The Amazon Resource Name (ARN) for each read-only secondary cluster associated with the Aurora global database.
        public var readers: [Swift.String]?

        public init (
            dBClusterArn: Swift.String? = nil,
            globalWriteForwardingStatus: RdsClientTypes.WriteForwardingStatus? = nil,
            isWriter: Swift.Bool = false,
            readers: [Swift.String]? = nil
        )
        {
            self.dBClusterArn = dBClusterArn
            self.globalWriteForwardingStatus = globalWriteForwardingStatus
            self.isWriter = isWriter
            self.readers = readers
        }
    }

}

extension GlobalClusterNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<GlobalClusterNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The GlobalClusterIdentifier doesn't refer to an existing global database cluster.
public struct GlobalClusterNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct GlobalClusterNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension GlobalClusterNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalClusterQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<GlobalClusterQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of global database clusters for this account is already at the maximum allowed.
public struct GlobalClusterQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct GlobalClusterQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension GlobalClusterQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes {
    public enum IAMAuthMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case `required`
        case sdkUnknown(Swift.String)

        public static var allCases: [IAMAuthMode] {
            return [
                .disabled,
                .required,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .required: return "REQUIRED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IAMAuthMode(rawValue: rawValue) ?? IAMAuthMode.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes.IPRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cIDRIP = "CIDRIP"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let cIDRIP = cIDRIP {
            try container.encode(cIDRIP, forKey: ClientRuntime.Key("CIDRIP"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let cIDRIPDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cIDRIP)
        cIDRIP = cIDRIPDecoded
    }
}

extension RdsClientTypes {
    /// This data type is used as a response element in the DescribeDBSecurityGroups action.
    public struct IPRange: Swift.Equatable {
        /// Specifies the IP range.
        public var cIDRIP: Swift.String?
        /// Specifies the status of the IP range. Status can be "authorizing", "authorized", "revoking", and "revoked".
        public var status: Swift.String?

        public init (
            cIDRIP: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.cIDRIP = cIDRIP
            self.status = status
        }
    }

}

extension IamRoleMissingPermissionsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<IamRoleMissingPermissionsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The IAM role requires additional permissions to export to an Amazon S3 bucket.
public struct IamRoleMissingPermissionsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IamRoleMissingPermissionsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension IamRoleMissingPermissionsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IamRoleNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<IamRoleNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The IAM role is missing for exporting to an Amazon S3 bucket.
public struct IamRoleNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IamRoleNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension IamRoleNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImportInstallationMediaInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let customAvailabilityZoneId = customAvailabilityZoneId {
            try container.encode(customAvailabilityZoneId, forKey: ClientRuntime.Key("CustomAvailabilityZoneId"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineInstallationMediaPath = engineInstallationMediaPath {
            try container.encode(engineInstallationMediaPath, forKey: ClientRuntime.Key("EngineInstallationMediaPath"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let oSInstallationMediaPath = oSInstallationMediaPath {
            try container.encode(oSInstallationMediaPath, forKey: ClientRuntime.Key("OSInstallationMediaPath"))
        }
        try container.encode("ImportInstallationMedia", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ImportInstallationMediaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportInstallationMediaInput: Swift.Equatable {
    /// The identifier of the custom Availability Zone (AZ) to import the installation media to.
    /// This member is required.
    public var customAvailabilityZoneId: Swift.String?
    /// The name of the database engine to be used for this instance. The list only includes supported DB engines that require an on-premises customer provided license. Valid Values:
    ///
    /// * sqlserver-ee
    ///
    /// * sqlserver-se
    ///
    /// * sqlserver-ex
    ///
    /// * sqlserver-web
    /// This member is required.
    public var engine: Swift.String?
    /// The path to the installation medium for the specified DB engine. Example: SQLServerISO/en_sql_server_2016_enterprise_x64_dvd_8701793.iso
    /// This member is required.
    public var engineInstallationMediaPath: Swift.String?
    /// The version number of the database engine to use. For a list of valid engine versions, call [DescribeDBEngineVersions]. The following are the database engines and links to information about the major and minor versions. The list only includes DB engines that require an on-premises customer provided license. Microsoft SQL Server See [ Microsoft SQL Server Versions on Amazon RDS](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.VersionSupport) in the Amazon RDS User Guide.
    /// This member is required.
    public var engineVersion: Swift.String?
    /// The path to the installation medium for the operating system associated with the specified DB engine. Example: WindowsISO/en_windows_server_2016_x64_dvd_9327751.iso
    /// This member is required.
    public var oSInstallationMediaPath: Swift.String?

    public init (
        customAvailabilityZoneId: Swift.String? = nil,
        engine: Swift.String? = nil,
        engineInstallationMediaPath: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        oSInstallationMediaPath: Swift.String? = nil
    )
    {
        self.customAvailabilityZoneId = customAvailabilityZoneId
        self.engine = engine
        self.engineInstallationMediaPath = engineInstallationMediaPath
        self.engineVersion = engineVersion
        self.oSInstallationMediaPath = oSInstallationMediaPath
    }
}

struct ImportInstallationMediaInputBody: Swift.Equatable {
    let customAvailabilityZoneId: Swift.String?
    let engine: Swift.String?
    let engineVersion: Swift.String?
    let engineInstallationMediaPath: Swift.String?
    let oSInstallationMediaPath: Swift.String?
}

extension ImportInstallationMediaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customAvailabilityZoneId = "CustomAvailabilityZoneId"
        case engine = "Engine"
        case engineInstallationMediaPath = "EngineInstallationMediaPath"
        case engineVersion = "EngineVersion"
        case oSInstallationMediaPath = "OSInstallationMediaPath"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customAvailabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customAvailabilityZoneId)
        customAvailabilityZoneId = customAvailabilityZoneIdDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let engineInstallationMediaPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineInstallationMediaPath)
        engineInstallationMediaPath = engineInstallationMediaPathDecoded
        let oSInstallationMediaPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oSInstallationMediaPath)
        oSInstallationMediaPath = oSInstallationMediaPathDecoded
    }
}

extension ImportInstallationMediaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ImportInstallationMediaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CustomAvailabilityZoneNotFound" : self = .customAvailabilityZoneNotFoundFault(try CustomAvailabilityZoneNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstallationMediaAlreadyExists" : self = .installationMediaAlreadyExistsFault(try InstallationMediaAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportInstallationMediaOutputError: Swift.Error, Swift.Equatable {
    case customAvailabilityZoneNotFoundFault(CustomAvailabilityZoneNotFoundFault)
    case installationMediaAlreadyExistsFault(InstallationMediaAlreadyExistsFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportInstallationMediaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImportInstallationMediaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customAvailabilityZoneId = output.customAvailabilityZoneId
            self.engine = output.engine
            self.engineInstallationMediaPath = output.engineInstallationMediaPath
            self.engineVersion = output.engineVersion
            self.failureCause = output.failureCause
            self.installationMediaId = output.installationMediaId
            self.oSInstallationMediaPath = output.oSInstallationMediaPath
            self.status = output.status
        } else {
            self.customAvailabilityZoneId = nil
            self.engine = nil
            self.engineInstallationMediaPath = nil
            self.engineVersion = nil
            self.failureCause = nil
            self.installationMediaId = nil
            self.oSInstallationMediaPath = nil
            self.status = nil
        }
    }
}

/// Contains the installation media for a DB engine that requires an on-premises customer provided license, such as Microsoft SQL Server.
public struct ImportInstallationMediaOutputResponse: Swift.Equatable {
    /// The custom Availability Zone (AZ) that contains the installation media.
    public var customAvailabilityZoneId: Swift.String?
    /// The DB engine.
    public var engine: Swift.String?
    /// The path to the installation medium for the DB engine.
    public var engineInstallationMediaPath: Swift.String?
    /// The engine version of the DB engine.
    public var engineVersion: Swift.String?
    /// If an installation media failure occurred, the cause of the failure.
    public var failureCause: RdsClientTypes.InstallationMediaFailureCause?
    /// The installation medium ID.
    public var installationMediaId: Swift.String?
    /// The path to the installation medium for the operating system associated with the DB engine.
    public var oSInstallationMediaPath: Swift.String?
    /// The status of the installation medium.
    public var status: Swift.String?

    public init (
        customAvailabilityZoneId: Swift.String? = nil,
        engine: Swift.String? = nil,
        engineInstallationMediaPath: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        failureCause: RdsClientTypes.InstallationMediaFailureCause? = nil,
        installationMediaId: Swift.String? = nil,
        oSInstallationMediaPath: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.customAvailabilityZoneId = customAvailabilityZoneId
        self.engine = engine
        self.engineInstallationMediaPath = engineInstallationMediaPath
        self.engineVersion = engineVersion
        self.failureCause = failureCause
        self.installationMediaId = installationMediaId
        self.oSInstallationMediaPath = oSInstallationMediaPath
        self.status = status
    }
}

struct ImportInstallationMediaOutputResponseBody: Swift.Equatable {
    let installationMediaId: Swift.String?
    let customAvailabilityZoneId: Swift.String?
    let engine: Swift.String?
    let engineVersion: Swift.String?
    let engineInstallationMediaPath: Swift.String?
    let oSInstallationMediaPath: Swift.String?
    let status: Swift.String?
    let failureCause: RdsClientTypes.InstallationMediaFailureCause?
}

extension ImportInstallationMediaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customAvailabilityZoneId = "CustomAvailabilityZoneId"
        case engine = "Engine"
        case engineInstallationMediaPath = "EngineInstallationMediaPath"
        case engineVersion = "EngineVersion"
        case failureCause = "FailureCause"
        case installationMediaId = "InstallationMediaId"
        case oSInstallationMediaPath = "OSInstallationMediaPath"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ImportInstallationMediaResult"))
        let installationMediaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .installationMediaId)
        installationMediaId = installationMediaIdDecoded
        let customAvailabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customAvailabilityZoneId)
        customAvailabilityZoneId = customAvailabilityZoneIdDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let engineInstallationMediaPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineInstallationMediaPath)
        engineInstallationMediaPath = engineInstallationMediaPathDecoded
        let oSInstallationMediaPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oSInstallationMediaPath)
        oSInstallationMediaPath = oSInstallationMediaPathDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let failureCauseDecoded = try containerValues.decodeIfPresent(RdsClientTypes.InstallationMediaFailureCause.self, forKey: .failureCause)
        failureCause = failureCauseDecoded
    }
}

extension RdsClientTypes.InstallationMedia: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customAvailabilityZoneId = "CustomAvailabilityZoneId"
        case engine = "Engine"
        case engineInstallationMediaPath = "EngineInstallationMediaPath"
        case engineVersion = "EngineVersion"
        case failureCause = "FailureCause"
        case installationMediaId = "InstallationMediaId"
        case oSInstallationMediaPath = "OSInstallationMediaPath"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let customAvailabilityZoneId = customAvailabilityZoneId {
            try container.encode(customAvailabilityZoneId, forKey: ClientRuntime.Key("CustomAvailabilityZoneId"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineInstallationMediaPath = engineInstallationMediaPath {
            try container.encode(engineInstallationMediaPath, forKey: ClientRuntime.Key("EngineInstallationMediaPath"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let failureCause = failureCause {
            try container.encode(failureCause, forKey: ClientRuntime.Key("FailureCause"))
        }
        if let installationMediaId = installationMediaId {
            try container.encode(installationMediaId, forKey: ClientRuntime.Key("InstallationMediaId"))
        }
        if let oSInstallationMediaPath = oSInstallationMediaPath {
            try container.encode(oSInstallationMediaPath, forKey: ClientRuntime.Key("OSInstallationMediaPath"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let installationMediaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .installationMediaId)
        installationMediaId = installationMediaIdDecoded
        let customAvailabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customAvailabilityZoneId)
        customAvailabilityZoneId = customAvailabilityZoneIdDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let engineInstallationMediaPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineInstallationMediaPath)
        engineInstallationMediaPath = engineInstallationMediaPathDecoded
        let oSInstallationMediaPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oSInstallationMediaPath)
        oSInstallationMediaPath = oSInstallationMediaPathDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let failureCauseDecoded = try containerValues.decodeIfPresent(RdsClientTypes.InstallationMediaFailureCause.self, forKey: .failureCause)
        failureCause = failureCauseDecoded
    }
}

extension RdsClientTypes {
    /// Contains the installation media for a DB engine that requires an on-premises customer provided license, such as Microsoft SQL Server.
    public struct InstallationMedia: Swift.Equatable {
        /// The custom Availability Zone (AZ) that contains the installation media.
        public var customAvailabilityZoneId: Swift.String?
        /// The DB engine.
        public var engine: Swift.String?
        /// The path to the installation medium for the DB engine.
        public var engineInstallationMediaPath: Swift.String?
        /// The engine version of the DB engine.
        public var engineVersion: Swift.String?
        /// If an installation media failure occurred, the cause of the failure.
        public var failureCause: RdsClientTypes.InstallationMediaFailureCause?
        /// The installation medium ID.
        public var installationMediaId: Swift.String?
        /// The path to the installation medium for the operating system associated with the DB engine.
        public var oSInstallationMediaPath: Swift.String?
        /// The status of the installation medium.
        public var status: Swift.String?

        public init (
            customAvailabilityZoneId: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineInstallationMediaPath: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            failureCause: RdsClientTypes.InstallationMediaFailureCause? = nil,
            installationMediaId: Swift.String? = nil,
            oSInstallationMediaPath: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.customAvailabilityZoneId = customAvailabilityZoneId
            self.engine = engine
            self.engineInstallationMediaPath = engineInstallationMediaPath
            self.engineVersion = engineVersion
            self.failureCause = failureCause
            self.installationMediaId = installationMediaId
            self.oSInstallationMediaPath = oSInstallationMediaPath
            self.status = status
        }
    }

}

extension InstallationMediaAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InstallationMediaAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified installation medium has already been imported.
public struct InstallationMediaAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InstallationMediaAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InstallationMediaAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.InstallationMediaFailureCause: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let message = message {
            try container.encode(message, forKey: ClientRuntime.Key("Message"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes {
    /// Contains the cause of an installation media failure. Installation media is used for a DB engine that requires an on-premises customer provided license, such as Microsoft SQL Server.
    public struct InstallationMediaFailureCause: Swift.Equatable {
        /// The reason that an installation media import failed.
        public var message: Swift.String?

        public init (
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }

}

extension InstallationMediaNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InstallationMediaNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// InstallationMediaID doesn't refer to an existing installation medium.
public struct InstallationMediaNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InstallationMediaNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InstallationMediaNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InstanceQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InstanceQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would result in the user exceeding the allowed number of DB instances.
public struct InstanceQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InstanceQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InstanceQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientAvailableIPsInSubnetFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InsufficientAvailableIPsInSubnetFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested operation can't be performed because there aren't enough available IP addresses in the proxy's subnets. Add more CIDR blocks to the VPC or remove IP address that aren't required from the subnets.
public struct InsufficientAvailableIPsInSubnetFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientAvailableIPsInSubnetFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientAvailableIPsInSubnetFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientDBClusterCapacityFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InsufficientDBClusterCapacityFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DB cluster doesn't have enough capacity for the current operation.
public struct InsufficientDBClusterCapacityFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientDBClusterCapacityFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientDBClusterCapacityFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientDBInstanceCapacityFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InsufficientDBInstanceCapacityFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified DB instance class isn't available in the specified Availability Zone.
public struct InsufficientDBInstanceCapacityFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientDBInstanceCapacityFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientDBInstanceCapacityFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientStorageClusterCapacityFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InsufficientStorageClusterCapacityFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is insufficient storage available for the current action. You might be able to resolve this error by updating your subnet group to use different Availability Zones that have more storage available.
public struct InsufficientStorageClusterCapacityFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientStorageClusterCapacityFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientStorageClusterCapacityFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCustomDBEngineVersionStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidCustomDBEngineVersionStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can't delete the CEV.
public struct InvalidCustomDBEngineVersionStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCustomDBEngineVersionStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCustomDBEngineVersionStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBClusterCapacityFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBClusterCapacityFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Capacity isn't a valid Aurora Serverless DB cluster capacity. Valid capacity values are 2, 4, 8, 16, 32, 64, 128, and 256.
public struct InvalidDBClusterCapacityFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBClusterCapacityFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDBClusterCapacityFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBClusterEndpointStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBClusterEndpointStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested operation can't be performed on the endpoint while the endpoint is in this state.
public struct InvalidDBClusterEndpointStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBClusterEndpointStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDBClusterEndpointStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBClusterSnapshotStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBClusterSnapshotStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The supplied value isn't a valid DB cluster snapshot state.
public struct InvalidDBClusterSnapshotStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBClusterSnapshotStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDBClusterSnapshotStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBClusterStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBClusterStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested operation can't be performed while the cluster is in this state.
public struct InvalidDBClusterStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBClusterStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDBClusterStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBInstanceAutomatedBackupStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBInstanceAutomatedBackupStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The automated backup is in an invalid state. For example, this automated backup is associated with an active instance.
public struct InvalidDBInstanceAutomatedBackupStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBInstanceAutomatedBackupStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDBInstanceAutomatedBackupStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBInstanceStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBInstanceStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DB instance isn't in a valid state.
public struct InvalidDBInstanceStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBInstanceStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDBInstanceStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBParameterGroupStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBParameterGroupStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DB parameter group is in use or is in an invalid state. If you are attempting to delete the parameter group, you can't delete it when the parameter group is in this state.
public struct InvalidDBParameterGroupStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBParameterGroupStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDBParameterGroupStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBProxyEndpointStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBProxyEndpointStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can't perform this operation while the DB proxy endpoint is in a particular state.
public struct InvalidDBProxyEndpointStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBProxyEndpointStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDBProxyEndpointStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBProxyStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBProxyStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested operation can't be performed while the proxy is in this state.
public struct InvalidDBProxyStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBProxyStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDBProxyStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBSecurityGroupStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBSecurityGroupStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The state of the DB security group doesn't allow deletion.
public struct InvalidDBSecurityGroupStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBSecurityGroupStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDBSecurityGroupStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBSnapshotStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBSnapshotStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The state of the DB snapshot doesn't allow deletion.
public struct InvalidDBSnapshotStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBSnapshotStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDBSnapshotStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBSubnetGroupFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBSubnetGroupFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DBSubnetGroup doesn't belong to the same VPC as that of an existing cross-region read replica of the same source instance.
public struct InvalidDBSubnetGroupFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBSubnetGroupFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDBSubnetGroupFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBSubnetGroupStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBSubnetGroupStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DB subnet group cannot be deleted because it's in use.
public struct InvalidDBSubnetGroupStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBSubnetGroupStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDBSubnetGroupStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBSubnetStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBSubnetStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DB subnet isn't in the available state.
public struct InvalidDBSubnetStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBSubnetStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDBSubnetStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEventSubscriptionStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidEventSubscriptionStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This error can occur if someone else is modifying a subscription. You should retry the action.
public struct InvalidEventSubscriptionStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEventSubscriptionStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidEventSubscriptionStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidExportOnlyFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidExportOnlyFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The export is invalid for exporting to an Amazon S3 bucket.
public struct InvalidExportOnlyFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidExportOnlyFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidExportOnlyFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidExportSourceStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidExportSourceStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The state of the export snapshot is invalid for exporting to an Amazon S3 bucket.
public struct InvalidExportSourceStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidExportSourceStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidExportSourceStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidExportTaskStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidExportTaskStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can't cancel an export task that has completed.
public struct InvalidExportTaskStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidExportTaskStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidExportTaskStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidGlobalClusterStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidGlobalClusterStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The global cluster is in an invalid state and can't perform the requested operation.
public struct InvalidGlobalClusterStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidGlobalClusterStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidGlobalClusterStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOptionGroupStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidOptionGroupStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The option group isn't in the available state.
public struct InvalidOptionGroupStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOptionGroupStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOptionGroupStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRestoreFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidRestoreFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Cannot restore from VPC backup to non-VPC DB instance.
public struct InvalidRestoreFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRestoreFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRestoreFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3BucketFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidS3BucketFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified Amazon S3 bucket name can't be found or Amazon RDS isn't authorized to access the specified Amazon S3 bucket. Verify the SourceS3BucketName and S3IngestionRoleArn values and try again.
public struct InvalidS3BucketFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidS3BucketFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidS3BucketFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnet {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidSubnetBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested subnet is invalid, or multiple subnets were requested that are not all in a common VPC.
public struct InvalidSubnet: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSubnetBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSubnetBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidVPCNetworkStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidVPCNetworkStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DB subnet group doesn't cover all Availability Zones after it's created because of users' change.
public struct InvalidVPCNetworkStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidVPCNetworkStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidVPCNetworkStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSKeyNotAccessibleFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<KMSKeyNotAccessibleFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error occurred accessing an Amazon Web Services KMS key.
public struct KMSKeyNotAccessibleFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSKeyNotAccessibleFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSKeyNotAccessibleFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: ClientRuntime.Key("ResourceName"))
        }
        try container.encode("ListTagsForResource", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ListTagsForResourceInput: Swift.Equatable {
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// The Amazon RDS resource with tags to be listed. This value is an Amazon Resource Name (ARN). For information about creating an ARN, see [ Constructing an ARN for Amazon RDS](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing) in the Amazon RDS User Guide.
    /// This member is required.
    public var resourceName: Swift.String?

    public init (
        filters: [RdsClientTypes.Filter]? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.resourceName = resourceName
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceName: Swift.String?
    let filters: [RdsClientTypes.Filter]?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        if containerValues.contains(.filters) {
            struct KeyVal0{struct Filter{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Filter>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([RdsClientTypes.Filter].self, forKey: .member)
                var filtersBuffer:[RdsClientTypes.Filter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [RdsClientTypes.Filter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

///
public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// List of tags returned by the ListTagsForResource operation.
    public var tagList: [RdsClientTypes.Tag]?

    public init (
        tagList: [RdsClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tagList: [RdsClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListTagsForResourceResult"))
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagListBuffer:[RdsClientTypes.Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
    }
}

extension RdsClientTypes.MinimumEngineVersionPerAllowedValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValue = "AllowedValue"
        case minimumEngineVersion = "MinimumEngineVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allowedValue = allowedValue {
            try container.encode(allowedValue, forKey: ClientRuntime.Key("AllowedValue"))
        }
        if let minimumEngineVersion = minimumEngineVersion {
            try container.encode(minimumEngineVersion, forKey: ClientRuntime.Key("MinimumEngineVersion"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedValue)
        allowedValue = allowedValueDecoded
        let minimumEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minimumEngineVersion)
        minimumEngineVersion = minimumEngineVersionDecoded
    }
}

extension RdsClientTypes {
    /// The minimum DB engine version required for each corresponding allowed value for an option setting.
    public struct MinimumEngineVersionPerAllowedValue: Swift.Equatable {
        /// The allowed value for an option setting.
        public var allowedValue: Swift.String?
        /// The minimum DB engine version required for the allowed value.
        public var minimumEngineVersion: Swift.String?

        public init (
            allowedValue: Swift.String? = nil,
            minimumEngineVersion: Swift.String? = nil
        )
        {
            self.allowedValue = allowedValue
            self.minimumEngineVersion = minimumEngineVersion
        }
    }

}

extension ModifyCertificatesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateIdentifier = certificateIdentifier {
            try container.encode(certificateIdentifier, forKey: ClientRuntime.Key("CertificateIdentifier"))
        }
        if let removeCustomerOverride = removeCustomerOverride {
            try container.encode(removeCustomerOverride, forKey: ClientRuntime.Key("RemoveCustomerOverride"))
        }
        try container.encode("ModifyCertificates", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ModifyCertificatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyCertificatesInput: Swift.Equatable {
    /// The new default certificate identifier to override the current one with. To determine the valid values, use the describe-certificates CLI command or the DescribeCertificates API operation.
    public var certificateIdentifier: Swift.String?
    /// A value that indicates whether to remove the override for the default certificate. If the override is removed, the default certificate is the system default.
    public var removeCustomerOverride: Swift.Bool?

    public init (
        certificateIdentifier: Swift.String? = nil,
        removeCustomerOverride: Swift.Bool? = nil
    )
    {
        self.certificateIdentifier = certificateIdentifier
        self.removeCustomerOverride = removeCustomerOverride
    }
}

struct ModifyCertificatesInputBody: Swift.Equatable {
    let certificateIdentifier: Swift.String?
    let removeCustomerOverride: Swift.Bool?
}

extension ModifyCertificatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateIdentifier = "CertificateIdentifier"
        case removeCustomerOverride = "RemoveCustomerOverride"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateIdentifier)
        certificateIdentifier = certificateIdentifierDecoded
        let removeCustomerOverrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeCustomerOverride)
        removeCustomerOverride = removeCustomerOverrideDecoded
    }
}

extension ModifyCertificatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyCertificatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CertificateNotFound" : self = .certificateNotFoundFault(try CertificateNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyCertificatesOutputError: Swift.Error, Swift.Equatable {
    case certificateNotFoundFault(CertificateNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyCertificatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
        } else {
            self.certificate = nil
        }
    }
}

public struct ModifyCertificatesOutputResponse: Swift.Equatable {
    /// A CA certificate for an Amazon Web Services account.
    public var certificate: RdsClientTypes.Certificate?

    public init (
        certificate: RdsClientTypes.Certificate? = nil
    )
    {
        self.certificate = certificate
    }
}

struct ModifyCertificatesOutputResponseBody: Swift.Equatable {
    let certificate: RdsClientTypes.Certificate?
}

extension ModifyCertificatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyCertificatesResult"))
        let certificateDecoded = try containerValues.decodeIfPresent(RdsClientTypes.Certificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

extension ModifyCurrentDBClusterCapacityInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let capacity = capacity {
            try container.encode(capacity, forKey: ClientRuntime.Key("Capacity"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let secondsBeforeTimeout = secondsBeforeTimeout {
            try container.encode(secondsBeforeTimeout, forKey: ClientRuntime.Key("SecondsBeforeTimeout"))
        }
        if let timeoutAction = timeoutAction {
            try container.encode(timeoutAction, forKey: ClientRuntime.Key("TimeoutAction"))
        }
        try container.encode("ModifyCurrentDBClusterCapacity", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ModifyCurrentDBClusterCapacityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyCurrentDBClusterCapacityInput: Swift.Equatable {
    /// The DB cluster capacity. When you change the capacity of a paused Aurora Serverless DB cluster, it automatically resumes. Constraints:
    ///
    /// * For Aurora MySQL, valid capacity values are 1, 2, 4, 8, 16, 32, 64, 128, and 256.
    ///
    /// * For Aurora PostgreSQL, valid capacity values are 2, 4, 8, 16, 32, 64, 192, and 384.
    public var capacity: Swift.Int?
    /// The DB cluster identifier for the cluster being modified. This parameter isn't case-sensitive. Constraints:
    ///
    /// * Must match the identifier of an existing DB cluster.
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// The amount of time, in seconds, that Aurora Serverless tries to find a scaling point to perform seamless scaling before enforcing the timeout action. The default is 300. Specify a value between 10 and 600 seconds.
    public var secondsBeforeTimeout: Swift.Int?
    /// The action to take when the timeout is reached, either ForceApplyCapacityChange or RollbackCapacityChange. ForceApplyCapacityChange, the default, sets the capacity to the specified value as soon as possible. RollbackCapacityChange ignores the capacity change if a scaling point isn't found in the timeout period.
    public var timeoutAction: Swift.String?

    public init (
        capacity: Swift.Int? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        secondsBeforeTimeout: Swift.Int? = nil,
        timeoutAction: Swift.String? = nil
    )
    {
        self.capacity = capacity
        self.dBClusterIdentifier = dBClusterIdentifier
        self.secondsBeforeTimeout = secondsBeforeTimeout
        self.timeoutAction = timeoutAction
    }
}

struct ModifyCurrentDBClusterCapacityInputBody: Swift.Equatable {
    let dBClusterIdentifier: Swift.String?
    let capacity: Swift.Int?
    let secondsBeforeTimeout: Swift.Int?
    let timeoutAction: Swift.String?
}

extension ModifyCurrentDBClusterCapacityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacity = "Capacity"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case secondsBeforeTimeout = "SecondsBeforeTimeout"
        case timeoutAction = "TimeoutAction"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let capacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .capacity)
        capacity = capacityDecoded
        let secondsBeforeTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .secondsBeforeTimeout)
        secondsBeforeTimeout = secondsBeforeTimeoutDecoded
        let timeoutActionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeoutAction)
        timeoutAction = timeoutActionDecoded
    }
}

extension ModifyCurrentDBClusterCapacityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyCurrentDBClusterCapacityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterCapacityFault" : self = .invalidDBClusterCapacityFault(try InvalidDBClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyCurrentDBClusterCapacityOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterCapacityFault(InvalidDBClusterCapacityFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyCurrentDBClusterCapacityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyCurrentDBClusterCapacityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.currentCapacity = output.currentCapacity
            self.dBClusterIdentifier = output.dBClusterIdentifier
            self.pendingCapacity = output.pendingCapacity
            self.secondsBeforeTimeout = output.secondsBeforeTimeout
            self.timeoutAction = output.timeoutAction
        } else {
            self.currentCapacity = nil
            self.dBClusterIdentifier = nil
            self.pendingCapacity = nil
            self.secondsBeforeTimeout = nil
            self.timeoutAction = nil
        }
    }
}

public struct ModifyCurrentDBClusterCapacityOutputResponse: Swift.Equatable {
    /// The current capacity of the DB cluster.
    public var currentCapacity: Swift.Int?
    /// A user-supplied DB cluster identifier. This identifier is the unique key that identifies a DB cluster.
    public var dBClusterIdentifier: Swift.String?
    /// A value that specifies the capacity that the DB cluster scales to next.
    public var pendingCapacity: Swift.Int?
    /// The number of seconds before a call to ModifyCurrentDBClusterCapacity times out.
    public var secondsBeforeTimeout: Swift.Int?
    /// The timeout action of a call to ModifyCurrentDBClusterCapacity, either ForceApplyCapacityChange or RollbackCapacityChange.
    public var timeoutAction: Swift.String?

    public init (
        currentCapacity: Swift.Int? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        pendingCapacity: Swift.Int? = nil,
        secondsBeforeTimeout: Swift.Int? = nil,
        timeoutAction: Swift.String? = nil
    )
    {
        self.currentCapacity = currentCapacity
        self.dBClusterIdentifier = dBClusterIdentifier
        self.pendingCapacity = pendingCapacity
        self.secondsBeforeTimeout = secondsBeforeTimeout
        self.timeoutAction = timeoutAction
    }
}

struct ModifyCurrentDBClusterCapacityOutputResponseBody: Swift.Equatable {
    let dBClusterIdentifier: Swift.String?
    let pendingCapacity: Swift.Int?
    let currentCapacity: Swift.Int?
    let secondsBeforeTimeout: Swift.Int?
    let timeoutAction: Swift.String?
}

extension ModifyCurrentDBClusterCapacityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentCapacity = "CurrentCapacity"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case pendingCapacity = "PendingCapacity"
        case secondsBeforeTimeout = "SecondsBeforeTimeout"
        case timeoutAction = "TimeoutAction"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyCurrentDBClusterCapacityResult"))
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let pendingCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pendingCapacity)
        pendingCapacity = pendingCapacityDecoded
        let currentCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentCapacity)
        currentCapacity = currentCapacityDecoded
        let secondsBeforeTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .secondsBeforeTimeout)
        secondsBeforeTimeout = secondsBeforeTimeoutDecoded
        let timeoutActionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeoutAction)
        timeoutAction = timeoutActionDecoded
    }
}

extension ModifyCustomDBEngineVersionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        try container.encode("ModifyCustomDBEngineVersion", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ModifyCustomDBEngineVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyCustomDBEngineVersionInput: Swift.Equatable {
    /// An optional description of your CEV.
    public var description: Swift.String?
    /// The DB engine. The only supported value is custom-oracle-ee.
    /// This member is required.
    public var engine: Swift.String?
    /// The custom engine version (CEV) that you want to modify. This option is required for RDS Custom, but optional for Amazon RDS. The combination of Engine and EngineVersion is unique per customer per Amazon Web Services Region.
    /// This member is required.
    public var engineVersion: Swift.String?
    /// The availability status to be assigned to the CEV. Valid values are as follows: available You can use this CEV to create a new RDS Custom DB instance. inactive You can create a new RDS Custom instance by restoring a DB snapshot with this CEV. You can't patch or create new instances with this CEV. You can change any status to any status. A typical reason to change status is to prevent the accidental use of a CEV, or to make a deprecated CEV eligible for use again. For example, you might change the status of your CEV from available to inactive, and from inactive back to available. To change the availability status of the CEV, it must not currently be in use by an RDS Custom instance, snapshot, or automated backup.
    public var status: RdsClientTypes.CustomEngineVersionStatus?

    public init (
        description: Swift.String? = nil,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        status: RdsClientTypes.CustomEngineVersionStatus? = nil
    )
    {
        self.description = description
        self.engine = engine
        self.engineVersion = engineVersion
        self.status = status
    }
}

struct ModifyCustomDBEngineVersionInputBody: Swift.Equatable {
    let engine: Swift.String?
    let engineVersion: Swift.String?
    let description: Swift.String?
    let status: RdsClientTypes.CustomEngineVersionStatus?
}

extension ModifyCustomDBEngineVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RdsClientTypes.CustomEngineVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ModifyCustomDBEngineVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyCustomDBEngineVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CustomDBEngineVersionNotFoundFault" : self = .customDBEngineVersionNotFoundFault(try CustomDBEngineVersionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCustomDBEngineVersionStateFault" : self = .invalidCustomDBEngineVersionStateFault(try InvalidCustomDBEngineVersionStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyCustomDBEngineVersionOutputError: Swift.Error, Swift.Equatable {
    case customDBEngineVersionNotFoundFault(CustomDBEngineVersionNotFoundFault)
    case invalidCustomDBEngineVersionStateFault(InvalidCustomDBEngineVersionStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyCustomDBEngineVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyCustomDBEngineVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.dBEngineDescription = output.dBEngineDescription
            self.dBEngineVersionArn = output.dBEngineVersionArn
            self.dBEngineVersionDescription = output.dBEngineVersionDescription
            self.dBParameterGroupFamily = output.dBParameterGroupFamily
            self.databaseInstallationFilesS3BucketName = output.databaseInstallationFilesS3BucketName
            self.databaseInstallationFilesS3Prefix = output.databaseInstallationFilesS3Prefix
            self.defaultCharacterSet = output.defaultCharacterSet
            self.engine = output.engine
            self.engineVersion = output.engineVersion
            self.exportableLogTypes = output.exportableLogTypes
            self.kMSKeyId = output.kMSKeyId
            self.majorEngineVersion = output.majorEngineVersion
            self.status = output.status
            self.supportedCharacterSets = output.supportedCharacterSets
            self.supportedEngineModes = output.supportedEngineModes
            self.supportedFeatureNames = output.supportedFeatureNames
            self.supportedNcharCharacterSets = output.supportedNcharCharacterSets
            self.supportedTimezones = output.supportedTimezones
            self.supportsGlobalDatabases = output.supportsGlobalDatabases
            self.supportsLogExportsToCloudwatchLogs = output.supportsLogExportsToCloudwatchLogs
            self.supportsParallelQuery = output.supportsParallelQuery
            self.supportsReadReplica = output.supportsReadReplica
            self.tagList = output.tagList
            self.validUpgradeTarget = output.validUpgradeTarget
        } else {
            self.createTime = nil
            self.dBEngineDescription = nil
            self.dBEngineVersionArn = nil
            self.dBEngineVersionDescription = nil
            self.dBParameterGroupFamily = nil
            self.databaseInstallationFilesS3BucketName = nil
            self.databaseInstallationFilesS3Prefix = nil
            self.defaultCharacterSet = nil
            self.engine = nil
            self.engineVersion = nil
            self.exportableLogTypes = nil
            self.kMSKeyId = nil
            self.majorEngineVersion = nil
            self.status = nil
            self.supportedCharacterSets = nil
            self.supportedEngineModes = nil
            self.supportedFeatureNames = nil
            self.supportedNcharCharacterSets = nil
            self.supportedTimezones = nil
            self.supportsGlobalDatabases = false
            self.supportsLogExportsToCloudwatchLogs = false
            self.supportsParallelQuery = false
            self.supportsReadReplica = false
            self.tagList = nil
            self.validUpgradeTarget = nil
        }
    }
}

/// This data type is used as a response element in the action DescribeDBEngineVersions.
public struct ModifyCustomDBEngineVersionOutputResponse: Swift.Equatable {
    /// The creation time of the DB engine version.
    public var createTime: ClientRuntime.Date?
    /// The description of the database engine.
    public var dBEngineDescription: Swift.String?
    /// The ARN of the custom engine version.
    public var dBEngineVersionArn: Swift.String?
    /// The description of the database engine version.
    public var dBEngineVersionDescription: Swift.String?
    /// The name of the DB parameter group family for the database engine.
    public var dBParameterGroupFamily: Swift.String?
    /// The name of the Amazon S3 bucket that contains your database installation files.
    public var databaseInstallationFilesS3BucketName: Swift.String?
    /// The Amazon S3 directory that contains the database installation files. If not specified, then no prefix is assumed.
    public var databaseInstallationFilesS3Prefix: Swift.String?
    /// The default character set for new instances of this engine version, if the CharacterSetName parameter of the CreateDBInstance API isn't specified.
    public var defaultCharacterSet: RdsClientTypes.CharacterSet?
    /// The name of the database engine.
    public var engine: Swift.String?
    /// The version number of the database engine.
    public var engineVersion: Swift.String?
    /// The types of logs that the database engine has available for export to CloudWatch Logs.
    public var exportableLogTypes: [Swift.String]?
    /// The Amazon Web Services KMS key identifier for an encrypted CEV. This parameter is required for RDS Custom, but optional for Amazon RDS.
    public var kMSKeyId: Swift.String?
    /// The major engine version of the CEV.
    public var majorEngineVersion: Swift.String?
    /// The status of the DB engine version, either available or deprecated.
    public var status: Swift.String?
    /// A list of the character sets supported by this engine for the CharacterSetName parameter of the CreateDBInstance operation.
    public var supportedCharacterSets: [RdsClientTypes.CharacterSet]?
    /// A list of the supported DB engine modes.
    public var supportedEngineModes: [Swift.String]?
    /// A list of features supported by the DB engine. The supported features vary by DB engine and DB engine version. To determine the supported features for a specific DB engine and DB engine version using the CLI, use the following command: aws rds describe-db-engine-versions --engine --engine-version  For example, to determine the supported features for RDS for PostgreSQL version 13.3 using the CLI, use the following command: aws rds describe-db-engine-versions --engine postgres --engine-version 13.3 The supported features are listed under SupportedFeatureNames in the output.
    public var supportedFeatureNames: [Swift.String]?
    /// A list of the character sets supported by the Oracle DB engine for the NcharCharacterSetName parameter of the CreateDBInstance operation.
    public var supportedNcharCharacterSets: [RdsClientTypes.CharacterSet]?
    /// A list of the time zones supported by this engine for the Timezone parameter of the CreateDBInstance action.
    public var supportedTimezones: [RdsClientTypes.Timezone]?
    /// A value that indicates whether you can use Aurora global databases with a specific DB engine version.
    public var supportsGlobalDatabases: Swift.Bool
    /// A value that indicates whether the engine version supports exporting the log types specified by ExportableLogTypes to CloudWatch Logs.
    public var supportsLogExportsToCloudwatchLogs: Swift.Bool
    /// A value that indicates whether you can use Aurora parallel query with a specific DB engine version.
    public var supportsParallelQuery: Swift.Bool
    /// Indicates whether the database engine version supports read replicas.
    public var supportsReadReplica: Swift.Bool
    /// A list of tags. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
    public var tagList: [RdsClientTypes.Tag]?
    /// A list of engine versions that this database engine version can be upgraded to.
    public var validUpgradeTarget: [RdsClientTypes.UpgradeTarget]?

    public init (
        createTime: ClientRuntime.Date? = nil,
        dBEngineDescription: Swift.String? = nil,
        dBEngineVersionArn: Swift.String? = nil,
        dBEngineVersionDescription: Swift.String? = nil,
        dBParameterGroupFamily: Swift.String? = nil,
        databaseInstallationFilesS3BucketName: Swift.String? = nil,
        databaseInstallationFilesS3Prefix: Swift.String? = nil,
        defaultCharacterSet: RdsClientTypes.CharacterSet? = nil,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        exportableLogTypes: [Swift.String]? = nil,
        kMSKeyId: Swift.String? = nil,
        majorEngineVersion: Swift.String? = nil,
        status: Swift.String? = nil,
        supportedCharacterSets: [RdsClientTypes.CharacterSet]? = nil,
        supportedEngineModes: [Swift.String]? = nil,
        supportedFeatureNames: [Swift.String]? = nil,
        supportedNcharCharacterSets: [RdsClientTypes.CharacterSet]? = nil,
        supportedTimezones: [RdsClientTypes.Timezone]? = nil,
        supportsGlobalDatabases: Swift.Bool = false,
        supportsLogExportsToCloudwatchLogs: Swift.Bool = false,
        supportsParallelQuery: Swift.Bool = false,
        supportsReadReplica: Swift.Bool = false,
        tagList: [RdsClientTypes.Tag]? = nil,
        validUpgradeTarget: [RdsClientTypes.UpgradeTarget]? = nil
    )
    {
        self.createTime = createTime
        self.dBEngineDescription = dBEngineDescription
        self.dBEngineVersionArn = dBEngineVersionArn
        self.dBEngineVersionDescription = dBEngineVersionDescription
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.databaseInstallationFilesS3BucketName = databaseInstallationFilesS3BucketName
        self.databaseInstallationFilesS3Prefix = databaseInstallationFilesS3Prefix
        self.defaultCharacterSet = defaultCharacterSet
        self.engine = engine
        self.engineVersion = engineVersion
        self.exportableLogTypes = exportableLogTypes
        self.kMSKeyId = kMSKeyId
        self.majorEngineVersion = majorEngineVersion
        self.status = status
        self.supportedCharacterSets = supportedCharacterSets
        self.supportedEngineModes = supportedEngineModes
        self.supportedFeatureNames = supportedFeatureNames
        self.supportedNcharCharacterSets = supportedNcharCharacterSets
        self.supportedTimezones = supportedTimezones
        self.supportsGlobalDatabases = supportsGlobalDatabases
        self.supportsLogExportsToCloudwatchLogs = supportsLogExportsToCloudwatchLogs
        self.supportsParallelQuery = supportsParallelQuery
        self.supportsReadReplica = supportsReadReplica
        self.tagList = tagList
        self.validUpgradeTarget = validUpgradeTarget
    }
}

struct ModifyCustomDBEngineVersionOutputResponseBody: Swift.Equatable {
    let engine: Swift.String?
    let engineVersion: Swift.String?
    let dBParameterGroupFamily: Swift.String?
    let dBEngineDescription: Swift.String?
    let dBEngineVersionDescription: Swift.String?
    let defaultCharacterSet: RdsClientTypes.CharacterSet?
    let supportedCharacterSets: [RdsClientTypes.CharacterSet]?
    let supportedNcharCharacterSets: [RdsClientTypes.CharacterSet]?
    let validUpgradeTarget: [RdsClientTypes.UpgradeTarget]?
    let supportedTimezones: [RdsClientTypes.Timezone]?
    let exportableLogTypes: [Swift.String]?
    let supportsLogExportsToCloudwatchLogs: Swift.Bool
    let supportsReadReplica: Swift.Bool
    let supportedEngineModes: [Swift.String]?
    let supportedFeatureNames: [Swift.String]?
    let status: Swift.String?
    let supportsParallelQuery: Swift.Bool
    let supportsGlobalDatabases: Swift.Bool
    let majorEngineVersion: Swift.String?
    let databaseInstallationFilesS3BucketName: Swift.String?
    let databaseInstallationFilesS3Prefix: Swift.String?
    let dBEngineVersionArn: Swift.String?
    let kMSKeyId: Swift.String?
    let createTime: ClientRuntime.Date?
    let tagList: [RdsClientTypes.Tag]?
}

extension ModifyCustomDBEngineVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case dBEngineDescription = "DBEngineDescription"
        case dBEngineVersionArn = "DBEngineVersionArn"
        case dBEngineVersionDescription = "DBEngineVersionDescription"
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case databaseInstallationFilesS3BucketName = "DatabaseInstallationFilesS3BucketName"
        case databaseInstallationFilesS3Prefix = "DatabaseInstallationFilesS3Prefix"
        case defaultCharacterSet = "DefaultCharacterSet"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case exportableLogTypes = "ExportableLogTypes"
        case kMSKeyId = "KMSKeyId"
        case majorEngineVersion = "MajorEngineVersion"
        case status = "Status"
        case supportedCharacterSets = "SupportedCharacterSets"
        case supportedEngineModes = "SupportedEngineModes"
        case supportedFeatureNames = "SupportedFeatureNames"
        case supportedNcharCharacterSets = "SupportedNcharCharacterSets"
        case supportedTimezones = "SupportedTimezones"
        case supportsGlobalDatabases = "SupportsGlobalDatabases"
        case supportsLogExportsToCloudwatchLogs = "SupportsLogExportsToCloudwatchLogs"
        case supportsParallelQuery = "SupportsParallelQuery"
        case supportsReadReplica = "SupportsReadReplica"
        case tagList = "TagList"
        case validUpgradeTarget = "ValidUpgradeTarget"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyCustomDBEngineVersionResult"))
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let dBEngineDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBEngineDescription)
        dBEngineDescription = dBEngineDescriptionDecoded
        let dBEngineVersionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBEngineVersionDescription)
        dBEngineVersionDescription = dBEngineVersionDescriptionDecoded
        let defaultCharacterSetDecoded = try containerValues.decodeIfPresent(RdsClientTypes.CharacterSet.self, forKey: .defaultCharacterSet)
        defaultCharacterSet = defaultCharacterSetDecoded
        if containerValues.contains(.supportedCharacterSets) {
            struct KeyVal0{struct CharacterSet{}}
            let supportedCharacterSetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CharacterSet>.CodingKeys.self, forKey: .supportedCharacterSets)
            if let supportedCharacterSetsWrappedContainer = supportedCharacterSetsWrappedContainer {
                let supportedCharacterSetsContainer = try supportedCharacterSetsWrappedContainer.decodeIfPresent([RdsClientTypes.CharacterSet].self, forKey: .member)
                var supportedCharacterSetsBuffer:[RdsClientTypes.CharacterSet]? = nil
                if let supportedCharacterSetsContainer = supportedCharacterSetsContainer {
                    supportedCharacterSetsBuffer = [RdsClientTypes.CharacterSet]()
                    for structureContainer0 in supportedCharacterSetsContainer {
                        supportedCharacterSetsBuffer?.append(structureContainer0)
                    }
                }
                supportedCharacterSets = supportedCharacterSetsBuffer
            } else {
                supportedCharacterSets = []
            }
        } else {
            supportedCharacterSets = nil
        }
        if containerValues.contains(.supportedNcharCharacterSets) {
            struct KeyVal0{struct CharacterSet{}}
            let supportedNcharCharacterSetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CharacterSet>.CodingKeys.self, forKey: .supportedNcharCharacterSets)
            if let supportedNcharCharacterSetsWrappedContainer = supportedNcharCharacterSetsWrappedContainer {
                let supportedNcharCharacterSetsContainer = try supportedNcharCharacterSetsWrappedContainer.decodeIfPresent([RdsClientTypes.CharacterSet].self, forKey: .member)
                var supportedNcharCharacterSetsBuffer:[RdsClientTypes.CharacterSet]? = nil
                if let supportedNcharCharacterSetsContainer = supportedNcharCharacterSetsContainer {
                    supportedNcharCharacterSetsBuffer = [RdsClientTypes.CharacterSet]()
                    for structureContainer0 in supportedNcharCharacterSetsContainer {
                        supportedNcharCharacterSetsBuffer?.append(structureContainer0)
                    }
                }
                supportedNcharCharacterSets = supportedNcharCharacterSetsBuffer
            } else {
                supportedNcharCharacterSets = []
            }
        } else {
            supportedNcharCharacterSets = nil
        }
        if containerValues.contains(.validUpgradeTarget) {
            struct KeyVal0{struct UpgradeTarget{}}
            let validUpgradeTargetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.UpgradeTarget>.CodingKeys.self, forKey: .validUpgradeTarget)
            if let validUpgradeTargetWrappedContainer = validUpgradeTargetWrappedContainer {
                let validUpgradeTargetContainer = try validUpgradeTargetWrappedContainer.decodeIfPresent([RdsClientTypes.UpgradeTarget].self, forKey: .member)
                var validUpgradeTargetBuffer:[RdsClientTypes.UpgradeTarget]? = nil
                if let validUpgradeTargetContainer = validUpgradeTargetContainer {
                    validUpgradeTargetBuffer = [RdsClientTypes.UpgradeTarget]()
                    for structureContainer0 in validUpgradeTargetContainer {
                        validUpgradeTargetBuffer?.append(structureContainer0)
                    }
                }
                validUpgradeTarget = validUpgradeTargetBuffer
            } else {
                validUpgradeTarget = []
            }
        } else {
            validUpgradeTarget = nil
        }
        if containerValues.contains(.supportedTimezones) {
            struct KeyVal0{struct Timezone{}}
            let supportedTimezonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Timezone>.CodingKeys.self, forKey: .supportedTimezones)
            if let supportedTimezonesWrappedContainer = supportedTimezonesWrappedContainer {
                let supportedTimezonesContainer = try supportedTimezonesWrappedContainer.decodeIfPresent([RdsClientTypes.Timezone].self, forKey: .member)
                var supportedTimezonesBuffer:[RdsClientTypes.Timezone]? = nil
                if let supportedTimezonesContainer = supportedTimezonesContainer {
                    supportedTimezonesBuffer = [RdsClientTypes.Timezone]()
                    for structureContainer0 in supportedTimezonesContainer {
                        supportedTimezonesBuffer?.append(structureContainer0)
                    }
                }
                supportedTimezones = supportedTimezonesBuffer
            } else {
                supportedTimezones = []
            }
        } else {
            supportedTimezones = nil
        }
        if containerValues.contains(.exportableLogTypes) {
            struct KeyVal0{struct member{}}
            let exportableLogTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .exportableLogTypes)
            if let exportableLogTypesWrappedContainer = exportableLogTypesWrappedContainer {
                let exportableLogTypesContainer = try exportableLogTypesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var exportableLogTypesBuffer:[Swift.String]? = nil
                if let exportableLogTypesContainer = exportableLogTypesContainer {
                    exportableLogTypesBuffer = [Swift.String]()
                    for stringContainer0 in exportableLogTypesContainer {
                        exportableLogTypesBuffer?.append(stringContainer0)
                    }
                }
                exportableLogTypes = exportableLogTypesBuffer
            } else {
                exportableLogTypes = []
            }
        } else {
            exportableLogTypes = nil
        }
        let supportsLogExportsToCloudwatchLogsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsLogExportsToCloudwatchLogs)
        supportsLogExportsToCloudwatchLogs = supportsLogExportsToCloudwatchLogsDecoded
        let supportsReadReplicaDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsReadReplica)
        supportsReadReplica = supportsReadReplicaDecoded
        if containerValues.contains(.supportedEngineModes) {
            struct KeyVal0{struct member{}}
            let supportedEngineModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedEngineModes)
            if let supportedEngineModesWrappedContainer = supportedEngineModesWrappedContainer {
                let supportedEngineModesContainer = try supportedEngineModesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedEngineModesBuffer:[Swift.String]? = nil
                if let supportedEngineModesContainer = supportedEngineModesContainer {
                    supportedEngineModesBuffer = [Swift.String]()
                    for stringContainer0 in supportedEngineModesContainer {
                        supportedEngineModesBuffer?.append(stringContainer0)
                    }
                }
                supportedEngineModes = supportedEngineModesBuffer
            } else {
                supportedEngineModes = []
            }
        } else {
            supportedEngineModes = nil
        }
        if containerValues.contains(.supportedFeatureNames) {
            struct KeyVal0{struct member{}}
            let supportedFeatureNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedFeatureNames)
            if let supportedFeatureNamesWrappedContainer = supportedFeatureNamesWrappedContainer {
                let supportedFeatureNamesContainer = try supportedFeatureNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedFeatureNamesBuffer:[Swift.String]? = nil
                if let supportedFeatureNamesContainer = supportedFeatureNamesContainer {
                    supportedFeatureNamesBuffer = [Swift.String]()
                    for stringContainer0 in supportedFeatureNamesContainer {
                        supportedFeatureNamesBuffer?.append(stringContainer0)
                    }
                }
                supportedFeatureNames = supportedFeatureNamesBuffer
            } else {
                supportedFeatureNames = []
            }
        } else {
            supportedFeatureNames = nil
        }
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let supportsParallelQueryDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsParallelQuery)
        supportsParallelQuery = supportsParallelQueryDecoded
        let supportsGlobalDatabasesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsGlobalDatabases)
        supportsGlobalDatabases = supportsGlobalDatabasesDecoded
        let majorEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorEngineVersion)
        majorEngineVersion = majorEngineVersionDecoded
        let databaseInstallationFilesS3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseInstallationFilesS3BucketName)
        databaseInstallationFilesS3BucketName = databaseInstallationFilesS3BucketNameDecoded
        let databaseInstallationFilesS3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseInstallationFilesS3Prefix)
        databaseInstallationFilesS3Prefix = databaseInstallationFilesS3PrefixDecoded
        let dBEngineVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBEngineVersionArn)
        dBEngineVersionArn = dBEngineVersionArnDecoded
        let kMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyId)
        kMSKeyId = kMSKeyIdDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        var createTimeBuffer:ClientRuntime.Date? = nil
        if let createTimeDecoded = createTimeDecoded {
            createTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createTimeDecoded, format: .dateTime)
        }
        createTime = createTimeBuffer
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagListBuffer:[RdsClientTypes.Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
    }
}

extension ModifyDBClusterEndpointInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: ClientRuntime.Key("DBClusterEndpointIdentifier"))
        }
        if let endpointType = endpointType {
            try container.encode(endpointType, forKey: ClientRuntime.Key("EndpointType"))
        }
        if let excludedMembers = excludedMembers {
            var excludedMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExcludedMembers"))
            for (index0, string0) in excludedMembers.enumerated() {
                try excludedMembersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let staticMembers = staticMembers {
            var staticMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("StaticMembers"))
            for (index0, string0) in staticMembers.enumerated() {
                try staticMembersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBClusterEndpoint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ModifyDBClusterEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyDBClusterEndpointInput: Swift.Equatable {
    /// The identifier of the endpoint to modify. This parameter is stored as a lowercase string.
    /// This member is required.
    public var dBClusterEndpointIdentifier: Swift.String?
    /// The type of the endpoint. One of: READER, WRITER, ANY.
    public var endpointType: Swift.String?
    /// List of DB instance identifiers that aren't part of the custom endpoint group. All other eligible instances are reachable through the custom endpoint. Only relevant if the list of static members is empty.
    public var excludedMembers: [Swift.String]?
    /// List of DB instance identifiers that are part of the custom endpoint group.
    public var staticMembers: [Swift.String]?

    public init (
        dBClusterEndpointIdentifier: Swift.String? = nil,
        endpointType: Swift.String? = nil,
        excludedMembers: [Swift.String]? = nil,
        staticMembers: [Swift.String]? = nil
    )
    {
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
    }
}

struct ModifyDBClusterEndpointInputBody: Swift.Equatable {
    let dBClusterEndpointIdentifier: Swift.String?
    let endpointType: Swift.String?
    let staticMembers: [Swift.String]?
    let excludedMembers: [Swift.String]?
}

extension ModifyDBClusterEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        case endpointType = "EndpointType"
        case excludedMembers = "ExcludedMembers"
        case staticMembers = "StaticMembers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        if containerValues.contains(.staticMembers) {
            struct KeyVal0{struct member{}}
            let staticMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .staticMembers)
            if let staticMembersWrappedContainer = staticMembersWrappedContainer {
                let staticMembersContainer = try staticMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var staticMembersBuffer:[Swift.String]? = nil
                if let staticMembersContainer = staticMembersContainer {
                    staticMembersBuffer = [Swift.String]()
                    for stringContainer0 in staticMembersContainer {
                        staticMembersBuffer?.append(stringContainer0)
                    }
                }
                staticMembers = staticMembersBuffer
            } else {
                staticMembers = []
            }
        } else {
            staticMembers = nil
        }
        if containerValues.contains(.excludedMembers) {
            struct KeyVal0{struct member{}}
            let excludedMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .excludedMembers)
            if let excludedMembersWrappedContainer = excludedMembersWrappedContainer {
                let excludedMembersContainer = try excludedMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var excludedMembersBuffer:[Swift.String]? = nil
                if let excludedMembersContainer = excludedMembersContainer {
                    excludedMembersBuffer = [Swift.String]()
                    for stringContainer0 in excludedMembersContainer {
                        excludedMembersBuffer?.append(stringContainer0)
                    }
                }
                excludedMembers = excludedMembersBuffer
            } else {
                excludedMembers = []
            }
        } else {
            excludedMembers = nil
        }
    }
}

extension ModifyDBClusterEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBClusterEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterEndpointNotFoundFault" : self = .dBClusterEndpointNotFoundFault(try DBClusterEndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterEndpointStateFault" : self = .invalidDBClusterEndpointStateFault(try InvalidDBClusterEndpointStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBClusterEndpointOutputError: Swift.Error, Swift.Equatable {
    case dBClusterEndpointNotFoundFault(DBClusterEndpointNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBClusterEndpointStateFault(InvalidDBClusterEndpointStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBClusterEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBClusterEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customEndpointType = output.customEndpointType
            self.dBClusterEndpointArn = output.dBClusterEndpointArn
            self.dBClusterEndpointIdentifier = output.dBClusterEndpointIdentifier
            self.dBClusterEndpointResourceIdentifier = output.dBClusterEndpointResourceIdentifier
            self.dBClusterIdentifier = output.dBClusterIdentifier
            self.endpoint = output.endpoint
            self.endpointType = output.endpointType
            self.excludedMembers = output.excludedMembers
            self.staticMembers = output.staticMembers
            self.status = output.status
        } else {
            self.customEndpointType = nil
            self.dBClusterEndpointArn = nil
            self.dBClusterEndpointIdentifier = nil
            self.dBClusterEndpointResourceIdentifier = nil
            self.dBClusterIdentifier = nil
            self.endpoint = nil
            self.endpointType = nil
            self.excludedMembers = nil
            self.staticMembers = nil
            self.status = nil
        }
    }
}

/// This data type represents the information you need to connect to an Amazon Aurora DB cluster. This data type is used as a response element in the following actions:
///
/// * CreateDBClusterEndpoint
///
/// * DescribeDBClusterEndpoints
///
/// * ModifyDBClusterEndpoint
///
/// * DeleteDBClusterEndpoint
///
///
/// For the data structure that represents Amazon RDS DB instance endpoints, see Endpoint.
public struct ModifyDBClusterEndpointOutputResponse: Swift.Equatable {
    /// The type associated with a custom endpoint. One of: READER, WRITER, ANY.
    public var customEndpointType: Swift.String?
    /// The Amazon Resource Name (ARN) for the endpoint.
    public var dBClusterEndpointArn: Swift.String?
    /// The identifier associated with the endpoint. This parameter is stored as a lowercase string.
    public var dBClusterEndpointIdentifier: Swift.String?
    /// A unique system-generated identifier for an endpoint. It remains the same for the whole life of the endpoint.
    public var dBClusterEndpointResourceIdentifier: Swift.String?
    /// The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is stored as a lowercase string.
    public var dBClusterIdentifier: Swift.String?
    /// The DNS address of the endpoint.
    public var endpoint: Swift.String?
    /// The type of the endpoint. One of: READER, WRITER, CUSTOM.
    public var endpointType: Swift.String?
    /// List of DB instance identifiers that aren't part of the custom endpoint group. All other eligible instances are reachable through the custom endpoint. Only relevant if the list of static members is empty.
    public var excludedMembers: [Swift.String]?
    /// List of DB instance identifiers that are part of the custom endpoint group.
    public var staticMembers: [Swift.String]?
    /// The current status of the endpoint. One of: creating, available, deleting, inactive, modifying. The inactive state applies to an endpoint that can't be used for a certain kind of cluster, such as a writer endpoint for a read-only secondary cluster in a global database.
    public var status: Swift.String?

    public init (
        customEndpointType: Swift.String? = nil,
        dBClusterEndpointArn: Swift.String? = nil,
        dBClusterEndpointIdentifier: Swift.String? = nil,
        dBClusterEndpointResourceIdentifier: Swift.String? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        endpoint: Swift.String? = nil,
        endpointType: Swift.String? = nil,
        excludedMembers: [Swift.String]? = nil,
        staticMembers: [Swift.String]? = nil,
        status: Swift.String? = nil
    )
    {
        self.customEndpointType = customEndpointType
        self.dBClusterEndpointArn = dBClusterEndpointArn
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.endpoint = endpoint
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
        self.status = status
    }
}

struct ModifyDBClusterEndpointOutputResponseBody: Swift.Equatable {
    let dBClusterEndpointIdentifier: Swift.String?
    let dBClusterIdentifier: Swift.String?
    let dBClusterEndpointResourceIdentifier: Swift.String?
    let endpoint: Swift.String?
    let status: Swift.String?
    let endpointType: Swift.String?
    let customEndpointType: Swift.String?
    let staticMembers: [Swift.String]?
    let excludedMembers: [Swift.String]?
    let dBClusterEndpointArn: Swift.String?
}

extension ModifyDBClusterEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customEndpointType = "CustomEndpointType"
        case dBClusterEndpointArn = "DBClusterEndpointArn"
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        case dBClusterEndpointResourceIdentifier = "DBClusterEndpointResourceIdentifier"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case endpoint = "Endpoint"
        case endpointType = "EndpointType"
        case excludedMembers = "ExcludedMembers"
        case staticMembers = "StaticMembers"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBClusterEndpointResult"))
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterEndpointResourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointResourceIdentifier)
        dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifierDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let customEndpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customEndpointType)
        customEndpointType = customEndpointTypeDecoded
        if containerValues.contains(.staticMembers) {
            struct KeyVal0{struct member{}}
            let staticMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .staticMembers)
            if let staticMembersWrappedContainer = staticMembersWrappedContainer {
                let staticMembersContainer = try staticMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var staticMembersBuffer:[Swift.String]? = nil
                if let staticMembersContainer = staticMembersContainer {
                    staticMembersBuffer = [Swift.String]()
                    for stringContainer0 in staticMembersContainer {
                        staticMembersBuffer?.append(stringContainer0)
                    }
                }
                staticMembers = staticMembersBuffer
            } else {
                staticMembers = []
            }
        } else {
            staticMembers = nil
        }
        if containerValues.contains(.excludedMembers) {
            struct KeyVal0{struct member{}}
            let excludedMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .excludedMembers)
            if let excludedMembersWrappedContainer = excludedMembersWrappedContainer {
                let excludedMembersContainer = try excludedMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var excludedMembersBuffer:[Swift.String]? = nil
                if let excludedMembersContainer = excludedMembersContainer {
                    excludedMembersBuffer = [Swift.String]()
                    for stringContainer0 in excludedMembersContainer {
                        excludedMembersBuffer?.append(stringContainer0)
                    }
                }
                excludedMembers = excludedMembersBuffer
            } else {
                excludedMembers = []
            }
        } else {
            excludedMembers = nil
        }
        let dBClusterEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointArn)
        dBClusterEndpointArn = dBClusterEndpointArnDecoded
    }
}

extension ModifyDBClusterInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if allowMajorVersionUpgrade != false {
            try container.encode(allowMajorVersionUpgrade, forKey: ClientRuntime.Key("AllowMajorVersionUpgrade"))
        }
        if applyImmediately != false {
            try container.encode(applyImmediately, forKey: ClientRuntime.Key("ApplyImmediately"))
        }
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: ClientRuntime.Key("AutoMinorVersionUpgrade"))
        }
        if let backtrackWindow = backtrackWindow {
            try container.encode(backtrackWindow, forKey: ClientRuntime.Key("BacktrackWindow"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfiguration {
            try container.encode(cloudwatchLogsExportConfiguration, forKey: ClientRuntime.Key("CloudwatchLogsExportConfiguration"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterInstanceClass = dBClusterInstanceClass {
            try container.encode(dBClusterInstanceClass, forKey: ClientRuntime.Key("DBClusterInstanceClass"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let dBInstanceParameterGroupName = dBInstanceParameterGroupName {
            try container.encode(dBInstanceParameterGroupName, forKey: ClientRuntime.Key("DBInstanceParameterGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: ClientRuntime.Key("DomainIAMRoleName"))
        }
        if let enableGlobalWriteForwarding = enableGlobalWriteForwarding {
            try container.encode(enableGlobalWriteForwarding, forKey: ClientRuntime.Key("EnableGlobalWriteForwarding"))
        }
        if let enableHttpEndpoint = enableHttpEndpoint {
            try container.encode(enableHttpEndpoint, forKey: ClientRuntime.Key("EnableHttpEndpoint"))
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let enablePerformanceInsights = enablePerformanceInsights {
            try container.encode(enablePerformanceInsights, forKey: ClientRuntime.Key("EnablePerformanceInsights"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: ClientRuntime.Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: ClientRuntime.Key("MonitoringRoleArn"))
        }
        if let newDBClusterIdentifier = newDBClusterIdentifier {
            try container.encode(newDBClusterIdentifier, forKey: ClientRuntime.Key("NewDBClusterIdentifier"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: ClientRuntime.Key("PerformanceInsightsKMSKeyId"))
        }
        if let performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod {
            try container.encode(performanceInsightsRetentionPeriod, forKey: ClientRuntime.Key("PerformanceInsightsRetentionPeriod"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let scalingConfiguration = scalingConfiguration {
            try container.encode(scalingConfiguration, forKey: ClientRuntime.Key("ScalingConfiguration"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ModifyDBClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ModifyDBClusterInput: Swift.Equatable {
    /// The amount of storage in gibibytes (GiB) to allocate to each DB instance in the Multi-AZ DB cluster. Type: Integer Valid for: Multi-AZ DB clusters only
    public var allocatedStorage: Swift.Int?
    /// A value that indicates whether major version upgrades are allowed. Constraints: You must allow major version upgrades when specifying a value for the EngineVersion parameter that is a different major version than the DB cluster's current version. Valid for: Aurora DB clusters only
    public var allowMajorVersionUpgrade: Swift.Bool
    /// A value that indicates whether the modifications in this request and any pending modifications are asynchronously applied as soon as possible, regardless of the PreferredMaintenanceWindow setting for the DB cluster. If this parameter is disabled, changes to the DB cluster are applied during the next maintenance window. The ApplyImmediately parameter only affects the EnableIAMDatabaseAuthentication, MasterUserPassword, and NewDBClusterIdentifier values. If the ApplyImmediately parameter is disabled, then changes to the EnableIAMDatabaseAuthentication, MasterUserPassword, and NewDBClusterIdentifier values are applied during the next maintenance window. All other changes are applied immediately, regardless of the value of the ApplyImmediately parameter. By default, this parameter is disabled. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var applyImmediately: Swift.Bool
    /// A value that indicates whether minor engine upgrades are applied automatically to the DB cluster during the maintenance window. By default, minor engine upgrades are applied automatically. Valid for: Multi-AZ DB clusters only
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The target backtrack window, in seconds. To disable backtracking, set this value to 0. Default: 0 Constraints:
    ///
    /// * If specified, this value must be set to a number from 0 to 259,200 (72 hours).
    ///
    ///
    /// Valid for: Aurora MySQL DB clusters only
    public var backtrackWindow: Swift.Int?
    /// The number of days for which automated backups are retained. Specify a minimum value of 1. Default: 1 Constraints:
    ///
    /// * Must be a value from 1 to 35
    ///
    ///
    /// Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var backupRetentionPeriod: Swift.Int?
    /// The configuration setting for the log types to be enabled for export to CloudWatch Logs for a specific DB cluster. Valid for: Aurora DB clusters only
    public var cloudwatchLogsExportConfiguration: RdsClientTypes.CloudwatchLogsExportConfiguration?
    /// A value that indicates whether to copy all tags from the DB cluster to snapshots of the DB cluster. The default is not to copy them. Valid for: Aurora DB clusters only
    public var copyTagsToSnapshot: Swift.Bool?
    /// The DB cluster identifier for the cluster being modified. This parameter isn't case-sensitive. Constraints: This identifier must match the identifier of an existing DB cluster. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// The compute and memory capacity of each DB instance in the Multi-AZ DB cluster, for example db.m6g.xlarge. Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines. For the full list of DB instance classes and availability for your engine, see [DB Instance Class](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html) in the Amazon RDS User Guide. Valid for: Multi-AZ DB clusters only
    public var dBClusterInstanceClass: Swift.String?
    /// The name of the DB cluster parameter group to use for the DB cluster. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var dBClusterParameterGroupName: Swift.String?
    /// The name of the DB parameter group to apply to all instances of the DB cluster. When you apply a parameter group using the DBInstanceParameterGroupName parameter, the DB cluster isn't rebooted automatically. Also, parameter changes aren't applied during the next maintenance window but instead are applied immediately. Default: The existing name setting Constraints:
    ///
    /// * The DB parameter group must be in the same DB parameter group family as this DB cluster.
    ///
    /// * The DBInstanceParameterGroupName parameter is only valid in combination with the AllowMajorVersionUpgrade parameter.
    ///
    ///
    /// Valid for: Aurora DB clusters only
    public var dBInstanceParameterGroupName: Swift.String?
    /// A value that indicates whether the DB cluster has deletion protection enabled. The database can't be deleted when deletion protection is enabled. By default, deletion protection isn't enabled. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var deletionProtection: Swift.Bool?
    /// The Active Directory directory ID to move the DB cluster to. Specify none to remove the cluster from its current domain. The domain must be created prior to this operation. For more information, see [Kerberos Authentication](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/kerberos-authentication.html) in the Amazon Aurora User Guide. Valid for: Aurora DB clusters only
    public var domain: Swift.String?
    /// Specify the name of the IAM role to be used when making API calls to the Directory Service. Valid for: Aurora DB clusters only
    public var domainIAMRoleName: Swift.String?
    /// A value that indicates whether to enable this DB cluster to forward write operations to the primary cluster of an Aurora global database ([GlobalCluster]). By default, write operations are not allowed on Aurora DB clusters that are secondary clusters in an Aurora global database. You can set this value only on Aurora DB clusters that are members of an Aurora global database. With this parameter enabled, a secondary cluster can forward writes to the current primary cluster and the resulting changes are replicated back to this cluster. For the primary DB cluster of an Aurora global database, this value is used immediately if the primary is demoted by the [FailoverGlobalCluster] API operation, but it does nothing until then. Valid for: Aurora DB clusters only
    public var enableGlobalWriteForwarding: Swift.Bool?
    /// A value that indicates whether to enable the HTTP endpoint for an Aurora Serverless DB cluster. By default, the HTTP endpoint is disabled. When enabled, the HTTP endpoint provides a connectionless web service API for running SQL queries on the Aurora Serverless DB cluster. You can also query your database from inside the RDS console with the query editor. For more information, see [Using the Data API for Aurora Serverless](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html) in the Amazon Aurora User Guide. Valid for: Aurora DB clusters only
    public var enableHttpEndpoint: Swift.Bool?
    /// A value that indicates whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping isn't enabled. For more information, see [ IAM Database Authentication](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.IAMDBAuth.html) in the Amazon Aurora User Guide. Valid for: Aurora DB clusters only
    public var enableIAMDatabaseAuthentication: Swift.Bool?
    /// A value that indicates whether to turn on Performance Insights for the DB cluster. For more information, see [ Using Amazon Performance Insights](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html) in the Amazon RDS User Guide. Valid for: Multi-AZ DB clusters only
    public var enablePerformanceInsights: Swift.Bool?
    /// The version number of the database engine to which you want to upgrade. Changing this parameter results in an outage. The change is applied during the next maintenance window unless ApplyImmediately is enabled. To list all of the available engine versions for MySQL 5.6-compatible Aurora, use the following command: aws rds describe-db-engine-versions --engine aurora --query "DBEngineVersions[].EngineVersion" To list all of the available engine versions for MySQL 5.7-compatible Aurora, use the following command: aws rds describe-db-engine-versions --engine aurora-mysql --query "DBEngineVersions[].EngineVersion" To list all of the available engine versions for Aurora PostgreSQL, use the following command: aws rds describe-db-engine-versions --engine aurora-postgresql --query "DBEngineVersions[].EngineVersion" To list all of the available engine versions for RDS for MySQL, use the following command: aws rds describe-db-engine-versions --engine mysql --query "DBEngineVersions[].EngineVersion" To list all of the available engine versions for RDS for PostgreSQL, use the following command: aws rds describe-db-engine-versions --engine postgres --query "DBEngineVersions[].EngineVersion" Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var engineVersion: Swift.String?
    /// The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for each DB instance in the Multi-AZ DB cluster. For information about valid Iops values, see [Amazon RDS Provisioned IOPS Storage to Improve Performance](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#USER_PIOPS) in the Amazon RDS User Guide. Constraints: Must be a multiple between .5 and 50 of the storage amount for the DB cluster. Valid for: Multi-AZ DB clusters only
    public var iops: Swift.Int?
    /// The new password for the master database user. This password can contain any printable ASCII character except "/", """, or "@". Constraints: Must contain from 8 to 41 characters. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var masterUserPassword: Swift.String?
    /// The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB cluster. To turn off collecting Enhanced Monitoring metrics, specify 0. The default is 0. If MonitoringRoleArn is specified, also set MonitoringInterval to a value other than 0. Valid Values: 0, 1, 5, 10, 15, 30, 60 Valid for: Multi-AZ DB clusters only
    public var monitoringInterval: Swift.Int?
    /// The Amazon Resource Name (ARN) for the IAM role that permits RDS to send Enhanced Monitoring metrics to Amazon CloudWatch Logs. An example is arn:aws:iam:123456789012:role/emaccess. For information on creating a monitoring role, see [To create an IAM role for Amazon RDS Enhanced Monitoring](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.html#USER_Monitoring.OS.IAMRole) in the Amazon RDS User Guide. If MonitoringInterval is set to a value other than 0, supply a MonitoringRoleArn value. Valid for: Multi-AZ DB clusters only
    public var monitoringRoleArn: Swift.String?
    /// The new DB cluster identifier for the DB cluster when renaming a DB cluster. This value is stored as a lowercase string. Constraints:
    ///
    /// * Must contain from 1 to 63 letters, numbers, or hyphens
    ///
    /// * The first character must be a letter
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    /// Example: my-cluster2 Valid for: Aurora DB clusters only
    public var newDBClusterIdentifier: Swift.String?
    /// A value that indicates that the DB cluster should be associated with the specified option group. DB clusters are associated with a default option group that can't be modified.
    public var optionGroupName: Swift.String?
    /// The Amazon Web Services KMS key identifier for encryption of Performance Insights data. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. If you don't specify a value for PerformanceInsightsKMSKeyId, then Amazon RDS uses your default KMS key. There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region. Valid for: Multi-AZ DB clusters only
    public var performanceInsightsKMSKeyId: Swift.String?
    /// The amount of time, in days, to retain Performance Insights data. Valid values are 7 or 731 (2 years). Valid for: Multi-AZ DB clusters only
    public var performanceInsightsRetentionPeriod: Swift.Int?
    /// The port number on which the DB cluster accepts connections. Constraints: Value must be 1150-65535 Default: The same port as the original DB cluster. Valid for: Aurora DB clusters only
    public var port: Swift.Int?
    /// The daily time range during which automated backups are created if automated backups are enabled, using the BackupRetentionPeriod parameter. The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region. To view the time blocks available, see [ Backup window](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.Backups.BackupWindow) in the Amazon Aurora User Guide. Constraints:
    ///
    /// * Must be in the format hh24:mi-hh24:mi.
    ///
    /// * Must be in Universal Coordinated Time (UTC).
    ///
    /// * Must not conflict with the preferred maintenance window.
    ///
    /// * Must be at least 30 minutes.
    ///
    ///
    /// Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var preferredBackupWindow: Swift.String?
    /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Format: ddd:hh24:mi-ddd:hh24:mi The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region, occurring on a random day of the week. To see the time blocks available, see [ Adjusting the Preferred DB Cluster Maintenance Window](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow.Aurora) in the Amazon Aurora User Guide. Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun. Constraints: Minimum 30-minute window. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var preferredMaintenanceWindow: Swift.String?
    /// The scaling properties of the DB cluster. You can only modify scaling properties for DB clusters in serverless DB engine mode. Valid for: Aurora DB clusters only
    public var scalingConfiguration: RdsClientTypes.ScalingConfiguration?
    /// Specifies the storage type to be associated with the DB cluster. Valid values: standard | gp2 | io1 If you specify io1, you must also include a value for the Iops parameter. Default: io1 if the Iops parameter is specified, otherwise gp2 Valid for: Multi-AZ DB clusters only
    public var storageType: Swift.String?
    /// A list of VPC security groups that the DB cluster will belong to. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        allocatedStorage: Swift.Int? = nil,
        allowMajorVersionUpgrade: Swift.Bool = false,
        applyImmediately: Swift.Bool = false,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        backtrackWindow: Swift.Int? = nil,
        backupRetentionPeriod: Swift.Int? = nil,
        cloudwatchLogsExportConfiguration: RdsClientTypes.CloudwatchLogsExportConfiguration? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        dBClusterInstanceClass: Swift.String? = nil,
        dBClusterParameterGroupName: Swift.String? = nil,
        dBInstanceParameterGroupName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        domainIAMRoleName: Swift.String? = nil,
        enableGlobalWriteForwarding: Swift.Bool? = nil,
        enableHttpEndpoint: Swift.Bool? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        enablePerformanceInsights: Swift.Bool? = nil,
        engineVersion: Swift.String? = nil,
        iops: Swift.Int? = nil,
        masterUserPassword: Swift.String? = nil,
        monitoringInterval: Swift.Int? = nil,
        monitoringRoleArn: Swift.String? = nil,
        newDBClusterIdentifier: Swift.String? = nil,
        optionGroupName: Swift.String? = nil,
        performanceInsightsKMSKeyId: Swift.String? = nil,
        performanceInsightsRetentionPeriod: Swift.Int? = nil,
        port: Swift.Int? = nil,
        preferredBackupWindow: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        scalingConfiguration: RdsClientTypes.ScalingConfiguration? = nil,
        storageType: Swift.String? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
        self.applyImmediately = applyImmediately
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.backtrackWindow = backtrackWindow
        self.backupRetentionPeriod = backupRetentionPeriod
        self.cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfiguration
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterInstanceClass = dBClusterInstanceClass
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBInstanceParameterGroupName = dBInstanceParameterGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableGlobalWriteForwarding = enableGlobalWriteForwarding
        self.enableHttpEndpoint = enableHttpEndpoint
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.enablePerformanceInsights = enablePerformanceInsights
        self.engineVersion = engineVersion
        self.iops = iops
        self.masterUserPassword = masterUserPassword
        self.monitoringInterval = monitoringInterval
        self.monitoringRoleArn = monitoringRoleArn
        self.newDBClusterIdentifier = newDBClusterIdentifier
        self.optionGroupName = optionGroupName
        self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
        self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
        self.port = port
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.scalingConfiguration = scalingConfiguration
        self.storageType = storageType
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct ModifyDBClusterInputBody: Swift.Equatable {
    let dBClusterIdentifier: Swift.String?
    let newDBClusterIdentifier: Swift.String?
    let applyImmediately: Swift.Bool
    let backupRetentionPeriod: Swift.Int?
    let dBClusterParameterGroupName: Swift.String?
    let vpcSecurityGroupIds: [Swift.String]?
    let port: Swift.Int?
    let masterUserPassword: Swift.String?
    let optionGroupName: Swift.String?
    let preferredBackupWindow: Swift.String?
    let preferredMaintenanceWindow: Swift.String?
    let enableIAMDatabaseAuthentication: Swift.Bool?
    let backtrackWindow: Swift.Int?
    let cloudwatchLogsExportConfiguration: RdsClientTypes.CloudwatchLogsExportConfiguration?
    let engineVersion: Swift.String?
    let allowMajorVersionUpgrade: Swift.Bool
    let dBInstanceParameterGroupName: Swift.String?
    let domain: Swift.String?
    let domainIAMRoleName: Swift.String?
    let scalingConfiguration: RdsClientTypes.ScalingConfiguration?
    let deletionProtection: Swift.Bool?
    let enableHttpEndpoint: Swift.Bool?
    let copyTagsToSnapshot: Swift.Bool?
    let enableGlobalWriteForwarding: Swift.Bool?
    let dBClusterInstanceClass: Swift.String?
    let allocatedStorage: Swift.Int?
    let storageType: Swift.String?
    let iops: Swift.Int?
    let autoMinorVersionUpgrade: Swift.Bool?
    let monitoringInterval: Swift.Int?
    let monitoringRoleArn: Swift.String?
    let enablePerformanceInsights: Swift.Bool?
    let performanceInsightsKMSKeyId: Swift.String?
    let performanceInsightsRetentionPeriod: Swift.Int?
}

extension ModifyDBClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case allowMajorVersionUpgrade = "AllowMajorVersionUpgrade"
        case applyImmediately = "ApplyImmediately"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case backtrackWindow = "BacktrackWindow"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case cloudwatchLogsExportConfiguration = "CloudwatchLogsExportConfiguration"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBClusterInstanceClass = "DBClusterInstanceClass"
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
        case dBInstanceParameterGroupName = "DBInstanceParameterGroupName"
        case deletionProtection = "DeletionProtection"
        case domain = "Domain"
        case domainIAMRoleName = "DomainIAMRoleName"
        case enableGlobalWriteForwarding = "EnableGlobalWriteForwarding"
        case enableHttpEndpoint = "EnableHttpEndpoint"
        case enableIAMDatabaseAuthentication = "EnableIAMDatabaseAuthentication"
        case enablePerformanceInsights = "EnablePerformanceInsights"
        case engineVersion = "EngineVersion"
        case iops = "Iops"
        case masterUserPassword = "MasterUserPassword"
        case monitoringInterval = "MonitoringInterval"
        case monitoringRoleArn = "MonitoringRoleArn"
        case newDBClusterIdentifier = "NewDBClusterIdentifier"
        case optionGroupName = "OptionGroupName"
        case performanceInsightsKMSKeyId = "PerformanceInsightsKMSKeyId"
        case performanceInsightsRetentionPeriod = "PerformanceInsightsRetentionPeriod"
        case port = "Port"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case scalingConfiguration = "ScalingConfiguration"
        case storageType = "StorageType"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let newDBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newDBClusterIdentifier)
        newDBClusterIdentifier = newDBClusterIdentifierDecoded
        let applyImmediatelyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .applyImmediately)
        applyImmediately = applyImmediatelyDecoded
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
        if containerValues.contains(.vpcSecurityGroupIds) {
            struct KeyVal0{struct VpcSecurityGroupId{}}
            let vpcSecurityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupId>.CodingKeys.self, forKey: .vpcSecurityGroupIds)
            if let vpcSecurityGroupIdsWrappedContainer = vpcSecurityGroupIdsWrappedContainer {
                let vpcSecurityGroupIdsContainer = try vpcSecurityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSecurityGroupIdsBuffer:[Swift.String]? = nil
                if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
                    vpcSecurityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSecurityGroupIdsContainer {
                        vpcSecurityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupIds = vpcSecurityGroupIdsBuffer
            } else {
                vpcSecurityGroupIds = []
            }
        } else {
            vpcSecurityGroupIds = nil
        }
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let masterUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUserPassword)
        masterUserPassword = masterUserPasswordDecoded
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let enableIAMDatabaseAuthenticationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableIAMDatabaseAuthentication)
        enableIAMDatabaseAuthentication = enableIAMDatabaseAuthenticationDecoded
        let backtrackWindowDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backtrackWindow)
        backtrackWindow = backtrackWindowDecoded
        let cloudwatchLogsExportConfigurationDecoded = try containerValues.decodeIfPresent(RdsClientTypes.CloudwatchLogsExportConfiguration.self, forKey: .cloudwatchLogsExportConfiguration)
        cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfigurationDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let allowMajorVersionUpgradeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowMajorVersionUpgrade)
        allowMajorVersionUpgrade = allowMajorVersionUpgradeDecoded
        let dBInstanceParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceParameterGroupName)
        dBInstanceParameterGroupName = dBInstanceParameterGroupNameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let domainIAMRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainIAMRoleName)
        domainIAMRoleName = domainIAMRoleNameDecoded
        let scalingConfigurationDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ScalingConfiguration.self, forKey: .scalingConfiguration)
        scalingConfiguration = scalingConfigurationDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let enableHttpEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableHttpEndpoint)
        enableHttpEndpoint = enableHttpEndpointDecoded
        let copyTagsToSnapshotDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let enableGlobalWriteForwardingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableGlobalWriteForwarding)
        enableGlobalWriteForwarding = enableGlobalWriteForwardingDecoded
        let dBClusterInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterInstanceClass)
        dBClusterInstanceClass = dBClusterInstanceClassDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let monitoringIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monitoringInterval)
        monitoringInterval = monitoringIntervalDecoded
        let monitoringRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitoringRoleArn)
        monitoringRoleArn = monitoringRoleArnDecoded
        let enablePerformanceInsightsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enablePerformanceInsights)
        enablePerformanceInsights = enablePerformanceInsightsDecoded
        let performanceInsightsKMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .performanceInsightsKMSKeyId)
        performanceInsightsKMSKeyId = performanceInsightsKMSKeyIdDecoded
        let performanceInsightsRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .performanceInsightsRetentionPeriod)
        performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriodDecoded
    }
}

extension ModifyDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterAlreadyExistsFault" : self = .dBClusterAlreadyExistsFault(try DBClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterParameterGroupNotFound" : self = .dBClusterParameterGroupNotFoundFault(try DBClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSecurityGroupState" : self = .invalidDBSecurityGroupStateFault(try InvalidDBSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetGroupStateFault" : self = .invalidDBSubnetGroupStateFault(try InvalidDBSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceeded" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterAlreadyExistsFault(DBClusterAlreadyExistsFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterParameterGroupNotFoundFault(DBClusterParameterGroupNotFoundFault)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidDBSecurityGroupStateFault(InvalidDBSecurityGroupStateFault)
    case invalidDBSubnetGroupStateFault(InvalidDBSubnetGroupStateFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct ModifyDBClusterOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon Aurora DB cluster or Multi-AZ DB cluster. For an Amazon Aurora DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, PromoteReadReplicaDBCluster, RestoreDBClusterFromS3, RestoreDBClusterFromSnapshot, RestoreDBClusterToPointInTime, StartDBCluster, and StopDBCluster. For a Multi-AZ DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, RebootDBCluster, RestoreDBClusterFromSnapshot, and RestoreDBClusterToPointInTime. For more information on Amazon Aurora DB clusters, see [ What is Amazon Aurora?](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/CHAP_AuroraOverview.html) in the Amazon Aurora User Guide. For more information on Multi-AZ DB clusters, see [ Multi-AZ deployments with two readable standby DB instances](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/multi-az-db-clusters-concepts.html) in the Amazon RDS User Guide. The Multi-AZ DB clusters feature is in preview and is subject to change.
    public var dBCluster: RdsClientTypes.DBCluster?

    public init (
        dBCluster: RdsClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct ModifyDBClusterOutputResponseBody: Swift.Equatable {
    let dBCluster: RdsClientTypes.DBCluster?
}

extension ModifyDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

extension ModifyDBClusterParameterGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: ClientRuntime.Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBClusterParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ModifyDBClusterParameterGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ModifyDBClusterParameterGroupInput: Swift.Equatable {
    /// The name of the DB cluster parameter group to modify.
    /// This member is required.
    public var dBClusterParameterGroupName: Swift.String?
    /// A list of parameters in the DB cluster parameter group to modify. Valid Values (for the application method): immediate | pending-reboot You can use the immediate value with dynamic parameters only. You can use the pending-reboot value for both dynamic and static parameters. When the application method is immediate, changes to dynamic parameters are applied immediately to the DB clusters associated with the parameter group. When the application method is pending-reboot, changes to dynamic and static parameters are applied after a reboot without failover to the DB clusters associated with the parameter group.
    /// This member is required.
    public var parameters: [RdsClientTypes.Parameter]?

    public init (
        dBClusterParameterGroupName: Swift.String? = nil,
        parameters: [RdsClientTypes.Parameter]? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.parameters = parameters
    }
}

struct ModifyDBClusterParameterGroupInputBody: Swift.Equatable {
    let dBClusterParameterGroupName: Swift.String?
    let parameters: [RdsClientTypes.Parameter]?
}

extension ModifyDBClusterParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct Parameter{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Parameter>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([RdsClientTypes.Parameter].self, forKey: .member)
                var parametersBuffer:[RdsClientTypes.Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [RdsClientTypes.Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
    }
}

extension ModifyDBClusterParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBClusterParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupState" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBClusterParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBClusterParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterParameterGroupName = output.dBClusterParameterGroupName
        } else {
            self.dBClusterParameterGroupName = nil
        }
    }
}

///
public struct ModifyDBClusterParameterGroupOutputResponse: Swift.Equatable {
    /// The name of the DB cluster parameter group. Constraints:
    ///
    /// * Must be 1 to 255 letters or numbers.
    ///
    /// * First character must be a letter
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    /// This value is stored as a lowercase string.
    public var dBClusterParameterGroupName: Swift.String?

    public init (
        dBClusterParameterGroupName: Swift.String? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
    }
}

struct ModifyDBClusterParameterGroupOutputResponseBody: Swift.Equatable {
    let dBClusterParameterGroupName: Swift.String?
}

extension ModifyDBClusterParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBClusterParameterGroupResult"))
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
    }
}

extension ModifyDBClusterSnapshotAttributeInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: ClientRuntime.Key("AttributeName"))
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("DBClusterSnapshotIdentifier"))
        }
        if let valuesToAdd = valuesToAdd {
            var valuesToAddContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ValuesToAdd"))
            for (index0, string0) in valuesToAdd.enumerated() {
                try valuesToAddContainer.encode(string0, forKey: ClientRuntime.Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
        if let valuesToRemove = valuesToRemove {
            var valuesToRemoveContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ValuesToRemove"))
            for (index0, string0) in valuesToRemove.enumerated() {
                try valuesToRemoveContainer.encode(string0, forKey: ClientRuntime.Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBClusterSnapshotAttribute", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ModifyDBClusterSnapshotAttributeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ModifyDBClusterSnapshotAttributeInput: Swift.Equatable {
    /// The name of the DB cluster snapshot attribute to modify. To manage authorization for other Amazon Web Services accounts to copy or restore a manual DB cluster snapshot, set this value to restore. To view the list of attributes available to modify, use the [DescribeDBClusterSnapshotAttributes] API action.
    /// This member is required.
    public var attributeName: Swift.String?
    /// The identifier for the DB cluster snapshot to modify the attributes for.
    /// This member is required.
    public var dBClusterSnapshotIdentifier: Swift.String?
    /// A list of DB cluster snapshot attributes to add to the attribute specified by AttributeName. To authorize other Amazon Web Services accounts to copy or restore a manual DB cluster snapshot, set this list to include one or more Amazon Web Services account IDs, or all to make the manual DB cluster snapshot restorable by any Amazon Web Services account. Do not add the all value for any manual DB cluster snapshots that contain private information that you don't want available to all Amazon Web Services accounts.
    public var valuesToAdd: [Swift.String]?
    /// A list of DB cluster snapshot attributes to remove from the attribute specified by AttributeName. To remove authorization for other Amazon Web Services accounts to copy or restore a manual DB cluster snapshot, set this list to include one or more Amazon Web Services account identifiers, or all to remove authorization for any Amazon Web Services account to copy or restore the DB cluster snapshot. If you specify all, an Amazon Web Services account whose account ID is explicitly added to the restore attribute can still copy or restore a manual DB cluster snapshot.
    public var valuesToRemove: [Swift.String]?

    public init (
        attributeName: Swift.String? = nil,
        dBClusterSnapshotIdentifier: Swift.String? = nil,
        valuesToAdd: [Swift.String]? = nil,
        valuesToRemove: [Swift.String]? = nil
    )
    {
        self.attributeName = attributeName
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
        self.valuesToAdd = valuesToAdd
        self.valuesToRemove = valuesToRemove
    }
}

struct ModifyDBClusterSnapshotAttributeInputBody: Swift.Equatable {
    let dBClusterSnapshotIdentifier: Swift.String?
    let attributeName: Swift.String?
    let valuesToAdd: [Swift.String]?
    let valuesToRemove: [Swift.String]?
}

extension ModifyDBClusterSnapshotAttributeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case dBClusterSnapshotIdentifier = "DBClusterSnapshotIdentifier"
        case valuesToAdd = "ValuesToAdd"
        case valuesToRemove = "ValuesToRemove"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterSnapshotIdentifier)
        dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifierDecoded
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        if containerValues.contains(.valuesToAdd) {
            struct KeyVal0{struct AttributeValue{}}
            let valuesToAddWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AttributeValue>.CodingKeys.self, forKey: .valuesToAdd)
            if let valuesToAddWrappedContainer = valuesToAddWrappedContainer {
                let valuesToAddContainer = try valuesToAddWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var valuesToAddBuffer:[Swift.String]? = nil
                if let valuesToAddContainer = valuesToAddContainer {
                    valuesToAddBuffer = [Swift.String]()
                    for stringContainer0 in valuesToAddContainer {
                        valuesToAddBuffer?.append(stringContainer0)
                    }
                }
                valuesToAdd = valuesToAddBuffer
            } else {
                valuesToAdd = []
            }
        } else {
            valuesToAdd = nil
        }
        if containerValues.contains(.valuesToRemove) {
            struct KeyVal0{struct AttributeValue{}}
            let valuesToRemoveWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AttributeValue>.CodingKeys.self, forKey: .valuesToRemove)
            if let valuesToRemoveWrappedContainer = valuesToRemoveWrappedContainer {
                let valuesToRemoveContainer = try valuesToRemoveWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var valuesToRemoveBuffer:[Swift.String]? = nil
                if let valuesToRemoveContainer = valuesToRemoveContainer {
                    valuesToRemoveBuffer = [Swift.String]()
                    for stringContainer0 in valuesToRemoveContainer {
                        valuesToRemoveBuffer?.append(stringContainer0)
                    }
                }
                valuesToRemove = valuesToRemoveBuffer
            } else {
                valuesToRemove = []
            }
        } else {
            valuesToRemove = nil
        }
    }
}

extension ModifyDBClusterSnapshotAttributeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBClusterSnapshotAttributeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SharedSnapshotQuotaExceeded" : self = .sharedSnapshotQuotaExceededFault(try SharedSnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBClusterSnapshotAttributeOutputError: Swift.Error, Swift.Equatable {
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case sharedSnapshotQuotaExceededFault(SharedSnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBClusterSnapshotAttributeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBClusterSnapshotAttributeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterSnapshotAttributesResult = output.dBClusterSnapshotAttributesResult
        } else {
            self.dBClusterSnapshotAttributesResult = nil
        }
    }
}

public struct ModifyDBClusterSnapshotAttributeOutputResponse: Swift.Equatable {
    /// Contains the results of a successful call to the DescribeDBClusterSnapshotAttributes API action. Manual DB cluster snapshot attributes are used to authorize other Amazon Web Services accounts to copy or restore a manual DB cluster snapshot. For more information, see the ModifyDBClusterSnapshotAttribute API action.
    public var dBClusterSnapshotAttributesResult: RdsClientTypes.DBClusterSnapshotAttributesResult?

    public init (
        dBClusterSnapshotAttributesResult: RdsClientTypes.DBClusterSnapshotAttributesResult? = nil
    )
    {
        self.dBClusterSnapshotAttributesResult = dBClusterSnapshotAttributesResult
    }
}

struct ModifyDBClusterSnapshotAttributeOutputResponseBody: Swift.Equatable {
    let dBClusterSnapshotAttributesResult: RdsClientTypes.DBClusterSnapshotAttributesResult?
}

extension ModifyDBClusterSnapshotAttributeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterSnapshotAttributesResult = "DBClusterSnapshotAttributesResult"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBClusterSnapshotAttributeResult"))
        let dBClusterSnapshotAttributesResultDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBClusterSnapshotAttributesResult.self, forKey: .dBClusterSnapshotAttributesResult)
        dBClusterSnapshotAttributesResult = dBClusterSnapshotAttributesResultDecoded
    }
}

extension ModifyDBInstanceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if allowMajorVersionUpgrade != false {
            try container.encode(allowMajorVersionUpgrade, forKey: ClientRuntime.Key("AllowMajorVersionUpgrade"))
        }
        if applyImmediately != false {
            try container.encode(applyImmediately, forKey: ClientRuntime.Key("ApplyImmediately"))
        }
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: ClientRuntime.Key("AutoMinorVersionUpgrade"))
        }
        if let automationMode = automationMode {
            try container.encode(automationMode, forKey: ClientRuntime.Key("AutomationMode"))
        }
        if let awsBackupRecoveryPointArn = awsBackupRecoveryPointArn {
            try container.encode(awsBackupRecoveryPointArn, forKey: ClientRuntime.Key("AwsBackupRecoveryPointArn"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let cACertificateIdentifier = cACertificateIdentifier {
            try container.encode(cACertificateIdentifier, forKey: ClientRuntime.Key("CACertificateIdentifier"))
        }
        if let certificateRotationRestart = certificateRotationRestart {
            try container.encode(certificateRotationRestart, forKey: ClientRuntime.Key("CertificateRotationRestart"))
        }
        if let cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfiguration {
            try container.encode(cloudwatchLogsExportConfiguration, forKey: ClientRuntime.Key("CloudwatchLogsExportConfiguration"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let dBPortNumber = dBPortNumber {
            try container.encode(dBPortNumber, forKey: ClientRuntime.Key("DBPortNumber"))
        }
        if let dBSecurityGroups = dBSecurityGroups {
            var dBSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBSecurityGroups"))
            for (index0, string0) in dBSecurityGroups.enumerated() {
                try dBSecurityGroupsContainer.encode(string0, forKey: ClientRuntime.Key("DBSecurityGroupName.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: ClientRuntime.Key("DomainIAMRoleName"))
        }
        if let enableCustomerOwnedIp = enableCustomerOwnedIp {
            try container.encode(enableCustomerOwnedIp, forKey: ClientRuntime.Key("EnableCustomerOwnedIp"))
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let enablePerformanceInsights = enablePerformanceInsights {
            try container.encode(enablePerformanceInsights, forKey: ClientRuntime.Key("EnablePerformanceInsights"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let maxAllocatedStorage = maxAllocatedStorage {
            try container.encode(maxAllocatedStorage, forKey: ClientRuntime.Key("MaxAllocatedStorage"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: ClientRuntime.Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: ClientRuntime.Key("MonitoringRoleArn"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let newDBInstanceIdentifier = newDBInstanceIdentifier {
            try container.encode(newDBInstanceIdentifier, forKey: ClientRuntime.Key("NewDBInstanceIdentifier"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: ClientRuntime.Key("PerformanceInsightsKMSKeyId"))
        }
        if let performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod {
            try container.encode(performanceInsightsRetentionPeriod, forKey: ClientRuntime.Key("PerformanceInsightsRetentionPeriod"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: ClientRuntime.Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let promotionTier = promotionTier {
            try container.encode(promotionTier, forKey: ClientRuntime.Key("PromotionTier"))
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let replicaMode = replicaMode {
            try container.encode(replicaMode, forKey: ClientRuntime.Key("ReplicaMode"))
        }
        if let resumeFullAutomationModeMinutes = resumeFullAutomationModeMinutes {
            try container.encode(resumeFullAutomationModeMinutes, forKey: ClientRuntime.Key("ResumeFullAutomationModeMinutes"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: ClientRuntime.Key("TdeCredentialArn"))
        }
        if let tdeCredentialPassword = tdeCredentialPassword {
            try container.encode(tdeCredentialPassword, forKey: ClientRuntime.Key("TdeCredentialPassword"))
        }
        if let useDefaultProcessorFeatures = useDefaultProcessorFeatures {
            try container.encode(useDefaultProcessorFeatures, forKey: ClientRuntime.Key("UseDefaultProcessorFeatures"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBInstance", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ModifyDBInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ModifyDBInstanceInput: Swift.Equatable {
    /// The new amount of storage in gibibytes (GiB) to allocate for the DB instance. For MariaDB, MySQL, Oracle, and PostgreSQL, the value supplied must be at least 10% greater than the current value. Values that are not at least 10% greater than the existing value are rounded up so that they are 10% greater than the current value. For the valid values for allocated storage for each engine, see CreateDBInstance.
    public var allocatedStorage: Swift.Int?
    /// A value that indicates whether major version upgrades are allowed. Changing this parameter doesn't result in an outage and the change is asynchronously applied as soon as possible. This setting doesn't apply to RDS Custom. Constraints: Major version upgrades must be allowed when specifying a value for the EngineVersion parameter that is a different major version than the DB instance's current version.
    public var allowMajorVersionUpgrade: Swift.Bool
    /// A value that indicates whether the modifications in this request and any pending modifications are asynchronously applied as soon as possible, regardless of the PreferredMaintenanceWindow setting for the DB instance. By default, this parameter is disabled. If this parameter is disabled, changes to the DB instance are applied during the next maintenance window. Some parameter changes can cause an outage and are applied on the next call to [RebootDBInstance], or the next failure reboot. Review the table of parameters in [Modifying a DB Instance](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Overview.DBInstance.Modifying.html) in the Amazon RDS User Guide. to see the impact of enabling or disabling ApplyImmediately for each modified parameter and to determine when the changes are applied.
    public var applyImmediately: Swift.Bool
    /// A value that indicates whether minor version upgrades are applied automatically to the DB instance during the maintenance window. An outage occurs when all the following conditions are met:
    ///
    /// * The automatic upgrade is enabled for the maintenance window.
    ///
    /// * A newer minor version is available.
    ///
    /// * RDS has enabled automatic patching for the engine version.
    ///
    ///
    /// If any of the preceding conditions isn't met, RDS applies the change as soon as possible and doesn't cause an outage. For an RDS Custom DB instance, set AutoMinorVersionUpgrade to false. Otherwise, the operation returns an error.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The automation mode of the RDS Custom DB instance: full or all paused. If full, the DB instance automates monitoring and instance recovery. If all paused, the instance pauses automation for the duration set by ResumeFullAutomationModeMinutes.
    public var automationMode: RdsClientTypes.AutomationMode?
    /// The Amazon Resource Name (ARN) of the recovery point in Amazon Web Services Backup. This setting doesn't apply to RDS Custom.
    public var awsBackupRecoveryPointArn: Swift.String?
    /// The number of days to retain automated backups. Setting this parameter to a positive number enables backups. Setting this parameter to 0 disables automated backups. Enabling and disabling backups can result in a brief I/O suspension that lasts from a few seconds to a few minutes, depending on the size and class of your DB instance. These changes are applied during the next maintenance window unless the ApplyImmediately parameter is enabled for this request. If you change the parameter from one non-zero value to another non-zero value, the change is asynchronously applied as soon as possible. Amazon Aurora Not applicable. The retention period for automated backups is managed by the DB cluster. For more information, see ModifyDBCluster. Default: Uses existing setting Constraints:
    ///
    /// * It must be a value from 0 to 35. It can't be set to 0 if the DB instance is a source to read replicas. It can't be set to 0 or 35 for an RDS Custom DB instance.
    ///
    /// * It can be specified for a MySQL read replica only if the source is running MySQL 5.6 or later.
    ///
    /// * It can be specified for a PostgreSQL read replica only if the source is running PostgreSQL 9.3.5.
    public var backupRetentionPeriod: Swift.Int?
    /// Specifies the certificate to associate with the DB instance. This setting doesn't apply to RDS Custom.
    public var cACertificateIdentifier: Swift.String?
    /// A value that indicates whether the DB instance is restarted when you rotate your SSL/TLS certificate. By default, the DB instance is restarted when you rotate your SSL/TLS certificate. The certificate is not updated until the DB instance is restarted. Set this parameter only if you are not using SSL/TLS to connect to the DB instance. If you are using SSL/TLS to connect to the DB instance, follow the appropriate instructions for your DB engine to rotate your SSL/TLS certificate:
    ///
    /// * For more information about rotating your SSL/TLS certificate for RDS DB engines, see [ Rotating Your SSL/TLS Certificate.](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL-certificate-rotation.html) in the Amazon RDS User Guide.
    ///
    /// * For more information about rotating your SSL/TLS certificate for Aurora DB engines, see [ Rotating Your SSL/TLS Certificate](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.SSL-certificate-rotation.html) in the Amazon Aurora User Guide.
    ///
    ///
    /// This setting doesn't apply to RDS Custom.
    public var certificateRotationRestart: Swift.Bool?
    /// The configuration setting for the log types to be enabled for export to CloudWatch Logs for a specific DB instance. A change to the CloudwatchLogsExportConfiguration parameter is always applied to the DB instance immediately. Therefore, the ApplyImmediately parameter has no effect. This setting doesn't apply to RDS Custom.
    public var cloudwatchLogsExportConfiguration: RdsClientTypes.CloudwatchLogsExportConfiguration?
    /// A value that indicates whether to copy all tags from the DB instance to snapshots of the DB instance. By default, tags are not copied. Amazon Aurora Not applicable. Copying tags to snapshots is managed by the DB cluster. Setting this value for an Aurora DB instance has no effect on the DB cluster setting. For more information, see ModifyDBCluster.
    public var copyTagsToSnapshot: Swift.Bool?
    /// The new compute and memory capacity of the DB instance, for example db.m4.large. Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines. For the full list of DB instance classes, and availability for your engine, see [DB Instance Class](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html) in the Amazon RDS User Guide. If you modify the DB instance class, an outage occurs during the change. The change is applied during the next maintenance window, unless ApplyImmediately is enabled for this request. This setting doesn't apply to RDS Custom. Default: Uses existing setting
    public var dBInstanceClass: Swift.String?
    /// The DB instance identifier. This value is stored as a lowercase string. Constraints:
    ///
    /// * Must match the identifier of an existing DBInstance.
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// The name of the DB parameter group to apply to the DB instance. Changing this setting doesn't result in an outage. The parameter group name itself is changed immediately, but the actual parameter changes are not applied until you reboot the instance without failover. In this case, the DB instance isn't rebooted automatically, and the parameter changes aren't applied during the next maintenance window. However, if you modify dynamic parameters in the newly associated DB parameter group, these changes are applied immediately without a reboot. This setting doesn't apply to RDS Custom. Default: Uses existing setting Constraints: The DB parameter group must be in the same DB parameter group family as the DB instance.
    public var dBParameterGroupName: Swift.String?
    /// The port number on which the database accepts connections. The value of the DBPortNumber parameter must not match any of the port values specified for options in the option group for the DB instance. If you change the DBPortNumber value, your database restarts regardless of the value of the ApplyImmediately parameter. This setting doesn't apply to RDS Custom. MySQL Default: 3306 Valid values: 1150-65535 MariaDB Default: 3306 Valid values: 1150-65535 PostgreSQL Default: 5432 Valid values: 1150-65535 Type: Integer Oracle Default: 1521 Valid values: 1150-65535 SQL Server Default: 1433 Valid values: 1150-65535 except 1234, 1434, 3260, 3343, 3389, 47001, and 49152-49156. Amazon Aurora Default: 3306 Valid values: 1150-65535
    public var dBPortNumber: Swift.Int?
    /// A list of DB security groups to authorize on this DB instance. Changing this setting doesn't result in an outage and the change is asynchronously applied as soon as possible. This setting doesn't apply to RDS Custom. Constraints:
    ///
    /// * If supplied, must match existing DBSecurityGroups.
    public var dBSecurityGroups: [Swift.String]?
    /// The new DB subnet group for the DB instance. You can use this parameter to move your DB instance to a different VPC. If your DB instance isn't in a VPC, you can also use this parameter to move your DB instance into a VPC. For more information, see [Working with a DB instance in a VPC](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.WorkingWithRDSInstanceinaVPC.html#USER_VPC.Non-VPC2VPC) in the Amazon RDS User Guide. Changing the subnet group causes an outage during the change. The change is applied during the next maintenance window, unless you enable ApplyImmediately. This parameter doesn't apply to RDS Custom. Constraints: If supplied, must match the name of an existing DBSubnetGroup. Example: mySubnetGroup
    public var dBSubnetGroupName: Swift.String?
    /// A value that indicates whether the DB instance has deletion protection enabled. The database can't be deleted when deletion protection is enabled. By default, deletion protection isn't enabled. For more information, see [ Deleting a DB Instance](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html).
    public var deletionProtection: Swift.Bool?
    /// The Active Directory directory ID to move the DB instance to. Specify none to remove the instance from its current domain. You must create the domain before this operation. Currently, you can create only MySQL, Microsoft SQL Server, Oracle, and PostgreSQL DB instances in an Active Directory Domain. For more information, see [ Kerberos Authentication](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html) in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom.
    public var domain: Swift.String?
    /// The name of the IAM role to use when making API calls to the Directory Service. This setting doesn't apply to RDS Custom.
    public var domainIAMRoleName: Swift.String?
    /// A value that indicates whether to enable a customer-owned IP address (CoIP) for an RDS on Outposts DB instance. A CoIP provides local or external connectivity to resources in your Outpost subnets through your on-premises network. For some use cases, a CoIP can provide lower latency for connections to the DB instance from outside of its virtual private cloud (VPC) on your local network. For more information about RDS on Outposts, see [Working with Amazon RDS on Amazon Web Services Outposts](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html) in the Amazon RDS User Guide. For more information about CoIPs, see [Customer-owned IP addresses](https://docs.aws.amazon.com/outposts/latest/userguide/outposts-networking-components.html#ip-addressing) in the Amazon Web Services Outposts User Guide.
    public var enableCustomerOwnedIp: Swift.Bool?
    /// A value that indicates whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping isn't enabled. This setting doesn't apply to Amazon Aurora. Mapping Amazon Web Services IAM accounts to database accounts is managed by the DB cluster. For more information about IAM database authentication, see [ IAM Database Authentication for MySQL and PostgreSQL](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html) in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom.
    public var enableIAMDatabaseAuthentication: Swift.Bool?
    /// A value that indicates whether to enable Performance Insights for the DB instance. For more information, see [Using Amazon Performance Insights](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html) in the Amazon Relational Database Service User Guide. This setting doesn't apply to RDS Custom.
    public var enablePerformanceInsights: Swift.Bool?
    /// The version number of the database engine to upgrade to. Changing this parameter results in an outage and the change is applied during the next maintenance window unless the ApplyImmediately parameter is enabled for this request. For major version upgrades, if a nondefault DB parameter group is currently in use, a new DB parameter group in the DB parameter group family for the new engine version must be specified. The new DB parameter group can be the default for that DB parameter group family. If you specify only a major version, Amazon RDS will update the DB instance to the default minor version if the current minor version is lower. For information about valid engine versions, see CreateDBInstance, or call DescribeDBEngineVersions. In RDS Custom, this parameter is supported for read replicas only if they are in the PATCH_DB_FAILURE lifecycle.
    public var engineVersion: Swift.String?
    /// The new Provisioned IOPS (I/O operations per second) value for the RDS instance. Changing this setting doesn't result in an outage and the change is applied during the next maintenance window unless the ApplyImmediately parameter is enabled for this request. If you are migrating from Provisioned IOPS to standard storage, set this value to 0. The DB instance will require a reboot for the change in storage type to take effect. If you choose to migrate your DB instance from using standard storage to using Provisioned IOPS, or from using Provisioned IOPS to using standard storage, the process can take time. The duration of the migration depends on several factors such as database load, storage size, storage type (standard or Provisioned IOPS), amount of IOPS provisioned (if any), and the number of prior scale storage operations. Typical migration times are under 24 hours, but the process can take up to several days in some cases. During the migration, the DB instance is available for use, but might experience performance degradation. While the migration takes place, nightly backups for the instance are suspended. No other Amazon RDS operations can take place for the instance, including modifying the instance, rebooting the instance, deleting the instance, creating a read replica for the instance, and creating a DB snapshot of the instance. Constraints: For MariaDB, MySQL, Oracle, and PostgreSQL, the value supplied must be at least 10% greater than the current value. Values that are not at least 10% greater than the existing value are rounded up so that they are 10% greater than the current value. Default: Uses existing setting
    public var iops: Swift.Int?
    /// The license model for the DB instance. This setting doesn't apply to RDS Custom. Valid values: license-included | bring-your-own-license | general-public-license
    public var licenseModel: Swift.String?
    /// The new password for the master user. The password can include any printable ASCII character except "/", """, or "@". Changing this parameter doesn't result in an outage and the change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the MasterUserPassword element exists in the PendingModifiedValues element of the operation response. This setting doesn't apply to RDS Custom. Amazon Aurora Not applicable. The password for the master user is managed by the DB cluster. For more information, see ModifyDBCluster. Default: Uses existing setting MariaDB Constraints: Must contain from 8 to 41 characters. Microsoft SQL Server Constraints: Must contain from 8 to 128 characters. MySQL Constraints: Must contain from 8 to 41 characters. Oracle Constraints: Must contain from 8 to 30 characters. PostgreSQL Constraints: Must contain from 8 to 128 characters. Amazon RDS API actions never return the password, so this action provides a way to regain access to a primary instance user if the password is lost. This includes restoring privileges that might have been accidentally revoked.
    public var masterUserPassword: Swift.String?
    /// The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance. For more information about this setting, including limitations that apply to it, see [ Managing capacity automatically with Amazon RDS storage autoscaling](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling) in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom.
    public var maxAllocatedStorage: Swift.Int?
    /// The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance. To disable collecting Enhanced Monitoring metrics, specify 0, which is the default. If MonitoringRoleArn is specified, set MonitoringInterval to a value other than 0. This setting doesn't apply to RDS Custom. Valid Values: 0, 1, 5, 10, 15, 30, 60
    public var monitoringInterval: Swift.Int?
    /// The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs. For example, arn:aws:iam:123456789012:role/emaccess. For information on creating a monitoring role, see [To create an IAM role for Amazon RDS Enhanced Monitoring](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.html#USER_Monitoring.OS.IAMRole) in the Amazon RDS User Guide. If MonitoringInterval is set to a value other than 0, supply a MonitoringRoleArn value. This setting doesn't apply to RDS Custom.
    public var monitoringRoleArn: Swift.String?
    /// A value that indicates whether the DB instance is a Multi-AZ deployment. Changing this parameter doesn't result in an outage. The change is applied during the next maintenance window unless the ApplyImmediately parameter is enabled for this request. This setting doesn't apply to RDS Custom.
    public var multiAZ: Swift.Bool?
    /// The new DB instance identifier for the DB instance when renaming a DB instance. When you change the DB instance identifier, an instance reboot occurs immediately if you enable ApplyImmediately, or will occur during the next maintenance window if you disable Apply Immediately. This value is stored as a lowercase string. This setting doesn't apply to RDS Custom. Constraints:
    ///
    /// * Must contain from 1 to 63 letters, numbers, or hyphens.
    ///
    /// * The first character must be a letter.
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    /// Example: mydbinstance
    public var newDBInstanceIdentifier: Swift.String?
    /// A value that indicates the DB instance should be associated with the specified option group. Changing this parameter doesn't result in an outage, with one exception. If the parameter change results in an option group that enables OEM, it can cause a brief period, lasting less than a second, during which new connections are rejected but existing connections aren't interrupted. The change is applied during the next maintenance window unless the ApplyImmediately parameter is enabled for this request. Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option group, and that option group can't be removed from a DB instance after it is associated with a DB instance. This setting doesn't apply to RDS Custom.
    public var optionGroupName: Swift.String?
    /// The Amazon Web Services KMS key identifier for encryption of Performance Insights data. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. If you do not specify a value for PerformanceInsightsKMSKeyId, then Amazon RDS uses your default KMS key. There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region. This setting doesn't apply to RDS Custom.
    public var performanceInsightsKMSKeyId: Swift.String?
    /// The amount of time, in days, to retain Performance Insights data. Valid values are 7 or 731 (2 years). This setting doesn't apply to RDS Custom.
    public var performanceInsightsRetentionPeriod: Swift.Int?
    /// The daily time range during which automated backups are created if automated backups are enabled, as determined by the BackupRetentionPeriod parameter. Changing this parameter doesn't result in an outage and the change is asynchronously applied as soon as possible. The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region. For more information, see [Backup window](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow) in the Amazon RDS User Guide. Amazon Aurora Not applicable. The daily time range for creating automated backups is managed by the DB cluster. For more information, see ModifyDBCluster. Constraints:
    ///
    /// * Must be in the format hh24:mi-hh24:mi
    ///
    /// * Must be in Universal Time Coordinated (UTC)
    ///
    /// * Must not conflict with the preferred maintenance window
    ///
    /// * Must be at least 30 minutes
    public var preferredBackupWindow: Swift.String?
    /// The weekly time range (in UTC) during which system maintenance can occur, which might result in an outage. Changing this parameter doesn't result in an outage, except in the following situation, and the change is asynchronously applied as soon as possible. If there are pending actions that cause a reboot, and the maintenance window is changed to include the current time, then changing this parameter will cause a reboot of the DB instance. If moving this window to the current time, there must be at least 30 minutes between the current time and end of the window to ensure pending changes are applied. For more information, see [Amazon RDS Maintenance Window](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance) in the Amazon RDS User Guide. Default: Uses existing setting Format: ddd:hh24:mi-ddd:hh24:mi Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun Constraints: Must be at least 30 minutes
    public var preferredMaintenanceWindow: Swift.String?
    /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance. This setting doesn't apply to RDS Custom.
    public var processorFeatures: [RdsClientTypes.ProcessorFeature]?
    /// A value that specifies the order in which an Aurora Replica is promoted to the primary instance after a failure of the existing primary instance. For more information, see [ Fault Tolerance for an Aurora DB Cluster](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.FaultTolerance) in the Amazon Aurora User Guide. This setting doesn't apply to RDS Custom. Default: 1 Valid Values: 0 - 15
    public var promotionTier: Swift.Int?
    /// A value that indicates whether the DB instance is publicly accessible. When the DB cluster is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB cluster's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB cluster's VPC. Access to the DB cluster is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB cluster doesn't permit it. When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address. PubliclyAccessible only applies to DB instances in a VPC. The DB instance must be part of a public subnet and PubliclyAccessible must be enabled for it to be publicly accessible. Changes to the PubliclyAccessible parameter are applied immediately regardless of the value of the ApplyImmediately parameter. This setting doesn't apply to RDS Custom.
    public var publiclyAccessible: Swift.Bool?
    /// A value that sets the open mode of a replica database to either mounted or read-only. Currently, this parameter is only supported for Oracle DB instances. Mounted DB replicas are included in Oracle Enterprise Edition. The main use case for mounted replicas is cross-Region disaster recovery. The primary database doesn't use Active Data Guard to transmit information to the mounted replica. Because it doesn't accept user connections, a mounted replica can't serve a read-only workload. For more information, see [Working with Oracle Read Replicas for Amazon RDS](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-read-replicas.html) in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom.
    public var replicaMode: RdsClientTypes.ReplicaMode?
    /// The number of minutes to pause the automation. When the time period ends, RDS Custom resumes full automation. The minimum value is 60 (default). The maximum value is 1,440.
    public var resumeFullAutomationModeMinutes: Swift.Int?
    /// Specifies the storage type to be associated with the DB instance. If you specify Provisioned IOPS (io1), you must also include a value for the Iops parameter. If you choose to migrate your DB instance from using standard storage to using Provisioned IOPS, or from using Provisioned IOPS to using standard storage, the process can take time. The duration of the migration depends on several factors such as database load, storage size, storage type (standard or Provisioned IOPS), amount of IOPS provisioned (if any), and the number of prior scale storage operations. Typical migration times are under 24 hours, but the process can take up to several days in some cases. During the migration, the DB instance is available for use, but might experience performance degradation. While the migration takes place, nightly backups for the instance are suspended. No other Amazon RDS operations can take place for the instance, including modifying the instance, rebooting the instance, deleting the instance, creating a read replica for the instance, and creating a DB snapshot of the instance. Valid values: standard | gp2 | io1 Default: io1 if the Iops parameter is specified, otherwise gp2
    public var storageType: Swift.String?
    /// The ARN from the key store with which to associate the instance for TDE encryption. This setting doesn't apply to RDS Custom.
    public var tdeCredentialArn: Swift.String?
    /// The password for the given ARN from the key store in order to access the device. This setting doesn't apply to RDS Custom.
    public var tdeCredentialPassword: Swift.String?
    /// A value that indicates whether the DB instance class of the DB instance uses its default processor features. This setting doesn't apply to RDS Custom.
    public var useDefaultProcessorFeatures: Swift.Bool?
    /// A list of Amazon EC2 VPC security groups to authorize on this DB instance. This change is asynchronously applied as soon as possible. This setting doesn't apply to RDS Custom. Amazon Aurora Not applicable. The associated list of EC2 VPC security groups is managed by the DB cluster. For more information, see ModifyDBCluster. Constraints:
    ///
    /// * If supplied, must match existing VpcSecurityGroupIds.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        allocatedStorage: Swift.Int? = nil,
        allowMajorVersionUpgrade: Swift.Bool = false,
        applyImmediately: Swift.Bool = false,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        automationMode: RdsClientTypes.AutomationMode? = nil,
        awsBackupRecoveryPointArn: Swift.String? = nil,
        backupRetentionPeriod: Swift.Int? = nil,
        cACertificateIdentifier: Swift.String? = nil,
        certificateRotationRestart: Swift.Bool? = nil,
        cloudwatchLogsExportConfiguration: RdsClientTypes.CloudwatchLogsExportConfiguration? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        dBInstanceClass: Swift.String? = nil,
        dBInstanceIdentifier: Swift.String? = nil,
        dBParameterGroupName: Swift.String? = nil,
        dBPortNumber: Swift.Int? = nil,
        dBSecurityGroups: [Swift.String]? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        domainIAMRoleName: Swift.String? = nil,
        enableCustomerOwnedIp: Swift.Bool? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        enablePerformanceInsights: Swift.Bool? = nil,
        engineVersion: Swift.String? = nil,
        iops: Swift.Int? = nil,
        licenseModel: Swift.String? = nil,
        masterUserPassword: Swift.String? = nil,
        maxAllocatedStorage: Swift.Int? = nil,
        monitoringInterval: Swift.Int? = nil,
        monitoringRoleArn: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil,
        newDBInstanceIdentifier: Swift.String? = nil,
        optionGroupName: Swift.String? = nil,
        performanceInsightsKMSKeyId: Swift.String? = nil,
        performanceInsightsRetentionPeriod: Swift.Int? = nil,
        preferredBackupWindow: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        processorFeatures: [RdsClientTypes.ProcessorFeature]? = nil,
        promotionTier: Swift.Int? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        replicaMode: RdsClientTypes.ReplicaMode? = nil,
        resumeFullAutomationModeMinutes: Swift.Int? = nil,
        storageType: Swift.String? = nil,
        tdeCredentialArn: Swift.String? = nil,
        tdeCredentialPassword: Swift.String? = nil,
        useDefaultProcessorFeatures: Swift.Bool? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
        self.applyImmediately = applyImmediately
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.automationMode = automationMode
        self.awsBackupRecoveryPointArn = awsBackupRecoveryPointArn
        self.backupRetentionPeriod = backupRetentionPeriod
        self.cACertificateIdentifier = cACertificateIdentifier
        self.certificateRotationRestart = certificateRotationRestart
        self.cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfiguration
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBParameterGroupName = dBParameterGroupName
        self.dBPortNumber = dBPortNumber
        self.dBSecurityGroups = dBSecurityGroups
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCustomerOwnedIp = enableCustomerOwnedIp
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.enablePerformanceInsights = enablePerformanceInsights
        self.engineVersion = engineVersion
        self.iops = iops
        self.licenseModel = licenseModel
        self.masterUserPassword = masterUserPassword
        self.maxAllocatedStorage = maxAllocatedStorage
        self.monitoringInterval = monitoringInterval
        self.monitoringRoleArn = monitoringRoleArn
        self.multiAZ = multiAZ
        self.newDBInstanceIdentifier = newDBInstanceIdentifier
        self.optionGroupName = optionGroupName
        self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
        self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.processorFeatures = processorFeatures
        self.promotionTier = promotionTier
        self.publiclyAccessible = publiclyAccessible
        self.replicaMode = replicaMode
        self.resumeFullAutomationModeMinutes = resumeFullAutomationModeMinutes
        self.storageType = storageType
        self.tdeCredentialArn = tdeCredentialArn
        self.tdeCredentialPassword = tdeCredentialPassword
        self.useDefaultProcessorFeatures = useDefaultProcessorFeatures
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct ModifyDBInstanceInputBody: Swift.Equatable {
    let dBInstanceIdentifier: Swift.String?
    let allocatedStorage: Swift.Int?
    let dBInstanceClass: Swift.String?
    let dBSubnetGroupName: Swift.String?
    let dBSecurityGroups: [Swift.String]?
    let vpcSecurityGroupIds: [Swift.String]?
    let applyImmediately: Swift.Bool
    let masterUserPassword: Swift.String?
    let dBParameterGroupName: Swift.String?
    let backupRetentionPeriod: Swift.Int?
    let preferredBackupWindow: Swift.String?
    let preferredMaintenanceWindow: Swift.String?
    let multiAZ: Swift.Bool?
    let engineVersion: Swift.String?
    let allowMajorVersionUpgrade: Swift.Bool
    let autoMinorVersionUpgrade: Swift.Bool?
    let licenseModel: Swift.String?
    let iops: Swift.Int?
    let optionGroupName: Swift.String?
    let newDBInstanceIdentifier: Swift.String?
    let storageType: Swift.String?
    let tdeCredentialArn: Swift.String?
    let tdeCredentialPassword: Swift.String?
    let cACertificateIdentifier: Swift.String?
    let domain: Swift.String?
    let copyTagsToSnapshot: Swift.Bool?
    let monitoringInterval: Swift.Int?
    let dBPortNumber: Swift.Int?
    let publiclyAccessible: Swift.Bool?
    let monitoringRoleArn: Swift.String?
    let domainIAMRoleName: Swift.String?
    let promotionTier: Swift.Int?
    let enableIAMDatabaseAuthentication: Swift.Bool?
    let enablePerformanceInsights: Swift.Bool?
    let performanceInsightsKMSKeyId: Swift.String?
    let performanceInsightsRetentionPeriod: Swift.Int?
    let cloudwatchLogsExportConfiguration: RdsClientTypes.CloudwatchLogsExportConfiguration?
    let processorFeatures: [RdsClientTypes.ProcessorFeature]?
    let useDefaultProcessorFeatures: Swift.Bool?
    let deletionProtection: Swift.Bool?
    let maxAllocatedStorage: Swift.Int?
    let certificateRotationRestart: Swift.Bool?
    let replicaMode: RdsClientTypes.ReplicaMode?
    let enableCustomerOwnedIp: Swift.Bool?
    let awsBackupRecoveryPointArn: Swift.String?
    let automationMode: RdsClientTypes.AutomationMode?
    let resumeFullAutomationModeMinutes: Swift.Int?
}

extension ModifyDBInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case allowMajorVersionUpgrade = "AllowMajorVersionUpgrade"
        case applyImmediately = "ApplyImmediately"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case automationMode = "AutomationMode"
        case awsBackupRecoveryPointArn = "AwsBackupRecoveryPointArn"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case cACertificateIdentifier = "CACertificateIdentifier"
        case certificateRotationRestart = "CertificateRotationRestart"
        case cloudwatchLogsExportConfiguration = "CloudwatchLogsExportConfiguration"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case dBInstanceClass = "DBInstanceClass"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dBParameterGroupName = "DBParameterGroupName"
        case dBPortNumber = "DBPortNumber"
        case dBSecurityGroups = "DBSecurityGroups"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case deletionProtection = "DeletionProtection"
        case domain = "Domain"
        case domainIAMRoleName = "DomainIAMRoleName"
        case enableCustomerOwnedIp = "EnableCustomerOwnedIp"
        case enableIAMDatabaseAuthentication = "EnableIAMDatabaseAuthentication"
        case enablePerformanceInsights = "EnablePerformanceInsights"
        case engineVersion = "EngineVersion"
        case iops = "Iops"
        case licenseModel = "LicenseModel"
        case masterUserPassword = "MasterUserPassword"
        case maxAllocatedStorage = "MaxAllocatedStorage"
        case monitoringInterval = "MonitoringInterval"
        case monitoringRoleArn = "MonitoringRoleArn"
        case multiAZ = "MultiAZ"
        case newDBInstanceIdentifier = "NewDBInstanceIdentifier"
        case optionGroupName = "OptionGroupName"
        case performanceInsightsKMSKeyId = "PerformanceInsightsKMSKeyId"
        case performanceInsightsRetentionPeriod = "PerformanceInsightsRetentionPeriod"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case processorFeatures = "ProcessorFeatures"
        case promotionTier = "PromotionTier"
        case publiclyAccessible = "PubliclyAccessible"
        case replicaMode = "ReplicaMode"
        case resumeFullAutomationModeMinutes = "ResumeFullAutomationModeMinutes"
        case storageType = "StorageType"
        case tdeCredentialArn = "TdeCredentialArn"
        case tdeCredentialPassword = "TdeCredentialPassword"
        case useDefaultProcessorFeatures = "UseDefaultProcessorFeatures"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        if containerValues.contains(.dBSecurityGroups) {
            struct KeyVal0{struct DBSecurityGroupName{}}
            let dBSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSecurityGroupName>.CodingKeys.self, forKey: .dBSecurityGroups)
            if let dBSecurityGroupsWrappedContainer = dBSecurityGroupsWrappedContainer {
                let dBSecurityGroupsContainer = try dBSecurityGroupsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var dBSecurityGroupsBuffer:[Swift.String]? = nil
                if let dBSecurityGroupsContainer = dBSecurityGroupsContainer {
                    dBSecurityGroupsBuffer = [Swift.String]()
                    for stringContainer0 in dBSecurityGroupsContainer {
                        dBSecurityGroupsBuffer?.append(stringContainer0)
                    }
                }
                dBSecurityGroups = dBSecurityGroupsBuffer
            } else {
                dBSecurityGroups = []
            }
        } else {
            dBSecurityGroups = nil
        }
        if containerValues.contains(.vpcSecurityGroupIds) {
            struct KeyVal0{struct VpcSecurityGroupId{}}
            let vpcSecurityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupId>.CodingKeys.self, forKey: .vpcSecurityGroupIds)
            if let vpcSecurityGroupIdsWrappedContainer = vpcSecurityGroupIdsWrappedContainer {
                let vpcSecurityGroupIdsContainer = try vpcSecurityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSecurityGroupIdsBuffer:[Swift.String]? = nil
                if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
                    vpcSecurityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSecurityGroupIdsContainer {
                        vpcSecurityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupIds = vpcSecurityGroupIdsBuffer
            } else {
                vpcSecurityGroupIds = []
            }
        } else {
            vpcSecurityGroupIds = nil
        }
        let applyImmediatelyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .applyImmediately)
        applyImmediately = applyImmediatelyDecoded
        let masterUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUserPassword)
        masterUserPassword = masterUserPasswordDecoded
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let allowMajorVersionUpgradeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowMajorVersionUpgrade)
        allowMajorVersionUpgrade = allowMajorVersionUpgradeDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let newDBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newDBInstanceIdentifier)
        newDBInstanceIdentifier = newDBInstanceIdentifierDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let tdeCredentialArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tdeCredentialArn)
        tdeCredentialArn = tdeCredentialArnDecoded
        let tdeCredentialPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tdeCredentialPassword)
        tdeCredentialPassword = tdeCredentialPasswordDecoded
        let cACertificateIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cACertificateIdentifier)
        cACertificateIdentifier = cACertificateIdentifierDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let copyTagsToSnapshotDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let monitoringIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monitoringInterval)
        monitoringInterval = monitoringIntervalDecoded
        let dBPortNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dBPortNumber)
        dBPortNumber = dBPortNumberDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let monitoringRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitoringRoleArn)
        monitoringRoleArn = monitoringRoleArnDecoded
        let domainIAMRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainIAMRoleName)
        domainIAMRoleName = domainIAMRoleNameDecoded
        let promotionTierDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .promotionTier)
        promotionTier = promotionTierDecoded
        let enableIAMDatabaseAuthenticationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableIAMDatabaseAuthentication)
        enableIAMDatabaseAuthentication = enableIAMDatabaseAuthenticationDecoded
        let enablePerformanceInsightsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enablePerformanceInsights)
        enablePerformanceInsights = enablePerformanceInsightsDecoded
        let performanceInsightsKMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .performanceInsightsKMSKeyId)
        performanceInsightsKMSKeyId = performanceInsightsKMSKeyIdDecoded
        let performanceInsightsRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .performanceInsightsRetentionPeriod)
        performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriodDecoded
        let cloudwatchLogsExportConfigurationDecoded = try containerValues.decodeIfPresent(RdsClientTypes.CloudwatchLogsExportConfiguration.self, forKey: .cloudwatchLogsExportConfiguration)
        cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfigurationDecoded
        if containerValues.contains(.processorFeatures) {
            struct KeyVal0{struct ProcessorFeature{}}
            let processorFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ProcessorFeature>.CodingKeys.self, forKey: .processorFeatures)
            if let processorFeaturesWrappedContainer = processorFeaturesWrappedContainer {
                let processorFeaturesContainer = try processorFeaturesWrappedContainer.decodeIfPresent([RdsClientTypes.ProcessorFeature].self, forKey: .member)
                var processorFeaturesBuffer:[RdsClientTypes.ProcessorFeature]? = nil
                if let processorFeaturesContainer = processorFeaturesContainer {
                    processorFeaturesBuffer = [RdsClientTypes.ProcessorFeature]()
                    for structureContainer0 in processorFeaturesContainer {
                        processorFeaturesBuffer?.append(structureContainer0)
                    }
                }
                processorFeatures = processorFeaturesBuffer
            } else {
                processorFeatures = []
            }
        } else {
            processorFeatures = nil
        }
        let useDefaultProcessorFeaturesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaultProcessorFeatures)
        useDefaultProcessorFeatures = useDefaultProcessorFeaturesDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let maxAllocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAllocatedStorage)
        maxAllocatedStorage = maxAllocatedStorageDecoded
        let certificateRotationRestartDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .certificateRotationRestart)
        certificateRotationRestart = certificateRotationRestartDecoded
        let replicaModeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ReplicaMode.self, forKey: .replicaMode)
        replicaMode = replicaModeDecoded
        let enableCustomerOwnedIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableCustomerOwnedIp)
        enableCustomerOwnedIp = enableCustomerOwnedIpDecoded
        let awsBackupRecoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsBackupRecoveryPointArn)
        awsBackupRecoveryPointArn = awsBackupRecoveryPointArnDecoded
        let automationModeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.AutomationMode.self, forKey: .automationMode)
        automationMode = automationModeDecoded
        let resumeFullAutomationModeMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .resumeFullAutomationModeMinutes)
        resumeFullAutomationModeMinutes = resumeFullAutomationModeMinutesDecoded
    }
}

extension ModifyDBInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFound" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BackupPolicyNotFoundFault" : self = .backupPolicyNotFoundFault(try BackupPolicyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CertificateNotFound" : self = .certificateNotFoundFault(try CertificateNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceAlreadyExists" : self = .dBInstanceAlreadyExistsFault(try DBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFound" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBUpgradeDependencyFailure" : self = .dBUpgradeDependencyFailureFault(try DBUpgradeDependencyFailureFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacity" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSecurityGroupState" : self = .invalidDBSecurityGroupStateFault(try InvalidDBSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedIopsNotAvailableInAZFault" : self = .provisionedIopsNotAvailableInAZFault(try ProvisionedIopsNotAvailableInAZFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceeded" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupported" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBInstanceOutputError: Swift.Error, Swift.Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case backupPolicyNotFoundFault(BackupPolicyNotFoundFault)
    case certificateNotFoundFault(CertificateNotFoundFault)
    case dBInstanceAlreadyExistsFault(DBInstanceAlreadyExistsFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case dBUpgradeDependencyFailureFault(DBUpgradeDependencyFailureFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidDBSecurityGroupStateFault(InvalidDBSecurityGroupStateFault)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case provisionedIopsNotAvailableInAZFault(ProvisionedIopsNotAvailableInAZFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct ModifyDBInstanceOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB instance. This data type is used as a response element in the operations CreateDBInstance, CreateDBInstanceReadReplica, DeleteDBInstance, DescribeDBInstances, ModifyDBInstance, PromoteReadReplica, RebootDBInstance, RestoreDBInstanceFromDBSnapshot, RestoreDBInstanceFromS3, RestoreDBInstanceToPointInTime, StartDBInstance, and StopDBInstance.
    public var dBInstance: RdsClientTypes.DBInstance?

    public init (
        dBInstance: RdsClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct ModifyDBInstanceOutputResponseBody: Swift.Equatable {
    let dBInstance: RdsClientTypes.DBInstance?
}

extension ModifyDBInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

extension ModifyDBParameterGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: ClientRuntime.Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ModifyDBParameterGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ModifyDBParameterGroupInput: Swift.Equatable {
    /// The name of the DB parameter group. Constraints:
    ///
    /// * If supplied, must match the name of an existing DBParameterGroup.
    /// This member is required.
    public var dBParameterGroupName: Swift.String?
    /// An array of parameter names, values, and the application methods for the parameter update. At least one parameter name, value, and application method method must be supplied; later arguments are optional. A maximum of 20 parameters can be modified in a single request. Valid Values (for the application method): immediate | pending-reboot You can use the immediate value with dynamic parameters only. You can use the pending-reboot value for both dynamic and static parameters. When the application method is immediate, changes to dynamic parameters are applied immediately to the DB instances associated with the parameter group. When the application method is pending-reboot, changes to dynamic and static parameters are applied after a reboot without failover to the DB instances associated with the parameter group.
    /// This member is required.
    public var parameters: [RdsClientTypes.Parameter]?

    public init (
        dBParameterGroupName: Swift.String? = nil,
        parameters: [RdsClientTypes.Parameter]? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
        self.parameters = parameters
    }
}

struct ModifyDBParameterGroupInputBody: Swift.Equatable {
    let dBParameterGroupName: Swift.String?
    let parameters: [RdsClientTypes.Parameter]?
}

extension ModifyDBParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupName = "DBParameterGroupName"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct Parameter{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Parameter>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([RdsClientTypes.Parameter].self, forKey: .member)
                var parametersBuffer:[RdsClientTypes.Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [RdsClientTypes.Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
    }
}

extension ModifyDBParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupState" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBParameterGroupName = output.dBParameterGroupName
        } else {
            self.dBParameterGroupName = nil
        }
    }
}

/// Contains the result of a successful invocation of the ModifyDBParameterGroup or ResetDBParameterGroup action.
public struct ModifyDBParameterGroupOutputResponse: Swift.Equatable {
    /// The name of the DB parameter group.
    public var dBParameterGroupName: Swift.String?

    public init (
        dBParameterGroupName: Swift.String? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
    }
}

struct ModifyDBParameterGroupOutputResponseBody: Swift.Equatable {
    let dBParameterGroupName: Swift.String?
}

extension ModifyDBParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupName = "DBParameterGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBParameterGroupResult"))
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
    }
}

extension ModifyDBProxyEndpointInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBProxyEndpointName = dBProxyEndpointName {
            try container.encode(dBProxyEndpointName, forKey: ClientRuntime.Key("DBProxyEndpointName"))
        }
        if let newDBProxyEndpointName = newDBProxyEndpointName {
            try container.encode(newDBProxyEndpointName, forKey: ClientRuntime.Key("NewDBProxyEndpointName"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBProxyEndpoint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ModifyDBProxyEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyDBProxyEndpointInput: Swift.Equatable {
    /// The name of the DB proxy sociated with the DB proxy endpoint that you want to modify.
    /// This member is required.
    public var dBProxyEndpointName: Swift.String?
    /// The new identifier for the DBProxyEndpoint. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens.
    public var newDBProxyEndpointName: Swift.String?
    /// The VPC security group IDs for the DB proxy endpoint. When the DB proxy endpoint uses a different VPC than the original proxy, you also specify a different set of security group IDs than for the original proxy.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        dBProxyEndpointName: Swift.String? = nil,
        newDBProxyEndpointName: Swift.String? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.dBProxyEndpointName = dBProxyEndpointName
        self.newDBProxyEndpointName = newDBProxyEndpointName
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct ModifyDBProxyEndpointInputBody: Swift.Equatable {
    let dBProxyEndpointName: Swift.String?
    let newDBProxyEndpointName: Swift.String?
    let vpcSecurityGroupIds: [Swift.String]?
}

extension ModifyDBProxyEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxyEndpointName = "DBProxyEndpointName"
        case newDBProxyEndpointName = "NewDBProxyEndpointName"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBProxyEndpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyEndpointName)
        dBProxyEndpointName = dBProxyEndpointNameDecoded
        let newDBProxyEndpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newDBProxyEndpointName)
        newDBProxyEndpointName = newDBProxyEndpointNameDecoded
        if containerValues.contains(.vpcSecurityGroupIds) {
            struct KeyVal0{struct member{}}
            let vpcSecurityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .vpcSecurityGroupIds)
            if let vpcSecurityGroupIdsWrappedContainer = vpcSecurityGroupIdsWrappedContainer {
                let vpcSecurityGroupIdsContainer = try vpcSecurityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSecurityGroupIdsBuffer:[Swift.String]? = nil
                if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
                    vpcSecurityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSecurityGroupIdsContainer {
                        vpcSecurityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupIds = vpcSecurityGroupIdsBuffer
            } else {
                vpcSecurityGroupIds = []
            }
        } else {
            vpcSecurityGroupIds = nil
        }
    }
}

extension ModifyDBProxyEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBProxyEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyEndpointAlreadyExistsFault" : self = .dBProxyEndpointAlreadyExistsFault(try DBProxyEndpointAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyEndpointNotFoundFault" : self = .dBProxyEndpointNotFoundFault(try DBProxyEndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyEndpointStateFault" : self = .invalidDBProxyEndpointStateFault(try InvalidDBProxyEndpointStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBProxyEndpointOutputError: Swift.Error, Swift.Equatable {
    case dBProxyEndpointAlreadyExistsFault(DBProxyEndpointAlreadyExistsFault)
    case dBProxyEndpointNotFoundFault(DBProxyEndpointNotFoundFault)
    case invalidDBProxyEndpointStateFault(InvalidDBProxyEndpointStateFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBProxyEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBProxyEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBProxyEndpoint = output.dBProxyEndpoint
        } else {
            self.dBProxyEndpoint = nil
        }
    }
}

public struct ModifyDBProxyEndpointOutputResponse: Swift.Equatable {
    /// The DBProxyEndpoint object representing the new settings for the DB proxy endpoint.
    public var dBProxyEndpoint: RdsClientTypes.DBProxyEndpoint?

    public init (
        dBProxyEndpoint: RdsClientTypes.DBProxyEndpoint? = nil
    )
    {
        self.dBProxyEndpoint = dBProxyEndpoint
    }
}

struct ModifyDBProxyEndpointOutputResponseBody: Swift.Equatable {
    let dBProxyEndpoint: RdsClientTypes.DBProxyEndpoint?
}

extension ModifyDBProxyEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxyEndpoint = "DBProxyEndpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBProxyEndpointResult"))
        let dBProxyEndpointDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBProxyEndpoint.self, forKey: .dBProxyEndpoint)
        dBProxyEndpoint = dBProxyEndpointDecoded
    }
}

extension ModifyDBProxyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let auth = auth {
            var authContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Auth"))
            for (index0, userauthconfig0) in auth.enumerated() {
                try authContainer.encode(userauthconfig0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if let debugLogging = debugLogging {
            try container.encode(debugLogging, forKey: ClientRuntime.Key("DebugLogging"))
        }
        if let idleClientTimeout = idleClientTimeout {
            try container.encode(idleClientTimeout, forKey: ClientRuntime.Key("IdleClientTimeout"))
        }
        if let newDBProxyName = newDBProxyName {
            try container.encode(newDBProxyName, forKey: ClientRuntime.Key("NewDBProxyName"))
        }
        if let requireTLS = requireTLS {
            try container.encode(requireTLS, forKey: ClientRuntime.Key("RequireTLS"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SecurityGroups"))
            for (index0, string0) in securityGroups.enumerated() {
                try securityGroupsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBProxy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ModifyDBProxyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyDBProxyInput: Swift.Equatable {
    /// The new authentication settings for the DBProxy.
    public var auth: [RdsClientTypes.UserAuthConfig]?
    /// The identifier for the DBProxy to modify.
    /// This member is required.
    public var dBProxyName: Swift.String?
    /// Whether the proxy includes detailed information about SQL statements in its logs. This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections. The debug information includes the text of SQL statements that you submit through the proxy. Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive information that appears in the logs.
    public var debugLogging: Swift.Bool?
    /// The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it. You can set this value higher or lower than the connection timeout limit for the associated database.
    public var idleClientTimeout: Swift.Int?
    /// The new identifier for the DBProxy. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens.
    public var newDBProxyName: Swift.String?
    /// Whether Transport Layer Security (TLS) encryption is required for connections to the proxy. By enabling this setting, you can enforce encrypted TLS connections to the proxy, even if the associated database doesn't use TLS.
    public var requireTLS: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the IAM role that the proxy uses to access secrets in Amazon Web Services Secrets Manager.
    public var roleArn: Swift.String?
    /// The new list of security groups for the DBProxy.
    public var securityGroups: [Swift.String]?

    public init (
        auth: [RdsClientTypes.UserAuthConfig]? = nil,
        dBProxyName: Swift.String? = nil,
        debugLogging: Swift.Bool? = nil,
        idleClientTimeout: Swift.Int? = nil,
        newDBProxyName: Swift.String? = nil,
        requireTLS: Swift.Bool? = nil,
        roleArn: Swift.String? = nil,
        securityGroups: [Swift.String]? = nil
    )
    {
        self.auth = auth
        self.dBProxyName = dBProxyName
        self.debugLogging = debugLogging
        self.idleClientTimeout = idleClientTimeout
        self.newDBProxyName = newDBProxyName
        self.requireTLS = requireTLS
        self.roleArn = roleArn
        self.securityGroups = securityGroups
    }
}

struct ModifyDBProxyInputBody: Swift.Equatable {
    let dBProxyName: Swift.String?
    let newDBProxyName: Swift.String?
    let auth: [RdsClientTypes.UserAuthConfig]?
    let requireTLS: Swift.Bool?
    let idleClientTimeout: Swift.Int?
    let debugLogging: Swift.Bool?
    let roleArn: Swift.String?
    let securityGroups: [Swift.String]?
}

extension ModifyDBProxyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auth = "Auth"
        case dBProxyName = "DBProxyName"
        case debugLogging = "DebugLogging"
        case idleClientTimeout = "IdleClientTimeout"
        case newDBProxyName = "NewDBProxyName"
        case requireTLS = "RequireTLS"
        case roleArn = "RoleArn"
        case securityGroups = "SecurityGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBProxyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyName)
        dBProxyName = dBProxyNameDecoded
        let newDBProxyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newDBProxyName)
        newDBProxyName = newDBProxyNameDecoded
        if containerValues.contains(.auth) {
            struct KeyVal0{struct member{}}
            let authWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .auth)
            if let authWrappedContainer = authWrappedContainer {
                let authContainer = try authWrappedContainer.decodeIfPresent([RdsClientTypes.UserAuthConfig].self, forKey: .member)
                var authBuffer:[RdsClientTypes.UserAuthConfig]? = nil
                if let authContainer = authContainer {
                    authBuffer = [RdsClientTypes.UserAuthConfig]()
                    for structureContainer0 in authContainer {
                        authBuffer?.append(structureContainer0)
                    }
                }
                auth = authBuffer
            } else {
                auth = []
            }
        } else {
            auth = nil
        }
        let requireTLSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireTLS)
        requireTLS = requireTLSDecoded
        let idleClientTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleClientTimeout)
        idleClientTimeout = idleClientTimeoutDecoded
        let debugLoggingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .debugLogging)
        debugLogging = debugLoggingDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        if containerValues.contains(.securityGroups) {
            struct KeyVal0{struct member{}}
            let securityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .securityGroups)
            if let securityGroupsWrappedContainer = securityGroupsWrappedContainer {
                let securityGroupsContainer = try securityGroupsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var securityGroupsBuffer:[Swift.String]? = nil
                if let securityGroupsContainer = securityGroupsContainer {
                    securityGroupsBuffer = [Swift.String]()
                    for stringContainer0 in securityGroupsContainer {
                        securityGroupsBuffer?.append(stringContainer0)
                    }
                }
                securityGroups = securityGroupsBuffer
            } else {
                securityGroups = []
            }
        } else {
            securityGroups = nil
        }
    }
}

extension ModifyDBProxyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBProxyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyAlreadyExistsFault" : self = .dBProxyAlreadyExistsFault(try DBProxyAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBProxyOutputError: Swift.Error, Swift.Equatable {
    case dBProxyAlreadyExistsFault(DBProxyAlreadyExistsFault)
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBProxyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBProxyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBProxy = output.dBProxy
        } else {
            self.dBProxy = nil
        }
    }
}

public struct ModifyDBProxyOutputResponse: Swift.Equatable {
    /// The DBProxy object representing the new settings for the proxy.
    public var dBProxy: RdsClientTypes.DBProxy?

    public init (
        dBProxy: RdsClientTypes.DBProxy? = nil
    )
    {
        self.dBProxy = dBProxy
    }
}

struct ModifyDBProxyOutputResponseBody: Swift.Equatable {
    let dBProxy: RdsClientTypes.DBProxy?
}

extension ModifyDBProxyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxy = "DBProxy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBProxyResult"))
        let dBProxyDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBProxy.self, forKey: .dBProxy)
        dBProxy = dBProxyDecoded
    }
}

extension ModifyDBProxyTargetGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let connectionPoolConfig = connectionPoolConfig {
            try container.encode(connectionPoolConfig, forKey: ClientRuntime.Key("ConnectionPoolConfig"))
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if let newName = newName {
            try container.encode(newName, forKey: ClientRuntime.Key("NewName"))
        }
        if let targetGroupName = targetGroupName {
            try container.encode(targetGroupName, forKey: ClientRuntime.Key("TargetGroupName"))
        }
        try container.encode("ModifyDBProxyTargetGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ModifyDBProxyTargetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyDBProxyTargetGroupInput: Swift.Equatable {
    /// The settings that determine the size and behavior of the connection pool for the target group.
    public var connectionPoolConfig: RdsClientTypes.ConnectionPoolConfiguration?
    /// The name of the new proxy to which to assign the target group.
    /// This member is required.
    public var dBProxyName: Swift.String?
    /// The new name for the modified DBProxyTarget. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens.
    public var newName: Swift.String?
    /// The name of the new target group to assign to the proxy.
    /// This member is required.
    public var targetGroupName: Swift.String?

    public init (
        connectionPoolConfig: RdsClientTypes.ConnectionPoolConfiguration? = nil,
        dBProxyName: Swift.String? = nil,
        newName: Swift.String? = nil,
        targetGroupName: Swift.String? = nil
    )
    {
        self.connectionPoolConfig = connectionPoolConfig
        self.dBProxyName = dBProxyName
        self.newName = newName
        self.targetGroupName = targetGroupName
    }
}

struct ModifyDBProxyTargetGroupInputBody: Swift.Equatable {
    let targetGroupName: Swift.String?
    let dBProxyName: Swift.String?
    let connectionPoolConfig: RdsClientTypes.ConnectionPoolConfiguration?
    let newName: Swift.String?
}

extension ModifyDBProxyTargetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionPoolConfig = "ConnectionPoolConfig"
        case dBProxyName = "DBProxyName"
        case newName = "NewName"
        case targetGroupName = "TargetGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetGroupName)
        targetGroupName = targetGroupNameDecoded
        let dBProxyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyName)
        dBProxyName = dBProxyNameDecoded
        let connectionPoolConfigDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ConnectionPoolConfiguration.self, forKey: .connectionPoolConfig)
        connectionPoolConfig = connectionPoolConfigDecoded
        let newNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newName)
        newName = newNameDecoded
    }
}

extension ModifyDBProxyTargetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBProxyTargetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBProxyTargetGroupOutputError: Swift.Error, Swift.Equatable {
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBProxyTargetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBProxyTargetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBProxyTargetGroup = output.dBProxyTargetGroup
        } else {
            self.dBProxyTargetGroup = nil
        }
    }
}

public struct ModifyDBProxyTargetGroupOutputResponse: Swift.Equatable {
    /// The settings of the modified DBProxyTarget.
    public var dBProxyTargetGroup: RdsClientTypes.DBProxyTargetGroup?

    public init (
        dBProxyTargetGroup: RdsClientTypes.DBProxyTargetGroup? = nil
    )
    {
        self.dBProxyTargetGroup = dBProxyTargetGroup
    }
}

struct ModifyDBProxyTargetGroupOutputResponseBody: Swift.Equatable {
    let dBProxyTargetGroup: RdsClientTypes.DBProxyTargetGroup?
}

extension ModifyDBProxyTargetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxyTargetGroup = "DBProxyTargetGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBProxyTargetGroupResult"))
        let dBProxyTargetGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBProxyTargetGroup.self, forKey: .dBProxyTargetGroup)
        dBProxyTargetGroup = dBProxyTargetGroupDecoded
    }
}

extension ModifyDBSnapshotAttributeInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: ClientRuntime.Key("AttributeName"))
        }
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: ClientRuntime.Key("DBSnapshotIdentifier"))
        }
        if let valuesToAdd = valuesToAdd {
            var valuesToAddContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ValuesToAdd"))
            for (index0, string0) in valuesToAdd.enumerated() {
                try valuesToAddContainer.encode(string0, forKey: ClientRuntime.Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
        if let valuesToRemove = valuesToRemove {
            var valuesToRemoveContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ValuesToRemove"))
            for (index0, string0) in valuesToRemove.enumerated() {
                try valuesToRemoveContainer.encode(string0, forKey: ClientRuntime.Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBSnapshotAttribute", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ModifyDBSnapshotAttributeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ModifyDBSnapshotAttributeInput: Swift.Equatable {
    /// The name of the DB snapshot attribute to modify. To manage authorization for other Amazon Web Services accounts to copy or restore a manual DB snapshot, set this value to restore. To view the list of attributes available to modify, use the [DescribeDBSnapshotAttributes] API action.
    /// This member is required.
    public var attributeName: Swift.String?
    /// The identifier for the DB snapshot to modify the attributes for.
    /// This member is required.
    public var dBSnapshotIdentifier: Swift.String?
    /// A list of DB snapshot attributes to add to the attribute specified by AttributeName. To authorize other Amazon Web Services accounts to copy or restore a manual snapshot, set this list to include one or more Amazon Web Services account IDs, or all to make the manual DB snapshot restorable by any Amazon Web Services account. Do not add the all value for any manual DB snapshots that contain private information that you don't want available to all Amazon Web Services accounts.
    public var valuesToAdd: [Swift.String]?
    /// A list of DB snapshot attributes to remove from the attribute specified by AttributeName. To remove authorization for other Amazon Web Services accounts to copy or restore a manual snapshot, set this list to include one or more Amazon Web Services account identifiers, or all to remove authorization for any Amazon Web Services account to copy or restore the DB snapshot. If you specify all, an Amazon Web Services account whose account ID is explicitly added to the restore attribute can still copy or restore the manual DB snapshot.
    public var valuesToRemove: [Swift.String]?

    public init (
        attributeName: Swift.String? = nil,
        dBSnapshotIdentifier: Swift.String? = nil,
        valuesToAdd: [Swift.String]? = nil,
        valuesToRemove: [Swift.String]? = nil
    )
    {
        self.attributeName = attributeName
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
        self.valuesToAdd = valuesToAdd
        self.valuesToRemove = valuesToRemove
    }
}

struct ModifyDBSnapshotAttributeInputBody: Swift.Equatable {
    let dBSnapshotIdentifier: Swift.String?
    let attributeName: Swift.String?
    let valuesToAdd: [Swift.String]?
    let valuesToRemove: [Swift.String]?
}

extension ModifyDBSnapshotAttributeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case dBSnapshotIdentifier = "DBSnapshotIdentifier"
        case valuesToAdd = "ValuesToAdd"
        case valuesToRemove = "ValuesToRemove"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSnapshotIdentifier)
        dBSnapshotIdentifier = dBSnapshotIdentifierDecoded
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        if containerValues.contains(.valuesToAdd) {
            struct KeyVal0{struct AttributeValue{}}
            let valuesToAddWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AttributeValue>.CodingKeys.self, forKey: .valuesToAdd)
            if let valuesToAddWrappedContainer = valuesToAddWrappedContainer {
                let valuesToAddContainer = try valuesToAddWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var valuesToAddBuffer:[Swift.String]? = nil
                if let valuesToAddContainer = valuesToAddContainer {
                    valuesToAddBuffer = [Swift.String]()
                    for stringContainer0 in valuesToAddContainer {
                        valuesToAddBuffer?.append(stringContainer0)
                    }
                }
                valuesToAdd = valuesToAddBuffer
            } else {
                valuesToAdd = []
            }
        } else {
            valuesToAdd = nil
        }
        if containerValues.contains(.valuesToRemove) {
            struct KeyVal0{struct AttributeValue{}}
            let valuesToRemoveWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AttributeValue>.CodingKeys.self, forKey: .valuesToRemove)
            if let valuesToRemoveWrappedContainer = valuesToRemoveWrappedContainer {
                let valuesToRemoveContainer = try valuesToRemoveWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var valuesToRemoveBuffer:[Swift.String]? = nil
                if let valuesToRemoveContainer = valuesToRemoveContainer {
                    valuesToRemoveBuffer = [Swift.String]()
                    for stringContainer0 in valuesToRemoveContainer {
                        valuesToRemoveBuffer?.append(stringContainer0)
                    }
                }
                valuesToRemove = valuesToRemoveBuffer
            } else {
                valuesToRemove = []
            }
        } else {
            valuesToRemove = nil
        }
    }
}

extension ModifyDBSnapshotAttributeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBSnapshotAttributeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSnapshotState" : self = .invalidDBSnapshotStateFault(try InvalidDBSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SharedSnapshotQuotaExceeded" : self = .sharedSnapshotQuotaExceededFault(try SharedSnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBSnapshotAttributeOutputError: Swift.Error, Swift.Equatable {
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case invalidDBSnapshotStateFault(InvalidDBSnapshotStateFault)
    case sharedSnapshotQuotaExceededFault(SharedSnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBSnapshotAttributeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBSnapshotAttributeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSnapshotAttributesResult = output.dBSnapshotAttributesResult
        } else {
            self.dBSnapshotAttributesResult = nil
        }
    }
}

public struct ModifyDBSnapshotAttributeOutputResponse: Swift.Equatable {
    /// Contains the results of a successful call to the DescribeDBSnapshotAttributes API action. Manual DB snapshot attributes are used to authorize other Amazon Web Services accounts to copy or restore a manual DB snapshot. For more information, see the ModifyDBSnapshotAttribute API action.
    public var dBSnapshotAttributesResult: RdsClientTypes.DBSnapshotAttributesResult?

    public init (
        dBSnapshotAttributesResult: RdsClientTypes.DBSnapshotAttributesResult? = nil
    )
    {
        self.dBSnapshotAttributesResult = dBSnapshotAttributesResult
    }
}

struct ModifyDBSnapshotAttributeOutputResponseBody: Swift.Equatable {
    let dBSnapshotAttributesResult: RdsClientTypes.DBSnapshotAttributesResult?
}

extension ModifyDBSnapshotAttributeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSnapshotAttributesResult = "DBSnapshotAttributesResult"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBSnapshotAttributeResult"))
        let dBSnapshotAttributesResultDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSnapshotAttributesResult.self, forKey: .dBSnapshotAttributesResult)
        dBSnapshotAttributesResult = dBSnapshotAttributesResultDecoded
    }
}

extension ModifyDBSnapshotInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: ClientRuntime.Key("DBSnapshotIdentifier"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        try container.encode("ModifyDBSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ModifyDBSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyDBSnapshotInput: Swift.Equatable {
    /// The identifier of the DB snapshot to modify.
    /// This member is required.
    public var dBSnapshotIdentifier: Swift.String?
    /// The engine version to upgrade the DB snapshot to. The following are the database engines and engine versions that are available when you upgrade a DB snapshot. MySQL
    ///
    /// * 5.5.46 (supported for 5.1 DB snapshots)
    ///
    ///
    /// Oracle
    ///
    /// * 12.1.0.2.v8 (supported for 12.1.0.1 DB snapshots)
    ///
    /// * 11.2.0.4.v12 (supported for 11.2.0.2 DB snapshots)
    ///
    /// * 11.2.0.4.v11 (supported for 11.2.0.3 DB snapshots)
    ///
    ///
    /// PostgreSQL For the list of engine versions that are available for upgrading a DB snapshot, see [ Upgrading the PostgreSQL DB Engine for Amazon RDS](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.PostgreSQL.html#USER_UpgradeDBInstance.PostgreSQL.MajorVersion).
    public var engineVersion: Swift.String?
    /// The option group to identify with the upgraded DB snapshot. You can specify this parameter when you upgrade an Oracle DB snapshot. The same option group considerations apply when upgrading a DB snapshot as when upgrading a DB instance. For more information, see [Option group considerations](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Oracle.html#USER_UpgradeDBInstance.Oracle.OGPG.OG) in the Amazon RDS User Guide.
    public var optionGroupName: Swift.String?

    public init (
        dBSnapshotIdentifier: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        optionGroupName: Swift.String? = nil
    )
    {
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
        self.engineVersion = engineVersion
        self.optionGroupName = optionGroupName
    }
}

struct ModifyDBSnapshotInputBody: Swift.Equatable {
    let dBSnapshotIdentifier: Swift.String?
    let engineVersion: Swift.String?
    let optionGroupName: Swift.String?
}

extension ModifyDBSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSnapshotIdentifier = "DBSnapshotIdentifier"
        case engineVersion = "EngineVersion"
        case optionGroupName = "OptionGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSnapshotIdentifier)
        dBSnapshotIdentifier = dBSnapshotIdentifierDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
    }
}

extension ModifyDBSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBSnapshotOutputError: Swift.Error, Swift.Equatable {
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSnapshot = output.dBSnapshot
        } else {
            self.dBSnapshot = nil
        }
    }
}

public struct ModifyDBSnapshotOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB snapshot. This data type is used as a response element in the DescribeDBSnapshots action.
    public var dBSnapshot: RdsClientTypes.DBSnapshot?

    public init (
        dBSnapshot: RdsClientTypes.DBSnapshot? = nil
    )
    {
        self.dBSnapshot = dBSnapshot
    }
}

struct ModifyDBSnapshotOutputResponseBody: Swift.Equatable {
    let dBSnapshot: RdsClientTypes.DBSnapshot?
}

extension ModifyDBSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSnapshot = "DBSnapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBSnapshotResult"))
        let dBSnapshotDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSnapshot.self, forKey: .dBSnapshot)
        dBSnapshot = dBSnapshotDecoded
    }
}

extension ModifyDBSubnetGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSubnetGroupDescription = dBSubnetGroupDescription {
            try container.encode(dBSubnetGroupDescription, forKey: ClientRuntime.Key("DBSubnetGroupDescription"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SubnetIds"))
            for (index0, string0) in subnetIds.enumerated() {
                try subnetIdsContainer.encode(string0, forKey: ClientRuntime.Key("SubnetIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBSubnetGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ModifyDBSubnetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ModifyDBSubnetGroupInput: Swift.Equatable {
    /// The description for the DB subnet group.
    public var dBSubnetGroupDescription: Swift.String?
    /// The name for the DB subnet group. This value is stored as a lowercase string. You can't modify the default subnet group. Constraints: Must match the name of an existing DBSubnetGroup. Must not be default. Example: mySubnetgroup
    /// This member is required.
    public var dBSubnetGroupName: Swift.String?
    /// The EC2 subnet IDs for the DB subnet group.
    /// This member is required.
    public var subnetIds: [Swift.String]?

    public init (
        dBSubnetGroupDescription: Swift.String? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil
    )
    {
        self.dBSubnetGroupDescription = dBSubnetGroupDescription
        self.dBSubnetGroupName = dBSubnetGroupName
        self.subnetIds = subnetIds
    }
}

struct ModifyDBSubnetGroupInputBody: Swift.Equatable {
    let dBSubnetGroupName: Swift.String?
    let dBSubnetGroupDescription: Swift.String?
    let subnetIds: [Swift.String]?
}

extension ModifyDBSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSubnetGroupDescription = "DBSubnetGroupDescription"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case subnetIds = "SubnetIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        let dBSubnetGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupDescription)
        dBSubnetGroupDescription = dBSubnetGroupDescriptionDecoded
        if containerValues.contains(.subnetIds) {
            struct KeyVal0{struct SubnetIdentifier{}}
            let subnetIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SubnetIdentifier>.CodingKeys.self, forKey: .subnetIds)
            if let subnetIdsWrappedContainer = subnetIdsWrappedContainer {
                let subnetIdsContainer = try subnetIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var subnetIdsBuffer:[Swift.String]? = nil
                if let subnetIdsContainer = subnetIdsContainer {
                    subnetIdsBuffer = [Swift.String]()
                    for stringContainer0 in subnetIdsContainer {
                        subnetIdsBuffer?.append(stringContainer0)
                    }
                }
                subnetIds = subnetIdsBuffer
            } else {
                subnetIds = []
            }
        } else {
            subnetIds = nil
        }
    }
}

extension ModifyDBSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetQuotaExceededFault" : self = .dBSubnetQuotaExceededFault(try DBSubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetAlreadyInUse" : self = .subnetAlreadyInUse(try SubnetAlreadyInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case dBSubnetQuotaExceededFault(DBSubnetQuotaExceededFault)
    case invalidSubnet(InvalidSubnet)
    case subnetAlreadyInUse(SubnetAlreadyInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSubnetGroup = output.dBSubnetGroup
        } else {
            self.dBSubnetGroup = nil
        }
    }
}

public struct ModifyDBSubnetGroupOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB subnet group. This data type is used as a response element in the DescribeDBSubnetGroups action.
    public var dBSubnetGroup: RdsClientTypes.DBSubnetGroup?

    public init (
        dBSubnetGroup: RdsClientTypes.DBSubnetGroup? = nil
    )
    {
        self.dBSubnetGroup = dBSubnetGroup
    }
}

struct ModifyDBSubnetGroupOutputResponseBody: Swift.Equatable {
    let dBSubnetGroup: RdsClientTypes.DBSubnetGroup?
}

extension ModifyDBSubnetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSubnetGroup = "DBSubnetGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBSubnetGroupResult"))
        let dBSubnetGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSubnetGroup.self, forKey: .dBSubnetGroup)
        dBSubnetGroup = dBSubnetGroupDecoded
    }
}

extension ModifyEventSubscriptionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: ClientRuntime.Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let snsTopicArn = snsTopicArn {
            try container.encode(snsTopicArn, forKey: ClientRuntime.Key("SnsTopicArn"))
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: ClientRuntime.Key("SubscriptionName"))
        }
        try container.encode("ModifyEventSubscription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ModifyEventSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ModifyEventSubscriptionInput: Swift.Equatable {
    /// A value that indicates whether to activate the subscription.
    public var enabled: Swift.Bool?
    /// A list of event categories for a source type (SourceType) that you want to subscribe to. You can see a list of the categories for a given source type in [Events](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Events.html) in the Amazon RDS User Guide or by using the DescribeEventCategories operation.
    public var eventCategories: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
    public var snsTopicArn: Swift.String?
    /// The type of source that is generating the events. For example, if you want to be notified of events generated by a DB instance, you would set this parameter to db-instance. If this value isn't specified, all events are returned. Valid values: db-instance | db-cluster | db-parameter-group | db-security-group | db-snapshot | db-cluster-snapshot
    public var sourceType: Swift.String?
    /// The name of the RDS event notification subscription.
    /// This member is required.
    public var subscriptionName: Swift.String?

    public init (
        enabled: Swift.Bool? = nil,
        eventCategories: [Swift.String]? = nil,
        snsTopicArn: Swift.String? = nil,
        sourceType: Swift.String? = nil,
        subscriptionName: Swift.String? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.snsTopicArn = snsTopicArn
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
    }
}

struct ModifyEventSubscriptionInputBody: Swift.Equatable {
    let subscriptionName: Swift.String?
    let snsTopicArn: Swift.String?
    let sourceType: Swift.String?
    let eventCategories: [Swift.String]?
    let enabled: Swift.Bool?
}

extension ModifyEventSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case eventCategories = "EventCategories"
        case snsTopicArn = "SnsTopicArn"
        case sourceType = "SourceType"
        case subscriptionName = "SubscriptionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        if containerValues.contains(.eventCategories) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategories)
            if let eventCategoriesWrappedContainer = eventCategoriesWrappedContainer {
                let eventCategoriesContainer = try eventCategoriesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var eventCategoriesBuffer:[Swift.String]? = nil
                if let eventCategoriesContainer = eventCategoriesContainer {
                    eventCategoriesBuffer = [Swift.String]()
                    for stringContainer0 in eventCategoriesContainer {
                        eventCategoriesBuffer?.append(stringContainer0)
                    }
                }
                eventCategories = eventCategoriesBuffer
            } else {
                eventCategories = []
            }
        } else {
            eventCategories = nil
        }
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension ModifyEventSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyEventSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EventSubscriptionQuotaExceeded" : self = .eventSubscriptionQuotaExceededFault(try EventSubscriptionQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSInvalidTopic" : self = .sNSInvalidTopicFault(try SNSInvalidTopicFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSNoAuthorization" : self = .sNSNoAuthorizationFault(try SNSNoAuthorizationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSTopicArnNotFound" : self = .sNSTopicArnNotFoundFault(try SNSTopicArnNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionCategoryNotFound" : self = .subscriptionCategoryNotFoundFault(try SubscriptionCategoryNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFound" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyEventSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case eventSubscriptionQuotaExceededFault(EventSubscriptionQuotaExceededFault)
    case sNSInvalidTopicFault(SNSInvalidTopicFault)
    case sNSNoAuthorizationFault(SNSNoAuthorizationFault)
    case sNSTopicArnNotFoundFault(SNSTopicArnNotFoundFault)
    case subscriptionCategoryNotFoundFault(SubscriptionCategoryNotFoundFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyEventSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct ModifyEventSubscriptionOutputResponse: Swift.Equatable {
    /// Contains the results of a successful invocation of the DescribeEventSubscriptions action.
    public var eventSubscription: RdsClientTypes.EventSubscription?

    public init (
        eventSubscription: RdsClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct ModifyEventSubscriptionOutputResponseBody: Swift.Equatable {
    let eventSubscription: RdsClientTypes.EventSubscription?
}

extension ModifyEventSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyEventSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(RdsClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

extension ModifyGlobalClusterInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allowMajorVersionUpgrade = allowMajorVersionUpgrade {
            try container.encode(allowMajorVersionUpgrade, forKey: ClientRuntime.Key("AllowMajorVersionUpgrade"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: ClientRuntime.Key("GlobalClusterIdentifier"))
        }
        if let newGlobalClusterIdentifier = newGlobalClusterIdentifier {
            try container.encode(newGlobalClusterIdentifier, forKey: ClientRuntime.Key("NewGlobalClusterIdentifier"))
        }
        try container.encode("ModifyGlobalCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ModifyGlobalClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyGlobalClusterInput: Swift.Equatable {
    /// A value that indicates whether major version upgrades are allowed. Constraints: You must allow major version upgrades when specifying a value for the EngineVersion parameter that is a different major version than the DB cluster's current version. If you upgrade the major version of a global database, the cluster and DB instance parameter groups are set to the default parameter groups for the new version. Apply any custom parameter groups after completing the upgrade.
    public var allowMajorVersionUpgrade: Swift.Bool?
    /// Indicates if the global database cluster has deletion protection enabled. The global database cluster can't be deleted when deletion protection is enabled.
    public var deletionProtection: Swift.Bool?
    /// The version number of the database engine to which you want to upgrade. Changing this parameter results in an outage. The change is applied during the next maintenance window unless ApplyImmediately is enabled. To list all of the available engine versions for aurora (for MySQL 5.6-compatible Aurora), use the following command: aws rds describe-db-engine-versions --engine aurora --query '*[]|[?SupportsGlobalDatabases == `true`].[EngineVersion]' To list all of the available engine versions for aurora-mysql (for MySQL 5.7-compatible Aurora), use the following command: aws rds describe-db-engine-versions --engine aurora-mysql --query '*[]|[?SupportsGlobalDatabases == `true`].[EngineVersion]' To list all of the available engine versions for aurora-postgresql, use the following command: aws rds describe-db-engine-versions --engine aurora-postgresql --query '*[]|[?SupportsGlobalDatabases == `true`].[EngineVersion]'
    public var engineVersion: Swift.String?
    /// The DB cluster identifier for the global cluster being modified. This parameter isn't case-sensitive. Constraints:
    ///
    /// * Must match the identifier of an existing global database cluster.
    public var globalClusterIdentifier: Swift.String?
    /// The new cluster identifier for the global database cluster when modifying a global database cluster. This value is stored as a lowercase string. Constraints:
    ///
    /// * Must contain from 1 to 63 letters, numbers, or hyphens
    ///
    /// * The first character must be a letter
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    /// Example: my-cluster2
    public var newGlobalClusterIdentifier: Swift.String?

    public init (
        allowMajorVersionUpgrade: Swift.Bool? = nil,
        deletionProtection: Swift.Bool? = nil,
        engineVersion: Swift.String? = nil,
        globalClusterIdentifier: Swift.String? = nil,
        newGlobalClusterIdentifier: Swift.String? = nil
    )
    {
        self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
        self.deletionProtection = deletionProtection
        self.engineVersion = engineVersion
        self.globalClusterIdentifier = globalClusterIdentifier
        self.newGlobalClusterIdentifier = newGlobalClusterIdentifier
    }
}

struct ModifyGlobalClusterInputBody: Swift.Equatable {
    let globalClusterIdentifier: Swift.String?
    let newGlobalClusterIdentifier: Swift.String?
    let deletionProtection: Swift.Bool?
    let engineVersion: Swift.String?
    let allowMajorVersionUpgrade: Swift.Bool?
}

extension ModifyGlobalClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowMajorVersionUpgrade = "AllowMajorVersionUpgrade"
        case deletionProtection = "DeletionProtection"
        case engineVersion = "EngineVersion"
        case globalClusterIdentifier = "GlobalClusterIdentifier"
        case newGlobalClusterIdentifier = "NewGlobalClusterIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalClusterIdentifier)
        globalClusterIdentifier = globalClusterIdentifierDecoded
        let newGlobalClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newGlobalClusterIdentifier)
        newGlobalClusterIdentifier = newGlobalClusterIdentifierDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let allowMajorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowMajorVersionUpgrade)
        allowMajorVersionUpgrade = allowMajorVersionUpgradeDecoded
    }
}

extension ModifyGlobalClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyGlobalClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "GlobalClusterNotFoundFault" : self = .globalClusterNotFoundFault(try GlobalClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGlobalClusterStateFault" : self = .invalidGlobalClusterStateFault(try InvalidGlobalClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyGlobalClusterOutputError: Swift.Error, Swift.Equatable {
    case globalClusterNotFoundFault(GlobalClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidGlobalClusterStateFault(InvalidGlobalClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyGlobalClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyGlobalClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalCluster = output.globalCluster
        } else {
            self.globalCluster = nil
        }
    }
}

public struct ModifyGlobalClusterOutputResponse: Swift.Equatable {
    /// A data type representing an Aurora global database.
    public var globalCluster: RdsClientTypes.GlobalCluster?

    public init (
        globalCluster: RdsClientTypes.GlobalCluster? = nil
    )
    {
        self.globalCluster = globalCluster
    }
}

struct ModifyGlobalClusterOutputResponseBody: Swift.Equatable {
    let globalCluster: RdsClientTypes.GlobalCluster?
}

extension ModifyGlobalClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalCluster = "GlobalCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyGlobalClusterResult"))
        let globalClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.GlobalCluster.self, forKey: .globalCluster)
        globalCluster = globalClusterDecoded
    }
}

extension ModifyOptionGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if applyImmediately != false {
            try container.encode(applyImmediately, forKey: ClientRuntime.Key("ApplyImmediately"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let optionsToInclude = optionsToInclude {
            var optionsToIncludeContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OptionsToInclude"))
            for (index0, optionconfiguration0) in optionsToInclude.enumerated() {
                try optionsToIncludeContainer.encode(optionconfiguration0, forKey: ClientRuntime.Key("OptionConfiguration.\(index0.advanced(by: 1))"))
            }
        }
        if let optionsToRemove = optionsToRemove {
            var optionsToRemoveContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OptionsToRemove"))
            for (index0, string0) in optionsToRemove.enumerated() {
                try optionsToRemoveContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyOptionGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ModifyOptionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ModifyOptionGroupInput: Swift.Equatable {
    /// A value that indicates whether to apply the change immediately or during the next maintenance window for each instance associated with the option group.
    public var applyImmediately: Swift.Bool
    /// The name of the option group to be modified. Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option group, and that option group can't be removed from a DB instance once it is associated with a DB instance
    /// This member is required.
    public var optionGroupName: Swift.String?
    /// Options in this list are added to the option group or, if already present, the specified configuration is used to update the existing configuration.
    public var optionsToInclude: [RdsClientTypes.OptionConfiguration]?
    /// Options in this list are removed from the option group.
    public var optionsToRemove: [Swift.String]?

    public init (
        applyImmediately: Swift.Bool = false,
        optionGroupName: Swift.String? = nil,
        optionsToInclude: [RdsClientTypes.OptionConfiguration]? = nil,
        optionsToRemove: [Swift.String]? = nil
    )
    {
        self.applyImmediately = applyImmediately
        self.optionGroupName = optionGroupName
        self.optionsToInclude = optionsToInclude
        self.optionsToRemove = optionsToRemove
    }
}

struct ModifyOptionGroupInputBody: Swift.Equatable {
    let optionGroupName: Swift.String?
    let optionsToInclude: [RdsClientTypes.OptionConfiguration]?
    let optionsToRemove: [Swift.String]?
    let applyImmediately: Swift.Bool
}

extension ModifyOptionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyImmediately = "ApplyImmediately"
        case optionGroupName = "OptionGroupName"
        case optionsToInclude = "OptionsToInclude"
        case optionsToRemove = "OptionsToRemove"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        if containerValues.contains(.optionsToInclude) {
            struct KeyVal0{struct OptionConfiguration{}}
            let optionsToIncludeWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionConfiguration>.CodingKeys.self, forKey: .optionsToInclude)
            if let optionsToIncludeWrappedContainer = optionsToIncludeWrappedContainer {
                let optionsToIncludeContainer = try optionsToIncludeWrappedContainer.decodeIfPresent([RdsClientTypes.OptionConfiguration].self, forKey: .member)
                var optionsToIncludeBuffer:[RdsClientTypes.OptionConfiguration]? = nil
                if let optionsToIncludeContainer = optionsToIncludeContainer {
                    optionsToIncludeBuffer = [RdsClientTypes.OptionConfiguration]()
                    for structureContainer0 in optionsToIncludeContainer {
                        optionsToIncludeBuffer?.append(structureContainer0)
                    }
                }
                optionsToInclude = optionsToIncludeBuffer
            } else {
                optionsToInclude = []
            }
        } else {
            optionsToInclude = nil
        }
        if containerValues.contains(.optionsToRemove) {
            struct KeyVal0{struct member{}}
            let optionsToRemoveWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .optionsToRemove)
            if let optionsToRemoveWrappedContainer = optionsToRemoveWrappedContainer {
                let optionsToRemoveContainer = try optionsToRemoveWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var optionsToRemoveBuffer:[Swift.String]? = nil
                if let optionsToRemoveContainer = optionsToRemoveContainer {
                    optionsToRemoveBuffer = [Swift.String]()
                    for stringContainer0 in optionsToRemoveContainer {
                        optionsToRemoveBuffer?.append(stringContainer0)
                    }
                }
                optionsToRemove = optionsToRemoveBuffer
            } else {
                optionsToRemove = []
            }
        } else {
            optionsToRemove = nil
        }
        let applyImmediatelyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .applyImmediately)
        applyImmediately = applyImmediatelyDecoded
    }
}

extension ModifyOptionGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyOptionGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidOptionGroupStateFault" : self = .invalidOptionGroupStateFault(try InvalidOptionGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyOptionGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidOptionGroupStateFault(InvalidOptionGroupStateFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyOptionGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyOptionGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.optionGroup = output.optionGroup
        } else {
            self.optionGroup = nil
        }
    }
}

public struct ModifyOptionGroupOutputResponse: Swift.Equatable {
    ///
    public var optionGroup: RdsClientTypes.OptionGroup?

    public init (
        optionGroup: RdsClientTypes.OptionGroup? = nil
    )
    {
        self.optionGroup = optionGroup
    }
}

struct ModifyOptionGroupOutputResponseBody: Swift.Equatable {
    let optionGroup: RdsClientTypes.OptionGroup?
}

extension ModifyOptionGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optionGroup = "OptionGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyOptionGroupResult"))
        let optionGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.OptionGroup.self, forKey: .optionGroup)
        optionGroup = optionGroupDecoded
    }
}

extension RdsClientTypes.Option: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSecurityGroupMemberships = "DBSecurityGroupMemberships"
        case optionDescription = "OptionDescription"
        case optionName = "OptionName"
        case optionSettings = "OptionSettings"
        case optionVersion = "OptionVersion"
        case permanent = "Permanent"
        case persistent = "Persistent"
        case port = "Port"
        case vpcSecurityGroupMemberships = "VpcSecurityGroupMemberships"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSecurityGroupMemberships = dBSecurityGroupMemberships {
            var dBSecurityGroupMembershipsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBSecurityGroupMemberships"))
            for (index0, dbsecuritygroupmembership0) in dBSecurityGroupMemberships.enumerated() {
                try dBSecurityGroupMembershipsContainer.encode(dbsecuritygroupmembership0, forKey: ClientRuntime.Key("DBSecurityGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let optionDescription = optionDescription {
            try container.encode(optionDescription, forKey: ClientRuntime.Key("OptionDescription"))
        }
        if let optionName = optionName {
            try container.encode(optionName, forKey: ClientRuntime.Key("OptionName"))
        }
        if let optionSettings = optionSettings {
            var optionSettingsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OptionSettings"))
            for (index0, optionsetting0) in optionSettings.enumerated() {
                try optionSettingsContainer.encode(optionsetting0, forKey: ClientRuntime.Key("OptionSetting.\(index0.advanced(by: 1))"))
            }
        }
        if let optionVersion = optionVersion {
            try container.encode(optionVersion, forKey: ClientRuntime.Key("OptionVersion"))
        }
        if permanent != false {
            try container.encode(permanent, forKey: ClientRuntime.Key("Permanent"))
        }
        if persistent != false {
            try container.encode(persistent, forKey: ClientRuntime.Key("Persistent"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let vpcSecurityGroupMemberships = vpcSecurityGroupMemberships {
            var vpcSecurityGroupMembershipsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupMemberships"))
            for (index0, vpcsecuritygroupmembership0) in vpcSecurityGroupMemberships.enumerated() {
                try vpcSecurityGroupMembershipsContainer.encode(vpcsecuritygroupmembership0, forKey: ClientRuntime.Key("VpcSecurityGroupMembership.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionName)
        optionName = optionNameDecoded
        let optionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionDescription)
        optionDescription = optionDescriptionDecoded
        let persistentDecoded = try containerValues.decode(Swift.Bool.self, forKey: .persistent)
        persistent = persistentDecoded
        let permanentDecoded = try containerValues.decode(Swift.Bool.self, forKey: .permanent)
        permanent = permanentDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let optionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionVersion)
        optionVersion = optionVersionDecoded
        if containerValues.contains(.optionSettings) {
            struct KeyVal0{struct OptionSetting{}}
            let optionSettingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionSetting>.CodingKeys.self, forKey: .optionSettings)
            if let optionSettingsWrappedContainer = optionSettingsWrappedContainer {
                let optionSettingsContainer = try optionSettingsWrappedContainer.decodeIfPresent([RdsClientTypes.OptionSetting].self, forKey: .member)
                var optionSettingsBuffer:[RdsClientTypes.OptionSetting]? = nil
                if let optionSettingsContainer = optionSettingsContainer {
                    optionSettingsBuffer = [RdsClientTypes.OptionSetting]()
                    for structureContainer0 in optionSettingsContainer {
                        optionSettingsBuffer?.append(structureContainer0)
                    }
                }
                optionSettings = optionSettingsBuffer
            } else {
                optionSettings = []
            }
        } else {
            optionSettings = nil
        }
        if containerValues.contains(.dBSecurityGroupMemberships) {
            struct KeyVal0{struct DBSecurityGroup{}}
            let dBSecurityGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSecurityGroup>.CodingKeys.self, forKey: .dBSecurityGroupMemberships)
            if let dBSecurityGroupMembershipsWrappedContainer = dBSecurityGroupMembershipsWrappedContainer {
                let dBSecurityGroupMembershipsContainer = try dBSecurityGroupMembershipsWrappedContainer.decodeIfPresent([RdsClientTypes.DBSecurityGroupMembership].self, forKey: .member)
                var dBSecurityGroupMembershipsBuffer:[RdsClientTypes.DBSecurityGroupMembership]? = nil
                if let dBSecurityGroupMembershipsContainer = dBSecurityGroupMembershipsContainer {
                    dBSecurityGroupMembershipsBuffer = [RdsClientTypes.DBSecurityGroupMembership]()
                    for structureContainer0 in dBSecurityGroupMembershipsContainer {
                        dBSecurityGroupMembershipsBuffer?.append(structureContainer0)
                    }
                }
                dBSecurityGroupMemberships = dBSecurityGroupMembershipsBuffer
            } else {
                dBSecurityGroupMemberships = []
            }
        } else {
            dBSecurityGroupMemberships = nil
        }
        if containerValues.contains(.vpcSecurityGroupMemberships) {
            struct KeyVal0{struct VpcSecurityGroupMembership{}}
            let vpcSecurityGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupMembership>.CodingKeys.self, forKey: .vpcSecurityGroupMemberships)
            if let vpcSecurityGroupMembershipsWrappedContainer = vpcSecurityGroupMembershipsWrappedContainer {
                let vpcSecurityGroupMembershipsContainer = try vpcSecurityGroupMembershipsWrappedContainer.decodeIfPresent([RdsClientTypes.VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupMembershipsBuffer:[RdsClientTypes.VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupMembershipsContainer = vpcSecurityGroupMembershipsContainer {
                    vpcSecurityGroupMembershipsBuffer = [RdsClientTypes.VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupMembershipsContainer {
                        vpcSecurityGroupMembershipsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroupMemberships = vpcSecurityGroupMembershipsBuffer
            } else {
                vpcSecurityGroupMemberships = []
            }
        } else {
            vpcSecurityGroupMemberships = nil
        }
    }
}

extension RdsClientTypes {
    /// Option details.
    public struct Option: Swift.Equatable {
        /// If the option requires access to a port, then this DB security group allows access to the port.
        public var dBSecurityGroupMemberships: [RdsClientTypes.DBSecurityGroupMembership]?
        /// The description of the option.
        public var optionDescription: Swift.String?
        /// The name of the option.
        public var optionName: Swift.String?
        /// The option settings for this option.
        public var optionSettings: [RdsClientTypes.OptionSetting]?
        /// The version of the option.
        public var optionVersion: Swift.String?
        /// Indicate if this option is permanent.
        public var permanent: Swift.Bool
        /// Indicate if this option is persistent.
        public var persistent: Swift.Bool
        /// If required, the port configured for this option to use.
        public var port: Swift.Int?
        /// If the option requires access to a port, then this VPC security group allows access to the port.
        public var vpcSecurityGroupMemberships: [RdsClientTypes.VpcSecurityGroupMembership]?

        public init (
            dBSecurityGroupMemberships: [RdsClientTypes.DBSecurityGroupMembership]? = nil,
            optionDescription: Swift.String? = nil,
            optionName: Swift.String? = nil,
            optionSettings: [RdsClientTypes.OptionSetting]? = nil,
            optionVersion: Swift.String? = nil,
            permanent: Swift.Bool = false,
            persistent: Swift.Bool = false,
            port: Swift.Int? = nil,
            vpcSecurityGroupMemberships: [RdsClientTypes.VpcSecurityGroupMembership]? = nil
        )
        {
            self.dBSecurityGroupMemberships = dBSecurityGroupMemberships
            self.optionDescription = optionDescription
            self.optionName = optionName
            self.optionSettings = optionSettings
            self.optionVersion = optionVersion
            self.permanent = permanent
            self.persistent = persistent
            self.port = port
            self.vpcSecurityGroupMemberships = vpcSecurityGroupMemberships
        }
    }

}

extension RdsClientTypes.OptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSecurityGroupMemberships = "DBSecurityGroupMemberships"
        case optionName = "OptionName"
        case optionSettings = "OptionSettings"
        case optionVersion = "OptionVersion"
        case port = "Port"
        case vpcSecurityGroupMemberships = "VpcSecurityGroupMemberships"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSecurityGroupMemberships = dBSecurityGroupMemberships {
            var dBSecurityGroupMembershipsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBSecurityGroupMemberships"))
            for (index0, string0) in dBSecurityGroupMemberships.enumerated() {
                try dBSecurityGroupMembershipsContainer.encode(string0, forKey: ClientRuntime.Key("DBSecurityGroupName.\(index0.advanced(by: 1))"))
            }
        }
        if let optionName = optionName {
            try container.encode(optionName, forKey: ClientRuntime.Key("OptionName"))
        }
        if let optionSettings = optionSettings {
            var optionSettingsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OptionSettings"))
            for (index0, optionsetting0) in optionSettings.enumerated() {
                try optionSettingsContainer.encode(optionsetting0, forKey: ClientRuntime.Key("OptionSetting.\(index0.advanced(by: 1))"))
            }
        }
        if let optionVersion = optionVersion {
            try container.encode(optionVersion, forKey: ClientRuntime.Key("OptionVersion"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let vpcSecurityGroupMemberships = vpcSecurityGroupMemberships {
            var vpcSecurityGroupMembershipsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupMemberships"))
            for (index0, string0) in vpcSecurityGroupMemberships.enumerated() {
                try vpcSecurityGroupMembershipsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionName)
        optionName = optionNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let optionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionVersion)
        optionVersion = optionVersionDecoded
        if containerValues.contains(.dBSecurityGroupMemberships) {
            struct KeyVal0{struct DBSecurityGroupName{}}
            let dBSecurityGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSecurityGroupName>.CodingKeys.self, forKey: .dBSecurityGroupMemberships)
            if let dBSecurityGroupMembershipsWrappedContainer = dBSecurityGroupMembershipsWrappedContainer {
                let dBSecurityGroupMembershipsContainer = try dBSecurityGroupMembershipsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var dBSecurityGroupMembershipsBuffer:[Swift.String]? = nil
                if let dBSecurityGroupMembershipsContainer = dBSecurityGroupMembershipsContainer {
                    dBSecurityGroupMembershipsBuffer = [Swift.String]()
                    for stringContainer0 in dBSecurityGroupMembershipsContainer {
                        dBSecurityGroupMembershipsBuffer?.append(stringContainer0)
                    }
                }
                dBSecurityGroupMemberships = dBSecurityGroupMembershipsBuffer
            } else {
                dBSecurityGroupMemberships = []
            }
        } else {
            dBSecurityGroupMemberships = nil
        }
        if containerValues.contains(.vpcSecurityGroupMemberships) {
            struct KeyVal0{struct VpcSecurityGroupId{}}
            let vpcSecurityGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupId>.CodingKeys.self, forKey: .vpcSecurityGroupMemberships)
            if let vpcSecurityGroupMembershipsWrappedContainer = vpcSecurityGroupMembershipsWrappedContainer {
                let vpcSecurityGroupMembershipsContainer = try vpcSecurityGroupMembershipsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSecurityGroupMembershipsBuffer:[Swift.String]? = nil
                if let vpcSecurityGroupMembershipsContainer = vpcSecurityGroupMembershipsContainer {
                    vpcSecurityGroupMembershipsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSecurityGroupMembershipsContainer {
                        vpcSecurityGroupMembershipsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupMemberships = vpcSecurityGroupMembershipsBuffer
            } else {
                vpcSecurityGroupMemberships = []
            }
        } else {
            vpcSecurityGroupMemberships = nil
        }
        if containerValues.contains(.optionSettings) {
            struct KeyVal0{struct OptionSetting{}}
            let optionSettingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionSetting>.CodingKeys.self, forKey: .optionSettings)
            if let optionSettingsWrappedContainer = optionSettingsWrappedContainer {
                let optionSettingsContainer = try optionSettingsWrappedContainer.decodeIfPresent([RdsClientTypes.OptionSetting].self, forKey: .member)
                var optionSettingsBuffer:[RdsClientTypes.OptionSetting]? = nil
                if let optionSettingsContainer = optionSettingsContainer {
                    optionSettingsBuffer = [RdsClientTypes.OptionSetting]()
                    for structureContainer0 in optionSettingsContainer {
                        optionSettingsBuffer?.append(structureContainer0)
                    }
                }
                optionSettings = optionSettingsBuffer
            } else {
                optionSettings = []
            }
        } else {
            optionSettings = nil
        }
    }
}

extension RdsClientTypes {
    /// A list of all available options
    public struct OptionConfiguration: Swift.Equatable {
        /// A list of DBSecurityGroupMembership name strings used for this option.
        public var dBSecurityGroupMemberships: [Swift.String]?
        /// The configuration of options to include in a group.
        /// This member is required.
        public var optionName: Swift.String?
        /// The option settings to include in an option group.
        public var optionSettings: [RdsClientTypes.OptionSetting]?
        /// The version for the option.
        public var optionVersion: Swift.String?
        /// The optional port for the option.
        public var port: Swift.Int?
        /// A list of VpcSecurityGroupMembership name strings used for this option.
        public var vpcSecurityGroupMemberships: [Swift.String]?

        public init (
            dBSecurityGroupMemberships: [Swift.String]? = nil,
            optionName: Swift.String? = nil,
            optionSettings: [RdsClientTypes.OptionSetting]? = nil,
            optionVersion: Swift.String? = nil,
            port: Swift.Int? = nil,
            vpcSecurityGroupMemberships: [Swift.String]? = nil
        )
        {
            self.dBSecurityGroupMemberships = dBSecurityGroupMemberships
            self.optionName = optionName
            self.optionSettings = optionSettings
            self.optionVersion = optionVersion
            self.port = port
            self.vpcSecurityGroupMemberships = vpcSecurityGroupMemberships
        }
    }

}

extension RdsClientTypes.OptionGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowsVpcAndNonVpcInstanceMemberships = "AllowsVpcAndNonVpcInstanceMemberships"
        case engineName = "EngineName"
        case majorEngineVersion = "MajorEngineVersion"
        case optionGroupArn = "OptionGroupArn"
        case optionGroupDescription = "OptionGroupDescription"
        case optionGroupName = "OptionGroupName"
        case options = "Options"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allowsVpcAndNonVpcInstanceMemberships != false {
            try container.encode(allowsVpcAndNonVpcInstanceMemberships, forKey: ClientRuntime.Key("AllowsVpcAndNonVpcInstanceMemberships"))
        }
        if let engineName = engineName {
            try container.encode(engineName, forKey: ClientRuntime.Key("EngineName"))
        }
        if let majorEngineVersion = majorEngineVersion {
            try container.encode(majorEngineVersion, forKey: ClientRuntime.Key("MajorEngineVersion"))
        }
        if let optionGroupArn = optionGroupArn {
            try container.encode(optionGroupArn, forKey: ClientRuntime.Key("OptionGroupArn"))
        }
        if let optionGroupDescription = optionGroupDescription {
            try container.encode(optionGroupDescription, forKey: ClientRuntime.Key("OptionGroupDescription"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let options = options {
            var optionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Options"))
            for (index0, option0) in options.enumerated() {
                try optionsContainer.encode(option0, forKey: ClientRuntime.Key("Option.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let optionGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupDescription)
        optionGroupDescription = optionGroupDescriptionDecoded
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let majorEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorEngineVersion)
        majorEngineVersion = majorEngineVersionDecoded
        if containerValues.contains(.options) {
            struct KeyVal0{struct Option{}}
            let optionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Option>.CodingKeys.self, forKey: .options)
            if let optionsWrappedContainer = optionsWrappedContainer {
                let optionsContainer = try optionsWrappedContainer.decodeIfPresent([RdsClientTypes.Option].self, forKey: .member)
                var optionsBuffer:[RdsClientTypes.Option]? = nil
                if let optionsContainer = optionsContainer {
                    optionsBuffer = [RdsClientTypes.Option]()
                    for structureContainer0 in optionsContainer {
                        optionsBuffer?.append(structureContainer0)
                    }
                }
                options = optionsBuffer
            } else {
                options = []
            }
        } else {
            options = nil
        }
        let allowsVpcAndNonVpcInstanceMembershipsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowsVpcAndNonVpcInstanceMemberships)
        allowsVpcAndNonVpcInstanceMemberships = allowsVpcAndNonVpcInstanceMembershipsDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let optionGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupArn)
        optionGroupArn = optionGroupArnDecoded
    }
}

extension RdsClientTypes {
    ///
    public struct OptionGroup: Swift.Equatable {
        /// Indicates whether this option group can be applied to both VPC and non-VPC instances. The value true indicates the option group can be applied to both VPC and non-VPC instances.
        public var allowsVpcAndNonVpcInstanceMemberships: Swift.Bool
        /// Indicates the name of the engine that this option group can be applied to.
        public var engineName: Swift.String?
        /// Indicates the major engine version associated with this option group.
        public var majorEngineVersion: Swift.String?
        /// The Amazon Resource Name (ARN) for the option group.
        public var optionGroupArn: Swift.String?
        /// Provides a description of the option group.
        public var optionGroupDescription: Swift.String?
        /// Specifies the name of the option group.
        public var optionGroupName: Swift.String?
        /// Indicates what options are available in the option group.
        public var options: [RdsClientTypes.Option]?
        /// If AllowsVpcAndNonVpcInstanceMemberships is false, this field is blank. If AllowsVpcAndNonVpcInstanceMemberships is true and this field is blank, then this option group can be applied to both VPC and non-VPC instances. If this field contains a value, then this option group can only be applied to instances that are in the VPC indicated by this field.
        public var vpcId: Swift.String?

        public init (
            allowsVpcAndNonVpcInstanceMemberships: Swift.Bool = false,
            engineName: Swift.String? = nil,
            majorEngineVersion: Swift.String? = nil,
            optionGroupArn: Swift.String? = nil,
            optionGroupDescription: Swift.String? = nil,
            optionGroupName: Swift.String? = nil,
            options: [RdsClientTypes.Option]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.allowsVpcAndNonVpcInstanceMemberships = allowsVpcAndNonVpcInstanceMemberships
            self.engineName = engineName
            self.majorEngineVersion = majorEngineVersion
            self.optionGroupArn = optionGroupArn
            self.optionGroupDescription = optionGroupDescription
            self.optionGroupName = optionGroupName
            self.options = options
            self.vpcId = vpcId
        }
    }

}

extension OptionGroupAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<OptionGroupAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The option group you are trying to create already exists.
public struct OptionGroupAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OptionGroupAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension OptionGroupAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.OptionGroupMembership: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optionGroupName = "OptionGroupName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension RdsClientTypes {
    /// Provides information on the option groups the DB instance is a member of.
    public struct OptionGroupMembership: Swift.Equatable {
        /// The name of the option group that the instance belongs to.
        public var optionGroupName: Swift.String?
        /// The status of the DB instance's option group membership. Valid values are: in-sync, pending-apply, pending-removal, pending-maintenance-apply, pending-maintenance-removal, applying, removing, and failed.
        public var status: Swift.String?

        public init (
            optionGroupName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.optionGroupName = optionGroupName
            self.status = status
        }
    }

}

extension OptionGroupNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<OptionGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified option group could not be found.
public struct OptionGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OptionGroupNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension OptionGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.OptionGroupOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultPort = "DefaultPort"
        case description = "Description"
        case engineName = "EngineName"
        case majorEngineVersion = "MajorEngineVersion"
        case minimumRequiredMinorEngineVersion = "MinimumRequiredMinorEngineVersion"
        case name = "Name"
        case optionGroupOptionSettings = "OptionGroupOptionSettings"
        case optionGroupOptionVersions = "OptionGroupOptionVersions"
        case optionsConflictsWith = "OptionsConflictsWith"
        case optionsDependedOn = "OptionsDependedOn"
        case permanent = "Permanent"
        case persistent = "Persistent"
        case portRequired = "PortRequired"
        case requiresAutoMinorEngineVersionUpgrade = "RequiresAutoMinorEngineVersionUpgrade"
        case supportsOptionVersionDowngrade = "SupportsOptionVersionDowngrade"
        case vpcOnly = "VpcOnly"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultPort = defaultPort {
            try container.encode(defaultPort, forKey: ClientRuntime.Key("DefaultPort"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let engineName = engineName {
            try container.encode(engineName, forKey: ClientRuntime.Key("EngineName"))
        }
        if let majorEngineVersion = majorEngineVersion {
            try container.encode(majorEngineVersion, forKey: ClientRuntime.Key("MajorEngineVersion"))
        }
        if let minimumRequiredMinorEngineVersion = minimumRequiredMinorEngineVersion {
            try container.encode(minimumRequiredMinorEngineVersion, forKey: ClientRuntime.Key("MinimumRequiredMinorEngineVersion"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let optionGroupOptionSettings = optionGroupOptionSettings {
            var optionGroupOptionSettingsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OptionGroupOptionSettings"))
            for (index0, optiongroupoptionsetting0) in optionGroupOptionSettings.enumerated() {
                try optionGroupOptionSettingsContainer.encode(optiongroupoptionsetting0, forKey: ClientRuntime.Key("OptionGroupOptionSetting.\(index0.advanced(by: 1))"))
            }
        }
        if let optionGroupOptionVersions = optionGroupOptionVersions {
            var optionGroupOptionVersionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OptionGroupOptionVersions"))
            for (index0, optionversion0) in optionGroupOptionVersions.enumerated() {
                try optionGroupOptionVersionsContainer.encode(optionversion0, forKey: ClientRuntime.Key("OptionVersion.\(index0.advanced(by: 1))"))
            }
        }
        if let optionsConflictsWith = optionsConflictsWith {
            var optionsConflictsWithContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OptionsConflictsWith"))
            for (index0, string0) in optionsConflictsWith.enumerated() {
                try optionsConflictsWithContainer.encode(string0, forKey: ClientRuntime.Key("OptionConflictName.\(index0.advanced(by: 1))"))
            }
        }
        if let optionsDependedOn = optionsDependedOn {
            var optionsDependedOnContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OptionsDependedOn"))
            for (index0, string0) in optionsDependedOn.enumerated() {
                try optionsDependedOnContainer.encode(string0, forKey: ClientRuntime.Key("OptionName.\(index0.advanced(by: 1))"))
            }
        }
        if permanent != false {
            try container.encode(permanent, forKey: ClientRuntime.Key("Permanent"))
        }
        if persistent != false {
            try container.encode(persistent, forKey: ClientRuntime.Key("Persistent"))
        }
        if portRequired != false {
            try container.encode(portRequired, forKey: ClientRuntime.Key("PortRequired"))
        }
        if requiresAutoMinorEngineVersionUpgrade != false {
            try container.encode(requiresAutoMinorEngineVersionUpgrade, forKey: ClientRuntime.Key("RequiresAutoMinorEngineVersionUpgrade"))
        }
        if let supportsOptionVersionDowngrade = supportsOptionVersionDowngrade {
            try container.encode(supportsOptionVersionDowngrade, forKey: ClientRuntime.Key("SupportsOptionVersionDowngrade"))
        }
        if vpcOnly != false {
            try container.encode(vpcOnly, forKey: ClientRuntime.Key("VpcOnly"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let majorEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorEngineVersion)
        majorEngineVersion = majorEngineVersionDecoded
        let minimumRequiredMinorEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minimumRequiredMinorEngineVersion)
        minimumRequiredMinorEngineVersion = minimumRequiredMinorEngineVersionDecoded
        let portRequiredDecoded = try containerValues.decode(Swift.Bool.self, forKey: .portRequired)
        portRequired = portRequiredDecoded
        let defaultPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultPort)
        defaultPort = defaultPortDecoded
        if containerValues.contains(.optionsDependedOn) {
            struct KeyVal0{struct OptionName{}}
            let optionsDependedOnWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionName>.CodingKeys.self, forKey: .optionsDependedOn)
            if let optionsDependedOnWrappedContainer = optionsDependedOnWrappedContainer {
                let optionsDependedOnContainer = try optionsDependedOnWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var optionsDependedOnBuffer:[Swift.String]? = nil
                if let optionsDependedOnContainer = optionsDependedOnContainer {
                    optionsDependedOnBuffer = [Swift.String]()
                    for stringContainer0 in optionsDependedOnContainer {
                        optionsDependedOnBuffer?.append(stringContainer0)
                    }
                }
                optionsDependedOn = optionsDependedOnBuffer
            } else {
                optionsDependedOn = []
            }
        } else {
            optionsDependedOn = nil
        }
        if containerValues.contains(.optionsConflictsWith) {
            struct KeyVal0{struct OptionConflictName{}}
            let optionsConflictsWithWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionConflictName>.CodingKeys.self, forKey: .optionsConflictsWith)
            if let optionsConflictsWithWrappedContainer = optionsConflictsWithWrappedContainer {
                let optionsConflictsWithContainer = try optionsConflictsWithWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var optionsConflictsWithBuffer:[Swift.String]? = nil
                if let optionsConflictsWithContainer = optionsConflictsWithContainer {
                    optionsConflictsWithBuffer = [Swift.String]()
                    for stringContainer0 in optionsConflictsWithContainer {
                        optionsConflictsWithBuffer?.append(stringContainer0)
                    }
                }
                optionsConflictsWith = optionsConflictsWithBuffer
            } else {
                optionsConflictsWith = []
            }
        } else {
            optionsConflictsWith = nil
        }
        let persistentDecoded = try containerValues.decode(Swift.Bool.self, forKey: .persistent)
        persistent = persistentDecoded
        let permanentDecoded = try containerValues.decode(Swift.Bool.self, forKey: .permanent)
        permanent = permanentDecoded
        let requiresAutoMinorEngineVersionUpgradeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .requiresAutoMinorEngineVersionUpgrade)
        requiresAutoMinorEngineVersionUpgrade = requiresAutoMinorEngineVersionUpgradeDecoded
        let vpcOnlyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .vpcOnly)
        vpcOnly = vpcOnlyDecoded
        let supportsOptionVersionDowngradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsOptionVersionDowngrade)
        supportsOptionVersionDowngrade = supportsOptionVersionDowngradeDecoded
        if containerValues.contains(.optionGroupOptionSettings) {
            struct KeyVal0{struct OptionGroupOptionSetting{}}
            let optionGroupOptionSettingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionGroupOptionSetting>.CodingKeys.self, forKey: .optionGroupOptionSettings)
            if let optionGroupOptionSettingsWrappedContainer = optionGroupOptionSettingsWrappedContainer {
                let optionGroupOptionSettingsContainer = try optionGroupOptionSettingsWrappedContainer.decodeIfPresent([RdsClientTypes.OptionGroupOptionSetting].self, forKey: .member)
                var optionGroupOptionSettingsBuffer:[RdsClientTypes.OptionGroupOptionSetting]? = nil
                if let optionGroupOptionSettingsContainer = optionGroupOptionSettingsContainer {
                    optionGroupOptionSettingsBuffer = [RdsClientTypes.OptionGroupOptionSetting]()
                    for structureContainer0 in optionGroupOptionSettingsContainer {
                        optionGroupOptionSettingsBuffer?.append(structureContainer0)
                    }
                }
                optionGroupOptionSettings = optionGroupOptionSettingsBuffer
            } else {
                optionGroupOptionSettings = []
            }
        } else {
            optionGroupOptionSettings = nil
        }
        if containerValues.contains(.optionGroupOptionVersions) {
            struct KeyVal0{struct OptionVersion{}}
            let optionGroupOptionVersionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionVersion>.CodingKeys.self, forKey: .optionGroupOptionVersions)
            if let optionGroupOptionVersionsWrappedContainer = optionGroupOptionVersionsWrappedContainer {
                let optionGroupOptionVersionsContainer = try optionGroupOptionVersionsWrappedContainer.decodeIfPresent([RdsClientTypes.OptionVersion].self, forKey: .member)
                var optionGroupOptionVersionsBuffer:[RdsClientTypes.OptionVersion]? = nil
                if let optionGroupOptionVersionsContainer = optionGroupOptionVersionsContainer {
                    optionGroupOptionVersionsBuffer = [RdsClientTypes.OptionVersion]()
                    for structureContainer0 in optionGroupOptionVersionsContainer {
                        optionGroupOptionVersionsBuffer?.append(structureContainer0)
                    }
                }
                optionGroupOptionVersions = optionGroupOptionVersionsBuffer
            } else {
                optionGroupOptionVersions = []
            }
        } else {
            optionGroupOptionVersions = nil
        }
    }
}

extension RdsClientTypes {
    /// Available option.
    public struct OptionGroupOption: Swift.Equatable {
        /// If the option requires a port, specifies the default port for the option.
        public var defaultPort: Swift.Int?
        /// The description of the option.
        public var description: Swift.String?
        /// The name of the engine that this option can be applied to.
        public var engineName: Swift.String?
        /// Indicates the major engine version that the option is available for.
        public var majorEngineVersion: Swift.String?
        /// The minimum required engine version for the option to be applied.
        public var minimumRequiredMinorEngineVersion: Swift.String?
        /// The name of the option.
        public var name: Swift.String?
        /// The option settings that are available (and the default value) for each option in an option group.
        public var optionGroupOptionSettings: [RdsClientTypes.OptionGroupOptionSetting]?
        /// The versions that are available for the option.
        public var optionGroupOptionVersions: [RdsClientTypes.OptionVersion]?
        /// The options that conflict with this option.
        public var optionsConflictsWith: [Swift.String]?
        /// The options that are prerequisites for this option.
        public var optionsDependedOn: [Swift.String]?
        /// Permanent options can never be removed from an option group. An option group containing a permanent option can't be removed from a DB instance.
        public var permanent: Swift.Bool
        /// Persistent options can't be removed from an option group while DB instances are associated with the option group. If you disassociate all DB instances from the option group, your can remove the persistent option from the option group.
        public var persistent: Swift.Bool
        /// Specifies whether the option requires a port.
        public var portRequired: Swift.Bool
        /// If true, you must enable the Auto Minor Version Upgrade setting for your DB instance before you can use this option. You can enable Auto Minor Version Upgrade when you first create your DB instance, or by modifying your DB instance later.
        public var requiresAutoMinorEngineVersionUpgrade: Swift.Bool
        /// If true, you can change the option to an earlier version of the option. This only applies to options that have different versions available.
        public var supportsOptionVersionDowngrade: Swift.Bool?
        /// If true, you can only use this option with a DB instance that is in a VPC.
        public var vpcOnly: Swift.Bool

        public init (
            defaultPort: Swift.Int? = nil,
            description: Swift.String? = nil,
            engineName: Swift.String? = nil,
            majorEngineVersion: Swift.String? = nil,
            minimumRequiredMinorEngineVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            optionGroupOptionSettings: [RdsClientTypes.OptionGroupOptionSetting]? = nil,
            optionGroupOptionVersions: [RdsClientTypes.OptionVersion]? = nil,
            optionsConflictsWith: [Swift.String]? = nil,
            optionsDependedOn: [Swift.String]? = nil,
            permanent: Swift.Bool = false,
            persistent: Swift.Bool = false,
            portRequired: Swift.Bool = false,
            requiresAutoMinorEngineVersionUpgrade: Swift.Bool = false,
            supportsOptionVersionDowngrade: Swift.Bool? = nil,
            vpcOnly: Swift.Bool = false
        )
        {
            self.defaultPort = defaultPort
            self.description = description
            self.engineName = engineName
            self.majorEngineVersion = majorEngineVersion
            self.minimumRequiredMinorEngineVersion = minimumRequiredMinorEngineVersion
            self.name = name
            self.optionGroupOptionSettings = optionGroupOptionSettings
            self.optionGroupOptionVersions = optionGroupOptionVersions
            self.optionsConflictsWith = optionsConflictsWith
            self.optionsDependedOn = optionsDependedOn
            self.permanent = permanent
            self.persistent = persistent
            self.portRequired = portRequired
            self.requiresAutoMinorEngineVersionUpgrade = requiresAutoMinorEngineVersionUpgrade
            self.supportsOptionVersionDowngrade = supportsOptionVersionDowngrade
            self.vpcOnly = vpcOnly
        }
    }

}

extension RdsClientTypes.OptionGroupOptionSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues = "AllowedValues"
        case applyType = "ApplyType"
        case defaultValue = "DefaultValue"
        case isModifiable = "IsModifiable"
        case isRequired = "IsRequired"
        case minimumEngineVersionPerAllowedValue = "MinimumEngineVersionPerAllowedValue"
        case settingDescription = "SettingDescription"
        case settingName = "SettingName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allowedValues = allowedValues {
            try container.encode(allowedValues, forKey: ClientRuntime.Key("AllowedValues"))
        }
        if let applyType = applyType {
            try container.encode(applyType, forKey: ClientRuntime.Key("ApplyType"))
        }
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if isModifiable != false {
            try container.encode(isModifiable, forKey: ClientRuntime.Key("IsModifiable"))
        }
        if isRequired != false {
            try container.encode(isRequired, forKey: ClientRuntime.Key("IsRequired"))
        }
        if let minimumEngineVersionPerAllowedValue = minimumEngineVersionPerAllowedValue {
            var minimumEngineVersionPerAllowedValueContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MinimumEngineVersionPerAllowedValue"))
            for (index0, minimumengineversionperallowedvalue0) in minimumEngineVersionPerAllowedValue.enumerated() {
                try minimumEngineVersionPerAllowedValueContainer.encode(minimumengineversionperallowedvalue0, forKey: ClientRuntime.Key("MinimumEngineVersionPerAllowedValue.\(index0.advanced(by: 1))"))
            }
        }
        if let settingDescription = settingDescription {
            try container.encode(settingDescription, forKey: ClientRuntime.Key("SettingDescription"))
        }
        if let settingName = settingName {
            try container.encode(settingName, forKey: ClientRuntime.Key("SettingName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let settingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .settingName)
        settingName = settingNameDecoded
        let settingDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .settingDescription)
        settingDescription = settingDescriptionDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let applyTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applyType)
        applyType = applyTypeDecoded
        let allowedValuesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedValues)
        allowedValues = allowedValuesDecoded
        let isModifiableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isModifiable)
        isModifiable = isModifiableDecoded
        let isRequiredDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isRequired)
        isRequired = isRequiredDecoded
        if containerValues.contains(.minimumEngineVersionPerAllowedValue) {
            struct KeyVal0{struct MinimumEngineVersionPerAllowedValue{}}
            let minimumEngineVersionPerAllowedValueWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.MinimumEngineVersionPerAllowedValue>.CodingKeys.self, forKey: .minimumEngineVersionPerAllowedValue)
            if let minimumEngineVersionPerAllowedValueWrappedContainer = minimumEngineVersionPerAllowedValueWrappedContainer {
                let minimumEngineVersionPerAllowedValueContainer = try minimumEngineVersionPerAllowedValueWrappedContainer.decodeIfPresent([RdsClientTypes.MinimumEngineVersionPerAllowedValue].self, forKey: .member)
                var minimumEngineVersionPerAllowedValueBuffer:[RdsClientTypes.MinimumEngineVersionPerAllowedValue]? = nil
                if let minimumEngineVersionPerAllowedValueContainer = minimumEngineVersionPerAllowedValueContainer {
                    minimumEngineVersionPerAllowedValueBuffer = [RdsClientTypes.MinimumEngineVersionPerAllowedValue]()
                    for structureContainer0 in minimumEngineVersionPerAllowedValueContainer {
                        minimumEngineVersionPerAllowedValueBuffer?.append(structureContainer0)
                    }
                }
                minimumEngineVersionPerAllowedValue = minimumEngineVersionPerAllowedValueBuffer
            } else {
                minimumEngineVersionPerAllowedValue = []
            }
        } else {
            minimumEngineVersionPerAllowedValue = nil
        }
    }
}

extension RdsClientTypes {
    /// Option group option settings are used to display settings available for each option with their default values and other information. These values are used with the DescribeOptionGroupOptions action.
    public struct OptionGroupOptionSetting: Swift.Equatable {
        /// Indicates the acceptable values for the option group option.
        public var allowedValues: Swift.String?
        /// The DB engine specific parameter type for the option group option.
        public var applyType: Swift.String?
        /// The default value for the option group option.
        public var defaultValue: Swift.String?
        /// Boolean value where true indicates that this option group option can be changed from the default value.
        public var isModifiable: Swift.Bool
        /// Boolean value where true indicates that a value must be specified for this option setting of the option group option.
        public var isRequired: Swift.Bool
        /// The minimum DB engine version required for the corresponding allowed value for this option setting.
        public var minimumEngineVersionPerAllowedValue: [RdsClientTypes.MinimumEngineVersionPerAllowedValue]?
        /// The description of the option group option.
        public var settingDescription: Swift.String?
        /// The name of the option group option.
        public var settingName: Swift.String?

        public init (
            allowedValues: Swift.String? = nil,
            applyType: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            isModifiable: Swift.Bool = false,
            isRequired: Swift.Bool = false,
            minimumEngineVersionPerAllowedValue: [RdsClientTypes.MinimumEngineVersionPerAllowedValue]? = nil,
            settingDescription: Swift.String? = nil,
            settingName: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.applyType = applyType
            self.defaultValue = defaultValue
            self.isModifiable = isModifiable
            self.isRequired = isRequired
            self.minimumEngineVersionPerAllowedValue = minimumEngineVersionPerAllowedValue
            self.settingDescription = settingDescription
            self.settingName = settingName
        }
    }

}

extension OptionGroupQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<OptionGroupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The quota of 20 option groups was exceeded for this Amazon Web Services account.
public struct OptionGroupQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OptionGroupQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension OptionGroupQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.OptionSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues = "AllowedValues"
        case applyType = "ApplyType"
        case dataType = "DataType"
        case defaultValue = "DefaultValue"
        case description = "Description"
        case isCollection = "IsCollection"
        case isModifiable = "IsModifiable"
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allowedValues = allowedValues {
            try container.encode(allowedValues, forKey: ClientRuntime.Key("AllowedValues"))
        }
        if let applyType = applyType {
            try container.encode(applyType, forKey: ClientRuntime.Key("ApplyType"))
        }
        if let dataType = dataType {
            try container.encode(dataType, forKey: ClientRuntime.Key("DataType"))
        }
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if isCollection != false {
            try container.encode(isCollection, forKey: ClientRuntime.Key("IsCollection"))
        }
        if isModifiable != false {
            try container.encode(isModifiable, forKey: ClientRuntime.Key("IsModifiable"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let applyTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applyType)
        applyType = applyTypeDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let allowedValuesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedValues)
        allowedValues = allowedValuesDecoded
        let isModifiableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isModifiable)
        isModifiable = isModifiableDecoded
        let isCollectionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isCollection)
        isCollection = isCollectionDecoded
    }
}

extension RdsClientTypes {
    /// Option settings are the actual settings being applied or configured for that option. It is used when you modify an option group or describe option groups. For example, the NATIVE_NETWORK_ENCRYPTION option has a setting called SQLNET.ENCRYPTION_SERVER that can have several different values.
    public struct OptionSetting: Swift.Equatable {
        /// The allowed values of the option setting.
        public var allowedValues: Swift.String?
        /// The DB engine specific parameter type.
        public var applyType: Swift.String?
        /// The data type of the option setting.
        public var dataType: Swift.String?
        /// The default value of the option setting.
        public var defaultValue: Swift.String?
        /// The description of the option setting.
        public var description: Swift.String?
        /// Indicates if the option setting is part of a collection.
        public var isCollection: Swift.Bool
        /// A Boolean value that, when true, indicates the option setting can be modified from the default.
        public var isModifiable: Swift.Bool
        /// The name of the option that has settings that you can set.
        public var name: Swift.String?
        /// The current value of the option setting.
        public var value: Swift.String?

        public init (
            allowedValues: Swift.String? = nil,
            applyType: Swift.String? = nil,
            dataType: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            isCollection: Swift.Bool = false,
            isModifiable: Swift.Bool = false,
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.applyType = applyType
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.description = description
            self.isCollection = isCollection
            self.isModifiable = isModifiable
            self.name = name
            self.value = value
        }
    }

}

extension RdsClientTypes.OptionVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isDefault = "IsDefault"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if isDefault != false {
            try container.encode(isDefault, forKey: ClientRuntime.Key("IsDefault"))
        }
        if let version = version {
            try container.encode(version, forKey: ClientRuntime.Key("Version"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let isDefaultDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
    }
}

extension RdsClientTypes {
    /// The version for an option. Option group option versions are returned by the DescribeOptionGroupOptions action.
    public struct OptionVersion: Swift.Equatable {
        /// True if the version is the default version of the option, and otherwise false.
        public var isDefault: Swift.Bool
        /// The version of the option.
        public var version: Swift.String?

        public init (
            isDefault: Swift.Bool = false,
            version: Swift.String? = nil
        )
        {
            self.isDefault = isDefault
            self.version = version
        }
    }

}

extension RdsClientTypes.OrderableDBInstanceOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneGroup = "AvailabilityZoneGroup"
        case availabilityZones = "AvailabilityZones"
        case availableProcessorFeatures = "AvailableProcessorFeatures"
        case dBInstanceClass = "DBInstanceClass"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case licenseModel = "LicenseModel"
        case maxIopsPerDbInstance = "MaxIopsPerDbInstance"
        case maxIopsPerGib = "MaxIopsPerGib"
        case maxStorageSize = "MaxStorageSize"
        case minIopsPerDbInstance = "MinIopsPerDbInstance"
        case minIopsPerGib = "MinIopsPerGib"
        case minStorageSize = "MinStorageSize"
        case multiAZCapable = "MultiAZCapable"
        case outpostCapable = "OutpostCapable"
        case readReplicaCapable = "ReadReplicaCapable"
        case storageType = "StorageType"
        case supportedActivityStreamModes = "SupportedActivityStreamModes"
        case supportedEngineModes = "SupportedEngineModes"
        case supportsClusters = "SupportsClusters"
        case supportsEnhancedMonitoring = "SupportsEnhancedMonitoring"
        case supportsGlobalDatabases = "SupportsGlobalDatabases"
        case supportsIAMDatabaseAuthentication = "SupportsIAMDatabaseAuthentication"
        case supportsIops = "SupportsIops"
        case supportsKerberosAuthentication = "SupportsKerberosAuthentication"
        case supportsPerformanceInsights = "SupportsPerformanceInsights"
        case supportsStorageAutoscaling = "SupportsStorageAutoscaling"
        case supportsStorageEncryption = "SupportsStorageEncryption"
        case vpc = "Vpc"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZoneGroup = availabilityZoneGroup {
            try container.encode(availabilityZoneGroup, forKey: ClientRuntime.Key("AvailabilityZoneGroup"))
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
            for (index0, availabilityzone0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(availabilityzone0, forKey: ClientRuntime.Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let availableProcessorFeatures = availableProcessorFeatures {
            var availableProcessorFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailableProcessorFeatures"))
            for (index0, availableprocessorfeature0) in availableProcessorFeatures.enumerated() {
                try availableProcessorFeaturesContainer.encode(availableprocessorfeature0, forKey: ClientRuntime.Key("AvailableProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let maxIopsPerDbInstance = maxIopsPerDbInstance {
            try container.encode(maxIopsPerDbInstance, forKey: ClientRuntime.Key("MaxIopsPerDbInstance"))
        }
        if let maxIopsPerGib = maxIopsPerGib {
            try container.encode(maxIopsPerGib, forKey: ClientRuntime.Key("MaxIopsPerGib"))
        }
        if let maxStorageSize = maxStorageSize {
            try container.encode(maxStorageSize, forKey: ClientRuntime.Key("MaxStorageSize"))
        }
        if let minIopsPerDbInstance = minIopsPerDbInstance {
            try container.encode(minIopsPerDbInstance, forKey: ClientRuntime.Key("MinIopsPerDbInstance"))
        }
        if let minIopsPerGib = minIopsPerGib {
            try container.encode(minIopsPerGib, forKey: ClientRuntime.Key("MinIopsPerGib"))
        }
        if let minStorageSize = minStorageSize {
            try container.encode(minStorageSize, forKey: ClientRuntime.Key("MinStorageSize"))
        }
        if multiAZCapable != false {
            try container.encode(multiAZCapable, forKey: ClientRuntime.Key("MultiAZCapable"))
        }
        if outpostCapable != false {
            try container.encode(outpostCapable, forKey: ClientRuntime.Key("OutpostCapable"))
        }
        if readReplicaCapable != false {
            try container.encode(readReplicaCapable, forKey: ClientRuntime.Key("ReadReplicaCapable"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let supportedActivityStreamModes = supportedActivityStreamModes {
            var supportedActivityStreamModesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedActivityStreamModes"))
            for (index0, string0) in supportedActivityStreamModes.enumerated() {
                try supportedActivityStreamModesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedEngineModes = supportedEngineModes {
            var supportedEngineModesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedEngineModes"))
            for (index0, string0) in supportedEngineModes.enumerated() {
                try supportedEngineModesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if supportsClusters != false {
            try container.encode(supportsClusters, forKey: ClientRuntime.Key("SupportsClusters"))
        }
        if supportsEnhancedMonitoring != false {
            try container.encode(supportsEnhancedMonitoring, forKey: ClientRuntime.Key("SupportsEnhancedMonitoring"))
        }
        if supportsGlobalDatabases != false {
            try container.encode(supportsGlobalDatabases, forKey: ClientRuntime.Key("SupportsGlobalDatabases"))
        }
        if supportsIAMDatabaseAuthentication != false {
            try container.encode(supportsIAMDatabaseAuthentication, forKey: ClientRuntime.Key("SupportsIAMDatabaseAuthentication"))
        }
        if supportsIops != false {
            try container.encode(supportsIops, forKey: ClientRuntime.Key("SupportsIops"))
        }
        if let supportsKerberosAuthentication = supportsKerberosAuthentication {
            try container.encode(supportsKerberosAuthentication, forKey: ClientRuntime.Key("SupportsKerberosAuthentication"))
        }
        if supportsPerformanceInsights != false {
            try container.encode(supportsPerformanceInsights, forKey: ClientRuntime.Key("SupportsPerformanceInsights"))
        }
        if let supportsStorageAutoscaling = supportsStorageAutoscaling {
            try container.encode(supportsStorageAutoscaling, forKey: ClientRuntime.Key("SupportsStorageAutoscaling"))
        }
        if supportsStorageEncryption != false {
            try container.encode(supportsStorageEncryption, forKey: ClientRuntime.Key("SupportsStorageEncryption"))
        }
        if vpc != false {
            try container.encode(vpc, forKey: ClientRuntime.Key("Vpc"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let availabilityZoneGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneGroup)
        availabilityZoneGroup = availabilityZoneGroupDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([RdsClientTypes.AvailabilityZone].self, forKey: .member)
                var availabilityZonesBuffer:[RdsClientTypes.AvailabilityZone]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [RdsClientTypes.AvailabilityZone]()
                    for structureContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(structureContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let multiAZCapableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .multiAZCapable)
        multiAZCapable = multiAZCapableDecoded
        let readReplicaCapableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .readReplicaCapable)
        readReplicaCapable = readReplicaCapableDecoded
        let vpcDecoded = try containerValues.decode(Swift.Bool.self, forKey: .vpc)
        vpc = vpcDecoded
        let supportsStorageEncryptionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsStorageEncryption)
        supportsStorageEncryption = supportsStorageEncryptionDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let supportsIopsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsIops)
        supportsIops = supportsIopsDecoded
        let supportsEnhancedMonitoringDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsEnhancedMonitoring)
        supportsEnhancedMonitoring = supportsEnhancedMonitoringDecoded
        let supportsIAMDatabaseAuthenticationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsIAMDatabaseAuthentication)
        supportsIAMDatabaseAuthentication = supportsIAMDatabaseAuthenticationDecoded
        let supportsPerformanceInsightsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsPerformanceInsights)
        supportsPerformanceInsights = supportsPerformanceInsightsDecoded
        let minStorageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minStorageSize)
        minStorageSize = minStorageSizeDecoded
        let maxStorageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxStorageSize)
        maxStorageSize = maxStorageSizeDecoded
        let minIopsPerDbInstanceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minIopsPerDbInstance)
        minIopsPerDbInstance = minIopsPerDbInstanceDecoded
        let maxIopsPerDbInstanceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxIopsPerDbInstance)
        maxIopsPerDbInstance = maxIopsPerDbInstanceDecoded
        let minIopsPerGibDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minIopsPerGib)
        minIopsPerGib = minIopsPerGibDecoded
        let maxIopsPerGibDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maxIopsPerGib)
        maxIopsPerGib = maxIopsPerGibDecoded
        if containerValues.contains(.availableProcessorFeatures) {
            struct KeyVal0{struct AvailableProcessorFeature{}}
            let availableProcessorFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailableProcessorFeature>.CodingKeys.self, forKey: .availableProcessorFeatures)
            if let availableProcessorFeaturesWrappedContainer = availableProcessorFeaturesWrappedContainer {
                let availableProcessorFeaturesContainer = try availableProcessorFeaturesWrappedContainer.decodeIfPresent([RdsClientTypes.AvailableProcessorFeature].self, forKey: .member)
                var availableProcessorFeaturesBuffer:[RdsClientTypes.AvailableProcessorFeature]? = nil
                if let availableProcessorFeaturesContainer = availableProcessorFeaturesContainer {
                    availableProcessorFeaturesBuffer = [RdsClientTypes.AvailableProcessorFeature]()
                    for structureContainer0 in availableProcessorFeaturesContainer {
                        availableProcessorFeaturesBuffer?.append(structureContainer0)
                    }
                }
                availableProcessorFeatures = availableProcessorFeaturesBuffer
            } else {
                availableProcessorFeatures = []
            }
        } else {
            availableProcessorFeatures = nil
        }
        if containerValues.contains(.supportedEngineModes) {
            struct KeyVal0{struct member{}}
            let supportedEngineModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedEngineModes)
            if let supportedEngineModesWrappedContainer = supportedEngineModesWrappedContainer {
                let supportedEngineModesContainer = try supportedEngineModesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedEngineModesBuffer:[Swift.String]? = nil
                if let supportedEngineModesContainer = supportedEngineModesContainer {
                    supportedEngineModesBuffer = [Swift.String]()
                    for stringContainer0 in supportedEngineModesContainer {
                        supportedEngineModesBuffer?.append(stringContainer0)
                    }
                }
                supportedEngineModes = supportedEngineModesBuffer
            } else {
                supportedEngineModes = []
            }
        } else {
            supportedEngineModes = nil
        }
        let supportsStorageAutoscalingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsStorageAutoscaling)
        supportsStorageAutoscaling = supportsStorageAutoscalingDecoded
        let supportsKerberosAuthenticationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsKerberosAuthentication)
        supportsKerberosAuthentication = supportsKerberosAuthenticationDecoded
        let outpostCapableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .outpostCapable)
        outpostCapable = outpostCapableDecoded
        if containerValues.contains(.supportedActivityStreamModes) {
            struct KeyVal0{struct member{}}
            let supportedActivityStreamModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedActivityStreamModes)
            if let supportedActivityStreamModesWrappedContainer = supportedActivityStreamModesWrappedContainer {
                let supportedActivityStreamModesContainer = try supportedActivityStreamModesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedActivityStreamModesBuffer:[Swift.String]? = nil
                if let supportedActivityStreamModesContainer = supportedActivityStreamModesContainer {
                    supportedActivityStreamModesBuffer = [Swift.String]()
                    for stringContainer0 in supportedActivityStreamModesContainer {
                        supportedActivityStreamModesBuffer?.append(stringContainer0)
                    }
                }
                supportedActivityStreamModes = supportedActivityStreamModesBuffer
            } else {
                supportedActivityStreamModes = []
            }
        } else {
            supportedActivityStreamModes = nil
        }
        let supportsGlobalDatabasesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsGlobalDatabases)
        supportsGlobalDatabases = supportsGlobalDatabasesDecoded
        let supportsClustersDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsClusters)
        supportsClusters = supportsClustersDecoded
    }
}

extension RdsClientTypes {
    /// Contains a list of available options for a DB instance. This data type is used as a response element in the DescribeOrderableDBInstanceOptions action.
    public struct OrderableDBInstanceOption: Swift.Equatable {
        /// The Availability Zone group for a DB instance.
        public var availabilityZoneGroup: Swift.String?
        /// A list of Availability Zones for a DB instance.
        public var availabilityZones: [RdsClientTypes.AvailabilityZone]?
        /// A list of the available processor features for the DB instance class of a DB instance.
        public var availableProcessorFeatures: [RdsClientTypes.AvailableProcessorFeature]?
        /// The DB instance class for a DB instance.
        public var dBInstanceClass: Swift.String?
        /// The engine type of a DB instance.
        public var engine: Swift.String?
        /// The engine version of a DB instance.
        public var engineVersion: Swift.String?
        /// The license model for a DB instance.
        public var licenseModel: Swift.String?
        /// Maximum total provisioned IOPS for a DB instance.
        public var maxIopsPerDbInstance: Swift.Int?
        /// Maximum provisioned IOPS per GiB for a DB instance.
        public var maxIopsPerGib: Swift.Double?
        /// Maximum storage size for a DB instance.
        public var maxStorageSize: Swift.Int?
        /// Minimum total provisioned IOPS for a DB instance.
        public var minIopsPerDbInstance: Swift.Int?
        /// Minimum provisioned IOPS per GiB for a DB instance.
        public var minIopsPerGib: Swift.Double?
        /// Minimum storage size for a DB instance.
        public var minStorageSize: Swift.Int?
        /// Indicates whether a DB instance is Multi-AZ capable.
        public var multiAZCapable: Swift.Bool
        /// Whether a DB instance supports RDS on Outposts. For more information about RDS on Outposts, see [Amazon RDS on Amazon Web Services Outposts](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html) in the Amazon RDS User Guide.
        public var outpostCapable: Swift.Bool
        /// Indicates whether a DB instance can have a read replica.
        public var readReplicaCapable: Swift.Bool
        /// Indicates the storage type for a DB instance.
        public var storageType: Swift.String?
        /// The list of supported modes for Database Activity Streams. Aurora PostgreSQL returns the value [sync, async]. Aurora MySQL and RDS for Oracle return [async] only. If Database Activity Streams isn't supported, the return value is an empty list.
        public var supportedActivityStreamModes: [Swift.String]?
        /// A list of the supported DB engine modes.
        public var supportedEngineModes: [Swift.String]?
        /// Whether DB instances can be configured as a Multi-AZ DB cluster. The Multi-AZ DB clusters feature is in preview and is subject to change. For more information on Multi-AZ DB clusters, see [ Multi-AZ deployments with two readable standby DB instances](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/multi-az-db-clusters-concepts.html) in the Amazon RDS User Guide.
        public var supportsClusters: Swift.Bool
        /// Indicates whether a DB instance supports Enhanced Monitoring at intervals from 1 to 60 seconds.
        public var supportsEnhancedMonitoring: Swift.Bool
        /// A value that indicates whether you can use Aurora global databases with a specific combination of other DB engine attributes.
        public var supportsGlobalDatabases: Swift.Bool
        /// Indicates whether a DB instance supports IAM database authentication.
        public var supportsIAMDatabaseAuthentication: Swift.Bool
        /// Indicates whether a DB instance supports provisioned IOPS.
        public var supportsIops: Swift.Bool
        /// Whether a DB instance supports Kerberos Authentication.
        public var supportsKerberosAuthentication: Swift.Bool?
        /// True if a DB instance supports Performance Insights, otherwise false.
        public var supportsPerformanceInsights: Swift.Bool
        /// Whether Amazon RDS can automatically scale storage for DB instances that use the specified DB instance class.
        public var supportsStorageAutoscaling: Swift.Bool?
        /// Indicates whether a DB instance supports encrypted storage.
        public var supportsStorageEncryption: Swift.Bool
        /// Indicates whether a DB instance is in a VPC.
        public var vpc: Swift.Bool

        public init (
            availabilityZoneGroup: Swift.String? = nil,
            availabilityZones: [RdsClientTypes.AvailabilityZone]? = nil,
            availableProcessorFeatures: [RdsClientTypes.AvailableProcessorFeature]? = nil,
            dBInstanceClass: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            licenseModel: Swift.String? = nil,
            maxIopsPerDbInstance: Swift.Int? = nil,
            maxIopsPerGib: Swift.Double? = nil,
            maxStorageSize: Swift.Int? = nil,
            minIopsPerDbInstance: Swift.Int? = nil,
            minIopsPerGib: Swift.Double? = nil,
            minStorageSize: Swift.Int? = nil,
            multiAZCapable: Swift.Bool = false,
            outpostCapable: Swift.Bool = false,
            readReplicaCapable: Swift.Bool = false,
            storageType: Swift.String? = nil,
            supportedActivityStreamModes: [Swift.String]? = nil,
            supportedEngineModes: [Swift.String]? = nil,
            supportsClusters: Swift.Bool = false,
            supportsEnhancedMonitoring: Swift.Bool = false,
            supportsGlobalDatabases: Swift.Bool = false,
            supportsIAMDatabaseAuthentication: Swift.Bool = false,
            supportsIops: Swift.Bool = false,
            supportsKerberosAuthentication: Swift.Bool? = nil,
            supportsPerformanceInsights: Swift.Bool = false,
            supportsStorageAutoscaling: Swift.Bool? = nil,
            supportsStorageEncryption: Swift.Bool = false,
            vpc: Swift.Bool = false
        )
        {
            self.availabilityZoneGroup = availabilityZoneGroup
            self.availabilityZones = availabilityZones
            self.availableProcessorFeatures = availableProcessorFeatures
            self.dBInstanceClass = dBInstanceClass
            self.engine = engine
            self.engineVersion = engineVersion
            self.licenseModel = licenseModel
            self.maxIopsPerDbInstance = maxIopsPerDbInstance
            self.maxIopsPerGib = maxIopsPerGib
            self.maxStorageSize = maxStorageSize
            self.minIopsPerDbInstance = minIopsPerDbInstance
            self.minIopsPerGib = minIopsPerGib
            self.minStorageSize = minStorageSize
            self.multiAZCapable = multiAZCapable
            self.outpostCapable = outpostCapable
            self.readReplicaCapable = readReplicaCapable
            self.storageType = storageType
            self.supportedActivityStreamModes = supportedActivityStreamModes
            self.supportedEngineModes = supportedEngineModes
            self.supportsClusters = supportsClusters
            self.supportsEnhancedMonitoring = supportsEnhancedMonitoring
            self.supportsGlobalDatabases = supportsGlobalDatabases
            self.supportsIAMDatabaseAuthentication = supportsIAMDatabaseAuthentication
            self.supportsIops = supportsIops
            self.supportsKerberosAuthentication = supportsKerberosAuthentication
            self.supportsPerformanceInsights = supportsPerformanceInsights
            self.supportsStorageAutoscaling = supportsStorageAutoscaling
            self.supportsStorageEncryption = supportsStorageEncryption
            self.vpc = vpc
        }
    }

}

extension RdsClientTypes.Outpost: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension RdsClientTypes {
    /// A data type that represents an Outpost. For more information about RDS on Outposts, see [Amazon RDS on Amazon Web Services Outposts](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html) in the Amazon RDS User Guide.
    public struct Outpost: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Outpost.
        public var arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension RdsClientTypes.Parameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues = "AllowedValues"
        case applyMethod = "ApplyMethod"
        case applyType = "ApplyType"
        case dataType = "DataType"
        case description = "Description"
        case isModifiable = "IsModifiable"
        case minimumEngineVersion = "MinimumEngineVersion"
        case parameterName = "ParameterName"
        case parameterValue = "ParameterValue"
        case source = "Source"
        case supportedEngineModes = "SupportedEngineModes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allowedValues = allowedValues {
            try container.encode(allowedValues, forKey: ClientRuntime.Key("AllowedValues"))
        }
        if let applyMethod = applyMethod {
            try container.encode(applyMethod, forKey: ClientRuntime.Key("ApplyMethod"))
        }
        if let applyType = applyType {
            try container.encode(applyType, forKey: ClientRuntime.Key("ApplyType"))
        }
        if let dataType = dataType {
            try container.encode(dataType, forKey: ClientRuntime.Key("DataType"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if isModifiable != false {
            try container.encode(isModifiable, forKey: ClientRuntime.Key("IsModifiable"))
        }
        if let minimumEngineVersion = minimumEngineVersion {
            try container.encode(minimumEngineVersion, forKey: ClientRuntime.Key("MinimumEngineVersion"))
        }
        if let parameterName = parameterName {
            try container.encode(parameterName, forKey: ClientRuntime.Key("ParameterName"))
        }
        if let parameterValue = parameterValue {
            try container.encode(parameterValue, forKey: ClientRuntime.Key("ParameterValue"))
        }
        if let source = source {
            try container.encode(source, forKey: ClientRuntime.Key("Source"))
        }
        if let supportedEngineModes = supportedEngineModes {
            var supportedEngineModesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedEngineModes"))
            for (index0, string0) in supportedEngineModes.enumerated() {
                try supportedEngineModesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let applyTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applyType)
        applyType = applyTypeDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let allowedValuesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedValues)
        allowedValues = allowedValuesDecoded
        let isModifiableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isModifiable)
        isModifiable = isModifiableDecoded
        let minimumEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minimumEngineVersion)
        minimumEngineVersion = minimumEngineVersionDecoded
        let applyMethodDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ApplyMethod.self, forKey: .applyMethod)
        applyMethod = applyMethodDecoded
        if containerValues.contains(.supportedEngineModes) {
            struct KeyVal0{struct member{}}
            let supportedEngineModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedEngineModes)
            if let supportedEngineModesWrappedContainer = supportedEngineModesWrappedContainer {
                let supportedEngineModesContainer = try supportedEngineModesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedEngineModesBuffer:[Swift.String]? = nil
                if let supportedEngineModesContainer = supportedEngineModesContainer {
                    supportedEngineModesBuffer = [Swift.String]()
                    for stringContainer0 in supportedEngineModesContainer {
                        supportedEngineModesBuffer?.append(stringContainer0)
                    }
                }
                supportedEngineModes = supportedEngineModesBuffer
            } else {
                supportedEngineModes = []
            }
        } else {
            supportedEngineModes = nil
        }
    }
}

extension RdsClientTypes {
    /// This data type is used as a request parameter in the ModifyDBParameterGroup and ResetDBParameterGroup actions. This data type is used as a response element in the DescribeEngineDefaultParameters and DescribeDBParameters actions.
    public struct Parameter: Swift.Equatable {
        /// Specifies the valid range of values for the parameter.
        public var allowedValues: Swift.String?
        /// Indicates when to apply parameter updates.
        public var applyMethod: RdsClientTypes.ApplyMethod?
        /// Specifies the engine specific parameters type.
        public var applyType: Swift.String?
        /// Specifies the valid data type for the parameter.
        public var dataType: Swift.String?
        /// Provides a description of the parameter.
        public var description: Swift.String?
        /// Indicates whether (true) or not (false) the parameter can be modified. Some parameters have security or operational implications that prevent them from being changed.
        public var isModifiable: Swift.Bool
        /// The earliest engine version to which the parameter can apply.
        public var minimumEngineVersion: Swift.String?
        /// Specifies the name of the parameter.
        public var parameterName: Swift.String?
        /// Specifies the value of the parameter.
        public var parameterValue: Swift.String?
        /// Indicates the source of the parameter value.
        public var source: Swift.String?
        /// The valid DB engine modes.
        public var supportedEngineModes: [Swift.String]?

        public init (
            allowedValues: Swift.String? = nil,
            applyMethod: RdsClientTypes.ApplyMethod? = nil,
            applyType: Swift.String? = nil,
            dataType: Swift.String? = nil,
            description: Swift.String? = nil,
            isModifiable: Swift.Bool = false,
            minimumEngineVersion: Swift.String? = nil,
            parameterName: Swift.String? = nil,
            parameterValue: Swift.String? = nil,
            source: Swift.String? = nil,
            supportedEngineModes: [Swift.String]? = nil
        )
        {
            self.allowedValues = allowedValues
            self.applyMethod = applyMethod
            self.applyType = applyType
            self.dataType = dataType
            self.description = description
            self.isModifiable = isModifiable
            self.minimumEngineVersion = minimumEngineVersion
            self.parameterName = parameterName
            self.parameterValue = parameterValue
            self.source = source
            self.supportedEngineModes = supportedEngineModes
        }
    }

}

extension RdsClientTypes.PendingCloudwatchLogsExports: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logTypesToDisable = "LogTypesToDisable"
        case logTypesToEnable = "LogTypesToEnable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let logTypesToDisable = logTypesToDisable {
            var logTypesToDisableContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LogTypesToDisable"))
            for (index0, string0) in logTypesToDisable.enumerated() {
                try logTypesToDisableContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let logTypesToEnable = logTypesToEnable {
            var logTypesToEnableContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LogTypesToEnable"))
            for (index0, string0) in logTypesToEnable.enumerated() {
                try logTypesToEnableContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.logTypesToEnable) {
            struct KeyVal0{struct member{}}
            let logTypesToEnableWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .logTypesToEnable)
            if let logTypesToEnableWrappedContainer = logTypesToEnableWrappedContainer {
                let logTypesToEnableContainer = try logTypesToEnableWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var logTypesToEnableBuffer:[Swift.String]? = nil
                if let logTypesToEnableContainer = logTypesToEnableContainer {
                    logTypesToEnableBuffer = [Swift.String]()
                    for stringContainer0 in logTypesToEnableContainer {
                        logTypesToEnableBuffer?.append(stringContainer0)
                    }
                }
                logTypesToEnable = logTypesToEnableBuffer
            } else {
                logTypesToEnable = []
            }
        } else {
            logTypesToEnable = nil
        }
        if containerValues.contains(.logTypesToDisable) {
            struct KeyVal0{struct member{}}
            let logTypesToDisableWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .logTypesToDisable)
            if let logTypesToDisableWrappedContainer = logTypesToDisableWrappedContainer {
                let logTypesToDisableContainer = try logTypesToDisableWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var logTypesToDisableBuffer:[Swift.String]? = nil
                if let logTypesToDisableContainer = logTypesToDisableContainer {
                    logTypesToDisableBuffer = [Swift.String]()
                    for stringContainer0 in logTypesToDisableContainer {
                        logTypesToDisableBuffer?.append(stringContainer0)
                    }
                }
                logTypesToDisable = logTypesToDisableBuffer
            } else {
                logTypesToDisable = []
            }
        } else {
            logTypesToDisable = nil
        }
    }
}

extension RdsClientTypes {
    /// A list of the log types whose configuration is still pending. In other words, these log types are in the process of being activated or deactivated.
    public struct PendingCloudwatchLogsExports: Swift.Equatable {
        /// Log types that are in the process of being enabled. After they are enabled, these log types are exported to CloudWatch Logs.
        public var logTypesToDisable: [Swift.String]?
        /// Log types that are in the process of being deactivated. After they are deactivated, these log types aren't exported to CloudWatch Logs.
        public var logTypesToEnable: [Swift.String]?

        public init (
            logTypesToDisable: [Swift.String]? = nil,
            logTypesToEnable: [Swift.String]? = nil
        )
        {
            self.logTypesToDisable = logTypesToDisable
            self.logTypesToEnable = logTypesToEnable
        }
    }

}

extension RdsClientTypes.PendingMaintenanceAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case autoAppliedAfterDate = "AutoAppliedAfterDate"
        case currentApplyDate = "CurrentApplyDate"
        case description = "Description"
        case forcedApplyDate = "ForcedApplyDate"
        case optInStatus = "OptInStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let action = action {
            try container.encode(action, forKey: ClientRuntime.Key("Action"))
        }
        if let autoAppliedAfterDate = autoAppliedAfterDate {
            try container.encode(ClientRuntime.TimestampWrapper(autoAppliedAfterDate, format: .dateTime), forKey: ClientRuntime.Key("autoAppliedAfterDate"))
        }
        if let currentApplyDate = currentApplyDate {
            try container.encode(ClientRuntime.TimestampWrapper(currentApplyDate, format: .dateTime), forKey: ClientRuntime.Key("currentApplyDate"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let forcedApplyDate = forcedApplyDate {
            try container.encode(ClientRuntime.TimestampWrapper(forcedApplyDate, format: .dateTime), forKey: ClientRuntime.Key("forcedApplyDate"))
        }
        if let optInStatus = optInStatus {
            try container.encode(optInStatus, forKey: ClientRuntime.Key("OptInStatus"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let autoAppliedAfterDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoAppliedAfterDate)
        var autoAppliedAfterDateBuffer:ClientRuntime.Date? = nil
        if let autoAppliedAfterDateDecoded = autoAppliedAfterDateDecoded {
            autoAppliedAfterDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(autoAppliedAfterDateDecoded, format: .dateTime)
        }
        autoAppliedAfterDate = autoAppliedAfterDateBuffer
        let forcedApplyDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forcedApplyDate)
        var forcedApplyDateBuffer:ClientRuntime.Date? = nil
        if let forcedApplyDateDecoded = forcedApplyDateDecoded {
            forcedApplyDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(forcedApplyDateDecoded, format: .dateTime)
        }
        forcedApplyDate = forcedApplyDateBuffer
        let optInStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optInStatus)
        optInStatus = optInStatusDecoded
        let currentApplyDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentApplyDate)
        var currentApplyDateBuffer:ClientRuntime.Date? = nil
        if let currentApplyDateDecoded = currentApplyDateDecoded {
            currentApplyDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(currentApplyDateDecoded, format: .dateTime)
        }
        currentApplyDate = currentApplyDateBuffer
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension RdsClientTypes {
    /// Provides information about a pending maintenance action for a resource.
    public struct PendingMaintenanceAction: Swift.Equatable {
        /// The type of pending maintenance action that is available for the resource. Valid actions are system-update, db-upgrade, hardware-maintenance, and ca-certificate-rotation.
        public var action: Swift.String?
        /// The date of the maintenance window when the action is applied. The maintenance action is applied to the resource during its first maintenance window after this date.
        public var autoAppliedAfterDate: ClientRuntime.Date?
        /// The effective date when the pending maintenance action is applied to the resource. This date takes into account opt-in requests received from the ApplyPendingMaintenanceAction API, the AutoAppliedAfterDate, and the ForcedApplyDate. This value is blank if an opt-in request has not been received and nothing has been specified as AutoAppliedAfterDate or ForcedApplyDate.
        public var currentApplyDate: ClientRuntime.Date?
        /// A description providing more detail about the maintenance action.
        public var description: Swift.String?
        /// The date when the maintenance action is automatically applied. On this date, the maintenance action is applied to the resource as soon as possible, regardless of the maintenance window for the resource. There might be a delay of one or more days from this date before the maintenance action is applied.
        public var forcedApplyDate: ClientRuntime.Date?
        /// Indicates the type of opt-in request that has been received for the resource.
        public var optInStatus: Swift.String?

        public init (
            action: Swift.String? = nil,
            autoAppliedAfterDate: ClientRuntime.Date? = nil,
            currentApplyDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            forcedApplyDate: ClientRuntime.Date? = nil,
            optInStatus: Swift.String? = nil
        )
        {
            self.action = action
            self.autoAppliedAfterDate = autoAppliedAfterDate
            self.currentApplyDate = currentApplyDate
            self.description = description
            self.forcedApplyDate = forcedApplyDate
            self.optInStatus = optInStatus
        }
    }

}

extension RdsClientTypes.PendingModifiedValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case automationMode = "AutomationMode"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case cACertificateIdentifier = "CACertificateIdentifier"
        case dBInstanceClass = "DBInstanceClass"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case engineVersion = "EngineVersion"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case iops = "Iops"
        case licenseModel = "LicenseModel"
        case masterUserPassword = "MasterUserPassword"
        case multiAZ = "MultiAZ"
        case pendingCloudwatchLogsExports = "PendingCloudwatchLogsExports"
        case port = "Port"
        case processorFeatures = "ProcessorFeatures"
        case resumeFullAutomationModeTime = "ResumeFullAutomationModeTime"
        case storageType = "StorageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if let automationMode = automationMode {
            try container.encode(automationMode, forKey: ClientRuntime.Key("AutomationMode"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let cACertificateIdentifier = cACertificateIdentifier {
            try container.encode(cACertificateIdentifier, forKey: ClientRuntime.Key("CACertificateIdentifier"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: ClientRuntime.Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let pendingCloudwatchLogsExports = pendingCloudwatchLogsExports {
            try container.encode(pendingCloudwatchLogsExports, forKey: ClientRuntime.Key("PendingCloudwatchLogsExports"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: ClientRuntime.Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let resumeFullAutomationModeTime = resumeFullAutomationModeTime {
            try container.encode(ClientRuntime.TimestampWrapper(resumeFullAutomationModeTime, format: .dateTime), forKey: ClientRuntime.Key("resumeFullAutomationModeTime"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let masterUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUserPassword)
        masterUserPassword = masterUserPasswordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let cACertificateIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cACertificateIdentifier)
        cACertificateIdentifier = cACertificateIdentifierDecoded
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        let pendingCloudwatchLogsExportsDecoded = try containerValues.decodeIfPresent(RdsClientTypes.PendingCloudwatchLogsExports.self, forKey: .pendingCloudwatchLogsExports)
        pendingCloudwatchLogsExports = pendingCloudwatchLogsExportsDecoded
        if containerValues.contains(.processorFeatures) {
            struct KeyVal0{struct ProcessorFeature{}}
            let processorFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ProcessorFeature>.CodingKeys.self, forKey: .processorFeatures)
            if let processorFeaturesWrappedContainer = processorFeaturesWrappedContainer {
                let processorFeaturesContainer = try processorFeaturesWrappedContainer.decodeIfPresent([RdsClientTypes.ProcessorFeature].self, forKey: .member)
                var processorFeaturesBuffer:[RdsClientTypes.ProcessorFeature]? = nil
                if let processorFeaturesContainer = processorFeaturesContainer {
                    processorFeaturesBuffer = [RdsClientTypes.ProcessorFeature]()
                    for structureContainer0 in processorFeaturesContainer {
                        processorFeaturesBuffer?.append(structureContainer0)
                    }
                }
                processorFeatures = processorFeaturesBuffer
            } else {
                processorFeatures = []
            }
        } else {
            processorFeatures = nil
        }
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        let automationModeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.AutomationMode.self, forKey: .automationMode)
        automationMode = automationModeDecoded
        let resumeFullAutomationModeTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resumeFullAutomationModeTime)
        var resumeFullAutomationModeTimeBuffer:ClientRuntime.Date? = nil
        if let resumeFullAutomationModeTimeDecoded = resumeFullAutomationModeTimeDecoded {
            resumeFullAutomationModeTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(resumeFullAutomationModeTimeDecoded, format: .dateTime)
        }
        resumeFullAutomationModeTime = resumeFullAutomationModeTimeBuffer
    }
}

extension RdsClientTypes {
    /// This data type is used as a response element in the ModifyDBInstance operation and contains changes that will be applied during the next maintenance window.
    public struct PendingModifiedValues: Swift.Equatable {
        /// The allocated storage size for the DB instance specified in gibibytes (GiB).
        public var allocatedStorage: Swift.Int?
        /// The automation mode of the RDS Custom DB instance: full or all-paused. If full, the DB instance automates monitoring and instance recovery. If all-paused, the instance pauses automation for the duration set by --resume-full-automation-mode-minutes.
        public var automationMode: RdsClientTypes.AutomationMode?
        /// The number of days for which automated backups are retained.
        public var backupRetentionPeriod: Swift.Int?
        /// The identifier of the CA certificate for the DB instance.
        public var cACertificateIdentifier: Swift.String?
        /// The name of the compute and memory capacity class for the DB instance.
        public var dBInstanceClass: Swift.String?
        /// The database identifier for the DB instance.
        public var dBInstanceIdentifier: Swift.String?
        /// The DB subnet group for the DB instance.
        public var dBSubnetGroupName: Swift.String?
        /// The database engine version.
        public var engineVersion: Swift.String?
        /// Whether mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled.
        public var iAMDatabaseAuthenticationEnabled: Swift.Bool?
        /// The Provisioned IOPS value for the DB instance.
        public var iops: Swift.Int?
        /// The license model for the DB instance. Valid values: license-included | bring-your-own-license | general-public-license
        public var licenseModel: Swift.String?
        /// The master credentials for the DB instance.
        public var masterUserPassword: Swift.String?
        /// A value that indicates that the Single-AZ DB instance will change to a Multi-AZ deployment.
        public var multiAZ: Swift.Bool?
        /// A list of the log types whose configuration is still pending. In other words, these log types are in the process of being activated or deactivated.
        public var pendingCloudwatchLogsExports: RdsClientTypes.PendingCloudwatchLogsExports?
        /// The port for the DB instance.
        public var port: Swift.Int?
        /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.
        public var processorFeatures: [RdsClientTypes.ProcessorFeature]?
        /// The number of minutes to pause the automation. When the time period ends, RDS Custom resumes full automation. The minimum value is 60 (default). The maximum value is 1,440.
        public var resumeFullAutomationModeTime: ClientRuntime.Date?
        /// The storage type of the DB instance.
        public var storageType: Swift.String?

        public init (
            allocatedStorage: Swift.Int? = nil,
            automationMode: RdsClientTypes.AutomationMode? = nil,
            backupRetentionPeriod: Swift.Int? = nil,
            cACertificateIdentifier: Swift.String? = nil,
            dBInstanceClass: Swift.String? = nil,
            dBInstanceIdentifier: Swift.String? = nil,
            dBSubnetGroupName: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            iAMDatabaseAuthenticationEnabled: Swift.Bool? = nil,
            iops: Swift.Int? = nil,
            licenseModel: Swift.String? = nil,
            masterUserPassword: Swift.String? = nil,
            multiAZ: Swift.Bool? = nil,
            pendingCloudwatchLogsExports: RdsClientTypes.PendingCloudwatchLogsExports? = nil,
            port: Swift.Int? = nil,
            processorFeatures: [RdsClientTypes.ProcessorFeature]? = nil,
            resumeFullAutomationModeTime: ClientRuntime.Date? = nil,
            storageType: Swift.String? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.automationMode = automationMode
            self.backupRetentionPeriod = backupRetentionPeriod
            self.cACertificateIdentifier = cACertificateIdentifier
            self.dBInstanceClass = dBInstanceClass
            self.dBInstanceIdentifier = dBInstanceIdentifier
            self.dBSubnetGroupName = dBSubnetGroupName
            self.engineVersion = engineVersion
            self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
            self.iops = iops
            self.licenseModel = licenseModel
            self.masterUserPassword = masterUserPassword
            self.multiAZ = multiAZ
            self.pendingCloudwatchLogsExports = pendingCloudwatchLogsExports
            self.port = port
            self.processorFeatures = processorFeatures
            self.resumeFullAutomationModeTime = resumeFullAutomationModeTime
            self.storageType = storageType
        }
    }

}

extension PointInTimeRestoreNotEnabledFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<PointInTimeRestoreNotEnabledFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// SourceDBInstanceIdentifier refers to a DB instance with BackupRetentionPeriod equal to 0.
public struct PointInTimeRestoreNotEnabledFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PointInTimeRestoreNotEnabledFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension PointInTimeRestoreNotEnabledFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.ProcessorFeature: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension RdsClientTypes {
    /// Contains the processor features of a DB instance class. To specify the number of CPU cores, use the coreCount feature name for the Name parameter. To specify the number of threads per core, use the threadsPerCore feature name for the Name parameter. You can set the processor features of the DB instance class for a DB instance when you call one of the following actions:
    ///
    /// * CreateDBInstance
    ///
    /// * ModifyDBInstance
    ///
    /// * RestoreDBInstanceFromDBSnapshot
    ///
    /// * RestoreDBInstanceFromS3
    ///
    /// * RestoreDBInstanceToPointInTime
    ///
    ///
    /// You can view the valid processor values for a particular instance class by calling the DescribeOrderableDBInstanceOptions action and specifying the instance class for the DBInstanceClass parameter. In addition, you can use the following actions for DB instance class processor information:
    ///
    /// * DescribeDBInstances
    ///
    /// * DescribeDBSnapshots
    ///
    /// * DescribeValidDBInstanceModifications
    ///
    ///
    /// If you call DescribeDBInstances, ProcessorFeature returns non-null values only if the following conditions are met:
    ///
    /// * You are accessing an Oracle DB instance.
    ///
    /// * Your Oracle DB instance class supports configuring the number of CPU cores and threads per core.
    ///
    /// * The current number CPU cores and threads is set to a non-default value.
    ///
    ///
    /// For more information, see [Configuring the Processor of the DB Instance Class](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html#USER_ConfigureProcessor) in the Amazon RDS User Guide.
    public struct ProcessorFeature: Swift.Equatable {
        /// The name of the processor feature. Valid names are coreCount and threadsPerCore.
        public var name: Swift.String?
        /// The value of a processor feature name.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension PromoteReadReplicaDBClusterInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        try container.encode("PromoteReadReplicaDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension PromoteReadReplicaDBClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct PromoteReadReplicaDBClusterInput: Swift.Equatable {
    /// The identifier of the DB cluster read replica to promote. This parameter isn't case-sensitive. Constraints:
    ///
    /// * Must match the identifier of an existing DB cluster read replica.
    ///
    ///
    /// Example: my-cluster-replica1
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?

    public init (
        dBClusterIdentifier: Swift.String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
    }
}

struct PromoteReadReplicaDBClusterInputBody: Swift.Equatable {
    let dBClusterIdentifier: Swift.String?
}

extension PromoteReadReplicaDBClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterIdentifier = "DBClusterIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
    }
}

extension PromoteReadReplicaDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PromoteReadReplicaDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PromoteReadReplicaDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension PromoteReadReplicaDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PromoteReadReplicaDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct PromoteReadReplicaDBClusterOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon Aurora DB cluster or Multi-AZ DB cluster. For an Amazon Aurora DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, PromoteReadReplicaDBCluster, RestoreDBClusterFromS3, RestoreDBClusterFromSnapshot, RestoreDBClusterToPointInTime, StartDBCluster, and StopDBCluster. For a Multi-AZ DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, RebootDBCluster, RestoreDBClusterFromSnapshot, and RestoreDBClusterToPointInTime. For more information on Amazon Aurora DB clusters, see [ What is Amazon Aurora?](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/CHAP_AuroraOverview.html) in the Amazon Aurora User Guide. For more information on Multi-AZ DB clusters, see [ Multi-AZ deployments with two readable standby DB instances](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/multi-az-db-clusters-concepts.html) in the Amazon RDS User Guide. The Multi-AZ DB clusters feature is in preview and is subject to change.
    public var dBCluster: RdsClientTypes.DBCluster?

    public init (
        dBCluster: RdsClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct PromoteReadReplicaDBClusterOutputResponseBody: Swift.Equatable {
    let dBCluster: RdsClientTypes.DBCluster?
}

extension PromoteReadReplicaDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("PromoteReadReplicaDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

extension PromoteReadReplicaInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        try container.encode("PromoteReadReplica", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension PromoteReadReplicaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct PromoteReadReplicaInput: Swift.Equatable {
    /// The number of days for which automated backups are retained. Setting this parameter to a positive number enables backups. Setting this parameter to 0 disables automated backups. Default: 1 Constraints:
    ///
    /// * Must be a value from 0 to 35.
    ///
    /// * Can't be set to 0 if the DB instance is a source to read replicas.
    public var backupRetentionPeriod: Swift.Int?
    /// The DB instance identifier. This value is stored as a lowercase string. Constraints:
    ///
    /// * Must match the identifier of an existing read replica DB instance.
    ///
    ///
    /// Example: mydbinstance
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// The daily time range during which automated backups are created if automated backups are enabled, using the BackupRetentionPeriod parameter. The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region. To see the time blocks available, see [ Adjusting the Preferred Maintenance Window](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/AdjustingTheMaintenanceWindow.html) in the Amazon RDS User Guide. Constraints:
    ///
    /// * Must be in the format hh24:mi-hh24:mi.
    ///
    /// * Must be in Universal Coordinated Time (UTC).
    ///
    /// * Must not conflict with the preferred maintenance window.
    ///
    /// * Must be at least 30 minutes.
    public var preferredBackupWindow: Swift.String?

    public init (
        backupRetentionPeriod: Swift.Int? = nil,
        dBInstanceIdentifier: Swift.String? = nil,
        preferredBackupWindow: Swift.String? = nil
    )
    {
        self.backupRetentionPeriod = backupRetentionPeriod
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.preferredBackupWindow = preferredBackupWindow
    }
}

struct PromoteReadReplicaInputBody: Swift.Equatable {
    let dBInstanceIdentifier: Swift.String?
    let backupRetentionPeriod: Swift.Int?
    let preferredBackupWindow: Swift.String?
}

extension PromoteReadReplicaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case preferredBackupWindow = "PreferredBackupWindow"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
    }
}

extension PromoteReadReplicaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PromoteReadReplicaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PromoteReadReplicaOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension PromoteReadReplicaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PromoteReadReplicaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct PromoteReadReplicaOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB instance. This data type is used as a response element in the operations CreateDBInstance, CreateDBInstanceReadReplica, DeleteDBInstance, DescribeDBInstances, ModifyDBInstance, PromoteReadReplica, RebootDBInstance, RestoreDBInstanceFromDBSnapshot, RestoreDBInstanceFromS3, RestoreDBInstanceToPointInTime, StartDBInstance, and StopDBInstance.
    public var dBInstance: RdsClientTypes.DBInstance?

    public init (
        dBInstance: RdsClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct PromoteReadReplicaOutputResponseBody: Swift.Equatable {
    let dBInstance: RdsClientTypes.DBInstance?
}

extension PromoteReadReplicaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("PromoteReadReplicaResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

extension ProvisionedIopsNotAvailableInAZFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ProvisionedIopsNotAvailableInAZFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Provisioned IOPS not available in the specified Availability Zone.
public struct ProvisionedIopsNotAvailableInAZFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ProvisionedIopsNotAvailableInAZFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ProvisionedIopsNotAvailableInAZFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PurchaseReservedDBInstancesOfferingInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceCount = dBInstanceCount {
            try container.encode(dBInstanceCount, forKey: ClientRuntime.Key("DBInstanceCount"))
        }
        if let reservedDBInstanceId = reservedDBInstanceId {
            try container.encode(reservedDBInstanceId, forKey: ClientRuntime.Key("ReservedDBInstanceId"))
        }
        if let reservedDBInstancesOfferingId = reservedDBInstancesOfferingId {
            try container.encode(reservedDBInstancesOfferingId, forKey: ClientRuntime.Key("ReservedDBInstancesOfferingId"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("PurchaseReservedDBInstancesOffering", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension PurchaseReservedDBInstancesOfferingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct PurchaseReservedDBInstancesOfferingInput: Swift.Equatable {
    /// The number of instances to reserve. Default: 1
    public var dBInstanceCount: Swift.Int?
    /// Customer-specified identifier to track this reservation. Example: myreservationID
    public var reservedDBInstanceId: Swift.String?
    /// The ID of the Reserved DB instance offering to purchase. Example: 438012d3-4052-4cc7-b2e3-8d3372e0e706
    /// This member is required.
    public var reservedDBInstancesOfferingId: Swift.String?
    /// A list of tags. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
    public var tags: [RdsClientTypes.Tag]?

    public init (
        dBInstanceCount: Swift.Int? = nil,
        reservedDBInstanceId: Swift.String? = nil,
        reservedDBInstancesOfferingId: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil
    )
    {
        self.dBInstanceCount = dBInstanceCount
        self.reservedDBInstanceId = reservedDBInstanceId
        self.reservedDBInstancesOfferingId = reservedDBInstancesOfferingId
        self.tags = tags
    }
}

struct PurchaseReservedDBInstancesOfferingInputBody: Swift.Equatable {
    let reservedDBInstancesOfferingId: Swift.String?
    let reservedDBInstanceId: Swift.String?
    let dBInstanceCount: Swift.Int?
    let tags: [RdsClientTypes.Tag]?
}

extension PurchaseReservedDBInstancesOfferingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceCount = "DBInstanceCount"
        case reservedDBInstanceId = "ReservedDBInstanceId"
        case reservedDBInstancesOfferingId = "ReservedDBInstancesOfferingId"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedDBInstancesOfferingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedDBInstancesOfferingId)
        reservedDBInstancesOfferingId = reservedDBInstancesOfferingIdDecoded
        let reservedDBInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedDBInstanceId)
        reservedDBInstanceId = reservedDBInstanceIdDecoded
        let dBInstanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dBInstanceCount)
        dBInstanceCount = dBInstanceCountDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension PurchaseReservedDBInstancesOfferingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PurchaseReservedDBInstancesOfferingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ReservedDBInstanceAlreadyExists" : self = .reservedDBInstanceAlreadyExistsFault(try ReservedDBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedDBInstanceQuotaExceeded" : self = .reservedDBInstanceQuotaExceededFault(try ReservedDBInstanceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedDBInstancesOfferingNotFound" : self = .reservedDBInstancesOfferingNotFoundFault(try ReservedDBInstancesOfferingNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PurchaseReservedDBInstancesOfferingOutputError: Swift.Error, Swift.Equatable {
    case reservedDBInstanceAlreadyExistsFault(ReservedDBInstanceAlreadyExistsFault)
    case reservedDBInstanceQuotaExceededFault(ReservedDBInstanceQuotaExceededFault)
    case reservedDBInstancesOfferingNotFoundFault(ReservedDBInstancesOfferingNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension PurchaseReservedDBInstancesOfferingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PurchaseReservedDBInstancesOfferingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reservedDBInstance = output.reservedDBInstance
        } else {
            self.reservedDBInstance = nil
        }
    }
}

public struct PurchaseReservedDBInstancesOfferingOutputResponse: Swift.Equatable {
    /// This data type is used as a response element in the DescribeReservedDBInstances and PurchaseReservedDBInstancesOffering actions.
    public var reservedDBInstance: RdsClientTypes.ReservedDBInstance?

    public init (
        reservedDBInstance: RdsClientTypes.ReservedDBInstance? = nil
    )
    {
        self.reservedDBInstance = reservedDBInstance
    }
}

struct PurchaseReservedDBInstancesOfferingOutputResponseBody: Swift.Equatable {
    let reservedDBInstance: RdsClientTypes.ReservedDBInstance?
}

extension PurchaseReservedDBInstancesOfferingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservedDBInstance = "ReservedDBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("PurchaseReservedDBInstancesOfferingResult"))
        let reservedDBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ReservedDBInstance.self, forKey: .reservedDBInstance)
        reservedDBInstance = reservedDBInstanceDecoded
    }
}

extension RdsClientTypes.Range: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case from = "From"
        case step = "Step"
        case to = "To"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if from != 0 {
            try container.encode(from, forKey: ClientRuntime.Key("From"))
        }
        if let step = step {
            try container.encode(step, forKey: ClientRuntime.Key("Step"))
        }
        if to != 0 {
            try container.encode(to, forKey: ClientRuntime.Key("To"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDecoded = try containerValues.decode(Swift.Int.self, forKey: .from)
        from = fromDecoded
        let toDecoded = try containerValues.decode(Swift.Int.self, forKey: .to)
        to = toDecoded
        let stepDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .step)
        step = stepDecoded
    }
}

extension RdsClientTypes {
    /// A range of integer values.
    public struct Range: Swift.Equatable {
        /// The minimum value in the range.
        public var from: Swift.Int
        /// The step value for the range. For example, if you have a range of 5,000 to 10,000, with a step value of 1,000, the valid values start at 5,000 and step up by 1,000. Even though 7,500 is within the range, it isn't a valid value for the range. The valid values are 5,000, 6,000, 7,000, 8,000...
        public var step: Swift.Int?
        /// The maximum value in the range.
        public var to: Swift.Int

        public init (
            from: Swift.Int = 0,
            step: Swift.Int? = nil,
            to: Swift.Int = 0
        )
        {
            self.from = from
            self.step = step
            self.to = to
        }
    }

}

extension RebootDBClusterInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        try container.encode("RebootDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension RebootDBClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RebootDBClusterInput: Swift.Equatable {
    /// The DB cluster identifier. This parameter is stored as a lowercase string. Constraints:
    ///
    /// * Must match the identifier of an existing DBCluster.
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?

    public init (
        dBClusterIdentifier: Swift.String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
    }
}

struct RebootDBClusterInputBody: Swift.Equatable {
    let dBClusterIdentifier: Swift.String?
}

extension RebootDBClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterIdentifier = "DBClusterIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
    }
}

extension RebootDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RebootDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebootDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RebootDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct RebootDBClusterOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon Aurora DB cluster or Multi-AZ DB cluster. For an Amazon Aurora DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, PromoteReadReplicaDBCluster, RestoreDBClusterFromS3, RestoreDBClusterFromSnapshot, RestoreDBClusterToPointInTime, StartDBCluster, and StopDBCluster. For a Multi-AZ DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, RebootDBCluster, RestoreDBClusterFromSnapshot, and RestoreDBClusterToPointInTime. For more information on Amazon Aurora DB clusters, see [ What is Amazon Aurora?](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/CHAP_AuroraOverview.html) in the Amazon Aurora User Guide. For more information on Multi-AZ DB clusters, see [ Multi-AZ deployments with two readable standby DB instances](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/multi-az-db-clusters-concepts.html) in the Amazon RDS User Guide. The Multi-AZ DB clusters feature is in preview and is subject to change.
    public var dBCluster: RdsClientTypes.DBCluster?

    public init (
        dBCluster: RdsClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct RebootDBClusterOutputResponseBody: Swift.Equatable {
    let dBCluster: RdsClientTypes.DBCluster?
}

extension RebootDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RebootDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

extension RebootDBInstanceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let forceFailover = forceFailover {
            try container.encode(forceFailover, forKey: ClientRuntime.Key("ForceFailover"))
        }
        try container.encode("RebootDBInstance", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension RebootDBInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct RebootDBInstanceInput: Swift.Equatable {
    /// The DB instance identifier. This parameter is stored as a lowercase string. Constraints:
    ///
    /// * Must match the identifier of an existing DBInstance.
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// A value that indicates whether the reboot is conducted through a Multi-AZ failover. Constraint: You can't enable force failover if the instance isn't configured for Multi-AZ.
    public var forceFailover: Swift.Bool?

    public init (
        dBInstanceIdentifier: Swift.String? = nil,
        forceFailover: Swift.Bool? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.forceFailover = forceFailover
    }
}

struct RebootDBInstanceInputBody: Swift.Equatable {
    let dBInstanceIdentifier: Swift.String?
    let forceFailover: Swift.Bool?
}

extension RebootDBInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case forceFailover = "ForceFailover"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let forceFailoverDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceFailover)
        forceFailover = forceFailoverDecoded
    }
}

extension RebootDBInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RebootDBInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebootDBInstanceOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootDBInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RebootDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct RebootDBInstanceOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB instance. This data type is used as a response element in the operations CreateDBInstance, CreateDBInstanceReadReplica, DeleteDBInstance, DescribeDBInstances, ModifyDBInstance, PromoteReadReplica, RebootDBInstance, RestoreDBInstanceFromDBSnapshot, RestoreDBInstanceFromS3, RestoreDBInstanceToPointInTime, StartDBInstance, and StopDBInstance.
    public var dBInstance: RdsClientTypes.DBInstance?

    public init (
        dBInstance: RdsClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct RebootDBInstanceOutputResponseBody: Swift.Equatable {
    let dBInstance: RdsClientTypes.DBInstance?
}

extension RebootDBInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RebootDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

extension RdsClientTypes.RecurringCharge: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recurringChargeAmount = "RecurringChargeAmount"
        case recurringChargeFrequency = "RecurringChargeFrequency"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if recurringChargeAmount != 0.0 {
            try container.encode(Swift.String(recurringChargeAmount), forKey: ClientRuntime.Key("RecurringChargeAmount"))
        }
        if let recurringChargeFrequency = recurringChargeFrequency {
            try container.encode(recurringChargeFrequency, forKey: ClientRuntime.Key("RecurringChargeFrequency"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recurringChargeAmountDecoded = try containerValues.decode(Swift.Double.self, forKey: .recurringChargeAmount)
        recurringChargeAmount = recurringChargeAmountDecoded
        let recurringChargeFrequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recurringChargeFrequency)
        recurringChargeFrequency = recurringChargeFrequencyDecoded
    }
}

extension RdsClientTypes {
    /// This data type is used as a response element in the DescribeReservedDBInstances and DescribeReservedDBInstancesOfferings actions.
    public struct RecurringCharge: Swift.Equatable {
        /// The amount of the recurring charge.
        public var recurringChargeAmount: Swift.Double
        /// The frequency of the recurring charge.
        public var recurringChargeFrequency: Swift.String?

        public init (
            recurringChargeAmount: Swift.Double = 0.0,
            recurringChargeFrequency: Swift.String? = nil
        )
        {
            self.recurringChargeAmount = recurringChargeAmount
            self.recurringChargeFrequency = recurringChargeFrequency
        }
    }

}

extension RegisterDBProxyTargetsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifiers = dBClusterIdentifiers {
            var dBClusterIdentifiersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBClusterIdentifiers"))
            for (index0, string0) in dBClusterIdentifiers.enumerated() {
                try dBClusterIdentifiersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dBInstanceIdentifiers = dBInstanceIdentifiers {
            var dBInstanceIdentifiersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBInstanceIdentifiers"))
            for (index0, string0) in dBInstanceIdentifiers.enumerated() {
                try dBInstanceIdentifiersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if let targetGroupName = targetGroupName {
            try container.encode(targetGroupName, forKey: ClientRuntime.Key("TargetGroupName"))
        }
        try container.encode("RegisterDBProxyTargets", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension RegisterDBProxyTargetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterDBProxyTargetsInput: Swift.Equatable {
    /// One or more DB cluster identifiers.
    public var dBClusterIdentifiers: [Swift.String]?
    /// One or more DB instance identifiers.
    public var dBInstanceIdentifiers: [Swift.String]?
    /// The identifier of the DBProxy that is associated with the DBProxyTargetGroup.
    /// This member is required.
    public var dBProxyName: Swift.String?
    /// The identifier of the DBProxyTargetGroup.
    public var targetGroupName: Swift.String?

    public init (
        dBClusterIdentifiers: [Swift.String]? = nil,
        dBInstanceIdentifiers: [Swift.String]? = nil,
        dBProxyName: Swift.String? = nil,
        targetGroupName: Swift.String? = nil
    )
    {
        self.dBClusterIdentifiers = dBClusterIdentifiers
        self.dBInstanceIdentifiers = dBInstanceIdentifiers
        self.dBProxyName = dBProxyName
        self.targetGroupName = targetGroupName
    }
}

struct RegisterDBProxyTargetsInputBody: Swift.Equatable {
    let dBProxyName: Swift.String?
    let targetGroupName: Swift.String?
    let dBInstanceIdentifiers: [Swift.String]?
    let dBClusterIdentifiers: [Swift.String]?
}

extension RegisterDBProxyTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterIdentifiers = "DBClusterIdentifiers"
        case dBInstanceIdentifiers = "DBInstanceIdentifiers"
        case dBProxyName = "DBProxyName"
        case targetGroupName = "TargetGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBProxyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyName)
        dBProxyName = dBProxyNameDecoded
        let targetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetGroupName)
        targetGroupName = targetGroupNameDecoded
        if containerValues.contains(.dBInstanceIdentifiers) {
            struct KeyVal0{struct member{}}
            let dBInstanceIdentifiersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .dBInstanceIdentifiers)
            if let dBInstanceIdentifiersWrappedContainer = dBInstanceIdentifiersWrappedContainer {
                let dBInstanceIdentifiersContainer = try dBInstanceIdentifiersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var dBInstanceIdentifiersBuffer:[Swift.String]? = nil
                if let dBInstanceIdentifiersContainer = dBInstanceIdentifiersContainer {
                    dBInstanceIdentifiersBuffer = [Swift.String]()
                    for stringContainer0 in dBInstanceIdentifiersContainer {
                        dBInstanceIdentifiersBuffer?.append(stringContainer0)
                    }
                }
                dBInstanceIdentifiers = dBInstanceIdentifiersBuffer
            } else {
                dBInstanceIdentifiers = []
            }
        } else {
            dBInstanceIdentifiers = nil
        }
        if containerValues.contains(.dBClusterIdentifiers) {
            struct KeyVal0{struct member{}}
            let dBClusterIdentifiersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .dBClusterIdentifiers)
            if let dBClusterIdentifiersWrappedContainer = dBClusterIdentifiersWrappedContainer {
                let dBClusterIdentifiersContainer = try dBClusterIdentifiersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var dBClusterIdentifiersBuffer:[Swift.String]? = nil
                if let dBClusterIdentifiersContainer = dBClusterIdentifiersContainer {
                    dBClusterIdentifiersBuffer = [Swift.String]()
                    for stringContainer0 in dBClusterIdentifiersContainer {
                        dBClusterIdentifiersBuffer?.append(stringContainer0)
                    }
                }
                dBClusterIdentifiers = dBClusterIdentifiersBuffer
            } else {
                dBClusterIdentifiers = []
            }
        } else {
            dBClusterIdentifiers = nil
        }
    }
}

extension RegisterDBProxyTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RegisterDBProxyTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetAlreadyRegisteredFault" : self = .dBProxyTargetAlreadyRegisteredFault(try DBProxyTargetAlreadyRegisteredFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientAvailableIPsInSubnetFault" : self = .insufficientAvailableIPsInSubnetFault(try InsufficientAvailableIPsInSubnetFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterDBProxyTargetsOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetAlreadyRegisteredFault(DBProxyTargetAlreadyRegisteredFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case insufficientAvailableIPsInSubnetFault(InsufficientAvailableIPsInSubnetFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterDBProxyTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterDBProxyTargetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBProxyTargets = output.dBProxyTargets
        } else {
            self.dBProxyTargets = nil
        }
    }
}

public struct RegisterDBProxyTargetsOutputResponse: Swift.Equatable {
    /// One or more DBProxyTarget objects that are created when you register targets with a target group.
    public var dBProxyTargets: [RdsClientTypes.DBProxyTarget]?

    public init (
        dBProxyTargets: [RdsClientTypes.DBProxyTarget]? = nil
    )
    {
        self.dBProxyTargets = dBProxyTargets
    }
}

struct RegisterDBProxyTargetsOutputResponseBody: Swift.Equatable {
    let dBProxyTargets: [RdsClientTypes.DBProxyTarget]?
}

extension RegisterDBProxyTargetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxyTargets = "DBProxyTargets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RegisterDBProxyTargetsResult"))
        if containerValues.contains(.dBProxyTargets) {
            struct KeyVal0{struct member{}}
            let dBProxyTargetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .dBProxyTargets)
            if let dBProxyTargetsWrappedContainer = dBProxyTargetsWrappedContainer {
                let dBProxyTargetsContainer = try dBProxyTargetsWrappedContainer.decodeIfPresent([RdsClientTypes.DBProxyTarget].self, forKey: .member)
                var dBProxyTargetsBuffer:[RdsClientTypes.DBProxyTarget]? = nil
                if let dBProxyTargetsContainer = dBProxyTargetsContainer {
                    dBProxyTargetsBuffer = [RdsClientTypes.DBProxyTarget]()
                    for structureContainer0 in dBProxyTargetsContainer {
                        dBProxyTargetsBuffer?.append(structureContainer0)
                    }
                }
                dBProxyTargets = dBProxyTargetsBuffer
            } else {
                dBProxyTargets = []
            }
        } else {
            dBProxyTargets = nil
        }
    }
}

extension RemoveFromGlobalClusterInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dbClusterIdentifier = dbClusterIdentifier {
            try container.encode(dbClusterIdentifier, forKey: ClientRuntime.Key("DbClusterIdentifier"))
        }
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: ClientRuntime.Key("GlobalClusterIdentifier"))
        }
        try container.encode("RemoveFromGlobalCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension RemoveFromGlobalClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RemoveFromGlobalClusterInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) identifying the cluster that was detached from the Aurora global database cluster.
    public var dbClusterIdentifier: Swift.String?
    /// The cluster identifier to detach from the Aurora global database cluster.
    public var globalClusterIdentifier: Swift.String?

    public init (
        dbClusterIdentifier: Swift.String? = nil,
        globalClusterIdentifier: Swift.String? = nil
    )
    {
        self.dbClusterIdentifier = dbClusterIdentifier
        self.globalClusterIdentifier = globalClusterIdentifier
    }
}

struct RemoveFromGlobalClusterInputBody: Swift.Equatable {
    let globalClusterIdentifier: Swift.String?
    let dbClusterIdentifier: Swift.String?
}

extension RemoveFromGlobalClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbClusterIdentifier = "DbClusterIdentifier"
        case globalClusterIdentifier = "GlobalClusterIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalClusterIdentifier)
        globalClusterIdentifier = globalClusterIdentifierDecoded
        let dbClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbClusterIdentifier)
        dbClusterIdentifier = dbClusterIdentifierDecoded
    }
}

extension RemoveFromGlobalClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveFromGlobalClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlobalClusterNotFoundFault" : self = .globalClusterNotFoundFault(try GlobalClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGlobalClusterStateFault" : self = .invalidGlobalClusterStateFault(try InvalidGlobalClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveFromGlobalClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case globalClusterNotFoundFault(GlobalClusterNotFoundFault)
    case invalidGlobalClusterStateFault(InvalidGlobalClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveFromGlobalClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemoveFromGlobalClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalCluster = output.globalCluster
        } else {
            self.globalCluster = nil
        }
    }
}

public struct RemoveFromGlobalClusterOutputResponse: Swift.Equatable {
    /// A data type representing an Aurora global database.
    public var globalCluster: RdsClientTypes.GlobalCluster?

    public init (
        globalCluster: RdsClientTypes.GlobalCluster? = nil
    )
    {
        self.globalCluster = globalCluster
    }
}

struct RemoveFromGlobalClusterOutputResponseBody: Swift.Equatable {
    let globalCluster: RdsClientTypes.GlobalCluster?
}

extension RemoveFromGlobalClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalCluster = "GlobalCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RemoveFromGlobalClusterResult"))
        let globalClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.GlobalCluster.self, forKey: .globalCluster)
        globalCluster = globalClusterDecoded
    }
}

extension RemoveRoleFromDBClusterInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let featureName = featureName {
            try container.encode(featureName, forKey: ClientRuntime.Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        try container.encode("RemoveRoleFromDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension RemoveRoleFromDBClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RemoveRoleFromDBClusterInput: Swift.Equatable {
    /// The name of the DB cluster to disassociate the IAM role from.
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// The name of the feature for the DB cluster that the IAM role is to be disassociated from. For information about supported feature names, see [DBEngineVersion].
    public var featureName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role to disassociate from the Aurora DB cluster, for example arn:aws:iam::123456789012:role/AuroraAccessRole.
    /// This member is required.
    public var roleArn: Swift.String?

    public init (
        dBClusterIdentifier: Swift.String? = nil,
        featureName: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.featureName = featureName
        self.roleArn = roleArn
    }
}

struct RemoveRoleFromDBClusterInputBody: Swift.Equatable {
    let dBClusterIdentifier: Swift.String?
    let roleArn: Swift.String?
    let featureName: Swift.String?
}

extension RemoveRoleFromDBClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterIdentifier = "DBClusterIdentifier"
        case featureName = "FeatureName"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let featureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureName)
        featureName = featureNameDecoded
    }
}

extension RemoveRoleFromDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveRoleFromDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterRoleNotFound" : self = .dBClusterRoleNotFoundFault(try DBClusterRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveRoleFromDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterRoleNotFoundFault(DBClusterRoleNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveRoleFromDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveRoleFromDBClusterOutputResponse: Swift.Equatable {

}

extension RemoveRoleFromDBInstanceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let featureName = featureName {
            try container.encode(featureName, forKey: ClientRuntime.Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        try container.encode("RemoveRoleFromDBInstance", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension RemoveRoleFromDBInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RemoveRoleFromDBInstanceInput: Swift.Equatable {
    /// The name of the DB instance to disassociate the IAM role from.
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// The name of the feature for the DB instance that the IAM role is to be disassociated from. For information about supported feature names, see DBEngineVersion.
    /// This member is required.
    public var featureName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role to disassociate from the DB instance, for example, arn:aws:iam::123456789012:role/AccessRole.
    /// This member is required.
    public var roleArn: Swift.String?

    public init (
        dBInstanceIdentifier: Swift.String? = nil,
        featureName: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.featureName = featureName
        self.roleArn = roleArn
    }
}

struct RemoveRoleFromDBInstanceInputBody: Swift.Equatable {
    let dBInstanceIdentifier: Swift.String?
    let roleArn: Swift.String?
    let featureName: Swift.String?
}

extension RemoveRoleFromDBInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case featureName = "FeatureName"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let featureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureName)
        featureName = featureNameDecoded
    }
}

extension RemoveRoleFromDBInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveRoleFromDBInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceRoleNotFound" : self = .dBInstanceRoleNotFoundFault(try DBInstanceRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveRoleFromDBInstanceOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBInstanceRoleNotFoundFault(DBInstanceRoleNotFoundFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveRoleFromDBInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveRoleFromDBInstanceOutputResponse: Swift.Equatable {

}

extension RemoveSourceIdentifierFromSubscriptionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: ClientRuntime.Key("SourceIdentifier"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: ClientRuntime.Key("SubscriptionName"))
        }
        try container.encode("RemoveSourceIdentifierFromSubscription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension RemoveSourceIdentifierFromSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct RemoveSourceIdentifierFromSubscriptionInput: Swift.Equatable {
    /// The source identifier to be removed from the subscription, such as the DB instance identifier for a DB instance or the name of a security group.
    /// This member is required.
    public var sourceIdentifier: Swift.String?
    /// The name of the RDS event notification subscription you want to remove a source identifier from.
    /// This member is required.
    public var subscriptionName: Swift.String?

    public init (
        sourceIdentifier: Swift.String? = nil,
        subscriptionName: Swift.String? = nil
    )
    {
        self.sourceIdentifier = sourceIdentifier
        self.subscriptionName = subscriptionName
    }
}

struct RemoveSourceIdentifierFromSubscriptionInputBody: Swift.Equatable {
    let subscriptionName: Swift.String?
    let sourceIdentifier: Swift.String?
}

extension RemoveSourceIdentifierFromSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceIdentifier = "SourceIdentifier"
        case subscriptionName = "SubscriptionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
    }
}

extension RemoveSourceIdentifierFromSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveSourceIdentifierFromSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "SourceNotFound" : self = .sourceNotFoundFault(try SourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFound" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveSourceIdentifierFromSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case sourceNotFoundFault(SourceNotFoundFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveSourceIdentifierFromSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemoveSourceIdentifierFromSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct RemoveSourceIdentifierFromSubscriptionOutputResponse: Swift.Equatable {
    /// Contains the results of a successful invocation of the DescribeEventSubscriptions action.
    public var eventSubscription: RdsClientTypes.EventSubscription?

    public init (
        eventSubscription: RdsClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct RemoveSourceIdentifierFromSubscriptionOutputResponseBody: Swift.Equatable {
    let eventSubscription: RdsClientTypes.EventSubscription?
}

extension RemoveSourceIdentifierFromSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RemoveSourceIdentifierFromSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(RdsClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

extension RemoveTagsFromResourceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: ClientRuntime.Key("ResourceName"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RemoveTagsFromResource", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension RemoveTagsFromResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct RemoveTagsFromResourceInput: Swift.Equatable {
    /// The Amazon RDS resource that the tags are removed from. This value is an Amazon Resource Name (ARN). For information about creating an ARN, see [ Constructing an ARN for Amazon RDS](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing) in the Amazon RDS User Guide.
    /// This member is required.
    public var resourceName: Swift.String?
    /// The tag key (name) of the tag to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceName: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceName = resourceName
        self.tagKeys = tagKeys
    }
}

struct RemoveTagsFromResourceInputBody: Swift.Equatable {
    let resourceName: Swift.String?
    let tagKeys: [Swift.String]?
}

extension RemoveTagsFromResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "ResourceName"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        if containerValues.contains(.tagKeys) {
            struct KeyVal0{struct member{}}
            let tagKeysWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagKeys)
            if let tagKeysWrappedContainer = tagKeysWrappedContainer {
                let tagKeysContainer = try tagKeysWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var tagKeysBuffer:[Swift.String]? = nil
                if let tagKeysContainer = tagKeysContainer {
                    tagKeysBuffer = [Swift.String]()
                    for stringContainer0 in tagKeysContainer {
                        tagKeysBuffer?.append(stringContainer0)
                    }
                }
                tagKeys = tagKeysBuffer
            } else {
                tagKeys = []
            }
        } else {
            tagKeys = nil
        }
    }
}

extension RemoveTagsFromResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveTagsFromResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsFromResourceOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsFromResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveTagsFromResourceOutputResponse: Swift.Equatable {

}

extension RdsClientTypes {
    public enum ReplicaMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mounted
        case openReadOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicaMode] {
            return [
                .mounted,
                .openReadOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mounted: return "mounted"
            case .openReadOnly: return "open-read-only"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicaMode(rawValue: rawValue) ?? ReplicaMode.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes.ReservedDBInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "CurrencyCode"
        case dBInstanceClass = "DBInstanceClass"
        case dBInstanceCount = "DBInstanceCount"
        case duration = "Duration"
        case fixedPrice = "FixedPrice"
        case leaseId = "LeaseId"
        case multiAZ = "MultiAZ"
        case offeringType = "OfferingType"
        case productDescription = "ProductDescription"
        case recurringCharges = "RecurringCharges"
        case reservedDBInstanceArn = "ReservedDBInstanceArn"
        case reservedDBInstanceId = "ReservedDBInstanceId"
        case reservedDBInstancesOfferingId = "ReservedDBInstancesOfferingId"
        case startTime = "StartTime"
        case state = "State"
        case usagePrice = "UsagePrice"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let currencyCode = currencyCode {
            try container.encode(currencyCode, forKey: ClientRuntime.Key("CurrencyCode"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if dBInstanceCount != 0 {
            try container.encode(dBInstanceCount, forKey: ClientRuntime.Key("DBInstanceCount"))
        }
        if duration != 0 {
            try container.encode(duration, forKey: ClientRuntime.Key("Duration"))
        }
        if fixedPrice != 0.0 {
            try container.encode(Swift.String(fixedPrice), forKey: ClientRuntime.Key("FixedPrice"))
        }
        if let leaseId = leaseId {
            try container.encode(leaseId, forKey: ClientRuntime.Key("LeaseId"))
        }
        if multiAZ != false {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let offeringType = offeringType {
            try container.encode(offeringType, forKey: ClientRuntime.Key("OfferingType"))
        }
        if let productDescription = productDescription {
            try container.encode(productDescription, forKey: ClientRuntime.Key("ProductDescription"))
        }
        if let recurringCharges = recurringCharges {
            var recurringChargesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RecurringCharges"))
            for (index0, recurringcharge0) in recurringCharges.enumerated() {
                try recurringChargesContainer.encode(recurringcharge0, forKey: ClientRuntime.Key("RecurringCharge.\(index0.advanced(by: 1))"))
            }
        }
        if let reservedDBInstanceArn = reservedDBInstanceArn {
            try container.encode(reservedDBInstanceArn, forKey: ClientRuntime.Key("ReservedDBInstanceArn"))
        }
        if let reservedDBInstanceId = reservedDBInstanceId {
            try container.encode(reservedDBInstanceId, forKey: ClientRuntime.Key("ReservedDBInstanceId"))
        }
        if let reservedDBInstancesOfferingId = reservedDBInstancesOfferingId {
            try container.encode(reservedDBInstancesOfferingId, forKey: ClientRuntime.Key("ReservedDBInstancesOfferingId"))
        }
        if let startTime = startTime {
            try container.encode(ClientRuntime.TimestampWrapper(startTime, format: .dateTime), forKey: ClientRuntime.Key("startTime"))
        }
        if let state = state {
            try container.encode(state, forKey: ClientRuntime.Key("State"))
        }
        if usagePrice != 0.0 {
            try container.encode(Swift.String(usagePrice), forKey: ClientRuntime.Key("UsagePrice"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedDBInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedDBInstanceId)
        reservedDBInstanceId = reservedDBInstanceIdDecoded
        let reservedDBInstancesOfferingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedDBInstancesOfferingId)
        reservedDBInstancesOfferingId = reservedDBInstancesOfferingIdDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        var startTimeBuffer:ClientRuntime.Date? = nil
        if let startTimeDecoded = startTimeDecoded {
            startTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(startTimeDecoded, format: .dateTime)
        }
        startTime = startTimeBuffer
        let durationDecoded = try containerValues.decode(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let fixedPriceDecoded = try containerValues.decode(Swift.Double.self, forKey: .fixedPrice)
        fixedPrice = fixedPriceDecoded
        let usagePriceDecoded = try containerValues.decode(Swift.Double.self, forKey: .usagePrice)
        usagePrice = usagePriceDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let dBInstanceCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .dBInstanceCount)
        dBInstanceCount = dBInstanceCountDecoded
        let productDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productDescription)
        productDescription = productDescriptionDecoded
        let offeringTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringType)
        offeringType = offeringTypeDecoded
        let multiAZDecoded = try containerValues.decode(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        if containerValues.contains(.recurringCharges) {
            struct KeyVal0{struct RecurringCharge{}}
            let recurringChargesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.RecurringCharge>.CodingKeys.self, forKey: .recurringCharges)
            if let recurringChargesWrappedContainer = recurringChargesWrappedContainer {
                let recurringChargesContainer = try recurringChargesWrappedContainer.decodeIfPresent([RdsClientTypes.RecurringCharge].self, forKey: .member)
                var recurringChargesBuffer:[RdsClientTypes.RecurringCharge]? = nil
                if let recurringChargesContainer = recurringChargesContainer {
                    recurringChargesBuffer = [RdsClientTypes.RecurringCharge]()
                    for structureContainer0 in recurringChargesContainer {
                        recurringChargesBuffer?.append(structureContainer0)
                    }
                }
                recurringCharges = recurringChargesBuffer
            } else {
                recurringCharges = []
            }
        } else {
            recurringCharges = nil
        }
        let reservedDBInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedDBInstanceArn)
        reservedDBInstanceArn = reservedDBInstanceArnDecoded
        let leaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .leaseId)
        leaseId = leaseIdDecoded
    }
}

extension RdsClientTypes {
    /// This data type is used as a response element in the DescribeReservedDBInstances and PurchaseReservedDBInstancesOffering actions.
    public struct ReservedDBInstance: Swift.Equatable {
        /// The currency code for the reserved DB instance.
        public var currencyCode: Swift.String?
        /// The DB instance class for the reserved DB instance.
        public var dBInstanceClass: Swift.String?
        /// The number of reserved DB instances.
        public var dBInstanceCount: Swift.Int
        /// The duration of the reservation in seconds.
        public var duration: Swift.Int
        /// The fixed price charged for this reserved DB instance.
        public var fixedPrice: Swift.Double
        /// The unique identifier for the lease associated with the reserved DB instance. Amazon Web Services Support might request the lease ID for an issue related to a reserved DB instance.
        public var leaseId: Swift.String?
        /// Indicates if the reservation applies to Multi-AZ deployments.
        public var multiAZ: Swift.Bool
        /// The offering type of this reserved DB instance.
        public var offeringType: Swift.String?
        /// The description of the reserved DB instance.
        public var productDescription: Swift.String?
        /// The recurring price charged to run this reserved DB instance.
        public var recurringCharges: [RdsClientTypes.RecurringCharge]?
        /// The Amazon Resource Name (ARN) for the reserved DB instance.
        public var reservedDBInstanceArn: Swift.String?
        /// The unique identifier for the reservation.
        public var reservedDBInstanceId: Swift.String?
        /// The offering identifier.
        public var reservedDBInstancesOfferingId: Swift.String?
        /// The time the reservation started.
        public var startTime: ClientRuntime.Date?
        /// The state of the reserved DB instance.
        public var state: Swift.String?
        /// The hourly price charged for this reserved DB instance.
        public var usagePrice: Swift.Double

        public init (
            currencyCode: Swift.String? = nil,
            dBInstanceClass: Swift.String? = nil,
            dBInstanceCount: Swift.Int = 0,
            duration: Swift.Int = 0,
            fixedPrice: Swift.Double = 0.0,
            leaseId: Swift.String? = nil,
            multiAZ: Swift.Bool = false,
            offeringType: Swift.String? = nil,
            productDescription: Swift.String? = nil,
            recurringCharges: [RdsClientTypes.RecurringCharge]? = nil,
            reservedDBInstanceArn: Swift.String? = nil,
            reservedDBInstanceId: Swift.String? = nil,
            reservedDBInstancesOfferingId: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: Swift.String? = nil,
            usagePrice: Swift.Double = 0.0
        )
        {
            self.currencyCode = currencyCode
            self.dBInstanceClass = dBInstanceClass
            self.dBInstanceCount = dBInstanceCount
            self.duration = duration
            self.fixedPrice = fixedPrice
            self.leaseId = leaseId
            self.multiAZ = multiAZ
            self.offeringType = offeringType
            self.productDescription = productDescription
            self.recurringCharges = recurringCharges
            self.reservedDBInstanceArn = reservedDBInstanceArn
            self.reservedDBInstanceId = reservedDBInstanceId
            self.reservedDBInstancesOfferingId = reservedDBInstancesOfferingId
            self.startTime = startTime
            self.state = state
            self.usagePrice = usagePrice
        }
    }

}

extension ReservedDBInstanceAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ReservedDBInstanceAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// User already has a reservation with the given identifier.
public struct ReservedDBInstanceAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedDBInstanceAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReservedDBInstanceAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReservedDBInstanceNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ReservedDBInstanceNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified reserved DB Instance not found.
public struct ReservedDBInstanceNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedDBInstanceNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReservedDBInstanceNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReservedDBInstanceQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ReservedDBInstanceQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request would exceed the user's DB Instance quota.
public struct ReservedDBInstanceQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedDBInstanceQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReservedDBInstanceQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.ReservedDBInstancesOffering: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "CurrencyCode"
        case dBInstanceClass = "DBInstanceClass"
        case duration = "Duration"
        case fixedPrice = "FixedPrice"
        case multiAZ = "MultiAZ"
        case offeringType = "OfferingType"
        case productDescription = "ProductDescription"
        case recurringCharges = "RecurringCharges"
        case reservedDBInstancesOfferingId = "ReservedDBInstancesOfferingId"
        case usagePrice = "UsagePrice"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let currencyCode = currencyCode {
            try container.encode(currencyCode, forKey: ClientRuntime.Key("CurrencyCode"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if duration != 0 {
            try container.encode(duration, forKey: ClientRuntime.Key("Duration"))
        }
        if fixedPrice != 0.0 {
            try container.encode(Swift.String(fixedPrice), forKey: ClientRuntime.Key("FixedPrice"))
        }
        if multiAZ != false {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let offeringType = offeringType {
            try container.encode(offeringType, forKey: ClientRuntime.Key("OfferingType"))
        }
        if let productDescription = productDescription {
            try container.encode(productDescription, forKey: ClientRuntime.Key("ProductDescription"))
        }
        if let recurringCharges = recurringCharges {
            var recurringChargesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RecurringCharges"))
            for (index0, recurringcharge0) in recurringCharges.enumerated() {
                try recurringChargesContainer.encode(recurringcharge0, forKey: ClientRuntime.Key("RecurringCharge.\(index0.advanced(by: 1))"))
            }
        }
        if let reservedDBInstancesOfferingId = reservedDBInstancesOfferingId {
            try container.encode(reservedDBInstancesOfferingId, forKey: ClientRuntime.Key("ReservedDBInstancesOfferingId"))
        }
        if usagePrice != 0.0 {
            try container.encode(Swift.String(usagePrice), forKey: ClientRuntime.Key("UsagePrice"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedDBInstancesOfferingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedDBInstancesOfferingId)
        reservedDBInstancesOfferingId = reservedDBInstancesOfferingIdDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let durationDecoded = try containerValues.decode(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let fixedPriceDecoded = try containerValues.decode(Swift.Double.self, forKey: .fixedPrice)
        fixedPrice = fixedPriceDecoded
        let usagePriceDecoded = try containerValues.decode(Swift.Double.self, forKey: .usagePrice)
        usagePrice = usagePriceDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let productDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productDescription)
        productDescription = productDescriptionDecoded
        let offeringTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringType)
        offeringType = offeringTypeDecoded
        let multiAZDecoded = try containerValues.decode(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        if containerValues.contains(.recurringCharges) {
            struct KeyVal0{struct RecurringCharge{}}
            let recurringChargesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.RecurringCharge>.CodingKeys.self, forKey: .recurringCharges)
            if let recurringChargesWrappedContainer = recurringChargesWrappedContainer {
                let recurringChargesContainer = try recurringChargesWrappedContainer.decodeIfPresent([RdsClientTypes.RecurringCharge].self, forKey: .member)
                var recurringChargesBuffer:[RdsClientTypes.RecurringCharge]? = nil
                if let recurringChargesContainer = recurringChargesContainer {
                    recurringChargesBuffer = [RdsClientTypes.RecurringCharge]()
                    for structureContainer0 in recurringChargesContainer {
                        recurringChargesBuffer?.append(structureContainer0)
                    }
                }
                recurringCharges = recurringChargesBuffer
            } else {
                recurringCharges = []
            }
        } else {
            recurringCharges = nil
        }
    }
}

extension RdsClientTypes {
    /// This data type is used as a response element in the DescribeReservedDBInstancesOfferings action.
    public struct ReservedDBInstancesOffering: Swift.Equatable {
        /// The currency code for the reserved DB instance offering.
        public var currencyCode: Swift.String?
        /// The DB instance class for the reserved DB instance.
        public var dBInstanceClass: Swift.String?
        /// The duration of the offering in seconds.
        public var duration: Swift.Int
        /// The fixed price charged for this offering.
        public var fixedPrice: Swift.Double
        /// Indicates if the offering applies to Multi-AZ deployments.
        public var multiAZ: Swift.Bool
        /// The offering type.
        public var offeringType: Swift.String?
        /// The database engine used by the offering.
        public var productDescription: Swift.String?
        /// The recurring price charged to run this reserved DB instance.
        public var recurringCharges: [RdsClientTypes.RecurringCharge]?
        /// The offering identifier.
        public var reservedDBInstancesOfferingId: Swift.String?
        /// The hourly price charged for this offering.
        public var usagePrice: Swift.Double

        public init (
            currencyCode: Swift.String? = nil,
            dBInstanceClass: Swift.String? = nil,
            duration: Swift.Int = 0,
            fixedPrice: Swift.Double = 0.0,
            multiAZ: Swift.Bool = false,
            offeringType: Swift.String? = nil,
            productDescription: Swift.String? = nil,
            recurringCharges: [RdsClientTypes.RecurringCharge]? = nil,
            reservedDBInstancesOfferingId: Swift.String? = nil,
            usagePrice: Swift.Double = 0.0
        )
        {
            self.currencyCode = currencyCode
            self.dBInstanceClass = dBInstanceClass
            self.duration = duration
            self.fixedPrice = fixedPrice
            self.multiAZ = multiAZ
            self.offeringType = offeringType
            self.productDescription = productDescription
            self.recurringCharges = recurringCharges
            self.reservedDBInstancesOfferingId = reservedDBInstancesOfferingId
            self.usagePrice = usagePrice
        }
    }

}

extension ReservedDBInstancesOfferingNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ReservedDBInstancesOfferingNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Specified offering does not exist.
public struct ReservedDBInstancesOfferingNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedDBInstancesOfferingNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReservedDBInstancesOfferingNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResetDBClusterParameterGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: ClientRuntime.Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        if resetAllParameters != false {
            try container.encode(resetAllParameters, forKey: ClientRuntime.Key("ResetAllParameters"))
        }
        try container.encode("ResetDBClusterParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ResetDBClusterParameterGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ResetDBClusterParameterGroupInput: Swift.Equatable {
    /// The name of the DB cluster parameter group to reset.
    /// This member is required.
    public var dBClusterParameterGroupName: Swift.String?
    /// A list of parameter names in the DB cluster parameter group to reset to the default values. You can't use this parameter if the ResetAllParameters parameter is enabled.
    public var parameters: [RdsClientTypes.Parameter]?
    /// A value that indicates whether to reset all parameters in the DB cluster parameter group to their default values. You can't use this parameter if there is a list of parameter names specified for the Parameters parameter.
    public var resetAllParameters: Swift.Bool

    public init (
        dBClusterParameterGroupName: Swift.String? = nil,
        parameters: [RdsClientTypes.Parameter]? = nil,
        resetAllParameters: Swift.Bool = false
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.parameters = parameters
        self.resetAllParameters = resetAllParameters
    }
}

struct ResetDBClusterParameterGroupInputBody: Swift.Equatable {
    let dBClusterParameterGroupName: Swift.String?
    let resetAllParameters: Swift.Bool
    let parameters: [RdsClientTypes.Parameter]?
}

extension ResetDBClusterParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
        case parameters = "Parameters"
        case resetAllParameters = "ResetAllParameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
        let resetAllParametersDecoded = try containerValues.decode(Swift.Bool.self, forKey: .resetAllParameters)
        resetAllParameters = resetAllParametersDecoded
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct Parameter{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Parameter>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([RdsClientTypes.Parameter].self, forKey: .member)
                var parametersBuffer:[RdsClientTypes.Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [RdsClientTypes.Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
    }
}

extension ResetDBClusterParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ResetDBClusterParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupState" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetDBClusterParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetDBClusterParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResetDBClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterParameterGroupName = output.dBClusterParameterGroupName
        } else {
            self.dBClusterParameterGroupName = nil
        }
    }
}

///
public struct ResetDBClusterParameterGroupOutputResponse: Swift.Equatable {
    /// The name of the DB cluster parameter group. Constraints:
    ///
    /// * Must be 1 to 255 letters or numbers.
    ///
    /// * First character must be a letter
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    /// This value is stored as a lowercase string.
    public var dBClusterParameterGroupName: Swift.String?

    public init (
        dBClusterParameterGroupName: Swift.String? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
    }
}

struct ResetDBClusterParameterGroupOutputResponseBody: Swift.Equatable {
    let dBClusterParameterGroupName: Swift.String?
}

extension ResetDBClusterParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ResetDBClusterParameterGroupResult"))
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
    }
}

extension ResetDBParameterGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: ClientRuntime.Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        if resetAllParameters != false {
            try container.encode(resetAllParameters, forKey: ClientRuntime.Key("ResetAllParameters"))
        }
        try container.encode("ResetDBParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ResetDBParameterGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ResetDBParameterGroupInput: Swift.Equatable {
    /// The name of the DB parameter group. Constraints:
    ///
    /// * Must match the name of an existing DBParameterGroup.
    /// This member is required.
    public var dBParameterGroupName: Swift.String?
    /// To reset the entire DB parameter group, specify the DBParameterGroup name and ResetAllParameters parameters. To reset specific parameters, provide a list of the following: ParameterName and ApplyMethod. A maximum of 20 parameters can be modified in a single request. MySQL Valid Values (for Apply method): immediate | pending-reboot You can use the immediate value with dynamic parameters only. You can use the pending-reboot value for both dynamic and static parameters, and changes are applied when DB instance reboots. MariaDB Valid Values (for Apply method): immediate | pending-reboot You can use the immediate value with dynamic parameters only. You can use the pending-reboot value for both dynamic and static parameters, and changes are applied when DB instance reboots. Oracle Valid Values (for Apply method): pending-reboot
    public var parameters: [RdsClientTypes.Parameter]?
    /// A value that indicates whether to reset all parameters in the DB parameter group to default values. By default, all parameters in the DB parameter group are reset to default values.
    public var resetAllParameters: Swift.Bool

    public init (
        dBParameterGroupName: Swift.String? = nil,
        parameters: [RdsClientTypes.Parameter]? = nil,
        resetAllParameters: Swift.Bool = false
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
        self.parameters = parameters
        self.resetAllParameters = resetAllParameters
    }
}

struct ResetDBParameterGroupInputBody: Swift.Equatable {
    let dBParameterGroupName: Swift.String?
    let resetAllParameters: Swift.Bool
    let parameters: [RdsClientTypes.Parameter]?
}

extension ResetDBParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupName = "DBParameterGroupName"
        case parameters = "Parameters"
        case resetAllParameters = "ResetAllParameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
        let resetAllParametersDecoded = try containerValues.decode(Swift.Bool.self, forKey: .resetAllParameters)
        resetAllParameters = resetAllParametersDecoded
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct Parameter{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Parameter>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([RdsClientTypes.Parameter].self, forKey: .member)
                var parametersBuffer:[RdsClientTypes.Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [RdsClientTypes.Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
    }
}

extension ResetDBParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ResetDBParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupState" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetDBParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetDBParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResetDBParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBParameterGroupName = output.dBParameterGroupName
        } else {
            self.dBParameterGroupName = nil
        }
    }
}

/// Contains the result of a successful invocation of the ModifyDBParameterGroup or ResetDBParameterGroup action.
public struct ResetDBParameterGroupOutputResponse: Swift.Equatable {
    /// The name of the DB parameter group.
    public var dBParameterGroupName: Swift.String?

    public init (
        dBParameterGroupName: Swift.String? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
    }
}

struct ResetDBParameterGroupOutputResponseBody: Swift.Equatable {
    let dBParameterGroupName: Swift.String?
}

extension ResetDBParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupName = "DBParameterGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ResetDBParameterGroupResult"))
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
    }
}

extension ResourceNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ResourceNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource ID was not found.
public struct ResourceNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.ResourcePendingMaintenanceActions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pendingMaintenanceActionDetails = "PendingMaintenanceActionDetails"
        case resourceIdentifier = "ResourceIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let pendingMaintenanceActionDetails = pendingMaintenanceActionDetails {
            var pendingMaintenanceActionDetailsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PendingMaintenanceActionDetails"))
            for (index0, pendingmaintenanceaction0) in pendingMaintenanceActionDetails.enumerated() {
                try pendingMaintenanceActionDetailsContainer.encode(pendingmaintenanceaction0, forKey: ClientRuntime.Key("PendingMaintenanceAction.\(index0.advanced(by: 1))"))
            }
        }
        if let resourceIdentifier = resourceIdentifier {
            try container.encode(resourceIdentifier, forKey: ClientRuntime.Key("ResourceIdentifier"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        if containerValues.contains(.pendingMaintenanceActionDetails) {
            struct KeyVal0{struct PendingMaintenanceAction{}}
            let pendingMaintenanceActionDetailsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.PendingMaintenanceAction>.CodingKeys.self, forKey: .pendingMaintenanceActionDetails)
            if let pendingMaintenanceActionDetailsWrappedContainer = pendingMaintenanceActionDetailsWrappedContainer {
                let pendingMaintenanceActionDetailsContainer = try pendingMaintenanceActionDetailsWrappedContainer.decodeIfPresent([RdsClientTypes.PendingMaintenanceAction].self, forKey: .member)
                var pendingMaintenanceActionDetailsBuffer:[RdsClientTypes.PendingMaintenanceAction]? = nil
                if let pendingMaintenanceActionDetailsContainer = pendingMaintenanceActionDetailsContainer {
                    pendingMaintenanceActionDetailsBuffer = [RdsClientTypes.PendingMaintenanceAction]()
                    for structureContainer0 in pendingMaintenanceActionDetailsContainer {
                        pendingMaintenanceActionDetailsBuffer?.append(structureContainer0)
                    }
                }
                pendingMaintenanceActionDetails = pendingMaintenanceActionDetailsBuffer
            } else {
                pendingMaintenanceActionDetails = []
            }
        } else {
            pendingMaintenanceActionDetails = nil
        }
    }
}

extension RdsClientTypes {
    /// Describes the pending maintenance actions for a resource.
    public struct ResourcePendingMaintenanceActions: Swift.Equatable {
        /// A list that provides details about the pending maintenance actions for the resource.
        public var pendingMaintenanceActionDetails: [RdsClientTypes.PendingMaintenanceAction]?
        /// The ARN of the resource that has pending maintenance actions.
        public var resourceIdentifier: Swift.String?

        public init (
            pendingMaintenanceActionDetails: [RdsClientTypes.PendingMaintenanceAction]? = nil,
            resourceIdentifier: Swift.String? = nil
        )
        {
            self.pendingMaintenanceActionDetails = pendingMaintenanceActionDetails
            self.resourceIdentifier = resourceIdentifier
        }
    }

}

extension RestoreDBClusterFromS3Input: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: ClientRuntime.Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let backtrackWindow = backtrackWindow {
            try container.encode(backtrackWindow, forKey: ClientRuntime.Key("BacktrackWindow"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: ClientRuntime.Key("CharacterSetName"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: ClientRuntime.Key("DatabaseName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: ClientRuntime.Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let s3BucketName = s3BucketName {
            try container.encode(s3BucketName, forKey: ClientRuntime.Key("S3BucketName"))
        }
        if let s3IngestionRoleArn = s3IngestionRoleArn {
            try container.encode(s3IngestionRoleArn, forKey: ClientRuntime.Key("S3IngestionRoleArn"))
        }
        if let s3Prefix = s3Prefix {
            try container.encode(s3Prefix, forKey: ClientRuntime.Key("S3Prefix"))
        }
        if let sourceEngine = sourceEngine {
            try container.encode(sourceEngine, forKey: ClientRuntime.Key("SourceEngine"))
        }
        if let sourceEngineVersion = sourceEngineVersion {
            try container.encode(sourceEngineVersion, forKey: ClientRuntime.Key("SourceEngineVersion"))
        }
        if let storageEncrypted = storageEncrypted {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreDBClusterFromS3", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension RestoreDBClusterFromS3Input: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RestoreDBClusterFromS3Input: Swift.Equatable {
    /// A list of Availability Zones (AZs) where instances in the restored DB cluster can be created.
    public var availabilityZones: [Swift.String]?
    /// The target backtrack window, in seconds. To disable backtracking, set this value to 0. Currently, Backtrack is only supported for Aurora MySQL DB clusters. Default: 0 Constraints:
    ///
    /// * If specified, this value must be set to a number from 0 to 259,200 (72 hours).
    public var backtrackWindow: Swift.Int?
    /// The number of days for which automated backups of the restored DB cluster are retained. You must specify a minimum value of 1. Default: 1 Constraints:
    ///
    /// * Must be a value from 1 to 35
    public var backupRetentionPeriod: Swift.Int?
    /// A value that indicates that the restored DB cluster should be associated with the specified CharacterSet.
    public var characterSetName: Swift.String?
    /// A value that indicates whether to copy all tags from the restored DB cluster to snapshots of the restored DB cluster. The default is not to copy them.
    public var copyTagsToSnapshot: Swift.Bool?
    /// The name of the DB cluster to create from the source data in the Amazon S3 bucket. This parameter isn't case-sensitive. Constraints:
    ///
    /// * Must contain from 1 to 63 letters, numbers, or hyphens.
    ///
    /// * First character must be a letter.
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    /// Example: my-cluster1
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// The name of the DB cluster parameter group to associate with the restored DB cluster. If this argument is omitted, default.aurora5.6 is used. Constraints:
    ///
    /// * If supplied, must match the name of an existing DBClusterParameterGroup.
    public var dBClusterParameterGroupName: Swift.String?
    /// A DB subnet group to associate with the restored DB cluster. Constraints: If supplied, must match the name of an existing DBSubnetGroup. Example: mySubnetgroup
    public var dBSubnetGroupName: Swift.String?
    /// The database name for the restored DB cluster.
    public var databaseName: Swift.String?
    /// A value that indicates whether the DB cluster has deletion protection enabled. The database can't be deleted when deletion protection is enabled. By default, deletion protection isn't enabled.
    public var deletionProtection: Swift.Bool?
    /// Specify the Active Directory directory ID to restore the DB cluster in. The domain must be created prior to this operation. For Amazon Aurora DB clusters, Amazon RDS can use Kerberos Authentication to authenticate users that connect to the DB cluster. For more information, see [Kerberos Authentication](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/kerberos-authentication.html) in the Amazon Aurora User Guide.
    public var domain: Swift.String?
    /// Specify the name of the IAM role to be used when making API calls to the Directory Service.
    public var domainIAMRoleName: Swift.String?
    /// The list of logs that the restored DB cluster is to export to CloudWatch Logs. The values in the list depend on the DB engine being used. For more information, see [Publishing Database Logs to Amazon CloudWatch Logs](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch) in the Amazon Aurora User Guide.
    public var enableCloudwatchLogsExports: [Swift.String]?
    /// A value that indicates whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping isn't enabled. For more information, see [ IAM Database Authentication](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.IAMDBAuth.html) in the Amazon Aurora User Guide.
    public var enableIAMDatabaseAuthentication: Swift.Bool?
    /// The name of the database engine to be used for this DB cluster. Valid Values: aurora (for MySQL 5.6-compatible Aurora), aurora-mysql (for MySQL 5.7-compatible Aurora), and aurora-postgresql
    /// This member is required.
    public var engine: Swift.String?
    /// The version number of the database engine to use. To list all of the available engine versions for aurora (for MySQL 5.6-compatible Aurora), use the following command: aws rds describe-db-engine-versions --engine aurora --query "DBEngineVersions[].EngineVersion" To list all of the available engine versions for aurora-mysql (for MySQL 5.7-compatible Aurora), use the following command: aws rds describe-db-engine-versions --engine aurora-mysql --query "DBEngineVersions[].EngineVersion" To list all of the available engine versions for aurora-postgresql, use the following command: aws rds describe-db-engine-versions --engine aurora-postgresql --query "DBEngineVersions[].EngineVersion" Aurora MySQL Example: 5.6.10a, 5.6.mysql_aurora.1.19.2, 5.7.12, 5.7.mysql_aurora.2.04.5 Aurora PostgreSQL Example: 9.6.3, 10.7
    public var engineVersion: Swift.String?
    /// The Amazon Web Services KMS key identifier for an encrypted DB cluster. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN. If the StorageEncrypted parameter is enabled, and you do not specify a value for the KmsKeyId parameter, then Amazon RDS will use your default KMS key. There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region.
    public var kmsKeyId: Swift.String?
    /// The password for the master database user. This password can contain any printable ASCII character except "/", """, or "@". Constraints: Must contain from 8 to 41 characters.
    /// This member is required.
    public var masterUserPassword: Swift.String?
    /// The name of the master user for the restored DB cluster. Constraints:
    ///
    /// * Must be 1 to 16 letters or numbers.
    ///
    /// * First character must be a letter.
    ///
    /// * Can't be a reserved word for the chosen database engine.
    /// This member is required.
    public var masterUsername: Swift.String?
    /// A value that indicates that the restored DB cluster should be associated with the specified option group. Permanent options can't be removed from an option group. An option group can't be removed from a DB cluster once it is associated with a DB cluster.
    public var optionGroupName: Swift.String?
    /// The port number on which the instances in the restored DB cluster accept connections. Default: 3306
    public var port: Swift.Int?
    /// The daily time range during which automated backups are created if automated backups are enabled using the BackupRetentionPeriod parameter. The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region. To view the time blocks available, see [ Backup window](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.Backups.BackupWindow) in the Amazon Aurora User Guide. Constraints:
    ///
    /// * Must be in the format hh24:mi-hh24:mi.
    ///
    /// * Must be in Universal Coordinated Time (UTC).
    ///
    /// * Must not conflict with the preferred maintenance window.
    ///
    /// * Must be at least 30 minutes.
    public var preferredBackupWindow: Swift.String?
    /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Format: ddd:hh24:mi-ddd:hh24:mi The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region, occurring on a random day of the week. To see the time blocks available, see [ Adjusting the Preferred Maintenance Window](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow.Aurora) in the Amazon Aurora User Guide. Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun. Constraints: Minimum 30-minute window.
    public var preferredMaintenanceWindow: Swift.String?
    /// The name of the Amazon S3 bucket that contains the data used to create the Amazon Aurora DB cluster.
    /// This member is required.
    public var s3BucketName: Swift.String?
    /// The Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that authorizes Amazon RDS to access the Amazon S3 bucket on your behalf.
    /// This member is required.
    public var s3IngestionRoleArn: Swift.String?
    /// The prefix for all of the file names that contain the data used to create the Amazon Aurora DB cluster. If you do not specify a SourceS3Prefix value, then the Amazon Aurora DB cluster is created by using all of the files in the Amazon S3 bucket.
    public var s3Prefix: Swift.String?
    /// The identifier for the database engine that was backed up to create the files stored in the Amazon S3 bucket. Valid values: mysql
    /// This member is required.
    public var sourceEngine: Swift.String?
    /// The version of the database that the backup files were created from. MySQL versions 5.5, 5.6, and 5.7 are supported. Example: 5.6.40, 5.7.28
    /// This member is required.
    public var sourceEngineVersion: Swift.String?
    /// A value that indicates whether the restored DB cluster is encrypted.
    public var storageEncrypted: Swift.Bool?
    /// A list of tags. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
    public var tags: [RdsClientTypes.Tag]?
    /// A list of EC2 VPC security groups to associate with the restored DB cluster.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        availabilityZones: [Swift.String]? = nil,
        backtrackWindow: Swift.Int? = nil,
        backupRetentionPeriod: Swift.Int? = nil,
        characterSetName: Swift.String? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        dBClusterParameterGroupName: Swift.String? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        domainIAMRoleName: Swift.String? = nil,
        enableCloudwatchLogsExports: [Swift.String]? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        masterUserPassword: Swift.String? = nil,
        masterUsername: Swift.String? = nil,
        optionGroupName: Swift.String? = nil,
        port: Swift.Int? = nil,
        preferredBackupWindow: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3IngestionRoleArn: Swift.String? = nil,
        s3Prefix: Swift.String? = nil,
        sourceEngine: Swift.String? = nil,
        sourceEngineVersion: Swift.String? = nil,
        storageEncrypted: Swift.Bool? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.backtrackWindow = backtrackWindow
        self.backupRetentionPeriod = backupRetentionPeriod
        self.characterSetName = characterSetName
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.databaseName = databaseName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engine = engine
        self.engineVersion = engineVersion
        self.kmsKeyId = kmsKeyId
        self.masterUserPassword = masterUserPassword
        self.masterUsername = masterUsername
        self.optionGroupName = optionGroupName
        self.port = port
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.s3BucketName = s3BucketName
        self.s3IngestionRoleArn = s3IngestionRoleArn
        self.s3Prefix = s3Prefix
        self.sourceEngine = sourceEngine
        self.sourceEngineVersion = sourceEngineVersion
        self.storageEncrypted = storageEncrypted
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct RestoreDBClusterFromS3InputBody: Swift.Equatable {
    let availabilityZones: [Swift.String]?
    let backupRetentionPeriod: Swift.Int?
    let characterSetName: Swift.String?
    let databaseName: Swift.String?
    let dBClusterIdentifier: Swift.String?
    let dBClusterParameterGroupName: Swift.String?
    let vpcSecurityGroupIds: [Swift.String]?
    let dBSubnetGroupName: Swift.String?
    let engine: Swift.String?
    let engineVersion: Swift.String?
    let port: Swift.Int?
    let masterUsername: Swift.String?
    let masterUserPassword: Swift.String?
    let optionGroupName: Swift.String?
    let preferredBackupWindow: Swift.String?
    let preferredMaintenanceWindow: Swift.String?
    let tags: [RdsClientTypes.Tag]?
    let storageEncrypted: Swift.Bool?
    let kmsKeyId: Swift.String?
    let enableIAMDatabaseAuthentication: Swift.Bool?
    let sourceEngine: Swift.String?
    let sourceEngineVersion: Swift.String?
    let s3BucketName: Swift.String?
    let s3Prefix: Swift.String?
    let s3IngestionRoleArn: Swift.String?
    let backtrackWindow: Swift.Int?
    let enableCloudwatchLogsExports: [Swift.String]?
    let deletionProtection: Swift.Bool?
    let copyTagsToSnapshot: Swift.Bool?
    let domain: Swift.String?
    let domainIAMRoleName: Swift.String?
}

extension RestoreDBClusterFromS3InputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case backtrackWindow = "BacktrackWindow"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case characterSetName = "CharacterSetName"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case databaseName = "DatabaseName"
        case deletionProtection = "DeletionProtection"
        case domain = "Domain"
        case domainIAMRoleName = "DomainIAMRoleName"
        case enableCloudwatchLogsExports = "EnableCloudwatchLogsExports"
        case enableIAMDatabaseAuthentication = "EnableIAMDatabaseAuthentication"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case kmsKeyId = "KmsKeyId"
        case masterUserPassword = "MasterUserPassword"
        case masterUsername = "MasterUsername"
        case optionGroupName = "OptionGroupName"
        case port = "Port"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case s3BucketName = "S3BucketName"
        case s3IngestionRoleArn = "S3IngestionRoleArn"
        case s3Prefix = "S3Prefix"
        case sourceEngine = "SourceEngine"
        case sourceEngineVersion = "SourceEngineVersion"
        case storageEncrypted = "StorageEncrypted"
        case tags = "Tags"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var availabilityZonesBuffer:[Swift.String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [Swift.String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let characterSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .characterSetName)
        characterSetName = characterSetNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
        if containerValues.contains(.vpcSecurityGroupIds) {
            struct KeyVal0{struct VpcSecurityGroupId{}}
            let vpcSecurityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupId>.CodingKeys.self, forKey: .vpcSecurityGroupIds)
            if let vpcSecurityGroupIdsWrappedContainer = vpcSecurityGroupIdsWrappedContainer {
                let vpcSecurityGroupIdsContainer = try vpcSecurityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSecurityGroupIdsBuffer:[Swift.String]? = nil
                if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
                    vpcSecurityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSecurityGroupIdsContainer {
                        vpcSecurityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupIds = vpcSecurityGroupIdsBuffer
            } else {
                vpcSecurityGroupIds = []
            }
        } else {
            vpcSecurityGroupIds = nil
        }
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let masterUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUserPassword)
        masterUserPassword = masterUserPasswordDecoded
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let storageEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let enableIAMDatabaseAuthenticationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableIAMDatabaseAuthentication)
        enableIAMDatabaseAuthentication = enableIAMDatabaseAuthenticationDecoded
        let sourceEngineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEngine)
        sourceEngine = sourceEngineDecoded
        let sourceEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEngineVersion)
        sourceEngineVersion = sourceEngineVersionDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
        let s3IngestionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3IngestionRoleArn)
        s3IngestionRoleArn = s3IngestionRoleArnDecoded
        let backtrackWindowDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backtrackWindow)
        backtrackWindow = backtrackWindowDecoded
        if containerValues.contains(.enableCloudwatchLogsExports) {
            struct KeyVal0{struct member{}}
            let enableCloudwatchLogsExportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enableCloudwatchLogsExports)
            if let enableCloudwatchLogsExportsWrappedContainer = enableCloudwatchLogsExportsWrappedContainer {
                let enableCloudwatchLogsExportsContainer = try enableCloudwatchLogsExportsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var enableCloudwatchLogsExportsBuffer:[Swift.String]? = nil
                if let enableCloudwatchLogsExportsContainer = enableCloudwatchLogsExportsContainer {
                    enableCloudwatchLogsExportsBuffer = [Swift.String]()
                    for stringContainer0 in enableCloudwatchLogsExportsContainer {
                        enableCloudwatchLogsExportsBuffer?.append(stringContainer0)
                    }
                }
                enableCloudwatchLogsExports = enableCloudwatchLogsExportsBuffer
            } else {
                enableCloudwatchLogsExports = []
            }
        } else {
            enableCloudwatchLogsExports = nil
        }
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let copyTagsToSnapshotDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let domainIAMRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainIAMRoleName)
        domainIAMRoleName = domainIAMRoleNameDecoded
    }
}

extension RestoreDBClusterFromS3OutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreDBClusterFromS3OutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterAlreadyExistsFault" : self = .dBClusterAlreadyExistsFault(try DBClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterParameterGroupNotFound" : self = .dBClusterParameterGroupNotFoundFault(try DBClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterQuotaExceededFault" : self = .dBClusterQuotaExceededFault(try DBClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientStorageClusterCapacity" : self = .insufficientStorageClusterCapacityFault(try InsufficientStorageClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetGroupStateFault" : self = .invalidDBSubnetGroupStateFault(try InvalidDBSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3BucketFault" : self = .invalidS3BucketFault(try InvalidS3BucketFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceeded" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDBClusterFromS3OutputError: Swift.Error, Swift.Equatable {
    case dBClusterAlreadyExistsFault(DBClusterAlreadyExistsFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterParameterGroupNotFoundFault(DBClusterParameterGroupNotFoundFault)
    case dBClusterQuotaExceededFault(DBClusterQuotaExceededFault)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case insufficientStorageClusterCapacityFault(InsufficientStorageClusterCapacityFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBSubnetGroupStateFault(InvalidDBSubnetGroupStateFault)
    case invalidS3BucketFault(InvalidS3BucketFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDBClusterFromS3OutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestoreDBClusterFromS3OutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct RestoreDBClusterFromS3OutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon Aurora DB cluster or Multi-AZ DB cluster. For an Amazon Aurora DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, PromoteReadReplicaDBCluster, RestoreDBClusterFromS3, RestoreDBClusterFromSnapshot, RestoreDBClusterToPointInTime, StartDBCluster, and StopDBCluster. For a Multi-AZ DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, RebootDBCluster, RestoreDBClusterFromSnapshot, and RestoreDBClusterToPointInTime. For more information on Amazon Aurora DB clusters, see [ What is Amazon Aurora?](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/CHAP_AuroraOverview.html) in the Amazon Aurora User Guide. For more information on Multi-AZ DB clusters, see [ Multi-AZ deployments with two readable standby DB instances](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/multi-az-db-clusters-concepts.html) in the Amazon RDS User Guide. The Multi-AZ DB clusters feature is in preview and is subject to change.
    public var dBCluster: RdsClientTypes.DBCluster?

    public init (
        dBCluster: RdsClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct RestoreDBClusterFromS3OutputResponseBody: Swift.Equatable {
    let dBCluster: RdsClientTypes.DBCluster?
}

extension RestoreDBClusterFromS3OutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RestoreDBClusterFromS3Result"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

extension RestoreDBClusterFromSnapshotInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: ClientRuntime.Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let backtrackWindow = backtrackWindow {
            try container.encode(backtrackWindow, forKey: ClientRuntime.Key("BacktrackWindow"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterInstanceClass = dBClusterInstanceClass {
            try container.encode(dBClusterInstanceClass, forKey: ClientRuntime.Key("DBClusterInstanceClass"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: ClientRuntime.Key("DatabaseName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: ClientRuntime.Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineMode = engineMode {
            try container.encode(engineMode, forKey: ClientRuntime.Key("EngineMode"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let scalingConfiguration = scalingConfiguration {
            try container.encode(scalingConfiguration, forKey: ClientRuntime.Key("ScalingConfiguration"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: ClientRuntime.Key("SnapshotIdentifier"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreDBClusterFromSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension RestoreDBClusterFromSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct RestoreDBClusterFromSnapshotInput: Swift.Equatable {
    /// Provides the list of Availability Zones (AZs) where instances in the restored DB cluster can be created. Valid for: Aurora DB clusters only
    public var availabilityZones: [Swift.String]?
    /// The target backtrack window, in seconds. To disable backtracking, set this value to 0. Currently, Backtrack is only supported for Aurora MySQL DB clusters. Default: 0 Constraints:
    ///
    /// * If specified, this value must be set to a number from 0 to 259,200 (72 hours).
    ///
    ///
    /// Valid for: Aurora DB clusters only
    public var backtrackWindow: Swift.Int?
    /// A value that indicates whether to copy all tags from the restored DB cluster to snapshots of the restored DB cluster. The default is not to copy them. Valid for: Aurora DB clusters only
    public var copyTagsToSnapshot: Swift.Bool?
    /// The name of the DB cluster to create from the DB snapshot or DB cluster snapshot. This parameter isn't case-sensitive. Constraints:
    ///
    /// * Must contain from 1 to 63 letters, numbers, or hyphens
    ///
    /// * First character must be a letter
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    /// Example: my-snapshot-id Valid for: Aurora DB clusters and Multi-AZ DB clusters
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// The compute and memory capacity of the each DB instance in the Multi-AZ DB cluster, for example db.m6g.xlarge. Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines. For the full list of DB instance classes, and availability for your engine, see [DB Instance Class](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html) in the Amazon RDS User Guide. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var dBClusterInstanceClass: Swift.String?
    /// The name of the DB cluster parameter group to associate with this DB cluster. If this argument is omitted, the default DB cluster parameter group for the specified engine is used. Constraints:
    ///
    /// * If supplied, must match the name of an existing default DB cluster parameter group.
    ///
    /// * Must be 1 to 255 letters, numbers, or hyphens.
    ///
    /// * First character must be a letter.
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    /// Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var dBClusterParameterGroupName: Swift.String?
    /// The name of the DB subnet group to use for the new DB cluster. Constraints: If supplied, must match the name of an existing DB subnet group. Example: mySubnetgroup Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var dBSubnetGroupName: Swift.String?
    /// The database name for the restored DB cluster. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var databaseName: Swift.String?
    /// A value that indicates whether the DB cluster has deletion protection enabled. The database can't be deleted when deletion protection is enabled. By default, deletion protection isn't enabled. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var deletionProtection: Swift.Bool?
    /// Specify the Active Directory directory ID to restore the DB cluster in. The domain must be created prior to this operation. Currently, only MySQL, Microsoft SQL Server, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain. For more information, see [ Kerberos Authentication](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html) in the Amazon RDS User Guide. Valid for: Aurora DB clusters only
    public var domain: Swift.String?
    /// Specify the name of the IAM role to be used when making API calls to the Directory Service. Valid for: Aurora DB clusters only
    public var domainIAMRoleName: Swift.String?
    /// The list of logs that the restored DB cluster is to export to Amazon CloudWatch Logs. The values in the list depend on the DB engine being used. For more information, see [Publishing Database Logs to Amazon CloudWatch Logs ](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch) in the Amazon Aurora User Guide. Valid for: Aurora DB clusters only
    public var enableCloudwatchLogsExports: [Swift.String]?
    /// A value that indicates whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping isn't enabled. For more information, see [ IAM Database Authentication](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.IAMDBAuth.html) in the Amazon Aurora User Guide. Valid for: Aurora DB clusters only
    public var enableIAMDatabaseAuthentication: Swift.Bool?
    /// The database engine to use for the new DB cluster. Default: The same as source Constraint: Must be compatible with the engine of the source Valid for: Aurora DB clusters and Multi-AZ DB clusters
    /// This member is required.
    public var engine: Swift.String?
    /// The DB engine mode of the DB cluster, either provisioned, serverless, parallelquery, global, or multimaster. For more information, see [ CreateDBCluster](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_CreateDBCluster.html). Valid for: Aurora DB clusters only
    public var engineMode: Swift.String?
    /// The version of the database engine to use for the new DB cluster. To list all of the available engine versions for MySQL 5.6-compatible Aurora, use the following command: aws rds describe-db-engine-versions --engine aurora --query "DBEngineVersions[].EngineVersion" To list all of the available engine versions for MySQL 5.7-compatible Aurora, use the following command: aws rds describe-db-engine-versions --engine aurora-mysql --query "DBEngineVersions[].EngineVersion" To list all of the available engine versions for Aurora PostgreSQL, use the following command: aws rds describe-db-engine-versions --engine aurora-postgresql --query "DBEngineVersions[].EngineVersion" To list all of the available engine versions for RDS for MySQL, use the following command: aws rds describe-db-engine-versions --engine mysql --query "DBEngineVersions[].EngineVersion" To list all of the available engine versions for RDS for PostgreSQL, use the following command: aws rds describe-db-engine-versions --engine postgres --query "DBEngineVersions[].EngineVersion" Aurora MySQL See [MySQL on Amazon RDS Versions](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Updates.html) in the Amazon Aurora User Guide. Aurora PostgreSQL See [Amazon Aurora PostgreSQL releases and engine versions](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraPostgreSQL.Updates.20180305.html) in the Amazon Aurora User Guide. MySQL See [MySQL on Amazon RDS Versions](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html#MySQL.Concepts.VersionMgmt) in the Amazon RDS User Guide. PostgreSQL See [Amazon RDS for PostgreSQL versions and extensions](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_PostgreSQL.html#PostgreSQL.Concepts) in the Amazon RDS User Guide. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var engineVersion: Swift.String?
    /// The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for each DB instance in the Multi-AZ DB cluster. For information about valid Iops values, see [Amazon RDS Provisioned IOPS Storage to Improve Performance](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#USER_PIOPS) in the Amazon RDS User Guide. Constraints: Must be a multiple between .5 and 50 of the storage amount for the DB instance. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var iops: Swift.Int?
    /// The Amazon Web Services KMS key identifier to use when restoring an encrypted DB cluster from a DB snapshot or DB cluster snapshot. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN. When you don't specify a value for the KmsKeyId parameter, then the following occurs:
    ///
    /// * If the DB snapshot or DB cluster snapshot in SnapshotIdentifier is encrypted, then the restored DB cluster is encrypted using the KMS key that was used to encrypt the DB snapshot or DB cluster snapshot.
    ///
    /// * If the DB snapshot or DB cluster snapshot in SnapshotIdentifier isn't encrypted, then the restored DB cluster isn't encrypted.
    ///
    ///
    /// Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var kmsKeyId: Swift.String?
    /// The name of the option group to use for the restored DB cluster. DB clusters are associated with a default option group that can't be modified.
    public var optionGroupName: Swift.String?
    /// The port number on which the new DB cluster accepts connections. Constraints: This value must be 1150-65535 Default: The same port as the original DB cluster. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var port: Swift.Int?
    /// A value that indicates whether the DB cluster is publicly accessible. When the DB cluster is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB cluster's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB cluster's VPC. Access to the DB cluster is ultimately controlled by the security group it uses. That public access is not permitted if the security group assigned to the DB cluster doesn't permit it. When the DB cluster isn't publicly accessible, it is an internal DB cluster with a DNS name that resolves to a private IP address. Default: The default behavior varies depending on whether DBSubnetGroupName is specified. If DBSubnetGroupName isn't specified, and PubliclyAccessible isn't specified, the following applies:
    ///
    /// * If the default VPC in the target Region doesnt have an internet gateway attached to it, the DB cluster is private.
    ///
    /// * If the default VPC in the target Region has an internet gateway attached to it, the DB cluster is public.
    ///
    ///
    /// If DBSubnetGroupName is specified, and PubliclyAccessible isn't specified, the following applies:
    ///
    /// * If the subnets are part of a VPC that doesnt have an internet gateway attached to it, the DB cluster is private.
    ///
    /// * If the subnets are part of a VPC that has an internet gateway attached to it, the DB cluster is public.
    ///
    ///
    /// Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var publiclyAccessible: Swift.Bool?
    /// For DB clusters in serverless DB engine mode, the scaling properties of the DB cluster. Valid for: Aurora DB clusters only
    public var scalingConfiguration: RdsClientTypes.ScalingConfiguration?
    /// The identifier for the DB snapshot or DB cluster snapshot to restore from. You can use either the name or the Amazon Resource Name (ARN) to specify a DB cluster snapshot. However, you can use only the ARN to specify a DB snapshot. Constraints:
    ///
    /// * Must match the identifier of an existing Snapshot.
    ///
    ///
    /// Valid for: Aurora DB clusters and Multi-AZ DB clusters
    /// This member is required.
    public var snapshotIdentifier: Swift.String?
    /// Specifies the storage type to be associated with the each DB instance in the Multi-AZ DB cluster. Valid values: standard | gp2 | io1 If you specify io1, you must also include a value for the Iops parameter. Default: io1 if the Iops parameter is specified, otherwise gp2 Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var storageType: Swift.String?
    /// The tags to be assigned to the restored DB cluster. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var tags: [RdsClientTypes.Tag]?
    /// A list of VPC security groups that the new DB cluster will belong to. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        availabilityZones: [Swift.String]? = nil,
        backtrackWindow: Swift.Int? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        dBClusterInstanceClass: Swift.String? = nil,
        dBClusterParameterGroupName: Swift.String? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        domainIAMRoleName: Swift.String? = nil,
        enableCloudwatchLogsExports: [Swift.String]? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        engine: Swift.String? = nil,
        engineMode: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        iops: Swift.Int? = nil,
        kmsKeyId: Swift.String? = nil,
        optionGroupName: Swift.String? = nil,
        port: Swift.Int? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        scalingConfiguration: RdsClientTypes.ScalingConfiguration? = nil,
        snapshotIdentifier: Swift.String? = nil,
        storageType: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.backtrackWindow = backtrackWindow
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterInstanceClass = dBClusterInstanceClass
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.databaseName = databaseName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engine = engine
        self.engineMode = engineMode
        self.engineVersion = engineVersion
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.optionGroupName = optionGroupName
        self.port = port
        self.publiclyAccessible = publiclyAccessible
        self.scalingConfiguration = scalingConfiguration
        self.snapshotIdentifier = snapshotIdentifier
        self.storageType = storageType
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct RestoreDBClusterFromSnapshotInputBody: Swift.Equatable {
    let availabilityZones: [Swift.String]?
    let dBClusterIdentifier: Swift.String?
    let snapshotIdentifier: Swift.String?
    let engine: Swift.String?
    let engineVersion: Swift.String?
    let port: Swift.Int?
    let dBSubnetGroupName: Swift.String?
    let databaseName: Swift.String?
    let optionGroupName: Swift.String?
    let vpcSecurityGroupIds: [Swift.String]?
    let tags: [RdsClientTypes.Tag]?
    let kmsKeyId: Swift.String?
    let enableIAMDatabaseAuthentication: Swift.Bool?
    let backtrackWindow: Swift.Int?
    let enableCloudwatchLogsExports: [Swift.String]?
    let engineMode: Swift.String?
    let scalingConfiguration: RdsClientTypes.ScalingConfiguration?
    let dBClusterParameterGroupName: Swift.String?
    let deletionProtection: Swift.Bool?
    let copyTagsToSnapshot: Swift.Bool?
    let domain: Swift.String?
    let domainIAMRoleName: Swift.String?
    let dBClusterInstanceClass: Swift.String?
    let storageType: Swift.String?
    let iops: Swift.Int?
    let publiclyAccessible: Swift.Bool?
}

extension RestoreDBClusterFromSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case backtrackWindow = "BacktrackWindow"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBClusterInstanceClass = "DBClusterInstanceClass"
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case databaseName = "DatabaseName"
        case deletionProtection = "DeletionProtection"
        case domain = "Domain"
        case domainIAMRoleName = "DomainIAMRoleName"
        case enableCloudwatchLogsExports = "EnableCloudwatchLogsExports"
        case enableIAMDatabaseAuthentication = "EnableIAMDatabaseAuthentication"
        case engine = "Engine"
        case engineMode = "EngineMode"
        case engineVersion = "EngineVersion"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case optionGroupName = "OptionGroupName"
        case port = "Port"
        case publiclyAccessible = "PubliclyAccessible"
        case scalingConfiguration = "ScalingConfiguration"
        case snapshotIdentifier = "SnapshotIdentifier"
        case storageType = "StorageType"
        case tags = "Tags"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var availabilityZonesBuffer:[Swift.String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [Swift.String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let snapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotIdentifier)
        snapshotIdentifier = snapshotIdentifierDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        if containerValues.contains(.vpcSecurityGroupIds) {
            struct KeyVal0{struct VpcSecurityGroupId{}}
            let vpcSecurityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupId>.CodingKeys.self, forKey: .vpcSecurityGroupIds)
            if let vpcSecurityGroupIdsWrappedContainer = vpcSecurityGroupIdsWrappedContainer {
                let vpcSecurityGroupIdsContainer = try vpcSecurityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSecurityGroupIdsBuffer:[Swift.String]? = nil
                if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
                    vpcSecurityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSecurityGroupIdsContainer {
                        vpcSecurityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupIds = vpcSecurityGroupIdsBuffer
            } else {
                vpcSecurityGroupIds = []
            }
        } else {
            vpcSecurityGroupIds = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let enableIAMDatabaseAuthenticationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableIAMDatabaseAuthentication)
        enableIAMDatabaseAuthentication = enableIAMDatabaseAuthenticationDecoded
        let backtrackWindowDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backtrackWindow)
        backtrackWindow = backtrackWindowDecoded
        if containerValues.contains(.enableCloudwatchLogsExports) {
            struct KeyVal0{struct member{}}
            let enableCloudwatchLogsExportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enableCloudwatchLogsExports)
            if let enableCloudwatchLogsExportsWrappedContainer = enableCloudwatchLogsExportsWrappedContainer {
                let enableCloudwatchLogsExportsContainer = try enableCloudwatchLogsExportsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var enableCloudwatchLogsExportsBuffer:[Swift.String]? = nil
                if let enableCloudwatchLogsExportsContainer = enableCloudwatchLogsExportsContainer {
                    enableCloudwatchLogsExportsBuffer = [Swift.String]()
                    for stringContainer0 in enableCloudwatchLogsExportsContainer {
                        enableCloudwatchLogsExportsBuffer?.append(stringContainer0)
                    }
                }
                enableCloudwatchLogsExports = enableCloudwatchLogsExportsBuffer
            } else {
                enableCloudwatchLogsExports = []
            }
        } else {
            enableCloudwatchLogsExports = nil
        }
        let engineModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineMode)
        engineMode = engineModeDecoded
        let scalingConfigurationDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ScalingConfiguration.self, forKey: .scalingConfiguration)
        scalingConfiguration = scalingConfigurationDecoded
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let copyTagsToSnapshotDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let domainIAMRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainIAMRoleName)
        domainIAMRoleName = domainIAMRoleNameDecoded
        let dBClusterInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterInstanceClass)
        dBClusterInstanceClass = dBClusterInstanceClassDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
    }
}

extension RestoreDBClusterFromSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreDBClusterFromSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterAlreadyExistsFault" : self = .dBClusterAlreadyExistsFault(try DBClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterParameterGroupNotFound" : self = .dBClusterParameterGroupNotFoundFault(try DBClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterQuotaExceededFault" : self = .dBClusterQuotaExceededFault(try DBClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBClusterCapacityFault" : self = .insufficientDBClusterCapacityFault(try InsufficientDBClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientStorageClusterCapacity" : self = .insufficientStorageClusterCapacityFault(try InsufficientStorageClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSnapshotState" : self = .invalidDBSnapshotStateFault(try InvalidDBSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRestoreFault" : self = .invalidRestoreFault(try InvalidRestoreFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceeded" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDBClusterFromSnapshotOutputError: Swift.Error, Swift.Equatable {
    case dBClusterAlreadyExistsFault(DBClusterAlreadyExistsFault)
    case dBClusterParameterGroupNotFoundFault(DBClusterParameterGroupNotFoundFault)
    case dBClusterQuotaExceededFault(DBClusterQuotaExceededFault)
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case insufficientDBClusterCapacityFault(InsufficientDBClusterCapacityFault)
    case insufficientStorageClusterCapacityFault(InsufficientStorageClusterCapacityFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBSnapshotStateFault(InvalidDBSnapshotStateFault)
    case invalidRestoreFault(InvalidRestoreFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDBClusterFromSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestoreDBClusterFromSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct RestoreDBClusterFromSnapshotOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon Aurora DB cluster or Multi-AZ DB cluster. For an Amazon Aurora DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, PromoteReadReplicaDBCluster, RestoreDBClusterFromS3, RestoreDBClusterFromSnapshot, RestoreDBClusterToPointInTime, StartDBCluster, and StopDBCluster. For a Multi-AZ DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, RebootDBCluster, RestoreDBClusterFromSnapshot, and RestoreDBClusterToPointInTime. For more information on Amazon Aurora DB clusters, see [ What is Amazon Aurora?](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/CHAP_AuroraOverview.html) in the Amazon Aurora User Guide. For more information on Multi-AZ DB clusters, see [ Multi-AZ deployments with two readable standby DB instances](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/multi-az-db-clusters-concepts.html) in the Amazon RDS User Guide. The Multi-AZ DB clusters feature is in preview and is subject to change.
    public var dBCluster: RdsClientTypes.DBCluster?

    public init (
        dBCluster: RdsClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct RestoreDBClusterFromSnapshotOutputResponseBody: Swift.Equatable {
    let dBCluster: RdsClientTypes.DBCluster?
}

extension RestoreDBClusterFromSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RestoreDBClusterFromSnapshotResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

extension RestoreDBClusterToPointInTimeInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let backtrackWindow = backtrackWindow {
            try container.encode(backtrackWindow, forKey: ClientRuntime.Key("BacktrackWindow"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterInstanceClass = dBClusterInstanceClass {
            try container.encode(dBClusterInstanceClass, forKey: ClientRuntime.Key("DBClusterInstanceClass"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: ClientRuntime.Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let engineMode = engineMode {
            try container.encode(engineMode, forKey: ClientRuntime.Key("EngineMode"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let restoreToTime = restoreToTime {
            try container.encode(ClientRuntime.TimestampWrapper(restoreToTime, format: .dateTime), forKey: ClientRuntime.Key("restoreToTime"))
        }
        if let restoreType = restoreType {
            try container.encode(restoreType, forKey: ClientRuntime.Key("RestoreType"))
        }
        if let scalingConfiguration = scalingConfiguration {
            try container.encode(scalingConfiguration, forKey: ClientRuntime.Key("ScalingConfiguration"))
        }
        if let sourceDBClusterIdentifier = sourceDBClusterIdentifier {
            try container.encode(sourceDBClusterIdentifier, forKey: ClientRuntime.Key("SourceDBClusterIdentifier"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if useLatestRestorableTime != false {
            try container.encode(useLatestRestorableTime, forKey: ClientRuntime.Key("UseLatestRestorableTime"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreDBClusterToPointInTime", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension RestoreDBClusterToPointInTimeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct RestoreDBClusterToPointInTimeInput: Swift.Equatable {
    /// The target backtrack window, in seconds. To disable backtracking, set this value to 0. Default: 0 Constraints:
    ///
    /// * If specified, this value must be set to a number from 0 to 259,200 (72 hours).
    ///
    ///
    /// Valid for: Aurora MySQL DB clusters only
    public var backtrackWindow: Swift.Int?
    /// A value that indicates whether to copy all tags from the restored DB cluster to snapshots of the restored DB cluster. The default is not to copy them. Valid for: Aurora DB clusters only
    public var copyTagsToSnapshot: Swift.Bool?
    /// The name of the new DB cluster to be created. Constraints:
    ///
    /// * Must contain from 1 to 63 letters, numbers, or hyphens
    ///
    /// * First character must be a letter
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    /// Valid for: Aurora DB clusters and Multi-AZ DB clusters
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// The compute and memory capacity of the each DB instance in the Multi-AZ DB cluster, for example db.m6g.xlarge. Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines. For the full list of DB instance classes, and availability for your engine, see [DB instance class](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html) in the Amazon RDS User Guide. Valid for: Multi-AZ DB clusters only
    public var dBClusterInstanceClass: Swift.String?
    /// The name of the DB cluster parameter group to associate with this DB cluster. If this argument is omitted, the default DB cluster parameter group for the specified engine is used. Constraints:
    ///
    /// * If supplied, must match the name of an existing DB cluster parameter group.
    ///
    /// * Must be 1 to 255 letters, numbers, or hyphens.
    ///
    /// * First character must be a letter.
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    /// Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var dBClusterParameterGroupName: Swift.String?
    /// The DB subnet group name to use for the new DB cluster. Constraints: If supplied, must match the name of an existing DBSubnetGroup. Example: mySubnetgroup Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var dBSubnetGroupName: Swift.String?
    /// A value that indicates whether the DB cluster has deletion protection enabled. The database can't be deleted when deletion protection is enabled. By default, deletion protection isn't enabled. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var deletionProtection: Swift.Bool?
    /// Specify the Active Directory directory ID to restore the DB cluster in. The domain must be created prior to this operation. For Amazon Aurora DB clusters, Amazon RDS can use Kerberos Authentication to authenticate users that connect to the DB cluster. For more information, see [Kerberos Authentication](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/kerberos-authentication.html) in the Amazon Aurora User Guide. Valid for: Aurora DB clusters only
    public var domain: Swift.String?
    /// Specify the name of the IAM role to be used when making API calls to the Directory Service. Valid for: Aurora DB clusters only
    public var domainIAMRoleName: Swift.String?
    /// The list of logs that the restored DB cluster is to export to CloudWatch Logs. The values in the list depend on the DB engine being used. For more information, see [Publishing Database Logs to Amazon CloudWatch Logs](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch) in the Amazon Aurora User Guide. Valid for: Aurora DB clusters only
    public var enableCloudwatchLogsExports: [Swift.String]?
    /// A value that indicates whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping isn't enabled. For more information, see [ IAM Database Authentication](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.IAMDBAuth.html) in the Amazon Aurora User Guide. Valid for: Aurora DB clusters only
    public var enableIAMDatabaseAuthentication: Swift.Bool?
    /// The engine mode of the new cluster. Specify provisioned or serverless, depending on the type of the cluster you are creating. You can create an Aurora Serverless clone from a provisioned cluster, or a provisioned clone from an Aurora Serverless cluster. To create a clone that is an Aurora Serverless cluster, the original cluster must be an Aurora Serverless cluster or an encrypted provisioned cluster. Valid for: Aurora DB clusters only
    public var engineMode: Swift.String?
    /// The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for each DB instance in the Multi-AZ DB cluster. For information about valid Iops values, see [Amazon RDS Provisioned IOPS storage to improve performance](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#USER_PIOPS) in the Amazon RDS User Guide. Constraints: Must be a multiple between .5 and 50 of the storage amount for the DB instance. Valid for: Multi-AZ DB clusters only
    public var iops: Swift.Int?
    /// The Amazon Web Services KMS key identifier to use when restoring an encrypted DB cluster from an encrypted DB cluster. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN. You can restore to a new DB cluster and encrypt the new DB cluster with a KMS key that is different from the KMS key used to encrypt the source DB cluster. The new DB cluster is encrypted with the KMS key identified by the KmsKeyId parameter. If you don't specify a value for the KmsKeyId parameter, then the following occurs:
    ///
    /// * If the DB cluster is encrypted, then the restored DB cluster is encrypted using the KMS key that was used to encrypt the source DB cluster.
    ///
    /// * If the DB cluster isn't encrypted, then the restored DB cluster isn't encrypted.
    ///
    ///
    /// If DBClusterIdentifier refers to a DB cluster that isn't encrypted, then the restore request is rejected. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var kmsKeyId: Swift.String?
    /// The name of the option group for the new DB cluster. DB clusters are associated with a default option group that can't be modified.
    public var optionGroupName: Swift.String?
    /// The port number on which the new DB cluster accepts connections. Constraints: A value from 1150-65535. Default: The default port for the engine. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var port: Swift.Int?
    /// A value that indicates whether the DB cluster is publicly accessible. When the DB cluster is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB cluster's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB cluster's VPC. Access to the DB cluster is ultimately controlled by the security group it uses. That public access is not permitted if the security group assigned to the DB cluster doesn't permit it. When the DB cluster isn't publicly accessible, it is an internal DB cluster with a DNS name that resolves to a private IP address. Default: The default behavior varies depending on whether DBSubnetGroupName is specified. If DBSubnetGroupName isn't specified, and PubliclyAccessible isn't specified, the following applies:
    ///
    /// * If the default VPC in the target Region doesnt have an internet gateway attached to it, the DB cluster is private.
    ///
    /// * If the default VPC in the target Region has an internet gateway attached to it, the DB cluster is public.
    ///
    ///
    /// If DBSubnetGroupName is specified, and PubliclyAccessible isn't specified, the following applies:
    ///
    /// * If the subnets are part of a VPC that doesnt have an internet gateway attached to it, the DB cluster is private.
    ///
    /// * If the subnets are part of a VPC that has an internet gateway attached to it, the DB cluster is public.
    ///
    ///
    /// Valid for: Multi-AZ DB clusters only
    public var publiclyAccessible: Swift.Bool?
    /// The date and time to restore the DB cluster to. Valid Values: Value must be a time in Universal Coordinated Time (UTC) format Constraints:
    ///
    /// * Must be before the latest restorable time for the DB instance
    ///
    /// * Must be specified if UseLatestRestorableTime parameter isn't provided
    ///
    /// * Can't be specified if the UseLatestRestorableTime parameter is enabled
    ///
    /// * Can't be specified if the RestoreType parameter is copy-on-write
    ///
    ///
    /// Example: 2015-03-07T23:45:00Z Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var restoreToTime: ClientRuntime.Date?
    /// The type of restore to be performed. You can specify one of the following values:
    ///
    /// * full-copy - The new DB cluster is restored as a full copy of the source DB cluster.
    ///
    /// * copy-on-write - The new DB cluster is restored as a clone of the source DB cluster.
    ///
    ///
    /// Constraints: You can't specify copy-on-write if the engine version of the source DB cluster is earlier than 1.11. If you don't specify a RestoreType value, then the new DB cluster is restored as a full copy of the source DB cluster. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var restoreType: Swift.String?
    /// For DB clusters in serverless DB engine mode, the scaling properties of the DB cluster. Valid for: Aurora DB clusters only
    public var scalingConfiguration: RdsClientTypes.ScalingConfiguration?
    /// The identifier of the source DB cluster from which to restore. Constraints:
    ///
    /// * Must match the identifier of an existing DBCluster.
    ///
    ///
    /// Valid for: Aurora DB clusters and Multi-AZ DB clusters
    /// This member is required.
    public var sourceDBClusterIdentifier: Swift.String?
    /// Specifies the storage type to be associated with the each DB instance in the Multi-AZ DB cluster. Valid values: standard | gp2 | io1 If you specify io1, also include a value for the Iops parameter. Default: io1 if the Iops parameter is specified, otherwise gp2 Valid for: Multi-AZ DB clusters only
    public var storageType: Swift.String?
    /// A list of tags. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
    public var tags: [RdsClientTypes.Tag]?
    /// A value that indicates whether to restore the DB cluster to the latest restorable backup time. By default, the DB cluster isn't restored to the latest restorable backup time. Constraints: Can't be specified if RestoreToTime parameter is provided. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var useLatestRestorableTime: Swift.Bool
    /// A list of VPC security groups that the new DB cluster belongs to. Valid for: Aurora DB clusters and Multi-AZ DB clusters
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        backtrackWindow: Swift.Int? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        dBClusterInstanceClass: Swift.String? = nil,
        dBClusterParameterGroupName: Swift.String? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        domainIAMRoleName: Swift.String? = nil,
        enableCloudwatchLogsExports: [Swift.String]? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        engineMode: Swift.String? = nil,
        iops: Swift.Int? = nil,
        kmsKeyId: Swift.String? = nil,
        optionGroupName: Swift.String? = nil,
        port: Swift.Int? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        restoreToTime: ClientRuntime.Date? = nil,
        restoreType: Swift.String? = nil,
        scalingConfiguration: RdsClientTypes.ScalingConfiguration? = nil,
        sourceDBClusterIdentifier: Swift.String? = nil,
        storageType: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        useLatestRestorableTime: Swift.Bool = false,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.backtrackWindow = backtrackWindow
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterInstanceClass = dBClusterInstanceClass
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engineMode = engineMode
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.optionGroupName = optionGroupName
        self.port = port
        self.publiclyAccessible = publiclyAccessible
        self.restoreToTime = restoreToTime
        self.restoreType = restoreType
        self.scalingConfiguration = scalingConfiguration
        self.sourceDBClusterIdentifier = sourceDBClusterIdentifier
        self.storageType = storageType
        self.tags = tags
        self.useLatestRestorableTime = useLatestRestorableTime
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct RestoreDBClusterToPointInTimeInputBody: Swift.Equatable {
    let dBClusterIdentifier: Swift.String?
    let restoreType: Swift.String?
    let sourceDBClusterIdentifier: Swift.String?
    let restoreToTime: ClientRuntime.Date?
    let useLatestRestorableTime: Swift.Bool
    let port: Swift.Int?
    let dBSubnetGroupName: Swift.String?
    let optionGroupName: Swift.String?
    let vpcSecurityGroupIds: [Swift.String]?
    let tags: [RdsClientTypes.Tag]?
    let kmsKeyId: Swift.String?
    let enableIAMDatabaseAuthentication: Swift.Bool?
    let backtrackWindow: Swift.Int?
    let enableCloudwatchLogsExports: [Swift.String]?
    let dBClusterParameterGroupName: Swift.String?
    let deletionProtection: Swift.Bool?
    let copyTagsToSnapshot: Swift.Bool?
    let domain: Swift.String?
    let domainIAMRoleName: Swift.String?
    let scalingConfiguration: RdsClientTypes.ScalingConfiguration?
    let engineMode: Swift.String?
    let dBClusterInstanceClass: Swift.String?
    let storageType: Swift.String?
    let publiclyAccessible: Swift.Bool?
    let iops: Swift.Int?
}

extension RestoreDBClusterToPointInTimeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backtrackWindow = "BacktrackWindow"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBClusterInstanceClass = "DBClusterInstanceClass"
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case deletionProtection = "DeletionProtection"
        case domain = "Domain"
        case domainIAMRoleName = "DomainIAMRoleName"
        case enableCloudwatchLogsExports = "EnableCloudwatchLogsExports"
        case enableIAMDatabaseAuthentication = "EnableIAMDatabaseAuthentication"
        case engineMode = "EngineMode"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case optionGroupName = "OptionGroupName"
        case port = "Port"
        case publiclyAccessible = "PubliclyAccessible"
        case restoreToTime = "RestoreToTime"
        case restoreType = "RestoreType"
        case scalingConfiguration = "ScalingConfiguration"
        case sourceDBClusterIdentifier = "SourceDBClusterIdentifier"
        case storageType = "StorageType"
        case tags = "Tags"
        case useLatestRestorableTime = "UseLatestRestorableTime"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let restoreTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restoreType)
        restoreType = restoreTypeDecoded
        let sourceDBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDBClusterIdentifier)
        sourceDBClusterIdentifier = sourceDBClusterIdentifierDecoded
        let restoreToTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restoreToTime)
        var restoreToTimeBuffer:ClientRuntime.Date? = nil
        if let restoreToTimeDecoded = restoreToTimeDecoded {
            restoreToTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(restoreToTimeDecoded, format: .dateTime)
        }
        restoreToTime = restoreToTimeBuffer
        let useLatestRestorableTimeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .useLatestRestorableTime)
        useLatestRestorableTime = useLatestRestorableTimeDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        if containerValues.contains(.vpcSecurityGroupIds) {
            struct KeyVal0{struct VpcSecurityGroupId{}}
            let vpcSecurityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupId>.CodingKeys.self, forKey: .vpcSecurityGroupIds)
            if let vpcSecurityGroupIdsWrappedContainer = vpcSecurityGroupIdsWrappedContainer {
                let vpcSecurityGroupIdsContainer = try vpcSecurityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSecurityGroupIdsBuffer:[Swift.String]? = nil
                if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
                    vpcSecurityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSecurityGroupIdsContainer {
                        vpcSecurityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupIds = vpcSecurityGroupIdsBuffer
            } else {
                vpcSecurityGroupIds = []
            }
        } else {
            vpcSecurityGroupIds = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let enableIAMDatabaseAuthenticationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableIAMDatabaseAuthentication)
        enableIAMDatabaseAuthentication = enableIAMDatabaseAuthenticationDecoded
        let backtrackWindowDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backtrackWindow)
        backtrackWindow = backtrackWindowDecoded
        if containerValues.contains(.enableCloudwatchLogsExports) {
            struct KeyVal0{struct member{}}
            let enableCloudwatchLogsExportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enableCloudwatchLogsExports)
            if let enableCloudwatchLogsExportsWrappedContainer = enableCloudwatchLogsExportsWrappedContainer {
                let enableCloudwatchLogsExportsContainer = try enableCloudwatchLogsExportsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var enableCloudwatchLogsExportsBuffer:[Swift.String]? = nil
                if let enableCloudwatchLogsExportsContainer = enableCloudwatchLogsExportsContainer {
                    enableCloudwatchLogsExportsBuffer = [Swift.String]()
                    for stringContainer0 in enableCloudwatchLogsExportsContainer {
                        enableCloudwatchLogsExportsBuffer?.append(stringContainer0)
                    }
                }
                enableCloudwatchLogsExports = enableCloudwatchLogsExportsBuffer
            } else {
                enableCloudwatchLogsExports = []
            }
        } else {
            enableCloudwatchLogsExports = nil
        }
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let copyTagsToSnapshotDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let domainIAMRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainIAMRoleName)
        domainIAMRoleName = domainIAMRoleNameDecoded
        let scalingConfigurationDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ScalingConfiguration.self, forKey: .scalingConfiguration)
        scalingConfiguration = scalingConfigurationDecoded
        let engineModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineMode)
        engineMode = engineModeDecoded
        let dBClusterInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterInstanceClass)
        dBClusterInstanceClass = dBClusterInstanceClassDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
    }
}

extension RestoreDBClusterToPointInTimeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreDBClusterToPointInTimeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterAlreadyExistsFault" : self = .dBClusterAlreadyExistsFault(try DBClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterParameterGroupNotFound" : self = .dBClusterParameterGroupNotFoundFault(try DBClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterQuotaExceededFault" : self = .dBClusterQuotaExceededFault(try DBClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBClusterCapacityFault" : self = .insufficientDBClusterCapacityFault(try InsufficientDBClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientStorageClusterCapacity" : self = .insufficientStorageClusterCapacityFault(try InsufficientStorageClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSnapshotState" : self = .invalidDBSnapshotStateFault(try InvalidDBSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRestoreFault" : self = .invalidRestoreFault(try InvalidRestoreFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceeded" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDBClusterToPointInTimeOutputError: Swift.Error, Swift.Equatable {
    case dBClusterAlreadyExistsFault(DBClusterAlreadyExistsFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterParameterGroupNotFoundFault(DBClusterParameterGroupNotFoundFault)
    case dBClusterQuotaExceededFault(DBClusterQuotaExceededFault)
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case insufficientDBClusterCapacityFault(InsufficientDBClusterCapacityFault)
    case insufficientStorageClusterCapacityFault(InsufficientStorageClusterCapacityFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBSnapshotStateFault(InvalidDBSnapshotStateFault)
    case invalidRestoreFault(InvalidRestoreFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDBClusterToPointInTimeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestoreDBClusterToPointInTimeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct RestoreDBClusterToPointInTimeOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon Aurora DB cluster or Multi-AZ DB cluster. For an Amazon Aurora DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, PromoteReadReplicaDBCluster, RestoreDBClusterFromS3, RestoreDBClusterFromSnapshot, RestoreDBClusterToPointInTime, StartDBCluster, and StopDBCluster. For a Multi-AZ DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, RebootDBCluster, RestoreDBClusterFromSnapshot, and RestoreDBClusterToPointInTime. For more information on Amazon Aurora DB clusters, see [ What is Amazon Aurora?](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/CHAP_AuroraOverview.html) in the Amazon Aurora User Guide. For more information on Multi-AZ DB clusters, see [ Multi-AZ deployments with two readable standby DB instances](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/multi-az-db-clusters-concepts.html) in the Amazon RDS User Guide. The Multi-AZ DB clusters feature is in preview and is subject to change.
    public var dBCluster: RdsClientTypes.DBCluster?

    public init (
        dBCluster: RdsClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct RestoreDBClusterToPointInTimeOutputResponseBody: Swift.Equatable {
    let dBCluster: RdsClientTypes.DBCluster?
}

extension RestoreDBClusterToPointInTimeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RestoreDBClusterToPointInTimeResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

extension RestoreDBInstanceFromDBSnapshotInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: ClientRuntime.Key("AutoMinorVersionUpgrade"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let backupTarget = backupTarget {
            try container.encode(backupTarget, forKey: ClientRuntime.Key("BackupTarget"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let customIamInstanceProfile = customIamInstanceProfile {
            try container.encode(customIamInstanceProfile, forKey: ClientRuntime.Key("CustomIamInstanceProfile"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: ClientRuntime.Key("DBName"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: ClientRuntime.Key("DBSnapshotIdentifier"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: ClientRuntime.Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableCustomerOwnedIp = enableCustomerOwnedIp {
            try container.encode(enableCustomerOwnedIp, forKey: ClientRuntime.Key("EnableCustomerOwnedIp"))
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: ClientRuntime.Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: ClientRuntime.Key("TdeCredentialArn"))
        }
        if let tdeCredentialPassword = tdeCredentialPassword {
            try container.encode(tdeCredentialPassword, forKey: ClientRuntime.Key("TdeCredentialPassword"))
        }
        if let useDefaultProcessorFeatures = useDefaultProcessorFeatures {
            try container.encode(useDefaultProcessorFeatures, forKey: ClientRuntime.Key("UseDefaultProcessorFeatures"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreDBInstanceFromDBSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension RestoreDBInstanceFromDBSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct RestoreDBInstanceFromDBSnapshotInput: Swift.Equatable {
    /// A value that indicates whether minor version upgrades are applied automatically to the DB instance during the maintenance window. If you restore an RDS Custom DB instance, you must disable this parameter.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The Availability Zone (AZ) where the DB instance will be created. Default: A random, system-chosen Availability Zone. Constraint: You can't specify the AvailabilityZone parameter if the DB instance is a Multi-AZ deployment. Example: us-east-1a
    public var availabilityZone: Swift.String?
    /// Specifies where automated backups and manual snapshots are stored for the restored DB instance. Possible values are outposts (Amazon Web Services Outposts) and region (Amazon Web Services Region). The default is region. For more information, see [Working with Amazon RDS on Amazon Web Services Outposts](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html) in the Amazon RDS User Guide.
    public var backupTarget: Swift.String?
    /// A value that indicates whether to copy all tags from the restored DB instance to snapshots of the DB instance. By default, tags are not copied.
    public var copyTagsToSnapshot: Swift.Bool?
    /// The instance profile associated with the underlying Amazon EC2 instance of an RDS Custom DB instance. The instance profile must meet the following requirements:
    ///
    /// * The profile must exist in your account.
    ///
    /// * The profile must have an IAM role that Amazon EC2 has permissions to assume.
    ///
    /// * The instance profile name and the associated IAM role name must start with the prefix AWSRDSCustom.
    ///
    ///
    /// For the list of permissions required for the IAM role, see [ Configure IAM and your VPC](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/custom-setup-orcl.html#custom-setup-orcl.iam-vpc) in the Amazon Relational Database Service User Guide. This setting is required for RDS Custom.
    public var customIamInstanceProfile: Swift.String?
    /// The compute and memory capacity of the Amazon RDS DB instance, for example db.m4.large. Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines. For the full list of DB instance classes, and availability for your engine, see [DB Instance Class](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html) in the Amazon RDS User Guide. Default: The same DBInstanceClass as the original DB instance.
    public var dBInstanceClass: Swift.String?
    /// Name of the DB instance to create from the DB snapshot. This parameter isn't case-sensitive. Constraints:
    ///
    /// * Must contain from 1 to 63 numbers, letters, or hyphens
    ///
    /// * First character must be a letter
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    /// Example: my-snapshot-id
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// The database name for the restored DB instance. This parameter doesn't apply to the MySQL, PostgreSQL, or MariaDB engines. It also doesn't apply to RDS Custom DB instances.
    public var dBName: Swift.String?
    /// The name of the DB parameter group to associate with this DB instance. If you don't specify a value for DBParameterGroupName, then RDS uses the default DBParameterGroup for the specified DB engine. This setting doesn't apply to RDS Custom. Constraints:
    ///
    /// * If supplied, must match the name of an existing DBParameterGroup.
    ///
    /// * Must be 1 to 255 letters, numbers, or hyphens.
    ///
    /// * First character must be a letter.
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens.
    public var dBParameterGroupName: Swift.String?
    /// The identifier for the DB snapshot to restore from. Constraints:
    ///
    /// * Must match the identifier of an existing DBSnapshot.
    ///
    /// * If you are restoring from a shared manual DB snapshot, the DBSnapshotIdentifier must be the ARN of the shared DB snapshot.
    /// This member is required.
    public var dBSnapshotIdentifier: Swift.String?
    /// The DB subnet group name to use for the new instance. Constraints: If supplied, must match the name of an existing DBSubnetGroup. Example: mySubnetgroup
    public var dBSubnetGroupName: Swift.String?
    /// A value that indicates whether the DB instance has deletion protection enabled. The database can't be deleted when deletion protection is enabled. By default, deletion protection isn't enabled. For more information, see [ Deleting a DB Instance](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html).
    public var deletionProtection: Swift.Bool?
    /// Specify the Active Directory directory ID to restore the DB instance in. The domain/ must be created prior to this operation. Currently, you can create only MySQL, Microsoft SQL Server, Oracle, and PostgreSQL DB instances in an Active Directory Domain. For more information, see [ Kerberos Authentication](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html) in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom.
    public var domain: Swift.String?
    /// Specify the name of the IAM role to be used when making API calls to the Directory Service. This setting doesn't apply to RDS Custom.
    public var domainIAMRoleName: Swift.String?
    /// The list of logs that the restored DB instance is to export to CloudWatch Logs. The values in the list depend on the DB engine being used. For more information, see [Publishing Database Logs to Amazon CloudWatch Logs](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch) in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom.
    public var enableCloudwatchLogsExports: [Swift.String]?
    /// A value that indicates whether to enable a customer-owned IP address (CoIP) for an RDS on Outposts DB instance. A CoIP provides local or external connectivity to resources in your Outpost subnets through your on-premises network. For some use cases, a CoIP can provide lower latency for connections to the DB instance from outside of its virtual private cloud (VPC) on your local network. This setting doesn't apply to RDS Custom. For more information about RDS on Outposts, see [Working with Amazon RDS on Amazon Web Services Outposts](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html) in the Amazon RDS User Guide. For more information about CoIPs, see [Customer-owned IP addresses](https://docs.aws.amazon.com/outposts/latest/userguide/outposts-networking-components.html#ip-addressing) in the Amazon Web Services Outposts User Guide.
    public var enableCustomerOwnedIp: Swift.Bool?
    /// A value that indicates whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping is disabled. For more information about IAM database authentication, see [ IAM Database Authentication for MySQL and PostgreSQL](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html) in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom.
    public var enableIAMDatabaseAuthentication: Swift.Bool?
    /// The database engine to use for the new instance. This setting doesn't apply to RDS Custom. Default: The same as source Constraint: Must be compatible with the engine of the source. For example, you can restore a MariaDB 10.1 DB instance from a MySQL 5.6 snapshot. Valid Values:
    ///
    /// * mariadb
    ///
    /// * mysql
    ///
    /// * oracle-ee
    ///
    /// * oracle-ee-cdb
    ///
    /// * oracle-se2
    ///
    /// * oracle-se2-cdb
    ///
    /// * postgres
    ///
    /// * sqlserver-ee
    ///
    /// * sqlserver-se
    ///
    /// * sqlserver-ex
    ///
    /// * sqlserver-web
    public var engine: Swift.String?
    /// Specifies the amount of provisioned IOPS for the DB instance, expressed in I/O operations per second. If this parameter isn't specified, the IOPS value is taken from the backup. If this parameter is set to 0, the new instance is converted to a non-PIOPS instance. The conversion takes additional time, though your DB instance is available for connections before the conversion starts. The provisioned IOPS value must follow the requirements for your database engine. For more information, see [Amazon RDS Provisioned IOPS Storage to Improve Performance](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#USER_PIOPS) in the Amazon RDS User Guide. Constraints: Must be an integer greater than 1000.
    public var iops: Swift.Int?
    /// License model information for the restored DB instance. This setting doesn't apply to RDS Custom. Default: Same as source. Valid values: license-included | bring-your-own-license | general-public-license
    public var licenseModel: Swift.String?
    /// A value that indicates whether the DB instance is a Multi-AZ deployment. This setting doesn't apply to RDS Custom. Constraint: You can't specify the AvailabilityZone parameter if the DB instance is a Multi-AZ deployment.
    public var multiAZ: Swift.Bool?
    /// The name of the option group to be used for the restored DB instance. Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option group, and that option group can't be removed from a DB instance after it is associated with a DB instance. This setting doesn't apply to RDS Custom.
    public var optionGroupName: Swift.String?
    /// The port number on which the database accepts connections. Default: The same port as the original DB instance Constraints: Value must be 1150-65535
    public var port: Swift.Int?
    /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance. This setting doesn't apply to RDS Custom.
    public var processorFeatures: [RdsClientTypes.ProcessorFeature]?
    /// A value that indicates whether the DB instance is publicly accessible. When the DB instance is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB instance's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB instance's VPC. Access to the DB instance is ultimately controlled by the security group it uses. That public access is not permitted if the security group assigned to the DB instance doesn't permit it. When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address. For more information, see [CreateDBInstance].
    public var publiclyAccessible: Swift.Bool?
    /// Specifies the storage type to be associated with the DB instance. Valid values: standard | gp2 | io1 If you specify io1, you must also include a value for the Iops parameter. Default: io1 if the Iops parameter is specified, otherwise gp2
    public var storageType: Swift.String?
    /// A list of tags. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
    public var tags: [RdsClientTypes.Tag]?
    /// The ARN from the key store with which to associate the instance for TDE encryption. This setting doesn't apply to RDS Custom.
    public var tdeCredentialArn: Swift.String?
    /// The password for the given ARN from the key store in order to access the device. This setting doesn't apply to RDS Custom.
    public var tdeCredentialPassword: Swift.String?
    /// A value that indicates whether the DB instance class of the DB instance uses its default processor features. This setting doesn't apply to RDS Custom.
    public var useDefaultProcessorFeatures: Swift.Bool?
    /// A list of EC2 VPC security groups to associate with this DB instance. Default: The default EC2 VPC security group for the DB subnet group's VPC.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        availabilityZone: Swift.String? = nil,
        backupTarget: Swift.String? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        customIamInstanceProfile: Swift.String? = nil,
        dBInstanceClass: Swift.String? = nil,
        dBInstanceIdentifier: Swift.String? = nil,
        dBName: Swift.String? = nil,
        dBParameterGroupName: Swift.String? = nil,
        dBSnapshotIdentifier: Swift.String? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        domainIAMRoleName: Swift.String? = nil,
        enableCloudwatchLogsExports: [Swift.String]? = nil,
        enableCustomerOwnedIp: Swift.Bool? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        engine: Swift.String? = nil,
        iops: Swift.Int? = nil,
        licenseModel: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil,
        optionGroupName: Swift.String? = nil,
        port: Swift.Int? = nil,
        processorFeatures: [RdsClientTypes.ProcessorFeature]? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        storageType: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        tdeCredentialArn: Swift.String? = nil,
        tdeCredentialPassword: Swift.String? = nil,
        useDefaultProcessorFeatures: Swift.Bool? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.backupTarget = backupTarget
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.customIamInstanceProfile = customIamInstanceProfile
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBName = dBName
        self.dBParameterGroupName = dBParameterGroupName
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableCustomerOwnedIp = enableCustomerOwnedIp
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engine = engine
        self.iops = iops
        self.licenseModel = licenseModel
        self.multiAZ = multiAZ
        self.optionGroupName = optionGroupName
        self.port = port
        self.processorFeatures = processorFeatures
        self.publiclyAccessible = publiclyAccessible
        self.storageType = storageType
        self.tags = tags
        self.tdeCredentialArn = tdeCredentialArn
        self.tdeCredentialPassword = tdeCredentialPassword
        self.useDefaultProcessorFeatures = useDefaultProcessorFeatures
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct RestoreDBInstanceFromDBSnapshotInputBody: Swift.Equatable {
    let dBInstanceIdentifier: Swift.String?
    let dBSnapshotIdentifier: Swift.String?
    let dBInstanceClass: Swift.String?
    let port: Swift.Int?
    let availabilityZone: Swift.String?
    let dBSubnetGroupName: Swift.String?
    let multiAZ: Swift.Bool?
    let publiclyAccessible: Swift.Bool?
    let autoMinorVersionUpgrade: Swift.Bool?
    let licenseModel: Swift.String?
    let dBName: Swift.String?
    let engine: Swift.String?
    let iops: Swift.Int?
    let optionGroupName: Swift.String?
    let tags: [RdsClientTypes.Tag]?
    let storageType: Swift.String?
    let tdeCredentialArn: Swift.String?
    let tdeCredentialPassword: Swift.String?
    let vpcSecurityGroupIds: [Swift.String]?
    let domain: Swift.String?
    let copyTagsToSnapshot: Swift.Bool?
    let domainIAMRoleName: Swift.String?
    let enableIAMDatabaseAuthentication: Swift.Bool?
    let enableCloudwatchLogsExports: [Swift.String]?
    let processorFeatures: [RdsClientTypes.ProcessorFeature]?
    let useDefaultProcessorFeatures: Swift.Bool?
    let dBParameterGroupName: Swift.String?
    let deletionProtection: Swift.Bool?
    let enableCustomerOwnedIp: Swift.Bool?
    let customIamInstanceProfile: Swift.String?
    let backupTarget: Swift.String?
}

extension RestoreDBInstanceFromDBSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityZone = "AvailabilityZone"
        case backupTarget = "BackupTarget"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case customIamInstanceProfile = "CustomIamInstanceProfile"
        case dBInstanceClass = "DBInstanceClass"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dBName = "DBName"
        case dBParameterGroupName = "DBParameterGroupName"
        case dBSnapshotIdentifier = "DBSnapshotIdentifier"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case deletionProtection = "DeletionProtection"
        case domain = "Domain"
        case domainIAMRoleName = "DomainIAMRoleName"
        case enableCloudwatchLogsExports = "EnableCloudwatchLogsExports"
        case enableCustomerOwnedIp = "EnableCustomerOwnedIp"
        case enableIAMDatabaseAuthentication = "EnableIAMDatabaseAuthentication"
        case engine = "Engine"
        case iops = "Iops"
        case licenseModel = "LicenseModel"
        case multiAZ = "MultiAZ"
        case optionGroupName = "OptionGroupName"
        case port = "Port"
        case processorFeatures = "ProcessorFeatures"
        case publiclyAccessible = "PubliclyAccessible"
        case storageType = "StorageType"
        case tags = "Tags"
        case tdeCredentialArn = "TdeCredentialArn"
        case tdeCredentialPassword = "TdeCredentialPassword"
        case useDefaultProcessorFeatures = "UseDefaultProcessorFeatures"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let dBSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSnapshotIdentifier)
        dBSnapshotIdentifier = dBSnapshotIdentifierDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let dBNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBName)
        dBName = dBNameDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let tdeCredentialArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tdeCredentialArn)
        tdeCredentialArn = tdeCredentialArnDecoded
        let tdeCredentialPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tdeCredentialPassword)
        tdeCredentialPassword = tdeCredentialPasswordDecoded
        if containerValues.contains(.vpcSecurityGroupIds) {
            struct KeyVal0{struct VpcSecurityGroupId{}}
            let vpcSecurityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupId>.CodingKeys.self, forKey: .vpcSecurityGroupIds)
            if let vpcSecurityGroupIdsWrappedContainer = vpcSecurityGroupIdsWrappedContainer {
                let vpcSecurityGroupIdsContainer = try vpcSecurityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSecurityGroupIdsBuffer:[Swift.String]? = nil
                if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
                    vpcSecurityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSecurityGroupIdsContainer {
                        vpcSecurityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupIds = vpcSecurityGroupIdsBuffer
            } else {
                vpcSecurityGroupIds = []
            }
        } else {
            vpcSecurityGroupIds = nil
        }
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let copyTagsToSnapshotDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let domainIAMRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainIAMRoleName)
        domainIAMRoleName = domainIAMRoleNameDecoded
        let enableIAMDatabaseAuthenticationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableIAMDatabaseAuthentication)
        enableIAMDatabaseAuthentication = enableIAMDatabaseAuthenticationDecoded
        if containerValues.contains(.enableCloudwatchLogsExports) {
            struct KeyVal0{struct member{}}
            let enableCloudwatchLogsExportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enableCloudwatchLogsExports)
            if let enableCloudwatchLogsExportsWrappedContainer = enableCloudwatchLogsExportsWrappedContainer {
                let enableCloudwatchLogsExportsContainer = try enableCloudwatchLogsExportsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var enableCloudwatchLogsExportsBuffer:[Swift.String]? = nil
                if let enableCloudwatchLogsExportsContainer = enableCloudwatchLogsExportsContainer {
                    enableCloudwatchLogsExportsBuffer = [Swift.String]()
                    for stringContainer0 in enableCloudwatchLogsExportsContainer {
                        enableCloudwatchLogsExportsBuffer?.append(stringContainer0)
                    }
                }
                enableCloudwatchLogsExports = enableCloudwatchLogsExportsBuffer
            } else {
                enableCloudwatchLogsExports = []
            }
        } else {
            enableCloudwatchLogsExports = nil
        }
        if containerValues.contains(.processorFeatures) {
            struct KeyVal0{struct ProcessorFeature{}}
            let processorFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ProcessorFeature>.CodingKeys.self, forKey: .processorFeatures)
            if let processorFeaturesWrappedContainer = processorFeaturesWrappedContainer {
                let processorFeaturesContainer = try processorFeaturesWrappedContainer.decodeIfPresent([RdsClientTypes.ProcessorFeature].self, forKey: .member)
                var processorFeaturesBuffer:[RdsClientTypes.ProcessorFeature]? = nil
                if let processorFeaturesContainer = processorFeaturesContainer {
                    processorFeaturesBuffer = [RdsClientTypes.ProcessorFeature]()
                    for structureContainer0 in processorFeaturesContainer {
                        processorFeaturesBuffer?.append(structureContainer0)
                    }
                }
                processorFeatures = processorFeaturesBuffer
            } else {
                processorFeatures = []
            }
        } else {
            processorFeatures = nil
        }
        let useDefaultProcessorFeaturesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaultProcessorFeatures)
        useDefaultProcessorFeatures = useDefaultProcessorFeaturesDecoded
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let enableCustomerOwnedIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableCustomerOwnedIp)
        enableCustomerOwnedIp = enableCustomerOwnedIpDecoded
        let customIamInstanceProfileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customIamInstanceProfile)
        customIamInstanceProfile = customIamInstanceProfileDecoded
        let backupTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupTarget)
        backupTarget = backupTargetDecoded
    }
}

extension RestoreDBInstanceFromDBSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreDBInstanceFromDBSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFound" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BackupPolicyNotFoundFault" : self = .backupPolicyNotFoundFault(try BackupPolicyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceAlreadyExists" : self = .dBInstanceAlreadyExistsFault(try DBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFound" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceQuotaExceeded" : self = .instanceQuotaExceededFault(try InstanceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacity" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSnapshotState" : self = .invalidDBSnapshotStateFault(try InvalidDBSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRestoreFault" : self = .invalidRestoreFault(try InvalidRestoreFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedIopsNotAvailableInAZFault" : self = .provisionedIopsNotAvailableInAZFault(try ProvisionedIopsNotAvailableInAZFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceeded" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupported" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDBInstanceFromDBSnapshotOutputError: Swift.Error, Swift.Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case backupPolicyNotFoundFault(BackupPolicyNotFoundFault)
    case dBInstanceAlreadyExistsFault(DBInstanceAlreadyExistsFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case instanceQuotaExceededFault(InstanceQuotaExceededFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidDBSnapshotStateFault(InvalidDBSnapshotStateFault)
    case invalidRestoreFault(InvalidRestoreFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case provisionedIopsNotAvailableInAZFault(ProvisionedIopsNotAvailableInAZFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDBInstanceFromDBSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestoreDBInstanceFromDBSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct RestoreDBInstanceFromDBSnapshotOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB instance. This data type is used as a response element in the operations CreateDBInstance, CreateDBInstanceReadReplica, DeleteDBInstance, DescribeDBInstances, ModifyDBInstance, PromoteReadReplica, RebootDBInstance, RestoreDBInstanceFromDBSnapshot, RestoreDBInstanceFromS3, RestoreDBInstanceToPointInTime, StartDBInstance, and StopDBInstance.
    public var dBInstance: RdsClientTypes.DBInstance?

    public init (
        dBInstance: RdsClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct RestoreDBInstanceFromDBSnapshotOutputResponseBody: Swift.Equatable {
    let dBInstance: RdsClientTypes.DBInstance?
}

extension RestoreDBInstanceFromDBSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RestoreDBInstanceFromDBSnapshotResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

extension RestoreDBInstanceFromS3Input: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: ClientRuntime.Key("AutoMinorVersionUpgrade"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: ClientRuntime.Key("DBName"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let dBSecurityGroups = dBSecurityGroups {
            var dBSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBSecurityGroups"))
            for (index0, string0) in dBSecurityGroups.enumerated() {
                try dBSecurityGroupsContainer.encode(string0, forKey: ClientRuntime.Key("DBSecurityGroupName.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let enablePerformanceInsights = enablePerformanceInsights {
            try container.encode(enablePerformanceInsights, forKey: ClientRuntime.Key("EnablePerformanceInsights"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let maxAllocatedStorage = maxAllocatedStorage {
            try container.encode(maxAllocatedStorage, forKey: ClientRuntime.Key("MaxAllocatedStorage"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: ClientRuntime.Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: ClientRuntime.Key("MonitoringRoleArn"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: ClientRuntime.Key("PerformanceInsightsKMSKeyId"))
        }
        if let performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod {
            try container.encode(performanceInsightsRetentionPeriod, forKey: ClientRuntime.Key("PerformanceInsightsRetentionPeriod"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: ClientRuntime.Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let s3BucketName = s3BucketName {
            try container.encode(s3BucketName, forKey: ClientRuntime.Key("S3BucketName"))
        }
        if let s3IngestionRoleArn = s3IngestionRoleArn {
            try container.encode(s3IngestionRoleArn, forKey: ClientRuntime.Key("S3IngestionRoleArn"))
        }
        if let s3Prefix = s3Prefix {
            try container.encode(s3Prefix, forKey: ClientRuntime.Key("S3Prefix"))
        }
        if let sourceEngine = sourceEngine {
            try container.encode(sourceEngine, forKey: ClientRuntime.Key("SourceEngine"))
        }
        if let sourceEngineVersion = sourceEngineVersion {
            try container.encode(sourceEngineVersion, forKey: ClientRuntime.Key("SourceEngineVersion"))
        }
        if let storageEncrypted = storageEncrypted {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let useDefaultProcessorFeatures = useDefaultProcessorFeatures {
            try container.encode(useDefaultProcessorFeatures, forKey: ClientRuntime.Key("UseDefaultProcessorFeatures"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreDBInstanceFromS3", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension RestoreDBInstanceFromS3Input: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RestoreDBInstanceFromS3Input: Swift.Equatable {
    /// The amount of storage (in gigabytes) to allocate initially for the DB instance. Follow the allocation rules specified in CreateDBInstance. Be sure to allocate enough memory for your new DB instance so that the restore operation can succeed. You can also allocate additional memory for future growth.
    public var allocatedStorage: Swift.Int?
    /// A value that indicates whether minor engine upgrades are applied automatically to the DB instance during the maintenance window. By default, minor engine upgrades are not applied automatically.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The Availability Zone that the DB instance is created in. For information about Amazon Web Services Regions and Availability Zones, see [Regions and Availability Zones](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html) in the Amazon RDS User Guide. Default: A random, system-chosen Availability Zone in the endpoint's Amazon Web Services Region. Example: us-east-1d Constraint: The AvailabilityZone parameter can't be specified if the DB instance is a Multi-AZ deployment. The specified Availability Zone must be in the same Amazon Web Services Region as the current endpoint.
    public var availabilityZone: Swift.String?
    /// The number of days for which automated backups are retained. Setting this parameter to a positive number enables backups. For more information, see CreateDBInstance.
    public var backupRetentionPeriod: Swift.Int?
    /// A value that indicates whether to copy all tags from the DB instance to snapshots of the DB instance. By default, tags are not copied.
    public var copyTagsToSnapshot: Swift.Bool?
    /// The compute and memory capacity of the DB instance, for example db.m4.large. Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines. For the full list of DB instance classes, and availability for your engine, see [DB Instance Class](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html) in the Amazon RDS User Guide. Importing from Amazon S3 isn't supported on the db.t2.micro DB instance class.
    /// This member is required.
    public var dBInstanceClass: Swift.String?
    /// The DB instance identifier. This parameter is stored as a lowercase string. Constraints:
    ///
    /// * Must contain from 1 to 63 letters, numbers, or hyphens.
    ///
    /// * First character must be a letter.
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    /// Example: mydbinstance
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// The name of the database to create when the DB instance is created. Follow the naming rules specified in CreateDBInstance.
    public var dBName: Swift.String?
    /// The name of the DB parameter group to associate with this DB instance. If you do not specify a value for DBParameterGroupName, then the default DBParameterGroup for the specified DB engine is used.
    public var dBParameterGroupName: Swift.String?
    /// A list of DB security groups to associate with this DB instance. Default: The default DB security group for the database engine.
    public var dBSecurityGroups: [Swift.String]?
    /// A DB subnet group to associate with this DB instance.
    public var dBSubnetGroupName: Swift.String?
    /// A value that indicates whether the DB instance has deletion protection enabled. The database can't be deleted when deletion protection is enabled. By default, deletion protection isn't enabled. For more information, see [ Deleting a DB Instance](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html).
    public var deletionProtection: Swift.Bool?
    /// The list of logs that the restored DB instance is to export to CloudWatch Logs. The values in the list depend on the DB engine being used. For more information, see [Publishing Database Logs to Amazon CloudWatch Logs](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch) in the Amazon RDS User Guide.
    public var enableCloudwatchLogsExports: [Swift.String]?
    /// A value that indicates whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping isn't enabled. For more information about IAM database authentication, see [ IAM Database Authentication for MySQL and PostgreSQL](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html) in the Amazon RDS User Guide.
    public var enableIAMDatabaseAuthentication: Swift.Bool?
    /// A value that indicates whether to enable Performance Insights for the DB instance. For more information, see [Using Amazon Performance Insights](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html) in the Amazon Relational Database Service User Guide.
    public var enablePerformanceInsights: Swift.Bool?
    /// The name of the database engine to be used for this instance. Valid Values: mysql
    /// This member is required.
    public var engine: Swift.String?
    /// The version number of the database engine to use. Choose the latest minor version of your database engine. For information about engine versions, see CreateDBInstance, or call DescribeDBEngineVersions.
    public var engineVersion: Swift.String?
    /// The amount of Provisioned IOPS (input/output operations per second) to allocate initially for the DB instance. For information about valid Iops values, see [Amazon RDS Provisioned IOPS Storage to Improve Performance](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#USER_PIOPS) in the Amazon RDS User Guide.
    public var iops: Swift.Int?
    /// The Amazon Web Services KMS key identifier for an encrypted DB instance. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN. If the StorageEncrypted parameter is enabled, and you do not specify a value for the KmsKeyId parameter, then Amazon RDS will use your default KMS key. There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region.
    public var kmsKeyId: Swift.String?
    /// The license model for this DB instance. Use general-public-license.
    public var licenseModel: Swift.String?
    /// The password for the master user. The password can include any printable ASCII character except "/", """, or "@". Constraints: Must contain from 8 to 41 characters.
    public var masterUserPassword: Swift.String?
    /// The name for the master user. Constraints:
    ///
    /// * Must be 1 to 16 letters or numbers.
    ///
    /// * First character must be a letter.
    ///
    /// * Can't be a reserved word for the chosen database engine.
    public var masterUsername: Swift.String?
    /// The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance. For more information about this setting, including limitations that apply to it, see [ Managing capacity automatically with Amazon RDS storage autoscaling](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling) in the Amazon RDS User Guide.
    public var maxAllocatedStorage: Swift.Int?
    /// The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance. To disable collecting Enhanced Monitoring metrics, specify 0. If MonitoringRoleArn is specified, then you must also set MonitoringInterval to a value other than 0. Valid Values: 0, 1, 5, 10, 15, 30, 60 Default: 0
    public var monitoringInterval: Swift.Int?
    /// The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs. For example, arn:aws:iam:123456789012:role/emaccess. For information on creating a monitoring role, see [Setting Up and Enabling Enhanced Monitoring](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.OS.html#USER_Monitoring.OS.Enabling) in the Amazon RDS User Guide. If MonitoringInterval is set to a value other than 0, then you must supply a MonitoringRoleArn value.
    public var monitoringRoleArn: Swift.String?
    /// A value that indicates whether the DB instance is a Multi-AZ deployment. If the DB instance is a Multi-AZ deployment, you can't set the AvailabilityZone parameter.
    public var multiAZ: Swift.Bool?
    /// The name of the option group to associate with this DB instance. If this argument is omitted, the default option group for the specified engine is used.
    public var optionGroupName: Swift.String?
    /// The Amazon Web Services KMS key identifier for encryption of Performance Insights data. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. If you do not specify a value for PerformanceInsightsKMSKeyId, then Amazon RDS uses your default KMS key. There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region.
    public var performanceInsightsKMSKeyId: Swift.String?
    /// The amount of time, in days, to retain Performance Insights data. Valid values are 7 or 731 (2 years).
    public var performanceInsightsRetentionPeriod: Swift.Int?
    /// The port number on which the database accepts connections. Type: Integer Valid Values: 1150-65535 Default: 3306
    public var port: Swift.Int?
    /// The time range each day during which automated backups are created if automated backups are enabled. For more information, see [Backup window](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow) in the Amazon RDS User Guide. Constraints:
    ///
    /// * Must be in the format hh24:mi-hh24:mi.
    ///
    /// * Must be in Universal Coordinated Time (UTC).
    ///
    /// * Must not conflict with the preferred maintenance window.
    ///
    /// * Must be at least 30 minutes.
    public var preferredBackupWindow: Swift.String?
    /// The time range each week during which system maintenance can occur, in Universal Coordinated Time (UTC). For more information, see [Amazon RDS Maintenance Window](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance) in the Amazon RDS User Guide. Constraints:
    ///
    /// * Must be in the format ddd:hh24:mi-ddd:hh24:mi.
    ///
    /// * Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.
    ///
    /// * Must be in Universal Coordinated Time (UTC).
    ///
    /// * Must not conflict with the preferred backup window.
    ///
    /// * Must be at least 30 minutes.
    public var preferredMaintenanceWindow: Swift.String?
    /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.
    public var processorFeatures: [RdsClientTypes.ProcessorFeature]?
    /// A value that indicates whether the DB instance is publicly accessible. When the DB instance is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB instance's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB instance's VPC. Access to the DB instance is ultimately controlled by the security group it uses. That public access is not permitted if the security group assigned to the DB instance doesn't permit it. When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address. For more information, see [CreateDBInstance].
    public var publiclyAccessible: Swift.Bool?
    /// The name of your Amazon S3 bucket that contains your database backup file.
    /// This member is required.
    public var s3BucketName: Swift.String?
    /// An Amazon Web Services Identity and Access Management (IAM) role to allow Amazon RDS to access your Amazon S3 bucket.
    /// This member is required.
    public var s3IngestionRoleArn: Swift.String?
    /// The prefix of your Amazon S3 bucket.
    public var s3Prefix: Swift.String?
    /// The name of the engine of your source database. Valid Values: mysql
    /// This member is required.
    public var sourceEngine: Swift.String?
    /// The version of the database that the backup files were created from. MySQL versions 5.6 and 5.7 are supported. Example: 5.6.40
    /// This member is required.
    public var sourceEngineVersion: Swift.String?
    /// A value that indicates whether the new DB instance is encrypted or not.
    public var storageEncrypted: Swift.Bool?
    /// Specifies the storage type to be associated with the DB instance. Valid values: standard | gp2 | io1 If you specify io1, you must also include a value for the Iops parameter. Default: io1 if the Iops parameter is specified; otherwise gp2
    public var storageType: Swift.String?
    /// A list of tags to associate with this DB instance. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
    public var tags: [RdsClientTypes.Tag]?
    /// A value that indicates whether the DB instance class of the DB instance uses its default processor features.
    public var useDefaultProcessorFeatures: Swift.Bool?
    /// A list of VPC security groups to associate with this DB instance.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        allocatedStorage: Swift.Int? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        availabilityZone: Swift.String? = nil,
        backupRetentionPeriod: Swift.Int? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        dBInstanceClass: Swift.String? = nil,
        dBInstanceIdentifier: Swift.String? = nil,
        dBName: Swift.String? = nil,
        dBParameterGroupName: Swift.String? = nil,
        dBSecurityGroups: [Swift.String]? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        enableCloudwatchLogsExports: [Swift.String]? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        enablePerformanceInsights: Swift.Bool? = nil,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        iops: Swift.Int? = nil,
        kmsKeyId: Swift.String? = nil,
        licenseModel: Swift.String? = nil,
        masterUserPassword: Swift.String? = nil,
        masterUsername: Swift.String? = nil,
        maxAllocatedStorage: Swift.Int? = nil,
        monitoringInterval: Swift.Int? = nil,
        monitoringRoleArn: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil,
        optionGroupName: Swift.String? = nil,
        performanceInsightsKMSKeyId: Swift.String? = nil,
        performanceInsightsRetentionPeriod: Swift.Int? = nil,
        port: Swift.Int? = nil,
        preferredBackupWindow: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        processorFeatures: [RdsClientTypes.ProcessorFeature]? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        s3BucketName: Swift.String? = nil,
        s3IngestionRoleArn: Swift.String? = nil,
        s3Prefix: Swift.String? = nil,
        sourceEngine: Swift.String? = nil,
        sourceEngineVersion: Swift.String? = nil,
        storageEncrypted: Swift.Bool? = nil,
        storageType: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        useDefaultProcessorFeatures: Swift.Bool? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.backupRetentionPeriod = backupRetentionPeriod
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBName = dBName
        self.dBParameterGroupName = dBParameterGroupName
        self.dBSecurityGroups = dBSecurityGroups
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.enablePerformanceInsights = enablePerformanceInsights
        self.engine = engine
        self.engineVersion = engineVersion
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.licenseModel = licenseModel
        self.masterUserPassword = masterUserPassword
        self.masterUsername = masterUsername
        self.maxAllocatedStorage = maxAllocatedStorage
        self.monitoringInterval = monitoringInterval
        self.monitoringRoleArn = monitoringRoleArn
        self.multiAZ = multiAZ
        self.optionGroupName = optionGroupName
        self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
        self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
        self.port = port
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.processorFeatures = processorFeatures
        self.publiclyAccessible = publiclyAccessible
        self.s3BucketName = s3BucketName
        self.s3IngestionRoleArn = s3IngestionRoleArn
        self.s3Prefix = s3Prefix
        self.sourceEngine = sourceEngine
        self.sourceEngineVersion = sourceEngineVersion
        self.storageEncrypted = storageEncrypted
        self.storageType = storageType
        self.tags = tags
        self.useDefaultProcessorFeatures = useDefaultProcessorFeatures
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct RestoreDBInstanceFromS3InputBody: Swift.Equatable {
    let dBName: Swift.String?
    let dBInstanceIdentifier: Swift.String?
    let allocatedStorage: Swift.Int?
    let dBInstanceClass: Swift.String?
    let engine: Swift.String?
    let masterUsername: Swift.String?
    let masterUserPassword: Swift.String?
    let dBSecurityGroups: [Swift.String]?
    let vpcSecurityGroupIds: [Swift.String]?
    let availabilityZone: Swift.String?
    let dBSubnetGroupName: Swift.String?
    let preferredMaintenanceWindow: Swift.String?
    let dBParameterGroupName: Swift.String?
    let backupRetentionPeriod: Swift.Int?
    let preferredBackupWindow: Swift.String?
    let port: Swift.Int?
    let multiAZ: Swift.Bool?
    let engineVersion: Swift.String?
    let autoMinorVersionUpgrade: Swift.Bool?
    let licenseModel: Swift.String?
    let iops: Swift.Int?
    let optionGroupName: Swift.String?
    let publiclyAccessible: Swift.Bool?
    let tags: [RdsClientTypes.Tag]?
    let storageType: Swift.String?
    let storageEncrypted: Swift.Bool?
    let kmsKeyId: Swift.String?
    let copyTagsToSnapshot: Swift.Bool?
    let monitoringInterval: Swift.Int?
    let monitoringRoleArn: Swift.String?
    let enableIAMDatabaseAuthentication: Swift.Bool?
    let sourceEngine: Swift.String?
    let sourceEngineVersion: Swift.String?
    let s3BucketName: Swift.String?
    let s3Prefix: Swift.String?
    let s3IngestionRoleArn: Swift.String?
    let enablePerformanceInsights: Swift.Bool?
    let performanceInsightsKMSKeyId: Swift.String?
    let performanceInsightsRetentionPeriod: Swift.Int?
    let enableCloudwatchLogsExports: [Swift.String]?
    let processorFeatures: [RdsClientTypes.ProcessorFeature]?
    let useDefaultProcessorFeatures: Swift.Bool?
    let deletionProtection: Swift.Bool?
    let maxAllocatedStorage: Swift.Int?
}

extension RestoreDBInstanceFromS3InputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityZone = "AvailabilityZone"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case dBInstanceClass = "DBInstanceClass"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dBName = "DBName"
        case dBParameterGroupName = "DBParameterGroupName"
        case dBSecurityGroups = "DBSecurityGroups"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case deletionProtection = "DeletionProtection"
        case enableCloudwatchLogsExports = "EnableCloudwatchLogsExports"
        case enableIAMDatabaseAuthentication = "EnableIAMDatabaseAuthentication"
        case enablePerformanceInsights = "EnablePerformanceInsights"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case licenseModel = "LicenseModel"
        case masterUserPassword = "MasterUserPassword"
        case masterUsername = "MasterUsername"
        case maxAllocatedStorage = "MaxAllocatedStorage"
        case monitoringInterval = "MonitoringInterval"
        case monitoringRoleArn = "MonitoringRoleArn"
        case multiAZ = "MultiAZ"
        case optionGroupName = "OptionGroupName"
        case performanceInsightsKMSKeyId = "PerformanceInsightsKMSKeyId"
        case performanceInsightsRetentionPeriod = "PerformanceInsightsRetentionPeriod"
        case port = "Port"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case processorFeatures = "ProcessorFeatures"
        case publiclyAccessible = "PubliclyAccessible"
        case s3BucketName = "S3BucketName"
        case s3IngestionRoleArn = "S3IngestionRoleArn"
        case s3Prefix = "S3Prefix"
        case sourceEngine = "SourceEngine"
        case sourceEngineVersion = "SourceEngineVersion"
        case storageEncrypted = "StorageEncrypted"
        case storageType = "StorageType"
        case tags = "Tags"
        case useDefaultProcessorFeatures = "UseDefaultProcessorFeatures"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBName)
        dBName = dBNameDecoded
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let masterUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUserPassword)
        masterUserPassword = masterUserPasswordDecoded
        if containerValues.contains(.dBSecurityGroups) {
            struct KeyVal0{struct DBSecurityGroupName{}}
            let dBSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSecurityGroupName>.CodingKeys.self, forKey: .dBSecurityGroups)
            if let dBSecurityGroupsWrappedContainer = dBSecurityGroupsWrappedContainer {
                let dBSecurityGroupsContainer = try dBSecurityGroupsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var dBSecurityGroupsBuffer:[Swift.String]? = nil
                if let dBSecurityGroupsContainer = dBSecurityGroupsContainer {
                    dBSecurityGroupsBuffer = [Swift.String]()
                    for stringContainer0 in dBSecurityGroupsContainer {
                        dBSecurityGroupsBuffer?.append(stringContainer0)
                    }
                }
                dBSecurityGroups = dBSecurityGroupsBuffer
            } else {
                dBSecurityGroups = []
            }
        } else {
            dBSecurityGroups = nil
        }
        if containerValues.contains(.vpcSecurityGroupIds) {
            struct KeyVal0{struct VpcSecurityGroupId{}}
            let vpcSecurityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupId>.CodingKeys.self, forKey: .vpcSecurityGroupIds)
            if let vpcSecurityGroupIdsWrappedContainer = vpcSecurityGroupIdsWrappedContainer {
                let vpcSecurityGroupIdsContainer = try vpcSecurityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSecurityGroupIdsBuffer:[Swift.String]? = nil
                if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
                    vpcSecurityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSecurityGroupIdsContainer {
                        vpcSecurityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupIds = vpcSecurityGroupIdsBuffer
            } else {
                vpcSecurityGroupIds = []
            }
        } else {
            vpcSecurityGroupIds = nil
        }
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let storageEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let copyTagsToSnapshotDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let monitoringIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monitoringInterval)
        monitoringInterval = monitoringIntervalDecoded
        let monitoringRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitoringRoleArn)
        monitoringRoleArn = monitoringRoleArnDecoded
        let enableIAMDatabaseAuthenticationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableIAMDatabaseAuthentication)
        enableIAMDatabaseAuthentication = enableIAMDatabaseAuthenticationDecoded
        let sourceEngineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEngine)
        sourceEngine = sourceEngineDecoded
        let sourceEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEngineVersion)
        sourceEngineVersion = sourceEngineVersionDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
        let s3IngestionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3IngestionRoleArn)
        s3IngestionRoleArn = s3IngestionRoleArnDecoded
        let enablePerformanceInsightsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enablePerformanceInsights)
        enablePerformanceInsights = enablePerformanceInsightsDecoded
        let performanceInsightsKMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .performanceInsightsKMSKeyId)
        performanceInsightsKMSKeyId = performanceInsightsKMSKeyIdDecoded
        let performanceInsightsRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .performanceInsightsRetentionPeriod)
        performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriodDecoded
        if containerValues.contains(.enableCloudwatchLogsExports) {
            struct KeyVal0{struct member{}}
            let enableCloudwatchLogsExportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enableCloudwatchLogsExports)
            if let enableCloudwatchLogsExportsWrappedContainer = enableCloudwatchLogsExportsWrappedContainer {
                let enableCloudwatchLogsExportsContainer = try enableCloudwatchLogsExportsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var enableCloudwatchLogsExportsBuffer:[Swift.String]? = nil
                if let enableCloudwatchLogsExportsContainer = enableCloudwatchLogsExportsContainer {
                    enableCloudwatchLogsExportsBuffer = [Swift.String]()
                    for stringContainer0 in enableCloudwatchLogsExportsContainer {
                        enableCloudwatchLogsExportsBuffer?.append(stringContainer0)
                    }
                }
                enableCloudwatchLogsExports = enableCloudwatchLogsExportsBuffer
            } else {
                enableCloudwatchLogsExports = []
            }
        } else {
            enableCloudwatchLogsExports = nil
        }
        if containerValues.contains(.processorFeatures) {
            struct KeyVal0{struct ProcessorFeature{}}
            let processorFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ProcessorFeature>.CodingKeys.self, forKey: .processorFeatures)
            if let processorFeaturesWrappedContainer = processorFeaturesWrappedContainer {
                let processorFeaturesContainer = try processorFeaturesWrappedContainer.decodeIfPresent([RdsClientTypes.ProcessorFeature].self, forKey: .member)
                var processorFeaturesBuffer:[RdsClientTypes.ProcessorFeature]? = nil
                if let processorFeaturesContainer = processorFeaturesContainer {
                    processorFeaturesBuffer = [RdsClientTypes.ProcessorFeature]()
                    for structureContainer0 in processorFeaturesContainer {
                        processorFeaturesBuffer?.append(structureContainer0)
                    }
                }
                processorFeatures = processorFeaturesBuffer
            } else {
                processorFeatures = []
            }
        } else {
            processorFeatures = nil
        }
        let useDefaultProcessorFeaturesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaultProcessorFeatures)
        useDefaultProcessorFeatures = useDefaultProcessorFeaturesDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let maxAllocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAllocatedStorage)
        maxAllocatedStorage = maxAllocatedStorageDecoded
    }
}

extension RestoreDBInstanceFromS3OutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreDBInstanceFromS3OutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFound" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BackupPolicyNotFoundFault" : self = .backupPolicyNotFoundFault(try BackupPolicyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceAlreadyExists" : self = .dBInstanceAlreadyExistsFault(try DBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFound" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceQuotaExceeded" : self = .instanceQuotaExceededFault(try InstanceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacity" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3BucketFault" : self = .invalidS3BucketFault(try InvalidS3BucketFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedIopsNotAvailableInAZFault" : self = .provisionedIopsNotAvailableInAZFault(try ProvisionedIopsNotAvailableInAZFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceeded" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupported" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDBInstanceFromS3OutputError: Swift.Error, Swift.Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case backupPolicyNotFoundFault(BackupPolicyNotFoundFault)
    case dBInstanceAlreadyExistsFault(DBInstanceAlreadyExistsFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case instanceQuotaExceededFault(InstanceQuotaExceededFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidS3BucketFault(InvalidS3BucketFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case provisionedIopsNotAvailableInAZFault(ProvisionedIopsNotAvailableInAZFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDBInstanceFromS3OutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestoreDBInstanceFromS3OutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct RestoreDBInstanceFromS3OutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB instance. This data type is used as a response element in the operations CreateDBInstance, CreateDBInstanceReadReplica, DeleteDBInstance, DescribeDBInstances, ModifyDBInstance, PromoteReadReplica, RebootDBInstance, RestoreDBInstanceFromDBSnapshot, RestoreDBInstanceFromS3, RestoreDBInstanceToPointInTime, StartDBInstance, and StopDBInstance.
    public var dBInstance: RdsClientTypes.DBInstance?

    public init (
        dBInstance: RdsClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct RestoreDBInstanceFromS3OutputResponseBody: Swift.Equatable {
    let dBInstance: RdsClientTypes.DBInstance?
}

extension RestoreDBInstanceFromS3OutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RestoreDBInstanceFromS3Result"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

extension RestoreDBInstanceToPointInTimeInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: ClientRuntime.Key("AutoMinorVersionUpgrade"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let backupTarget = backupTarget {
            try container.encode(backupTarget, forKey: ClientRuntime.Key("BackupTarget"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let customIamInstanceProfile = customIamInstanceProfile {
            try container.encode(customIamInstanceProfile, forKey: ClientRuntime.Key("CustomIamInstanceProfile"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: ClientRuntime.Key("DBName"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: ClientRuntime.Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableCustomerOwnedIp = enableCustomerOwnedIp {
            try container.encode(enableCustomerOwnedIp, forKey: ClientRuntime.Key("EnableCustomerOwnedIp"))
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let maxAllocatedStorage = maxAllocatedStorage {
            try container.encode(maxAllocatedStorage, forKey: ClientRuntime.Key("MaxAllocatedStorage"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: ClientRuntime.Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let restoreTime = restoreTime {
            try container.encode(ClientRuntime.TimestampWrapper(restoreTime, format: .dateTime), forKey: ClientRuntime.Key("restoreTime"))
        }
        if let sourceDBInstanceAutomatedBackupsArn = sourceDBInstanceAutomatedBackupsArn {
            try container.encode(sourceDBInstanceAutomatedBackupsArn, forKey: ClientRuntime.Key("SourceDBInstanceAutomatedBackupsArn"))
        }
        if let sourceDBInstanceIdentifier = sourceDBInstanceIdentifier {
            try container.encode(sourceDBInstanceIdentifier, forKey: ClientRuntime.Key("SourceDBInstanceIdentifier"))
        }
        if let sourceDbiResourceId = sourceDbiResourceId {
            try container.encode(sourceDbiResourceId, forKey: ClientRuntime.Key("SourceDbiResourceId"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetDBInstanceIdentifier = targetDBInstanceIdentifier {
            try container.encode(targetDBInstanceIdentifier, forKey: ClientRuntime.Key("TargetDBInstanceIdentifier"))
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: ClientRuntime.Key("TdeCredentialArn"))
        }
        if let tdeCredentialPassword = tdeCredentialPassword {
            try container.encode(tdeCredentialPassword, forKey: ClientRuntime.Key("TdeCredentialPassword"))
        }
        if let useDefaultProcessorFeatures = useDefaultProcessorFeatures {
            try container.encode(useDefaultProcessorFeatures, forKey: ClientRuntime.Key("UseDefaultProcessorFeatures"))
        }
        if useLatestRestorableTime != false {
            try container.encode(useLatestRestorableTime, forKey: ClientRuntime.Key("UseLatestRestorableTime"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreDBInstanceToPointInTime", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension RestoreDBInstanceToPointInTimeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct RestoreDBInstanceToPointInTimeInput: Swift.Equatable {
    /// A value that indicates whether minor version upgrades are applied automatically to the DB instance during the maintenance window. This setting doesn't apply to RDS Custom.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The Availability Zone (AZ) where the DB instance will be created. Default: A random, system-chosen Availability Zone. Constraint: You can't specify the AvailabilityZone parameter if the DB instance is a Multi-AZ deployment. Example: us-east-1a
    public var availabilityZone: Swift.String?
    /// Specifies where automated backups and manual snapshots are stored for the restored DB instance. Possible values are outposts (Amazon Web Services Outposts) and region (Amazon Web Services Region). The default is region. For more information, see [Working with Amazon RDS on Amazon Web Services Outposts](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html) in the Amazon RDS User Guide.
    public var backupTarget: Swift.String?
    /// A value that indicates whether to copy all tags from the restored DB instance to snapshots of the DB instance. By default, tags are not copied.
    public var copyTagsToSnapshot: Swift.Bool?
    /// The instance profile associated with the underlying Amazon EC2 instance of an RDS Custom DB instance. The instance profile must meet the following requirements:
    ///
    /// * The profile must exist in your account.
    ///
    /// * The profile must have an IAM role that Amazon EC2 has permissions to assume.
    ///
    /// * The instance profile name and the associated IAM role name must start with the prefix AWSRDSCustom.
    ///
    ///
    /// For the list of permissions required for the IAM role, see [ Configure IAM and your VPC](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/custom-setup-orcl.html#custom-setup-orcl.iam-vpc) in the Amazon Relational Database Service User Guide. This setting is required for RDS Custom.
    public var customIamInstanceProfile: Swift.String?
    /// The compute and memory capacity of the Amazon RDS DB instance, for example db.m4.large. Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines. For the full list of DB instance classes, and availability for your engine, see [DB Instance Class](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html) in the Amazon RDS User Guide. Default: The same DBInstanceClass as the original DB instance.
    public var dBInstanceClass: Swift.String?
    /// The database name for the restored DB instance. This parameter isn't supported for the MySQL or MariaDB engines. It also doesn't apply to RDS Custom.
    public var dBName: Swift.String?
    /// The name of the DB parameter group to associate with this DB instance. If you do not specify a value for DBParameterGroupName, then the default DBParameterGroup for the specified DB engine is used. This setting doesn't apply to RDS Custom. Constraints:
    ///
    /// * If supplied, must match the name of an existing DBParameterGroup.
    ///
    /// * Must be 1 to 255 letters, numbers, or hyphens.
    ///
    /// * First character must be a letter.
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens.
    public var dBParameterGroupName: Swift.String?
    /// The DB subnet group name to use for the new instance. Constraints: If supplied, must match the name of an existing DBSubnetGroup. Example: mySubnetgroup
    public var dBSubnetGroupName: Swift.String?
    /// A value that indicates whether the DB instance has deletion protection enabled. The database can't be deleted when deletion protection is enabled. By default, deletion protection isn't enabled. For more information, see [ Deleting a DB Instance](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html).
    public var deletionProtection: Swift.Bool?
    /// Specify the Active Directory directory ID to restore the DB instance in. Create the domain before running this command. Currently, you can create only the MySQL, Microsoft SQL Server, Oracle, and PostgreSQL DB instances in an Active Directory Domain. This setting doesn't apply to RDS Custom. For more information, see [ Kerberos Authentication](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html) in the Amazon RDS User Guide.
    public var domain: Swift.String?
    /// Specify the name of the IAM role to be used when making API calls to the Directory Service. This setting doesn't apply to RDS Custom.
    public var domainIAMRoleName: Swift.String?
    /// The list of logs that the restored DB instance is to export to CloudWatch Logs. The values in the list depend on the DB engine being used. For more information, see [Publishing Database Logs to Amazon CloudWatch Logs](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch) in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom.
    public var enableCloudwatchLogsExports: [Swift.String]?
    /// A value that indicates whether to enable a customer-owned IP address (CoIP) for an RDS on Outposts DB instance. A CoIP provides local or external connectivity to resources in your Outpost subnets through your on-premises network. For some use cases, a CoIP can provide lower latency for connections to the DB instance from outside of its virtual private cloud (VPC) on your local network. This setting doesn't apply to RDS Custom. For more information about RDS on Outposts, see [Working with Amazon RDS on Amazon Web Services Outposts](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html) in the Amazon RDS User Guide. For more information about CoIPs, see [Customer-owned IP addresses](https://docs.aws.amazon.com/outposts/latest/userguide/outposts-networking-components.html#ip-addressing) in the Amazon Web Services Outposts User Guide.
    public var enableCustomerOwnedIp: Swift.Bool?
    /// A value that indicates whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping isn't enabled. This setting doesn't apply to RDS Custom. For more information about IAM database authentication, see [ IAM Database Authentication for MySQL and PostgreSQL](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html) in the Amazon RDS User Guide.
    public var enableIAMDatabaseAuthentication: Swift.Bool?
    /// The database engine to use for the new instance. This setting doesn't apply to RDS Custom. Default: The same as source Constraint: Must be compatible with the engine of the source Valid Values:
    ///
    /// * mariadb
    ///
    /// * mysql
    ///
    /// * oracle-ee
    ///
    /// * oracle-ee-cdb
    ///
    /// * oracle-se2
    ///
    /// * oracle-se2-cdb
    ///
    /// * postgres
    ///
    /// * sqlserver-ee
    ///
    /// * sqlserver-se
    ///
    /// * sqlserver-ex
    ///
    /// * sqlserver-web
    public var engine: Swift.String?
    /// The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for the DB instance. Constraints: Must be an integer greater than 1000. SQL Server Setting the IOPS value for the SQL Server database engine isn't supported.
    public var iops: Swift.Int?
    /// License model information for the restored DB instance. This setting doesn't apply to RDS Custom. Default: Same as source. Valid values: license-included | bring-your-own-license | general-public-license
    public var licenseModel: Swift.String?
    /// The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance. For more information about this setting, including limitations that apply to it, see [ Managing capacity automatically with Amazon RDS storage autoscaling](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling) in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom.
    public var maxAllocatedStorage: Swift.Int?
    /// A value that indicates whether the DB instance is a Multi-AZ deployment. This setting doesn't apply to RDS Custom. Constraint: You can't specify the AvailabilityZone parameter if the DB instance is a Multi-AZ deployment.
    public var multiAZ: Swift.Bool?
    /// The name of the option group to be used for the restored DB instance. Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option group, and that option group can't be removed from a DB instance after it is associated with a DB instance This setting doesn't apply to RDS Custom.
    public var optionGroupName: Swift.String?
    /// The port number on which the database accepts connections. Constraints: Value must be 1150-65535 Default: The same port as the original DB instance.
    public var port: Swift.Int?
    /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance. This setting doesn't apply to RDS Custom.
    public var processorFeatures: [RdsClientTypes.ProcessorFeature]?
    /// A value that indicates whether the DB instance is publicly accessible. When the DB cluster is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB cluster's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB cluster's VPC. Access to the DB cluster is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB cluster doesn't permit it. When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address. For more information, see [CreateDBInstance].
    public var publiclyAccessible: Swift.Bool?
    /// The date and time to restore from. Valid Values: Value must be a time in Universal Coordinated Time (UTC) format Constraints:
    ///
    /// * Must be before the latest restorable time for the DB instance
    ///
    /// * Can't be specified if the UseLatestRestorableTime parameter is enabled
    ///
    ///
    /// Example: 2009-09-07T23:45:00Z
    public var restoreTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the replicated automated backups from which to restore, for example, arn:aws:rds:useast-1:123456789012:auto-backup:ab-L2IJCEXJP7XQ7HOJ4SIEXAMPLE. This setting doesn't apply to RDS Custom.
    public var sourceDBInstanceAutomatedBackupsArn: Swift.String?
    /// The identifier of the source DB instance from which to restore. Constraints:
    ///
    /// * Must match the identifier of an existing DB instance.
    public var sourceDBInstanceIdentifier: Swift.String?
    /// The resource ID of the source DB instance from which to restore.
    public var sourceDbiResourceId: Swift.String?
    /// Specifies the storage type to be associated with the DB instance. Valid values: standard | gp2 | io1 If you specify io1, you must also include a value for the Iops parameter. Default: io1 if the Iops parameter is specified, otherwise gp2
    public var storageType: Swift.String?
    /// A list of tags. For more information, see [Tagging Amazon RDS Resources](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html) in the Amazon RDS User Guide.
    public var tags: [RdsClientTypes.Tag]?
    /// The name of the new DB instance to be created. Constraints:
    ///
    /// * Must contain from 1 to 63 letters, numbers, or hyphens
    ///
    /// * First character must be a letter
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens
    /// This member is required.
    public var targetDBInstanceIdentifier: Swift.String?
    /// The ARN from the key store with which to associate the instance for TDE encryption. This setting doesn't apply to RDS Custom.
    public var tdeCredentialArn: Swift.String?
    /// The password for the given ARN from the key store in order to access the device. This setting doesn't apply to RDS Custom.
    public var tdeCredentialPassword: Swift.String?
    /// A value that indicates whether the DB instance class of the DB instance uses its default processor features. This setting doesn't apply to RDS Custom.
    public var useDefaultProcessorFeatures: Swift.Bool?
    /// A value that indicates whether the DB instance is restored from the latest backup time. By default, the DB instance isn't restored from the latest backup time. Constraints: Can't be specified if the RestoreTime parameter is provided.
    public var useLatestRestorableTime: Swift.Bool
    /// A list of EC2 VPC security groups to associate with this DB instance. Default: The default EC2 VPC security group for the DB subnet group's VPC.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        availabilityZone: Swift.String? = nil,
        backupTarget: Swift.String? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        customIamInstanceProfile: Swift.String? = nil,
        dBInstanceClass: Swift.String? = nil,
        dBName: Swift.String? = nil,
        dBParameterGroupName: Swift.String? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        domainIAMRoleName: Swift.String? = nil,
        enableCloudwatchLogsExports: [Swift.String]? = nil,
        enableCustomerOwnedIp: Swift.Bool? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        engine: Swift.String? = nil,
        iops: Swift.Int? = nil,
        licenseModel: Swift.String? = nil,
        maxAllocatedStorage: Swift.Int? = nil,
        multiAZ: Swift.Bool? = nil,
        optionGroupName: Swift.String? = nil,
        port: Swift.Int? = nil,
        processorFeatures: [RdsClientTypes.ProcessorFeature]? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        restoreTime: ClientRuntime.Date? = nil,
        sourceDBInstanceAutomatedBackupsArn: Swift.String? = nil,
        sourceDBInstanceIdentifier: Swift.String? = nil,
        sourceDbiResourceId: Swift.String? = nil,
        storageType: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        targetDBInstanceIdentifier: Swift.String? = nil,
        tdeCredentialArn: Swift.String? = nil,
        tdeCredentialPassword: Swift.String? = nil,
        useDefaultProcessorFeatures: Swift.Bool? = nil,
        useLatestRestorableTime: Swift.Bool = false,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.backupTarget = backupTarget
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.customIamInstanceProfile = customIamInstanceProfile
        self.dBInstanceClass = dBInstanceClass
        self.dBName = dBName
        self.dBParameterGroupName = dBParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableCustomerOwnedIp = enableCustomerOwnedIp
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engine = engine
        self.iops = iops
        self.licenseModel = licenseModel
        self.maxAllocatedStorage = maxAllocatedStorage
        self.multiAZ = multiAZ
        self.optionGroupName = optionGroupName
        self.port = port
        self.processorFeatures = processorFeatures
        self.publiclyAccessible = publiclyAccessible
        self.restoreTime = restoreTime
        self.sourceDBInstanceAutomatedBackupsArn = sourceDBInstanceAutomatedBackupsArn
        self.sourceDBInstanceIdentifier = sourceDBInstanceIdentifier
        self.sourceDbiResourceId = sourceDbiResourceId
        self.storageType = storageType
        self.tags = tags
        self.targetDBInstanceIdentifier = targetDBInstanceIdentifier
        self.tdeCredentialArn = tdeCredentialArn
        self.tdeCredentialPassword = tdeCredentialPassword
        self.useDefaultProcessorFeatures = useDefaultProcessorFeatures
        self.useLatestRestorableTime = useLatestRestorableTime
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct RestoreDBInstanceToPointInTimeInputBody: Swift.Equatable {
    let sourceDBInstanceIdentifier: Swift.String?
    let targetDBInstanceIdentifier: Swift.String?
    let restoreTime: ClientRuntime.Date?
    let useLatestRestorableTime: Swift.Bool
    let dBInstanceClass: Swift.String?
    let port: Swift.Int?
    let availabilityZone: Swift.String?
    let dBSubnetGroupName: Swift.String?
    let multiAZ: Swift.Bool?
    let publiclyAccessible: Swift.Bool?
    let autoMinorVersionUpgrade: Swift.Bool?
    let licenseModel: Swift.String?
    let dBName: Swift.String?
    let engine: Swift.String?
    let iops: Swift.Int?
    let optionGroupName: Swift.String?
    let copyTagsToSnapshot: Swift.Bool?
    let tags: [RdsClientTypes.Tag]?
    let storageType: Swift.String?
    let tdeCredentialArn: Swift.String?
    let tdeCredentialPassword: Swift.String?
    let vpcSecurityGroupIds: [Swift.String]?
    let domain: Swift.String?
    let domainIAMRoleName: Swift.String?
    let enableIAMDatabaseAuthentication: Swift.Bool?
    let enableCloudwatchLogsExports: [Swift.String]?
    let processorFeatures: [RdsClientTypes.ProcessorFeature]?
    let useDefaultProcessorFeatures: Swift.Bool?
    let dBParameterGroupName: Swift.String?
    let deletionProtection: Swift.Bool?
    let sourceDbiResourceId: Swift.String?
    let maxAllocatedStorage: Swift.Int?
    let sourceDBInstanceAutomatedBackupsArn: Swift.String?
    let enableCustomerOwnedIp: Swift.Bool?
    let customIamInstanceProfile: Swift.String?
    let backupTarget: Swift.String?
}

extension RestoreDBInstanceToPointInTimeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityZone = "AvailabilityZone"
        case backupTarget = "BackupTarget"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case customIamInstanceProfile = "CustomIamInstanceProfile"
        case dBInstanceClass = "DBInstanceClass"
        case dBName = "DBName"
        case dBParameterGroupName = "DBParameterGroupName"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case deletionProtection = "DeletionProtection"
        case domain = "Domain"
        case domainIAMRoleName = "DomainIAMRoleName"
        case enableCloudwatchLogsExports = "EnableCloudwatchLogsExports"
        case enableCustomerOwnedIp = "EnableCustomerOwnedIp"
        case enableIAMDatabaseAuthentication = "EnableIAMDatabaseAuthentication"
        case engine = "Engine"
        case iops = "Iops"
        case licenseModel = "LicenseModel"
        case maxAllocatedStorage = "MaxAllocatedStorage"
        case multiAZ = "MultiAZ"
        case optionGroupName = "OptionGroupName"
        case port = "Port"
        case processorFeatures = "ProcessorFeatures"
        case publiclyAccessible = "PubliclyAccessible"
        case restoreTime = "RestoreTime"
        case sourceDBInstanceAutomatedBackupsArn = "SourceDBInstanceAutomatedBackupsArn"
        case sourceDBInstanceIdentifier = "SourceDBInstanceIdentifier"
        case sourceDbiResourceId = "SourceDbiResourceId"
        case storageType = "StorageType"
        case tags = "Tags"
        case targetDBInstanceIdentifier = "TargetDBInstanceIdentifier"
        case tdeCredentialArn = "TdeCredentialArn"
        case tdeCredentialPassword = "TdeCredentialPassword"
        case useDefaultProcessorFeatures = "UseDefaultProcessorFeatures"
        case useLatestRestorableTime = "UseLatestRestorableTime"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDBInstanceIdentifier)
        sourceDBInstanceIdentifier = sourceDBInstanceIdentifierDecoded
        let targetDBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetDBInstanceIdentifier)
        targetDBInstanceIdentifier = targetDBInstanceIdentifierDecoded
        let restoreTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restoreTime)
        var restoreTimeBuffer:ClientRuntime.Date? = nil
        if let restoreTimeDecoded = restoreTimeDecoded {
            restoreTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(restoreTimeDecoded, format: .dateTime)
        }
        restoreTime = restoreTimeBuffer
        let useLatestRestorableTimeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .useLatestRestorableTime)
        useLatestRestorableTime = useLatestRestorableTimeDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let dBNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBName)
        dBName = dBNameDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let copyTagsToSnapshotDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let tdeCredentialArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tdeCredentialArn)
        tdeCredentialArn = tdeCredentialArnDecoded
        let tdeCredentialPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tdeCredentialPassword)
        tdeCredentialPassword = tdeCredentialPasswordDecoded
        if containerValues.contains(.vpcSecurityGroupIds) {
            struct KeyVal0{struct VpcSecurityGroupId{}}
            let vpcSecurityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupId>.CodingKeys.self, forKey: .vpcSecurityGroupIds)
            if let vpcSecurityGroupIdsWrappedContainer = vpcSecurityGroupIdsWrappedContainer {
                let vpcSecurityGroupIdsContainer = try vpcSecurityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSecurityGroupIdsBuffer:[Swift.String]? = nil
                if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
                    vpcSecurityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSecurityGroupIdsContainer {
                        vpcSecurityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupIds = vpcSecurityGroupIdsBuffer
            } else {
                vpcSecurityGroupIds = []
            }
        } else {
            vpcSecurityGroupIds = nil
        }
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let domainIAMRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainIAMRoleName)
        domainIAMRoleName = domainIAMRoleNameDecoded
        let enableIAMDatabaseAuthenticationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableIAMDatabaseAuthentication)
        enableIAMDatabaseAuthentication = enableIAMDatabaseAuthenticationDecoded
        if containerValues.contains(.enableCloudwatchLogsExports) {
            struct KeyVal0{struct member{}}
            let enableCloudwatchLogsExportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enableCloudwatchLogsExports)
            if let enableCloudwatchLogsExportsWrappedContainer = enableCloudwatchLogsExportsWrappedContainer {
                let enableCloudwatchLogsExportsContainer = try enableCloudwatchLogsExportsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var enableCloudwatchLogsExportsBuffer:[Swift.String]? = nil
                if let enableCloudwatchLogsExportsContainer = enableCloudwatchLogsExportsContainer {
                    enableCloudwatchLogsExportsBuffer = [Swift.String]()
                    for stringContainer0 in enableCloudwatchLogsExportsContainer {
                        enableCloudwatchLogsExportsBuffer?.append(stringContainer0)
                    }
                }
                enableCloudwatchLogsExports = enableCloudwatchLogsExportsBuffer
            } else {
                enableCloudwatchLogsExports = []
            }
        } else {
            enableCloudwatchLogsExports = nil
        }
        if containerValues.contains(.processorFeatures) {
            struct KeyVal0{struct ProcessorFeature{}}
            let processorFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ProcessorFeature>.CodingKeys.self, forKey: .processorFeatures)
            if let processorFeaturesWrappedContainer = processorFeaturesWrappedContainer {
                let processorFeaturesContainer = try processorFeaturesWrappedContainer.decodeIfPresent([RdsClientTypes.ProcessorFeature].self, forKey: .member)
                var processorFeaturesBuffer:[RdsClientTypes.ProcessorFeature]? = nil
                if let processorFeaturesContainer = processorFeaturesContainer {
                    processorFeaturesBuffer = [RdsClientTypes.ProcessorFeature]()
                    for structureContainer0 in processorFeaturesContainer {
                        processorFeaturesBuffer?.append(structureContainer0)
                    }
                }
                processorFeatures = processorFeaturesBuffer
            } else {
                processorFeatures = []
            }
        } else {
            processorFeatures = nil
        }
        let useDefaultProcessorFeaturesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaultProcessorFeatures)
        useDefaultProcessorFeatures = useDefaultProcessorFeaturesDecoded
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let sourceDbiResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDbiResourceId)
        sourceDbiResourceId = sourceDbiResourceIdDecoded
        let maxAllocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAllocatedStorage)
        maxAllocatedStorage = maxAllocatedStorageDecoded
        let sourceDBInstanceAutomatedBackupsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDBInstanceAutomatedBackupsArn)
        sourceDBInstanceAutomatedBackupsArn = sourceDBInstanceAutomatedBackupsArnDecoded
        let enableCustomerOwnedIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableCustomerOwnedIp)
        enableCustomerOwnedIp = enableCustomerOwnedIpDecoded
        let customIamInstanceProfileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customIamInstanceProfile)
        customIamInstanceProfile = customIamInstanceProfileDecoded
        let backupTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupTarget)
        backupTarget = backupTargetDecoded
    }
}

extension RestoreDBInstanceToPointInTimeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreDBInstanceToPointInTimeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFound" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BackupPolicyNotFoundFault" : self = .backupPolicyNotFoundFault(try BackupPolicyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceAlreadyExists" : self = .dBInstanceAlreadyExistsFault(try DBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceAutomatedBackupNotFound" : self = .dBInstanceAutomatedBackupNotFoundFault(try DBInstanceAutomatedBackupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFound" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceQuotaExceeded" : self = .instanceQuotaExceededFault(try InstanceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacity" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRestoreFault" : self = .invalidRestoreFault(try InvalidRestoreFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PointInTimeRestoreNotEnabled" : self = .pointInTimeRestoreNotEnabledFault(try PointInTimeRestoreNotEnabledFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedIopsNotAvailableInAZFault" : self = .provisionedIopsNotAvailableInAZFault(try ProvisionedIopsNotAvailableInAZFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceeded" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupported" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDBInstanceToPointInTimeOutputError: Swift.Error, Swift.Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case backupPolicyNotFoundFault(BackupPolicyNotFoundFault)
    case dBInstanceAlreadyExistsFault(DBInstanceAlreadyExistsFault)
    case dBInstanceAutomatedBackupNotFoundFault(DBInstanceAutomatedBackupNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case instanceQuotaExceededFault(InstanceQuotaExceededFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidRestoreFault(InvalidRestoreFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case pointInTimeRestoreNotEnabledFault(PointInTimeRestoreNotEnabledFault)
    case provisionedIopsNotAvailableInAZFault(ProvisionedIopsNotAvailableInAZFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDBInstanceToPointInTimeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestoreDBInstanceToPointInTimeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct RestoreDBInstanceToPointInTimeOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB instance. This data type is used as a response element in the operations CreateDBInstance, CreateDBInstanceReadReplica, DeleteDBInstance, DescribeDBInstances, ModifyDBInstance, PromoteReadReplica, RebootDBInstance, RestoreDBInstanceFromDBSnapshot, RestoreDBInstanceFromS3, RestoreDBInstanceToPointInTime, StartDBInstance, and StopDBInstance.
    public var dBInstance: RdsClientTypes.DBInstance?

    public init (
        dBInstance: RdsClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct RestoreDBInstanceToPointInTimeOutputResponseBody: Swift.Equatable {
    let dBInstance: RdsClientTypes.DBInstance?
}

extension RestoreDBInstanceToPointInTimeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RestoreDBInstanceToPointInTimeResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

extension RdsClientTypes.RestoreWindow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case earliestTime = "EarliestTime"
        case latestTime = "LatestTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let earliestTime = earliestTime {
            try container.encode(ClientRuntime.TimestampWrapper(earliestTime, format: .dateTime), forKey: ClientRuntime.Key("earliestTime"))
        }
        if let latestTime = latestTime {
            try container.encode(ClientRuntime.TimestampWrapper(latestTime, format: .dateTime), forKey: ClientRuntime.Key("latestTime"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let earliestTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .earliestTime)
        var earliestTimeBuffer:ClientRuntime.Date? = nil
        if let earliestTimeDecoded = earliestTimeDecoded {
            earliestTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(earliestTimeDecoded, format: .dateTime)
        }
        earliestTime = earliestTimeBuffer
        let latestTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestTime)
        var latestTimeBuffer:ClientRuntime.Date? = nil
        if let latestTimeDecoded = latestTimeDecoded {
            latestTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(latestTimeDecoded, format: .dateTime)
        }
        latestTime = latestTimeBuffer
    }
}

extension RdsClientTypes {
    /// Earliest and latest time an instance can be restored to:
    public struct RestoreWindow: Swift.Equatable {
        /// The earliest time you can restore an instance to.
        public var earliestTime: ClientRuntime.Date?
        /// The latest time you can restore an instance to.
        public var latestTime: ClientRuntime.Date?

        public init (
            earliestTime: ClientRuntime.Date? = nil,
            latestTime: ClientRuntime.Date? = nil
        )
        {
            self.earliestTime = earliestTime
            self.latestTime = latestTime
        }
    }

}

extension RevokeDBSecurityGroupIngressInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let cIDRIP = cIDRIP {
            try container.encode(cIDRIP, forKey: ClientRuntime.Key("CIDRIP"))
        }
        if let dBSecurityGroupName = dBSecurityGroupName {
            try container.encode(dBSecurityGroupName, forKey: ClientRuntime.Key("DBSecurityGroupName"))
        }
        if let eC2SecurityGroupId = eC2SecurityGroupId {
            try container.encode(eC2SecurityGroupId, forKey: ClientRuntime.Key("EC2SecurityGroupId"))
        }
        if let eC2SecurityGroupName = eC2SecurityGroupName {
            try container.encode(eC2SecurityGroupName, forKey: ClientRuntime.Key("EC2SecurityGroupName"))
        }
        if let eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId {
            try container.encode(eC2SecurityGroupOwnerId, forKey: ClientRuntime.Key("EC2SecurityGroupOwnerId"))
        }
        try container.encode("RevokeDBSecurityGroupIngress", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension RevokeDBSecurityGroupIngressInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct RevokeDBSecurityGroupIngressInput: Swift.Equatable {
    /// The IP range to revoke access from. Must be a valid CIDR range. If CIDRIP is specified, EC2SecurityGroupName, EC2SecurityGroupId and EC2SecurityGroupOwnerId can't be provided.
    public var cIDRIP: Swift.String?
    /// The name of the DB security group to revoke ingress from.
    /// This member is required.
    public var dBSecurityGroupName: Swift.String?
    /// The id of the EC2 security group to revoke access from. For VPC DB security groups, EC2SecurityGroupId must be provided. Otherwise, EC2SecurityGroupOwnerId and either EC2SecurityGroupName or EC2SecurityGroupId must be provided.
    public var eC2SecurityGroupId: Swift.String?
    /// The name of the EC2 security group to revoke access from. For VPC DB security groups, EC2SecurityGroupId must be provided. Otherwise, EC2SecurityGroupOwnerId and either EC2SecurityGroupName or EC2SecurityGroupId must be provided.
    public var eC2SecurityGroupName: Swift.String?
    /// The Amazon Web Services account number of the owner of the EC2 security group specified in the EC2SecurityGroupName parameter. The Amazon Web Services access key ID isn't an acceptable value. For VPC DB security groups, EC2SecurityGroupId must be provided. Otherwise, EC2SecurityGroupOwnerId and either EC2SecurityGroupName or EC2SecurityGroupId must be provided.
    public var eC2SecurityGroupOwnerId: Swift.String?

    public init (
        cIDRIP: Swift.String? = nil,
        dBSecurityGroupName: Swift.String? = nil,
        eC2SecurityGroupId: Swift.String? = nil,
        eC2SecurityGroupName: Swift.String? = nil,
        eC2SecurityGroupOwnerId: Swift.String? = nil
    )
    {
        self.cIDRIP = cIDRIP
        self.dBSecurityGroupName = dBSecurityGroupName
        self.eC2SecurityGroupId = eC2SecurityGroupId
        self.eC2SecurityGroupName = eC2SecurityGroupName
        self.eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId
    }
}

struct RevokeDBSecurityGroupIngressInputBody: Swift.Equatable {
    let dBSecurityGroupName: Swift.String?
    let cIDRIP: Swift.String?
    let eC2SecurityGroupName: Swift.String?
    let eC2SecurityGroupId: Swift.String?
    let eC2SecurityGroupOwnerId: Swift.String?
}

extension RevokeDBSecurityGroupIngressInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cIDRIP = "CIDRIP"
        case dBSecurityGroupName = "DBSecurityGroupName"
        case eC2SecurityGroupId = "EC2SecurityGroupId"
        case eC2SecurityGroupName = "EC2SecurityGroupName"
        case eC2SecurityGroupOwnerId = "EC2SecurityGroupOwnerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSecurityGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSecurityGroupName)
        dBSecurityGroupName = dBSecurityGroupNameDecoded
        let cIDRIPDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cIDRIP)
        cIDRIP = cIDRIPDecoded
        let eC2SecurityGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eC2SecurityGroupName)
        eC2SecurityGroupName = eC2SecurityGroupNameDecoded
        let eC2SecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eC2SecurityGroupId)
        eC2SecurityGroupId = eC2SecurityGroupIdDecoded
        let eC2SecurityGroupOwnerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eC2SecurityGroupOwnerId)
        eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerIdDecoded
    }
}

extension RevokeDBSecurityGroupIngressOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RevokeDBSecurityGroupIngressOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFound" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFound" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSecurityGroupState" : self = .invalidDBSecurityGroupStateFault(try InvalidDBSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeDBSecurityGroupIngressOutputError: Swift.Error, Swift.Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case invalidDBSecurityGroupStateFault(InvalidDBSecurityGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeDBSecurityGroupIngressOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RevokeDBSecurityGroupIngressOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSecurityGroup = output.dBSecurityGroup
        } else {
            self.dBSecurityGroup = nil
        }
    }
}

public struct RevokeDBSecurityGroupIngressOutputResponse: Swift.Equatable {
    /// Contains the details for an Amazon RDS DB security group. This data type is used as a response element in the DescribeDBSecurityGroups action.
    public var dBSecurityGroup: RdsClientTypes.DBSecurityGroup?

    public init (
        dBSecurityGroup: RdsClientTypes.DBSecurityGroup? = nil
    )
    {
        self.dBSecurityGroup = dBSecurityGroup
    }
}

struct RevokeDBSecurityGroupIngressOutputResponseBody: Swift.Equatable {
    let dBSecurityGroup: RdsClientTypes.DBSecurityGroup?
}

extension RevokeDBSecurityGroupIngressOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSecurityGroup = "DBSecurityGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RevokeDBSecurityGroupIngressResult"))
        let dBSecurityGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSecurityGroup.self, forKey: .dBSecurityGroup)
        dBSecurityGroup = dBSecurityGroupDecoded
    }
}

extension SNSInvalidTopicFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<SNSInvalidTopicFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// SNS has responded that there is a problem with the SND topic specified.
public struct SNSInvalidTopicFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SNSInvalidTopicFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SNSInvalidTopicFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SNSNoAuthorizationFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<SNSNoAuthorizationFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have permission to publish to the SNS topic ARN.
public struct SNSNoAuthorizationFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SNSNoAuthorizationFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SNSNoAuthorizationFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SNSTopicArnNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<SNSTopicArnNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The SNS topic ARN does not exist.
public struct SNSTopicArnNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SNSTopicArnNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SNSTopicArnNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.ScalingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoPause = "AutoPause"
        case maxCapacity = "MaxCapacity"
        case minCapacity = "MinCapacity"
        case secondsBeforeTimeout = "SecondsBeforeTimeout"
        case secondsUntilAutoPause = "SecondsUntilAutoPause"
        case timeoutAction = "TimeoutAction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let autoPause = autoPause {
            try container.encode(autoPause, forKey: ClientRuntime.Key("AutoPause"))
        }
        if let maxCapacity = maxCapacity {
            try container.encode(maxCapacity, forKey: ClientRuntime.Key("MaxCapacity"))
        }
        if let minCapacity = minCapacity {
            try container.encode(minCapacity, forKey: ClientRuntime.Key("MinCapacity"))
        }
        if let secondsBeforeTimeout = secondsBeforeTimeout {
            try container.encode(secondsBeforeTimeout, forKey: ClientRuntime.Key("SecondsBeforeTimeout"))
        }
        if let secondsUntilAutoPause = secondsUntilAutoPause {
            try container.encode(secondsUntilAutoPause, forKey: ClientRuntime.Key("SecondsUntilAutoPause"))
        }
        if let timeoutAction = timeoutAction {
            try container.encode(timeoutAction, forKey: ClientRuntime.Key("TimeoutAction"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minCapacity)
        minCapacity = minCapacityDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let autoPauseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoPause)
        autoPause = autoPauseDecoded
        let secondsUntilAutoPauseDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .secondsUntilAutoPause)
        secondsUntilAutoPause = secondsUntilAutoPauseDecoded
        let timeoutActionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeoutAction)
        timeoutAction = timeoutActionDecoded
        let secondsBeforeTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .secondsBeforeTimeout)
        secondsBeforeTimeout = secondsBeforeTimeoutDecoded
    }
}

extension RdsClientTypes {
    /// Contains the scaling configuration of an Aurora Serverless DB cluster. For more information, see [Using Amazon Aurora Serverless](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html) in the Amazon Aurora User Guide.
    public struct ScalingConfiguration: Swift.Equatable {
        /// A value that indicates whether to allow or disallow automatic pause for an Aurora DB cluster in serverless DB engine mode. A DB cluster can be paused only when it's idle (it has no connections). If a DB cluster is paused for more than seven days, the DB cluster might be backed up with a snapshot. In this case, the DB cluster is restored when there is a request to connect to it.
        public var autoPause: Swift.Bool?
        /// The maximum capacity for an Aurora DB cluster in serverless DB engine mode. For Aurora MySQL, valid capacity values are 1, 2, 4, 8, 16, 32, 64, 128, and 256. For Aurora PostgreSQL, valid capacity values are 2, 4, 8, 16, 32, 64, 192, and 384. The maximum capacity must be greater than or equal to the minimum capacity.
        public var maxCapacity: Swift.Int?
        /// The minimum capacity for an Aurora DB cluster in serverless DB engine mode. For Aurora MySQL, valid capacity values are 1, 2, 4, 8, 16, 32, 64, 128, and 256. For Aurora PostgreSQL, valid capacity values are 2, 4, 8, 16, 32, 64, 192, and 384. The minimum capacity must be less than or equal to the maximum capacity.
        public var minCapacity: Swift.Int?
        /// The amount of time, in seconds, that Aurora Serverless tries to find a scaling point to perform seamless scaling before enforcing the timeout action. The default is 300. Specify a value between 60 and 600 seconds.
        public var secondsBeforeTimeout: Swift.Int?
        /// The time, in seconds, before an Aurora DB cluster in serverless mode is paused. Specify a value between 300 and 86,400 seconds.
        public var secondsUntilAutoPause: Swift.Int?
        /// The action to take when the timeout is reached, either ForceApplyCapacityChange or RollbackCapacityChange. ForceApplyCapacityChange sets the capacity to the specified value as soon as possible. RollbackCapacityChange, the default, ignores the capacity change if a scaling point isn't found in the timeout period. If you specify ForceApplyCapacityChange, connections that prevent Aurora Serverless from finding a scaling point might be dropped. For more information, see [ Autoscaling for Aurora Serverless](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.how-it-works.html#aurora-serverless.how-it-works.auto-scaling) in the Amazon Aurora User Guide.
        public var timeoutAction: Swift.String?

        public init (
            autoPause: Swift.Bool? = nil,
            maxCapacity: Swift.Int? = nil,
            minCapacity: Swift.Int? = nil,
            secondsBeforeTimeout: Swift.Int? = nil,
            secondsUntilAutoPause: Swift.Int? = nil,
            timeoutAction: Swift.String? = nil
        )
        {
            self.autoPause = autoPause
            self.maxCapacity = maxCapacity
            self.minCapacity = minCapacity
            self.secondsBeforeTimeout = secondsBeforeTimeout
            self.secondsUntilAutoPause = secondsUntilAutoPause
            self.timeoutAction = timeoutAction
        }
    }

}

extension RdsClientTypes.ScalingConfigurationInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoPause = "AutoPause"
        case maxCapacity = "MaxCapacity"
        case minCapacity = "MinCapacity"
        case secondsBeforeTimeout = "SecondsBeforeTimeout"
        case secondsUntilAutoPause = "SecondsUntilAutoPause"
        case timeoutAction = "TimeoutAction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let autoPause = autoPause {
            try container.encode(autoPause, forKey: ClientRuntime.Key("AutoPause"))
        }
        if let maxCapacity = maxCapacity {
            try container.encode(maxCapacity, forKey: ClientRuntime.Key("MaxCapacity"))
        }
        if let minCapacity = minCapacity {
            try container.encode(minCapacity, forKey: ClientRuntime.Key("MinCapacity"))
        }
        if let secondsBeforeTimeout = secondsBeforeTimeout {
            try container.encode(secondsBeforeTimeout, forKey: ClientRuntime.Key("SecondsBeforeTimeout"))
        }
        if let secondsUntilAutoPause = secondsUntilAutoPause {
            try container.encode(secondsUntilAutoPause, forKey: ClientRuntime.Key("SecondsUntilAutoPause"))
        }
        if let timeoutAction = timeoutAction {
            try container.encode(timeoutAction, forKey: ClientRuntime.Key("TimeoutAction"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minCapacity)
        minCapacity = minCapacityDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let autoPauseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoPause)
        autoPause = autoPauseDecoded
        let secondsUntilAutoPauseDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .secondsUntilAutoPause)
        secondsUntilAutoPause = secondsUntilAutoPauseDecoded
        let timeoutActionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeoutAction)
        timeoutAction = timeoutActionDecoded
        let secondsBeforeTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .secondsBeforeTimeout)
        secondsBeforeTimeout = secondsBeforeTimeoutDecoded
    }
}

extension RdsClientTypes {
    /// Shows the scaling configuration for an Aurora DB cluster in serverless DB engine mode. For more information, see [Using Amazon Aurora Serverless](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html) in the Amazon Aurora User Guide.
    public struct ScalingConfigurationInfo: Swift.Equatable {
        /// A value that indicates whether automatic pause is allowed for the Aurora DB cluster in serverless DB engine mode. When the value is set to false for an Aurora Serverless DB cluster, the DB cluster automatically resumes.
        public var autoPause: Swift.Bool?
        /// The maximum capacity for an Aurora DB cluster in serverless DB engine mode.
        public var maxCapacity: Swift.Int?
        /// The maximum capacity for the Aurora DB cluster in serverless DB engine mode.
        public var minCapacity: Swift.Int?
        /// The number of seconds before scaling times out. What happens when an attempted scaling action times out is determined by the TimeoutAction setting.
        public var secondsBeforeTimeout: Swift.Int?
        /// The remaining amount of time, in seconds, before the Aurora DB cluster in serverless mode is paused. A DB cluster can be paused only when it's idle (it has no connections).
        public var secondsUntilAutoPause: Swift.Int?
        /// The action that occurs when Aurora times out while attempting to change the capacity of an Aurora Serverless cluster. The value is either ForceApplyCapacityChange or RollbackCapacityChange. ForceApplyCapacityChange, the default, sets the capacity to the specified value as soon as possible. RollbackCapacityChange ignores the capacity change if a scaling point isn't found in the timeout period.
        public var timeoutAction: Swift.String?

        public init (
            autoPause: Swift.Bool? = nil,
            maxCapacity: Swift.Int? = nil,
            minCapacity: Swift.Int? = nil,
            secondsBeforeTimeout: Swift.Int? = nil,
            secondsUntilAutoPause: Swift.Int? = nil,
            timeoutAction: Swift.String? = nil
        )
        {
            self.autoPause = autoPause
            self.maxCapacity = maxCapacity
            self.minCapacity = minCapacity
            self.secondsBeforeTimeout = secondsBeforeTimeout
            self.secondsUntilAutoPause = secondsUntilAutoPause
            self.timeoutAction = timeoutAction
        }
    }

}

extension SharedSnapshotQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<SharedSnapshotQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the maximum number of accounts that you can share a manual DB snapshot with.
public struct SharedSnapshotQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SharedSnapshotQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SharedSnapshotQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<SnapshotQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would result in the user exceeding the allowed number of DB snapshots.
public struct SnapshotQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SnapshotQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SourceNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<SourceNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested source could not be found.
public struct SourceNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SourceNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SourceNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.SourceRegion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
        case regionName = "RegionName"
        case status = "Status"
        case supportsDBInstanceAutomatedBackupsReplication = "SupportsDBInstanceAutomatedBackupsReplication"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if let regionName = regionName {
            try container.encode(regionName, forKey: ClientRuntime.Key("RegionName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if supportsDBInstanceAutomatedBackupsReplication != false {
            try container.encode(supportsDBInstanceAutomatedBackupsReplication, forKey: ClientRuntime.Key("SupportsDBInstanceAutomatedBackupsReplication"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionName)
        regionName = regionNameDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let supportsDBInstanceAutomatedBackupsReplicationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsDBInstanceAutomatedBackupsReplication)
        supportsDBInstanceAutomatedBackupsReplication = supportsDBInstanceAutomatedBackupsReplicationDecoded
    }
}

extension RdsClientTypes {
    /// Contains an Amazon Web Services Region name as the result of a successful call to the DescribeSourceRegions action.
    public struct SourceRegion: Swift.Equatable {
        /// The endpoint for the source Amazon Web Services Region endpoint.
        public var endpoint: Swift.String?
        /// The name of the source Amazon Web Services Region.
        public var regionName: Swift.String?
        /// The status of the source Amazon Web Services Region.
        public var status: Swift.String?
        /// Whether the source Amazon Web Services Region supports replicating automated backups to the current Amazon Web Services Region.
        public var supportsDBInstanceAutomatedBackupsReplication: Swift.Bool

        public init (
            endpoint: Swift.String? = nil,
            regionName: Swift.String? = nil,
            status: Swift.String? = nil,
            supportsDBInstanceAutomatedBackupsReplication: Swift.Bool = false
        )
        {
            self.endpoint = endpoint
            self.regionName = regionName
            self.status = status
            self.supportsDBInstanceAutomatedBackupsReplication = supportsDBInstanceAutomatedBackupsReplication
        }
    }

}

extension RdsClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case customEngineVersion
        case dbCluster
        case dbClusterSnapshot
        case dbInstance
        case dbParameterGroup
        case dbSecurityGroup
        case dbSnapshot
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .customEngineVersion,
                .dbCluster,
                .dbClusterSnapshot,
                .dbInstance,
                .dbParameterGroup,
                .dbSecurityGroup,
                .dbSnapshot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .customEngineVersion: return "custom-engine-version"
            case .dbCluster: return "db-cluster"
            case .dbClusterSnapshot: return "db-cluster-snapshot"
            case .dbInstance: return "db-instance"
            case .dbParameterGroup: return "db-parameter-group"
            case .dbSecurityGroup: return "db-security-group"
            case .dbSnapshot: return "db-snapshot"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

extension StartActivityStreamInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let applyImmediately = applyImmediately {
            try container.encode(applyImmediately, forKey: ClientRuntime.Key("ApplyImmediately"))
        }
        if let engineNativeAuditFieldsIncluded = engineNativeAuditFieldsIncluded {
            try container.encode(engineNativeAuditFieldsIncluded, forKey: ClientRuntime.Key("EngineNativeAuditFieldsIncluded"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let mode = mode {
            try container.encode(mode, forKey: ClientRuntime.Key("Mode"))
        }
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: ClientRuntime.Key("ResourceArn"))
        }
        try container.encode("StartActivityStream", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension StartActivityStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartActivityStreamInput: Swift.Equatable {
    /// Specifies whether or not the database activity stream is to start as soon as possible, regardless of the maintenance window for the database.
    public var applyImmediately: Swift.Bool?
    /// Specifies whether the database activity stream includes engine-native audit fields. This option only applies to an Oracle DB instance. By default, no engine-native audit fields are included.
    public var engineNativeAuditFieldsIncluded: Swift.Bool?
    /// The Amazon Web Services KMS key identifier for encrypting messages in the database activity stream. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
    /// This member is required.
    public var kmsKeyId: Swift.String?
    /// Specifies the mode of the database activity stream. Database events such as a change or access generate an activity stream event. The database session can handle these events either synchronously or asynchronously.
    /// This member is required.
    public var mode: RdsClientTypes.ActivityStreamMode?
    /// The Amazon Resource Name (ARN) of the DB cluster, for example, arn:aws:rds:us-east-1:12345667890:cluster:das-cluster.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        applyImmediately: Swift.Bool? = nil,
        engineNativeAuditFieldsIncluded: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        mode: RdsClientTypes.ActivityStreamMode? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.applyImmediately = applyImmediately
        self.engineNativeAuditFieldsIncluded = engineNativeAuditFieldsIncluded
        self.kmsKeyId = kmsKeyId
        self.mode = mode
        self.resourceArn = resourceArn
    }
}

struct StartActivityStreamInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let mode: RdsClientTypes.ActivityStreamMode?
    let kmsKeyId: Swift.String?
    let applyImmediately: Swift.Bool?
    let engineNativeAuditFieldsIncluded: Swift.Bool?
}

extension StartActivityStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyImmediately = "ApplyImmediately"
        case engineNativeAuditFieldsIncluded = "EngineNativeAuditFieldsIncluded"
        case kmsKeyId = "KmsKeyId"
        case mode = "Mode"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let modeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ActivityStreamMode.self, forKey: .mode)
        mode = modeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let applyImmediatelyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .applyImmediately)
        applyImmediately = applyImmediatelyDecoded
        let engineNativeAuditFieldsIncludedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .engineNativeAuditFieldsIncluded)
        engineNativeAuditFieldsIncluded = engineNativeAuditFieldsIncludedDecoded
    }
}

extension StartActivityStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StartActivityStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartActivityStreamOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartActivityStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartActivityStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applyImmediately = output.applyImmediately
            self.engineNativeAuditFieldsIncluded = output.engineNativeAuditFieldsIncluded
            self.kinesisStreamName = output.kinesisStreamName
            self.kmsKeyId = output.kmsKeyId
            self.mode = output.mode
            self.status = output.status
        } else {
            self.applyImmediately = false
            self.engineNativeAuditFieldsIncluded = nil
            self.kinesisStreamName = nil
            self.kmsKeyId = nil
            self.mode = nil
            self.status = nil
        }
    }
}

public struct StartActivityStreamOutputResponse: Swift.Equatable {
    /// Indicates whether or not the database activity stream will start as soon as possible, regardless of the maintenance window for the database.
    public var applyImmediately: Swift.Bool
    /// Indicates whether engine-native audit fields are included in the database activity stream.
    public var engineNativeAuditFieldsIncluded: Swift.Bool?
    /// The name of the Amazon Kinesis data stream to be used for the database activity stream.
    public var kinesisStreamName: Swift.String?
    /// The Amazon Web Services KMS key identifier for encryption of messages in the database activity stream.
    public var kmsKeyId: Swift.String?
    /// The mode of the database activity stream.
    public var mode: RdsClientTypes.ActivityStreamMode?
    /// The status of the database activity stream.
    public var status: RdsClientTypes.ActivityStreamStatus?

    public init (
        applyImmediately: Swift.Bool = false,
        engineNativeAuditFieldsIncluded: Swift.Bool? = nil,
        kinesisStreamName: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        mode: RdsClientTypes.ActivityStreamMode? = nil,
        status: RdsClientTypes.ActivityStreamStatus? = nil
    )
    {
        self.applyImmediately = applyImmediately
        self.engineNativeAuditFieldsIncluded = engineNativeAuditFieldsIncluded
        self.kinesisStreamName = kinesisStreamName
        self.kmsKeyId = kmsKeyId
        self.mode = mode
        self.status = status
    }
}

struct StartActivityStreamOutputResponseBody: Swift.Equatable {
    let kmsKeyId: Swift.String?
    let kinesisStreamName: Swift.String?
    let status: RdsClientTypes.ActivityStreamStatus?
    let mode: RdsClientTypes.ActivityStreamMode?
    let applyImmediately: Swift.Bool
    let engineNativeAuditFieldsIncluded: Swift.Bool?
}

extension StartActivityStreamOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyImmediately = "ApplyImmediately"
        case engineNativeAuditFieldsIncluded = "EngineNativeAuditFieldsIncluded"
        case kinesisStreamName = "KinesisStreamName"
        case kmsKeyId = "KmsKeyId"
        case mode = "Mode"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("StartActivityStreamResult"))
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let kinesisStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kinesisStreamName)
        kinesisStreamName = kinesisStreamNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ActivityStreamStatus.self, forKey: .status)
        status = statusDecoded
        let modeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ActivityStreamMode.self, forKey: .mode)
        mode = modeDecoded
        let applyImmediatelyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .applyImmediately)
        applyImmediately = applyImmediatelyDecoded
        let engineNativeAuditFieldsIncludedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .engineNativeAuditFieldsIncluded)
        engineNativeAuditFieldsIncluded = engineNativeAuditFieldsIncludedDecoded
    }
}

extension StartDBClusterInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        try container.encode("StartDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension StartDBClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartDBClusterInput: Swift.Equatable {
    /// The DB cluster identifier of the Amazon Aurora DB cluster to be started. This parameter is stored as a lowercase string.
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?

    public init (
        dBClusterIdentifier: Swift.String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
    }
}

struct StartDBClusterInputBody: Swift.Equatable {
    let dBClusterIdentifier: Swift.String?
}

extension StartDBClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterIdentifier = "DBClusterIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
    }
}

extension StartDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StartDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct StartDBClusterOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon Aurora DB cluster or Multi-AZ DB cluster. For an Amazon Aurora DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, PromoteReadReplicaDBCluster, RestoreDBClusterFromS3, RestoreDBClusterFromSnapshot, RestoreDBClusterToPointInTime, StartDBCluster, and StopDBCluster. For a Multi-AZ DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, RebootDBCluster, RestoreDBClusterFromSnapshot, and RestoreDBClusterToPointInTime. For more information on Amazon Aurora DB clusters, see [ What is Amazon Aurora?](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/CHAP_AuroraOverview.html) in the Amazon Aurora User Guide. For more information on Multi-AZ DB clusters, see [ Multi-AZ deployments with two readable standby DB instances](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/multi-az-db-clusters-concepts.html) in the Amazon RDS User Guide. The Multi-AZ DB clusters feature is in preview and is subject to change.
    public var dBCluster: RdsClientTypes.DBCluster?

    public init (
        dBCluster: RdsClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct StartDBClusterOutputResponseBody: Swift.Equatable {
    let dBCluster: RdsClientTypes.DBCluster?
}

extension StartDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("StartDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

extension StartDBInstanceAutomatedBackupsReplicationInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let preSignedUrl = preSignedUrl {
            try container.encode(preSignedUrl, forKey: ClientRuntime.Key("PreSignedUrl"))
        }
        if let sourceDBInstanceArn = sourceDBInstanceArn {
            try container.encode(sourceDBInstanceArn, forKey: ClientRuntime.Key("SourceDBInstanceArn"))
        }
        try container.encode("StartDBInstanceAutomatedBackupsReplication", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension StartDBInstanceAutomatedBackupsReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartDBInstanceAutomatedBackupsReplicationInput: Swift.Equatable {
    /// The retention period for the replicated automated backups.
    public var backupRetentionPeriod: Swift.Int?
    /// The Amazon Web Services KMS key identifier for encryption of the replicated automated backups. The KMS key ID is the Amazon Resource Name (ARN) for the KMS encryption key in the destination Amazon Web Services Region, for example, arn:aws:kms:us-east-1:123456789012:key/AKIAIOSFODNN7EXAMPLE.
    public var kmsKeyId: Swift.String?
    /// A URL that contains a Signature Version 4 signed request for the StartDBInstanceAutomatedBackupsReplication action to be called in the Amazon Web Services Region of the source DB instance. The presigned URL must be a valid request for the StartDBInstanceAutomatedBackupsReplication API action that can be executed in the Amazon Web Services Region that contains the source DB instance.
    public var preSignedUrl: Swift.String?
    /// The Amazon Resource Name (ARN) of the source DB instance for the replicated automated backups, for example, arn:aws:rds:us-west-2:123456789012:db:mydatabase.
    /// This member is required.
    public var sourceDBInstanceArn: Swift.String?

    public init (
        backupRetentionPeriod: Swift.Int? = nil,
        kmsKeyId: Swift.String? = nil,
        preSignedUrl: Swift.String? = nil,
        sourceDBInstanceArn: Swift.String? = nil
    )
    {
        self.backupRetentionPeriod = backupRetentionPeriod
        self.kmsKeyId = kmsKeyId
        self.preSignedUrl = preSignedUrl
        self.sourceDBInstanceArn = sourceDBInstanceArn
    }
}

struct StartDBInstanceAutomatedBackupsReplicationInputBody: Swift.Equatable {
    let sourceDBInstanceArn: Swift.String?
    let backupRetentionPeriod: Swift.Int?
    let kmsKeyId: Swift.String?
    let preSignedUrl: Swift.String?
}

extension StartDBInstanceAutomatedBackupsReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case kmsKeyId = "KmsKeyId"
        case preSignedUrl = "PreSignedUrl"
        case sourceDBInstanceArn = "SourceDBInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDBInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDBInstanceArn)
        sourceDBInstanceArn = sourceDBInstanceArnDecoded
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let preSignedUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preSignedUrl)
        preSignedUrl = preSignedUrlDecoded
    }
}

extension StartDBInstanceAutomatedBackupsReplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StartDBInstanceAutomatedBackupsReplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceAutomatedBackupQuotaExceeded" : self = .dBInstanceAutomatedBackupQuotaExceededFault(try DBInstanceAutomatedBackupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupported" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDBInstanceAutomatedBackupsReplicationOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceAutomatedBackupQuotaExceededFault(DBInstanceAutomatedBackupQuotaExceededFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDBInstanceAutomatedBackupsReplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartDBInstanceAutomatedBackupsReplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstanceAutomatedBackup = output.dBInstanceAutomatedBackup
        } else {
            self.dBInstanceAutomatedBackup = nil
        }
    }
}

public struct StartDBInstanceAutomatedBackupsReplicationOutputResponse: Swift.Equatable {
    /// An automated backup of a DB instance. It consists of system backups, transaction logs, and the database instance properties that existed at the time you deleted the source instance.
    public var dBInstanceAutomatedBackup: RdsClientTypes.DBInstanceAutomatedBackup?

    public init (
        dBInstanceAutomatedBackup: RdsClientTypes.DBInstanceAutomatedBackup? = nil
    )
    {
        self.dBInstanceAutomatedBackup = dBInstanceAutomatedBackup
    }
}

struct StartDBInstanceAutomatedBackupsReplicationOutputResponseBody: Swift.Equatable {
    let dBInstanceAutomatedBackup: RdsClientTypes.DBInstanceAutomatedBackup?
}

extension StartDBInstanceAutomatedBackupsReplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceAutomatedBackup = "DBInstanceAutomatedBackup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("StartDBInstanceAutomatedBackupsReplicationResult"))
        let dBInstanceAutomatedBackupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstanceAutomatedBackup.self, forKey: .dBInstanceAutomatedBackup)
        dBInstanceAutomatedBackup = dBInstanceAutomatedBackupDecoded
    }
}

extension StartDBInstanceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        try container.encode("StartDBInstance", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension StartDBInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartDBInstanceInput: Swift.Equatable {
    /// The user-supplied instance identifier.
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?

    public init (
        dBInstanceIdentifier: Swift.String? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
    }
}

struct StartDBInstanceInputBody: Swift.Equatable {
    let dBInstanceIdentifier: Swift.String?
}

extension StartDBInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceIdentifier = "DBInstanceIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
    }
}

extension StartDBInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StartDBInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFound" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacity" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDBInstanceOutputError: Swift.Error, Swift.Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDBInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct StartDBInstanceOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB instance. This data type is used as a response element in the operations CreateDBInstance, CreateDBInstanceReadReplica, DeleteDBInstance, DescribeDBInstances, ModifyDBInstance, PromoteReadReplica, RebootDBInstance, RestoreDBInstanceFromDBSnapshot, RestoreDBInstanceFromS3, RestoreDBInstanceToPointInTime, StartDBInstance, and StopDBInstance.
    public var dBInstance: RdsClientTypes.DBInstance?

    public init (
        dBInstance: RdsClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct StartDBInstanceOutputResponseBody: Swift.Equatable {
    let dBInstance: RdsClientTypes.DBInstance?
}

extension StartDBInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("StartDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

extension StartExportTaskInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let exportOnly = exportOnly {
            var exportOnlyContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExportOnly"))
            for (index0, string0) in exportOnly.enumerated() {
                try exportOnlyContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let exportTaskIdentifier = exportTaskIdentifier {
            try container.encode(exportTaskIdentifier, forKey: ClientRuntime.Key("ExportTaskIdentifier"))
        }
        if let iamRoleArn = iamRoleArn {
            try container.encode(iamRoleArn, forKey: ClientRuntime.Key("IamRoleArn"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let s3BucketName = s3BucketName {
            try container.encode(s3BucketName, forKey: ClientRuntime.Key("S3BucketName"))
        }
        if let s3Prefix = s3Prefix {
            try container.encode(s3Prefix, forKey: ClientRuntime.Key("S3Prefix"))
        }
        if let sourceArn = sourceArn {
            try container.encode(sourceArn, forKey: ClientRuntime.Key("SourceArn"))
        }
        try container.encode("StartExportTask", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension StartExportTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartExportTaskInput: Swift.Equatable {
    /// The data to be exported from the snapshot. If this parameter is not provided, all the snapshot data is exported. Valid values are the following:
    ///
    /// * database - Export all the data from a specified database.
    ///
    /// * database.table table-name - Export a table of the snapshot. This format is valid only for RDS for MySQL, RDS for MariaDB, and Aurora MySQL.
    ///
    /// * database.schema schema-name - Export a database schema of the snapshot. This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.
    ///
    /// * database.schema.table table-name - Export a table of the database schema. This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.
    public var exportOnly: [Swift.String]?
    /// A unique identifier for the snapshot export task. This ID isn't an identifier for the Amazon S3 bucket where the snapshot is to be exported to.
    /// This member is required.
    public var exportTaskIdentifier: Swift.String?
    /// The name of the IAM role to use for writing to the Amazon S3 bucket when exporting a snapshot.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// The ID of the Amazon Web Services KMS key to use to encrypt the snapshot exported to Amazon S3. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. The caller of this operation must be authorized to execute the following operations. These can be set in the Amazon Web Services KMS key policy:
    ///
    /// * GrantOperation.Encrypt
    ///
    /// * GrantOperation.Decrypt
    ///
    /// * GrantOperation.GenerateDataKey
    ///
    /// * GrantOperation.GenerateDataKeyWithoutPlaintext
    ///
    /// * GrantOperation.ReEncryptFrom
    ///
    /// * GrantOperation.ReEncryptTo
    ///
    /// * GrantOperation.CreateGrant
    ///
    /// * GrantOperation.DescribeKey
    ///
    /// * GrantOperation.RetireGrant
    /// This member is required.
    public var kmsKeyId: Swift.String?
    /// The name of the Amazon S3 bucket to export the snapshot to.
    /// This member is required.
    public var s3BucketName: Swift.String?
    /// The Amazon S3 bucket prefix to use as the file name and path of the exported snapshot.
    public var s3Prefix: Swift.String?
    /// The Amazon Resource Name (ARN) of the snapshot to export to Amazon S3.
    /// This member is required.
    public var sourceArn: Swift.String?

    public init (
        exportOnly: [Swift.String]? = nil,
        exportTaskIdentifier: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3Prefix: Swift.String? = nil,
        sourceArn: Swift.String? = nil
    )
    {
        self.exportOnly = exportOnly
        self.exportTaskIdentifier = exportTaskIdentifier
        self.iamRoleArn = iamRoleArn
        self.kmsKeyId = kmsKeyId
        self.s3BucketName = s3BucketName
        self.s3Prefix = s3Prefix
        self.sourceArn = sourceArn
    }
}

struct StartExportTaskInputBody: Swift.Equatable {
    let exportTaskIdentifier: Swift.String?
    let sourceArn: Swift.String?
    let s3BucketName: Swift.String?
    let iamRoleArn: Swift.String?
    let kmsKeyId: Swift.String?
    let s3Prefix: Swift.String?
    let exportOnly: [Swift.String]?
}

extension StartExportTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportOnly = "ExportOnly"
        case exportTaskIdentifier = "ExportTaskIdentifier"
        case iamRoleArn = "IamRoleArn"
        case kmsKeyId = "KmsKeyId"
        case s3BucketName = "S3BucketName"
        case s3Prefix = "S3Prefix"
        case sourceArn = "SourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportTaskIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportTaskIdentifier)
        exportTaskIdentifier = exportTaskIdentifierDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
        if containerValues.contains(.exportOnly) {
            struct KeyVal0{struct member{}}
            let exportOnlyWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .exportOnly)
            if let exportOnlyWrappedContainer = exportOnlyWrappedContainer {
                let exportOnlyContainer = try exportOnlyWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var exportOnlyBuffer:[Swift.String]? = nil
                if let exportOnlyContainer = exportOnlyContainer {
                    exportOnlyBuffer = [Swift.String]()
                    for stringContainer0 in exportOnlyContainer {
                        exportOnlyBuffer?.append(stringContainer0)
                    }
                }
                exportOnly = exportOnlyBuffer
            } else {
                exportOnly = []
            }
        } else {
            exportOnly = nil
        }
    }
}

extension StartExportTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StartExportTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExportTaskAlreadyExists" : self = .exportTaskAlreadyExistsFault(try ExportTaskAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IamRoleMissingPermissions" : self = .iamRoleMissingPermissionsFault(try IamRoleMissingPermissionsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IamRoleNotFound" : self = .iamRoleNotFoundFault(try IamRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidExportOnly" : self = .invalidExportOnlyFault(try InvalidExportOnlyFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidExportSourceState" : self = .invalidExportSourceStateFault(try InvalidExportSourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3BucketFault" : self = .invalidS3BucketFault(try InvalidS3BucketFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartExportTaskOutputError: Swift.Error, Swift.Equatable {
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case exportTaskAlreadyExistsFault(ExportTaskAlreadyExistsFault)
    case iamRoleMissingPermissionsFault(IamRoleMissingPermissionsFault)
    case iamRoleNotFoundFault(IamRoleNotFoundFault)
    case invalidExportOnlyFault(InvalidExportOnlyFault)
    case invalidExportSourceStateFault(InvalidExportSourceStateFault)
    case invalidS3BucketFault(InvalidS3BucketFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartExportTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartExportTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exportOnly = output.exportOnly
            self.exportTaskIdentifier = output.exportTaskIdentifier
            self.failureCause = output.failureCause
            self.iamRoleArn = output.iamRoleArn
            self.kmsKeyId = output.kmsKeyId
            self.percentProgress = output.percentProgress
            self.s3Bucket = output.s3Bucket
            self.s3Prefix = output.s3Prefix
            self.snapshotTime = output.snapshotTime
            self.sourceArn = output.sourceArn
            self.status = output.status
            self.taskEndTime = output.taskEndTime
            self.taskStartTime = output.taskStartTime
            self.totalExtractedDataInGB = output.totalExtractedDataInGB
            self.warningMessage = output.warningMessage
        } else {
            self.exportOnly = nil
            self.exportTaskIdentifier = nil
            self.failureCause = nil
            self.iamRoleArn = nil
            self.kmsKeyId = nil
            self.percentProgress = 0
            self.s3Bucket = nil
            self.s3Prefix = nil
            self.snapshotTime = nil
            self.sourceArn = nil
            self.status = nil
            self.taskEndTime = nil
            self.taskStartTime = nil
            self.totalExtractedDataInGB = 0
            self.warningMessage = nil
        }
    }
}

/// Contains the details of a snapshot export to Amazon S3. This data type is used as a response element in the DescribeExportTasks action.
public struct StartExportTaskOutputResponse: Swift.Equatable {
    /// The data exported from the snapshot. Valid values are the following:
    ///
    /// * database - Export all the data from a specified database.
    ///
    /// * database.table table-name - Export a table of the snapshot. This format is valid only for RDS for MySQL, RDS for MariaDB, and Aurora MySQL.
    ///
    /// * database.schema schema-name - Export a database schema of the snapshot. This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.
    ///
    /// * database.schema.table table-name - Export a table of the database schema. This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.
    public var exportOnly: [Swift.String]?
    /// A unique identifier for the snapshot export task. This ID isn't an identifier for the Amazon S3 bucket where the snapshot is exported to.
    public var exportTaskIdentifier: Swift.String?
    /// The reason the export failed, if it failed.
    public var failureCause: Swift.String?
    /// The name of the IAM role that is used to write to Amazon S3 when exporting a snapshot.
    public var iamRoleArn: Swift.String?
    /// The key identifier of the Amazon Web Services KMS key that is used to encrypt the snapshot when it's exported to Amazon S3. The KMS key identifier is its key ARN, key ID, alias ARN, or alias name. The IAM role used for the snapshot export must have encryption and decryption permissions to use this KMS key.
    public var kmsKeyId: Swift.String?
    /// The progress of the snapshot export task as a percentage.
    public var percentProgress: Swift.Int
    /// The Amazon S3 bucket that the snapshot is exported to.
    public var s3Bucket: Swift.String?
    /// The Amazon S3 bucket prefix that is the file name and path of the exported snapshot.
    public var s3Prefix: Swift.String?
    /// The time that the snapshot was created.
    public var snapshotTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the snapshot exported to Amazon S3.
    public var sourceArn: Swift.String?
    /// The progress status of the export task.
    public var status: Swift.String?
    /// The time that the snapshot export task completed.
    public var taskEndTime: ClientRuntime.Date?
    /// The time that the snapshot export task started.
    public var taskStartTime: ClientRuntime.Date?
    /// The total amount of data exported, in gigabytes.
    public var totalExtractedDataInGB: Swift.Int
    /// A warning about the snapshot export task.
    public var warningMessage: Swift.String?

    public init (
        exportOnly: [Swift.String]? = nil,
        exportTaskIdentifier: Swift.String? = nil,
        failureCause: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        percentProgress: Swift.Int = 0,
        s3Bucket: Swift.String? = nil,
        s3Prefix: Swift.String? = nil,
        snapshotTime: ClientRuntime.Date? = nil,
        sourceArn: Swift.String? = nil,
        status: Swift.String? = nil,
        taskEndTime: ClientRuntime.Date? = nil,
        taskStartTime: ClientRuntime.Date? = nil,
        totalExtractedDataInGB: Swift.Int = 0,
        warningMessage: Swift.String? = nil
    )
    {
        self.exportOnly = exportOnly
        self.exportTaskIdentifier = exportTaskIdentifier
        self.failureCause = failureCause
        self.iamRoleArn = iamRoleArn
        self.kmsKeyId = kmsKeyId
        self.percentProgress = percentProgress
        self.s3Bucket = s3Bucket
        self.s3Prefix = s3Prefix
        self.snapshotTime = snapshotTime
        self.sourceArn = sourceArn
        self.status = status
        self.taskEndTime = taskEndTime
        self.taskStartTime = taskStartTime
        self.totalExtractedDataInGB = totalExtractedDataInGB
        self.warningMessage = warningMessage
    }
}

struct StartExportTaskOutputResponseBody: Swift.Equatable {
    let exportTaskIdentifier: Swift.String?
    let sourceArn: Swift.String?
    let exportOnly: [Swift.String]?
    let snapshotTime: ClientRuntime.Date?
    let taskStartTime: ClientRuntime.Date?
    let taskEndTime: ClientRuntime.Date?
    let s3Bucket: Swift.String?
    let s3Prefix: Swift.String?
    let iamRoleArn: Swift.String?
    let kmsKeyId: Swift.String?
    let status: Swift.String?
    let percentProgress: Swift.Int
    let totalExtractedDataInGB: Swift.Int
    let failureCause: Swift.String?
    let warningMessage: Swift.String?
}

extension StartExportTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportOnly = "ExportOnly"
        case exportTaskIdentifier = "ExportTaskIdentifier"
        case failureCause = "FailureCause"
        case iamRoleArn = "IamRoleArn"
        case kmsKeyId = "KmsKeyId"
        case percentProgress = "PercentProgress"
        case s3Bucket = "S3Bucket"
        case s3Prefix = "S3Prefix"
        case snapshotTime = "SnapshotTime"
        case sourceArn = "SourceArn"
        case status = "Status"
        case taskEndTime = "TaskEndTime"
        case taskStartTime = "TaskStartTime"
        case totalExtractedDataInGB = "TotalExtractedDataInGB"
        case warningMessage = "WarningMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("StartExportTaskResult"))
        let exportTaskIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportTaskIdentifier)
        exportTaskIdentifier = exportTaskIdentifierDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        if containerValues.contains(.exportOnly) {
            struct KeyVal0{struct member{}}
            let exportOnlyWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .exportOnly)
            if let exportOnlyWrappedContainer = exportOnlyWrappedContainer {
                let exportOnlyContainer = try exportOnlyWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var exportOnlyBuffer:[Swift.String]? = nil
                if let exportOnlyContainer = exportOnlyContainer {
                    exportOnlyBuffer = [Swift.String]()
                    for stringContainer0 in exportOnlyContainer {
                        exportOnlyBuffer?.append(stringContainer0)
                    }
                }
                exportOnly = exportOnlyBuffer
            } else {
                exportOnly = []
            }
        } else {
            exportOnly = nil
        }
        let snapshotTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotTime)
        var snapshotTimeBuffer:ClientRuntime.Date? = nil
        if let snapshotTimeDecoded = snapshotTimeDecoded {
            snapshotTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(snapshotTimeDecoded, format: .dateTime)
        }
        snapshotTime = snapshotTimeBuffer
        let taskStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskStartTime)
        var taskStartTimeBuffer:ClientRuntime.Date? = nil
        if let taskStartTimeDecoded = taskStartTimeDecoded {
            taskStartTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(taskStartTimeDecoded, format: .dateTime)
        }
        taskStartTime = taskStartTimeBuffer
        let taskEndTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskEndTime)
        var taskEndTimeBuffer:ClientRuntime.Date? = nil
        if let taskEndTimeDecoded = taskEndTimeDecoded {
            taskEndTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(taskEndTimeDecoded, format: .dateTime)
        }
        taskEndTime = taskEndTimeBuffer
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let percentProgressDecoded = try containerValues.decode(Swift.Int.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let totalExtractedDataInGBDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalExtractedDataInGB)
        totalExtractedDataInGB = totalExtractedDataInGBDecoded
        let failureCauseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCause)
        failureCause = failureCauseDecoded
        let warningMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .warningMessage)
        warningMessage = warningMessageDecoded
    }
}

extension StopActivityStreamInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let applyImmediately = applyImmediately {
            try container.encode(applyImmediately, forKey: ClientRuntime.Key("ApplyImmediately"))
        }
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: ClientRuntime.Key("ResourceArn"))
        }
        try container.encode("StopActivityStream", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension StopActivityStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopActivityStreamInput: Swift.Equatable {
    /// Specifies whether or not the database activity stream is to stop as soon as possible, regardless of the maintenance window for the database.
    public var applyImmediately: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the DB cluster for the database activity stream. For example, arn:aws:rds:us-east-1:12345667890:cluster:das-cluster.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        applyImmediately: Swift.Bool? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.applyImmediately = applyImmediately
        self.resourceArn = resourceArn
    }
}

struct StopActivityStreamInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let applyImmediately: Swift.Bool?
}

extension StopActivityStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyImmediately = "ApplyImmediately"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let applyImmediatelyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .applyImmediately)
        applyImmediately = applyImmediatelyDecoded
    }
}

extension StopActivityStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StopActivityStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopActivityStreamOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopActivityStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopActivityStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.kinesisStreamName = output.kinesisStreamName
            self.kmsKeyId = output.kmsKeyId
            self.status = output.status
        } else {
            self.kinesisStreamName = nil
            self.kmsKeyId = nil
            self.status = nil
        }
    }
}

public struct StopActivityStreamOutputResponse: Swift.Equatable {
    /// The name of the Amazon Kinesis data stream used for the database activity stream.
    public var kinesisStreamName: Swift.String?
    /// The Amazon Web Services KMS key identifier used for encrypting messages in the database activity stream. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
    public var kmsKeyId: Swift.String?
    /// The status of the database activity stream.
    public var status: RdsClientTypes.ActivityStreamStatus?

    public init (
        kinesisStreamName: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        status: RdsClientTypes.ActivityStreamStatus? = nil
    )
    {
        self.kinesisStreamName = kinesisStreamName
        self.kmsKeyId = kmsKeyId
        self.status = status
    }
}

struct StopActivityStreamOutputResponseBody: Swift.Equatable {
    let kmsKeyId: Swift.String?
    let kinesisStreamName: Swift.String?
    let status: RdsClientTypes.ActivityStreamStatus?
}

extension StopActivityStreamOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kinesisStreamName = "KinesisStreamName"
        case kmsKeyId = "KmsKeyId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("StopActivityStreamResult"))
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let kinesisStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kinesisStreamName)
        kinesisStreamName = kinesisStreamNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ActivityStreamStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension StopDBClusterInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        try container.encode("StopDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension StopDBClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopDBClusterInput: Swift.Equatable {
    /// The DB cluster identifier of the Amazon Aurora DB cluster to be stopped. This parameter is stored as a lowercase string.
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?

    public init (
        dBClusterIdentifier: Swift.String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
    }
}

struct StopDBClusterInputBody: Swift.Equatable {
    let dBClusterIdentifier: Swift.String?
}

extension StopDBClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterIdentifier = "DBClusterIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
    }
}

extension StopDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StopDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct StopDBClusterOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon Aurora DB cluster or Multi-AZ DB cluster. For an Amazon Aurora DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, PromoteReadReplicaDBCluster, RestoreDBClusterFromS3, RestoreDBClusterFromSnapshot, RestoreDBClusterToPointInTime, StartDBCluster, and StopDBCluster. For a Multi-AZ DB cluster, this data type is used as a response element in the operations CreateDBCluster, DeleteDBCluster, DescribeDBClusters, FailoverDBCluster, ModifyDBCluster, RebootDBCluster, RestoreDBClusterFromSnapshot, and RestoreDBClusterToPointInTime. For more information on Amazon Aurora DB clusters, see [ What is Amazon Aurora?](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/CHAP_AuroraOverview.html) in the Amazon Aurora User Guide. For more information on Multi-AZ DB clusters, see [ Multi-AZ deployments with two readable standby DB instances](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/multi-az-db-clusters-concepts.html) in the Amazon RDS User Guide. The Multi-AZ DB clusters feature is in preview and is subject to change.
    public var dBCluster: RdsClientTypes.DBCluster?

    public init (
        dBCluster: RdsClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct StopDBClusterOutputResponseBody: Swift.Equatable {
    let dBCluster: RdsClientTypes.DBCluster?
}

extension StopDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("StopDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

extension StopDBInstanceAutomatedBackupsReplicationInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sourceDBInstanceArn = sourceDBInstanceArn {
            try container.encode(sourceDBInstanceArn, forKey: ClientRuntime.Key("SourceDBInstanceArn"))
        }
        try container.encode("StopDBInstanceAutomatedBackupsReplication", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension StopDBInstanceAutomatedBackupsReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopDBInstanceAutomatedBackupsReplicationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the source DB instance for which to stop replicating automated backups, for example, arn:aws:rds:us-west-2:123456789012:db:mydatabase.
    /// This member is required.
    public var sourceDBInstanceArn: Swift.String?

    public init (
        sourceDBInstanceArn: Swift.String? = nil
    )
    {
        self.sourceDBInstanceArn = sourceDBInstanceArn
    }
}

struct StopDBInstanceAutomatedBackupsReplicationInputBody: Swift.Equatable {
    let sourceDBInstanceArn: Swift.String?
}

extension StopDBInstanceAutomatedBackupsReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceDBInstanceArn = "SourceDBInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDBInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDBInstanceArn)
        sourceDBInstanceArn = sourceDBInstanceArnDecoded
    }
}

extension StopDBInstanceAutomatedBackupsReplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StopDBInstanceAutomatedBackupsReplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopDBInstanceAutomatedBackupsReplicationOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopDBInstanceAutomatedBackupsReplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopDBInstanceAutomatedBackupsReplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstanceAutomatedBackup = output.dBInstanceAutomatedBackup
        } else {
            self.dBInstanceAutomatedBackup = nil
        }
    }
}

public struct StopDBInstanceAutomatedBackupsReplicationOutputResponse: Swift.Equatable {
    /// An automated backup of a DB instance. It consists of system backups, transaction logs, and the database instance properties that existed at the time you deleted the source instance.
    public var dBInstanceAutomatedBackup: RdsClientTypes.DBInstanceAutomatedBackup?

    public init (
        dBInstanceAutomatedBackup: RdsClientTypes.DBInstanceAutomatedBackup? = nil
    )
    {
        self.dBInstanceAutomatedBackup = dBInstanceAutomatedBackup
    }
}

struct StopDBInstanceAutomatedBackupsReplicationOutputResponseBody: Swift.Equatable {
    let dBInstanceAutomatedBackup: RdsClientTypes.DBInstanceAutomatedBackup?
}

extension StopDBInstanceAutomatedBackupsReplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceAutomatedBackup = "DBInstanceAutomatedBackup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("StopDBInstanceAutomatedBackupsReplicationResult"))
        let dBInstanceAutomatedBackupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstanceAutomatedBackup.self, forKey: .dBInstanceAutomatedBackup)
        dBInstanceAutomatedBackup = dBInstanceAutomatedBackupDecoded
    }
}

extension StopDBInstanceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: ClientRuntime.Key("DBSnapshotIdentifier"))
        }
        try container.encode("StopDBInstance", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension StopDBInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopDBInstanceInput: Swift.Equatable {
    /// The user-supplied instance identifier.
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// The user-supplied instance identifier of the DB Snapshot created immediately before the DB instance is stopped.
    public var dBSnapshotIdentifier: Swift.String?

    public init (
        dBInstanceIdentifier: Swift.String? = nil,
        dBSnapshotIdentifier: Swift.String? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
    }
}

struct StopDBInstanceInputBody: Swift.Equatable {
    let dBInstanceIdentifier: Swift.String?
    let dBSnapshotIdentifier: Swift.String?
}

extension StopDBInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dBSnapshotIdentifier = "DBSnapshotIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let dBSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSnapshotIdentifier)
        dBSnapshotIdentifier = dBSnapshotIdentifierDecoded
    }
}

extension StopDBInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StopDBInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotAlreadyExists" : self = .dBSnapshotAlreadyExistsFault(try DBSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceeded" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopDBInstanceOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSnapshotAlreadyExistsFault(DBSnapshotAlreadyExistsFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopDBInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct StopDBInstanceOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB instance. This data type is used as a response element in the operations CreateDBInstance, CreateDBInstanceReadReplica, DeleteDBInstance, DescribeDBInstances, ModifyDBInstance, PromoteReadReplica, RebootDBInstance, RestoreDBInstanceFromDBSnapshot, RestoreDBInstanceFromS3, RestoreDBInstanceToPointInTime, StartDBInstance, and StopDBInstance.
    public var dBInstance: RdsClientTypes.DBInstance?

    public init (
        dBInstance: RdsClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct StopDBInstanceOutputResponseBody: Swift.Equatable {
    let dBInstance: RdsClientTypes.DBInstance?
}

extension StopDBInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("StopDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

extension StorageQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<StorageQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would result in the user exceeding the allowed amount of storage available across all DB instances.
public struct StorageQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StorageQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension StorageQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StorageTypeNotSupportedFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<StorageTypeNotSupportedFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Storage of the StorageType specified can't be associated with the DB instance.
public struct StorageTypeNotSupportedFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StorageTypeNotSupportedFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension StorageTypeNotSupportedFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.Subnet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetAvailabilityZone = "SubnetAvailabilityZone"
        case subnetIdentifier = "SubnetIdentifier"
        case subnetOutpost = "SubnetOutpost"
        case subnetStatus = "SubnetStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let subnetAvailabilityZone = subnetAvailabilityZone {
            try container.encode(subnetAvailabilityZone, forKey: ClientRuntime.Key("SubnetAvailabilityZone"))
        }
        if let subnetIdentifier = subnetIdentifier {
            try container.encode(subnetIdentifier, forKey: ClientRuntime.Key("SubnetIdentifier"))
        }
        if let subnetOutpost = subnetOutpost {
            try container.encode(subnetOutpost, forKey: ClientRuntime.Key("SubnetOutpost"))
        }
        if let subnetStatus = subnetStatus {
            try container.encode(subnetStatus, forKey: ClientRuntime.Key("SubnetStatus"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetIdentifier)
        subnetIdentifier = subnetIdentifierDecoded
        let subnetAvailabilityZoneDecoded = try containerValues.decodeIfPresent(RdsClientTypes.AvailabilityZone.self, forKey: .subnetAvailabilityZone)
        subnetAvailabilityZone = subnetAvailabilityZoneDecoded
        let subnetOutpostDecoded = try containerValues.decodeIfPresent(RdsClientTypes.Outpost.self, forKey: .subnetOutpost)
        subnetOutpost = subnetOutpostDecoded
        let subnetStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetStatus)
        subnetStatus = subnetStatusDecoded
    }
}

extension RdsClientTypes {
    /// This data type is used as a response element for the DescribeDBSubnetGroups operation.
    public struct Subnet: Swift.Equatable {
        /// Contains Availability Zone information. This data type is used as an element in the OrderableDBInstanceOption data type.
        public var subnetAvailabilityZone: RdsClientTypes.AvailabilityZone?
        /// The identifier of the subnet.
        public var subnetIdentifier: Swift.String?
        /// If the subnet is associated with an Outpost, this value specifies the Outpost. For more information about RDS on Outposts, see [Amazon RDS on Amazon Web Services Outposts](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html) in the Amazon RDS User Guide.
        public var subnetOutpost: RdsClientTypes.Outpost?
        /// The status of the subnet.
        public var subnetStatus: Swift.String?

        public init (
            subnetAvailabilityZone: RdsClientTypes.AvailabilityZone? = nil,
            subnetIdentifier: Swift.String? = nil,
            subnetOutpost: RdsClientTypes.Outpost? = nil,
            subnetStatus: Swift.String? = nil
        )
        {
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetIdentifier = subnetIdentifier
            self.subnetOutpost = subnetOutpost
            self.subnetStatus = subnetStatus
        }
    }

}

extension SubnetAlreadyInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<SubnetAlreadyInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DB subnet is already in use in the Availability Zone.
public struct SubnetAlreadyInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetAlreadyInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension SubnetAlreadyInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionAlreadyExistFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<SubscriptionAlreadyExistFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The supplied subscription name already exists.
public struct SubscriptionAlreadyExistFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionAlreadyExistFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SubscriptionAlreadyExistFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionCategoryNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<SubscriptionCategoryNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The supplied category does not exist.
public struct SubscriptionCategoryNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionCategoryNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SubscriptionCategoryNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<SubscriptionNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The subscription name does not exist.
public struct SubscriptionNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SubscriptionNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension RdsClientTypes {
    /// Metadata assigned to an Amazon RDS resource consisting of a key-value pair.
    public struct Tag: Swift.Equatable {
        /// A key is the required name of the tag. The string value can be from 1 to 128 Unicode characters in length and can't be prefixed with aws: or rds:. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', ':', '/', '=', '+', '-', '@' (Java regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$").
        public var key: Swift.String?
        /// A value is the optional value of the tag. The string value can be from 1 to 256 Unicode characters in length and can't be prefixed with aws: or rds:. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', ':', '/', '=', '+', '-', '@' (Java regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$").
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension RdsClientTypes.TargetHealth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case reason = "Reason"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let reason = reason {
            try container.encode(reason, forKey: ClientRuntime.Key("Reason"))
        }
        if let state = state {
            try container.encode(state, forKey: ClientRuntime.Key("State"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(RdsClientTypes.TargetState.self, forKey: .state)
        state = stateDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(RdsClientTypes.TargetHealthReason.self, forKey: .reason)
        reason = reasonDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension RdsClientTypes {
    /// Information about the connection health of an RDS Proxy target.
    public struct TargetHealth: Swift.Equatable {
        /// A description of the health of the RDS Proxy target. If the State is AVAILABLE, a description is not included.
        public var description: Swift.String?
        /// The reason for the current health State of the RDS Proxy target.
        public var reason: RdsClientTypes.TargetHealthReason?
        /// The current state of the connection health lifecycle for the RDS Proxy target. The following is a typical lifecycle example for the states of an RDS Proxy target: registering > unavailable > available > unavailable > available
        public var state: RdsClientTypes.TargetState?

        public init (
            description: Swift.String? = nil,
            reason: RdsClientTypes.TargetHealthReason? = nil,
            state: RdsClientTypes.TargetState? = nil
        )
        {
            self.description = description
            self.reason = reason
            self.state = state
        }
    }

}

extension RdsClientTypes {
    public enum TargetHealthReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authFailure
        case connectionFailed
        case invalidReplicationState
        case pendingProxyCapacity
        case unreachable
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetHealthReason] {
            return [
                .authFailure,
                .connectionFailed,
                .invalidReplicationState,
                .pendingProxyCapacity,
                .unreachable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authFailure: return "AUTH_FAILURE"
            case .connectionFailed: return "CONNECTION_FAILED"
            case .invalidReplicationState: return "INVALID_REPLICATION_STATE"
            case .pendingProxyCapacity: return "PENDING_PROXY_CAPACITY"
            case .unreachable: return "UNREACHABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetHealthReason(rawValue: rawValue) ?? TargetHealthReason.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes {
    public enum TargetRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case readOnly
        case readWrite
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetRole] {
            return [
                .readOnly,
                .readWrite,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .readOnly: return "READ_ONLY"
            case .readWrite: return "READ_WRITE"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetRole(rawValue: rawValue) ?? TargetRole.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes {
    public enum TargetState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case registering
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetState] {
            return [
                .available,
                .registering,
                .unavailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .registering: return "REGISTERING"
            case .unavailable: return "UNAVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetState(rawValue: rawValue) ?? TargetState.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes {
    public enum TargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case rdsInstance
        case rdsServerlessEndpoint
        case trackedCluster
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetType] {
            return [
                .rdsInstance,
                .rdsServerlessEndpoint,
                .trackedCluster,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .rdsInstance: return "RDS_INSTANCE"
            case .rdsServerlessEndpoint: return "RDS_SERVERLESS_ENDPOINT"
            case .trackedCluster: return "TRACKED_CLUSTER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetType(rawValue: rawValue) ?? TargetType.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes.Timezone: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timezoneName = "TimezoneName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let timezoneName = timezoneName {
            try container.encode(timezoneName, forKey: ClientRuntime.Key("TimezoneName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timezoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezoneName)
        timezoneName = timezoneNameDecoded
    }
}

extension RdsClientTypes {
    /// A time zone associated with a DBInstance or a DBSnapshot. This data type is an element in the response to the DescribeDBInstances, the DescribeDBSnapshots, and the DescribeDBEngineVersions actions.
    public struct Timezone: Swift.Equatable {
        /// The name of the time zone.
        public var timezoneName: Swift.String?

        public init (
            timezoneName: Swift.String? = nil
        )
        {
            self.timezoneName = timezoneName
        }
    }

}

extension RdsClientTypes.UpgradeTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoUpgrade = "AutoUpgrade"
        case description = "Description"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case isMajorVersionUpgrade = "IsMajorVersionUpgrade"
        case supportedEngineModes = "SupportedEngineModes"
        case supportsGlobalDatabases = "SupportsGlobalDatabases"
        case supportsParallelQuery = "SupportsParallelQuery"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if autoUpgrade != false {
            try container.encode(autoUpgrade, forKey: ClientRuntime.Key("AutoUpgrade"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if isMajorVersionUpgrade != false {
            try container.encode(isMajorVersionUpgrade, forKey: ClientRuntime.Key("IsMajorVersionUpgrade"))
        }
        if let supportedEngineModes = supportedEngineModes {
            var supportedEngineModesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedEngineModes"))
            for (index0, string0) in supportedEngineModes.enumerated() {
                try supportedEngineModesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let supportsGlobalDatabases = supportsGlobalDatabases {
            try container.encode(supportsGlobalDatabases, forKey: ClientRuntime.Key("SupportsGlobalDatabases"))
        }
        if let supportsParallelQuery = supportsParallelQuery {
            try container.encode(supportsParallelQuery, forKey: ClientRuntime.Key("SupportsParallelQuery"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let autoUpgradeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoUpgrade)
        autoUpgrade = autoUpgradeDecoded
        let isMajorVersionUpgradeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isMajorVersionUpgrade)
        isMajorVersionUpgrade = isMajorVersionUpgradeDecoded
        if containerValues.contains(.supportedEngineModes) {
            struct KeyVal0{struct member{}}
            let supportedEngineModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedEngineModes)
            if let supportedEngineModesWrappedContainer = supportedEngineModesWrappedContainer {
                let supportedEngineModesContainer = try supportedEngineModesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedEngineModesBuffer:[Swift.String]? = nil
                if let supportedEngineModesContainer = supportedEngineModesContainer {
                    supportedEngineModesBuffer = [Swift.String]()
                    for stringContainer0 in supportedEngineModesContainer {
                        supportedEngineModesBuffer?.append(stringContainer0)
                    }
                }
                supportedEngineModes = supportedEngineModesBuffer
            } else {
                supportedEngineModes = []
            }
        } else {
            supportedEngineModes = nil
        }
        let supportsParallelQueryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsParallelQuery)
        supportsParallelQuery = supportsParallelQueryDecoded
        let supportsGlobalDatabasesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsGlobalDatabases)
        supportsGlobalDatabases = supportsGlobalDatabasesDecoded
    }
}

extension RdsClientTypes {
    /// The version of the database engine that a DB instance can be upgraded to.
    public struct UpgradeTarget: Swift.Equatable {
        /// A value that indicates whether the target version is applied to any source DB instances that have AutoMinorVersionUpgrade set to true.
        public var autoUpgrade: Swift.Bool
        /// The version of the database engine that a DB instance can be upgraded to.
        public var description: Swift.String?
        /// The name of the upgrade target database engine.
        public var engine: Swift.String?
        /// The version number of the upgrade target database engine.
        public var engineVersion: Swift.String?
        /// A value that indicates whether upgrading to the target version requires upgrading the major version of the database engine.
        public var isMajorVersionUpgrade: Swift.Bool
        /// A list of the supported DB engine modes for the target engine version.
        public var supportedEngineModes: [Swift.String]?
        /// A value that indicates whether you can use Aurora global databases with the target engine version.
        public var supportsGlobalDatabases: Swift.Bool?
        /// A value that indicates whether you can use Aurora parallel query with the target engine version.
        public var supportsParallelQuery: Swift.Bool?

        public init (
            autoUpgrade: Swift.Bool = false,
            description: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            isMajorVersionUpgrade: Swift.Bool = false,
            supportedEngineModes: [Swift.String]? = nil,
            supportsGlobalDatabases: Swift.Bool? = nil,
            supportsParallelQuery: Swift.Bool? = nil
        )
        {
            self.autoUpgrade = autoUpgrade
            self.description = description
            self.engine = engine
            self.engineVersion = engineVersion
            self.isMajorVersionUpgrade = isMajorVersionUpgrade
            self.supportedEngineModes = supportedEngineModes
            self.supportsGlobalDatabases = supportsGlobalDatabases
            self.supportsParallelQuery = supportsParallelQuery
        }
    }

}

extension RdsClientTypes.UserAuthConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authScheme = "AuthScheme"
        case description = "Description"
        case iAMAuth = "IAMAuth"
        case secretArn = "SecretArn"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let authScheme = authScheme {
            try container.encode(authScheme, forKey: ClientRuntime.Key("AuthScheme"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let iAMAuth = iAMAuth {
            try container.encode(iAMAuth, forKey: ClientRuntime.Key("IAMAuth"))
        }
        if let secretArn = secretArn {
            try container.encode(secretArn, forKey: ClientRuntime.Key("SecretArn"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let authSchemeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.AuthScheme.self, forKey: .authScheme)
        authScheme = authSchemeDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let iAMAuthDecoded = try containerValues.decodeIfPresent(RdsClientTypes.IAMAuthMode.self, forKey: .iAMAuth)
        iAMAuth = iAMAuthDecoded
    }
}

extension RdsClientTypes {
    /// Specifies the details of authentication used by a proxy to log in as a specific database user.
    public struct UserAuthConfig: Swift.Equatable {
        /// The type of authentication that the proxy uses for connections from the proxy to the underlying database.
        public var authScheme: RdsClientTypes.AuthScheme?
        /// A user-specified description about the authentication used by a proxy to log in as a specific database user.
        public var description: Swift.String?
        /// Whether to require or disallow Amazon Web Services Identity and Access Management (IAM) authentication for connections to the proxy.
        public var iAMAuth: RdsClientTypes.IAMAuthMode?
        /// The Amazon Resource Name (ARN) representing the secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager.
        public var secretArn: Swift.String?
        /// The name of the database user to which the proxy connects.
        public var userName: Swift.String?

        public init (
            authScheme: RdsClientTypes.AuthScheme? = nil,
            description: Swift.String? = nil,
            iAMAuth: RdsClientTypes.IAMAuthMode? = nil,
            secretArn: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.authScheme = authScheme
            self.description = description
            self.iAMAuth = iAMAuth
            self.secretArn = secretArn
            self.userName = userName
        }
    }

}

extension RdsClientTypes.UserAuthConfigInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authScheme = "AuthScheme"
        case description = "Description"
        case iAMAuth = "IAMAuth"
        case secretArn = "SecretArn"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let authScheme = authScheme {
            try container.encode(authScheme, forKey: ClientRuntime.Key("AuthScheme"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let iAMAuth = iAMAuth {
            try container.encode(iAMAuth, forKey: ClientRuntime.Key("IAMAuth"))
        }
        if let secretArn = secretArn {
            try container.encode(secretArn, forKey: ClientRuntime.Key("SecretArn"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let authSchemeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.AuthScheme.self, forKey: .authScheme)
        authScheme = authSchemeDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let iAMAuthDecoded = try containerValues.decodeIfPresent(RdsClientTypes.IAMAuthMode.self, forKey: .iAMAuth)
        iAMAuth = iAMAuthDecoded
    }
}

extension RdsClientTypes {
    /// Returns the details of authentication used by a proxy to log in as a specific database user.
    public struct UserAuthConfigInfo: Swift.Equatable {
        /// The type of authentication that the proxy uses for connections from the proxy to the underlying database.
        public var authScheme: RdsClientTypes.AuthScheme?
        /// A user-specified description about the authentication used by a proxy to log in as a specific database user.
        public var description: Swift.String?
        /// Whether to require or disallow Amazon Web Services Identity and Access Management (IAM) authentication for connections to the proxy.
        public var iAMAuth: RdsClientTypes.IAMAuthMode?
        /// The Amazon Resource Name (ARN) representing the secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager.
        public var secretArn: Swift.String?
        /// The name of the database user to which the proxy connects.
        public var userName: Swift.String?

        public init (
            authScheme: RdsClientTypes.AuthScheme? = nil,
            description: Swift.String? = nil,
            iAMAuth: RdsClientTypes.IAMAuthMode? = nil,
            secretArn: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.authScheme = authScheme
            self.description = description
            self.iAMAuth = iAMAuth
            self.secretArn = secretArn
            self.userName = userName
        }
    }

}

extension RdsClientTypes.ValidDBInstanceModificationsMessage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storage = "Storage"
        case validProcessorFeatures = "ValidProcessorFeatures"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let storage = storage {
            var storageContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Storage"))
            for (index0, validstorageoptions0) in storage.enumerated() {
                try storageContainer.encode(validstorageoptions0, forKey: ClientRuntime.Key("ValidStorageOptions.\(index0.advanced(by: 1))"))
            }
        }
        if let validProcessorFeatures = validProcessorFeatures {
            var validProcessorFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ValidProcessorFeatures"))
            for (index0, availableprocessorfeature0) in validProcessorFeatures.enumerated() {
                try validProcessorFeaturesContainer.encode(availableprocessorfeature0, forKey: ClientRuntime.Key("AvailableProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.storage) {
            struct KeyVal0{struct ValidStorageOptions{}}
            let storageWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ValidStorageOptions>.CodingKeys.self, forKey: .storage)
            if let storageWrappedContainer = storageWrappedContainer {
                let storageContainer = try storageWrappedContainer.decodeIfPresent([RdsClientTypes.ValidStorageOptions].self, forKey: .member)
                var storageBuffer:[RdsClientTypes.ValidStorageOptions]? = nil
                if let storageContainer = storageContainer {
                    storageBuffer = [RdsClientTypes.ValidStorageOptions]()
                    for structureContainer0 in storageContainer {
                        storageBuffer?.append(structureContainer0)
                    }
                }
                storage = storageBuffer
            } else {
                storage = []
            }
        } else {
            storage = nil
        }
        if containerValues.contains(.validProcessorFeatures) {
            struct KeyVal0{struct AvailableProcessorFeature{}}
            let validProcessorFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailableProcessorFeature>.CodingKeys.self, forKey: .validProcessorFeatures)
            if let validProcessorFeaturesWrappedContainer = validProcessorFeaturesWrappedContainer {
                let validProcessorFeaturesContainer = try validProcessorFeaturesWrappedContainer.decodeIfPresent([RdsClientTypes.AvailableProcessorFeature].self, forKey: .member)
                var validProcessorFeaturesBuffer:[RdsClientTypes.AvailableProcessorFeature]? = nil
                if let validProcessorFeaturesContainer = validProcessorFeaturesContainer {
                    validProcessorFeaturesBuffer = [RdsClientTypes.AvailableProcessorFeature]()
                    for structureContainer0 in validProcessorFeaturesContainer {
                        validProcessorFeaturesBuffer?.append(structureContainer0)
                    }
                }
                validProcessorFeatures = validProcessorFeaturesBuffer
            } else {
                validProcessorFeatures = []
            }
        } else {
            validProcessorFeatures = nil
        }
    }
}

extension RdsClientTypes {
    /// Information about valid modifications that you can make to your DB instance. Contains the result of a successful call to the DescribeValidDBInstanceModifications action. You can use this information when you call ModifyDBInstance.
    public struct ValidDBInstanceModificationsMessage: Swift.Equatable {
        /// Valid storage options for your DB instance.
        public var storage: [RdsClientTypes.ValidStorageOptions]?
        /// Valid processor features for your DB instance.
        public var validProcessorFeatures: [RdsClientTypes.AvailableProcessorFeature]?

        public init (
            storage: [RdsClientTypes.ValidStorageOptions]? = nil,
            validProcessorFeatures: [RdsClientTypes.AvailableProcessorFeature]? = nil
        )
        {
            self.storage = storage
            self.validProcessorFeatures = validProcessorFeatures
        }
    }

}

extension RdsClientTypes.ValidStorageOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iopsToStorageRatio = "IopsToStorageRatio"
        case provisionedIops = "ProvisionedIops"
        case storageSize = "StorageSize"
        case storageType = "StorageType"
        case supportsStorageAutoscaling = "SupportsStorageAutoscaling"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let iopsToStorageRatio = iopsToStorageRatio {
            var iopsToStorageRatioContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("IopsToStorageRatio"))
            for (index0, doublerange0) in iopsToStorageRatio.enumerated() {
                try iopsToStorageRatioContainer.encode(doublerange0, forKey: ClientRuntime.Key("DoubleRange.\(index0.advanced(by: 1))"))
            }
        }
        if let provisionedIops = provisionedIops {
            var provisionedIopsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProvisionedIops"))
            for (index0, range0) in provisionedIops.enumerated() {
                try provisionedIopsContainer.encode(range0, forKey: ClientRuntime.Key("Range.\(index0.advanced(by: 1))"))
            }
        }
        if let storageSize = storageSize {
            var storageSizeContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("StorageSize"))
            for (index0, range0) in storageSize.enumerated() {
                try storageSizeContainer.encode(range0, forKey: ClientRuntime.Key("Range.\(index0.advanced(by: 1))"))
            }
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if supportsStorageAutoscaling != false {
            try container.encode(supportsStorageAutoscaling, forKey: ClientRuntime.Key("SupportsStorageAutoscaling"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        if containerValues.contains(.storageSize) {
            struct KeyVal0{struct Range{}}
            let storageSizeWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Range>.CodingKeys.self, forKey: .storageSize)
            if let storageSizeWrappedContainer = storageSizeWrappedContainer {
                let storageSizeContainer = try storageSizeWrappedContainer.decodeIfPresent([RdsClientTypes.Range].self, forKey: .member)
                var storageSizeBuffer:[RdsClientTypes.Range]? = nil
                if let storageSizeContainer = storageSizeContainer {
                    storageSizeBuffer = [RdsClientTypes.Range]()
                    for structureContainer0 in storageSizeContainer {
                        storageSizeBuffer?.append(structureContainer0)
                    }
                }
                storageSize = storageSizeBuffer
            } else {
                storageSize = []
            }
        } else {
            storageSize = nil
        }
        if containerValues.contains(.provisionedIops) {
            struct KeyVal0{struct Range{}}
            let provisionedIopsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Range>.CodingKeys.self, forKey: .provisionedIops)
            if let provisionedIopsWrappedContainer = provisionedIopsWrappedContainer {
                let provisionedIopsContainer = try provisionedIopsWrappedContainer.decodeIfPresent([RdsClientTypes.Range].self, forKey: .member)
                var provisionedIopsBuffer:[RdsClientTypes.Range]? = nil
                if let provisionedIopsContainer = provisionedIopsContainer {
                    provisionedIopsBuffer = [RdsClientTypes.Range]()
                    for structureContainer0 in provisionedIopsContainer {
                        provisionedIopsBuffer?.append(structureContainer0)
                    }
                }
                provisionedIops = provisionedIopsBuffer
            } else {
                provisionedIops = []
            }
        } else {
            provisionedIops = nil
        }
        if containerValues.contains(.iopsToStorageRatio) {
            struct KeyVal0{struct DoubleRange{}}
            let iopsToStorageRatioWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DoubleRange>.CodingKeys.self, forKey: .iopsToStorageRatio)
            if let iopsToStorageRatioWrappedContainer = iopsToStorageRatioWrappedContainer {
                let iopsToStorageRatioContainer = try iopsToStorageRatioWrappedContainer.decodeIfPresent([RdsClientTypes.DoubleRange].self, forKey: .member)
                var iopsToStorageRatioBuffer:[RdsClientTypes.DoubleRange]? = nil
                if let iopsToStorageRatioContainer = iopsToStorageRatioContainer {
                    iopsToStorageRatioBuffer = [RdsClientTypes.DoubleRange]()
                    for structureContainer0 in iopsToStorageRatioContainer {
                        iopsToStorageRatioBuffer?.append(structureContainer0)
                    }
                }
                iopsToStorageRatio = iopsToStorageRatioBuffer
            } else {
                iopsToStorageRatio = []
            }
        } else {
            iopsToStorageRatio = nil
        }
        let supportsStorageAutoscalingDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsStorageAutoscaling)
        supportsStorageAutoscaling = supportsStorageAutoscalingDecoded
    }
}

extension RdsClientTypes {
    /// Information about valid modifications that you can make to your DB instance. Contains the result of a successful call to the DescribeValidDBInstanceModifications action.
    public struct ValidStorageOptions: Swift.Equatable {
        /// The valid range of Provisioned IOPS to gibibytes of storage multiplier. For example, 3-10, which means that provisioned IOPS can be between 3 and 10 times storage.
        public var iopsToStorageRatio: [RdsClientTypes.DoubleRange]?
        /// The valid range of provisioned IOPS. For example, 1000-20000.
        public var provisionedIops: [RdsClientTypes.Range]?
        /// The valid range of storage in gibibytes (GiB). For example, 100 to 16384.
        public var storageSize: [RdsClientTypes.Range]?
        /// The valid storage types for your DB instance. For example, gp2, io1.
        public var storageType: Swift.String?
        /// Whether or not Amazon RDS can automatically scale storage for DB instances that use the new instance class.
        public var supportsStorageAutoscaling: Swift.Bool

        public init (
            iopsToStorageRatio: [RdsClientTypes.DoubleRange]? = nil,
            provisionedIops: [RdsClientTypes.Range]? = nil,
            storageSize: [RdsClientTypes.Range]? = nil,
            storageType: Swift.String? = nil,
            supportsStorageAutoscaling: Swift.Bool = false
        )
        {
            self.iopsToStorageRatio = iopsToStorageRatio
            self.provisionedIops = provisionedIops
            self.storageSize = storageSize
            self.storageType = storageType
            self.supportsStorageAutoscaling = supportsStorageAutoscaling
        }
    }

}

extension RdsClientTypes.VpcSecurityGroupMembership: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case vpcSecurityGroupId = "VpcSecurityGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let vpcSecurityGroupId = vpcSecurityGroupId {
            try container.encode(vpcSecurityGroupId, forKey: ClientRuntime.Key("VpcSecurityGroupId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcSecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcSecurityGroupId)
        vpcSecurityGroupId = vpcSecurityGroupIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension RdsClientTypes {
    /// This data type is used as a response element for queries on VPC security group membership.
    public struct VpcSecurityGroupMembership: Swift.Equatable {
        /// The status of the VPC security group.
        public var status: Swift.String?
        /// The name of the VPC security group.
        public var vpcSecurityGroupId: Swift.String?

        public init (
            status: Swift.String? = nil,
            vpcSecurityGroupId: Swift.String? = nil
        )
        {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }
    }

}

extension RdsClientTypes.VpnDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpnGatewayIp = "VpnGatewayIp"
        case vpnId = "VpnId"
        case vpnName = "VpnName"
        case vpnPSK = "VpnPSK"
        case vpnState = "VpnState"
        case vpnTunnelOriginatorIP = "VpnTunnelOriginatorIP"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let vpnGatewayIp = vpnGatewayIp {
            try container.encode(vpnGatewayIp, forKey: ClientRuntime.Key("VpnGatewayIp"))
        }
        if let vpnId = vpnId {
            try container.encode(vpnId, forKey: ClientRuntime.Key("VpnId"))
        }
        if let vpnName = vpnName {
            try container.encode(vpnName, forKey: ClientRuntime.Key("VpnName"))
        }
        if let vpnPSK = vpnPSK {
            try container.encode(vpnPSK, forKey: ClientRuntime.Key("VpnPSK"))
        }
        if let vpnState = vpnState {
            try container.encode(vpnState, forKey: ClientRuntime.Key("VpnState"))
        }
        if let vpnTunnelOriginatorIP = vpnTunnelOriginatorIP {
            try container.encode(vpnTunnelOriginatorIP, forKey: ClientRuntime.Key("VpnTunnelOriginatorIP"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpnIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpnId)
        vpnId = vpnIdDecoded
        let vpnTunnelOriginatorIPDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpnTunnelOriginatorIP)
        vpnTunnelOriginatorIP = vpnTunnelOriginatorIPDecoded
        let vpnGatewayIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpnGatewayIp)
        vpnGatewayIp = vpnGatewayIpDecoded
        let vpnPSKDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpnPSK)
        vpnPSK = vpnPSKDecoded
        let vpnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpnName)
        vpnName = vpnNameDecoded
        let vpnStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpnState)
        vpnState = vpnStateDecoded
    }
}

extension RdsClientTypes {
    /// Information about the virtual private network (VPN) between the VMware vSphere cluster and the Amazon Web Services website. For more information about RDS on VMware, see the [ RDS on VMware User Guide.](https://docs.aws.amazon.com/AmazonRDS/latest/RDSonVMwareUserGuide/rds-on-vmware.html)
    public struct VpnDetails: Swift.Equatable {
        /// The IP address of network traffic from Amazon Web Services to your on-premises data center.
        public var vpnGatewayIp: Swift.String?
        /// The ID of the VPN.
        public var vpnId: Swift.String?
        /// The name of the VPN.
        public var vpnName: Swift.String?
        /// The preshared key (PSK) for the VPN.
        public var vpnPSK: Swift.String?
        /// The state of the VPN.
        public var vpnState: Swift.String?
        /// The IP address of network traffic from your on-premises data center. A custom AZ receives the network traffic.
        public var vpnTunnelOriginatorIP: Swift.String?

        public init (
            vpnGatewayIp: Swift.String? = nil,
            vpnId: Swift.String? = nil,
            vpnName: Swift.String? = nil,
            vpnPSK: Swift.String? = nil,
            vpnState: Swift.String? = nil,
            vpnTunnelOriginatorIP: Swift.String? = nil
        )
        {
            self.vpnGatewayIp = vpnGatewayIp
            self.vpnId = vpnId
            self.vpnName = vpnName
            self.vpnPSK = vpnPSK
            self.vpnState = vpnState
            self.vpnTunnelOriginatorIP = vpnTunnelOriginatorIP
        }
    }

}

extension RdsClientTypes {
    public enum WriteForwardingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case disabling
        case enabled
        case enabling
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [WriteForwardingStatus] {
            return [
                .disabled,
                .disabling,
                .enabled,
                .enabling,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "disabled"
            case .disabling: return "disabling"
            case .enabled: return "enabled"
            case .enabling: return "enabling"
            case .unknown: return "unknown"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WriteForwardingStatus(rawValue: rawValue) ?? WriteForwardingStatus.sdkUnknown(rawValue)
        }
    }
}
