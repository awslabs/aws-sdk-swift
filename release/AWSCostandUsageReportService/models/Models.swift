// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CostAndUsageReportClientTypes {
    /// The region of the S3 bucket that AWS delivers the report into.
    public enum AWSRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bahrain
        case beijing
        case canadaCentral
        case capeTown
        case frankfurt
        case hongKong
        case ireland
        case london
        case milano
        case mumbai
        case ningxia
        case northernCalifornia
        case ohio
        case oregon
        case osaka
        case paris
        case saoPaulo
        case seoul
        case singapore
        case stockholm
        case sydney
        case tokyo
        case usStandard
        case sdkUnknown(Swift.String)

        public static var allCases: [AWSRegion] {
            return [
                .bahrain,
                .beijing,
                .canadaCentral,
                .capeTown,
                .frankfurt,
                .hongKong,
                .ireland,
                .london,
                .milano,
                .mumbai,
                .ningxia,
                .northernCalifornia,
                .ohio,
                .oregon,
                .osaka,
                .paris,
                .saoPaulo,
                .seoul,
                .singapore,
                .stockholm,
                .sydney,
                .tokyo,
                .usStandard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bahrain: return "me-south-1"
            case .beijing: return "cn-north-1"
            case .canadaCentral: return "ca-central-1"
            case .capeTown: return "af-south-1"
            case .frankfurt: return "eu-central-1"
            case .hongKong: return "ap-east-1"
            case .ireland: return "eu-west-1"
            case .london: return "eu-west-2"
            case .milano: return "eu-south-1"
            case .mumbai: return "ap-south-1"
            case .ningxia: return "cn-northwest-1"
            case .northernCalifornia: return "us-west-1"
            case .ohio: return "us-east-2"
            case .oregon: return "us-west-2"
            case .osaka: return "ap-northeast-3"
            case .paris: return "eu-west-3"
            case .saoPaulo: return "sa-east-1"
            case .seoul: return "ap-northeast-2"
            case .singapore: return "ap-southeast-1"
            case .stockholm: return "eu-north-1"
            case .sydney: return "ap-southeast-2"
            case .tokyo: return "ap-northeast-1"
            case .usStandard: return "us-east-1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AWSRegion(rawValue: rawValue) ?? AWSRegion.sdkUnknown(rawValue)
        }
    }
}

extension CostAndUsageReportClientTypes {
    /// The types of manifest that you want AWS to create for this report.
    public enum AdditionalArtifact: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case athena
        case quicksight
        case redshift
        case sdkUnknown(Swift.String)

        public static var allCases: [AdditionalArtifact] {
            return [
                .athena,
                .quicksight,
                .redshift,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .athena: return "ATHENA"
            case .quicksight: return "QUICKSIGHT"
            case .redshift: return "REDSHIFT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AdditionalArtifact(rawValue: rawValue) ?? AdditionalArtifact.sdkUnknown(rawValue)
        }
    }
}

extension CostAndUsageReportClientTypes {
    /// The compression format that AWS uses for the report.
    public enum CompressionFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gzip
        case parquet
        case zip
        case sdkUnknown(Swift.String)

        public static var allCases: [CompressionFormat] {
            return [
                .gzip,
                .parquet,
                .zip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "GZIP"
            case .parquet: return "Parquet"
            case .zip: return "ZIP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CompressionFormat(rawValue: rawValue) ?? CompressionFormat.sdkUnknown(rawValue)
        }
    }
}

extension DeleteReportDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportName = "ReportName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reportName = reportName {
            try encodeContainer.encode(reportName, forKey: .reportName)
        }
    }
}

extension DeleteReportDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Deletes the specified report.
public struct DeleteReportDefinitionInput: Swift.Equatable {
    /// The name of the report that you want to delete. The name must be unique, is case sensitive, and can't include spaces.
    public var reportName: Swift.String?

    public init (
        reportName: Swift.String? = nil
    )
    {
        self.reportName = reportName
    }
}

struct DeleteReportDefinitionInputBody: Swift.Equatable {
    let reportName: Swift.String?
}

extension DeleteReportDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportName = "ReportName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportName)
        reportName = reportNameDecoded
    }
}

extension DeleteReportDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReportDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReportDefinitionOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReportDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteReportDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.responseMessage = output.responseMessage
        } else {
            self.responseMessage = nil
        }
    }
}

/// If the action is successful, the service sends back an HTTP 200 response.
public struct DeleteReportDefinitionOutputResponse: Swift.Equatable {
    /// Whether the deletion was successful or not.
    public var responseMessage: Swift.String?

    public init (
        responseMessage: Swift.String? = nil
    )
    {
        self.responseMessage = responseMessage
    }
}

struct DeleteReportDefinitionOutputResponseBody: Swift.Equatable {
    let responseMessage: Swift.String?
}

extension DeleteReportDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseMessage = "ResponseMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseMessage)
        responseMessage = responseMessageDecoded
    }
}

extension DescribeReportDefinitionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeReportDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Requests a list of AWS Cost and Usage reports owned by the account.
public struct DescribeReportDefinitionsInput: Swift.Equatable {
    /// The maximum number of results that AWS returns for the operation.
    public var maxResults: Swift.Int?
    /// A generic string.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeReportDefinitionsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeReportDefinitionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeReportDefinitionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReportDefinitionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReportDefinitionsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReportDefinitionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReportDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reportDefinitions = output.reportDefinitions
        } else {
            self.nextToken = nil
            self.reportDefinitions = nil
        }
    }
}

/// If the action is successful, the service sends back an HTTP 200 response.
public struct DescribeReportDefinitionsOutputResponse: Swift.Equatable {
    /// A generic string.
    public var nextToken: Swift.String?
    /// A list of AWS Cost and Usage reports owned by the account.
    public var reportDefinitions: [CostAndUsageReportClientTypes.ReportDefinition]?

    public init (
        nextToken: Swift.String? = nil,
        reportDefinitions: [CostAndUsageReportClientTypes.ReportDefinition]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportDefinitions = reportDefinitions
    }
}

struct DescribeReportDefinitionsOutputResponseBody: Swift.Equatable {
    let reportDefinitions: [CostAndUsageReportClientTypes.ReportDefinition]?
    let nextToken: Swift.String?
}

extension DescribeReportDefinitionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case reportDefinitions = "ReportDefinitions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportDefinitionsContainer = try containerValues.decodeIfPresent([CostAndUsageReportClientTypes.ReportDefinition?].self, forKey: .reportDefinitions)
        var reportDefinitionsDecoded0:[CostAndUsageReportClientTypes.ReportDefinition]? = nil
        if let reportDefinitionsContainer = reportDefinitionsContainer {
            reportDefinitionsDecoded0 = [CostAndUsageReportClientTypes.ReportDefinition]()
            for structure0 in reportDefinitionsContainer {
                if let structure0 = structure0 {
                    reportDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        reportDefinitions = reportDefinitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DuplicateReportNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DuplicateReportNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A report with the specified name already exists in the account. Specify a different report name.
public struct DuplicateReportNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A message to show the detail of the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateReportNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicateReportNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error on the server occurred during the processing of your request. Try again later.
public struct InternalErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// A message to show the detail of the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ModifyReportDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportDefinition = "ReportDefinition"
        case reportName = "ReportName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reportDefinition = reportDefinition {
            try encodeContainer.encode(reportDefinition, forKey: .reportDefinition)
        }
        if let reportName = reportName {
            try encodeContainer.encode(reportName, forKey: .reportName)
        }
    }
}

extension ModifyReportDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyReportDefinitionInput: Swift.Equatable {
    /// The definition of AWS Cost and Usage Report. You can specify the report name, time unit, report format, compression format, S3 bucket, additional artifacts, and schema elements in the definition.
    /// This member is required.
    public var reportDefinition: CostAndUsageReportClientTypes.ReportDefinition?
    /// The name of the report that you want to create. The name must be unique, is case sensitive, and can't include spaces.
    /// This member is required.
    public var reportName: Swift.String?

    public init (
        reportDefinition: CostAndUsageReportClientTypes.ReportDefinition? = nil,
        reportName: Swift.String? = nil
    )
    {
        self.reportDefinition = reportDefinition
        self.reportName = reportName
    }
}

struct ModifyReportDefinitionInputBody: Swift.Equatable {
    let reportName: Swift.String?
    let reportDefinition: CostAndUsageReportClientTypes.ReportDefinition?
}

extension ModifyReportDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportDefinition = "ReportDefinition"
        case reportName = "ReportName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportName)
        reportName = reportNameDecoded
        let reportDefinitionDecoded = try containerValues.decodeIfPresent(CostAndUsageReportClientTypes.ReportDefinition.self, forKey: .reportDefinition)
        reportDefinition = reportDefinitionDecoded
    }
}

extension ModifyReportDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyReportDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyReportDefinitionOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyReportDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ModifyReportDefinitionOutputResponse: Swift.Equatable {

}

extension PutReportDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportDefinition = "ReportDefinition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reportDefinition = reportDefinition {
            try encodeContainer.encode(reportDefinition, forKey: .reportDefinition)
        }
    }
}

extension PutReportDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Creates a Cost and Usage Report.
public struct PutReportDefinitionInput: Swift.Equatable {
    /// Represents the output of the PutReportDefinition operation. The content consists of the detailed metadata and data file information.
    /// This member is required.
    public var reportDefinition: CostAndUsageReportClientTypes.ReportDefinition?

    public init (
        reportDefinition: CostAndUsageReportClientTypes.ReportDefinition? = nil
    )
    {
        self.reportDefinition = reportDefinition
    }
}

struct PutReportDefinitionInputBody: Swift.Equatable {
    let reportDefinition: CostAndUsageReportClientTypes.ReportDefinition?
}

extension PutReportDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportDefinition = "ReportDefinition"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportDefinitionDecoded = try containerValues.decodeIfPresent(CostAndUsageReportClientTypes.ReportDefinition.self, forKey: .reportDefinition)
        reportDefinition = reportDefinitionDecoded
    }
}

extension PutReportDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutReportDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateReportNameException" : self = .duplicateReportNameException(try DuplicateReportNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReportLimitReachedException" : self = .reportLimitReachedException(try ReportLimitReachedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutReportDefinitionOutputError: Swift.Error, Swift.Equatable {
    case duplicateReportNameException(DuplicateReportNameException)
    case internalErrorException(InternalErrorException)
    case reportLimitReachedException(ReportLimitReachedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutReportDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// If the action is successful, the service sends back an HTTP 200 response with an empty HTTP body.
public struct PutReportDefinitionOutputResponse: Swift.Equatable {

}

extension CostAndUsageReportClientTypes.ReportDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalArtifacts = "AdditionalArtifacts"
        case additionalSchemaElements = "AdditionalSchemaElements"
        case billingViewArn = "BillingViewArn"
        case compression = "Compression"
        case format = "Format"
        case refreshClosedReports = "RefreshClosedReports"
        case reportName = "ReportName"
        case reportVersioning = "ReportVersioning"
        case s3Bucket = "S3Bucket"
        case s3Prefix = "S3Prefix"
        case s3Region = "S3Region"
        case timeUnit = "TimeUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalArtifacts = additionalArtifacts {
            var additionalArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalArtifacts)
            for additionalartifactlist0 in additionalArtifacts {
                try additionalArtifactsContainer.encode(additionalartifactlist0.rawValue)
            }
        }
        if let additionalSchemaElements = additionalSchemaElements {
            var additionalSchemaElementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalSchemaElements)
            for schemaelementlist0 in additionalSchemaElements {
                try additionalSchemaElementsContainer.encode(schemaelementlist0.rawValue)
            }
        }
        if let billingViewArn = billingViewArn {
            try encodeContainer.encode(billingViewArn, forKey: .billingViewArn)
        }
        if let compression = compression {
            try encodeContainer.encode(compression.rawValue, forKey: .compression)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let refreshClosedReports = refreshClosedReports {
            try encodeContainer.encode(refreshClosedReports, forKey: .refreshClosedReports)
        }
        if let reportName = reportName {
            try encodeContainer.encode(reportName, forKey: .reportName)
        }
        if let reportVersioning = reportVersioning {
            try encodeContainer.encode(reportVersioning.rawValue, forKey: .reportVersioning)
        }
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Prefix = s3Prefix {
            try encodeContainer.encode(s3Prefix, forKey: .s3Prefix)
        }
        if let s3Region = s3Region {
            try encodeContainer.encode(s3Region.rawValue, forKey: .s3Region)
        }
        if let timeUnit = timeUnit {
            try encodeContainer.encode(timeUnit.rawValue, forKey: .timeUnit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportName)
        reportName = reportNameDecoded
        let timeUnitDecoded = try containerValues.decodeIfPresent(CostAndUsageReportClientTypes.TimeUnit.self, forKey: .timeUnit)
        timeUnit = timeUnitDecoded
        let formatDecoded = try containerValues.decodeIfPresent(CostAndUsageReportClientTypes.ReportFormat.self, forKey: .format)
        format = formatDecoded
        let compressionDecoded = try containerValues.decodeIfPresent(CostAndUsageReportClientTypes.CompressionFormat.self, forKey: .compression)
        compression = compressionDecoded
        let additionalSchemaElementsContainer = try containerValues.decodeIfPresent([CostAndUsageReportClientTypes.SchemaElement?].self, forKey: .additionalSchemaElements)
        var additionalSchemaElementsDecoded0:[CostAndUsageReportClientTypes.SchemaElement]? = nil
        if let additionalSchemaElementsContainer = additionalSchemaElementsContainer {
            additionalSchemaElementsDecoded0 = [CostAndUsageReportClientTypes.SchemaElement]()
            for string0 in additionalSchemaElementsContainer {
                if let string0 = string0 {
                    additionalSchemaElementsDecoded0?.append(string0)
                }
            }
        }
        additionalSchemaElements = additionalSchemaElementsDecoded0
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
        let s3RegionDecoded = try containerValues.decodeIfPresent(CostAndUsageReportClientTypes.AWSRegion.self, forKey: .s3Region)
        s3Region = s3RegionDecoded
        let additionalArtifactsContainer = try containerValues.decodeIfPresent([CostAndUsageReportClientTypes.AdditionalArtifact?].self, forKey: .additionalArtifacts)
        var additionalArtifactsDecoded0:[CostAndUsageReportClientTypes.AdditionalArtifact]? = nil
        if let additionalArtifactsContainer = additionalArtifactsContainer {
            additionalArtifactsDecoded0 = [CostAndUsageReportClientTypes.AdditionalArtifact]()
            for string0 in additionalArtifactsContainer {
                if let string0 = string0 {
                    additionalArtifactsDecoded0?.append(string0)
                }
            }
        }
        additionalArtifacts = additionalArtifactsDecoded0
        let refreshClosedReportsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .refreshClosedReports)
        refreshClosedReports = refreshClosedReportsDecoded
        let reportVersioningDecoded = try containerValues.decodeIfPresent(CostAndUsageReportClientTypes.ReportVersioning.self, forKey: .reportVersioning)
        reportVersioning = reportVersioningDecoded
        let billingViewArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingViewArn)
        billingViewArn = billingViewArnDecoded
    }
}

extension CostAndUsageReportClientTypes {
    /// The definition of AWS Cost and Usage Report. You can specify the report name, time unit, report format, compression format, S3 bucket, additional artifacts, and schema elements in the definition.
    public struct ReportDefinition: Swift.Equatable {
        /// A list of manifests that you want Amazon Web Services to create for this report.
        public var additionalArtifacts: [CostAndUsageReportClientTypes.AdditionalArtifact]?
        /// A list of strings that indicate additional content that Amazon Web Services includes in the report, such as individual resource IDs.
        /// This member is required.
        public var additionalSchemaElements: [CostAndUsageReportClientTypes.SchemaElement]?
        /// The Amazon resource name of the billing view. You can get this value by using the billing view service public APIs.
        public var billingViewArn: Swift.String?
        /// The compression format that AWS uses for the report.
        /// This member is required.
        public var compression: CostAndUsageReportClientTypes.CompressionFormat?
        /// The format that AWS saves the report in.
        /// This member is required.
        public var format: CostAndUsageReportClientTypes.ReportFormat?
        /// Whether you want Amazon Web Services to update your reports after they have been finalized if Amazon Web Services detects charges related to previous months. These charges can include refunds, credits, or support fees.
        public var refreshClosedReports: Swift.Bool?
        /// The name of the report that you want to create. The name must be unique, is case sensitive, and can't include spaces.
        /// This member is required.
        public var reportName: Swift.String?
        /// Whether you want Amazon Web Services to overwrite the previous version of each report or to deliver the report in addition to the previous versions.
        public var reportVersioning: CostAndUsageReportClientTypes.ReportVersioning?
        /// The S3 bucket where AWS delivers the report.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The prefix that AWS adds to the report name when AWS delivers the report. Your prefix can't include spaces.
        /// This member is required.
        public var s3Prefix: Swift.String?
        /// The region of the S3 bucket that AWS delivers the report into.
        /// This member is required.
        public var s3Region: CostAndUsageReportClientTypes.AWSRegion?
        /// The length of time covered by the report.
        /// This member is required.
        public var timeUnit: CostAndUsageReportClientTypes.TimeUnit?

        public init (
            additionalArtifacts: [CostAndUsageReportClientTypes.AdditionalArtifact]? = nil,
            additionalSchemaElements: [CostAndUsageReportClientTypes.SchemaElement]? = nil,
            billingViewArn: Swift.String? = nil,
            compression: CostAndUsageReportClientTypes.CompressionFormat? = nil,
            format: CostAndUsageReportClientTypes.ReportFormat? = nil,
            refreshClosedReports: Swift.Bool? = nil,
            reportName: Swift.String? = nil,
            reportVersioning: CostAndUsageReportClientTypes.ReportVersioning? = nil,
            s3Bucket: Swift.String? = nil,
            s3Prefix: Swift.String? = nil,
            s3Region: CostAndUsageReportClientTypes.AWSRegion? = nil,
            timeUnit: CostAndUsageReportClientTypes.TimeUnit? = nil
        )
        {
            self.additionalArtifacts = additionalArtifacts
            self.additionalSchemaElements = additionalSchemaElements
            self.billingViewArn = billingViewArn
            self.compression = compression
            self.format = format
            self.refreshClosedReports = refreshClosedReports
            self.reportName = reportName
            self.reportVersioning = reportVersioning
            self.s3Bucket = s3Bucket
            self.s3Prefix = s3Prefix
            self.s3Region = s3Region
            self.timeUnit = timeUnit
        }
    }

}

extension CostAndUsageReportClientTypes {
    /// The format that AWS saves the report in.
    public enum ReportFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportFormat] {
            return [
                .csv,
                .parquet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "textORcsv"
            case .parquet: return "Parquet"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportFormat(rawValue: rawValue) ?? ReportFormat.sdkUnknown(rawValue)
        }
    }
}

extension ReportLimitReachedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ReportLimitReachedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This account already has five reports defined. To define a new report, you must delete an existing report.
public struct ReportLimitReachedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A message to show the detail of the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReportLimitReachedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReportLimitReachedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CostAndUsageReportClientTypes {
    public enum ReportVersioning: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createNewReport
        case overwriteReport
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportVersioning] {
            return [
                .createNewReport,
                .overwriteReport,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createNewReport: return "CREATE_NEW_REPORT"
            case .overwriteReport: return "OVERWRITE_REPORT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportVersioning(rawValue: rawValue) ?? ReportVersioning.sdkUnknown(rawValue)
        }
    }
}

extension CostAndUsageReportClientTypes {
    /// Whether or not AWS includes resource IDs in the report.
    public enum SchemaElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case resources
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaElement] {
            return [
                .resources,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .resources: return "RESOURCES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SchemaElement(rawValue: rawValue) ?? SchemaElement.sdkUnknown(rawValue)
        }
    }
}

extension CostAndUsageReportClientTypes {
    /// The length of time covered by the report.
    public enum TimeUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daily
        case hourly
        case monthly
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeUnit] {
            return [
                .daily,
                .hourly,
                .monthly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daily: return "DAILY"
            case .hourly: return "HOURLY"
            case .monthly: return "MONTHLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimeUnit(rawValue: rawValue) ?? TimeUnit.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A message to show the detail of the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
