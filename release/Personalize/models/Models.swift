// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension Algorithm: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case algorithmArn
        case algorithmImage
        case creationDateTime
        case defaultHyperParameterRanges
        case defaultHyperParameters
        case defaultResourceConfig
        case lastUpdatedDateTime
        case name
        case roleArn
        case trainingInputMode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
        if let algorithmImage = algorithmImage {
            try encodeContainer.encode(algorithmImage, forKey: .algorithmImage)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let defaultHyperParameterRanges = defaultHyperParameterRanges {
            try encodeContainer.encode(defaultHyperParameterRanges, forKey: .defaultHyperParameterRanges)
        }
        if let defaultHyperParameters = defaultHyperParameters {
            var defaultHyperParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .defaultHyperParameters)
            for (dictKey0, hyperparameters0) in defaultHyperParameters {
                try defaultHyperParametersContainer.encode(hyperparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let defaultResourceConfig = defaultResourceConfig {
            var defaultResourceConfigContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .defaultResourceConfig)
            for (dictKey0, resourceconfig0) in defaultResourceConfig {
                try defaultResourceConfigContainer.encode(resourceconfig0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let trainingInputMode = trainingInputMode {
            try encodeContainer.encode(trainingInputMode, forKey: .trainingInputMode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let algorithmArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let algorithmImageDecoded = try containerValues.decodeIfPresent(AlgorithmImage.self, forKey: .algorithmImage)
        algorithmImage = algorithmImageDecoded
        let defaultHyperParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .defaultHyperParameters)
        var defaultHyperParametersDecoded0: [String:String]? = nil
        if let defaultHyperParametersContainer = defaultHyperParametersContainer {
            defaultHyperParametersDecoded0 = [String:String]()
            for (key0, parametervalue0) in defaultHyperParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    defaultHyperParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        defaultHyperParameters = defaultHyperParametersDecoded0
        let defaultHyperParameterRangesDecoded = try containerValues.decodeIfPresent(DefaultHyperParameterRanges.self, forKey: .defaultHyperParameterRanges)
        defaultHyperParameterRanges = defaultHyperParameterRangesDecoded
        let defaultResourceConfigContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .defaultResourceConfig)
        var defaultResourceConfigDecoded0: [String:String]? = nil
        if let defaultResourceConfigContainer = defaultResourceConfigContainer {
            defaultResourceConfigDecoded0 = [String:String]()
            for (key0, parametervalue0) in defaultResourceConfigContainer {
                if let parametervalue0 = parametervalue0 {
                    defaultResourceConfigDecoded0?[key0] = parametervalue0
                }
            }
        }
        defaultResourceConfig = defaultResourceConfigDecoded0
        let trainingInputModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trainingInputMode)
        trainingInputMode = trainingInputModeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension Algorithm: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Algorithm(algorithmArn: \(String(describing: algorithmArn)), algorithmImage: \(String(describing: algorithmImage)), creationDateTime: \(String(describing: creationDateTime)), defaultHyperParameterRanges: \(String(describing: defaultHyperParameterRanges)), defaultHyperParameters: \(String(describing: defaultHyperParameters)), defaultResourceConfig: \(String(describing: defaultResourceConfig)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), trainingInputMode: \(String(describing: trainingInputMode)))"}
}

/// <p>Describes a custom algorithm.</p>
public struct Algorithm: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the algorithm.</p>
    public let algorithmArn: String?
    /// <p>The URI of the Docker container for the algorithm image.</p>
    public let algorithmImage: AlgorithmImage?
    /// <p>The date and time (in Unix time) that the algorithm was created.</p>
    public let creationDateTime: Date?
    /// <p>Specifies the default hyperparameters, their ranges, and whether they
    ///       are tunable. A tunable hyperparameter can
    ///       have its value determined during hyperparameter optimization (HPO).</p>
    public let defaultHyperParameterRanges: DefaultHyperParameterRanges?
    /// <p>Specifies the default hyperparameters.</p>
    public let defaultHyperParameters: [String:String]?
    /// <p>Specifies the default maximum number of training jobs and parallel training jobs.</p>
    public let defaultResourceConfig: [String:String]?
    /// <p>The date and time (in Unix time) that the algorithm was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The name of the algorithm.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the role.</p>
    public let roleArn: String?
    /// <p>The training input mode.</p>
    public let trainingInputMode: String?

    public init (
        algorithmArn: String? = nil,
        algorithmImage: AlgorithmImage? = nil,
        creationDateTime: Date? = nil,
        defaultHyperParameterRanges: DefaultHyperParameterRanges? = nil,
        defaultHyperParameters: [String:String]? = nil,
        defaultResourceConfig: [String:String]? = nil,
        lastUpdatedDateTime: Date? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        trainingInputMode: String? = nil
    )
    {
        self.algorithmArn = algorithmArn
        self.algorithmImage = algorithmImage
        self.creationDateTime = creationDateTime
        self.defaultHyperParameterRanges = defaultHyperParameterRanges
        self.defaultHyperParameters = defaultHyperParameters
        self.defaultResourceConfig = defaultResourceConfig
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.name = name
        self.roleArn = roleArn
        self.trainingInputMode = trainingInputMode
    }
}

extension AlgorithmImage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dockerURI
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dockerURI = dockerURI {
            try encodeContainer.encode(dockerURI, forKey: .dockerURI)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let dockerURIDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dockerURI)
        dockerURI = dockerURIDecoded
    }
}

extension AlgorithmImage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlgorithmImage(dockerURI: \(String(describing: dockerURI)), name: \(String(describing: name)))"}
}

/// <p>Describes an algorithm image.</p>
public struct AlgorithmImage: Equatable {
    /// <p>The URI of the Docker container for the algorithm image.</p>
    public let dockerURI: String?
    /// <p>The name of the algorithm image.</p>
    public let name: String?

    public init (
        dockerURI: String? = nil,
        name: String? = nil
    )
    {
        self.dockerURI = dockerURI
        self.name = name
    }
}

extension AutoMLConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case metricName
        case recipeList
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let recipeList = recipeList {
            var recipeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recipeList)
            for arnlist0 in recipeList {
                try recipeListContainer.encode(arnlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let recipeListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .recipeList)
        var recipeListDecoded0:[String]? = nil
        if let recipeListContainer = recipeListContainer {
            recipeListDecoded0 = [String]()
            for string0 in recipeListContainer {
                if let string0 = string0 {
                    recipeListDecoded0?.append(string0)
                }
            }
        }
        recipeList = recipeListDecoded0
    }
}

extension AutoMLConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutoMLConfig(metricName: \(String(describing: metricName)), recipeList: \(String(describing: recipeList)))"}
}

/// <p>When the solution performs AutoML (<code>performAutoML</code> is true in
///       <a>CreateSolution</a>), Amazon Personalize
///       determines which recipe, from the specified list, optimizes the given metric.
///       Amazon Personalize then uses that recipe for the solution.</p>
public struct AutoMLConfig: Equatable {
    /// <p>The metric to optimize.</p>
    public let metricName: String?
    /// <p>The list of candidate recipes.</p>
    public let recipeList: [String]?

    public init (
        metricName: String? = nil,
        recipeList: [String]? = nil
    )
    {
        self.metricName = metricName
        self.recipeList = recipeList
    }
}

extension AutoMLResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bestRecipeArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bestRecipeArn = bestRecipeArn {
            try encodeContainer.encode(bestRecipeArn, forKey: .bestRecipeArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bestRecipeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bestRecipeArn)
        bestRecipeArn = bestRecipeArnDecoded
    }
}

extension AutoMLResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutoMLResult(bestRecipeArn: \(String(describing: bestRecipeArn)))"}
}

/// <p>When the solution performs AutoML (<code>performAutoML</code> is true in
///       <a>CreateSolution</a>), specifies the recipe that best optimized the
///       specified metric.</p>
public struct AutoMLResult: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the best recipe.</p>
    public let bestRecipeArn: String?

    public init (
        bestRecipeArn: String? = nil
    )
    {
        self.bestRecipeArn = bestRecipeArn
    }
}

extension BatchInferenceJob: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case batchInferenceJobArn
        case batchInferenceJobConfig
        case creationDateTime
        case failureReason
        case filterArn
        case jobInput
        case jobName
        case jobOutput
        case lastUpdatedDateTime
        case numResults
        case roleArn
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchInferenceJobArn = batchInferenceJobArn {
            try encodeContainer.encode(batchInferenceJobArn, forKey: .batchInferenceJobArn)
        }
        if let batchInferenceJobConfig = batchInferenceJobConfig {
            try encodeContainer.encode(batchInferenceJobConfig, forKey: .batchInferenceJobConfig)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let filterArn = filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let jobInput = jobInput {
            try encodeContainer.encode(jobInput, forKey: .jobInput)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutput = jobOutput {
            try encodeContainer.encode(jobOutput, forKey: .jobOutput)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let numResults = numResults {
            try encodeContainer.encode(numResults, forKey: .numResults)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let batchInferenceJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .batchInferenceJobArn)
        batchInferenceJobArn = batchInferenceJobArnDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let jobInputDecoded = try containerValues.decodeIfPresent(BatchInferenceJobInput.self, forKey: .jobInput)
        jobInput = jobInputDecoded
        let jobOutputDecoded = try containerValues.decodeIfPresent(BatchInferenceJobOutput.self, forKey: .jobOutput)
        jobOutput = jobOutputDecoded
        let batchInferenceJobConfigDecoded = try containerValues.decodeIfPresent(BatchInferenceJobConfig.self, forKey: .batchInferenceJobConfig)
        batchInferenceJobConfig = batchInferenceJobConfigDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension BatchInferenceJob: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchInferenceJob(batchInferenceJobArn: \(String(describing: batchInferenceJobArn)), batchInferenceJobConfig: \(String(describing: batchInferenceJobConfig)), creationDateTime: \(String(describing: creationDateTime)), failureReason: \(String(describing: failureReason)), filterArn: \(String(describing: filterArn)), jobInput: \(String(describing: jobInput)), jobName: \(String(describing: jobName)), jobOutput: \(String(describing: jobOutput)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), numResults: \(String(describing: numResults)), roleArn: \(String(describing: roleArn)), solutionVersionArn: \(String(describing: solutionVersionArn)), status: \(String(describing: status)))"}
}

/// <p>Contains information on a batch inference job.</p>
public struct BatchInferenceJob: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the batch inference job.</p>
    public let batchInferenceJobArn: String?
    /// <p>A string to string map of the configuration details of a batch inference job.</p>
    public let batchInferenceJobConfig: BatchInferenceJobConfig?
    /// <p>The time at which the batch inference job was created.</p>
    public let creationDateTime: Date?
    /// <p>If the batch inference job failed, the reason for the failure.</p>
    public let failureReason: String?
    /// <p>The ARN of the filter used on the batch inference job.</p>
    public let filterArn: String?
    /// <p>The Amazon S3 path that leads to the input data used to generate the batch inference
    ///       job.</p>
    public let jobInput: BatchInferenceJobInput?
    /// <p>The name of the batch inference job.</p>
    public let jobName: String?
    /// <p>The Amazon S3 bucket that contains the output data generated by the batch inference job.</p>
    public let jobOutput: BatchInferenceJobOutput?
    /// <p>The time at which the batch inference job was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The number of recommendations generated by the batch inference job. This number includes
    ///       the error messages generated for failed input records.</p>
    public let numResults: Int?
    /// <p>The ARN of the Amazon Identity and Access Management (IAM) role that requested the batch inference job.</p>
    public let roleArn: String?
    /// <p>The Amazon Resource Name (ARN) of the solution version from which the batch inference job
    ///       was created.</p>
    public let solutionVersionArn: String?
    /// <p>The status of the batch inference job. The status is one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>PENDING</p>
    ///             </li>
    ///             <li>
    ///                <p>IN PROGRESS</p>
    ///             </li>
    ///             <li>
    ///                <p>ACTIVE</p>
    ///             </li>
    ///             <li>
    ///                <p>CREATE FAILED</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        batchInferenceJobArn: String? = nil,
        batchInferenceJobConfig: BatchInferenceJobConfig? = nil,
        creationDateTime: Date? = nil,
        failureReason: String? = nil,
        filterArn: String? = nil,
        jobInput: BatchInferenceJobInput? = nil,
        jobName: String? = nil,
        jobOutput: BatchInferenceJobOutput? = nil,
        lastUpdatedDateTime: Date? = nil,
        numResults: Int? = nil,
        roleArn: String? = nil,
        solutionVersionArn: String? = nil,
        status: String? = nil
    )
    {
        self.batchInferenceJobArn = batchInferenceJobArn
        self.batchInferenceJobConfig = batchInferenceJobConfig
        self.creationDateTime = creationDateTime
        self.failureReason = failureReason
        self.filterArn = filterArn
        self.jobInput = jobInput
        self.jobName = jobName
        self.jobOutput = jobOutput
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.numResults = numResults
        self.roleArn = roleArn
        self.solutionVersionArn = solutionVersionArn
        self.status = status
    }
}

extension BatchInferenceJobConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case itemExplorationConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let itemExplorationConfig = itemExplorationConfig {
            var itemExplorationConfigContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .itemExplorationConfig)
            for (dictKey0, hyperparameters0) in itemExplorationConfig {
                try itemExplorationConfigContainer.encode(hyperparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemExplorationConfigContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .itemExplorationConfig)
        var itemExplorationConfigDecoded0: [String:String]? = nil
        if let itemExplorationConfigContainer = itemExplorationConfigContainer {
            itemExplorationConfigDecoded0 = [String:String]()
            for (key0, parametervalue0) in itemExplorationConfigContainer {
                if let parametervalue0 = parametervalue0 {
                    itemExplorationConfigDecoded0?[key0] = parametervalue0
                }
            }
        }
        itemExplorationConfig = itemExplorationConfigDecoded0
    }
}

extension BatchInferenceJobConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchInferenceJobConfig(itemExplorationConfig: \(String(describing: itemExplorationConfig)))"}
}

/// <p>The configuration details of a batch inference job.</p>
public struct BatchInferenceJobConfig: Equatable {
    /// <p>A string to string map specifying the exploration configuration hyperparameters, including <code>explorationWeight</code> and
    ///       <code>explorationItemAgeCutOff</code>, you want to use to configure the amount of item exploration Amazon Personalize uses when
    ///       recommending items.
    ///       See <a href="https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-new-item-USER_PERSONALIZATION.html">User-Personalization</a>.</p>
    public let itemExplorationConfig: [String:String]?

    public init (
        itemExplorationConfig: [String:String]? = nil
    )
    {
        self.itemExplorationConfig = itemExplorationConfig
    }
}

extension BatchInferenceJobInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3DataSource
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3DataSource = s3DataSource {
            try encodeContainer.encode(s3DataSource, forKey: .s3DataSource)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataSourceDecoded = try containerValues.decodeIfPresent(S3DataConfig.self, forKey: .s3DataSource)
        s3DataSource = s3DataSourceDecoded
    }
}

extension BatchInferenceJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchInferenceJobInput(s3DataSource: \(String(describing: s3DataSource)))"}
}

/// <p>The input configuration of a batch inference job.</p>
public struct BatchInferenceJobInput: Equatable {
    /// <p>The URI of the Amazon S3 location that contains your input data. The Amazon S3 bucket must be in the
    ///       same region as the API endpoint you are calling.</p>
    public let s3DataSource: S3DataConfig?

    public init (
        s3DataSource: S3DataConfig? = nil
    )
    {
        self.s3DataSource = s3DataSource
    }
}

extension BatchInferenceJobOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3DataDestination
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3DataDestination = s3DataDestination {
            try encodeContainer.encode(s3DataDestination, forKey: .s3DataDestination)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataDestinationDecoded = try containerValues.decodeIfPresent(S3DataConfig.self, forKey: .s3DataDestination)
        s3DataDestination = s3DataDestinationDecoded
    }
}

extension BatchInferenceJobOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchInferenceJobOutput(s3DataDestination: \(String(describing: s3DataDestination)))"}
}

/// <p>The output configuration parameters of a batch inference job.</p>
public struct BatchInferenceJobOutput: Equatable {
    /// <p>Information on the Amazon S3 bucket in which the batch inference job's output is stored.</p>
    public let s3DataDestination: S3DataConfig?

    public init (
        s3DataDestination: S3DataConfig? = nil
    )
    {
        self.s3DataDestination = s3DataDestination
    }
}

extension BatchInferenceJobSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case batchInferenceJobArn
        case creationDateTime
        case failureReason
        case jobName
        case lastUpdatedDateTime
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchInferenceJobArn = batchInferenceJobArn {
            try encodeContainer.encode(batchInferenceJobArn, forKey: .batchInferenceJobArn)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchInferenceJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .batchInferenceJobArn)
        batchInferenceJobArn = batchInferenceJobArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
    }
}

extension BatchInferenceJobSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchInferenceJobSummary(batchInferenceJobArn: \(String(describing: batchInferenceJobArn)), creationDateTime: \(String(describing: creationDateTime)), failureReason: \(String(describing: failureReason)), jobName: \(String(describing: jobName)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), solutionVersionArn: \(String(describing: solutionVersionArn)), status: \(String(describing: status)))"}
}

/// <p>A truncated version of the <a>BatchInferenceJob</a> datatype. The <a>ListBatchInferenceJobs</a> operation returns a list of batch inference job
///       summaries.</p>
public struct BatchInferenceJobSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the batch inference job.</p>
    public let batchInferenceJobArn: String?
    /// <p>The time at which the batch inference job was created.</p>
    public let creationDateTime: Date?
    /// <p>If the batch inference job failed, the reason for the failure.</p>
    public let failureReason: String?
    /// <p>The name of the batch inference job.</p>
    public let jobName: String?
    /// <p>The time at which the batch inference job was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The ARN of the solution version used by the batch inference job.</p>
    public let solutionVersionArn: String?
    /// <p>The status of the batch inference job. The status is one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>PENDING</p>
    ///             </li>
    ///             <li>
    ///                <p>IN PROGRESS</p>
    ///             </li>
    ///             <li>
    ///                <p>ACTIVE</p>
    ///             </li>
    ///             <li>
    ///                <p>CREATE FAILED</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        batchInferenceJobArn: String? = nil,
        creationDateTime: Date? = nil,
        failureReason: String? = nil,
        jobName: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        solutionVersionArn: String? = nil,
        status: String? = nil
    )
    {
        self.batchInferenceJobArn = batchInferenceJobArn
        self.creationDateTime = creationDateTime
        self.failureReason = failureReason
        self.jobName = jobName
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.solutionVersionArn = solutionVersionArn
        self.status = status
    }
}

extension Campaign: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case campaignArn
        case campaignConfig
        case creationDateTime
        case failureReason
        case lastUpdatedDateTime
        case latestCampaignUpdate
        case minProvisionedTPS
        case name
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
        if let campaignConfig = campaignConfig {
            try encodeContainer.encode(campaignConfig, forKey: .campaignConfig)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let latestCampaignUpdate = latestCampaignUpdate {
            try encodeContainer.encode(latestCampaignUpdate, forKey: .latestCampaignUpdate)
        }
        if let minProvisionedTPS = minProvisionedTPS {
            try encodeContainer.encode(minProvisionedTPS, forKey: .minProvisionedTPS)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let campaignArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let minProvisionedTPSDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minProvisionedTPS)
        minProvisionedTPS = minProvisionedTPSDecoded
        let campaignConfigDecoded = try containerValues.decodeIfPresent(CampaignConfig.self, forKey: .campaignConfig)
        campaignConfig = campaignConfigDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let latestCampaignUpdateDecoded = try containerValues.decodeIfPresent(CampaignUpdateSummary.self, forKey: .latestCampaignUpdate)
        latestCampaignUpdate = latestCampaignUpdateDecoded
    }
}

extension Campaign: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Campaign(campaignArn: \(String(describing: campaignArn)), campaignConfig: \(String(describing: campaignConfig)), creationDateTime: \(String(describing: creationDateTime)), failureReason: \(String(describing: failureReason)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), latestCampaignUpdate: \(String(describing: latestCampaignUpdate)), minProvisionedTPS: \(String(describing: minProvisionedTPS)), name: \(String(describing: name)), solutionVersionArn: \(String(describing: solutionVersionArn)), status: \(String(describing: status)))"}
}

/// <p>Describes a deployed solution version, otherwise known as a campaign.
///       For more information on campaigns, see <a>CreateCampaign</a>.</p>
public struct Campaign: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the campaign. </p>
    public let campaignArn: String?
    /// <p>The configuration details of a campaign.</p>
    public let campaignConfig: CampaignConfig?
    /// <p>The date and time (in Unix format) that the campaign was created.</p>
    public let creationDateTime: Date?
    /// <p>If a campaign fails, the reason behind the failure.</p>
    public let failureReason: String?
    /// <p>The date and time (in Unix format) that the campaign was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>Provides a summary of the properties of a campaign update. For a complete listing, call the
    ///       <a>DescribeCampaign</a> API.</p>
    public let latestCampaignUpdate: CampaignUpdateSummary?
    /// <p>Specifies the requested minimum provisioned transactions (recommendations) per second.</p>
    public let minProvisionedTPS: Int?
    /// <p>The name of the campaign.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of a specific version of the solution.</p>
    public let solutionVersionArn: String?
    /// <p>The status of the campaign.</p>
    ///          <p>A campaign can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///             <li>
    ///                <p>DELETE PENDING > DELETE IN_PROGRESS</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        campaignArn: String? = nil,
        campaignConfig: CampaignConfig? = nil,
        creationDateTime: Date? = nil,
        failureReason: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        latestCampaignUpdate: CampaignUpdateSummary? = nil,
        minProvisionedTPS: Int? = nil,
        name: String? = nil,
        solutionVersionArn: String? = nil,
        status: String? = nil
    )
    {
        self.campaignArn = campaignArn
        self.campaignConfig = campaignConfig
        self.creationDateTime = creationDateTime
        self.failureReason = failureReason
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.latestCampaignUpdate = latestCampaignUpdate
        self.minProvisionedTPS = minProvisionedTPS
        self.name = name
        self.solutionVersionArn = solutionVersionArn
        self.status = status
    }
}

extension CampaignConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case itemExplorationConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let itemExplorationConfig = itemExplorationConfig {
            var itemExplorationConfigContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .itemExplorationConfig)
            for (dictKey0, hyperparameters0) in itemExplorationConfig {
                try itemExplorationConfigContainer.encode(hyperparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemExplorationConfigContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .itemExplorationConfig)
        var itemExplorationConfigDecoded0: [String:String]? = nil
        if let itemExplorationConfigContainer = itemExplorationConfigContainer {
            itemExplorationConfigDecoded0 = [String:String]()
            for (key0, parametervalue0) in itemExplorationConfigContainer {
                if let parametervalue0 = parametervalue0 {
                    itemExplorationConfigDecoded0?[key0] = parametervalue0
                }
            }
        }
        itemExplorationConfig = itemExplorationConfigDecoded0
    }
}

extension CampaignConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CampaignConfig(itemExplorationConfig: \(String(describing: itemExplorationConfig)))"}
}

/// <p>The configuration details of a campaign.</p>
public struct CampaignConfig: Equatable {
    /// <p>A string to string map specifying the exploration configuration hyperparameters, including <code>explorationWeight</code> and
    ///       <code>explorationItemAgeCutOff</code>, you want to use to configure the amount of item exploration Amazon Personalize uses when
    ///       recommending items. Provide <code>itemExplorationConfig</code> data only if your solution uses the
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-new-item-USER_PERSONALIZATION.html">User-Personalization</a> recipe.</p>
    public let itemExplorationConfig: [String:String]?

    public init (
        itemExplorationConfig: [String:String]? = nil
    )
    {
        self.itemExplorationConfig = itemExplorationConfig
    }
}

extension CampaignSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case campaignArn
        case creationDateTime
        case failureReason
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let campaignArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension CampaignSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CampaignSummary(campaignArn: \(String(describing: campaignArn)), creationDateTime: \(String(describing: creationDateTime)), failureReason: \(String(describing: failureReason)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), name: \(String(describing: name)), status: \(String(describing: status)))"}
}

/// <p>Provides a summary of the properties of a campaign. For a complete listing, call the
///       <a>DescribeCampaign</a> API.</p>
public struct CampaignSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the campaign.</p>
    public let campaignArn: String?
    /// <p>The date and time (in Unix time) that the campaign was created.</p>
    public let creationDateTime: Date?
    /// <p>If a campaign fails, the reason behind the failure.</p>
    public let failureReason: String?
    /// <p>The date and time (in Unix time) that the campaign was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The name of the campaign.</p>
    public let name: String?
    /// <p>The status of the campaign.</p>
    ///          <p>A campaign can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///             <li>
    ///                <p>DELETE PENDING > DELETE IN_PROGRESS</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        campaignArn: String? = nil,
        creationDateTime: Date? = nil,
        failureReason: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        name: String? = nil,
        status: String? = nil
    )
    {
        self.campaignArn = campaignArn
        self.creationDateTime = creationDateTime
        self.failureReason = failureReason
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.name = name
        self.status = status
    }
}

extension CampaignUpdateSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case campaignConfig
        case creationDateTime
        case failureReason
        case lastUpdatedDateTime
        case minProvisionedTPS
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignConfig = campaignConfig {
            try encodeContainer.encode(campaignConfig, forKey: .campaignConfig)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let minProvisionedTPS = minProvisionedTPS {
            try encodeContainer.encode(minProvisionedTPS, forKey: .minProvisionedTPS)
        }
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let minProvisionedTPSDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minProvisionedTPS)
        minProvisionedTPS = minProvisionedTPSDecoded
        let campaignConfigDecoded = try containerValues.decodeIfPresent(CampaignConfig.self, forKey: .campaignConfig)
        campaignConfig = campaignConfigDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension CampaignUpdateSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CampaignUpdateSummary(campaignConfig: \(String(describing: campaignConfig)), creationDateTime: \(String(describing: creationDateTime)), failureReason: \(String(describing: failureReason)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), minProvisionedTPS: \(String(describing: minProvisionedTPS)), solutionVersionArn: \(String(describing: solutionVersionArn)), status: \(String(describing: status)))"}
}

/// <p>Provides a summary of the properties of a campaign update. For a complete listing, call the
///       <a>DescribeCampaign</a> API.</p>
public struct CampaignUpdateSummary: Equatable {
    /// <p>The configuration details of a campaign.</p>
    public let campaignConfig: CampaignConfig?
    /// <p>The date and time (in Unix time) that the campaign update was created.</p>
    public let creationDateTime: Date?
    /// <p>If a campaign update fails, the reason behind the failure.</p>
    public let failureReason: String?
    /// <p>The date and time (in Unix time) that the campaign update was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>Specifies the requested minimum provisioned transactions (recommendations) per second that
    ///       Amazon Personalize will support.</p>
    public let minProvisionedTPS: Int?
    /// <p>The Amazon Resource Name (ARN) of the deployed solution version.</p>
    public let solutionVersionArn: String?
    /// <p>The status of the campaign update.</p>
    ///          <p>A campaign update can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///             <li>
    ///                <p>DELETE PENDING > DELETE IN_PROGRESS</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        campaignConfig: CampaignConfig? = nil,
        creationDateTime: Date? = nil,
        failureReason: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        minProvisionedTPS: Int? = nil,
        solutionVersionArn: String? = nil,
        status: String? = nil
    )
    {
        self.campaignConfig = campaignConfig
        self.creationDateTime = creationDateTime
        self.failureReason = failureReason
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.minProvisionedTPS = minProvisionedTPS
        self.solutionVersionArn = solutionVersionArn
        self.status = status
    }
}

extension CategoricalHyperParameterRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for categoricalvalues0 in values {
                try valuesContainer.encode(categoricalvalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension CategoricalHyperParameterRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CategoricalHyperParameterRange(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>Provides the name and range of a categorical hyperparameter.</p>
public struct CategoricalHyperParameterRange: Equatable {
    /// <p>The name of the hyperparameter.</p>
    public let name: String?
    /// <p>A list of the categories for the hyperparameter.</p>
    public let values: [String]?

    public init (
        name: String? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

extension ContinuousHyperParameterRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxValue
        case minValue
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxValue != 0.0 {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if minValue != 0.0 {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let minValueDecoded = try containerValues.decode(Double.self, forKey: .minValue)
        minValue = minValueDecoded
        let maxValueDecoded = try containerValues.decode(Double.self, forKey: .maxValue)
        maxValue = maxValueDecoded
    }
}

extension ContinuousHyperParameterRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContinuousHyperParameterRange(maxValue: \(String(describing: maxValue)), minValue: \(String(describing: minValue)), name: \(String(describing: name)))"}
}

/// <p>Provides the name and range of a continuous hyperparameter.</p>
public struct ContinuousHyperParameterRange: Equatable {
    /// <p>The maximum allowable value for the hyperparameter.</p>
    public let maxValue: Double
    /// <p>The minimum allowable value for the hyperparameter.</p>
    public let minValue: Double
    /// <p>The name of the hyperparameter.</p>
    public let name: String?

    public init (
        maxValue: Double = 0.0,
        minValue: Double = 0.0,
        name: String? = nil
    )
    {
        self.maxValue = maxValue
        self.minValue = minValue
        self.name = name
    }
}

public struct CreateBatchInferenceJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateBatchInferenceJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBatchInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBatchInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBatchInferenceJobInput>
    public typealias MOutput = OperationOutput<CreateBatchInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBatchInferenceJobOutputError>
}

extension CreateBatchInferenceJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBatchInferenceJobInput(batchInferenceJobConfig: \(String(describing: batchInferenceJobConfig)), filterArn: \(String(describing: filterArn)), jobInput: \(String(describing: jobInput)), jobName: \(String(describing: jobName)), jobOutput: \(String(describing: jobOutput)), numResults: \(String(describing: numResults)), roleArn: \(String(describing: roleArn)), solutionVersionArn: \(String(describing: solutionVersionArn)))"}
}

extension CreateBatchInferenceJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case batchInferenceJobConfig
        case filterArn
        case jobInput
        case jobName
        case jobOutput
        case numResults
        case roleArn
        case solutionVersionArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchInferenceJobConfig = batchInferenceJobConfig {
            try encodeContainer.encode(batchInferenceJobConfig, forKey: .batchInferenceJobConfig)
        }
        if let filterArn = filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let jobInput = jobInput {
            try encodeContainer.encode(jobInput, forKey: .jobInput)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutput = jobOutput {
            try encodeContainer.encode(jobOutput, forKey: .jobOutput)
        }
        if let numResults = numResults {
            try encodeContainer.encode(numResults, forKey: .numResults)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

public struct CreateBatchInferenceJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBatchInferenceJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBatchInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBatchInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBatchInferenceJobInput>
    public typealias MOutput = OperationOutput<CreateBatchInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBatchInferenceJobOutputError>
}

public struct CreateBatchInferenceJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBatchInferenceJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBatchInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBatchInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBatchInferenceJobInput>
    public typealias MOutput = OperationOutput<CreateBatchInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBatchInferenceJobOutputError>
}

public struct CreateBatchInferenceJobInput: Equatable {
    /// <p>The configuration details of a batch inference job.</p>
    public let batchInferenceJobConfig: BatchInferenceJobConfig?
    /// <p>The ARN of the filter to apply to the batch inference job. For more information on using
    ///       filters, see
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/filter-batch.html">Filtering Batch Recommendations</a>..</p>
    public let filterArn: String?
    /// <p>The Amazon S3 path that leads to the input file to base your recommendations on. The input
    ///       material must be in JSON format.</p>
    public let jobInput: BatchInferenceJobInput?
    /// <p>The name of the batch inference job to create.</p>
    public let jobName: String?
    /// <p>The path to the Amazon S3 bucket where the job's output will be stored.</p>
    public let jobOutput: BatchInferenceJobOutput?
    /// <p>The number of recommendations to retreive.</p>
    public let numResults: Int?
    /// <p>The ARN of the Amazon Identity and Access Management role that has permissions to read and write to your input and output
    ///       Amazon S3 buckets respectively.</p>
    public let roleArn: String?
    /// <p>The Amazon Resource Name (ARN) of the solution version that will be used to generate the
    ///       batch inference recommendations.</p>
    public let solutionVersionArn: String?

    public init (
        batchInferenceJobConfig: BatchInferenceJobConfig? = nil,
        filterArn: String? = nil,
        jobInput: BatchInferenceJobInput? = nil,
        jobName: String? = nil,
        jobOutput: BatchInferenceJobOutput? = nil,
        numResults: Int? = nil,
        roleArn: String? = nil,
        solutionVersionArn: String? = nil
    )
    {
        self.batchInferenceJobConfig = batchInferenceJobConfig
        self.filterArn = filterArn
        self.jobInput = jobInput
        self.jobName = jobName
        self.jobOutput = jobOutput
        self.numResults = numResults
        self.roleArn = roleArn
        self.solutionVersionArn = solutionVersionArn
    }
}

struct CreateBatchInferenceJobInputBody: Equatable {
    public let jobName: String?
    public let solutionVersionArn: String?
    public let filterArn: String?
    public let numResults: Int?
    public let jobInput: BatchInferenceJobInput?
    public let jobOutput: BatchInferenceJobOutput?
    public let roleArn: String?
    public let batchInferenceJobConfig: BatchInferenceJobConfig?
}

extension CreateBatchInferenceJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case batchInferenceJobConfig
        case filterArn
        case jobInput
        case jobName
        case jobOutput
        case numResults
        case roleArn
        case solutionVersionArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let jobInputDecoded = try containerValues.decodeIfPresent(BatchInferenceJobInput.self, forKey: .jobInput)
        jobInput = jobInputDecoded
        let jobOutputDecoded = try containerValues.decodeIfPresent(BatchInferenceJobOutput.self, forKey: .jobOutput)
        jobOutput = jobOutputDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let batchInferenceJobConfigDecoded = try containerValues.decodeIfPresent(BatchInferenceJobConfig.self, forKey: .batchInferenceJobConfig)
        batchInferenceJobConfig = batchInferenceJobConfigDecoded
    }
}

extension CreateBatchInferenceJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBatchInferenceJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBatchInferenceJobOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBatchInferenceJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBatchInferenceJobOutputResponse(batchInferenceJobArn: \(String(describing: batchInferenceJobArn)))"}
}

extension CreateBatchInferenceJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateBatchInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.batchInferenceJobArn = output.batchInferenceJobArn
        } else {
            self.batchInferenceJobArn = nil
        }
    }
}

public struct CreateBatchInferenceJobOutputResponse: Equatable {
    /// <p>The ARN of the batch inference job.</p>
    public let batchInferenceJobArn: String?

    public init (
        batchInferenceJobArn: String? = nil
    )
    {
        self.batchInferenceJobArn = batchInferenceJobArn
    }
}

struct CreateBatchInferenceJobOutputResponseBody: Equatable {
    public let batchInferenceJobArn: String?
}

extension CreateBatchInferenceJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case batchInferenceJobArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchInferenceJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .batchInferenceJobArn)
        batchInferenceJobArn = batchInferenceJobArnDecoded
    }
}

public struct CreateCampaignInputBodyMiddleware: Middleware {
    public let id: String = "CreateCampaignInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCampaignInput>
    public typealias MOutput = OperationOutput<CreateCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCampaignOutputError>
}

extension CreateCampaignInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCampaignInput(campaignConfig: \(String(describing: campaignConfig)), minProvisionedTPS: \(String(describing: minProvisionedTPS)), name: \(String(describing: name)), solutionVersionArn: \(String(describing: solutionVersionArn)))"}
}

extension CreateCampaignInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case campaignConfig
        case minProvisionedTPS
        case name
        case solutionVersionArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignConfig = campaignConfig {
            try encodeContainer.encode(campaignConfig, forKey: .campaignConfig)
        }
        if let minProvisionedTPS = minProvisionedTPS {
            try encodeContainer.encode(minProvisionedTPS, forKey: .minProvisionedTPS)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

public struct CreateCampaignInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCampaignInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCampaignInput>
    public typealias MOutput = OperationOutput<CreateCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCampaignOutputError>
}

public struct CreateCampaignInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCampaignInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCampaignInput>
    public typealias MOutput = OperationOutput<CreateCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCampaignOutputError>
}

public struct CreateCampaignInput: Equatable {
    /// <p>The configuration details of a campaign.</p>
    public let campaignConfig: CampaignConfig?
    /// <p>Specifies the requested minimum provisioned transactions (recommendations) per second that
    ///       Amazon Personalize will support.</p>
    public let minProvisionedTPS: Int?
    /// <p>A name for the new campaign. The campaign name must be unique within your account.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the solution version to deploy.</p>
    public let solutionVersionArn: String?

    public init (
        campaignConfig: CampaignConfig? = nil,
        minProvisionedTPS: Int? = nil,
        name: String? = nil,
        solutionVersionArn: String? = nil
    )
    {
        self.campaignConfig = campaignConfig
        self.minProvisionedTPS = minProvisionedTPS
        self.name = name
        self.solutionVersionArn = solutionVersionArn
    }
}

struct CreateCampaignInputBody: Equatable {
    public let name: String?
    public let solutionVersionArn: String?
    public let minProvisionedTPS: Int?
    public let campaignConfig: CampaignConfig?
}

extension CreateCampaignInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case campaignConfig
        case minProvisionedTPS
        case name
        case solutionVersionArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let minProvisionedTPSDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minProvisionedTPS)
        minProvisionedTPS = minProvisionedTPSDecoded
        let campaignConfigDecoded = try containerValues.decodeIfPresent(CampaignConfig.self, forKey: .campaignConfig)
        campaignConfig = campaignConfigDecoded
    }
}

extension CreateCampaignOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCampaignOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCampaignOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCampaignOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCampaignOutputResponse(campaignArn: \(String(describing: campaignArn)))"}
}

extension CreateCampaignOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateCampaignOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.campaignArn = output.campaignArn
        } else {
            self.campaignArn = nil
        }
    }
}

public struct CreateCampaignOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the campaign.</p>
    public let campaignArn: String?

    public init (
        campaignArn: String? = nil
    )
    {
        self.campaignArn = campaignArn
    }
}

struct CreateCampaignOutputResponseBody: Equatable {
    public let campaignArn: String?
}

extension CreateCampaignOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case campaignArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
    }
}

public struct CreateDatasetExportJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateDatasetExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetExportJobInput>
    public typealias MOutput = OperationOutput<CreateDatasetExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetExportJobOutputError>
}

extension CreateDatasetExportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetExportJobInput(datasetArn: \(String(describing: datasetArn)), ingestionMode: \(String(describing: ingestionMode)), jobName: \(String(describing: jobName)), jobOutput: \(String(describing: jobOutput)), roleArn: \(String(describing: roleArn)))"}
}

extension CreateDatasetExportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetArn
        case ingestionMode
        case jobName
        case jobOutput
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let ingestionMode = ingestionMode {
            try encodeContainer.encode(ingestionMode.rawValue, forKey: .ingestionMode)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutput = jobOutput {
            try encodeContainer.encode(jobOutput, forKey: .jobOutput)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct CreateDatasetExportJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDatasetExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetExportJobInput>
    public typealias MOutput = OperationOutput<CreateDatasetExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetExportJobOutputError>
}

public struct CreateDatasetExportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDatasetExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetExportJobInput>
    public typealias MOutput = OperationOutput<CreateDatasetExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetExportJobOutputError>
}

public struct CreateDatasetExportJobInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset that contains the data to export.</p>
    public let datasetArn: String?
    /// <p>The data to export, based on how you imported the data. You can choose to export only <code>BULK</code> data that you imported using a dataset import job,
    ///       only <code>PUT</code> data that you imported incrementally (using the console, PutEvents, PutUsers and PutItems operations), or <code>ALL</code>
    ///       for both types. The default value is <code>PUT</code>.
    ///     </p>
    public let ingestionMode: IngestionMode?
    /// <p>The name for the dataset export job.</p>
    public let jobName: String?
    /// <p>The path to the Amazon S3 bucket where the job's output is stored.</p>
    public let jobOutput: DatasetExportJobOutput?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management service role that has permissions to add data to your
    ///       output Amazon S3 bucket.</p>
    public let roleArn: String?

    public init (
        datasetArn: String? = nil,
        ingestionMode: IngestionMode? = nil,
        jobName: String? = nil,
        jobOutput: DatasetExportJobOutput? = nil,
        roleArn: String? = nil
    )
    {
        self.datasetArn = datasetArn
        self.ingestionMode = ingestionMode
        self.jobName = jobName
        self.jobOutput = jobOutput
        self.roleArn = roleArn
    }
}

struct CreateDatasetExportJobInputBody: Equatable {
    public let jobName: String?
    public let datasetArn: String?
    public let ingestionMode: IngestionMode?
    public let roleArn: String?
    public let jobOutput: DatasetExportJobOutput?
}

extension CreateDatasetExportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetArn
        case ingestionMode
        case jobName
        case jobOutput
        case roleArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let ingestionModeDecoded = try containerValues.decodeIfPresent(IngestionMode.self, forKey: .ingestionMode)
        ingestionMode = ingestionModeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let jobOutputDecoded = try containerValues.decodeIfPresent(DatasetExportJobOutput.self, forKey: .jobOutput)
        jobOutput = jobOutputDecoded
    }
}

extension CreateDatasetExportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetExportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetExportJobOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetExportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetExportJobOutputResponse(datasetExportJobArn: \(String(describing: datasetExportJobArn)))"}
}

extension CreateDatasetExportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDatasetExportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasetExportJobArn = output.datasetExportJobArn
        } else {
            self.datasetExportJobArn = nil
        }
    }
}

public struct CreateDatasetExportJobOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset export job.</p>
    public let datasetExportJobArn: String?

    public init (
        datasetExportJobArn: String? = nil
    )
    {
        self.datasetExportJobArn = datasetExportJobArn
    }
}

struct CreateDatasetExportJobOutputResponseBody: Equatable {
    public let datasetExportJobArn: String?
}

extension CreateDatasetExportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetExportJobArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetExportJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetExportJobArn)
        datasetExportJobArn = datasetExportJobArnDecoded
    }
}

public struct CreateDatasetGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateDatasetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetGroupInput>
    public typealias MOutput = OperationOutput<CreateDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetGroupOutputError>
}

extension CreateDatasetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetGroupInput(kmsKeyArn: \(String(describing: kmsKeyArn)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)))"}
}

extension CreateDatasetGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kmsKeyArn
        case name
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct CreateDatasetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDatasetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetGroupInput>
    public typealias MOutput = OperationOutput<CreateDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetGroupOutputError>
}

public struct CreateDatasetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDatasetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetGroupInput>
    public typealias MOutput = OperationOutput<CreateDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetGroupOutputError>
}

public struct CreateDatasetGroupInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of a KMS key used to encrypt the datasets.</p>
    public let kmsKeyArn: String?
    /// <p>The name for the new dataset group.</p>
    public let name: String?
    /// <p>The ARN of the IAM role that has permissions to access the KMS key. Supplying an IAM
    ///       role is only valid when also specifying a KMS key.</p>
    public let roleArn: String?

    public init (
        kmsKeyArn: String? = nil,
        name: String? = nil,
        roleArn: String? = nil
    )
    {
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.roleArn = roleArn
    }
}

struct CreateDatasetGroupInputBody: Equatable {
    public let name: String?
    public let roleArn: String?
    public let kmsKeyArn: String?
}

extension CreateDatasetGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case kmsKeyArn
        case name
        case roleArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension CreateDatasetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetGroupOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetGroupOutputResponse(datasetGroupArn: \(String(describing: datasetGroupArn)))"}
}

extension CreateDatasetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDatasetGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasetGroupArn = output.datasetGroupArn
        } else {
            self.datasetGroupArn = nil
        }
    }
}

public struct CreateDatasetGroupOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the new dataset group.</p>
    public let datasetGroupArn: String?

    public init (
        datasetGroupArn: String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct CreateDatasetGroupOutputResponseBody: Equatable {
    public let datasetGroupArn: String?
}

extension CreateDatasetGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

public struct CreateDatasetImportJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateDatasetImportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetImportJobInput>
    public typealias MOutput = OperationOutput<CreateDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetImportJobOutputError>
}

extension CreateDatasetImportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetImportJobInput(dataSource: \(String(describing: dataSource)), datasetArn: \(String(describing: datasetArn)), jobName: \(String(describing: jobName)), roleArn: \(String(describing: roleArn)))"}
}

extension CreateDatasetImportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSource
        case datasetArn
        case jobName
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct CreateDatasetImportJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDatasetImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetImportJobInput>
    public typealias MOutput = OperationOutput<CreateDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetImportJobOutputError>
}

public struct CreateDatasetImportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDatasetImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetImportJobInput>
    public typealias MOutput = OperationOutput<CreateDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetImportJobOutputError>
}

public struct CreateDatasetImportJobInput: Equatable {
    /// <p>The Amazon S3 bucket that contains the training data to import.</p>
    public let dataSource: DataSource?
    /// <p>The ARN of the dataset that receives the imported data.</p>
    public let datasetArn: String?
    /// <p>The name for the dataset import job.</p>
    public let jobName: String?
    /// <p>The ARN of the IAM role that has permissions to read from the Amazon S3 data source.</p>
    public let roleArn: String?

    public init (
        dataSource: DataSource? = nil,
        datasetArn: String? = nil,
        jobName: String? = nil,
        roleArn: String? = nil
    )
    {
        self.dataSource = dataSource
        self.datasetArn = datasetArn
        self.jobName = jobName
        self.roleArn = roleArn
    }
}

struct CreateDatasetImportJobInputBody: Equatable {
    public let jobName: String?
    public let datasetArn: String?
    public let dataSource: DataSource?
    public let roleArn: String?
}

extension CreateDatasetImportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSource
        case datasetArn
        case jobName
        case roleArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension CreateDatasetImportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetImportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetImportJobOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetImportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetImportJobOutputResponse(datasetImportJobArn: \(String(describing: datasetImportJobArn)))"}
}

extension CreateDatasetImportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDatasetImportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasetImportJobArn = output.datasetImportJobArn
        } else {
            self.datasetImportJobArn = nil
        }
    }
}

public struct CreateDatasetImportJobOutputResponse: Equatable {
    /// <p>The ARN of the dataset import job.</p>
    public let datasetImportJobArn: String?

    public init (
        datasetImportJobArn: String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

struct CreateDatasetImportJobOutputResponseBody: Equatable {
    public let datasetImportJobArn: String?
}

extension CreateDatasetImportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetImportJobArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
    }
}

public struct CreateDatasetInputBodyMiddleware: Middleware {
    public let id: String = "CreateDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetOutputError>
}

extension CreateDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetInput(datasetGroupArn: \(String(describing: datasetGroupArn)), datasetType: \(String(describing: datasetType)), name: \(String(describing: name)), schemaArn: \(String(describing: schemaArn)))"}
}

extension CreateDatasetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn
        case datasetType
        case name
        case schemaArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let datasetType = datasetType {
            try encodeContainer.encode(datasetType, forKey: .datasetType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }
}

public struct CreateDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset group to add the dataset to.</p>
    public let datasetGroupArn: String?
    /// <p>The type of dataset.</p>
    ///          <p>One of the following (case insensitive) values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Interactions</p>
    ///             </li>
    ///             <li>
    ///                <p>Items</p>
    ///             </li>
    ///             <li>
    ///                <p>Users</p>
    ///             </li>
    ///          </ul>
    public let datasetType: String?
    /// <p>The name for the dataset.</p>
    public let name: String?
    /// <p>The ARN of the schema to associate with the dataset. The schema defines the dataset
    ///       fields.</p>
    public let schemaArn: String?

    public init (
        datasetGroupArn: String? = nil,
        datasetType: String? = nil,
        name: String? = nil,
        schemaArn: String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.datasetType = datasetType
        self.name = name
        self.schemaArn = schemaArn
    }
}

struct CreateDatasetInputBody: Equatable {
    public let name: String?
    public let schemaArn: String?
    public let datasetGroupArn: String?
    public let datasetType: String?
}

extension CreateDatasetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn
        case datasetType
        case name
        case schemaArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
    }
}

extension CreateDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetOutputResponse(datasetArn: \(String(describing: datasetArn)))"}
}

extension CreateDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDatasetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasetArn = output.datasetArn
        } else {
            self.datasetArn = nil
        }
    }
}

public struct CreateDatasetOutputResponse: Equatable {
    /// <p>The ARN of the dataset.</p>
    public let datasetArn: String?

    public init (
        datasetArn: String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct CreateDatasetOutputResponseBody: Equatable {
    public let datasetArn: String?
}

extension CreateDatasetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

public struct CreateEventTrackerInputBodyMiddleware: Middleware {
    public let id: String = "CreateEventTrackerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventTrackerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventTrackerInput>
    public typealias MOutput = OperationOutput<CreateEventTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventTrackerOutputError>
}

extension CreateEventTrackerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEventTrackerInput(datasetGroupArn: \(String(describing: datasetGroupArn)), name: \(String(describing: name)))"}
}

extension CreateEventTrackerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateEventTrackerInputHeadersMiddleware: Middleware {
    public let id: String = "CreateEventTrackerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventTrackerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventTrackerInput>
    public typealias MOutput = OperationOutput<CreateEventTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventTrackerOutputError>
}

public struct CreateEventTrackerInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEventTrackerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventTrackerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventTrackerInput>
    public typealias MOutput = OperationOutput<CreateEventTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventTrackerOutputError>
}

public struct CreateEventTrackerInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset group that receives the event data.</p>
    public let datasetGroupArn: String?
    /// <p>The name for the event tracker.</p>
    public let name: String?

    public init (
        datasetGroupArn: String? = nil,
        name: String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.name = name
    }
}

struct CreateEventTrackerInputBody: Equatable {
    public let name: String?
    public let datasetGroupArn: String?
}

extension CreateEventTrackerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

extension CreateEventTrackerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEventTrackerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEventTrackerOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEventTrackerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEventTrackerOutputResponse(eventTrackerArn: \(String(describing: eventTrackerArn)), trackingId: \(String(describing: trackingId)))"}
}

extension CreateEventTrackerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateEventTrackerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventTrackerArn = output.eventTrackerArn
            self.trackingId = output.trackingId
        } else {
            self.eventTrackerArn = nil
            self.trackingId = nil
        }
    }
}

public struct CreateEventTrackerOutputResponse: Equatable {
    /// <p>The ARN of the event tracker.</p>
    public let eventTrackerArn: String?
    /// <p>The ID of the event tracker. Include this ID in requests to the
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_UBS_PutEvents.html">PutEvents</a> API.</p>
    public let trackingId: String?

    public init (
        eventTrackerArn: String? = nil,
        trackingId: String? = nil
    )
    {
        self.eventTrackerArn = eventTrackerArn
        self.trackingId = trackingId
    }
}

struct CreateEventTrackerOutputResponseBody: Equatable {
    public let eventTrackerArn: String?
    public let trackingId: String?
}

extension CreateEventTrackerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventTrackerArn
        case trackingId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTrackerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventTrackerArn)
        eventTrackerArn = eventTrackerArnDecoded
        let trackingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trackingId)
        trackingId = trackingIdDecoded
    }
}

public struct CreateFilterInputBodyMiddleware: Middleware {
    public let id: String = "CreateFilterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFilterInput>
    public typealias MOutput = OperationOutput<CreateFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFilterOutputError>
}

extension CreateFilterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFilterInput(datasetGroupArn: \(String(describing: datasetGroupArn)), filterExpression: \(String(describing: filterExpression)), name: \(String(describing: name)))"}
}

extension CreateFilterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn
        case filterExpression
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let filterExpression = filterExpression {
            try encodeContainer.encode(filterExpression, forKey: .filterExpression)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateFilterInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFilterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFilterInput>
    public typealias MOutput = OperationOutput<CreateFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFilterOutputError>
}

public struct CreateFilterInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFilterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFilterInput>
    public typealias MOutput = OperationOutput<CreateFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFilterOutputError>
}

public struct CreateFilterInput: Equatable {
    /// <p>The ARN of the dataset group that the filter will belong to.</p>
    public let datasetGroupArn: String?
    /// <p>The filter expression defines which items are included or excluded from recommendations. Filter expression must follow specific format rules.
    ///             For information about filter expression structure and syntax, see
    ///              <a>filter-expressions</a>.</p>
    public let filterExpression: String?
    /// <p>The name of the filter to create.</p>
    public let name: String?

    public init (
        datasetGroupArn: String? = nil,
        filterExpression: String? = nil,
        name: String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.filterExpression = filterExpression
        self.name = name
    }
}

struct CreateFilterInputBody: Equatable {
    public let name: String?
    public let datasetGroupArn: String?
    public let filterExpression: String?
}

extension CreateFilterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn
        case filterExpression
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let filterExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filterExpression)
        filterExpression = filterExpressionDecoded
    }
}

extension CreateFilterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFilterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFilterOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFilterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFilterOutputResponse(filterArn: \(String(describing: filterArn)))"}
}

extension CreateFilterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateFilterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.filterArn = output.filterArn
        } else {
            self.filterArn = nil
        }
    }
}

public struct CreateFilterOutputResponse: Equatable {
    /// <p>The ARN of the new filter.</p>
    public let filterArn: String?

    public init (
        filterArn: String? = nil
    )
    {
        self.filterArn = filterArn
    }
}

struct CreateFilterOutputResponseBody: Equatable {
    public let filterArn: String?
}

extension CreateFilterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filterArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
    }
}

public struct CreateSchemaInputBodyMiddleware: Middleware {
    public let id: String = "CreateSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSchemaInput>
    public typealias MOutput = OperationOutput<CreateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSchemaOutputError>
}

extension CreateSchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSchemaInput(name: \(String(describing: name)), schema: \(String(describing: schema)))"}
}

extension CreateSchemaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case schema
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }
}

public struct CreateSchemaInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSchemaInput>
    public typealias MOutput = OperationOutput<CreateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSchemaOutputError>
}

public struct CreateSchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSchemaInput>
    public typealias MOutput = OperationOutput<CreateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSchemaOutputError>
}

public struct CreateSchemaInput: Equatable {
    /// <p>The name for the schema.</p>
    public let name: String?
    /// <p>A schema in Avro JSON format.</p>
    public let schema: String?

    public init (
        name: String? = nil,
        schema: String? = nil
    )
    {
        self.name = name
        self.schema = schema
    }
}

struct CreateSchemaInputBody: Equatable {
    public let name: String?
    public let schema: String?
}

extension CreateSchemaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name
        case schema
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension CreateSchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSchemaOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSchemaOutputResponse(schemaArn: \(String(describing: schemaArn)))"}
}

extension CreateSchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSchemaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.schemaArn = output.schemaArn
        } else {
            self.schemaArn = nil
        }
    }
}

public struct CreateSchemaOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the created schema.</p>
    public let schemaArn: String?

    public init (
        schemaArn: String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct CreateSchemaOutputResponseBody: Equatable {
    public let schemaArn: String?
}

extension CreateSchemaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case schemaArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

public struct CreateSolutionInputBodyMiddleware: Middleware {
    public let id: String = "CreateSolutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSolutionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSolutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSolutionInput>
    public typealias MOutput = OperationOutput<CreateSolutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSolutionOutputError>
}

extension CreateSolutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSolutionInput(datasetGroupArn: \(String(describing: datasetGroupArn)), eventType: \(String(describing: eventType)), name: \(String(describing: name)), performAutoML: \(String(describing: performAutoML)), performHPO: \(String(describing: performHPO)), recipeArn: \(String(describing: recipeArn)), solutionConfig: \(String(describing: solutionConfig)))"}
}

extension CreateSolutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn
        case eventType
        case name
        case performAutoML
        case performHPO
        case recipeArn
        case solutionConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let eventType = eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if performAutoML != false {
            try encodeContainer.encode(performAutoML, forKey: .performAutoML)
        }
        if let performHPO = performHPO {
            try encodeContainer.encode(performHPO, forKey: .performHPO)
        }
        if let recipeArn = recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let solutionConfig = solutionConfig {
            try encodeContainer.encode(solutionConfig, forKey: .solutionConfig)
        }
    }
}

public struct CreateSolutionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSolutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSolutionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSolutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSolutionInput>
    public typealias MOutput = OperationOutput<CreateSolutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSolutionOutputError>
}

public struct CreateSolutionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSolutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSolutionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSolutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSolutionInput>
    public typealias MOutput = OperationOutput<CreateSolutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSolutionOutputError>
}

public struct CreateSolutionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset group that provides the training data.</p>
    public let datasetGroupArn: String?
    /// <p>When your have multiple event types (using an <code>EVENT_TYPE</code> schema field),
    ///       this parameter specifies which event type (for example, 'click' or 'like') is used for
    ///       training the model.</p>
    ///          <p>If you do not provide an <code>eventType</code>, Amazon Personalize will use all interactions for training with
    ///        equal weight regardless of type.</p>
    public let eventType: String?
    /// <p>The name for the solution.</p>
    public let name: String?
    /// <p>Whether to perform automated machine learning (AutoML). The default is <code>false</code>.
    ///       For this case, you must specify <code>recipeArn</code>.</p>
    ///          <p>When set to <code>true</code>, Amazon Personalize analyzes your training data and selects
    ///       the optimal USER_PERSONALIZATION recipe and hyperparameters. In this case, you must omit
    ///       <code>recipeArn</code>. Amazon Personalize determines the optimal recipe by running tests with
    ///       different values for the hyperparameters.
    ///       AutoML lengthens the training process as compared to selecting a specific recipe.</p>
    public let performAutoML: Bool
    /// <p>Whether to perform hyperparameter optimization (HPO) on the specified or selected recipe.
    ///       The default is <code>false</code>.</p>
    ///          <p>When performing AutoML, this parameter is always <code>true</code> and you
    ///       should not set it to <code>false</code>.</p>
    public let performHPO: Bool?
    /// <p>The ARN of the recipe to use for model training. Only specified when
    ///       <code>performAutoML</code> is false.</p>
    public let recipeArn: String?
    /// <p>The configuration to use with the solution. When <code>performAutoML</code> is set to
    ///       true, Amazon Personalize only evaluates the <code>autoMLConfig</code> section
    ///       of the solution configuration.</p>
    ///          <note>
    ///             <p>Amazon Personalize doesn't support configuring the <code>hpoObjective</code>
    ///         at this time.</p>
    ///          </note>
    public let solutionConfig: SolutionConfig?

    public init (
        datasetGroupArn: String? = nil,
        eventType: String? = nil,
        name: String? = nil,
        performAutoML: Bool = false,
        performHPO: Bool? = nil,
        recipeArn: String? = nil,
        solutionConfig: SolutionConfig? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.eventType = eventType
        self.name = name
        self.performAutoML = performAutoML
        self.performHPO = performHPO
        self.recipeArn = recipeArn
        self.solutionConfig = solutionConfig
    }
}

struct CreateSolutionInputBody: Equatable {
    public let name: String?
    public let performHPO: Bool?
    public let performAutoML: Bool
    public let recipeArn: String?
    public let datasetGroupArn: String?
    public let eventType: String?
    public let solutionConfig: SolutionConfig?
}

extension CreateSolutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn
        case eventType
        case name
        case performAutoML
        case performHPO
        case recipeArn
        case solutionConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let performHPODecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .performHPO)
        performHPO = performHPODecoded
        let performAutoMLDecoded = try containerValues.decode(Bool.self, forKey: .performAutoML)
        performAutoML = performAutoMLDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let solutionConfigDecoded = try containerValues.decodeIfPresent(SolutionConfig.self, forKey: .solutionConfig)
        solutionConfig = solutionConfigDecoded
    }
}

extension CreateSolutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSolutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSolutionOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSolutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSolutionOutputResponse(solutionArn: \(String(describing: solutionArn)))"}
}

extension CreateSolutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSolutionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.solutionArn = output.solutionArn
        } else {
            self.solutionArn = nil
        }
    }
}

public struct CreateSolutionOutputResponse: Equatable {
    /// <p>The ARN of the solution.</p>
    public let solutionArn: String?

    public init (
        solutionArn: String? = nil
    )
    {
        self.solutionArn = solutionArn
    }
}

struct CreateSolutionOutputResponseBody: Equatable {
    public let solutionArn: String?
}

extension CreateSolutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case solutionArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
    }
}

public struct CreateSolutionVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreateSolutionVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSolutionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSolutionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSolutionVersionInput>
    public typealias MOutput = OperationOutput<CreateSolutionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSolutionVersionOutputError>
}

extension CreateSolutionVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSolutionVersionInput(solutionArn: \(String(describing: solutionArn)), trainingMode: \(String(describing: trainingMode)))"}
}

extension CreateSolutionVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case solutionArn
        case trainingMode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let solutionArn = solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
        if let trainingMode = trainingMode {
            try encodeContainer.encode(trainingMode.rawValue, forKey: .trainingMode)
        }
    }
}

public struct CreateSolutionVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSolutionVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSolutionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSolutionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSolutionVersionInput>
    public typealias MOutput = OperationOutput<CreateSolutionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSolutionVersionOutputError>
}

public struct CreateSolutionVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSolutionVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSolutionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSolutionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSolutionVersionInput>
    public typealias MOutput = OperationOutput<CreateSolutionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSolutionVersionOutputError>
}

public struct CreateSolutionVersionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the solution containing the training configuration
    ///       information.</p>
    public let solutionArn: String?
    /// <p>The scope of training to be performed when creating the solution version. The
    ///         <code>FULL</code> option trains the solution version based on the entirety of the input
    ///       solution's training data, while the <code>UPDATE</code> option processes only the data that
    ///       has changed in comparison to the input solution. Choose <code>UPDATE</code> when you want to
    ///       incrementally update your solution version instead of creating an entirely new one.</p>
    ///          <important>
    ///             <p>The <code>UPDATE</code> option can only be used when you already have an active solution
    ///         version created from the input solution using the <code>FULL</code> option and the input
    ///         solution was trained with the
    ///         <a href="https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-new-item-USER_PERSONALIZATION.html">User-Personalization</a>
    ///         recipe or the
    ///         <a href="https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-hrnn-coldstart.html">HRNN-Coldstart</a> recipe.</p>
    ///          </important>
    public let trainingMode: TrainingMode?

    public init (
        solutionArn: String? = nil,
        trainingMode: TrainingMode? = nil
    )
    {
        self.solutionArn = solutionArn
        self.trainingMode = trainingMode
    }
}

struct CreateSolutionVersionInputBody: Equatable {
    public let solutionArn: String?
    public let trainingMode: TrainingMode?
}

extension CreateSolutionVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case solutionArn
        case trainingMode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let trainingModeDecoded = try containerValues.decodeIfPresent(TrainingMode.self, forKey: .trainingMode)
        trainingMode = trainingModeDecoded
    }
}

extension CreateSolutionVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSolutionVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSolutionVersionOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSolutionVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSolutionVersionOutputResponse(solutionVersionArn: \(String(describing: solutionVersionArn)))"}
}

extension CreateSolutionVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSolutionVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.solutionVersionArn = output.solutionVersionArn
        } else {
            self.solutionVersionArn = nil
        }
    }
}

public struct CreateSolutionVersionOutputResponse: Equatable {
    /// <p>The ARN of the new solution version.</p>
    public let solutionVersionArn: String?

    public init (
        solutionVersionArn: String? = nil
    )
    {
        self.solutionVersionArn = solutionVersionArn
    }
}

struct CreateSolutionVersionOutputResponseBody: Equatable {
    public let solutionVersionArn: String?
}

extension CreateSolutionVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case solutionVersionArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
    }
}

extension DataSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataLocation
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataLocation = dataLocation {
            try encodeContainer.encode(dataLocation, forKey: .dataLocation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataLocationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataLocation)
        dataLocation = dataLocationDecoded
    }
}

extension DataSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataSource(dataLocation: \(String(describing: dataLocation)))"}
}

/// <p>Describes the data source that contains the data to upload to a dataset.</p>
public struct DataSource: Equatable {
    /// <p>The path to the Amazon S3 bucket where the data that you want to upload to your dataset is
    ///       stored. For example: </p>
    ///          <p>
    ///             <code>s3://bucket-name/folder-name/</code>
    ///          </p>
    public let dataLocation: String?

    public init (
        dataLocation: String? = nil
    )
    {
        self.dataLocation = dataLocation
    }
}

extension Dataset: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case datasetArn
        case datasetGroupArn
        case datasetType
        case lastUpdatedDateTime
        case name
        case schemaArn
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let datasetType = datasetType {
            try encodeContainer.encode(datasetType, forKey: .datasetType)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension Dataset: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Dataset(creationDateTime: \(String(describing: creationDateTime)), datasetArn: \(String(describing: datasetArn)), datasetGroupArn: \(String(describing: datasetGroupArn)), datasetType: \(String(describing: datasetType)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), name: \(String(describing: name)), schemaArn: \(String(describing: schemaArn)), status: \(String(describing: status)))"}
}

/// <p>Provides metadata for a dataset.</p>
public struct Dataset: Equatable {
    /// <p>The creation date and time (in Unix time) of the dataset.</p>
    public let creationDateTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the dataset that you want metadata for.</p>
    public let datasetArn: String?
    /// <p>The Amazon Resource Name (ARN) of the dataset group.</p>
    public let datasetGroupArn: String?
    /// <p>One of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Interactions</p>
    ///             </li>
    ///             <li>
    ///                <p>Items</p>
    ///             </li>
    ///             <li>
    ///                <p>Users</p>
    ///             </li>
    ///          </ul>
    public let datasetType: String?
    /// <p>A time stamp that shows when the dataset was updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The name of the dataset.</p>
    public let name: String?
    /// <p>The ARN of the associated schema.</p>
    public let schemaArn: String?
    /// <p>The status of the dataset.</p>
    ///          <p>A dataset can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///             <li>
    ///                <p>DELETE PENDING > DELETE IN_PROGRESS</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        creationDateTime: Date? = nil,
        datasetArn: String? = nil,
        datasetGroupArn: String? = nil,
        datasetType: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        name: String? = nil,
        schemaArn: String? = nil,
        status: String? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.datasetArn = datasetArn
        self.datasetGroupArn = datasetGroupArn
        self.datasetType = datasetType
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.name = name
        self.schemaArn = schemaArn
        self.status = status
    }
}

extension DatasetExportJob: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case datasetArn
        case datasetExportJobArn
        case failureReason
        case ingestionMode
        case jobName
        case jobOutput
        case lastUpdatedDateTime
        case roleArn
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetExportJobArn = datasetExportJobArn {
            try encodeContainer.encode(datasetExportJobArn, forKey: .datasetExportJobArn)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let ingestionMode = ingestionMode {
            try encodeContainer.encode(ingestionMode.rawValue, forKey: .ingestionMode)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutput = jobOutput {
            try encodeContainer.encode(jobOutput, forKey: .jobOutput)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let datasetExportJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetExportJobArn)
        datasetExportJobArn = datasetExportJobArnDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let ingestionModeDecoded = try containerValues.decodeIfPresent(IngestionMode.self, forKey: .ingestionMode)
        ingestionMode = ingestionModeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let jobOutputDecoded = try containerValues.decodeIfPresent(DatasetExportJobOutput.self, forKey: .jobOutput)
        jobOutput = jobOutputDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension DatasetExportJob: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetExportJob(creationDateTime: \(String(describing: creationDateTime)), datasetArn: \(String(describing: datasetArn)), datasetExportJobArn: \(String(describing: datasetExportJobArn)), failureReason: \(String(describing: failureReason)), ingestionMode: \(String(describing: ingestionMode)), jobName: \(String(describing: jobName)), jobOutput: \(String(describing: jobOutput)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), roleArn: \(String(describing: roleArn)), status: \(String(describing: status)))"}
}

/// <p>Describes a job that exports a dataset to an Amazon S3 bucket. For more information, see <a>CreateDatasetExportJob</a>.</p>
///          <p>A dataset export job can be in one of the following states:</p>
///          <ul>
///             <li>
///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
///             </li>
///          </ul>
public struct DatasetExportJob: Equatable {
    /// <p>The creation date and time (in Unix time) of the dataset export job.</p>
    public let creationDateTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the dataset to export.</p>
    public let datasetArn: String?
    /// <p>The Amazon Resource Name (ARN) of the dataset export job.</p>
    public let datasetExportJobArn: String?
    /// <p>If a dataset export job fails, provides the reason why.</p>
    public let failureReason: String?
    /// <p>The data to export, based on how you imported the data. You can choose to export <code>BULK</code> data that you imported using a dataset import job,
    ///       <code>PUT</code> data that you imported incrementally (using the console, PutEvents, PutUsers and PutItems operations), or <code>ALL</code>
    ///       for both types. The default value is <code>PUT</code>.
    ///     </p>
    public let ingestionMode: IngestionMode?
    /// <p>The name of the export job.</p>
    public let jobName: String?
    /// <p>The path to the Amazon S3 bucket where the job's output is stored.  For example:</p>
    ///          <p>
    ///             <code>s3://bucket-name/folder-name/</code>
    ///          </p>
    public let jobOutput: DatasetExportJobOutput?
    /// <p>The date and time (in Unix time) the status of the dataset export job was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management service role that has permissions to add data to your
    ///       output Amazon S3 bucket.</p>
    public let roleArn: String?
    /// <p>The status of the dataset export job.</p>
    ///          <p>A dataset export job can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        creationDateTime: Date? = nil,
        datasetArn: String? = nil,
        datasetExportJobArn: String? = nil,
        failureReason: String? = nil,
        ingestionMode: IngestionMode? = nil,
        jobName: String? = nil,
        jobOutput: DatasetExportJobOutput? = nil,
        lastUpdatedDateTime: Date? = nil,
        roleArn: String? = nil,
        status: String? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.datasetArn = datasetArn
        self.datasetExportJobArn = datasetExportJobArn
        self.failureReason = failureReason
        self.ingestionMode = ingestionMode
        self.jobName = jobName
        self.jobOutput = jobOutput
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.roleArn = roleArn
        self.status = status
    }
}

extension DatasetExportJobOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3DataDestination
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3DataDestination = s3DataDestination {
            try encodeContainer.encode(s3DataDestination, forKey: .s3DataDestination)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataDestinationDecoded = try containerValues.decodeIfPresent(S3DataConfig.self, forKey: .s3DataDestination)
        s3DataDestination = s3DataDestinationDecoded
    }
}

extension DatasetExportJobOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetExportJobOutput(s3DataDestination: \(String(describing: s3DataDestination)))"}
}

/// <p>The output configuration parameters of a dataset export job.</p>
public struct DatasetExportJobOutput: Equatable {
    /// <p>The configuration details of an Amazon S3 input or output bucket.</p>
    public let s3DataDestination: S3DataConfig?

    public init (
        s3DataDestination: S3DataConfig? = nil
    )
    {
        self.s3DataDestination = s3DataDestination
    }
}

extension DatasetExportJobSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case datasetExportJobArn
        case failureReason
        case jobName
        case lastUpdatedDateTime
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetExportJobArn = datasetExportJobArn {
            try encodeContainer.encode(datasetExportJobArn, forKey: .datasetExportJobArn)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetExportJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetExportJobArn)
        datasetExportJobArn = datasetExportJobArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension DatasetExportJobSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetExportJobSummary(creationDateTime: \(String(describing: creationDateTime)), datasetExportJobArn: \(String(describing: datasetExportJobArn)), failureReason: \(String(describing: failureReason)), jobName: \(String(describing: jobName)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), status: \(String(describing: status)))"}
}

/// <p>Provides a summary of the properties of a dataset export job. For a complete listing, call the
///       <a>DescribeDatasetExportJob</a> API.</p>
public struct DatasetExportJobSummary: Equatable {
    /// <p>The date and time (in Unix time) that the dataset export job was created.</p>
    public let creationDateTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the dataset export job.</p>
    public let datasetExportJobArn: String?
    /// <p>If a dataset export job fails, the reason behind the failure.</p>
    public let failureReason: String?
    /// <p>The name of the dataset export job.</p>
    public let jobName: String?
    /// <p>The date and time (in Unix time) that the dataset export job status was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The status of the dataset export job.</p>
    ///          <p>A dataset export job can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        creationDateTime: Date? = nil,
        datasetExportJobArn: String? = nil,
        failureReason: String? = nil,
        jobName: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        status: String? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.datasetExportJobArn = datasetExportJobArn
        self.failureReason = failureReason
        self.jobName = jobName
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.status = status
    }
}

extension DatasetGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case datasetGroupArn
        case failureReason
        case kmsKeyArn
        case lastUpdatedDateTime
        case name
        case roleArn
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension DatasetGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetGroup(creationDateTime: \(String(describing: creationDateTime)), datasetGroupArn: \(String(describing: datasetGroupArn)), failureReason: \(String(describing: failureReason)), kmsKeyArn: \(String(describing: kmsKeyArn)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), status: \(String(describing: status)))"}
}

/// <p>A dataset group is a collection of related datasets (Interactions, User, and Item). You
///       create a dataset group by calling <a>CreateDatasetGroup</a>. You then create a
///       dataset and add it to a dataset group by calling <a>CreateDataset</a>. The dataset
///       group is used to create and train a solution by calling <a>CreateSolution</a>. A
///       dataset group can contain only one of each type of dataset.</p>
///          <p>You can specify an AWS Key Management Service (KMS) key to encrypt the datasets in the group.</p>
public struct DatasetGroup: Equatable {
    /// <p>The creation date and time (in Unix time) of the dataset group.</p>
    public let creationDateTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the dataset group.</p>
    public let datasetGroupArn: String?
    /// <p>If creating a dataset group fails, provides the reason why.</p>
    public let failureReason: String?
    /// <p>The Amazon Resource Name (ARN) of the KMS key used to encrypt the datasets.</p>
    public let kmsKeyArn: String?
    /// <p>The last update date and time (in Unix time) of the dataset group.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The name of the dataset group.</p>
    public let name: String?
    /// <p>The ARN of the IAM role that has permissions to create the dataset group.</p>
    public let roleArn: String?
    /// <p>The current status of the dataset group.</p>
    ///          <p>A dataset group can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///             <li>
    ///                <p>DELETE PENDING</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        creationDateTime: Date? = nil,
        datasetGroupArn: String? = nil,
        failureReason: String? = nil,
        kmsKeyArn: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        status: String? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.datasetGroupArn = datasetGroupArn
        self.failureReason = failureReason
        self.kmsKeyArn = kmsKeyArn
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.name = name
        self.roleArn = roleArn
        self.status = status
    }
}

extension DatasetGroupSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case datasetGroupArn
        case failureReason
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension DatasetGroupSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetGroupSummary(creationDateTime: \(String(describing: creationDateTime)), datasetGroupArn: \(String(describing: datasetGroupArn)), failureReason: \(String(describing: failureReason)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), name: \(String(describing: name)), status: \(String(describing: status)))"}
}

/// <p>Provides a summary of the properties of a dataset group. For a complete listing, call the
///       <a>DescribeDatasetGroup</a> API.</p>
public struct DatasetGroupSummary: Equatable {
    /// <p>The date and time (in Unix time) that the dataset group was created.</p>
    public let creationDateTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the dataset group.</p>
    public let datasetGroupArn: String?
    /// <p>If creating a dataset group fails, the reason behind the failure.</p>
    public let failureReason: String?
    /// <p>The date and time (in Unix time) that the dataset group was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The name of the dataset group.</p>
    public let name: String?
    /// <p>The status of the dataset group.</p>
    ///          <p>A dataset group can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///             <li>
    ///                <p>DELETE PENDING</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        creationDateTime: Date? = nil,
        datasetGroupArn: String? = nil,
        failureReason: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        name: String? = nil,
        status: String? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.datasetGroupArn = datasetGroupArn
        self.failureReason = failureReason
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.name = name
        self.status = status
    }
}

extension DatasetImportJob: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case dataSource
        case datasetArn
        case datasetImportJobArn
        case failureReason
        case jobName
        case lastUpdatedDateTime
        case roleArn
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetImportJobArn = datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension DatasetImportJob: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetImportJob(creationDateTime: \(String(describing: creationDateTime)), dataSource: \(String(describing: dataSource)), datasetArn: \(String(describing: datasetArn)), datasetImportJobArn: \(String(describing: datasetImportJobArn)), failureReason: \(String(describing: failureReason)), jobName: \(String(describing: jobName)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), roleArn: \(String(describing: roleArn)), status: \(String(describing: status)))"}
}

/// <p>Describes a job that imports training data from a data source (Amazon S3 bucket) to an
///       Amazon Personalize dataset. For more information, see <a>CreateDatasetImportJob</a>.</p>
///          <p>A dataset import job can be in one of the following states:</p>
///          <ul>
///             <li>
///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
///             </li>
///          </ul>
public struct DatasetImportJob: Equatable {
    /// <p>The creation date and time (in Unix time) of the dataset import job.</p>
    public let creationDateTime: Date?
    /// <p>The Amazon S3 bucket that contains the training data to import.</p>
    public let dataSource: DataSource?
    /// <p>The Amazon Resource Name (ARN) of the dataset that receives the imported data.</p>
    public let datasetArn: String?
    /// <p>The ARN of the dataset import job.</p>
    public let datasetImportJobArn: String?
    /// <p>If a dataset import job fails, provides the reason why.</p>
    public let failureReason: String?
    /// <p>The name of the import job.</p>
    public let jobName: String?
    /// <p>The date and time (in Unix time) the dataset was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The ARN of the AWS Identity and Access Management (IAM) role that has permissions to read from the Amazon S3 data
    ///       source.</p>
    public let roleArn: String?
    /// <p>The status of the dataset import job.</p>
    ///          <p>A dataset import job can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        creationDateTime: Date? = nil,
        dataSource: DataSource? = nil,
        datasetArn: String? = nil,
        datasetImportJobArn: String? = nil,
        failureReason: String? = nil,
        jobName: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        roleArn: String? = nil,
        status: String? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.dataSource = dataSource
        self.datasetArn = datasetArn
        self.datasetImportJobArn = datasetImportJobArn
        self.failureReason = failureReason
        self.jobName = jobName
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.roleArn = roleArn
        self.status = status
    }
}

extension DatasetImportJobSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case datasetImportJobArn
        case failureReason
        case jobName
        case lastUpdatedDateTime
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetImportJobArn = datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension DatasetImportJobSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetImportJobSummary(creationDateTime: \(String(describing: creationDateTime)), datasetImportJobArn: \(String(describing: datasetImportJobArn)), failureReason: \(String(describing: failureReason)), jobName: \(String(describing: jobName)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), status: \(String(describing: status)))"}
}

/// <p>Provides a summary of the properties of a dataset import job. For a complete listing, call the
///       <a>DescribeDatasetImportJob</a> API.</p>
public struct DatasetImportJobSummary: Equatable {
    /// <p>The date and time (in Unix time) that the dataset import job was created.</p>
    public let creationDateTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the dataset import job.</p>
    public let datasetImportJobArn: String?
    /// <p>If a dataset import job fails, the reason behind the failure.</p>
    public let failureReason: String?
    /// <p>The name of the dataset import job.</p>
    public let jobName: String?
    /// <p>The date and time (in Unix time) that the dataset import job status was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The status of the dataset import job.</p>
    ///          <p>A dataset import job can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        creationDateTime: Date? = nil,
        datasetImportJobArn: String? = nil,
        failureReason: String? = nil,
        jobName: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        status: String? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.datasetImportJobArn = datasetImportJobArn
        self.failureReason = failureReason
        self.jobName = jobName
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.status = status
    }
}

extension DatasetSchema: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case lastUpdatedDateTime
        case name
        case schema
        case schemaArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension DatasetSchema: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetSchema(creationDateTime: \(String(describing: creationDateTime)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), name: \(String(describing: name)), schema: \(String(describing: schema)), schemaArn: \(String(describing: schemaArn)))"}
}

/// <p>Describes the schema for a dataset. For more information on schemas, see
///       <a>CreateSchema</a>.</p>
public struct DatasetSchema: Equatable {
    /// <p>The date and time (in Unix time) that the schema was created.</p>
    public let creationDateTime: Date?
    /// <p>The date and time (in Unix time) that the schema was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The name of the schema.</p>
    public let name: String?
    /// <p>The schema.</p>
    public let schema: String?
    /// <p>The Amazon Resource Name (ARN) of the schema.</p>
    public let schemaArn: String?

    public init (
        creationDateTime: Date? = nil,
        lastUpdatedDateTime: Date? = nil,
        name: String? = nil,
        schema: String? = nil,
        schemaArn: String? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.name = name
        self.schema = schema
        self.schemaArn = schemaArn
    }
}

extension DatasetSchemaSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case lastUpdatedDateTime
        case name
        case schemaArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension DatasetSchemaSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetSchemaSummary(creationDateTime: \(String(describing: creationDateTime)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), name: \(String(describing: name)), schemaArn: \(String(describing: schemaArn)))"}
}

/// <p>Provides a summary of the properties of a dataset schema. For a complete listing, call the
///       <a>DescribeSchema</a> API.</p>
public struct DatasetSchemaSummary: Equatable {
    /// <p>The date and time (in Unix time) that the schema was created.</p>
    public let creationDateTime: Date?
    /// <p>The date and time (in Unix time) that the schema was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The name of the schema.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the schema.</p>
    public let schemaArn: String?

    public init (
        creationDateTime: Date? = nil,
        lastUpdatedDateTime: Date? = nil,
        name: String? = nil,
        schemaArn: String? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.name = name
        self.schemaArn = schemaArn
    }
}

extension DatasetSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case datasetArn
        case datasetType
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetType = datasetType {
            try encodeContainer.encode(datasetType, forKey: .datasetType)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension DatasetSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetSummary(creationDateTime: \(String(describing: creationDateTime)), datasetArn: \(String(describing: datasetArn)), datasetType: \(String(describing: datasetType)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), name: \(String(describing: name)), status: \(String(describing: status)))"}
}

/// <p>Provides a summary of the properties of a dataset. For a complete listing, call the
///       <a>DescribeDataset</a> API.</p>
public struct DatasetSummary: Equatable {
    /// <p>The date and time (in Unix time) that the dataset was created.</p>
    public let creationDateTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the dataset.</p>
    public let datasetArn: String?
    /// <p>The dataset type. One of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Interactions</p>
    ///             </li>
    ///             <li>
    ///                <p>Items</p>
    ///             </li>
    ///             <li>
    ///                <p>Users</p>
    ///             </li>
    ///             <li>
    ///                <p>Event-Interactions</p>
    ///             </li>
    ///          </ul>
    public let datasetType: String?
    /// <p>The date and time (in Unix time) that the dataset was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The name of the dataset.</p>
    public let name: String?
    /// <p>The status of the dataset.</p>
    ///          <p>A dataset can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///             <li>
    ///                <p>DELETE PENDING > DELETE IN_PROGRESS</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        creationDateTime: Date? = nil,
        datasetArn: String? = nil,
        datasetType: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        name: String? = nil,
        status: String? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.datasetArn = datasetArn
        self.datasetType = datasetType
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.name = name
        self.status = status
    }
}

extension DefaultCategoricalHyperParameterRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isTunable
        case name
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isTunable != false {
            try encodeContainer.encode(isTunable, forKey: .isTunable)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for categoricalvalues0 in values {
                try valuesContainer.encode(categoricalvalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let isTunableDecoded = try containerValues.decode(Bool.self, forKey: .isTunable)
        isTunable = isTunableDecoded
    }
}

extension DefaultCategoricalHyperParameterRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefaultCategoricalHyperParameterRange(isTunable: \(String(describing: isTunable)), name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>Provides the name and default range of a categorical hyperparameter
///       and whether the hyperparameter is tunable. A tunable hyperparameter can
///       have its value determined during hyperparameter optimization (HPO).</p>
public struct DefaultCategoricalHyperParameterRange: Equatable {
    /// <p>Whether the hyperparameter is tunable.</p>
    public let isTunable: Bool
    /// <p>The name of the hyperparameter.</p>
    public let name: String?
    /// <p>A list of the categories for the hyperparameter.</p>
    public let values: [String]?

    public init (
        isTunable: Bool = false,
        name: String? = nil,
        values: [String]? = nil
    )
    {
        self.isTunable = isTunable
        self.name = name
        self.values = values
    }
}

extension DefaultContinuousHyperParameterRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isTunable
        case maxValue
        case minValue
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isTunable != false {
            try encodeContainer.encode(isTunable, forKey: .isTunable)
        }
        if maxValue != 0.0 {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if minValue != 0.0 {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let minValueDecoded = try containerValues.decode(Double.self, forKey: .minValue)
        minValue = minValueDecoded
        let maxValueDecoded = try containerValues.decode(Double.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let isTunableDecoded = try containerValues.decode(Bool.self, forKey: .isTunable)
        isTunable = isTunableDecoded
    }
}

extension DefaultContinuousHyperParameterRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefaultContinuousHyperParameterRange(isTunable: \(String(describing: isTunable)), maxValue: \(String(describing: maxValue)), minValue: \(String(describing: minValue)), name: \(String(describing: name)))"}
}

/// <p>Provides the name and default range of a continuous hyperparameter
///       and whether the hyperparameter is tunable. A tunable hyperparameter can
///       have its value determined during hyperparameter optimization (HPO).</p>
public struct DefaultContinuousHyperParameterRange: Equatable {
    /// <p>Whether the hyperparameter is tunable.</p>
    public let isTunable: Bool
    /// <p>The maximum allowable value for the hyperparameter.</p>
    public let maxValue: Double
    /// <p>The minimum allowable value for the hyperparameter.</p>
    public let minValue: Double
    /// <p>The name of the hyperparameter.</p>
    public let name: String?

    public init (
        isTunable: Bool = false,
        maxValue: Double = 0.0,
        minValue: Double = 0.0,
        name: String? = nil
    )
    {
        self.isTunable = isTunable
        self.maxValue = maxValue
        self.minValue = minValue
        self.name = name
    }
}

extension DefaultHyperParameterRanges: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case categoricalHyperParameterRanges
        case continuousHyperParameterRanges
        case integerHyperParameterRanges
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoricalHyperParameterRanges = categoricalHyperParameterRanges {
            var categoricalHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categoricalHyperParameterRanges)
            for defaultcategoricalhyperparameterranges0 in categoricalHyperParameterRanges {
                try categoricalHyperParameterRangesContainer.encode(defaultcategoricalhyperparameterranges0)
            }
        }
        if let continuousHyperParameterRanges = continuousHyperParameterRanges {
            var continuousHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .continuousHyperParameterRanges)
            for defaultcontinuoushyperparameterranges0 in continuousHyperParameterRanges {
                try continuousHyperParameterRangesContainer.encode(defaultcontinuoushyperparameterranges0)
            }
        }
        if let integerHyperParameterRanges = integerHyperParameterRanges {
            var integerHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .integerHyperParameterRanges)
            for defaultintegerhyperparameterranges0 in integerHyperParameterRanges {
                try integerHyperParameterRangesContainer.encode(defaultintegerhyperparameterranges0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let integerHyperParameterRangesContainer = try containerValues.decodeIfPresent([DefaultIntegerHyperParameterRange?].self, forKey: .integerHyperParameterRanges)
        var integerHyperParameterRangesDecoded0:[DefaultIntegerHyperParameterRange]? = nil
        if let integerHyperParameterRangesContainer = integerHyperParameterRangesContainer {
            integerHyperParameterRangesDecoded0 = [DefaultIntegerHyperParameterRange]()
            for structure0 in integerHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    integerHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        integerHyperParameterRanges = integerHyperParameterRangesDecoded0
        let continuousHyperParameterRangesContainer = try containerValues.decodeIfPresent([DefaultContinuousHyperParameterRange?].self, forKey: .continuousHyperParameterRanges)
        var continuousHyperParameterRangesDecoded0:[DefaultContinuousHyperParameterRange]? = nil
        if let continuousHyperParameterRangesContainer = continuousHyperParameterRangesContainer {
            continuousHyperParameterRangesDecoded0 = [DefaultContinuousHyperParameterRange]()
            for structure0 in continuousHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    continuousHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        continuousHyperParameterRanges = continuousHyperParameterRangesDecoded0
        let categoricalHyperParameterRangesContainer = try containerValues.decodeIfPresent([DefaultCategoricalHyperParameterRange?].self, forKey: .categoricalHyperParameterRanges)
        var categoricalHyperParameterRangesDecoded0:[DefaultCategoricalHyperParameterRange]? = nil
        if let categoricalHyperParameterRangesContainer = categoricalHyperParameterRangesContainer {
            categoricalHyperParameterRangesDecoded0 = [DefaultCategoricalHyperParameterRange]()
            for structure0 in categoricalHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    categoricalHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        categoricalHyperParameterRanges = categoricalHyperParameterRangesDecoded0
    }
}

extension DefaultHyperParameterRanges: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefaultHyperParameterRanges(categoricalHyperParameterRanges: \(String(describing: categoricalHyperParameterRanges)), continuousHyperParameterRanges: \(String(describing: continuousHyperParameterRanges)), integerHyperParameterRanges: \(String(describing: integerHyperParameterRanges)))"}
}

/// <p>Specifies the hyperparameters and their default ranges.
///     Hyperparameters can be categorical, continuous, or integer-valued.</p>
public struct DefaultHyperParameterRanges: Equatable {
    /// <p>The categorical hyperparameters and their default ranges.</p>
    public let categoricalHyperParameterRanges: [DefaultCategoricalHyperParameterRange]?
    /// <p>The continuous hyperparameters and their default ranges.</p>
    public let continuousHyperParameterRanges: [DefaultContinuousHyperParameterRange]?
    /// <p>The integer-valued hyperparameters and their default ranges.</p>
    public let integerHyperParameterRanges: [DefaultIntegerHyperParameterRange]?

    public init (
        categoricalHyperParameterRanges: [DefaultCategoricalHyperParameterRange]? = nil,
        continuousHyperParameterRanges: [DefaultContinuousHyperParameterRange]? = nil,
        integerHyperParameterRanges: [DefaultIntegerHyperParameterRange]? = nil
    )
    {
        self.categoricalHyperParameterRanges = categoricalHyperParameterRanges
        self.continuousHyperParameterRanges = continuousHyperParameterRanges
        self.integerHyperParameterRanges = integerHyperParameterRanges
    }
}

extension DefaultIntegerHyperParameterRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isTunable
        case maxValue
        case minValue
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isTunable != false {
            try encodeContainer.encode(isTunable, forKey: .isTunable)
        }
        if maxValue != 0 {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if minValue != 0 {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let minValueDecoded = try containerValues.decode(Int.self, forKey: .minValue)
        minValue = minValueDecoded
        let maxValueDecoded = try containerValues.decode(Int.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let isTunableDecoded = try containerValues.decode(Bool.self, forKey: .isTunable)
        isTunable = isTunableDecoded
    }
}

extension DefaultIntegerHyperParameterRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefaultIntegerHyperParameterRange(isTunable: \(String(describing: isTunable)), maxValue: \(String(describing: maxValue)), minValue: \(String(describing: minValue)), name: \(String(describing: name)))"}
}

/// <p>Provides the name and default range of a integer-valued hyperparameter
///       and whether the hyperparameter is tunable. A tunable hyperparameter can
///       have its value determined during hyperparameter optimization (HPO).</p>
public struct DefaultIntegerHyperParameterRange: Equatable {
    /// <p>Indicates whether the hyperparameter is tunable.</p>
    public let isTunable: Bool
    /// <p>The maximum allowable value for the hyperparameter.</p>
    public let maxValue: Int
    /// <p>The minimum allowable value for the hyperparameter.</p>
    public let minValue: Int
    /// <p>The name of the hyperparameter.</p>
    public let name: String?

    public init (
        isTunable: Bool = false,
        maxValue: Int = 0,
        minValue: Int = 0,
        name: String? = nil
    )
    {
        self.isTunable = isTunable
        self.maxValue = maxValue
        self.minValue = minValue
        self.name = name
    }
}

public struct DeleteCampaignInputBodyMiddleware: Middleware {
    public let id: String = "DeleteCampaignInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCampaignInput>
    public typealias MOutput = OperationOutput<DeleteCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCampaignOutputError>
}

extension DeleteCampaignInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCampaignInput(campaignArn: \(String(describing: campaignArn)))"}
}

extension DeleteCampaignInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case campaignArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
    }
}

public struct DeleteCampaignInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCampaignInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCampaignInput>
    public typealias MOutput = OperationOutput<DeleteCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCampaignOutputError>
}

public struct DeleteCampaignInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCampaignInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCampaignInput>
    public typealias MOutput = OperationOutput<DeleteCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCampaignOutputError>
}

public struct DeleteCampaignInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the campaign to delete.</p>
    public let campaignArn: String?

    public init (
        campaignArn: String? = nil
    )
    {
        self.campaignArn = campaignArn
    }
}

struct DeleteCampaignInputBody: Equatable {
    public let campaignArn: String?
}

extension DeleteCampaignInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case campaignArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
    }
}

extension DeleteCampaignOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCampaignOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCampaignOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCampaignOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCampaignOutputResponse()"}
}

extension DeleteCampaignOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCampaignOutputResponse: Equatable {

    public init() {}
}

struct DeleteCampaignOutputResponseBody: Equatable {
}

extension DeleteCampaignOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteDatasetGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDatasetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetGroupInput>
    public typealias MOutput = OperationOutput<DeleteDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetGroupOutputError>
}

extension DeleteDatasetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatasetGroupInput(datasetGroupArn: \(String(describing: datasetGroupArn)))"}
}

extension DeleteDatasetGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }
}

public struct DeleteDatasetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDatasetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetGroupInput>
    public typealias MOutput = OperationOutput<DeleteDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetGroupOutputError>
}

public struct DeleteDatasetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDatasetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetGroupInput>
    public typealias MOutput = OperationOutput<DeleteDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetGroupOutputError>
}

public struct DeleteDatasetGroupInput: Equatable {
    /// <p>The ARN of the dataset group to delete.</p>
    public let datasetGroupArn: String?

    public init (
        datasetGroupArn: String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct DeleteDatasetGroupInputBody: Equatable {
    public let datasetGroupArn: String?
}

extension DeleteDatasetGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

extension DeleteDatasetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetGroupOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatasetGroupOutputResponse()"}
}

extension DeleteDatasetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteDatasetGroupOutputResponseBody: Equatable {
}

extension DeleteDatasetGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteDatasetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetOutputError>
}

extension DeleteDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatasetInput(datasetArn: \(String(describing: datasetArn)))"}
}

extension DeleteDatasetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
    }
}

public struct DeleteDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset to delete.</p>
    public let datasetArn: String?

    public init (
        datasetArn: String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct DeleteDatasetInputBody: Equatable {
    public let datasetArn: String?
}

extension DeleteDatasetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

extension DeleteDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatasetOutputResponse()"}
}

extension DeleteDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetOutputResponse: Equatable {

    public init() {}
}

struct DeleteDatasetOutputResponseBody: Equatable {
}

extension DeleteDatasetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteEventTrackerInputBodyMiddleware: Middleware {
    public let id: String = "DeleteEventTrackerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventTrackerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventTrackerInput>
    public typealias MOutput = OperationOutput<DeleteEventTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventTrackerOutputError>
}

extension DeleteEventTrackerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEventTrackerInput(eventTrackerArn: \(String(describing: eventTrackerArn)))"}
}

extension DeleteEventTrackerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventTrackerArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventTrackerArn = eventTrackerArn {
            try encodeContainer.encode(eventTrackerArn, forKey: .eventTrackerArn)
        }
    }
}

public struct DeleteEventTrackerInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEventTrackerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventTrackerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventTrackerInput>
    public typealias MOutput = OperationOutput<DeleteEventTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventTrackerOutputError>
}

public struct DeleteEventTrackerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEventTrackerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventTrackerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventTrackerInput>
    public typealias MOutput = OperationOutput<DeleteEventTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventTrackerOutputError>
}

public struct DeleteEventTrackerInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the event tracker to delete.</p>
    public let eventTrackerArn: String?

    public init (
        eventTrackerArn: String? = nil
    )
    {
        self.eventTrackerArn = eventTrackerArn
    }
}

struct DeleteEventTrackerInputBody: Equatable {
    public let eventTrackerArn: String?
}

extension DeleteEventTrackerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventTrackerArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTrackerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventTrackerArn)
        eventTrackerArn = eventTrackerArnDecoded
    }
}

extension DeleteEventTrackerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEventTrackerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventTrackerOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventTrackerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEventTrackerOutputResponse()"}
}

extension DeleteEventTrackerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEventTrackerOutputResponse: Equatable {

    public init() {}
}

struct DeleteEventTrackerOutputResponseBody: Equatable {
}

extension DeleteEventTrackerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteFilterInputBodyMiddleware: Middleware {
    public let id: String = "DeleteFilterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFilterInput>
    public typealias MOutput = OperationOutput<DeleteFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFilterOutputError>
}

extension DeleteFilterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFilterInput(filterArn: \(String(describing: filterArn)))"}
}

extension DeleteFilterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filterArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterArn = filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
    }
}

public struct DeleteFilterInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFilterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFilterInput>
    public typealias MOutput = OperationOutput<DeleteFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFilterOutputError>
}

public struct DeleteFilterInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFilterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFilterInput>
    public typealias MOutput = OperationOutput<DeleteFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFilterOutputError>
}

public struct DeleteFilterInput: Equatable {
    /// <p>The ARN of the filter to delete.</p>
    public let filterArn: String?

    public init (
        filterArn: String? = nil
    )
    {
        self.filterArn = filterArn
    }
}

struct DeleteFilterInputBody: Equatable {
    public let filterArn: String?
}

extension DeleteFilterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filterArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
    }
}

extension DeleteFilterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFilterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFilterOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFilterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFilterOutputResponse()"}
}

extension DeleteFilterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFilterOutputResponse: Equatable {

    public init() {}
}

struct DeleteFilterOutputResponseBody: Equatable {
}

extension DeleteFilterOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteSchemaInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSchemaInput>
    public typealias MOutput = OperationOutput<DeleteSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSchemaOutputError>
}

extension DeleteSchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSchemaInput(schemaArn: \(String(describing: schemaArn)))"}
}

extension DeleteSchemaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case schemaArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }
}

public struct DeleteSchemaInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSchemaInput>
    public typealias MOutput = OperationOutput<DeleteSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSchemaOutputError>
}

public struct DeleteSchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSchemaInput>
    public typealias MOutput = OperationOutput<DeleteSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSchemaOutputError>
}

public struct DeleteSchemaInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the schema to delete.</p>
    public let schemaArn: String?

    public init (
        schemaArn: String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct DeleteSchemaInputBody: Equatable {
    public let schemaArn: String?
}

extension DeleteSchemaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case schemaArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

extension DeleteSchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSchemaOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSchemaOutputResponse()"}
}

extension DeleteSchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSchemaOutputResponse: Equatable {

    public init() {}
}

struct DeleteSchemaOutputResponseBody: Equatable {
}

extension DeleteSchemaOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteSolutionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSolutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSolutionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSolutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSolutionInput>
    public typealias MOutput = OperationOutput<DeleteSolutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSolutionOutputError>
}

extension DeleteSolutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSolutionInput(solutionArn: \(String(describing: solutionArn)))"}
}

extension DeleteSolutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case solutionArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let solutionArn = solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
    }
}

public struct DeleteSolutionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSolutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSolutionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSolutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSolutionInput>
    public typealias MOutput = OperationOutput<DeleteSolutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSolutionOutputError>
}

public struct DeleteSolutionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSolutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSolutionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSolutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSolutionInput>
    public typealias MOutput = OperationOutput<DeleteSolutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSolutionOutputError>
}

public struct DeleteSolutionInput: Equatable {
    /// <p>The ARN of the solution to delete.</p>
    public let solutionArn: String?

    public init (
        solutionArn: String? = nil
    )
    {
        self.solutionArn = solutionArn
    }
}

struct DeleteSolutionInputBody: Equatable {
    public let solutionArn: String?
}

extension DeleteSolutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case solutionArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
    }
}

extension DeleteSolutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSolutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSolutionOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSolutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSolutionOutputResponse()"}
}

extension DeleteSolutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSolutionOutputResponse: Equatable {

    public init() {}
}

struct DeleteSolutionOutputResponseBody: Equatable {
}

extension DeleteSolutionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeAlgorithmInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAlgorithmInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAlgorithmInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAlgorithmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAlgorithmInput>
    public typealias MOutput = OperationOutput<DescribeAlgorithmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAlgorithmOutputError>
}

extension DescribeAlgorithmInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAlgorithmInput(algorithmArn: \(String(describing: algorithmArn)))"}
}

extension DescribeAlgorithmInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case algorithmArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
    }
}

public struct DescribeAlgorithmInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAlgorithmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAlgorithmInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAlgorithmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAlgorithmInput>
    public typealias MOutput = OperationOutput<DescribeAlgorithmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAlgorithmOutputError>
}

public struct DescribeAlgorithmInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAlgorithmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAlgorithmInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAlgorithmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAlgorithmInput>
    public typealias MOutput = OperationOutput<DescribeAlgorithmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAlgorithmOutputError>
}

public struct DescribeAlgorithmInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the algorithm to describe.</p>
    public let algorithmArn: String?

    public init (
        algorithmArn: String? = nil
    )
    {
        self.algorithmArn = algorithmArn
    }
}

struct DescribeAlgorithmInputBody: Equatable {
    public let algorithmArn: String?
}

extension DescribeAlgorithmInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case algorithmArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
    }
}

extension DescribeAlgorithmOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAlgorithmOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAlgorithmOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAlgorithmOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAlgorithmOutputResponse(algorithm: \(String(describing: algorithm)))"}
}

extension DescribeAlgorithmOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAlgorithmOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.algorithm = output.algorithm
        } else {
            self.algorithm = nil
        }
    }
}

public struct DescribeAlgorithmOutputResponse: Equatable {
    /// <p>A listing of the properties of the algorithm.</p>
    public let algorithm: Algorithm?

    public init (
        algorithm: Algorithm? = nil
    )
    {
        self.algorithm = algorithm
    }
}

struct DescribeAlgorithmOutputResponseBody: Equatable {
    public let algorithm: Algorithm?
}

extension DescribeAlgorithmOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case algorithm
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmDecoded = try containerValues.decodeIfPresent(Algorithm.self, forKey: .algorithm)
        algorithm = algorithmDecoded
    }
}

public struct DescribeBatchInferenceJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeBatchInferenceJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBatchInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBatchInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBatchInferenceJobInput>
    public typealias MOutput = OperationOutput<DescribeBatchInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBatchInferenceJobOutputError>
}

extension DescribeBatchInferenceJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBatchInferenceJobInput(batchInferenceJobArn: \(String(describing: batchInferenceJobArn)))"}
}

extension DescribeBatchInferenceJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case batchInferenceJobArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchInferenceJobArn = batchInferenceJobArn {
            try encodeContainer.encode(batchInferenceJobArn, forKey: .batchInferenceJobArn)
        }
    }
}

public struct DescribeBatchInferenceJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBatchInferenceJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBatchInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBatchInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBatchInferenceJobInput>
    public typealias MOutput = OperationOutput<DescribeBatchInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBatchInferenceJobOutputError>
}

public struct DescribeBatchInferenceJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBatchInferenceJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBatchInferenceJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBatchInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBatchInferenceJobInput>
    public typealias MOutput = OperationOutput<DescribeBatchInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBatchInferenceJobOutputError>
}

public struct DescribeBatchInferenceJobInput: Equatable {
    /// <p>The ARN of the batch inference job to describe.</p>
    public let batchInferenceJobArn: String?

    public init (
        batchInferenceJobArn: String? = nil
    )
    {
        self.batchInferenceJobArn = batchInferenceJobArn
    }
}

struct DescribeBatchInferenceJobInputBody: Equatable {
    public let batchInferenceJobArn: String?
}

extension DescribeBatchInferenceJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case batchInferenceJobArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchInferenceJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .batchInferenceJobArn)
        batchInferenceJobArn = batchInferenceJobArnDecoded
    }
}

extension DescribeBatchInferenceJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBatchInferenceJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBatchInferenceJobOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBatchInferenceJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBatchInferenceJobOutputResponse(batchInferenceJob: \(String(describing: batchInferenceJob)))"}
}

extension DescribeBatchInferenceJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBatchInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.batchInferenceJob = output.batchInferenceJob
        } else {
            self.batchInferenceJob = nil
        }
    }
}

public struct DescribeBatchInferenceJobOutputResponse: Equatable {
    /// <p>Information on the specified batch inference job.</p>
    public let batchInferenceJob: BatchInferenceJob?

    public init (
        batchInferenceJob: BatchInferenceJob? = nil
    )
    {
        self.batchInferenceJob = batchInferenceJob
    }
}

struct DescribeBatchInferenceJobOutputResponseBody: Equatable {
    public let batchInferenceJob: BatchInferenceJob?
}

extension DescribeBatchInferenceJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case batchInferenceJob
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchInferenceJobDecoded = try containerValues.decodeIfPresent(BatchInferenceJob.self, forKey: .batchInferenceJob)
        batchInferenceJob = batchInferenceJobDecoded
    }
}

public struct DescribeCampaignInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCampaignInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCampaignInput>
    public typealias MOutput = OperationOutput<DescribeCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCampaignOutputError>
}

extension DescribeCampaignInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCampaignInput(campaignArn: \(String(describing: campaignArn)))"}
}

extension DescribeCampaignInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case campaignArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
    }
}

public struct DescribeCampaignInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCampaignInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCampaignInput>
    public typealias MOutput = OperationOutput<DescribeCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCampaignOutputError>
}

public struct DescribeCampaignInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCampaignInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCampaignInput>
    public typealias MOutput = OperationOutput<DescribeCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCampaignOutputError>
}

public struct DescribeCampaignInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the campaign.</p>
    public let campaignArn: String?

    public init (
        campaignArn: String? = nil
    )
    {
        self.campaignArn = campaignArn
    }
}

struct DescribeCampaignInputBody: Equatable {
    public let campaignArn: String?
}

extension DescribeCampaignInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case campaignArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
    }
}

extension DescribeCampaignOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCampaignOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCampaignOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCampaignOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCampaignOutputResponse(campaign: \(String(describing: campaign)))"}
}

extension DescribeCampaignOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCampaignOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.campaign = output.campaign
        } else {
            self.campaign = nil
        }
    }
}

public struct DescribeCampaignOutputResponse: Equatable {
    /// <p>The properties of the campaign.</p>
    public let campaign: Campaign?

    public init (
        campaign: Campaign? = nil
    )
    {
        self.campaign = campaign
    }
}

struct DescribeCampaignOutputResponseBody: Equatable {
    public let campaign: Campaign?
}

extension DescribeCampaignOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case campaign
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignDecoded = try containerValues.decodeIfPresent(Campaign.self, forKey: .campaign)
        campaign = campaignDecoded
    }
}

public struct DescribeDatasetExportJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDatasetExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetExportJobInput>
    public typealias MOutput = OperationOutput<DescribeDatasetExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetExportJobOutputError>
}

extension DescribeDatasetExportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetExportJobInput(datasetExportJobArn: \(String(describing: datasetExportJobArn)))"}
}

extension DescribeDatasetExportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetExportJobArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetExportJobArn = datasetExportJobArn {
            try encodeContainer.encode(datasetExportJobArn, forKey: .datasetExportJobArn)
        }
    }
}

public struct DescribeDatasetExportJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDatasetExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetExportJobInput>
    public typealias MOutput = OperationOutput<DescribeDatasetExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetExportJobOutputError>
}

public struct DescribeDatasetExportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDatasetExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetExportJobInput>
    public typealias MOutput = OperationOutput<DescribeDatasetExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetExportJobOutputError>
}

public struct DescribeDatasetExportJobInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset export job to describe.</p>
    public let datasetExportJobArn: String?

    public init (
        datasetExportJobArn: String? = nil
    )
    {
        self.datasetExportJobArn = datasetExportJobArn
    }
}

struct DescribeDatasetExportJobInputBody: Equatable {
    public let datasetExportJobArn: String?
}

extension DescribeDatasetExportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetExportJobArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetExportJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetExportJobArn)
        datasetExportJobArn = datasetExportJobArnDecoded
    }
}

extension DescribeDatasetExportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetExportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetExportJobOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetExportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetExportJobOutputResponse(datasetExportJob: \(String(describing: datasetExportJob)))"}
}

extension DescribeDatasetExportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDatasetExportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasetExportJob = output.datasetExportJob
        } else {
            self.datasetExportJob = nil
        }
    }
}

public struct DescribeDatasetExportJobOutputResponse: Equatable {
    /// <p>Information about the dataset export job, including the status.</p>
    ///          <p>The status is one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING</p>
    ///             </li>
    ///             <li>
    ///                <p>CREATE IN_PROGRESS</p>
    ///             </li>
    ///             <li>
    ///                <p>ACTIVE</p>
    ///             </li>
    ///             <li>
    ///                <p>CREATE FAILED</p>
    ///             </li>
    ///          </ul>
    public let datasetExportJob: DatasetExportJob?

    public init (
        datasetExportJob: DatasetExportJob? = nil
    )
    {
        self.datasetExportJob = datasetExportJob
    }
}

struct DescribeDatasetExportJobOutputResponseBody: Equatable {
    public let datasetExportJob: DatasetExportJob?
}

extension DescribeDatasetExportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetExportJob
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetExportJobDecoded = try containerValues.decodeIfPresent(DatasetExportJob.self, forKey: .datasetExportJob)
        datasetExportJob = datasetExportJobDecoded
    }
}

public struct DescribeDatasetGroupInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDatasetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetGroupInput>
    public typealias MOutput = OperationOutput<DescribeDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetGroupOutputError>
}

extension DescribeDatasetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetGroupInput(datasetGroupArn: \(String(describing: datasetGroupArn)))"}
}

extension DescribeDatasetGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }
}

public struct DescribeDatasetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDatasetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetGroupInput>
    public typealias MOutput = OperationOutput<DescribeDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetGroupOutputError>
}

public struct DescribeDatasetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDatasetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetGroupInput>
    public typealias MOutput = OperationOutput<DescribeDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetGroupOutputError>
}

public struct DescribeDatasetGroupInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset group to describe.</p>
    public let datasetGroupArn: String?

    public init (
        datasetGroupArn: String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct DescribeDatasetGroupInputBody: Equatable {
    public let datasetGroupArn: String?
}

extension DescribeDatasetGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

extension DescribeDatasetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetGroupOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetGroupOutputResponse(datasetGroup: \(String(describing: datasetGroup)))"}
}

extension DescribeDatasetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDatasetGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasetGroup = output.datasetGroup
        } else {
            self.datasetGroup = nil
        }
    }
}

public struct DescribeDatasetGroupOutputResponse: Equatable {
    /// <p>A listing of the dataset group's properties.</p>
    public let datasetGroup: DatasetGroup?

    public init (
        datasetGroup: DatasetGroup? = nil
    )
    {
        self.datasetGroup = datasetGroup
    }
}

struct DescribeDatasetGroupOutputResponseBody: Equatable {
    public let datasetGroup: DatasetGroup?
}

extension DescribeDatasetGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetGroup
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupDecoded = try containerValues.decodeIfPresent(DatasetGroup.self, forKey: .datasetGroup)
        datasetGroup = datasetGroupDecoded
    }
}

public struct DescribeDatasetImportJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDatasetImportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetImportJobInput>
    public typealias MOutput = OperationOutput<DescribeDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetImportJobOutputError>
}

extension DescribeDatasetImportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetImportJobInput(datasetImportJobArn: \(String(describing: datasetImportJobArn)))"}
}

extension DescribeDatasetImportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetImportJobArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetImportJobArn = datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
    }
}

public struct DescribeDatasetImportJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDatasetImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetImportJobInput>
    public typealias MOutput = OperationOutput<DescribeDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetImportJobOutputError>
}

public struct DescribeDatasetImportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDatasetImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetImportJobInput>
    public typealias MOutput = OperationOutput<DescribeDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetImportJobOutputError>
}

public struct DescribeDatasetImportJobInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset import job to describe.</p>
    public let datasetImportJobArn: String?

    public init (
        datasetImportJobArn: String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

struct DescribeDatasetImportJobInputBody: Equatable {
    public let datasetImportJobArn: String?
}

extension DescribeDatasetImportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetImportJobArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
    }
}

extension DescribeDatasetImportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetImportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetImportJobOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetImportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetImportJobOutputResponse(datasetImportJob: \(String(describing: datasetImportJob)))"}
}

extension DescribeDatasetImportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDatasetImportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasetImportJob = output.datasetImportJob
        } else {
            self.datasetImportJob = nil
        }
    }
}

public struct DescribeDatasetImportJobOutputResponse: Equatable {
    /// <p>Information about the dataset import job, including the status.</p>
    ///          <p>The status is one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING</p>
    ///             </li>
    ///             <li>
    ///                <p>CREATE IN_PROGRESS</p>
    ///             </li>
    ///             <li>
    ///                <p>ACTIVE</p>
    ///             </li>
    ///             <li>
    ///                <p>CREATE FAILED</p>
    ///             </li>
    ///          </ul>
    public let datasetImportJob: DatasetImportJob?

    public init (
        datasetImportJob: DatasetImportJob? = nil
    )
    {
        self.datasetImportJob = datasetImportJob
    }
}

struct DescribeDatasetImportJobOutputResponseBody: Equatable {
    public let datasetImportJob: DatasetImportJob?
}

extension DescribeDatasetImportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetImportJob
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobDecoded = try containerValues.decodeIfPresent(DatasetImportJob.self, forKey: .datasetImportJob)
        datasetImportJob = datasetImportJobDecoded
    }
}

public struct DescribeDatasetInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetOutputError>
}

extension DescribeDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetInput(datasetArn: \(String(describing: datasetArn)))"}
}

extension DescribeDatasetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
    }
}

public struct DescribeDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset to describe.</p>
    public let datasetArn: String?

    public init (
        datasetArn: String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct DescribeDatasetInputBody: Equatable {
    public let datasetArn: String?
}

extension DescribeDatasetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

extension DescribeDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetOutputResponse(dataset: \(String(describing: dataset)))"}
}

extension DescribeDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDatasetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataset = output.dataset
        } else {
            self.dataset = nil
        }
    }
}

public struct DescribeDatasetOutputResponse: Equatable {
    /// <p>A listing of the dataset's properties.</p>
    public let dataset: Dataset?

    public init (
        dataset: Dataset? = nil
    )
    {
        self.dataset = dataset
    }
}

struct DescribeDatasetOutputResponseBody: Equatable {
    public let dataset: Dataset?
}

extension DescribeDatasetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataset
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetDecoded = try containerValues.decodeIfPresent(Dataset.self, forKey: .dataset)
        dataset = datasetDecoded
    }
}

public struct DescribeEventTrackerInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventTrackerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventTrackerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventTrackerInput>
    public typealias MOutput = OperationOutput<DescribeEventTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventTrackerOutputError>
}

extension DescribeEventTrackerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventTrackerInput(eventTrackerArn: \(String(describing: eventTrackerArn)))"}
}

extension DescribeEventTrackerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventTrackerArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventTrackerArn = eventTrackerArn {
            try encodeContainer.encode(eventTrackerArn, forKey: .eventTrackerArn)
        }
    }
}

public struct DescribeEventTrackerInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventTrackerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventTrackerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventTrackerInput>
    public typealias MOutput = OperationOutput<DescribeEventTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventTrackerOutputError>
}

public struct DescribeEventTrackerInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventTrackerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventTrackerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventTrackerInput>
    public typealias MOutput = OperationOutput<DescribeEventTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventTrackerOutputError>
}

public struct DescribeEventTrackerInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the event tracker to describe.</p>
    public let eventTrackerArn: String?

    public init (
        eventTrackerArn: String? = nil
    )
    {
        self.eventTrackerArn = eventTrackerArn
    }
}

struct DescribeEventTrackerInputBody: Equatable {
    public let eventTrackerArn: String?
}

extension DescribeEventTrackerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventTrackerArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTrackerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventTrackerArn)
        eventTrackerArn = eventTrackerArnDecoded
    }
}

extension DescribeEventTrackerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventTrackerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventTrackerOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventTrackerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventTrackerOutputResponse(eventTracker: \(String(describing: eventTracker)))"}
}

extension DescribeEventTrackerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventTrackerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventTracker = output.eventTracker
        } else {
            self.eventTracker = nil
        }
    }
}

public struct DescribeEventTrackerOutputResponse: Equatable {
    /// <p>An object that describes the event tracker.</p>
    public let eventTracker: EventTracker?

    public init (
        eventTracker: EventTracker? = nil
    )
    {
        self.eventTracker = eventTracker
    }
}

struct DescribeEventTrackerOutputResponseBody: Equatable {
    public let eventTracker: EventTracker?
}

extension DescribeEventTrackerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventTracker
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTrackerDecoded = try containerValues.decodeIfPresent(EventTracker.self, forKey: .eventTracker)
        eventTracker = eventTrackerDecoded
    }
}

public struct DescribeFeatureTransformationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeFeatureTransformationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFeatureTransformationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFeatureTransformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFeatureTransformationInput>
    public typealias MOutput = OperationOutput<DescribeFeatureTransformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFeatureTransformationOutputError>
}

extension DescribeFeatureTransformationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFeatureTransformationInput(featureTransformationArn: \(String(describing: featureTransformationArn)))"}
}

extension DescribeFeatureTransformationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case featureTransformationArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featureTransformationArn = featureTransformationArn {
            try encodeContainer.encode(featureTransformationArn, forKey: .featureTransformationArn)
        }
    }
}

public struct DescribeFeatureTransformationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeFeatureTransformationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFeatureTransformationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFeatureTransformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFeatureTransformationInput>
    public typealias MOutput = OperationOutput<DescribeFeatureTransformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFeatureTransformationOutputError>
}

public struct DescribeFeatureTransformationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeFeatureTransformationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFeatureTransformationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFeatureTransformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFeatureTransformationInput>
    public typealias MOutput = OperationOutput<DescribeFeatureTransformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFeatureTransformationOutputError>
}

public struct DescribeFeatureTransformationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the feature transformation to describe.</p>
    public let featureTransformationArn: String?

    public init (
        featureTransformationArn: String? = nil
    )
    {
        self.featureTransformationArn = featureTransformationArn
    }
}

struct DescribeFeatureTransformationInputBody: Equatable {
    public let featureTransformationArn: String?
}

extension DescribeFeatureTransformationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case featureTransformationArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureTransformationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .featureTransformationArn)
        featureTransformationArn = featureTransformationArnDecoded
    }
}

extension DescribeFeatureTransformationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFeatureTransformationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFeatureTransformationOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFeatureTransformationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFeatureTransformationOutputResponse(featureTransformation: \(String(describing: featureTransformation)))"}
}

extension DescribeFeatureTransformationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeFeatureTransformationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.featureTransformation = output.featureTransformation
        } else {
            self.featureTransformation = nil
        }
    }
}

public struct DescribeFeatureTransformationOutputResponse: Equatable {
    /// <p>A listing of the FeatureTransformation properties.</p>
    public let featureTransformation: FeatureTransformation?

    public init (
        featureTransformation: FeatureTransformation? = nil
    )
    {
        self.featureTransformation = featureTransformation
    }
}

struct DescribeFeatureTransformationOutputResponseBody: Equatable {
    public let featureTransformation: FeatureTransformation?
}

extension DescribeFeatureTransformationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case featureTransformation
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureTransformationDecoded = try containerValues.decodeIfPresent(FeatureTransformation.self, forKey: .featureTransformation)
        featureTransformation = featureTransformationDecoded
    }
}

public struct DescribeFilterInputBodyMiddleware: Middleware {
    public let id: String = "DescribeFilterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFilterInput>
    public typealias MOutput = OperationOutput<DescribeFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFilterOutputError>
}

extension DescribeFilterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFilterInput(filterArn: \(String(describing: filterArn)))"}
}

extension DescribeFilterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filterArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterArn = filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
    }
}

public struct DescribeFilterInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeFilterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFilterInput>
    public typealias MOutput = OperationOutput<DescribeFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFilterOutputError>
}

public struct DescribeFilterInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeFilterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFilterInput>
    public typealias MOutput = OperationOutput<DescribeFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFilterOutputError>
}

public struct DescribeFilterInput: Equatable {
    /// <p>The ARN of the filter to describe.</p>
    public let filterArn: String?

    public init (
        filterArn: String? = nil
    )
    {
        self.filterArn = filterArn
    }
}

struct DescribeFilterInputBody: Equatable {
    public let filterArn: String?
}

extension DescribeFilterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filterArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
    }
}

extension DescribeFilterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFilterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFilterOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFilterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFilterOutputResponse(filter: \(String(describing: filter)))"}
}

extension DescribeFilterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeFilterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.filter = output.filter
        } else {
            self.filter = nil
        }
    }
}

public struct DescribeFilterOutputResponse: Equatable {
    /// <p>The filter's details.</p>
    public let filter: Filter?

    public init (
        filter: Filter? = nil
    )
    {
        self.filter = filter
    }
}

struct DescribeFilterOutputResponseBody: Equatable {
    public let filter: Filter?
}

extension DescribeFilterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(Filter.self, forKey: .filter)
        filter = filterDecoded
    }
}

public struct DescribeRecipeInputBodyMiddleware: Middleware {
    public let id: String = "DescribeRecipeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRecipeInput>
    public typealias MOutput = OperationOutput<DescribeRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRecipeOutputError>
}

extension DescribeRecipeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRecipeInput(recipeArn: \(String(describing: recipeArn)))"}
}

extension DescribeRecipeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recipeArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recipeArn = recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
    }
}

public struct DescribeRecipeInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRecipeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRecipeInput>
    public typealias MOutput = OperationOutput<DescribeRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRecipeOutputError>
}

public struct DescribeRecipeInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRecipeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRecipeInput>
    public typealias MOutput = OperationOutput<DescribeRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRecipeOutputError>
}

public struct DescribeRecipeInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the recipe to describe.</p>
    public let recipeArn: String?

    public init (
        recipeArn: String? = nil
    )
    {
        self.recipeArn = recipeArn
    }
}

struct DescribeRecipeInputBody: Equatable {
    public let recipeArn: String?
}

extension DescribeRecipeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case recipeArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
    }
}

extension DescribeRecipeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRecipeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRecipeOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRecipeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRecipeOutputResponse(recipe: \(String(describing: recipe)))"}
}

extension DescribeRecipeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRecipeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.recipe = output.recipe
        } else {
            self.recipe = nil
        }
    }
}

public struct DescribeRecipeOutputResponse: Equatable {
    /// <p>An object that describes the recipe.</p>
    public let recipe: Recipe?

    public init (
        recipe: Recipe? = nil
    )
    {
        self.recipe = recipe
    }
}

struct DescribeRecipeOutputResponseBody: Equatable {
    public let recipe: Recipe?
}

extension DescribeRecipeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case recipe
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipeDecoded = try containerValues.decodeIfPresent(Recipe.self, forKey: .recipe)
        recipe = recipeDecoded
    }
}

public struct DescribeSchemaInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSchemaInput>
    public typealias MOutput = OperationOutput<DescribeSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSchemaOutputError>
}

extension DescribeSchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSchemaInput(schemaArn: \(String(describing: schemaArn)))"}
}

extension DescribeSchemaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case schemaArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }
}

public struct DescribeSchemaInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSchemaInput>
    public typealias MOutput = OperationOutput<DescribeSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSchemaOutputError>
}

public struct DescribeSchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSchemaInput>
    public typealias MOutput = OperationOutput<DescribeSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSchemaOutputError>
}

public struct DescribeSchemaInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the schema to retrieve.</p>
    public let schemaArn: String?

    public init (
        schemaArn: String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct DescribeSchemaInputBody: Equatable {
    public let schemaArn: String?
}

extension DescribeSchemaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case schemaArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

extension DescribeSchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSchemaOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSchemaOutputResponse(schema: \(String(describing: schema)))"}
}

extension DescribeSchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSchemaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.schema = output.schema
        } else {
            self.schema = nil
        }
    }
}

public struct DescribeSchemaOutputResponse: Equatable {
    /// <p>The requested schema.</p>
    public let schema: DatasetSchema?

    public init (
        schema: DatasetSchema? = nil
    )
    {
        self.schema = schema
    }
}

struct DescribeSchemaOutputResponseBody: Equatable {
    public let schema: DatasetSchema?
}

extension DescribeSchemaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case schema
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaDecoded = try containerValues.decodeIfPresent(DatasetSchema.self, forKey: .schema)
        schema = schemaDecoded
    }
}

public struct DescribeSolutionInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSolutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSolutionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSolutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSolutionInput>
    public typealias MOutput = OperationOutput<DescribeSolutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSolutionOutputError>
}

extension DescribeSolutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSolutionInput(solutionArn: \(String(describing: solutionArn)))"}
}

extension DescribeSolutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case solutionArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let solutionArn = solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
    }
}

public struct DescribeSolutionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSolutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSolutionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSolutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSolutionInput>
    public typealias MOutput = OperationOutput<DescribeSolutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSolutionOutputError>
}

public struct DescribeSolutionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSolutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSolutionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSolutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSolutionInput>
    public typealias MOutput = OperationOutput<DescribeSolutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSolutionOutputError>
}

public struct DescribeSolutionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the solution to describe.</p>
    public let solutionArn: String?

    public init (
        solutionArn: String? = nil
    )
    {
        self.solutionArn = solutionArn
    }
}

struct DescribeSolutionInputBody: Equatable {
    public let solutionArn: String?
}

extension DescribeSolutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case solutionArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
    }
}

extension DescribeSolutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSolutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSolutionOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSolutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSolutionOutputResponse(solution: \(String(describing: solution)))"}
}

extension DescribeSolutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSolutionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.solution = output.solution
        } else {
            self.solution = nil
        }
    }
}

public struct DescribeSolutionOutputResponse: Equatable {
    /// <p>An object that describes the solution.</p>
    public let solution: Solution?

    public init (
        solution: Solution? = nil
    )
    {
        self.solution = solution
    }
}

struct DescribeSolutionOutputResponseBody: Equatable {
    public let solution: Solution?
}

extension DescribeSolutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case solution
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionDecoded = try containerValues.decodeIfPresent(Solution.self, forKey: .solution)
        solution = solutionDecoded
    }
}

public struct DescribeSolutionVersionInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSolutionVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSolutionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSolutionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSolutionVersionInput>
    public typealias MOutput = OperationOutput<DescribeSolutionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSolutionVersionOutputError>
}

extension DescribeSolutionVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSolutionVersionInput(solutionVersionArn: \(String(describing: solutionVersionArn)))"}
}

extension DescribeSolutionVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case solutionVersionArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

public struct DescribeSolutionVersionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSolutionVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSolutionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSolutionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSolutionVersionInput>
    public typealias MOutput = OperationOutput<DescribeSolutionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSolutionVersionOutputError>
}

public struct DescribeSolutionVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSolutionVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSolutionVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSolutionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSolutionVersionInput>
    public typealias MOutput = OperationOutput<DescribeSolutionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSolutionVersionOutputError>
}

public struct DescribeSolutionVersionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the solution version.</p>
    public let solutionVersionArn: String?

    public init (
        solutionVersionArn: String? = nil
    )
    {
        self.solutionVersionArn = solutionVersionArn
    }
}

struct DescribeSolutionVersionInputBody: Equatable {
    public let solutionVersionArn: String?
}

extension DescribeSolutionVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case solutionVersionArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
    }
}

extension DescribeSolutionVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSolutionVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSolutionVersionOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSolutionVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSolutionVersionOutputResponse(solutionVersion: \(String(describing: solutionVersion)))"}
}

extension DescribeSolutionVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSolutionVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.solutionVersion = output.solutionVersion
        } else {
            self.solutionVersion = nil
        }
    }
}

public struct DescribeSolutionVersionOutputResponse: Equatable {
    /// <p>The solution version.</p>
    public let solutionVersion: SolutionVersion?

    public init (
        solutionVersion: SolutionVersion? = nil
    )
    {
        self.solutionVersion = solutionVersion
    }
}

struct DescribeSolutionVersionOutputResponseBody: Equatable {
    public let solutionVersion: SolutionVersion?
}

extension DescribeSolutionVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case solutionVersion
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionDecoded = try containerValues.decodeIfPresent(SolutionVersion.self, forKey: .solutionVersion)
        solutionVersion = solutionVersionDecoded
    }
}

extension EventTracker: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId
        case creationDateTime
        case datasetGroupArn
        case eventTrackerArn
        case lastUpdatedDateTime
        case name
        case status
        case trackingId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let eventTrackerArn = eventTrackerArn {
            try encodeContainer.encode(eventTrackerArn, forKey: .eventTrackerArn)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let trackingId = trackingId {
            try encodeContainer.encode(trackingId, forKey: .trackingId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let eventTrackerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventTrackerArn)
        eventTrackerArn = eventTrackerArnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let trackingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trackingId)
        trackingId = trackingIdDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension EventTracker: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventTracker(accountId: \(String(describing: accountId)), creationDateTime: \(String(describing: creationDateTime)), datasetGroupArn: \(String(describing: datasetGroupArn)), eventTrackerArn: \(String(describing: eventTrackerArn)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), name: \(String(describing: name)), status: \(String(describing: status)), trackingId: \(String(describing: trackingId)))"}
}

/// <p>Provides information about an event tracker.</p>
public struct EventTracker: Equatable {
    /// <p>The Amazon AWS account that owns the event tracker.</p>
    public let accountId: String?
    /// <p>The date and time (in Unix format) that the event tracker was created.</p>
    public let creationDateTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the dataset group that receives the event data.</p>
    public let datasetGroupArn: String?
    /// <p>The ARN of the event tracker.</p>
    public let eventTrackerArn: String?
    /// <p>The date and time (in Unix time) that the event tracker was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The name of the event tracker.</p>
    public let name: String?
    /// <p>The status of the event tracker.</p>
    ///          <p>An event tracker can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///             <li>
    ///                <p>DELETE PENDING > DELETE IN_PROGRESS</p>
    ///             </li>
    ///          </ul>
    public let status: String?
    /// <p>The ID of the event tracker. Include this ID in requests to the
    ///     <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_UBS_PutEvents.html">PutEvents</a> API.</p>
    public let trackingId: String?

    public init (
        accountId: String? = nil,
        creationDateTime: Date? = nil,
        datasetGroupArn: String? = nil,
        eventTrackerArn: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        name: String? = nil,
        status: String? = nil,
        trackingId: String? = nil
    )
    {
        self.accountId = accountId
        self.creationDateTime = creationDateTime
        self.datasetGroupArn = datasetGroupArn
        self.eventTrackerArn = eventTrackerArn
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.name = name
        self.status = status
        self.trackingId = trackingId
    }
}

extension EventTrackerSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case eventTrackerArn
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let eventTrackerArn = eventTrackerArn {
            try encodeContainer.encode(eventTrackerArn, forKey: .eventTrackerArn)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let eventTrackerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventTrackerArn)
        eventTrackerArn = eventTrackerArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension EventTrackerSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventTrackerSummary(creationDateTime: \(String(describing: creationDateTime)), eventTrackerArn: \(String(describing: eventTrackerArn)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), name: \(String(describing: name)), status: \(String(describing: status)))"}
}

/// <p>Provides a summary of the properties of an event tracker. For a complete listing, call the
///       <a>DescribeEventTracker</a> API.</p>
public struct EventTrackerSummary: Equatable {
    /// <p>The date and time (in Unix time) that the event tracker was created.</p>
    public let creationDateTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the event tracker.</p>
    public let eventTrackerArn: String?
    /// <p>The date and time (in Unix time) that the event tracker was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The name of the event tracker.</p>
    public let name: String?
    /// <p>The status of the event tracker.</p>
    ///          <p>An event tracker can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///             <li>
    ///                <p>DELETE PENDING > DELETE IN_PROGRESS</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        creationDateTime: Date? = nil,
        eventTrackerArn: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        name: String? = nil,
        status: String? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.eventTrackerArn = eventTrackerArn
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.name = name
        self.status = status
    }
}

extension FeatureTransformation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case defaultParameters
        case featureTransformationArn
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let defaultParameters = defaultParameters {
            var defaultParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .defaultParameters)
            for (dictKey0, featurizationparameters0) in defaultParameters {
                try defaultParametersContainer.encode(featurizationparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let featureTransformationArn = featureTransformationArn {
            try encodeContainer.encode(featureTransformationArn, forKey: .featureTransformationArn)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let featureTransformationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .featureTransformationArn)
        featureTransformationArn = featureTransformationArnDecoded
        let defaultParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .defaultParameters)
        var defaultParametersDecoded0: [String:String]? = nil
        if let defaultParametersContainer = defaultParametersContainer {
            defaultParametersDecoded0 = [String:String]()
            for (key0, parametervalue0) in defaultParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    defaultParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        defaultParameters = defaultParametersDecoded0
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension FeatureTransformation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FeatureTransformation(creationDateTime: \(String(describing: creationDateTime)), defaultParameters: \(String(describing: defaultParameters)), featureTransformationArn: \(String(describing: featureTransformationArn)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), name: \(String(describing: name)), status: \(String(describing: status)))"}
}

/// <p>Provides feature transformation information. Feature transformation is the process
///       of modifying raw input data into a form more suitable for model training.</p>
public struct FeatureTransformation: Equatable {
    /// <p>The creation date and time (in Unix time) of the feature transformation.</p>
    public let creationDateTime: Date?
    /// <p>Provides the default parameters for feature transformation.</p>
    public let defaultParameters: [String:String]?
    /// <p>The Amazon Resource Name (ARN) of the FeatureTransformation object.</p>
    public let featureTransformationArn: String?
    /// <p>The last update date and time (in Unix time) of the feature transformation.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The name of the feature transformation.</p>
    public let name: String?
    /// <p>The status of the feature transformation.</p>
    ///          <p>A feature transformation can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        creationDateTime: Date? = nil,
        defaultParameters: [String:String]? = nil,
        featureTransformationArn: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        name: String? = nil,
        status: String? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.defaultParameters = defaultParameters
        self.featureTransformationArn = featureTransformationArn
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.name = name
        self.status = status
    }
}

extension Filter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case datasetGroupArn
        case failureReason
        case filterArn
        case filterExpression
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let filterArn = filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let filterExpression = filterExpression {
            try encodeContainer.encode(filterExpression, forKey: .filterExpression)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let filterExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filterExpression)
        filterExpression = filterExpressionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension Filter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Filter(creationDateTime: \(String(describing: creationDateTime)), datasetGroupArn: \(String(describing: datasetGroupArn)), failureReason: \(String(describing: failureReason)), filterArn: \(String(describing: filterArn)), filterExpression: \(String(describing: filterExpression)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), name: \(String(describing: name)), status: \(String(describing: status)))"}
}

/// <p>Contains information on a recommendation filter, including its ARN, status, and filter
///             expression.</p>
public struct Filter: Equatable {
    /// <p>The time at which the filter was created.</p>
    public let creationDateTime: Date?
    /// <p>The ARN of the dataset group to which the filter belongs.</p>
    public let datasetGroupArn: String?
    /// <p>If the filter failed, the reason for its failure.</p>
    public let failureReason: String?
    /// <p>The ARN of the filter.</p>
    public let filterArn: String?
    /// <p>Specifies the type of item interactions to filter out of recommendation results. The
    ///             filter expression must follow specific format rules. For information about filter expression structure and syntax, see
    ///             <a>filter-expressions</a>.</p>
    public let filterExpression: String?
    /// <p>The time at which the filter was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The name of the filter.</p>
    public let name: String?
    /// <p>The status of the filter.</p>
    public let status: String?

    public init (
        creationDateTime: Date? = nil,
        datasetGroupArn: String? = nil,
        failureReason: String? = nil,
        filterArn: String? = nil,
        filterExpression: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        name: String? = nil,
        status: String? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.datasetGroupArn = datasetGroupArn
        self.failureReason = failureReason
        self.filterArn = filterArn
        self.filterExpression = filterExpression
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.name = name
        self.status = status
    }
}

extension FilterSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case datasetGroupArn
        case failureReason
        case filterArn
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let filterArn = filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension FilterSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FilterSummary(creationDateTime: \(String(describing: creationDateTime)), datasetGroupArn: \(String(describing: datasetGroupArn)), failureReason: \(String(describing: failureReason)), filterArn: \(String(describing: filterArn)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), name: \(String(describing: name)), status: \(String(describing: status)))"}
}

/// <p>A short summary of a filter's attributes.</p>
public struct FilterSummary: Equatable {
    /// <p>The time at which the filter was created.</p>
    public let creationDateTime: Date?
    /// <p>The ARN of the dataset group to which the filter belongs.</p>
    public let datasetGroupArn: String?
    /// <p>If the filter failed, the reason for the failure.</p>
    public let failureReason: String?
    /// <p>The ARN of the filter.</p>
    public let filterArn: String?
    /// <p>The time at which the filter was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The name of the filter.</p>
    public let name: String?
    /// <p>The status of the filter.</p>
    public let status: String?

    public init (
        creationDateTime: Date? = nil,
        datasetGroupArn: String? = nil,
        failureReason: String? = nil,
        filterArn: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        name: String? = nil,
        status: String? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.datasetGroupArn = datasetGroupArn
        self.failureReason = failureReason
        self.filterArn = filterArn
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.name = name
        self.status = status
    }
}

public struct GetSolutionMetricsInputBodyMiddleware: Middleware {
    public let id: String = "GetSolutionMetricsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSolutionMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSolutionMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSolutionMetricsInput>
    public typealias MOutput = OperationOutput<GetSolutionMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSolutionMetricsOutputError>
}

extension GetSolutionMetricsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSolutionMetricsInput(solutionVersionArn: \(String(describing: solutionVersionArn)))"}
}

extension GetSolutionMetricsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case solutionVersionArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

public struct GetSolutionMetricsInputHeadersMiddleware: Middleware {
    public let id: String = "GetSolutionMetricsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSolutionMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSolutionMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSolutionMetricsInput>
    public typealias MOutput = OperationOutput<GetSolutionMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSolutionMetricsOutputError>
}

public struct GetSolutionMetricsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSolutionMetricsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSolutionMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSolutionMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSolutionMetricsInput>
    public typealias MOutput = OperationOutput<GetSolutionMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSolutionMetricsOutputError>
}

public struct GetSolutionMetricsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the solution version for which to get metrics.</p>
    public let solutionVersionArn: String?

    public init (
        solutionVersionArn: String? = nil
    )
    {
        self.solutionVersionArn = solutionVersionArn
    }
}

struct GetSolutionMetricsInputBody: Equatable {
    public let solutionVersionArn: String?
}

extension GetSolutionMetricsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case solutionVersionArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
    }
}

extension GetSolutionMetricsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSolutionMetricsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSolutionMetricsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSolutionMetricsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSolutionMetricsOutputResponse(metrics: \(String(describing: metrics)), solutionVersionArn: \(String(describing: solutionVersionArn)))"}
}

extension GetSolutionMetricsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSolutionMetricsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.metrics = output.metrics
            self.solutionVersionArn = output.solutionVersionArn
        } else {
            self.metrics = nil
            self.solutionVersionArn = nil
        }
    }
}

public struct GetSolutionMetricsOutputResponse: Equatable {
    /// <p>The metrics for the solution version.</p>
    public let metrics: [String:Double]?
    /// <p>The same solution version ARN as specified in the request.</p>
    public let solutionVersionArn: String?

    public init (
        metrics: [String:Double]? = nil,
        solutionVersionArn: String? = nil
    )
    {
        self.metrics = metrics
        self.solutionVersionArn = solutionVersionArn
    }
}

struct GetSolutionMetricsOutputResponseBody: Equatable {
    public let solutionVersionArn: String?
    public let metrics: [String:Double]?
}

extension GetSolutionMetricsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metrics
        case solutionVersionArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let metricsContainer = try containerValues.decodeIfPresent([String: Double?].self, forKey: .metrics)
        var metricsDecoded0: [String:Double]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [String:Double]()
            for (key0, metricvalue0) in metricsContainer {
                if let metricvalue0 = metricvalue0 {
                    metricsDecoded0?[key0] = metricvalue0
                }
            }
        }
        metrics = metricsDecoded0
    }
}

extension HPOConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case algorithmHyperParameterRanges
        case hpoObjective
        case hpoResourceConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmHyperParameterRanges = algorithmHyperParameterRanges {
            try encodeContainer.encode(algorithmHyperParameterRanges, forKey: .algorithmHyperParameterRanges)
        }
        if let hpoObjective = hpoObjective {
            try encodeContainer.encode(hpoObjective, forKey: .hpoObjective)
        }
        if let hpoResourceConfig = hpoResourceConfig {
            try encodeContainer.encode(hpoResourceConfig, forKey: .hpoResourceConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hpoObjectiveDecoded = try containerValues.decodeIfPresent(HPOObjective.self, forKey: .hpoObjective)
        hpoObjective = hpoObjectiveDecoded
        let hpoResourceConfigDecoded = try containerValues.decodeIfPresent(HPOResourceConfig.self, forKey: .hpoResourceConfig)
        hpoResourceConfig = hpoResourceConfigDecoded
        let algorithmHyperParameterRangesDecoded = try containerValues.decodeIfPresent(HyperParameterRanges.self, forKey: .algorithmHyperParameterRanges)
        algorithmHyperParameterRanges = algorithmHyperParameterRangesDecoded
    }
}

extension HPOConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HPOConfig(algorithmHyperParameterRanges: \(String(describing: algorithmHyperParameterRanges)), hpoObjective: \(String(describing: hpoObjective)), hpoResourceConfig: \(String(describing: hpoResourceConfig)))"}
}

/// <p>Describes the properties for hyperparameter optimization (HPO).</p>
public struct HPOConfig: Equatable {
    /// <p>The hyperparameters and their allowable ranges.</p>
    public let algorithmHyperParameterRanges: HyperParameterRanges?
    /// <p>The metric to optimize during HPO.</p>
    ///          <note>
    ///             <p>Amazon Personalize doesn't support configuring the <code>hpoObjective</code>
    ///         at this time.</p>
    ///          </note>
    public let hpoObjective: HPOObjective?
    /// <p>Describes the resource configuration for HPO.</p>
    public let hpoResourceConfig: HPOResourceConfig?

    public init (
        algorithmHyperParameterRanges: HyperParameterRanges? = nil,
        hpoObjective: HPOObjective? = nil,
        hpoResourceConfig: HPOResourceConfig? = nil
    )
    {
        self.algorithmHyperParameterRanges = algorithmHyperParameterRanges
        self.hpoObjective = hpoObjective
        self.hpoResourceConfig = hpoResourceConfig
    }
}

extension HPOObjective: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case metricName
        case metricRegex
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let metricRegex = metricRegex {
            try encodeContainer.encode(metricRegex, forKey: .metricRegex)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let metricRegexDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricRegex)
        metricRegex = metricRegexDecoded
    }
}

extension HPOObjective: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HPOObjective(metricName: \(String(describing: metricName)), metricRegex: \(String(describing: metricRegex)), type: \(String(describing: type)))"}
}

/// <p>The metric to optimize during hyperparameter optimization (HPO).</p>
///          <note>
///             <p>Amazon Personalize doesn't support configuring the <code>hpoObjective</code>
///         at this time.</p>
///          </note>
public struct HPOObjective: Equatable {
    /// <p>The name of the metric.</p>
    public let metricName: String?
    /// <p>A regular expression for finding the metric in the training job logs.</p>
    public let metricRegex: String?
    /// <p>The type of the metric. Valid values are <code>Maximize</code> and <code>Minimize</code>.</p>
    public let type: String?

    public init (
        metricName: String? = nil,
        metricRegex: String? = nil,
        type: String? = nil
    )
    {
        self.metricName = metricName
        self.metricRegex = metricRegex
        self.type = type
    }
}

extension HPOResourceConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxNumberOfTrainingJobs
        case maxParallelTrainingJobs
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxNumberOfTrainingJobs = maxNumberOfTrainingJobs {
            try encodeContainer.encode(maxNumberOfTrainingJobs, forKey: .maxNumberOfTrainingJobs)
        }
        if let maxParallelTrainingJobs = maxParallelTrainingJobs {
            try encodeContainer.encode(maxParallelTrainingJobs, forKey: .maxParallelTrainingJobs)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxNumberOfTrainingJobsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxNumberOfTrainingJobs)
        maxNumberOfTrainingJobs = maxNumberOfTrainingJobsDecoded
        let maxParallelTrainingJobsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxParallelTrainingJobs)
        maxParallelTrainingJobs = maxParallelTrainingJobsDecoded
    }
}

extension HPOResourceConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HPOResourceConfig(maxNumberOfTrainingJobs: \(String(describing: maxNumberOfTrainingJobs)), maxParallelTrainingJobs: \(String(describing: maxParallelTrainingJobs)))"}
}

/// <p>Describes the resource configuration for hyperparameter optimization (HPO).</p>
public struct HPOResourceConfig: Equatable {
    /// <p>The maximum number of training
    ///       jobs when you create a
    ///       solution
    ///       version.
    ///       The maximum value for <code>maxNumberOfTrainingJobs</code> is
    ///       <code>40</code>.</p>
    public let maxNumberOfTrainingJobs: String?
    /// <p>The maximum number of parallel training
    ///       jobs when you create a
    ///       solution
    ///       version.
    ///       The maximum value for <code>maxParallelTrainingJobs</code> is
    ///       <code>10</code>.</p>
    public let maxParallelTrainingJobs: String?

    public init (
        maxNumberOfTrainingJobs: String? = nil,
        maxParallelTrainingJobs: String? = nil
    )
    {
        self.maxNumberOfTrainingJobs = maxNumberOfTrainingJobs
        self.maxParallelTrainingJobs = maxParallelTrainingJobs
    }
}

extension HyperParameterRanges: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case categoricalHyperParameterRanges
        case continuousHyperParameterRanges
        case integerHyperParameterRanges
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoricalHyperParameterRanges = categoricalHyperParameterRanges {
            var categoricalHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categoricalHyperParameterRanges)
            for categoricalhyperparameterranges0 in categoricalHyperParameterRanges {
                try categoricalHyperParameterRangesContainer.encode(categoricalhyperparameterranges0)
            }
        }
        if let continuousHyperParameterRanges = continuousHyperParameterRanges {
            var continuousHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .continuousHyperParameterRanges)
            for continuoushyperparameterranges0 in continuousHyperParameterRanges {
                try continuousHyperParameterRangesContainer.encode(continuoushyperparameterranges0)
            }
        }
        if let integerHyperParameterRanges = integerHyperParameterRanges {
            var integerHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .integerHyperParameterRanges)
            for integerhyperparameterranges0 in integerHyperParameterRanges {
                try integerHyperParameterRangesContainer.encode(integerhyperparameterranges0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let integerHyperParameterRangesContainer = try containerValues.decodeIfPresent([IntegerHyperParameterRange?].self, forKey: .integerHyperParameterRanges)
        var integerHyperParameterRangesDecoded0:[IntegerHyperParameterRange]? = nil
        if let integerHyperParameterRangesContainer = integerHyperParameterRangesContainer {
            integerHyperParameterRangesDecoded0 = [IntegerHyperParameterRange]()
            for structure0 in integerHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    integerHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        integerHyperParameterRanges = integerHyperParameterRangesDecoded0
        let continuousHyperParameterRangesContainer = try containerValues.decodeIfPresent([ContinuousHyperParameterRange?].self, forKey: .continuousHyperParameterRanges)
        var continuousHyperParameterRangesDecoded0:[ContinuousHyperParameterRange]? = nil
        if let continuousHyperParameterRangesContainer = continuousHyperParameterRangesContainer {
            continuousHyperParameterRangesDecoded0 = [ContinuousHyperParameterRange]()
            for structure0 in continuousHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    continuousHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        continuousHyperParameterRanges = continuousHyperParameterRangesDecoded0
        let categoricalHyperParameterRangesContainer = try containerValues.decodeIfPresent([CategoricalHyperParameterRange?].self, forKey: .categoricalHyperParameterRanges)
        var categoricalHyperParameterRangesDecoded0:[CategoricalHyperParameterRange]? = nil
        if let categoricalHyperParameterRangesContainer = categoricalHyperParameterRangesContainer {
            categoricalHyperParameterRangesDecoded0 = [CategoricalHyperParameterRange]()
            for structure0 in categoricalHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    categoricalHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        categoricalHyperParameterRanges = categoricalHyperParameterRangesDecoded0
    }
}

extension HyperParameterRanges: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HyperParameterRanges(categoricalHyperParameterRanges: \(String(describing: categoricalHyperParameterRanges)), continuousHyperParameterRanges: \(String(describing: continuousHyperParameterRanges)), integerHyperParameterRanges: \(String(describing: integerHyperParameterRanges)))"}
}

/// <p>Specifies the hyperparameters and their ranges.
///     Hyperparameters can be categorical, continuous, or integer-valued.</p>
public struct HyperParameterRanges: Equatable {
    /// <p>The categorical hyperparameters and their ranges.</p>
    public let categoricalHyperParameterRanges: [CategoricalHyperParameterRange]?
    /// <p>The continuous hyperparameters and their ranges.</p>
    public let continuousHyperParameterRanges: [ContinuousHyperParameterRange]?
    /// <p>The integer-valued hyperparameters and their ranges.</p>
    public let integerHyperParameterRanges: [IntegerHyperParameterRange]?

    public init (
        categoricalHyperParameterRanges: [CategoricalHyperParameterRange]? = nil,
        continuousHyperParameterRanges: [ContinuousHyperParameterRange]? = nil,
        integerHyperParameterRanges: [IntegerHyperParameterRange]? = nil
    )
    {
        self.categoricalHyperParameterRanges = categoricalHyperParameterRanges
        self.continuousHyperParameterRanges = continuousHyperParameterRanges
        self.integerHyperParameterRanges = integerHyperParameterRanges
    }
}

public enum IngestionMode {
    case all
    case bulk
    case put
    case sdkUnknown(String)
}

extension IngestionMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IngestionMode] {
        return [
            .all,
            .bulk,
            .put,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .bulk: return "BULK"
        case .put: return "PUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IngestionMode(rawValue: rawValue) ?? IngestionMode.sdkUnknown(rawValue)
    }
}

extension IntegerHyperParameterRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxValue
        case minValue
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxValue != 0 {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if minValue != 0 {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let minValueDecoded = try containerValues.decode(Int.self, forKey: .minValue)
        minValue = minValueDecoded
        let maxValueDecoded = try containerValues.decode(Int.self, forKey: .maxValue)
        maxValue = maxValueDecoded
    }
}

extension IntegerHyperParameterRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IntegerHyperParameterRange(maxValue: \(String(describing: maxValue)), minValue: \(String(describing: minValue)), name: \(String(describing: name)))"}
}

/// <p>Provides the name and range of an integer-valued hyperparameter.</p>
public struct IntegerHyperParameterRange: Equatable {
    /// <p>The maximum allowable value for the hyperparameter.</p>
    public let maxValue: Int
    /// <p>The minimum allowable value for the hyperparameter.</p>
    public let minValue: Int
    /// <p>The name of the hyperparameter.</p>
    public let name: String?

    public init (
        maxValue: Int = 0,
        minValue: Int = 0,
        name: String? = nil
    )
    {
        self.maxValue = maxValue
        self.minValue = minValue
        self.name = name
    }
}

extension InvalidInputException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInputException(message: \(String(describing: message)))"}
}

extension InvalidInputException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Provide a valid value for the field or parameter.</p>
public struct InvalidInputException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Equatable {
    public let message: String?
}

extension InvalidInputExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The token is not valid.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The limit on the number of requests per second has been exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListBatchInferenceJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListBatchInferenceJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBatchInferenceJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBatchInferenceJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBatchInferenceJobsInput>
    public typealias MOutput = OperationOutput<ListBatchInferenceJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBatchInferenceJobsOutputError>
}

extension ListBatchInferenceJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBatchInferenceJobsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), solutionVersionArn: \(String(describing: solutionVersionArn)))"}
}

extension ListBatchInferenceJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case solutionVersionArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

public struct ListBatchInferenceJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListBatchInferenceJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBatchInferenceJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBatchInferenceJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBatchInferenceJobsInput>
    public typealias MOutput = OperationOutput<ListBatchInferenceJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBatchInferenceJobsOutputError>
}

public struct ListBatchInferenceJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBatchInferenceJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBatchInferenceJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBatchInferenceJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBatchInferenceJobsInput>
    public typealias MOutput = OperationOutput<ListBatchInferenceJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBatchInferenceJobsOutputError>
}

public struct ListBatchInferenceJobsInput: Equatable {
    /// <p>The maximum number of batch inference job results to return in each page. The default
    ///       value is 100.</p>
    public let maxResults: Int?
    /// <p>The token to request the next page of results.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the solution version from which the batch inference jobs
    ///       were created.</p>
    public let solutionVersionArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        solutionVersionArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.solutionVersionArn = solutionVersionArn
    }
}

struct ListBatchInferenceJobsInputBody: Equatable {
    public let solutionVersionArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListBatchInferenceJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case solutionVersionArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListBatchInferenceJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBatchInferenceJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBatchInferenceJobsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBatchInferenceJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBatchInferenceJobsOutputResponse(batchInferenceJobs: \(String(describing: batchInferenceJobs)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBatchInferenceJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBatchInferenceJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.batchInferenceJobs = output.batchInferenceJobs
            self.nextToken = output.nextToken
        } else {
            self.batchInferenceJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListBatchInferenceJobsOutputResponse: Equatable {
    /// <p>A list containing information on each job that is returned.</p>
    public let batchInferenceJobs: [BatchInferenceJobSummary]?
    /// <p>The token to use to retrieve the next page of results. The value is <code>null</code> when
    ///       there are no more results to return.</p>
    public let nextToken: String?

    public init (
        batchInferenceJobs: [BatchInferenceJobSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.batchInferenceJobs = batchInferenceJobs
        self.nextToken = nextToken
    }
}

struct ListBatchInferenceJobsOutputResponseBody: Equatable {
    public let batchInferenceJobs: [BatchInferenceJobSummary]?
    public let nextToken: String?
}

extension ListBatchInferenceJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case batchInferenceJobs
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchInferenceJobsContainer = try containerValues.decodeIfPresent([BatchInferenceJobSummary?].self, forKey: .batchInferenceJobs)
        var batchInferenceJobsDecoded0:[BatchInferenceJobSummary]? = nil
        if let batchInferenceJobsContainer = batchInferenceJobsContainer {
            batchInferenceJobsDecoded0 = [BatchInferenceJobSummary]()
            for structure0 in batchInferenceJobsContainer {
                if let structure0 = structure0 {
                    batchInferenceJobsDecoded0?.append(structure0)
                }
            }
        }
        batchInferenceJobs = batchInferenceJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListCampaignsInputBodyMiddleware: Middleware {
    public let id: String = "ListCampaignsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCampaignsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCampaignsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCampaignsInput>
    public typealias MOutput = OperationOutput<ListCampaignsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCampaignsOutputError>
}

extension ListCampaignsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCampaignsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), solutionArn: \(String(describing: solutionArn)))"}
}

extension ListCampaignsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case solutionArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let solutionArn = solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
    }
}

public struct ListCampaignsInputHeadersMiddleware: Middleware {
    public let id: String = "ListCampaignsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCampaignsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCampaignsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCampaignsInput>
    public typealias MOutput = OperationOutput<ListCampaignsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCampaignsOutputError>
}

public struct ListCampaignsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCampaignsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCampaignsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCampaignsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCampaignsInput>
    public typealias MOutput = OperationOutput<ListCampaignsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCampaignsOutputError>
}

public struct ListCampaignsInput: Equatable {
    /// <p>The maximum number of campaigns to return.</p>
    public let maxResults: Int?
    /// <p>A token returned from the previous call to <code>ListCampaigns</code> for getting
    ///       the next set of campaigns (if they exist).</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the solution to list the campaigns for. When
    ///         a solution is not specified, all the campaigns associated with the account are listed.</p>
    public let solutionArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        solutionArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.solutionArn = solutionArn
    }
}

struct ListCampaignsInputBody: Equatable {
    public let solutionArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListCampaignsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case solutionArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListCampaignsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCampaignsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCampaignsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCampaignsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCampaignsOutputResponse(campaigns: \(String(describing: campaigns)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCampaignsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCampaignsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.campaigns = output.campaigns
            self.nextToken = output.nextToken
        } else {
            self.campaigns = nil
            self.nextToken = nil
        }
    }
}

public struct ListCampaignsOutputResponse: Equatable {
    /// <p>A list of the campaigns.</p>
    public let campaigns: [CampaignSummary]?
    /// <p>A token for getting the next set of campaigns (if they exist).</p>
    public let nextToken: String?

    public init (
        campaigns: [CampaignSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.campaigns = campaigns
        self.nextToken = nextToken
    }
}

struct ListCampaignsOutputResponseBody: Equatable {
    public let campaigns: [CampaignSummary]?
    public let nextToken: String?
}

extension ListCampaignsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case campaigns
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignsContainer = try containerValues.decodeIfPresent([CampaignSummary?].self, forKey: .campaigns)
        var campaignsDecoded0:[CampaignSummary]? = nil
        if let campaignsContainer = campaignsContainer {
            campaignsDecoded0 = [CampaignSummary]()
            for structure0 in campaignsContainer {
                if let structure0 = structure0 {
                    campaignsDecoded0?.append(structure0)
                }
            }
        }
        campaigns = campaignsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDatasetExportJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListDatasetExportJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetExportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetExportJobsInput>
    public typealias MOutput = OperationOutput<ListDatasetExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetExportJobsOutputError>
}

extension ListDatasetExportJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetExportJobsInput(datasetArn: \(String(describing: datasetArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetExportJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDatasetExportJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDatasetExportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetExportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetExportJobsInput>
    public typealias MOutput = OperationOutput<ListDatasetExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetExportJobsOutputError>
}

public struct ListDatasetExportJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDatasetExportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetExportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetExportJobsInput>
    public typealias MOutput = OperationOutput<ListDatasetExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetExportJobsOutputError>
}

public struct ListDatasetExportJobsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset to list the dataset export jobs for.</p>
    public let datasetArn: String?
    /// <p>The maximum number of dataset export jobs to return.</p>
    public let maxResults: Int?
    /// <p>A token returned from the previous call to <code>ListDatasetExportJobs</code> for getting
    ///       the next set of dataset export jobs (if they exist).</p>
    public let nextToken: String?

    public init (
        datasetArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.datasetArn = datasetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetExportJobsInputBody: Equatable {
    public let datasetArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListDatasetExportJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetExportJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetExportJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetExportJobsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetExportJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetExportJobsOutputResponse(datasetExportJobs: \(String(describing: datasetExportJobs)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetExportJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDatasetExportJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasetExportJobs = output.datasetExportJobs
            self.nextToken = output.nextToken
        } else {
            self.datasetExportJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetExportJobsOutputResponse: Equatable {
    /// <p>The list of dataset export jobs.</p>
    public let datasetExportJobs: [DatasetExportJobSummary]?
    /// <p>A token for getting the next set of dataset export jobs (if they exist).</p>
    public let nextToken: String?

    public init (
        datasetExportJobs: [DatasetExportJobSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.datasetExportJobs = datasetExportJobs
        self.nextToken = nextToken
    }
}

struct ListDatasetExportJobsOutputResponseBody: Equatable {
    public let datasetExportJobs: [DatasetExportJobSummary]?
    public let nextToken: String?
}

extension ListDatasetExportJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetExportJobs
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetExportJobsContainer = try containerValues.decodeIfPresent([DatasetExportJobSummary?].self, forKey: .datasetExportJobs)
        var datasetExportJobsDecoded0:[DatasetExportJobSummary]? = nil
        if let datasetExportJobsContainer = datasetExportJobsContainer {
            datasetExportJobsDecoded0 = [DatasetExportJobSummary]()
            for structure0 in datasetExportJobsContainer {
                if let structure0 = structure0 {
                    datasetExportJobsDecoded0?.append(structure0)
                }
            }
        }
        datasetExportJobs = datasetExportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDatasetGroupsInputBodyMiddleware: Middleware {
    public let id: String = "ListDatasetGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetGroupsInput>
    public typealias MOutput = OperationOutput<ListDatasetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetGroupsOutputError>
}

extension ListDatasetGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetGroupsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDatasetGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDatasetGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetGroupsInput>
    public typealias MOutput = OperationOutput<ListDatasetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetGroupsOutputError>
}

public struct ListDatasetGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDatasetGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetGroupsInput>
    public typealias MOutput = OperationOutput<ListDatasetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetGroupsOutputError>
}

public struct ListDatasetGroupsInput: Equatable {
    /// <p>The maximum number of dataset groups to return.</p>
    public let maxResults: Int?
    /// <p>A token returned from the previous call to <code>ListDatasetGroups</code> for getting the
    ///       next set of dataset groups (if they exist).</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetGroupsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListDatasetGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetGroupsOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetGroupsOutputResponse(datasetGroups: \(String(describing: datasetGroups)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDatasetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasetGroups = output.datasetGroups
            self.nextToken = output.nextToken
        } else {
            self.datasetGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetGroupsOutputResponse: Equatable {
    /// <p>The list of your dataset groups.</p>
    public let datasetGroups: [DatasetGroupSummary]?
    /// <p>A token for getting the next set of dataset groups (if they exist).</p>
    public let nextToken: String?

    public init (
        datasetGroups: [DatasetGroupSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.datasetGroups = datasetGroups
        self.nextToken = nextToken
    }
}

struct ListDatasetGroupsOutputResponseBody: Equatable {
    public let datasetGroups: [DatasetGroupSummary]?
    public let nextToken: String?
}

extension ListDatasetGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetGroups
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupsContainer = try containerValues.decodeIfPresent([DatasetGroupSummary?].self, forKey: .datasetGroups)
        var datasetGroupsDecoded0:[DatasetGroupSummary]? = nil
        if let datasetGroupsContainer = datasetGroupsContainer {
            datasetGroupsDecoded0 = [DatasetGroupSummary]()
            for structure0 in datasetGroupsContainer {
                if let structure0 = structure0 {
                    datasetGroupsDecoded0?.append(structure0)
                }
            }
        }
        datasetGroups = datasetGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDatasetImportJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListDatasetImportJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetImportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetImportJobsInput>
    public typealias MOutput = OperationOutput<ListDatasetImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetImportJobsOutputError>
}

extension ListDatasetImportJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetImportJobsInput(datasetArn: \(String(describing: datasetArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetImportJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDatasetImportJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDatasetImportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetImportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetImportJobsInput>
    public typealias MOutput = OperationOutput<ListDatasetImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetImportJobsOutputError>
}

public struct ListDatasetImportJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDatasetImportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetImportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetImportJobsInput>
    public typealias MOutput = OperationOutput<ListDatasetImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetImportJobsOutputError>
}

public struct ListDatasetImportJobsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset to list the dataset import jobs for.</p>
    public let datasetArn: String?
    /// <p>The maximum number of dataset import jobs to return.</p>
    public let maxResults: Int?
    /// <p>A token returned from the previous call to <code>ListDatasetImportJobs</code> for getting
    ///       the next set of dataset import jobs (if they exist).</p>
    public let nextToken: String?

    public init (
        datasetArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.datasetArn = datasetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetImportJobsInputBody: Equatable {
    public let datasetArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListDatasetImportJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetImportJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetImportJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetImportJobsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetImportJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetImportJobsOutputResponse(datasetImportJobs: \(String(describing: datasetImportJobs)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetImportJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDatasetImportJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasetImportJobs = output.datasetImportJobs
            self.nextToken = output.nextToken
        } else {
            self.datasetImportJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetImportJobsOutputResponse: Equatable {
    /// <p>The list of dataset import jobs.</p>
    public let datasetImportJobs: [DatasetImportJobSummary]?
    /// <p>A token for getting the next set of dataset import jobs (if they exist).</p>
    public let nextToken: String?

    public init (
        datasetImportJobs: [DatasetImportJobSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.datasetImportJobs = datasetImportJobs
        self.nextToken = nextToken
    }
}

struct ListDatasetImportJobsOutputResponseBody: Equatable {
    public let datasetImportJobs: [DatasetImportJobSummary]?
    public let nextToken: String?
}

extension ListDatasetImportJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetImportJobs
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobsContainer = try containerValues.decodeIfPresent([DatasetImportJobSummary?].self, forKey: .datasetImportJobs)
        var datasetImportJobsDecoded0:[DatasetImportJobSummary]? = nil
        if let datasetImportJobsContainer = datasetImportJobsContainer {
            datasetImportJobsDecoded0 = [DatasetImportJobSummary]()
            for structure0 in datasetImportJobsContainer {
                if let structure0 = structure0 {
                    datasetImportJobsDecoded0?.append(structure0)
                }
            }
        }
        datasetImportJobs = datasetImportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDatasetsInputBodyMiddleware: Middleware {
    public let id: String = "ListDatasetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetsOutputError>
}

extension ListDatasetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetsInput(datasetGroupArn: \(String(describing: datasetGroupArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDatasetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDatasetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDatasetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset group that contains the datasets to
    ///       list.</p>
    public let datasetGroupArn: String?
    /// <p>The maximum number of datasets to return.</p>
    public let maxResults: Int?
    /// <p>A token returned from the previous call to <code>ListDatasetImportJobs</code> for getting
    ///       the next set of dataset import jobs (if they exist).</p>
    public let nextToken: String?

    public init (
        datasetGroupArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetsInputBody: Equatable {
    public let datasetGroupArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListDatasetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetsOutputResponse(datasets: \(String(describing: datasets)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDatasetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasets = output.datasets
            self.nextToken = output.nextToken
        } else {
            self.datasets = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetsOutputResponse: Equatable {
    /// <p>An array of <code>Dataset</code> objects. Each object provides metadata
    ///       information.</p>
    public let datasets: [DatasetSummary]?
    /// <p>A token for getting the next set of datasets (if they exist).</p>
    public let nextToken: String?

    public init (
        datasets: [DatasetSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.datasets = datasets
        self.nextToken = nextToken
    }
}

struct ListDatasetsOutputResponseBody: Equatable {
    public let datasets: [DatasetSummary]?
    public let nextToken: String?
}

extension ListDatasetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasets
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetsContainer = try containerValues.decodeIfPresent([DatasetSummary?].self, forKey: .datasets)
        var datasetsDecoded0:[DatasetSummary]? = nil
        if let datasetsContainer = datasetsContainer {
            datasetsDecoded0 = [DatasetSummary]()
            for structure0 in datasetsContainer {
                if let structure0 = structure0 {
                    datasetsDecoded0?.append(structure0)
                }
            }
        }
        datasets = datasetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListEventTrackersInputBodyMiddleware: Middleware {
    public let id: String = "ListEventTrackersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventTrackersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventTrackersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventTrackersInput>
    public typealias MOutput = OperationOutput<ListEventTrackersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventTrackersOutputError>
}

extension ListEventTrackersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEventTrackersInput(datasetGroupArn: \(String(describing: datasetGroupArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEventTrackersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListEventTrackersInputHeadersMiddleware: Middleware {
    public let id: String = "ListEventTrackersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventTrackersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventTrackersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventTrackersInput>
    public typealias MOutput = OperationOutput<ListEventTrackersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventTrackersOutputError>
}

public struct ListEventTrackersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEventTrackersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventTrackersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventTrackersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventTrackersInput>
    public typealias MOutput = OperationOutput<ListEventTrackersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventTrackersOutputError>
}

public struct ListEventTrackersInput: Equatable {
    /// <p>The ARN of a dataset group used to filter the response.</p>
    public let datasetGroupArn: String?
    /// <p>The maximum number of event trackers to return.</p>
    public let maxResults: Int?
    /// <p>A token returned from the previous call to <code>ListEventTrackers</code> for getting
    ///       the next set of event trackers (if they exist).</p>
    public let nextToken: String?

    public init (
        datasetGroupArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEventTrackersInputBody: Equatable {
    public let datasetGroupArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListEventTrackersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEventTrackersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventTrackersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEventTrackersOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventTrackersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEventTrackersOutputResponse(eventTrackers: \(String(describing: eventTrackers)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEventTrackersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEventTrackersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventTrackers = output.eventTrackers
            self.nextToken = output.nextToken
        } else {
            self.eventTrackers = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventTrackersOutputResponse: Equatable {
    /// <p>A list of event trackers.</p>
    public let eventTrackers: [EventTrackerSummary]?
    /// <p>A token for getting the next set of event trackers (if they exist).</p>
    public let nextToken: String?

    public init (
        eventTrackers: [EventTrackerSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.eventTrackers = eventTrackers
        self.nextToken = nextToken
    }
}

struct ListEventTrackersOutputResponseBody: Equatable {
    public let eventTrackers: [EventTrackerSummary]?
    public let nextToken: String?
}

extension ListEventTrackersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventTrackers
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTrackersContainer = try containerValues.decodeIfPresent([EventTrackerSummary?].self, forKey: .eventTrackers)
        var eventTrackersDecoded0:[EventTrackerSummary]? = nil
        if let eventTrackersContainer = eventTrackersContainer {
            eventTrackersDecoded0 = [EventTrackerSummary]()
            for structure0 in eventTrackersContainer {
                if let structure0 = structure0 {
                    eventTrackersDecoded0?.append(structure0)
                }
            }
        }
        eventTrackers = eventTrackersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListFiltersInputBodyMiddleware: Middleware {
    public let id: String = "ListFiltersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFiltersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFiltersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFiltersInput>
    public typealias MOutput = OperationOutput<ListFiltersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFiltersOutputError>
}

extension ListFiltersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFiltersInput(datasetGroupArn: \(String(describing: datasetGroupArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFiltersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFiltersInputHeadersMiddleware: Middleware {
    public let id: String = "ListFiltersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFiltersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFiltersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFiltersInput>
    public typealias MOutput = OperationOutput<ListFiltersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFiltersOutputError>
}

public struct ListFiltersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFiltersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFiltersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFiltersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFiltersInput>
    public typealias MOutput = OperationOutput<ListFiltersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFiltersOutputError>
}

public struct ListFiltersInput: Equatable {
    /// <p>The ARN of the dataset group that contains the filters.</p>
    public let datasetGroupArn: String?
    /// <p>The maximum number of filters to return.</p>
    public let maxResults: Int?
    /// <p>A token returned from the previous call to <code>ListFilters</code> for getting the
    ///             next set of filters (if they exist).</p>
    public let nextToken: String?

    public init (
        datasetGroupArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFiltersInputBody: Equatable {
    public let datasetGroupArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListFiltersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFiltersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFiltersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFiltersOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFiltersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFiltersOutputResponse(filters: \(String(describing: filters)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFiltersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFiltersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.filters = output.filters
            self.nextToken = output.nextToken
        } else {
            self.filters = nil
            self.nextToken = nil
        }
    }
}

public struct ListFiltersOutputResponse: Equatable {
    /// <p>A list of returned filters.</p>
    public let filters: [FilterSummary]?
    /// <p>A token for getting the next set of filters (if they exist).</p>
    public let nextToken: String?

    public init (
        filters: [FilterSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.nextToken = nextToken
    }
}

struct ListFiltersOutputResponseBody: Equatable {
    public let filters: [FilterSummary]?
    public let nextToken: String?
}

extension ListFiltersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([FilterSummary?].self, forKey: .filters)
        var filtersDecoded0:[FilterSummary]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [FilterSummary]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRecipesInputBodyMiddleware: Middleware {
    public let id: String = "ListRecipesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecipesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecipesInput>
    public typealias MOutput = OperationOutput<ListRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecipesOutputError>
}

extension ListRecipesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecipesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), recipeProvider: \(String(describing: recipeProvider)))"}
}

extension ListRecipesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case recipeProvider
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let recipeProvider = recipeProvider {
            try encodeContainer.encode(recipeProvider.rawValue, forKey: .recipeProvider)
        }
    }
}

public struct ListRecipesInputHeadersMiddleware: Middleware {
    public let id: String = "ListRecipesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecipesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecipesInput>
    public typealias MOutput = OperationOutput<ListRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecipesOutputError>
}

public struct ListRecipesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRecipesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecipesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecipesInput>
    public typealias MOutput = OperationOutput<ListRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecipesOutputError>
}

public struct ListRecipesInput: Equatable {
    /// <p>The maximum number of recipes to return.</p>
    public let maxResults: Int?
    /// <p>A token returned from the previous call to <code>ListRecipes</code> for getting
    ///       the next set of recipes (if they exist).</p>
    public let nextToken: String?
    /// <p>The default is <code>SERVICE</code>.</p>
    public let recipeProvider: RecipeProvider?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        recipeProvider: RecipeProvider? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recipeProvider = recipeProvider
    }
}

struct ListRecipesInputBody: Equatable {
    public let recipeProvider: RecipeProvider?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListRecipesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case recipeProvider
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipeProviderDecoded = try containerValues.decodeIfPresent(RecipeProvider.self, forKey: .recipeProvider)
        recipeProvider = recipeProviderDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRecipesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecipesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRecipesOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecipesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecipesOutputResponse(nextToken: \(String(describing: nextToken)), recipes: \(String(describing: recipes)))"}
}

extension ListRecipesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRecipesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.recipes = output.recipes
        } else {
            self.nextToken = nil
            self.recipes = nil
        }
    }
}

public struct ListRecipesOutputResponse: Equatable {
    /// <p>A token for getting the next set of recipes.</p>
    public let nextToken: String?
    /// <p>The list of available recipes.</p>
    public let recipes: [RecipeSummary]?

    public init (
        nextToken: String? = nil,
        recipes: [RecipeSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.recipes = recipes
    }
}

struct ListRecipesOutputResponseBody: Equatable {
    public let recipes: [RecipeSummary]?
    public let nextToken: String?
}

extension ListRecipesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case recipes
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipesContainer = try containerValues.decodeIfPresent([RecipeSummary?].self, forKey: .recipes)
        var recipesDecoded0:[RecipeSummary]? = nil
        if let recipesContainer = recipesContainer {
            recipesDecoded0 = [RecipeSummary]()
            for structure0 in recipesContainer {
                if let structure0 = structure0 {
                    recipesDecoded0?.append(structure0)
                }
            }
        }
        recipes = recipesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSchemasInputBodyMiddleware: Middleware {
    public let id: String = "ListSchemasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSchemasInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSchemasInput>
    public typealias MOutput = OperationOutput<ListSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSchemasOutputError>
}

extension ListSchemasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSchemasInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSchemasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListSchemasInputHeadersMiddleware: Middleware {
    public let id: String = "ListSchemasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSchemasInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSchemasInput>
    public typealias MOutput = OperationOutput<ListSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSchemasOutputError>
}

public struct ListSchemasInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSchemasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSchemasInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSchemasInput>
    public typealias MOutput = OperationOutput<ListSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSchemasOutputError>
}

public struct ListSchemasInput: Equatable {
    /// <p>The maximum number of schemas to return.</p>
    public let maxResults: Int?
    /// <p>A token returned from the previous call to <code>ListSchemas</code> for getting
    ///       the next set of schemas (if they exist).</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSchemasInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListSchemasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSchemasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSchemasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSchemasOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSchemasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSchemasOutputResponse(nextToken: \(String(describing: nextToken)), schemas: \(String(describing: schemas)))"}
}

extension ListSchemasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSchemasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.schemas = output.schemas
        } else {
            self.nextToken = nil
            self.schemas = nil
        }
    }
}

public struct ListSchemasOutputResponse: Equatable {
    /// <p>A token used to get the next set of schemas (if they exist).</p>
    public let nextToken: String?
    /// <p>A list of schemas.</p>
    public let schemas: [DatasetSchemaSummary]?

    public init (
        nextToken: String? = nil,
        schemas: [DatasetSchemaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

struct ListSchemasOutputResponseBody: Equatable {
    public let schemas: [DatasetSchemaSummary]?
    public let nextToken: String?
}

extension ListSchemasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case schemas
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemasContainer = try containerValues.decodeIfPresent([DatasetSchemaSummary?].self, forKey: .schemas)
        var schemasDecoded0:[DatasetSchemaSummary]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [DatasetSchemaSummary]()
            for structure0 in schemasContainer {
                if let structure0 = structure0 {
                    schemasDecoded0?.append(structure0)
                }
            }
        }
        schemas = schemasDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSolutionVersionsInputBodyMiddleware: Middleware {
    public let id: String = "ListSolutionVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSolutionVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSolutionVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSolutionVersionsInput>
    public typealias MOutput = OperationOutput<ListSolutionVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSolutionVersionsOutputError>
}

extension ListSolutionVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSolutionVersionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), solutionArn: \(String(describing: solutionArn)))"}
}

extension ListSolutionVersionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case solutionArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let solutionArn = solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
    }
}

public struct ListSolutionVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSolutionVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSolutionVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSolutionVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSolutionVersionsInput>
    public typealias MOutput = OperationOutput<ListSolutionVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSolutionVersionsOutputError>
}

public struct ListSolutionVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSolutionVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSolutionVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSolutionVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSolutionVersionsInput>
    public typealias MOutput = OperationOutput<ListSolutionVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSolutionVersionsOutputError>
}

public struct ListSolutionVersionsInput: Equatable {
    /// <p>The maximum number of solution versions to return.</p>
    public let maxResults: Int?
    /// <p>A token returned from the previous call to <code>ListSolutionVersions</code> for getting
    ///       the next set of solution versions (if they exist).</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the solution.</p>
    public let solutionArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        solutionArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.solutionArn = solutionArn
    }
}

struct ListSolutionVersionsInputBody: Equatable {
    public let solutionArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListSolutionVersionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case solutionArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSolutionVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSolutionVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSolutionVersionsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSolutionVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSolutionVersionsOutputResponse(nextToken: \(String(describing: nextToken)), solutionVersions: \(String(describing: solutionVersions)))"}
}

extension ListSolutionVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSolutionVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.solutionVersions = output.solutionVersions
        } else {
            self.nextToken = nil
            self.solutionVersions = nil
        }
    }
}

public struct ListSolutionVersionsOutputResponse: Equatable {
    /// <p>A token for getting the next set of solution versions (if they exist).</p>
    public let nextToken: String?
    /// <p>A list of solution versions describing the version properties.</p>
    public let solutionVersions: [SolutionVersionSummary]?

    public init (
        nextToken: String? = nil,
        solutionVersions: [SolutionVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.solutionVersions = solutionVersions
    }
}

struct ListSolutionVersionsOutputResponseBody: Equatable {
    public let solutionVersions: [SolutionVersionSummary]?
    public let nextToken: String?
}

extension ListSolutionVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case solutionVersions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionsContainer = try containerValues.decodeIfPresent([SolutionVersionSummary?].self, forKey: .solutionVersions)
        var solutionVersionsDecoded0:[SolutionVersionSummary]? = nil
        if let solutionVersionsContainer = solutionVersionsContainer {
            solutionVersionsDecoded0 = [SolutionVersionSummary]()
            for structure0 in solutionVersionsContainer {
                if let structure0 = structure0 {
                    solutionVersionsDecoded0?.append(structure0)
                }
            }
        }
        solutionVersions = solutionVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSolutionsInputBodyMiddleware: Middleware {
    public let id: String = "ListSolutionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSolutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSolutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSolutionsInput>
    public typealias MOutput = OperationOutput<ListSolutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSolutionsOutputError>
}

extension ListSolutionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSolutionsInput(datasetGroupArn: \(String(describing: datasetGroupArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSolutionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListSolutionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSolutionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSolutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSolutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSolutionsInput>
    public typealias MOutput = OperationOutput<ListSolutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSolutionsOutputError>
}

public struct ListSolutionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSolutionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSolutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSolutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSolutionsInput>
    public typealias MOutput = OperationOutput<ListSolutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSolutionsOutputError>
}

public struct ListSolutionsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset group.</p>
    public let datasetGroupArn: String?
    /// <p>The maximum number of solutions to return.</p>
    public let maxResults: Int?
    /// <p>A token returned from the previous call to <code>ListSolutions</code> for getting
    ///       the next set of solutions (if they exist).</p>
    public let nextToken: String?

    public init (
        datasetGroupArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSolutionsInputBody: Equatable {
    public let datasetGroupArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListSolutionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSolutionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSolutionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSolutionsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSolutionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSolutionsOutputResponse(nextToken: \(String(describing: nextToken)), solutions: \(String(describing: solutions)))"}
}

extension ListSolutionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSolutionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.solutions = output.solutions
        } else {
            self.nextToken = nil
            self.solutions = nil
        }
    }
}

public struct ListSolutionsOutputResponse: Equatable {
    /// <p>A token for getting the next set of solutions (if they exist).</p>
    public let nextToken: String?
    /// <p>A list of the current solutions.</p>
    public let solutions: [SolutionSummary]?

    public init (
        nextToken: String? = nil,
        solutions: [SolutionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.solutions = solutions
    }
}

struct ListSolutionsOutputResponseBody: Equatable {
    public let solutions: [SolutionSummary]?
    public let nextToken: String?
}

extension ListSolutionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case solutions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionsContainer = try containerValues.decodeIfPresent([SolutionSummary?].self, forKey: .solutions)
        var solutionsDecoded0:[SolutionSummary]? = nil
        if let solutionsContainer = solutionsContainer {
            solutionsDecoded0 = [SolutionSummary]()
            for structure0 in solutionsContainer {
                if let structure0 = structure0 {
                    solutionsDecoded0?.append(structure0)
                }
            }
        }
        solutions = solutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public enum ObjectiveSensitivity {
    case high
    case low
    case medium
    case off
    case sdkUnknown(String)
}

extension ObjectiveSensitivity : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ObjectiveSensitivity] {
        return [
            .high,
            .low,
            .medium,
            .off,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .high: return "HIGH"
        case .low: return "LOW"
        case .medium: return "MEDIUM"
        case .off: return "OFF"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ObjectiveSensitivity(rawValue: rawValue) ?? ObjectiveSensitivity.sdkUnknown(rawValue)
    }
}

extension OptimizationObjective: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case itemAttribute
        case objectiveSensitivity
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let itemAttribute = itemAttribute {
            try encodeContainer.encode(itemAttribute, forKey: .itemAttribute)
        }
        if let objectiveSensitivity = objectiveSensitivity {
            try encodeContainer.encode(objectiveSensitivity.rawValue, forKey: .objectiveSensitivity)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemAttributeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .itemAttribute)
        itemAttribute = itemAttributeDecoded
        let objectiveSensitivityDecoded = try containerValues.decodeIfPresent(ObjectiveSensitivity.self, forKey: .objectiveSensitivity)
        objectiveSensitivity = objectiveSensitivityDecoded
    }
}

extension OptimizationObjective: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OptimizationObjective(itemAttribute: \(String(describing: itemAttribute)), objectiveSensitivity: \(String(describing: objectiveSensitivity)))"}
}

/// <p>Describes the additional objective for the solution, such as maximizing streaming
///       minutes or increasing revenue. For more information see <a href="https://docs.aws.amazon.com/personalize/latest/dg/optimizing-solution-for-objective.html">Optimizing a solution</a>.</p>
public struct OptimizationObjective: Equatable {
    /// <p>The numerical metadata column in an Items dataset related to the optimization objective. For example, VIDEO_LENGTH (to maximize streaming minutes), or PRICE (to maximize revenue).</p>
    public let itemAttribute: String?
    /// <p>Specifies how Amazon Personalize balances the importance of your optimization objective versus relevance.</p>
    public let objectiveSensitivity: ObjectiveSensitivity?

    public init (
        itemAttribute: String? = nil,
        objectiveSensitivity: ObjectiveSensitivity? = nil
    )
    {
        self.itemAttribute = itemAttribute
        self.objectiveSensitivity = objectiveSensitivity
    }
}

extension Recipe: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case algorithmArn
        case creationDateTime
        case description
        case featureTransformationArn
        case lastUpdatedDateTime
        case name
        case recipeArn
        case recipeType
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let featureTransformationArn = featureTransformationArn {
            try encodeContainer.encode(featureTransformationArn, forKey: .featureTransformationArn)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recipeArn = recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let recipeType = recipeType {
            try encodeContainer.encode(recipeType, forKey: .recipeType)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let algorithmArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let featureTransformationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .featureTransformationArn)
        featureTransformationArn = featureTransformationArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let recipeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recipeType)
        recipeType = recipeTypeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension Recipe: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Recipe(algorithmArn: \(String(describing: algorithmArn)), creationDateTime: \(String(describing: creationDateTime)), description: \(String(describing: description)), featureTransformationArn: \(String(describing: featureTransformationArn)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), name: \(String(describing: name)), recipeArn: \(String(describing: recipeArn)), recipeType: \(String(describing: recipeType)), status: \(String(describing: status)))"}
}

/// <p>Provides information about a recipe. Each recipe provides an algorithm
///       that Amazon Personalize uses in model training when you use the <a>CreateSolution</a>
///       operation. </p>
public struct Recipe: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the algorithm that Amazon Personalize uses to train
    ///       the model.</p>
    public let algorithmArn: String?
    /// <p>The date and time (in Unix format) that the recipe was created.</p>
    public let creationDateTime: Date?
    /// <p>The description of the recipe.</p>
    public let description: String?
    /// <p>The ARN of the FeatureTransformation object.</p>
    public let featureTransformationArn: String?
    /// <p>The date and time (in Unix format) that the recipe was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The name of the recipe.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the recipe.</p>
    public let recipeArn: String?
    /// <p>One of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>PERSONALIZED_RANKING</p>
    ///             </li>
    ///             <li>
    ///                <p>RELATED_ITEMS</p>
    ///             </li>
    ///             <li>
    ///                <p>USER_PERSONALIZATION</p>
    ///             </li>
    ///          </ul>
    public let recipeType: String?
    /// <p>The status of the recipe.</p>
    public let status: String?

    public init (
        algorithmArn: String? = nil,
        creationDateTime: Date? = nil,
        description: String? = nil,
        featureTransformationArn: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        name: String? = nil,
        recipeArn: String? = nil,
        recipeType: String? = nil,
        status: String? = nil
    )
    {
        self.algorithmArn = algorithmArn
        self.creationDateTime = creationDateTime
        self.description = description
        self.featureTransformationArn = featureTransformationArn
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.name = name
        self.recipeArn = recipeArn
        self.recipeType = recipeType
        self.status = status
    }
}

public enum RecipeProvider {
    case service
    case sdkUnknown(String)
}

extension RecipeProvider : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RecipeProvider] {
        return [
            .service,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .service: return "SERVICE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RecipeProvider(rawValue: rawValue) ?? RecipeProvider.sdkUnknown(rawValue)
    }
}

extension RecipeSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case lastUpdatedDateTime
        case name
        case recipeArn
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recipeArn = recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension RecipeSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecipeSummary(creationDateTime: \(String(describing: creationDateTime)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), name: \(String(describing: name)), recipeArn: \(String(describing: recipeArn)), status: \(String(describing: status)))"}
}

/// <p>Provides a summary of the properties of a recipe. For a complete listing, call the
///       <a>DescribeRecipe</a> API.</p>
public struct RecipeSummary: Equatable {
    /// <p>The date and time (in Unix time) that the recipe was created.</p>
    public let creationDateTime: Date?
    /// <p>The date and time (in Unix time) that the recipe was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The name of the recipe.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the recipe.</p>
    public let recipeArn: String?
    /// <p>The status of the recipe.</p>
    public let status: String?

    public init (
        creationDateTime: Date? = nil,
        lastUpdatedDateTime: Date? = nil,
        name: String? = nil,
        recipeArn: String? = nil,
        status: String? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.name = name
        self.recipeArn = recipeArn
        self.status = status
    }
}

extension ResourceAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAlreadyExistsException(message: \(String(describing: message)))"}
}

extension ResourceAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource already exists.</p>
public struct ResourceAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension ResourceAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource is in use.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Could not find the specified resource.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3DataConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kmsKeyArn
        case path
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension S3DataConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3DataConfig(kmsKeyArn: \(String(describing: kmsKeyArn)), path: \(String(describing: path)))"}
}

/// <p>The configuration details of an Amazon S3 input or output bucket.</p>
public struct S3DataConfig: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Amazon Key Management Service (KMS) key that Amazon Personalize uses to
    ///       encrypt or decrypt the input and output files of a batch inference job.</p>
    public let kmsKeyArn: String?
    /// <p>The file path of the Amazon S3 bucket.</p>
    public let path: String?

    public init (
        kmsKeyArn: String? = nil,
        path: String? = nil
    )
    {
        self.kmsKeyArn = kmsKeyArn
        self.path = path
    }
}

extension Solution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoMLResult
        case creationDateTime
        case datasetGroupArn
        case eventType
        case lastUpdatedDateTime
        case latestSolutionVersion
        case name
        case performAutoML
        case performHPO
        case recipeArn
        case solutionArn
        case solutionConfig
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoMLResult = autoMLResult {
            try encodeContainer.encode(autoMLResult, forKey: .autoMLResult)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let eventType = eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let latestSolutionVersion = latestSolutionVersion {
            try encodeContainer.encode(latestSolutionVersion, forKey: .latestSolutionVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if performAutoML != false {
            try encodeContainer.encode(performAutoML, forKey: .performAutoML)
        }
        if performHPO != false {
            try encodeContainer.encode(performHPO, forKey: .performHPO)
        }
        if let recipeArn = recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let solutionArn = solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
        if let solutionConfig = solutionConfig {
            try encodeContainer.encode(solutionConfig, forKey: .solutionConfig)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let solutionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let performHPODecoded = try containerValues.decode(Bool.self, forKey: .performHPO)
        performHPO = performHPODecoded
        let performAutoMLDecoded = try containerValues.decode(Bool.self, forKey: .performAutoML)
        performAutoML = performAutoMLDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let solutionConfigDecoded = try containerValues.decodeIfPresent(SolutionConfig.self, forKey: .solutionConfig)
        solutionConfig = solutionConfigDecoded
        let autoMLResultDecoded = try containerValues.decodeIfPresent(AutoMLResult.self, forKey: .autoMLResult)
        autoMLResult = autoMLResultDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let latestSolutionVersionDecoded = try containerValues.decodeIfPresent(SolutionVersionSummary.self, forKey: .latestSolutionVersion)
        latestSolutionVersion = latestSolutionVersionDecoded
    }
}

extension Solution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Solution(autoMLResult: \(String(describing: autoMLResult)), creationDateTime: \(String(describing: creationDateTime)), datasetGroupArn: \(String(describing: datasetGroupArn)), eventType: \(String(describing: eventType)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), latestSolutionVersion: \(String(describing: latestSolutionVersion)), name: \(String(describing: name)), performAutoML: \(String(describing: performAutoML)), performHPO: \(String(describing: performHPO)), recipeArn: \(String(describing: recipeArn)), solutionArn: \(String(describing: solutionArn)), solutionConfig: \(String(describing: solutionConfig)), status: \(String(describing: status)))"}
}

/// <p>An object that provides information about a solution. A solution is a trained model
///       that can be deployed as a campaign.</p>
public struct Solution: Equatable {
    /// <p>When <code>performAutoML</code> is true, specifies the best recipe found.</p>
    public let autoMLResult: AutoMLResult?
    /// <p>The creation date and time (in Unix time) of the solution.</p>
    public let creationDateTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the dataset group that provides the training data.</p>
    public let datasetGroupArn: String?
    /// <p>The event type (for example, 'click' or 'like') that is used for training the model.
    ///       If no <code>eventType</code> is provided, Amazon Personalize uses all interactions for training with
    ///       equal weight regardless of type.</p>
    public let eventType: String?
    /// <p>The date and time (in Unix time) that the solution was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>Describes the latest version of the solution, including the status and the ARN.</p>
    public let latestSolutionVersion: SolutionVersionSummary?
    /// <p>The name of the solution.</p>
    public let name: String?
    /// <p>When true, Amazon Personalize performs a search for the best USER_PERSONALIZATION recipe from
    ///       the list specified in the solution configuration (<code>recipeArn</code> must not be specified).
    ///       When false (the default), Amazon Personalize uses <code>recipeArn</code> for training.</p>
    public let performAutoML: Bool
    /// <p>Whether to perform hyperparameter optimization (HPO) on the chosen recipe. The
    ///       default is <code>false</code>.</p>
    public let performHPO: Bool
    /// <p>The ARN of the recipe used to create the solution.</p>
    public let recipeArn: String?
    /// <p>The ARN of the solution.</p>
    public let solutionArn: String?
    /// <p>Describes the configuration properties for the solution.</p>
    public let solutionConfig: SolutionConfig?
    /// <p>The status of the solution.</p>
    ///          <p>A solution can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///             <li>
    ///                <p>DELETE PENDING > DELETE IN_PROGRESS</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        autoMLResult: AutoMLResult? = nil,
        creationDateTime: Date? = nil,
        datasetGroupArn: String? = nil,
        eventType: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        latestSolutionVersion: SolutionVersionSummary? = nil,
        name: String? = nil,
        performAutoML: Bool = false,
        performHPO: Bool = false,
        recipeArn: String? = nil,
        solutionArn: String? = nil,
        solutionConfig: SolutionConfig? = nil,
        status: String? = nil
    )
    {
        self.autoMLResult = autoMLResult
        self.creationDateTime = creationDateTime
        self.datasetGroupArn = datasetGroupArn
        self.eventType = eventType
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.latestSolutionVersion = latestSolutionVersion
        self.name = name
        self.performAutoML = performAutoML
        self.performHPO = performHPO
        self.recipeArn = recipeArn
        self.solutionArn = solutionArn
        self.solutionConfig = solutionConfig
        self.status = status
    }
}

extension SolutionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case algorithmHyperParameters
        case autoMLConfig
        case eventValueThreshold
        case featureTransformationParameters
        case hpoConfig
        case optimizationObjective
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmHyperParameters = algorithmHyperParameters {
            var algorithmHyperParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .algorithmHyperParameters)
            for (dictKey0, hyperparameters0) in algorithmHyperParameters {
                try algorithmHyperParametersContainer.encode(hyperparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let autoMLConfig = autoMLConfig {
            try encodeContainer.encode(autoMLConfig, forKey: .autoMLConfig)
        }
        if let eventValueThreshold = eventValueThreshold {
            try encodeContainer.encode(eventValueThreshold, forKey: .eventValueThreshold)
        }
        if let featureTransformationParameters = featureTransformationParameters {
            var featureTransformationParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .featureTransformationParameters)
            for (dictKey0, featuretransformationparameters0) in featureTransformationParameters {
                try featureTransformationParametersContainer.encode(featuretransformationparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let hpoConfig = hpoConfig {
            try encodeContainer.encode(hpoConfig, forKey: .hpoConfig)
        }
        if let optimizationObjective = optimizationObjective {
            try encodeContainer.encode(optimizationObjective, forKey: .optimizationObjective)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventValueThresholdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventValueThreshold)
        eventValueThreshold = eventValueThresholdDecoded
        let hpoConfigDecoded = try containerValues.decodeIfPresent(HPOConfig.self, forKey: .hpoConfig)
        hpoConfig = hpoConfigDecoded
        let algorithmHyperParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .algorithmHyperParameters)
        var algorithmHyperParametersDecoded0: [String:String]? = nil
        if let algorithmHyperParametersContainer = algorithmHyperParametersContainer {
            algorithmHyperParametersDecoded0 = [String:String]()
            for (key0, parametervalue0) in algorithmHyperParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    algorithmHyperParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        algorithmHyperParameters = algorithmHyperParametersDecoded0
        let featureTransformationParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .featureTransformationParameters)
        var featureTransformationParametersDecoded0: [String:String]? = nil
        if let featureTransformationParametersContainer = featureTransformationParametersContainer {
            featureTransformationParametersDecoded0 = [String:String]()
            for (key0, parametervalue0) in featureTransformationParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    featureTransformationParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        featureTransformationParameters = featureTransformationParametersDecoded0
        let autoMLConfigDecoded = try containerValues.decodeIfPresent(AutoMLConfig.self, forKey: .autoMLConfig)
        autoMLConfig = autoMLConfigDecoded
        let optimizationObjectiveDecoded = try containerValues.decodeIfPresent(OptimizationObjective.self, forKey: .optimizationObjective)
        optimizationObjective = optimizationObjectiveDecoded
    }
}

extension SolutionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SolutionConfig(algorithmHyperParameters: \(String(describing: algorithmHyperParameters)), autoMLConfig: \(String(describing: autoMLConfig)), eventValueThreshold: \(String(describing: eventValueThreshold)), featureTransformationParameters: \(String(describing: featureTransformationParameters)), hpoConfig: \(String(describing: hpoConfig)), optimizationObjective: \(String(describing: optimizationObjective)))"}
}

/// <p>Describes the configuration properties for the solution.</p>
public struct SolutionConfig: Equatable {
    /// <p>Lists the hyperparameter names and ranges.</p>
    public let algorithmHyperParameters: [String:String]?
    /// <p>The <a>AutoMLConfig</a> object containing a list of recipes to search
    ///       when AutoML is performed.</p>
    public let autoMLConfig: AutoMLConfig?
    /// <p>Only events with a value greater than or equal to this threshold are
    ///       used for training a model.</p>
    public let eventValueThreshold: String?
    /// <p>Lists the feature transformation parameters.</p>
    public let featureTransformationParameters: [String:String]?
    /// <p>Describes the properties for hyperparameter optimization (HPO).</p>
    public let hpoConfig: HPOConfig?
    /// <p>Describes the additional objective for the solution, such as maximizing streaming
    ///       minutes or increasing revenue. For more information see <a href="https://docs.aws.amazon.com/personalize/latest/dg/optimizing-solution-for-objective.html">Optimizing a solution</a>.</p>
    public let optimizationObjective: OptimizationObjective?

    public init (
        algorithmHyperParameters: [String:String]? = nil,
        autoMLConfig: AutoMLConfig? = nil,
        eventValueThreshold: String? = nil,
        featureTransformationParameters: [String:String]? = nil,
        hpoConfig: HPOConfig? = nil,
        optimizationObjective: OptimizationObjective? = nil
    )
    {
        self.algorithmHyperParameters = algorithmHyperParameters
        self.autoMLConfig = autoMLConfig
        self.eventValueThreshold = eventValueThreshold
        self.featureTransformationParameters = featureTransformationParameters
        self.hpoConfig = hpoConfig
        self.optimizationObjective = optimizationObjective
    }
}

extension SolutionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case lastUpdatedDateTime
        case name
        case solutionArn
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let solutionArn = solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let solutionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension SolutionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SolutionSummary(creationDateTime: \(String(describing: creationDateTime)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), name: \(String(describing: name)), solutionArn: \(String(describing: solutionArn)), status: \(String(describing: status)))"}
}

/// <p>Provides a summary of the properties of a solution. For a complete listing, call the
///       <a>DescribeSolution</a> API.</p>
public struct SolutionSummary: Equatable {
    /// <p>The date and time (in Unix time) that the solution was created.</p>
    public let creationDateTime: Date?
    /// <p>The date and time (in Unix time) that the solution was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The name of the solution.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the solution.</p>
    public let solutionArn: String?
    /// <p>The status of the solution.</p>
    ///          <p>A solution can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///             <li>
    ///                <p>DELETE PENDING > DELETE IN_PROGRESS</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        creationDateTime: Date? = nil,
        lastUpdatedDateTime: Date? = nil,
        name: String? = nil,
        solutionArn: String? = nil,
        status: String? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.name = name
        self.solutionArn = solutionArn
        self.status = status
    }
}

extension SolutionVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case datasetGroupArn
        case eventType
        case failureReason
        case lastUpdatedDateTime
        case performAutoML
        case performHPO
        case recipeArn
        case solutionArn
        case solutionConfig
        case solutionVersionArn
        case status
        case trainingHours
        case trainingMode
        case tunedHPOParams
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let eventType = eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if performAutoML != false {
            try encodeContainer.encode(performAutoML, forKey: .performAutoML)
        }
        if performHPO != false {
            try encodeContainer.encode(performHPO, forKey: .performHPO)
        }
        if let recipeArn = recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let solutionArn = solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
        if let solutionConfig = solutionConfig {
            try encodeContainer.encode(solutionConfig, forKey: .solutionConfig)
        }
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let trainingHours = trainingHours {
            try encodeContainer.encode(trainingHours, forKey: .trainingHours)
        }
        if let trainingMode = trainingMode {
            try encodeContainer.encode(trainingMode.rawValue, forKey: .trainingMode)
        }
        if let tunedHPOParams = tunedHPOParams {
            try encodeContainer.encode(tunedHPOParams, forKey: .tunedHPOParams)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let solutionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let performHPODecoded = try containerValues.decode(Bool.self, forKey: .performHPO)
        performHPO = performHPODecoded
        let performAutoMLDecoded = try containerValues.decode(Bool.self, forKey: .performAutoML)
        performAutoML = performAutoMLDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let solutionConfigDecoded = try containerValues.decodeIfPresent(SolutionConfig.self, forKey: .solutionConfig)
        solutionConfig = solutionConfigDecoded
        let trainingHoursDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .trainingHours)
        trainingHours = trainingHoursDecoded
        let trainingModeDecoded = try containerValues.decodeIfPresent(TrainingMode.self, forKey: .trainingMode)
        trainingMode = trainingModeDecoded
        let tunedHPOParamsDecoded = try containerValues.decodeIfPresent(TunedHPOParams.self, forKey: .tunedHPOParams)
        tunedHPOParams = tunedHPOParamsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension SolutionVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SolutionVersion(creationDateTime: \(String(describing: creationDateTime)), datasetGroupArn: \(String(describing: datasetGroupArn)), eventType: \(String(describing: eventType)), failureReason: \(String(describing: failureReason)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), performAutoML: \(String(describing: performAutoML)), performHPO: \(String(describing: performHPO)), recipeArn: \(String(describing: recipeArn)), solutionArn: \(String(describing: solutionArn)), solutionConfig: \(String(describing: solutionConfig)), solutionVersionArn: \(String(describing: solutionVersionArn)), status: \(String(describing: status)), trainingHours: \(String(describing: trainingHours)), trainingMode: \(String(describing: trainingMode)), tunedHPOParams: \(String(describing: tunedHPOParams)))"}
}

/// <p>An object that provides information about a specific version of a <a>Solution</a>.</p>
public struct SolutionVersion: Equatable {
    /// <p>The date and
    ///       time
    ///       (in Unix time) that this version of the solution was created.</p>
    public let creationDateTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the dataset group providing the training data.</p>
    public let datasetGroupArn: String?
    /// <p>The event type (for example, 'click' or 'like') that is used for training the
    ///       model.</p>
    public let eventType: String?
    /// <p>If training a solution version fails, the reason for the failure.</p>
    public let failureReason: String?
    /// <p>The date and time (in
    ///       Unix
    ///       time) that the solution was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>When true, Amazon Personalize searches for the most optimal recipe according to the solution
    ///       configuration. When false (the default), Amazon Personalize uses <code>recipeArn</code>.</p>
    public let performAutoML: Bool
    /// <p>Whether to perform hyperparameter optimization (HPO) on the chosen recipe. The default is
    ///         <code>false</code>.</p>
    public let performHPO: Bool
    /// <p>The ARN of the recipe used in the solution.</p>
    public let recipeArn: String?
    /// <p>The ARN of the solution.</p>
    public let solutionArn: String?
    /// <p>Describes the configuration properties for the solution.</p>
    public let solutionConfig: SolutionConfig?
    /// <p>The ARN of the solution version.</p>
    public let solutionVersionArn: String?
    /// <p>The status of the solution version.</p>
    ///          <p>A solution version can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING</p>
    ///             </li>
    ///             <li>
    ///                <p>CREATE IN_PROGRESS</p>
    ///             </li>
    ///             <li>
    ///                <p>ACTIVE</p>
    ///             </li>
    ///             <li>
    ///                <p>CREATE FAILED</p>
    ///             </li>
    ///             <li>
    ///                <p>CREATE STOPPING</p>
    ///             </li>
    ///             <li>
    ///                <p>CREATE STOPPED</p>
    ///             </li>
    ///          </ul>
    public let status: String?
    /// <p>The time used to train the model. You are billed for the time it takes to train a model.
    ///       This field is visible only after Amazon Personalize successfully trains a model.</p>
    public let trainingHours: Double?
    /// <p>The scope of training to be performed when creating the solution version. The
    ///       <code>FULL</code> option trains the solution version based on the entirety of the input
    ///       solution's training data, while the <code>UPDATE</code> option processes only the data that
    ///       has changed in comparison to the input solution. Choose <code>UPDATE</code> when you want to
    ///       incrementally update your solution version instead of creating an entirely new one.</p>
    ///          <important>
    ///             <p>The <code>UPDATE</code> option can only be used when you already have an active solution
    ///         version created from the input solution using the <code>FULL</code> option and the input
    ///         solution was trained with the
    ///         <a href="https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-new-item-USER_PERSONALIZATION.html">User-Personalization</a>
    ///         recipe or the
    ///         <a href="https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-hrnn-coldstart.html">HRNN-Coldstart</a> recipe.</p>
    ///          </important>
    public let trainingMode: TrainingMode?
    /// <p>If hyperparameter optimization was performed, contains the hyperparameter values of the
    ///       best performing model.</p>
    public let tunedHPOParams: TunedHPOParams?

    public init (
        creationDateTime: Date? = nil,
        datasetGroupArn: String? = nil,
        eventType: String? = nil,
        failureReason: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        performAutoML: Bool = false,
        performHPO: Bool = false,
        recipeArn: String? = nil,
        solutionArn: String? = nil,
        solutionConfig: SolutionConfig? = nil,
        solutionVersionArn: String? = nil,
        status: String? = nil,
        trainingHours: Double? = nil,
        trainingMode: TrainingMode? = nil,
        tunedHPOParams: TunedHPOParams? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.datasetGroupArn = datasetGroupArn
        self.eventType = eventType
        self.failureReason = failureReason
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.performAutoML = performAutoML
        self.performHPO = performHPO
        self.recipeArn = recipeArn
        self.solutionArn = solutionArn
        self.solutionConfig = solutionConfig
        self.solutionVersionArn = solutionVersionArn
        self.status = status
        self.trainingHours = trainingHours
        self.trainingMode = trainingMode
        self.tunedHPOParams = tunedHPOParams
    }
}

extension SolutionVersionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case failureReason
        case lastUpdatedDateTime
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension SolutionVersionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SolutionVersionSummary(creationDateTime: \(String(describing: creationDateTime)), failureReason: \(String(describing: failureReason)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), solutionVersionArn: \(String(describing: solutionVersionArn)), status: \(String(describing: status)))"}
}

/// <p>Provides a summary of the properties of a solution version. For a complete listing, call the
///       <a>DescribeSolutionVersion</a> API.</p>
public struct SolutionVersionSummary: Equatable {
    /// <p>The date and time (in Unix time) that this version of a solution was created.</p>
    public let creationDateTime: Date?
    /// <p>If a solution version fails, the reason behind the failure.</p>
    public let failureReason: String?
    /// <p>The date and time (in Unix time) that the solution version was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the solution version.</p>
    public let solutionVersionArn: String?
    /// <p>The status of the solution version.</p>
    ///          <p>A solution version can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        creationDateTime: Date? = nil,
        failureReason: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        solutionVersionArn: String? = nil,
        status: String? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.failureReason = failureReason
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.solutionVersionArn = solutionVersionArn
        self.status = status
    }
}

public struct StopSolutionVersionCreationInputBodyMiddleware: Middleware {
    public let id: String = "StopSolutionVersionCreationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopSolutionVersionCreationInput>,
                  next: H) -> Swift.Result<OperationOutput<StopSolutionVersionCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopSolutionVersionCreationInput>
    public typealias MOutput = OperationOutput<StopSolutionVersionCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopSolutionVersionCreationOutputError>
}

extension StopSolutionVersionCreationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopSolutionVersionCreationInput(solutionVersionArn: \(String(describing: solutionVersionArn)))"}
}

extension StopSolutionVersionCreationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case solutionVersionArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

public struct StopSolutionVersionCreationInputHeadersMiddleware: Middleware {
    public let id: String = "StopSolutionVersionCreationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopSolutionVersionCreationInput>,
                  next: H) -> Swift.Result<OperationOutput<StopSolutionVersionCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopSolutionVersionCreationInput>
    public typealias MOutput = OperationOutput<StopSolutionVersionCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopSolutionVersionCreationOutputError>
}

public struct StopSolutionVersionCreationInputQueryItemMiddleware: Middleware {
    public let id: String = "StopSolutionVersionCreationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopSolutionVersionCreationInput>,
                  next: H) -> Swift.Result<OperationOutput<StopSolutionVersionCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopSolutionVersionCreationInput>
    public typealias MOutput = OperationOutput<StopSolutionVersionCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopSolutionVersionCreationOutputError>
}

public struct StopSolutionVersionCreationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the solution version you want to stop creating.</p>
    public let solutionVersionArn: String?

    public init (
        solutionVersionArn: String? = nil
    )
    {
        self.solutionVersionArn = solutionVersionArn
    }
}

struct StopSolutionVersionCreationInputBody: Equatable {
    public let solutionVersionArn: String?
}

extension StopSolutionVersionCreationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case solutionVersionArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
    }
}

extension StopSolutionVersionCreationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopSolutionVersionCreationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopSolutionVersionCreationOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopSolutionVersionCreationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopSolutionVersionCreationOutputResponse()"}
}

extension StopSolutionVersionCreationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopSolutionVersionCreationOutputResponse: Equatable {

    public init() {}
}

struct StopSolutionVersionCreationOutputResponseBody: Equatable {
}

extension StopSolutionVersionCreationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum TrainingMode {
    case full
    case update
    case sdkUnknown(String)
}

extension TrainingMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TrainingMode] {
        return [
            .full,
            .update,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .full: return "FULL"
        case .update: return "UPDATE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TrainingMode(rawValue: rawValue) ?? TrainingMode.sdkUnknown(rawValue)
    }
}

extension TunedHPOParams: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case algorithmHyperParameters
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmHyperParameters = algorithmHyperParameters {
            var algorithmHyperParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .algorithmHyperParameters)
            for (dictKey0, hyperparameters0) in algorithmHyperParameters {
                try algorithmHyperParametersContainer.encode(hyperparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmHyperParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .algorithmHyperParameters)
        var algorithmHyperParametersDecoded0: [String:String]? = nil
        if let algorithmHyperParametersContainer = algorithmHyperParametersContainer {
            algorithmHyperParametersDecoded0 = [String:String]()
            for (key0, parametervalue0) in algorithmHyperParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    algorithmHyperParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        algorithmHyperParameters = algorithmHyperParametersDecoded0
    }
}

extension TunedHPOParams: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TunedHPOParams(algorithmHyperParameters: \(String(describing: algorithmHyperParameters)))"}
}

/// <p>If hyperparameter optimization (HPO) was performed, contains the hyperparameter values of
///       the best performing model.</p>
public struct TunedHPOParams: Equatable {
    /// <p>A list of the hyperparameter values of the best performing model.</p>
    public let algorithmHyperParameters: [String:String]?

    public init (
        algorithmHyperParameters: [String:String]? = nil
    )
    {
        self.algorithmHyperParameters = algorithmHyperParameters
    }
}

public struct UpdateCampaignInputBodyMiddleware: Middleware {
    public let id: String = "UpdateCampaignInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCampaignInput>
    public typealias MOutput = OperationOutput<UpdateCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCampaignOutputError>
}

extension UpdateCampaignInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCampaignInput(campaignArn: \(String(describing: campaignArn)), campaignConfig: \(String(describing: campaignConfig)), minProvisionedTPS: \(String(describing: minProvisionedTPS)), solutionVersionArn: \(String(describing: solutionVersionArn)))"}
}

extension UpdateCampaignInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case campaignArn
        case campaignConfig
        case minProvisionedTPS
        case solutionVersionArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
        if let campaignConfig = campaignConfig {
            try encodeContainer.encode(campaignConfig, forKey: .campaignConfig)
        }
        if let minProvisionedTPS = minProvisionedTPS {
            try encodeContainer.encode(minProvisionedTPS, forKey: .minProvisionedTPS)
        }
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

public struct UpdateCampaignInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateCampaignInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCampaignInput>
    public typealias MOutput = OperationOutput<UpdateCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCampaignOutputError>
}

public struct UpdateCampaignInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateCampaignInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCampaignInput>
    public typealias MOutput = OperationOutput<UpdateCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCampaignOutputError>
}

public struct UpdateCampaignInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the campaign.</p>
    public let campaignArn: String?
    /// <p>The configuration details of a campaign.</p>
    public let campaignConfig: CampaignConfig?
    /// <p>Specifies the requested minimum provisioned transactions (recommendations) per second that
    ///       Amazon Personalize will support.</p>
    public let minProvisionedTPS: Int?
    /// <p>The ARN of a new solution version to deploy.</p>
    public let solutionVersionArn: String?

    public init (
        campaignArn: String? = nil,
        campaignConfig: CampaignConfig? = nil,
        minProvisionedTPS: Int? = nil,
        solutionVersionArn: String? = nil
    )
    {
        self.campaignArn = campaignArn
        self.campaignConfig = campaignConfig
        self.minProvisionedTPS = minProvisionedTPS
        self.solutionVersionArn = solutionVersionArn
    }
}

struct UpdateCampaignInputBody: Equatable {
    public let campaignArn: String?
    public let solutionVersionArn: String?
    public let minProvisionedTPS: Int?
    public let campaignConfig: CampaignConfig?
}

extension UpdateCampaignInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case campaignArn
        case campaignConfig
        case minProvisionedTPS
        case solutionVersionArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let minProvisionedTPSDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minProvisionedTPS)
        minProvisionedTPS = minProvisionedTPSDecoded
        let campaignConfigDecoded = try containerValues.decodeIfPresent(CampaignConfig.self, forKey: .campaignConfig)
        campaignConfig = campaignConfigDecoded
    }
}

extension UpdateCampaignOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCampaignOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCampaignOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCampaignOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCampaignOutputResponse(campaignArn: \(String(describing: campaignArn)))"}
}

extension UpdateCampaignOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateCampaignOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.campaignArn = output.campaignArn
        } else {
            self.campaignArn = nil
        }
    }
}

public struct UpdateCampaignOutputResponse: Equatable {
    /// <p>The same campaign ARN as given in the request.</p>
    public let campaignArn: String?

    public init (
        campaignArn: String? = nil
    )
    {
        self.campaignArn = campaignArn
    }
}

struct UpdateCampaignOutputResponseBody: Equatable {
    public let campaignArn: String?
}

extension UpdateCampaignOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case campaignArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
    }
}
