// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[ListAliasesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAliasesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAliasesOutputResponse`
extension LambdaClient {
    public func listAliasesPaginated(input: ListAliasesInput) -> ClientRuntime.PaginatorSequence<ListAliasesInput, ListAliasesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAliasesInput, ListAliasesOutputResponse>(input: input, inputKey: \ListAliasesInput.marker, outputKey: \ListAliasesOutputResponse.nextMarker, paginationFunction: self.listAliases(input:))
    }
}

extension ListAliasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAliasesInput {
        return ListAliasesInput(
            functionName: self.functionName,
            functionVersion: self.functionVersion,
            marker: token,
            maxItems: self.maxItems
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAliasesPaginated`
/// to access the nested member `[LambdaClientTypes.AliasConfiguration]`
/// - Returns: `[LambdaClientTypes.AliasConfiguration]`
extension PaginatorSequence where Input == ListAliasesInput, Output == ListAliasesOutputResponse {
    func aliases() async throws -> [LambdaClientTypes.AliasConfiguration] {
        return try await self.asyncCompactMap { item in item.aliases }
    }
}

/// Paginate over `[ListCodeSigningConfigsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCodeSigningConfigsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCodeSigningConfigsOutputResponse`
extension LambdaClient {
    public func listCodeSigningConfigsPaginated(input: ListCodeSigningConfigsInput) -> ClientRuntime.PaginatorSequence<ListCodeSigningConfigsInput, ListCodeSigningConfigsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCodeSigningConfigsInput, ListCodeSigningConfigsOutputResponse>(input: input, inputKey: \ListCodeSigningConfigsInput.marker, outputKey: \ListCodeSigningConfigsOutputResponse.nextMarker, paginationFunction: self.listCodeSigningConfigs(input:))
    }
}

extension ListCodeSigningConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCodeSigningConfigsInput {
        return ListCodeSigningConfigsInput(
            marker: token,
            maxItems: self.maxItems
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listCodeSigningConfigsPaginated`
/// to access the nested member `[LambdaClientTypes.CodeSigningConfig]`
/// - Returns: `[LambdaClientTypes.CodeSigningConfig]`
extension PaginatorSequence where Input == ListCodeSigningConfigsInput, Output == ListCodeSigningConfigsOutputResponse {
    func codeSigningConfigs() async throws -> [LambdaClientTypes.CodeSigningConfig] {
        return try await self.asyncCompactMap { item in item.codeSigningConfigs }
    }
}

/// Paginate over `[ListEventSourceMappingsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListEventSourceMappingsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListEventSourceMappingsOutputResponse`
extension LambdaClient {
    public func listEventSourceMappingsPaginated(input: ListEventSourceMappingsInput) -> ClientRuntime.PaginatorSequence<ListEventSourceMappingsInput, ListEventSourceMappingsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListEventSourceMappingsInput, ListEventSourceMappingsOutputResponse>(input: input, inputKey: \ListEventSourceMappingsInput.marker, outputKey: \ListEventSourceMappingsOutputResponse.nextMarker, paginationFunction: self.listEventSourceMappings(input:))
    }
}

extension ListEventSourceMappingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEventSourceMappingsInput {
        return ListEventSourceMappingsInput(
            eventSourceArn: self.eventSourceArn,
            functionName: self.functionName,
            marker: token,
            maxItems: self.maxItems
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listEventSourceMappingsPaginated`
/// to access the nested member `[LambdaClientTypes.EventSourceMappingConfiguration]`
/// - Returns: `[LambdaClientTypes.EventSourceMappingConfiguration]`
extension PaginatorSequence where Input == ListEventSourceMappingsInput, Output == ListEventSourceMappingsOutputResponse {
    func eventSourceMappings() async throws -> [LambdaClientTypes.EventSourceMappingConfiguration] {
        return try await self.asyncCompactMap { item in item.eventSourceMappings }
    }
}

/// Paginate over `[ListFunctionEventInvokeConfigsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListFunctionEventInvokeConfigsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListFunctionEventInvokeConfigsOutputResponse`
extension LambdaClient {
    public func listFunctionEventInvokeConfigsPaginated(input: ListFunctionEventInvokeConfigsInput) -> ClientRuntime.PaginatorSequence<ListFunctionEventInvokeConfigsInput, ListFunctionEventInvokeConfigsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListFunctionEventInvokeConfigsInput, ListFunctionEventInvokeConfigsOutputResponse>(input: input, inputKey: \ListFunctionEventInvokeConfigsInput.marker, outputKey: \ListFunctionEventInvokeConfigsOutputResponse.nextMarker, paginationFunction: self.listFunctionEventInvokeConfigs(input:))
    }
}

extension ListFunctionEventInvokeConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFunctionEventInvokeConfigsInput {
        return ListFunctionEventInvokeConfigsInput(
            functionName: self.functionName,
            marker: token,
            maxItems: self.maxItems
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listFunctionEventInvokeConfigsPaginated`
/// to access the nested member `[LambdaClientTypes.FunctionEventInvokeConfig]`
/// - Returns: `[LambdaClientTypes.FunctionEventInvokeConfig]`
extension PaginatorSequence where Input == ListFunctionEventInvokeConfigsInput, Output == ListFunctionEventInvokeConfigsOutputResponse {
    func functionEventInvokeConfigs() async throws -> [LambdaClientTypes.FunctionEventInvokeConfig] {
        return try await self.asyncCompactMap { item in item.functionEventInvokeConfigs }
    }
}

/// Paginate over `[ListFunctionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListFunctionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListFunctionsOutputResponse`
extension LambdaClient {
    public func listFunctionsPaginated(input: ListFunctionsInput) -> ClientRuntime.PaginatorSequence<ListFunctionsInput, ListFunctionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListFunctionsInput, ListFunctionsOutputResponse>(input: input, inputKey: \ListFunctionsInput.marker, outputKey: \ListFunctionsOutputResponse.nextMarker, paginationFunction: self.listFunctions(input:))
    }
}

extension ListFunctionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFunctionsInput {
        return ListFunctionsInput(
            functionVersion: self.functionVersion,
            marker: token,
            masterRegion: self.masterRegion,
            maxItems: self.maxItems
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listFunctionsPaginated`
/// to access the nested member `[LambdaClientTypes.FunctionConfiguration]`
/// - Returns: `[LambdaClientTypes.FunctionConfiguration]`
extension PaginatorSequence where Input == ListFunctionsInput, Output == ListFunctionsOutputResponse {
    func functions() async throws -> [LambdaClientTypes.FunctionConfiguration] {
        return try await self.asyncCompactMap { item in item.functions }
    }
}

/// Paginate over `[ListFunctionsByCodeSigningConfigOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListFunctionsByCodeSigningConfigInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListFunctionsByCodeSigningConfigOutputResponse`
extension LambdaClient {
    public func listFunctionsByCodeSigningConfigPaginated(input: ListFunctionsByCodeSigningConfigInput) -> ClientRuntime.PaginatorSequence<ListFunctionsByCodeSigningConfigInput, ListFunctionsByCodeSigningConfigOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListFunctionsByCodeSigningConfigInput, ListFunctionsByCodeSigningConfigOutputResponse>(input: input, inputKey: \ListFunctionsByCodeSigningConfigInput.marker, outputKey: \ListFunctionsByCodeSigningConfigOutputResponse.nextMarker, paginationFunction: self.listFunctionsByCodeSigningConfig(input:))
    }
}

extension ListFunctionsByCodeSigningConfigInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFunctionsByCodeSigningConfigInput {
        return ListFunctionsByCodeSigningConfigInput(
            codeSigningConfigArn: self.codeSigningConfigArn,
            marker: token,
            maxItems: self.maxItems
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listFunctionsByCodeSigningConfigPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListFunctionsByCodeSigningConfigInput, Output == ListFunctionsByCodeSigningConfigOutputResponse {
    func functionArns() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.functionArns }
    }
}

/// Paginate over `[ListLayersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListLayersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListLayersOutputResponse`
extension LambdaClient {
    public func listLayersPaginated(input: ListLayersInput) -> ClientRuntime.PaginatorSequence<ListLayersInput, ListLayersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListLayersInput, ListLayersOutputResponse>(input: input, inputKey: \ListLayersInput.marker, outputKey: \ListLayersOutputResponse.nextMarker, paginationFunction: self.listLayers(input:))
    }
}

extension ListLayersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLayersInput {
        return ListLayersInput(
            compatibleArchitecture: self.compatibleArchitecture,
            compatibleRuntime: self.compatibleRuntime,
            marker: token,
            maxItems: self.maxItems
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listLayersPaginated`
/// to access the nested member `[LambdaClientTypes.LayersListItem]`
/// - Returns: `[LambdaClientTypes.LayersListItem]`
extension PaginatorSequence where Input == ListLayersInput, Output == ListLayersOutputResponse {
    func layers() async throws -> [LambdaClientTypes.LayersListItem] {
        return try await self.asyncCompactMap { item in item.layers }
    }
}

/// Paginate over `[ListLayerVersionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListLayerVersionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListLayerVersionsOutputResponse`
extension LambdaClient {
    public func listLayerVersionsPaginated(input: ListLayerVersionsInput) -> ClientRuntime.PaginatorSequence<ListLayerVersionsInput, ListLayerVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListLayerVersionsInput, ListLayerVersionsOutputResponse>(input: input, inputKey: \ListLayerVersionsInput.marker, outputKey: \ListLayerVersionsOutputResponse.nextMarker, paginationFunction: self.listLayerVersions(input:))
    }
}

extension ListLayerVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLayerVersionsInput {
        return ListLayerVersionsInput(
            compatibleArchitecture: self.compatibleArchitecture,
            compatibleRuntime: self.compatibleRuntime,
            layerName: self.layerName,
            marker: token,
            maxItems: self.maxItems
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listLayerVersionsPaginated`
/// to access the nested member `[LambdaClientTypes.LayerVersionsListItem]`
/// - Returns: `[LambdaClientTypes.LayerVersionsListItem]`
extension PaginatorSequence where Input == ListLayerVersionsInput, Output == ListLayerVersionsOutputResponse {
    func layerVersions() async throws -> [LambdaClientTypes.LayerVersionsListItem] {
        return try await self.asyncCompactMap { item in item.layerVersions }
    }
}

/// Paginate over `[ListProvisionedConcurrencyConfigsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListProvisionedConcurrencyConfigsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListProvisionedConcurrencyConfigsOutputResponse`
extension LambdaClient {
    public func listProvisionedConcurrencyConfigsPaginated(input: ListProvisionedConcurrencyConfigsInput) -> ClientRuntime.PaginatorSequence<ListProvisionedConcurrencyConfigsInput, ListProvisionedConcurrencyConfigsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListProvisionedConcurrencyConfigsInput, ListProvisionedConcurrencyConfigsOutputResponse>(input: input, inputKey: \ListProvisionedConcurrencyConfigsInput.marker, outputKey: \ListProvisionedConcurrencyConfigsOutputResponse.nextMarker, paginationFunction: self.listProvisionedConcurrencyConfigs(input:))
    }
}

extension ListProvisionedConcurrencyConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProvisionedConcurrencyConfigsInput {
        return ListProvisionedConcurrencyConfigsInput(
            functionName: self.functionName,
            marker: token,
            maxItems: self.maxItems
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listProvisionedConcurrencyConfigsPaginated`
/// to access the nested member `[LambdaClientTypes.ProvisionedConcurrencyConfigListItem]`
/// - Returns: `[LambdaClientTypes.ProvisionedConcurrencyConfigListItem]`
extension PaginatorSequence where Input == ListProvisionedConcurrencyConfigsInput, Output == ListProvisionedConcurrencyConfigsOutputResponse {
    func provisionedConcurrencyConfigs() async throws -> [LambdaClientTypes.ProvisionedConcurrencyConfigListItem] {
        return try await self.asyncCompactMap { item in item.provisionedConcurrencyConfigs }
    }
}

/// Paginate over `[ListVersionsByFunctionOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListVersionsByFunctionInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListVersionsByFunctionOutputResponse`
extension LambdaClient {
    public func listVersionsByFunctionPaginated(input: ListVersionsByFunctionInput) -> ClientRuntime.PaginatorSequence<ListVersionsByFunctionInput, ListVersionsByFunctionOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListVersionsByFunctionInput, ListVersionsByFunctionOutputResponse>(input: input, inputKey: \ListVersionsByFunctionInput.marker, outputKey: \ListVersionsByFunctionOutputResponse.nextMarker, paginationFunction: self.listVersionsByFunction(input:))
    }
}

extension ListVersionsByFunctionInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListVersionsByFunctionInput {
        return ListVersionsByFunctionInput(
            functionName: self.functionName,
            marker: token,
            maxItems: self.maxItems
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listVersionsByFunctionPaginated`
/// to access the nested member `[LambdaClientTypes.FunctionConfiguration]`
/// - Returns: `[LambdaClientTypes.FunctionConfiguration]`
extension PaginatorSequence where Input == ListVersionsByFunctionInput, Output == ListVersionsByFunctionOutputResponse {
    func versions() async throws -> [LambdaClientTypes.FunctionConfiguration] {
        return try await self.asyncCompactMap { item in item.versions }
    }
}
