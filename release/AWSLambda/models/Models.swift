// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension LambdaClientTypes.AccountLimit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSizeUnzipped = "CodeSizeUnzipped"
        case codeSizeZipped = "CodeSizeZipped"
        case concurrentExecutions = "ConcurrentExecutions"
        case totalCodeSize = "TotalCodeSize"
        case unreservedConcurrentExecutions = "UnreservedConcurrentExecutions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if codeSizeUnzipped != 0 {
            try encodeContainer.encode(codeSizeUnzipped, forKey: .codeSizeUnzipped)
        }
        if codeSizeZipped != 0 {
            try encodeContainer.encode(codeSizeZipped, forKey: .codeSizeZipped)
        }
        if concurrentExecutions != 0 {
            try encodeContainer.encode(concurrentExecutions, forKey: .concurrentExecutions)
        }
        if totalCodeSize != 0 {
            try encodeContainer.encode(totalCodeSize, forKey: .totalCodeSize)
        }
        if let unreservedConcurrentExecutions = unreservedConcurrentExecutions {
            try encodeContainer.encode(unreservedConcurrentExecutions, forKey: .unreservedConcurrentExecutions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalCodeSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalCodeSize)
        totalCodeSize = totalCodeSizeDecoded
        let codeSizeUnzippedDecoded = try containerValues.decode(Swift.Int.self, forKey: .codeSizeUnzipped)
        codeSizeUnzipped = codeSizeUnzippedDecoded
        let codeSizeZippedDecoded = try containerValues.decode(Swift.Int.self, forKey: .codeSizeZipped)
        codeSizeZipped = codeSizeZippedDecoded
        let concurrentExecutionsDecoded = try containerValues.decode(Swift.Int.self, forKey: .concurrentExecutions)
        concurrentExecutions = concurrentExecutionsDecoded
        let unreservedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unreservedConcurrentExecutions)
        unreservedConcurrentExecutions = unreservedConcurrentExecutionsDecoded
    }
}

extension LambdaClientTypes {
    /// Limits that are related to concurrency and storage. All file and storage sizes are in bytes.
    public struct AccountLimit: Swift.Equatable {
        /// The maximum size of a function's deployment package and layers when they're extracted.
        public var codeSizeUnzipped: Swift.Int
        /// The maximum size of a deployment package when it's uploaded directly to Lambda. Use Amazon S3 for larger files.
        public var codeSizeZipped: Swift.Int
        /// The maximum number of simultaneous function executions.
        public var concurrentExecutions: Swift.Int
        /// The amount of storage space that you can use for all deployment packages and layer archives.
        public var totalCodeSize: Swift.Int
        /// The maximum number of simultaneous function executions, minus the capacity that's reserved for individual functions with [PutFunctionConcurrency].
        public var unreservedConcurrentExecutions: Swift.Int?

        public init (
            codeSizeUnzipped: Swift.Int = 0,
            codeSizeZipped: Swift.Int = 0,
            concurrentExecutions: Swift.Int = 0,
            totalCodeSize: Swift.Int = 0,
            unreservedConcurrentExecutions: Swift.Int? = nil
        )
        {
            self.codeSizeUnzipped = codeSizeUnzipped
            self.codeSizeZipped = codeSizeZipped
            self.concurrentExecutions = concurrentExecutions
            self.totalCodeSize = totalCodeSize
            self.unreservedConcurrentExecutions = unreservedConcurrentExecutions
        }
    }

}

extension LambdaClientTypes.AccountUsage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionCount = "FunctionCount"
        case totalCodeSize = "TotalCodeSize"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if functionCount != 0 {
            try encodeContainer.encode(functionCount, forKey: .functionCount)
        }
        if totalCodeSize != 0 {
            try encodeContainer.encode(totalCodeSize, forKey: .totalCodeSize)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalCodeSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalCodeSize)
        totalCodeSize = totalCodeSizeDecoded
        let functionCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .functionCount)
        functionCount = functionCountDecoded
    }
}

extension LambdaClientTypes {
    /// The number of functions and amount of storage in use.
    public struct AccountUsage: Swift.Equatable {
        /// The number of Lambda functions.
        public var functionCount: Swift.Int
        /// The amount of storage space, in bytes, that's being used by deployment packages and layer archives.
        public var totalCodeSize: Swift.Int

        public init (
            functionCount: Swift.Int = 0,
            totalCodeSize: Swift.Int = 0
        )
        {
            self.functionCount = functionCount
            self.totalCodeSize = totalCodeSize
        }
    }

}

extension AddLayerVersionPermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case organizationId = "OrganizationId"
        case principal = "Principal"
        case statementId = "StatementId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let statementId = statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }
}

extension AddLayerVersionPermissionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let revisionId = revisionId {
            let revisionIdQueryItem = ClientRuntime.URLQueryItem(name: "RevisionId".urlPercentEncoding(), value: Swift.String(revisionId).urlPercentEncoding())
            items.append(revisionIdQueryItem)
        }
        return items
    }
}

extension AddLayerVersionPermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let layerName = layerName else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)/policy"
    }
}

public struct AddLayerVersionPermissionInput: Swift.Equatable {
    /// The API action that grants access to the layer. For example, lambda:GetLayerVersion.
    /// This member is required.
    public var action: Swift.String?
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// With the principal set to *, grant permission to all accounts in the specified organization.
    public var organizationId: Swift.String?
    /// An account ID, or * to grant layer usage permission to all accounts in an organization, or all Amazon Web Services accounts (if organizationId is not specified). For the last case, make sure that you really do want all Amazon Web Services accounts to have usage permission to this layer.
    /// This member is required.
    public var principal: Swift.String?
    /// Only update the policy if the revision ID matches the ID specified. Use this option to avoid modifying a policy that has changed since you last read it.
    public var revisionId: Swift.String?
    /// An identifier that distinguishes the policy from others on the same layer version.
    /// This member is required.
    public var statementId: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int

    public init (
        action: Swift.String? = nil,
        layerName: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        principal: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        statementId: Swift.String? = nil,
        versionNumber: Swift.Int = 0
    )
    {
        self.action = action
        self.layerName = layerName
        self.organizationId = organizationId
        self.principal = principal
        self.revisionId = revisionId
        self.statementId = statementId
        self.versionNumber = versionNumber
    }
}

struct AddLayerVersionPermissionInputBody: Swift.Equatable {
    let statementId: Swift.String?
    let action: Swift.String?
    let principal: Swift.String?
    let organizationId: Swift.String?
}

extension AddLayerVersionPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case organizationId = "OrganizationId"
        case principal = "Principal"
        case statementId = "StatementId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementId)
        statementId = statementIdDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension AddLayerVersionPermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddLayerVersionPermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyLengthExceededException" : self = .policyLengthExceededException(try PolicyLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddLayerVersionPermissionOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case policyLengthExceededException(PolicyLengthExceededException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddLayerVersionPermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddLayerVersionPermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.revisionId = output.revisionId
            self.statement = output.statement
        } else {
            self.revisionId = nil
            self.statement = nil
        }
    }
}

public struct AddLayerVersionPermissionOutputResponse: Swift.Equatable {
    /// A unique identifier for the current revision of the policy.
    public var revisionId: Swift.String?
    /// The permission statement.
    public var statement: Swift.String?

    public init (
        revisionId: Swift.String? = nil,
        statement: Swift.String? = nil
    )
    {
        self.revisionId = revisionId
        self.statement = statement
    }
}

struct AddLayerVersionPermissionOutputResponseBody: Swift.Equatable {
    let statement: Swift.String?
    let revisionId: Swift.String?
}

extension AddLayerVersionPermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case revisionId = "RevisionId"
        case statement = "Statement"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statement)
        statement = statementDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension AddPermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case eventSourceToken = "EventSourceToken"
        case principal = "Principal"
        case revisionId = "RevisionId"
        case sourceAccount = "SourceAccount"
        case sourceArn = "SourceArn"
        case statementId = "StatementId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let eventSourceToken = eventSourceToken {
            try encodeContainer.encode(eventSourceToken, forKey: .eventSourceToken)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let sourceAccount = sourceAccount {
            try encodeContainer.encode(sourceAccount, forKey: .sourceAccount)
        }
        if let sourceArn = sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let statementId = statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }
}

extension AddPermissionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let qualifier = qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension AddPermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/policy"
    }
}

public struct AddPermissionInput: Swift.Equatable {
    /// The action that the principal can use on the function. For example, lambda:InvokeFunction or lambda:GetFunction.
    /// This member is required.
    public var action: Swift.String?
    /// For Alexa Smart Home functions, a token that must be supplied by the invoker.
    public var eventSourceToken: Swift.String?
    /// The name of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The Amazon Web Services service or account that invokes the function. If you specify a service, use SourceArn or SourceAccount to limit who can invoke the function through that service.
    /// This member is required.
    public var principal: Swift.String?
    /// Specify a version or alias to add permissions to a published version of the function.
    public var qualifier: Swift.String?
    /// Only update the policy if the revision ID matches the ID that's specified. Use this option to avoid modifying a policy that has changed since you last read it.
    public var revisionId: Swift.String?
    /// For Amazon S3, the ID of the account that owns the resource. Use this together with SourceArn to ensure that the resource is owned by the specified account. It is possible for an Amazon S3 bucket to be deleted by its owner and recreated by another account.
    public var sourceAccount: Swift.String?
    /// For Amazon Web Services services, the ARN of the Amazon Web Services resource that invokes the function. For example, an Amazon S3 bucket or Amazon SNS topic. Note that Lambda configures the comparison using the StringLike operator.
    public var sourceArn: Swift.String?
    /// A statement identifier that differentiates the statement from others in the same policy.
    /// This member is required.
    public var statementId: Swift.String?

    public init (
        action: Swift.String? = nil,
        eventSourceToken: Swift.String? = nil,
        functionName: Swift.String? = nil,
        principal: Swift.String? = nil,
        qualifier: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        sourceAccount: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.action = action
        self.eventSourceToken = eventSourceToken
        self.functionName = functionName
        self.principal = principal
        self.qualifier = qualifier
        self.revisionId = revisionId
        self.sourceAccount = sourceAccount
        self.sourceArn = sourceArn
        self.statementId = statementId
    }
}

struct AddPermissionInputBody: Swift.Equatable {
    let statementId: Swift.String?
    let action: Swift.String?
    let principal: Swift.String?
    let sourceArn: Swift.String?
    let sourceAccount: Swift.String?
    let eventSourceToken: Swift.String?
    let revisionId: Swift.String?
}

extension AddPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case eventSourceToken = "EventSourceToken"
        case principal = "Principal"
        case revisionId = "RevisionId"
        case sourceAccount = "SourceAccount"
        case sourceArn = "SourceArn"
        case statementId = "StatementId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementId)
        statementId = statementIdDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let sourceAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceAccount)
        sourceAccount = sourceAccountDecoded
        let eventSourceTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceToken)
        eventSourceToken = eventSourceTokenDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension AddPermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddPermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyLengthExceededException" : self = .policyLengthExceededException(try PolicyLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddPermissionOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case policyLengthExceededException(PolicyLengthExceededException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddPermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddPermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.statement = output.statement
        } else {
            self.statement = nil
        }
    }
}

public struct AddPermissionOutputResponse: Swift.Equatable {
    /// The permission statement that's added to the function policy.
    public var statement: Swift.String?

    public init (
        statement: Swift.String? = nil
    )
    {
        self.statement = statement
    }
}

struct AddPermissionOutputResponseBody: Swift.Equatable {
    let statement: Swift.String?
}

extension AddPermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statement = "Statement"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statement)
        statement = statementDecoded
    }
}

extension LambdaClientTypes.AliasConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasArn = "AliasArn"
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasArn = aliasArn {
            try encodeContainer.encode(aliasArn, forKey: .aliasArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionVersion = functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let routingConfig = routingConfig {
            try encodeContainer.encode(routingConfig, forKey: .routingConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasArn)
        aliasArn = aliasArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension LambdaClientTypes {
    /// Provides configuration information about a Lambda function [alias](https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html).
    public struct AliasConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the alias.
        public var aliasArn: Swift.String?
        /// A description of the alias.
        public var description: Swift.String?
        /// The function version that the alias invokes.
        public var functionVersion: Swift.String?
        /// The name of the alias.
        public var name: Swift.String?
        /// A unique identifier that changes when you update the alias.
        public var revisionId: Swift.String?
        /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html) of the alias.
        public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

        public init (
            aliasArn: Swift.String? = nil,
            description: Swift.String? = nil,
            functionVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
        )
        {
            self.aliasArn = aliasArn
            self.description = description
            self.functionVersion = functionVersion
            self.name = name
            self.revisionId = revisionId
            self.routingConfig = routingConfig
        }
    }

}

extension LambdaClientTypes.AliasRoutingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalVersionWeights = "AdditionalVersionWeights"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalVersionWeights = additionalVersionWeights {
            var additionalVersionWeightsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalVersionWeights)
            for (dictKey0, additionalversionweights0) in additionalVersionWeights {
                try additionalVersionWeightsContainer.encode(additionalversionweights0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalVersionWeightsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Double?].self, forKey: .additionalVersionWeights)
        var additionalVersionWeightsDecoded0: [Swift.String:Swift.Double]? = nil
        if let additionalVersionWeightsContainer = additionalVersionWeightsContainer {
            additionalVersionWeightsDecoded0 = [Swift.String:Swift.Double]()
            for (key0, weight0) in additionalVersionWeightsContainer {
                if let weight0 = weight0 {
                    additionalVersionWeightsDecoded0?[key0] = weight0
                }
            }
        }
        additionalVersionWeights = additionalVersionWeightsDecoded0
    }
}

extension LambdaClientTypes {
    /// The [traffic-shifting](https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html) configuration of a Lambda function alias.
    public struct AliasRoutingConfiguration: Swift.Equatable {
        /// The second version, and the percentage of traffic that's routed to it.
        public var additionalVersionWeights: [Swift.String:Swift.Double]?

        public init (
            additionalVersionWeights: [Swift.String:Swift.Double]? = nil
        )
        {
            self.additionalVersionWeights = additionalVersionWeights
        }
    }

}

extension LambdaClientTypes.AllowedPublishers: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signingProfileVersionArns = "SigningProfileVersionArns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signingProfileVersionArns = signingProfileVersionArns {
            var signingProfileVersionArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .signingProfileVersionArns)
            for signingprofileversionarns0 in signingProfileVersionArns {
                try signingProfileVersionArnsContainer.encode(signingprofileversionarns0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingProfileVersionArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .signingProfileVersionArns)
        var signingProfileVersionArnsDecoded0:[Swift.String]? = nil
        if let signingProfileVersionArnsContainer = signingProfileVersionArnsContainer {
            signingProfileVersionArnsDecoded0 = [Swift.String]()
            for string0 in signingProfileVersionArnsContainer {
                if let string0 = string0 {
                    signingProfileVersionArnsDecoded0?.append(string0)
                }
            }
        }
        signingProfileVersionArns = signingProfileVersionArnsDecoded0
    }
}

extension LambdaClientTypes {
    /// List of signing profiles that can sign a code package.
    public struct AllowedPublishers: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for each of the signing profiles. A signing profile defines a trusted user who can sign a code package.
        /// This member is required.
        public var signingProfileVersionArns: [Swift.String]?

        public init (
            signingProfileVersionArns: [Swift.String]? = nil
        )
        {
            self.signingProfileVersionArns = signingProfileVersionArns
        }
    }

}

extension LambdaClientTypes {
    public enum Architecture: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arm64
        case x8664
        case sdkUnknown(Swift.String)

        public static var allCases: [Architecture] {
            return [
                .arm64,
                .x8664,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arm64: return "arm64"
            case .x8664: return "x86_64"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Architecture(rawValue: rawValue) ?? Architecture.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes.CodeSigningConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPublishers = "AllowedPublishers"
        case codeSigningConfigArn = "CodeSigningConfigArn"
        case codeSigningConfigId = "CodeSigningConfigId"
        case codeSigningPolicies = "CodeSigningPolicies"
        case description = "Description"
        case lastModified = "LastModified"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPublishers = allowedPublishers {
            try encodeContainer.encode(allowedPublishers, forKey: .allowedPublishers)
        }
        if let codeSigningConfigArn = codeSigningConfigArn {
            try encodeContainer.encode(codeSigningConfigArn, forKey: .codeSigningConfigArn)
        }
        if let codeSigningConfigId = codeSigningConfigId {
            try encodeContainer.encode(codeSigningConfigId, forKey: .codeSigningConfigId)
        }
        if let codeSigningPolicies = codeSigningPolicies {
            try encodeContainer.encode(codeSigningPolicies, forKey: .codeSigningPolicies)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified, forKey: .lastModified)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSigningConfigId)
        codeSigningConfigId = codeSigningConfigIdDecoded
        let codeSigningConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSigningConfigArn)
        codeSigningConfigArn = codeSigningConfigArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let allowedPublishersDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AllowedPublishers.self, forKey: .allowedPublishers)
        allowedPublishers = allowedPublishersDecoded
        let codeSigningPoliciesDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.CodeSigningPolicies.self, forKey: .codeSigningPolicies)
        codeSigningPolicies = codeSigningPoliciesDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension LambdaClientTypes {
    /// Details about a [Code signing configuration](https://docs.aws.amazon.com/lambda/latest/dg/configuration-codesigning.html).
    public struct CodeSigningConfig: Swift.Equatable {
        /// List of allowed publishers.
        /// This member is required.
        public var allowedPublishers: LambdaClientTypes.AllowedPublishers?
        /// The Amazon Resource Name (ARN) of the Code signing configuration.
        /// This member is required.
        public var codeSigningConfigArn: Swift.String?
        /// Unique identifer for the Code signing configuration.
        /// This member is required.
        public var codeSigningConfigId: Swift.String?
        /// The code signing policy controls the validation failure action for signature mismatch or expiry.
        /// This member is required.
        public var codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies?
        /// Code signing configuration description.
        public var description: Swift.String?
        /// The date and time that the Code signing configuration was last modified, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
        /// This member is required.
        public var lastModified: Swift.String?

        public init (
            allowedPublishers: LambdaClientTypes.AllowedPublishers? = nil,
            codeSigningConfigArn: Swift.String? = nil,
            codeSigningConfigId: Swift.String? = nil,
            codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies? = nil,
            description: Swift.String? = nil,
            lastModified: Swift.String? = nil
        )
        {
            self.allowedPublishers = allowedPublishers
            self.codeSigningConfigArn = codeSigningConfigArn
            self.codeSigningConfigId = codeSigningConfigId
            self.codeSigningPolicies = codeSigningPolicies
            self.description = description
            self.lastModified = lastModified
        }
    }

}

extension CodeSigningConfigNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CodeSigningConfigNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified code signing configuration does not exist.
public struct CodeSigningConfigNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct CodeSigningConfigNotFoundExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension CodeSigningConfigNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes.CodeSigningPolicies: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case untrustedArtifactOnDeployment = "UntrustedArtifactOnDeployment"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let untrustedArtifactOnDeployment = untrustedArtifactOnDeployment {
            try encodeContainer.encode(untrustedArtifactOnDeployment.rawValue, forKey: .untrustedArtifactOnDeployment)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let untrustedArtifactOnDeploymentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.CodeSigningPolicy.self, forKey: .untrustedArtifactOnDeployment)
        untrustedArtifactOnDeployment = untrustedArtifactOnDeploymentDecoded
    }
}

extension LambdaClientTypes {
    /// Code signing configuration [policies](https://docs.aws.amazon.com/lambda/latest/dg/configuration-codesigning.html#config-codesigning-policies) specify the validation failure action for signature mismatch or expiry.
    public struct CodeSigningPolicies: Swift.Equatable {
        /// Code signing configuration policy for deployment validation failure. If you set the policy to Enforce, Lambda blocks the deployment request if signature validation checks fail. If you set the policy to Warn, Lambda allows the deployment and creates a CloudWatch log. Default value: Warn
        public var untrustedArtifactOnDeployment: LambdaClientTypes.CodeSigningPolicy?

        public init (
            untrustedArtifactOnDeployment: LambdaClientTypes.CodeSigningPolicy? = nil
        )
        {
            self.untrustedArtifactOnDeployment = untrustedArtifactOnDeployment
        }
    }

}

extension LambdaClientTypes {
    public enum CodeSigningPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enforce
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [CodeSigningPolicy] {
            return [
                .enforce,
                .warn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enforce: return "Enforce"
            case .warn: return "Warn"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CodeSigningPolicy(rawValue: rawValue) ?? CodeSigningPolicy.sdkUnknown(rawValue)
        }
    }
}

extension CodeStorageExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CodeStorageExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded your maximum total code size per account. [Learn more](https://docs.aws.amazon.com/lambda/latest/dg/limits.html)
public struct CodeStorageExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The exception type.
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct CodeStorageExceededExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension CodeStorageExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeVerificationFailedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CodeVerificationFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The code signature failed one or more of the validation checks for signature mismatch or expiry, and the code signing policy is set to ENFORCE. Lambda blocks the deployment.
public struct CodeVerificationFailedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct CodeVerificationFailedExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension CodeVerificationFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes.Concurrency: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reservedConcurrentExecutions = reservedConcurrentExecutions {
            try encodeContainer.encode(reservedConcurrentExecutions, forKey: .reservedConcurrentExecutions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reservedConcurrentExecutions)
        reservedConcurrentExecutions = reservedConcurrentExecutionsDecoded
    }
}

extension LambdaClientTypes {
    public struct Concurrency: Swift.Equatable {
        /// The number of concurrent executions that are reserved for this function. For more information, see [Managing Concurrency](https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html).
        public var reservedConcurrentExecutions: Swift.Int?

        public init (
            reservedConcurrentExecutions: Swift.Int? = nil
        )
        {
            self.reservedConcurrentExecutions = reservedConcurrentExecutions
        }
    }

}

extension CreateAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case routingConfig = "RoutingConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionVersion = functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let routingConfig = routingConfig {
            try encodeContainer.encode(routingConfig, forKey: .routingConfig)
        }
    }
}

extension CreateAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases"
    }
}

public struct CreateAliasInput: Swift.Equatable {
    /// A description of the alias.
    public var description: Swift.String?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The function version that the alias invokes.
    /// This member is required.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?
    /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html#configuring-alias-routing) of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init (
        description: Swift.String? = nil,
        functionName: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    )
    {
        self.description = description
        self.functionName = functionName
        self.functionVersion = functionVersion
        self.name = name
        self.routingConfig = routingConfig
    }
}

struct CreateAliasInputBody: Swift.Equatable {
    let name: Swift.String?
    let functionVersion: Swift.String?
    let description: Swift.String?
    let routingConfig: LambdaClientTypes.AliasRoutingConfiguration?
}

extension CreateAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case routingConfig = "RoutingConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
    }
}

extension CreateAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAliasOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aliasArn = output.aliasArn
            self.description = output.description
            self.functionVersion = output.functionVersion
            self.name = output.name
            self.revisionId = output.revisionId
            self.routingConfig = output.routingConfig
        } else {
            self.aliasArn = nil
            self.description = nil
            self.functionVersion = nil
            self.name = nil
            self.revisionId = nil
            self.routingConfig = nil
        }
    }
}

/// Provides configuration information about a Lambda function [alias](https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html).
public struct CreateAliasOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the alias.
    public var aliasArn: Swift.String?
    /// A description of the alias.
    public var description: Swift.String?
    /// The function version that the alias invokes.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    public var name: Swift.String?
    /// A unique identifier that changes when you update the alias.
    public var revisionId: Swift.String?
    /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html) of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init (
        aliasArn: Swift.String? = nil,
        description: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    )
    {
        self.aliasArn = aliasArn
        self.description = description
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

struct CreateAliasOutputResponseBody: Swift.Equatable {
    let aliasArn: Swift.String?
    let name: Swift.String?
    let functionVersion: Swift.String?
    let description: Swift.String?
    let routingConfig: LambdaClientTypes.AliasRoutingConfiguration?
    let revisionId: Swift.String?
}

extension CreateAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasArn = "AliasArn"
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasArn)
        aliasArn = aliasArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension CreateCodeSigningConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPublishers = "AllowedPublishers"
        case codeSigningPolicies = "CodeSigningPolicies"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPublishers = allowedPublishers {
            try encodeContainer.encode(allowedPublishers, forKey: .allowedPublishers)
        }
        if let codeSigningPolicies = codeSigningPolicies {
            try encodeContainer.encode(codeSigningPolicies, forKey: .codeSigningPolicies)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension CreateCodeSigningConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-04-22/code-signing-configs"
    }
}

public struct CreateCodeSigningConfigInput: Swift.Equatable {
    /// Signing profiles for this code signing configuration.
    /// This member is required.
    public var allowedPublishers: LambdaClientTypes.AllowedPublishers?
    /// The code signing policies define the actions to take if the validation checks fail.
    public var codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies?
    /// Descriptive name for this code signing configuration.
    public var description: Swift.String?

    public init (
        allowedPublishers: LambdaClientTypes.AllowedPublishers? = nil,
        codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies? = nil,
        description: Swift.String? = nil
    )
    {
        self.allowedPublishers = allowedPublishers
        self.codeSigningPolicies = codeSigningPolicies
        self.description = description
    }
}

struct CreateCodeSigningConfigInputBody: Swift.Equatable {
    let description: Swift.String?
    let allowedPublishers: LambdaClientTypes.AllowedPublishers?
    let codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies?
}

extension CreateCodeSigningConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPublishers = "AllowedPublishers"
        case codeSigningPolicies = "CodeSigningPolicies"
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let allowedPublishersDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AllowedPublishers.self, forKey: .allowedPublishers)
        allowedPublishers = allowedPublishersDecoded
        let codeSigningPoliciesDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.CodeSigningPolicies.self, forKey: .codeSigningPolicies)
        codeSigningPolicies = codeSigningPoliciesDecoded
    }
}

extension CreateCodeSigningConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCodeSigningConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCodeSigningConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCodeSigningConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCodeSigningConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.codeSigningConfig = output.codeSigningConfig
        } else {
            self.codeSigningConfig = nil
        }
    }
}

public struct CreateCodeSigningConfigOutputResponse: Swift.Equatable {
    /// The code signing configuration.
    /// This member is required.
    public var codeSigningConfig: LambdaClientTypes.CodeSigningConfig?

    public init (
        codeSigningConfig: LambdaClientTypes.CodeSigningConfig? = nil
    )
    {
        self.codeSigningConfig = codeSigningConfig
    }
}

struct CreateCodeSigningConfigOutputResponseBody: Swift.Equatable {
    let codeSigningConfig: LambdaClientTypes.CodeSigningConfig?
}

extension CreateCodeSigningConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfig = "CodeSigningConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.CodeSigningConfig.self, forKey: .codeSigningConfig)
        codeSigningConfig = codeSigningConfigDecoded
    }
}

extension CreateEventSourceMappingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case enabled = "Enabled"
        case eventSourceArn = "EventSourceArn"
        case filterCriteria = "FilterCriteria"
        case functionName = "FunctionName"
        case functionResponseTypes = "FunctionResponseTypes"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case selfManagedEventSource = "SelfManagedEventSource"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchSize = batchSize {
            try encodeContainer.encode(batchSize, forKey: .batchSize)
        }
        if let bisectBatchOnFunctionError = bisectBatchOnFunctionError {
            try encodeContainer.encode(bisectBatchOnFunctionError, forKey: .bisectBatchOnFunctionError)
        }
        if let destinationConfig = destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let eventSourceArn = eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let filterCriteria = filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let functionName = functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let functionResponseTypes = functionResponseTypes {
            var functionResponseTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functionResponseTypes)
            for functionresponsetypelist0 in functionResponseTypes {
                try functionResponseTypesContainer.encode(functionresponsetypelist0.rawValue)
            }
        }
        if let maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds {
            try encodeContainer.encode(maximumBatchingWindowInSeconds, forKey: .maximumBatchingWindowInSeconds)
        }
        if let maximumRecordAgeInSeconds = maximumRecordAgeInSeconds {
            try encodeContainer.encode(maximumRecordAgeInSeconds, forKey: .maximumRecordAgeInSeconds)
        }
        if let maximumRetryAttempts = maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
        if let parallelizationFactor = parallelizationFactor {
            try encodeContainer.encode(parallelizationFactor, forKey: .parallelizationFactor)
        }
        if let queues = queues {
            var queuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queues)
            for queues0 in queues {
                try queuesContainer.encode(queues0)
            }
        }
        if let selfManagedEventSource = selfManagedEventSource {
            try encodeContainer.encode(selfManagedEventSource, forKey: .selfManagedEventSource)
        }
        if let sourceAccessConfigurations = sourceAccessConfigurations {
            var sourceAccessConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceAccessConfigurations)
            for sourceaccessconfigurations0 in sourceAccessConfigurations {
                try sourceAccessConfigurationsContainer.encode(sourceaccessconfigurations0)
            }
        }
        if let startingPosition = startingPosition {
            try encodeContainer.encode(startingPosition.rawValue, forKey: .startingPosition)
        }
        if let startingPositionTimestamp = startingPositionTimestamp {
            try encodeContainer.encode(startingPositionTimestamp.timeIntervalSince1970, forKey: .startingPositionTimestamp)
        }
        if let topics = topics {
            var topicsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topics)
            for topics0 in topics {
                try topicsContainer.encode(topics0)
            }
        }
        if let tumblingWindowInSeconds = tumblingWindowInSeconds {
            try encodeContainer.encode(tumblingWindowInSeconds, forKey: .tumblingWindowInSeconds)
        }
    }
}

extension CreateEventSourceMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2015-03-31/event-source-mappings"
    }
}

public struct CreateEventSourceMappingInput: Swift.Equatable {
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB).
    ///
    /// * Amazon Kinesis - Default 100. Max 10,000.
    ///
    /// * Amazon DynamoDB Streams - Default 100. Max 1,000.
    ///
    /// * Amazon Simple Queue Service - Default 10. For standard queues the max is 10,000. For FIFO queues the max is 10.
    ///
    /// * Amazon Managed Streaming for Apache Kafka - Default 100. Max 10,000.
    ///
    /// * Self-Managed Apache Kafka - Default 100. Max 10,000.
    ///
    /// * Amazon MQ (ActiveMQ and RabbitMQ) - Default 100. Max 10,000.
    public var batchSize: Swift.Int?
    /// (Streams only) If the function returns an error, split the batch in two and retry.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// When true, the event source mapping is active. When false, Lambda pauses polling and invocation. Default: True
    public var enabled: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the event source.
    ///
    /// * Amazon Kinesis - The ARN of the data stream or a stream consumer.
    ///
    /// * Amazon DynamoDB Streams - The ARN of the stream.
    ///
    /// * Amazon Simple Queue Service - The ARN of the queue.
    ///
    /// * Amazon Managed Streaming for Apache Kafka - The ARN of the cluster.
    public var eventSourceArn: Swift.String?
    /// (Streams and Amazon SQS) An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html).
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Version or Alias ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// (Streams and Amazon SQS) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// (Streams and Amazon SQS standard queues) The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. Default: 0 Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Streams only) Discard records older than the specified age. The default value is infinite (-1).
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Streams only) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records will be retried until the record expires.
    public var maximumRetryAttempts: Swift.Int?
    /// (Streams only) The number of batches to process from each shard concurrently.
    public var parallelizationFactor: Swift.Int?
    /// (MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// The Self-Managed Apache Kafka cluster to send records.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// An array of authentication protocols or VPC components required to secure your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK Streams sources. AT_TIMESTAMP is only supported for Amazon Kinesis streams.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading.
    public var startingPositionTimestamp: ClientRuntime.Date?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Streams only) The duration in seconds of a processing window. The range is between 1 second up to 900 seconds.
    public var tumblingWindowInSeconds: Swift.Int?

    public init (
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        enabled: Swift.Bool? = nil,
        eventSourceArn: Swift.String? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        functionName: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        queues: [Swift.String]? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: ClientRuntime.Date? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil
    )
    {
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.enabled = enabled
        self.eventSourceArn = eventSourceArn
        self.filterCriteria = filterCriteria
        self.functionName = functionName
        self.functionResponseTypes = functionResponseTypes
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.selfManagedEventSource = selfManagedEventSource
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
    }
}

struct CreateEventSourceMappingInputBody: Swift.Equatable {
    let eventSourceArn: Swift.String?
    let functionName: Swift.String?
    let enabled: Swift.Bool?
    let batchSize: Swift.Int?
    let filterCriteria: LambdaClientTypes.FilterCriteria?
    let maximumBatchingWindowInSeconds: Swift.Int?
    let parallelizationFactor: Swift.Int?
    let startingPosition: LambdaClientTypes.EventSourcePosition?
    let startingPositionTimestamp: ClientRuntime.Date?
    let destinationConfig: LambdaClientTypes.DestinationConfig?
    let maximumRecordAgeInSeconds: Swift.Int?
    let bisectBatchOnFunctionError: Swift.Bool?
    let maximumRetryAttempts: Swift.Int?
    let tumblingWindowInSeconds: Swift.Int?
    let topics: [Swift.String]?
    let queues: [Swift.String]?
    let sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    let selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    let functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
}

extension CreateEventSourceMappingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case enabled = "Enabled"
        case eventSourceArn = "EventSourceArn"
        case filterCriteria = "FilterCriteria"
        case functionName = "FunctionName"
        case functionResponseTypes = "FunctionResponseTypes"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case selfManagedEventSource = "SelfManagedEventSource"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let topicsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .topics)
        var topicsDecoded0:[Swift.String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [Swift.String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queues)
        var queuesDecoded0:[Swift.String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [Swift.String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[LambdaClientTypes.SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [LambdaClientTypes.SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[LambdaClientTypes.FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [LambdaClientTypes.FunctionResponseType]()
            for string0 in functionResponseTypesContainer {
                if let string0 = string0 {
                    functionResponseTypesDecoded0?.append(string0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
    }
}

extension CreateEventSourceMappingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEventSourceMappingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEventSourceMappingOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEventSourceMappingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEventSourceMappingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchSize = output.batchSize
            self.bisectBatchOnFunctionError = output.bisectBatchOnFunctionError
            self.destinationConfig = output.destinationConfig
            self.eventSourceArn = output.eventSourceArn
            self.filterCriteria = output.filterCriteria
            self.functionArn = output.functionArn
            self.functionResponseTypes = output.functionResponseTypes
            self.lastModified = output.lastModified
            self.lastProcessingResult = output.lastProcessingResult
            self.maximumBatchingWindowInSeconds = output.maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = output.maximumRecordAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
            self.parallelizationFactor = output.parallelizationFactor
            self.queues = output.queues
            self.selfManagedEventSource = output.selfManagedEventSource
            self.sourceAccessConfigurations = output.sourceAccessConfigurations
            self.startingPosition = output.startingPosition
            self.startingPositionTimestamp = output.startingPositionTimestamp
            self.state = output.state
            self.stateTransitionReason = output.stateTransitionReason
            self.topics = output.topics
            self.tumblingWindowInSeconds = output.tumblingWindowInSeconds
            self.uUID = output.uUID
        } else {
            self.batchSize = nil
            self.bisectBatchOnFunctionError = nil
            self.destinationConfig = nil
            self.eventSourceArn = nil
            self.filterCriteria = nil
            self.functionArn = nil
            self.functionResponseTypes = nil
            self.lastModified = nil
            self.lastProcessingResult = nil
            self.maximumBatchingWindowInSeconds = nil
            self.maximumRecordAgeInSeconds = nil
            self.maximumRetryAttempts = nil
            self.parallelizationFactor = nil
            self.queues = nil
            self.selfManagedEventSource = nil
            self.sourceAccessConfigurations = nil
            self.startingPosition = nil
            self.startingPositionTimestamp = nil
            self.state = nil
            self.stateTransitionReason = nil
            self.topics = nil
            self.tumblingWindowInSeconds = nil
            self.uUID = nil
        }
    }
}

/// A mapping between an Amazon Web Services resource and a Lambda function. For details, see [CreateEventSourceMapping].
public struct CreateEventSourceMappingOutputResponse: Swift.Equatable {
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB). Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100. Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var batchSize: Swift.Int?
    /// (Streams only) If the function returns an error, split the batch in two and retry. The default value is false.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The Amazon Resource Name (ARN) of the event source.
    public var eventSourceArn: Swift.String?
    /// (Streams and Amazon SQS) An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html).
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// The ARN of the Lambda function.
    public var functionArn: Swift.String?
    /// (Streams only) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The date that the event source mapping was last updated or that its state changed.
    public var lastModified: ClientRuntime.Date?
    /// The result of the last Lambda invocation of your function.
    public var lastProcessingResult: Swift.String?
    /// (Streams and Amazon SQS standard queues) The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. Default: 0 Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Streams only) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records.
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Streams only) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
    public var maximumRetryAttempts: Swift.Int?
    /// (Streams only) The number of batches to process concurrently from each shard. The default value is 1.
    public var parallelizationFactor: Swift.Int?
    /// (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// The self-managed Apache Kafka cluster for your event source.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK stream sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading.
    public var startingPositionTimestamp: ClientRuntime.Date?
    /// The state of the event source mapping. It can be one of the following: Creating, Enabling, Enabled, Disabling, Disabled, Updating, or Deleting.
    public var state: Swift.String?
    /// Indicates whether a user or Lambda made the last change to the event source mapping.
    public var stateTransitionReason: Swift.String?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Streams only) The duration in seconds of a processing window. The range is 1900 seconds.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    public var uUID: Swift.String?

    public init (
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        eventSourceArn: Swift.String? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        functionArn: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        lastModified: ClientRuntime.Date? = nil,
        lastProcessingResult: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        queues: [Swift.String]? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: ClientRuntime.Date? = nil,
        state: Swift.String? = nil,
        stateTransitionReason: Swift.String? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uUID: Swift.String? = nil
    )
    {
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.eventSourceArn = eventSourceArn
        self.filterCriteria = filterCriteria
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.selfManagedEventSource = selfManagedEventSource
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uUID = uUID
    }
}

struct CreateEventSourceMappingOutputResponseBody: Swift.Equatable {
    let uUID: Swift.String?
    let startingPosition: LambdaClientTypes.EventSourcePosition?
    let startingPositionTimestamp: ClientRuntime.Date?
    let batchSize: Swift.Int?
    let maximumBatchingWindowInSeconds: Swift.Int?
    let parallelizationFactor: Swift.Int?
    let eventSourceArn: Swift.String?
    let filterCriteria: LambdaClientTypes.FilterCriteria?
    let functionArn: Swift.String?
    let lastModified: ClientRuntime.Date?
    let lastProcessingResult: Swift.String?
    let state: Swift.String?
    let stateTransitionReason: Swift.String?
    let destinationConfig: LambdaClientTypes.DestinationConfig?
    let topics: [Swift.String]?
    let queues: [Swift.String]?
    let sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    let selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    let maximumRecordAgeInSeconds: Swift.Int?
    let bisectBatchOnFunctionError: Swift.Bool?
    let maximumRetryAttempts: Swift.Int?
    let tumblingWindowInSeconds: Swift.Int?
    let functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
}

extension CreateEventSourceMappingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case eventSourceArn = "EventSourceArn"
        case filterCriteria = "FilterCriteria"
        case functionArn = "FunctionArn"
        case functionResponseTypes = "FunctionResponseTypes"
        case lastModified = "LastModified"
        case lastProcessingResult = "LastProcessingResult"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case selfManagedEventSource = "SelfManagedEventSource"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case state = "State"
        case stateTransitionReason = "StateTransitionReason"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        case uUID = "UUID"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uUIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uUID)
        uUID = uUIDDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lastProcessingResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastProcessingResult)
        lastProcessingResult = lastProcessingResultDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let stateTransitionReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateTransitionReason)
        stateTransitionReason = stateTransitionReasonDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let topicsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .topics)
        var topicsDecoded0:[Swift.String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [Swift.String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queues)
        var queuesDecoded0:[Swift.String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [Swift.String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[LambdaClientTypes.SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [LambdaClientTypes.SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[LambdaClientTypes.FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [LambdaClientTypes.FunctionResponseType]()
            for string0 in functionResponseTypesContainer {
                if let string0 = string0 {
                    functionResponseTypesDecoded0?.append(string0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
    }
}

extension CreateFunctionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case code = "Code"
        case codeSigningConfigArn = "CodeSigningConfigArn"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfig = "ImageConfig"
        case kMSKeyArn = "KMSKeyArn"
        case layers = "Layers"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case publish = "Publish"
        case role = "Role"
        case runtime = "Runtime"
        case tags = "Tags"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architectures = architectures {
            var architecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .architectures)
            for architectureslist0 in architectures {
                try architecturesContainer.encode(architectureslist0.rawValue)
            }
        }
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let codeSigningConfigArn = codeSigningConfigArn {
            try encodeContainer.encode(codeSigningConfigArn, forKey: .codeSigningConfigArn)
        }
        if let deadLetterConfig = deadLetterConfig {
            try encodeContainer.encode(deadLetterConfig, forKey: .deadLetterConfig)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environment = environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let fileSystemConfigs = fileSystemConfigs {
            var fileSystemConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemConfigs)
            for filesystemconfiglist0 in fileSystemConfigs {
                try fileSystemConfigsContainer.encode(filesystemconfiglist0)
            }
        }
        if let functionName = functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let handler = handler {
            try encodeContainer.encode(handler, forKey: .handler)
        }
        if let imageConfig = imageConfig {
            try encodeContainer.encode(imageConfig, forKey: .imageConfig)
        }
        if let kMSKeyArn = kMSKeyArn {
            try encodeContainer.encode(kMSKeyArn, forKey: .kMSKeyArn)
        }
        if let layers = layers {
            var layersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layers)
            for layerlist0 in layers {
                try layersContainer.encode(layerlist0)
            }
        }
        if let memorySize = memorySize {
            try encodeContainer.encode(memorySize, forKey: .memorySize)
        }
        if let packageType = packageType {
            try encodeContainer.encode(packageType.rawValue, forKey: .packageType)
        }
        if publish != false {
            try encodeContainer.encode(publish, forKey: .publish)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let runtime = runtime {
            try encodeContainer.encode(runtime.rawValue, forKey: .runtime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let tracingConfig = tracingConfig {
            try encodeContainer.encode(tracingConfig, forKey: .tracingConfig)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

extension CreateFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2015-03-31/functions"
    }
}

public struct CreateFunctionInput: Swift.Equatable {
    /// The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64). The default value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The code for the function.
    /// This member is required.
    public var code: LambdaClientTypes.FunctionCode?
    /// To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration includes a set of signing profiles, which define the trusted publishers for this function.
    public var codeSigningConfigArn: Swift.String?
    /// A dead letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see [Dead Letter Queues](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq).
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// A description of the function.
    public var description: Swift.String?
    /// Environment variables that are accessible from function code during execution.
    public var environment: LambdaClientTypes.Environment?
    /// Connection settings for an Amazon EFS file system.
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - my-function.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The name of the method within your code that Lambda calls to execute your function. Handler is required if the deployment package is a .zip file archive. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see [Programming Model](https://docs.aws.amazon.com/lambda/latest/dg/programming-model-v2.html).
    public var handler: Swift.String?
    /// Container image [configuration values](https://docs.aws.amazon.com/lambda/latest/dg/configuration-images.html#configuration-images-settings) that override the values in the container image Dockerfile.
    public var imageConfig: LambdaClientTypes.ImageConfig?
    /// The ARN of the Amazon Web Services Key Management Service (KMS) key that's used to encrypt your function's environment variables. If it's not provided, Lambda uses a default service key.
    public var kMSKeyArn: Swift.String?
    /// A list of [function layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) to add to the function's execution environment. Specify each layer by its ARN, including the version.
    public var layers: [Swift.String]?
    /// The amount of [memory available to the function](https://docs.aws.amazon.com/lambda/latest/dg/configuration-memory.html) at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for ZIP archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// Set to true to publish the first version of the function during creation.
    public var publish: Swift.Bool
    /// The Amazon Resource Name (ARN) of the function's execution role.
    /// This member is required.
    public var role: Swift.String?
    /// The identifier of the function's [runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive.
    public var runtime: LambdaClientTypes.Runtime?
    /// A list of [tags](https://docs.aws.amazon.com/lambda/latest/dg/tagging.html) to apply to the function.
    public var tags: [Swift.String:Swift.String]?
    /// The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For additional information, see [Lambda execution environment](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html).
    public var timeout: Swift.Int?
    /// Set Mode to Active to sample and trace a subset of incoming requests with [X-Ray](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html).
    public var tracingConfig: LambdaClientTypes.TracingConfig?
    /// For network connectivity to Amazon Web Services resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can only access resources and the internet through that VPC. For more information, see [VPC Settings](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
    public var vpcConfig: LambdaClientTypes.VpcConfig?

    public init (
        architectures: [LambdaClientTypes.Architecture]? = nil,
        code: LambdaClientTypes.FunctionCode? = nil,
        codeSigningConfigArn: Swift.String? = nil,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.Environment? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfig: LambdaClientTypes.ImageConfig? = nil,
        kMSKeyArn: Swift.String? = nil,
        layers: [Swift.String]? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        publish: Swift.Bool = false,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfig? = nil,
        vpcConfig: LambdaClientTypes.VpcConfig? = nil
    )
    {
        self.architectures = architectures
        self.code = code
        self.codeSigningConfigArn = codeSigningConfigArn
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.fileSystemConfigs = fileSystemConfigs
        self.functionName = functionName
        self.handler = handler
        self.imageConfig = imageConfig
        self.kMSKeyArn = kMSKeyArn
        self.layers = layers
        self.memorySize = memorySize
        self.packageType = packageType
        self.publish = publish
        self.role = role
        self.runtime = runtime
        self.tags = tags
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.vpcConfig = vpcConfig
    }
}

struct CreateFunctionInputBody: Swift.Equatable {
    let functionName: Swift.String?
    let runtime: LambdaClientTypes.Runtime?
    let role: Swift.String?
    let handler: Swift.String?
    let code: LambdaClientTypes.FunctionCode?
    let description: Swift.String?
    let timeout: Swift.Int?
    let memorySize: Swift.Int?
    let publish: Swift.Bool
    let vpcConfig: LambdaClientTypes.VpcConfig?
    let packageType: LambdaClientTypes.PackageType?
    let deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    let environment: LambdaClientTypes.Environment?
    let kMSKeyArn: Swift.String?
    let tracingConfig: LambdaClientTypes.TracingConfig?
    let tags: [Swift.String:Swift.String]?
    let layers: [Swift.String]?
    let fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    let imageConfig: LambdaClientTypes.ImageConfig?
    let codeSigningConfigArn: Swift.String?
    let architectures: [LambdaClientTypes.Architecture]?
}

extension CreateFunctionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case code = "Code"
        case codeSigningConfigArn = "CodeSigningConfigArn"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfig = "ImageConfig"
        case kMSKeyArn = "KMSKeyArn"
        case layers = "Layers"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case publish = "Publish"
        case role = "Role"
        case runtime = "Runtime"
        case tags = "Tags"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let codeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FunctionCode.self, forKey: .code)
        code = codeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let publishDecoded = try containerValues.decode(Swift.Bool.self, forKey: .publish)
        publish = publishDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let packageTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfig.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let layersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layers)
        var layersDecoded0:[Swift.String]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [Swift.String]()
            for string0 in layersContainer {
                if let string0 = string0 {
                    layersDecoded0?.append(string0)
                }
            }
        }
        layers = layersDecoded0
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let imageConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfig.self, forKey: .imageConfig)
        imageConfig = imageConfigDecoded
        let codeSigningConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSigningConfigArn)
        codeSigningConfigArn = codeSigningConfigArnDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
    }
}

extension CreateFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CodeSigningConfigNotFoundException" : self = .codeSigningConfigNotFoundException(try CodeSigningConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CodeStorageExceededException" : self = .codeStorageExceededException(try CodeStorageExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CodeVerificationFailedException" : self = .codeVerificationFailedException(try CodeVerificationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCodeSignatureException" : self = .invalidCodeSignatureException(try InvalidCodeSignatureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFunctionOutputError: Swift.Error, Swift.Equatable {
    case codeSigningConfigNotFoundException(CodeSigningConfigNotFoundException)
    case codeStorageExceededException(CodeStorageExceededException)
    case codeVerificationFailedException(CodeVerificationFailedException)
    case invalidCodeSignatureException(InvalidCodeSignatureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFunctionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.architectures = output.architectures
            self.codeSha256 = output.codeSha256
            self.codeSize = output.codeSize
            self.deadLetterConfig = output.deadLetterConfig
            self.description = output.description
            self.environment = output.environment
            self.fileSystemConfigs = output.fileSystemConfigs
            self.functionArn = output.functionArn
            self.functionName = output.functionName
            self.handler = output.handler
            self.imageConfigResponse = output.imageConfigResponse
            self.kMSKeyArn = output.kMSKeyArn
            self.lastModified = output.lastModified
            self.lastUpdateStatus = output.lastUpdateStatus
            self.lastUpdateStatusReason = output.lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = output.lastUpdateStatusReasonCode
            self.layers = output.layers
            self.masterArn = output.masterArn
            self.memorySize = output.memorySize
            self.packageType = output.packageType
            self.revisionId = output.revisionId
            self.role = output.role
            self.runtime = output.runtime
            self.signingJobArn = output.signingJobArn
            self.signingProfileVersionArn = output.signingProfileVersionArn
            self.state = output.state
            self.stateReason = output.stateReason
            self.stateReasonCode = output.stateReasonCode
            self.timeout = output.timeout
            self.tracingConfig = output.tracingConfig
            self.version = output.version
            self.vpcConfig = output.vpcConfig
        } else {
            self.architectures = nil
            self.codeSha256 = nil
            self.codeSize = 0
            self.deadLetterConfig = nil
            self.description = nil
            self.environment = nil
            self.fileSystemConfigs = nil
            self.functionArn = nil
            self.functionName = nil
            self.handler = nil
            self.imageConfigResponse = nil
            self.kMSKeyArn = nil
            self.lastModified = nil
            self.lastUpdateStatus = nil
            self.lastUpdateStatusReason = nil
            self.lastUpdateStatusReasonCode = nil
            self.layers = nil
            self.masterArn = nil
            self.memorySize = nil
            self.packageType = nil
            self.revisionId = nil
            self.role = nil
            self.runtime = nil
            self.signingJobArn = nil
            self.signingProfileVersionArn = nil
            self.state = nil
            self.stateReason = nil
            self.stateReasonCode = nil
            self.timeout = nil
            self.tracingConfig = nil
            self.version = nil
            self.vpcConfig = nil
        }
    }
}

/// Details about a function's configuration.
public struct CreateFunctionOutputResponse: Swift.Equatable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html).
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin executing your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've configured a customer managed key.
    public var kMSKeyArn: Swift.String?
    /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's [ layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public var layers: [LambdaClientTypes.Layer]?
    /// For Lambda@Edge functions, the ARN of the main function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The runtime environment for the Lambda function.
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init (
        architectures: [LambdaClientTypes.Architecture]? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kMSKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    )
    {
        self.architectures = architectures
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kMSKeyArn = kMSKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

struct CreateFunctionOutputResponseBody: Swift.Equatable {
    let functionName: Swift.String?
    let functionArn: Swift.String?
    let runtime: LambdaClientTypes.Runtime?
    let role: Swift.String?
    let handler: Swift.String?
    let codeSize: Swift.Int
    let description: Swift.String?
    let timeout: Swift.Int?
    let memorySize: Swift.Int?
    let lastModified: Swift.String?
    let codeSha256: Swift.String?
    let version: Swift.String?
    let vpcConfig: LambdaClientTypes.VpcConfigResponse?
    let deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    let environment: LambdaClientTypes.EnvironmentResponse?
    let kMSKeyArn: Swift.String?
    let tracingConfig: LambdaClientTypes.TracingConfigResponse?
    let masterArn: Swift.String?
    let revisionId: Swift.String?
    let layers: [LambdaClientTypes.Layer]?
    let state: LambdaClientTypes.State?
    let stateReason: Swift.String?
    let stateReasonCode: LambdaClientTypes.StateReasonCode?
    let lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    let lastUpdateStatusReason: Swift.String?
    let lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    let fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    let packageType: LambdaClientTypes.PackageType?
    let imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    let signingProfileVersionArn: Swift.String?
    let signingJobArn: Swift.String?
    let architectures: [LambdaClientTypes.Architecture]?
}

extension CreateFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kMSKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[LambdaClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [LambdaClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
    }
}

extension LambdaClientTypes.DeadLetterConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetArn = "TargetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetArn = targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
    }
}

extension LambdaClientTypes {
    /// The [dead-letter queue](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq) for failed asynchronous invocations.
    public struct DeadLetterConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
        public var targetArn: Swift.String?

        public init (
            targetArn: Swift.String? = nil
        )
        {
            self.targetArn = targetArn
        }
    }

}

extension DeleteAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases/\(name.urlPercentEncoding())"
    }
}

public struct DeleteAliasInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.name = name
    }
}

struct DeleteAliasInputBody: Swift.Equatable {
}

extension DeleteAliasInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAliasOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAliasOutputResponse: Swift.Equatable {

}

extension DeleteCodeSigningConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let codeSigningConfigArn = codeSigningConfigArn else {
            return nil
        }
        return "/2020-04-22/code-signing-configs/\(codeSigningConfigArn.urlPercentEncoding())"
    }
}

public struct DeleteCodeSigningConfigInput: Swift.Equatable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?

    public init (
        codeSigningConfigArn: Swift.String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
    }
}

struct DeleteCodeSigningConfigInputBody: Swift.Equatable {
}

extension DeleteCodeSigningConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCodeSigningConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCodeSigningConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCodeSigningConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCodeSigningConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCodeSigningConfigOutputResponse: Swift.Equatable {

}

extension DeleteEventSourceMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let uUID = uUID else {
            return nil
        }
        return "/2015-03-31/event-source-mappings/\(uUID.urlPercentEncoding())"
    }
}

public struct DeleteEventSourceMappingInput: Swift.Equatable {
    /// The identifier of the event source mapping.
    /// This member is required.
    public var uUID: Swift.String?

    public init (
        uUID: Swift.String? = nil
    )
    {
        self.uUID = uUID
    }
}

struct DeleteEventSourceMappingInputBody: Swift.Equatable {
}

extension DeleteEventSourceMappingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEventSourceMappingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEventSourceMappingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventSourceMappingOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventSourceMappingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteEventSourceMappingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchSize = output.batchSize
            self.bisectBatchOnFunctionError = output.bisectBatchOnFunctionError
            self.destinationConfig = output.destinationConfig
            self.eventSourceArn = output.eventSourceArn
            self.filterCriteria = output.filterCriteria
            self.functionArn = output.functionArn
            self.functionResponseTypes = output.functionResponseTypes
            self.lastModified = output.lastModified
            self.lastProcessingResult = output.lastProcessingResult
            self.maximumBatchingWindowInSeconds = output.maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = output.maximumRecordAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
            self.parallelizationFactor = output.parallelizationFactor
            self.queues = output.queues
            self.selfManagedEventSource = output.selfManagedEventSource
            self.sourceAccessConfigurations = output.sourceAccessConfigurations
            self.startingPosition = output.startingPosition
            self.startingPositionTimestamp = output.startingPositionTimestamp
            self.state = output.state
            self.stateTransitionReason = output.stateTransitionReason
            self.topics = output.topics
            self.tumblingWindowInSeconds = output.tumblingWindowInSeconds
            self.uUID = output.uUID
        } else {
            self.batchSize = nil
            self.bisectBatchOnFunctionError = nil
            self.destinationConfig = nil
            self.eventSourceArn = nil
            self.filterCriteria = nil
            self.functionArn = nil
            self.functionResponseTypes = nil
            self.lastModified = nil
            self.lastProcessingResult = nil
            self.maximumBatchingWindowInSeconds = nil
            self.maximumRecordAgeInSeconds = nil
            self.maximumRetryAttempts = nil
            self.parallelizationFactor = nil
            self.queues = nil
            self.selfManagedEventSource = nil
            self.sourceAccessConfigurations = nil
            self.startingPosition = nil
            self.startingPositionTimestamp = nil
            self.state = nil
            self.stateTransitionReason = nil
            self.topics = nil
            self.tumblingWindowInSeconds = nil
            self.uUID = nil
        }
    }
}

/// A mapping between an Amazon Web Services resource and a Lambda function. For details, see [CreateEventSourceMapping].
public struct DeleteEventSourceMappingOutputResponse: Swift.Equatable {
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB). Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100. Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var batchSize: Swift.Int?
    /// (Streams only) If the function returns an error, split the batch in two and retry. The default value is false.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The Amazon Resource Name (ARN) of the event source.
    public var eventSourceArn: Swift.String?
    /// (Streams and Amazon SQS) An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html).
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// The ARN of the Lambda function.
    public var functionArn: Swift.String?
    /// (Streams only) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The date that the event source mapping was last updated or that its state changed.
    public var lastModified: ClientRuntime.Date?
    /// The result of the last Lambda invocation of your function.
    public var lastProcessingResult: Swift.String?
    /// (Streams and Amazon SQS standard queues) The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. Default: 0 Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Streams only) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records.
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Streams only) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
    public var maximumRetryAttempts: Swift.Int?
    /// (Streams only) The number of batches to process concurrently from each shard. The default value is 1.
    public var parallelizationFactor: Swift.Int?
    /// (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// The self-managed Apache Kafka cluster for your event source.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK stream sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading.
    public var startingPositionTimestamp: ClientRuntime.Date?
    /// The state of the event source mapping. It can be one of the following: Creating, Enabling, Enabled, Disabling, Disabled, Updating, or Deleting.
    public var state: Swift.String?
    /// Indicates whether a user or Lambda made the last change to the event source mapping.
    public var stateTransitionReason: Swift.String?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Streams only) The duration in seconds of a processing window. The range is 1900 seconds.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    public var uUID: Swift.String?

    public init (
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        eventSourceArn: Swift.String? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        functionArn: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        lastModified: ClientRuntime.Date? = nil,
        lastProcessingResult: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        queues: [Swift.String]? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: ClientRuntime.Date? = nil,
        state: Swift.String? = nil,
        stateTransitionReason: Swift.String? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uUID: Swift.String? = nil
    )
    {
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.eventSourceArn = eventSourceArn
        self.filterCriteria = filterCriteria
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.selfManagedEventSource = selfManagedEventSource
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uUID = uUID
    }
}

struct DeleteEventSourceMappingOutputResponseBody: Swift.Equatable {
    let uUID: Swift.String?
    let startingPosition: LambdaClientTypes.EventSourcePosition?
    let startingPositionTimestamp: ClientRuntime.Date?
    let batchSize: Swift.Int?
    let maximumBatchingWindowInSeconds: Swift.Int?
    let parallelizationFactor: Swift.Int?
    let eventSourceArn: Swift.String?
    let filterCriteria: LambdaClientTypes.FilterCriteria?
    let functionArn: Swift.String?
    let lastModified: ClientRuntime.Date?
    let lastProcessingResult: Swift.String?
    let state: Swift.String?
    let stateTransitionReason: Swift.String?
    let destinationConfig: LambdaClientTypes.DestinationConfig?
    let topics: [Swift.String]?
    let queues: [Swift.String]?
    let sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    let selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    let maximumRecordAgeInSeconds: Swift.Int?
    let bisectBatchOnFunctionError: Swift.Bool?
    let maximumRetryAttempts: Swift.Int?
    let tumblingWindowInSeconds: Swift.Int?
    let functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
}

extension DeleteEventSourceMappingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case eventSourceArn = "EventSourceArn"
        case filterCriteria = "FilterCriteria"
        case functionArn = "FunctionArn"
        case functionResponseTypes = "FunctionResponseTypes"
        case lastModified = "LastModified"
        case lastProcessingResult = "LastProcessingResult"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case selfManagedEventSource = "SelfManagedEventSource"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case state = "State"
        case stateTransitionReason = "StateTransitionReason"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        case uUID = "UUID"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uUIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uUID)
        uUID = uUIDDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lastProcessingResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastProcessingResult)
        lastProcessingResult = lastProcessingResultDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let stateTransitionReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateTransitionReason)
        stateTransitionReason = stateTransitionReasonDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let topicsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .topics)
        var topicsDecoded0:[Swift.String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [Swift.String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queues)
        var queuesDecoded0:[Swift.String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [Swift.String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[LambdaClientTypes.SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [LambdaClientTypes.SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[LambdaClientTypes.FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [LambdaClientTypes.FunctionResponseType]()
            for string0 in functionResponseTypesContainer {
                if let string0 = string0 {
                    functionResponseTypesDecoded0?.append(string0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
    }
}

extension DeleteFunctionCodeSigningConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2020-06-30/functions/\(functionName.urlPercentEncoding())/code-signing-config"
    }
}

public struct DeleteFunctionCodeSigningConfigInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init (
        functionName: Swift.String? = nil
    )
    {
        self.functionName = functionName
    }
}

struct DeleteFunctionCodeSigningConfigInputBody: Swift.Equatable {
}

extension DeleteFunctionCodeSigningConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionCodeSigningConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFunctionCodeSigningConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CodeSigningConfigNotFoundException" : self = .codeSigningConfigNotFoundException(try CodeSigningConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFunctionCodeSigningConfigOutputError: Swift.Error, Swift.Equatable {
    case codeSigningConfigNotFoundException(CodeSigningConfigNotFoundException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFunctionCodeSigningConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFunctionCodeSigningConfigOutputResponse: Swift.Equatable {

}

extension DeleteFunctionConcurrencyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2017-10-31/functions/\(functionName.urlPercentEncoding())/concurrency"
    }
}

public struct DeleteFunctionConcurrencyInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - my-function.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init (
        functionName: Swift.String? = nil
    )
    {
        self.functionName = functionName
    }
}

struct DeleteFunctionConcurrencyInputBody: Swift.Equatable {
}

extension DeleteFunctionConcurrencyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionConcurrencyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFunctionConcurrencyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFunctionConcurrencyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFunctionConcurrencyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFunctionConcurrencyOutputResponse: Swift.Equatable {

}

extension DeleteFunctionEventInvokeConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let qualifier = qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension DeleteFunctionEventInvokeConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config"
    }
}

public struct DeleteFunctionEventInvokeConfigInput: Swift.Equatable {
    /// The name of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// A version number or alias name.
    public var qualifier: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct DeleteFunctionEventInvokeConfigInputBody: Swift.Equatable {
}

extension DeleteFunctionEventInvokeConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionEventInvokeConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFunctionEventInvokeConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFunctionEventInvokeConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFunctionEventInvokeConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFunctionEventInvokeConfigOutputResponse: Swift.Equatable {

}

extension DeleteFunctionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let qualifier = qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension DeleteFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())"
    }
}

public struct DeleteFunctionInput: Swift.Equatable {
    /// The name of the Lambda function or version. Name formats
    ///
    /// * Function name - my-function (name-only), my-function:1 (with version).
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version to delete. You can't delete a version that's referenced by an alias.
    public var qualifier: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct DeleteFunctionInputBody: Swift.Equatable {
}

extension DeleteFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFunctionOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFunctionOutputResponse: Swift.Equatable {

}

extension DeleteLayerVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let layerName = layerName else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)"
    }
}

public struct DeleteLayerVersionInput: Swift.Equatable {
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int

    public init (
        layerName: Swift.String? = nil,
        versionNumber: Swift.Int = 0
    )
    {
        self.layerName = layerName
        self.versionNumber = versionNumber
    }
}

struct DeleteLayerVersionInputBody: Swift.Equatable {
}

extension DeleteLayerVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLayerVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLayerVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLayerVersionOutputError: Swift.Error, Swift.Equatable {
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLayerVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLayerVersionOutputResponse: Swift.Equatable {

}

extension DeleteProvisionedConcurrencyConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let qualifier = qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension DeleteProvisionedConcurrencyConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2019-09-30/functions/\(functionName.urlPercentEncoding())/provisioned-concurrency"
    }
}

public struct DeleteProvisionedConcurrencyConfigInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - my-function.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The version number or alias name.
    /// This member is required.
    public var qualifier: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct DeleteProvisionedConcurrencyConfigInputBody: Swift.Equatable {
}

extension DeleteProvisionedConcurrencyConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProvisionedConcurrencyConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProvisionedConcurrencyConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProvisionedConcurrencyConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProvisionedConcurrencyConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProvisionedConcurrencyConfigOutputResponse: Swift.Equatable {

}

extension LambdaClientTypes.DestinationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case onFailure = "OnFailure"
        case onSuccess = "OnSuccess"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let onFailure = onFailure {
            try encodeContainer.encode(onFailure, forKey: .onFailure)
        }
        if let onSuccess = onSuccess {
            try encodeContainer.encode(onSuccess, forKey: .onSuccess)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let onSuccessDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.OnSuccess.self, forKey: .onSuccess)
        onSuccess = onSuccessDecoded
        let onFailureDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.OnFailure.self, forKey: .onFailure)
        onFailure = onFailureDecoded
    }
}

extension LambdaClientTypes {
    /// A configuration object that specifies the destination of an event after Lambda processes it.
    public struct DestinationConfig: Swift.Equatable {
        /// The destination configuration for failed invocations.
        public var onFailure: LambdaClientTypes.OnFailure?
        /// The destination configuration for successful invocations.
        public var onSuccess: LambdaClientTypes.OnSuccess?

        public init (
            onFailure: LambdaClientTypes.OnFailure? = nil,
            onSuccess: LambdaClientTypes.OnSuccess? = nil
        )
        {
            self.onFailure = onFailure
            self.onSuccess = onSuccess
        }
    }

}

extension EC2AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EC2AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Need additional permissions to configure VPC settings.
public struct EC2AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct EC2AccessDeniedExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension EC2AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EC2ThrottledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EC2ThrottledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Lambda was throttled by Amazon EC2 during Lambda function initialization using the execution role provided for the Lambda function.
public struct EC2ThrottledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct EC2ThrottledExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension EC2ThrottledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EC2UnexpectedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EC2UnexpectedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.eC2ErrorCode = output.eC2ErrorCode
            self.message = output.message
            self.type = output.type
        } else {
            self.eC2ErrorCode = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Lambda received an unexpected EC2 client exception while setting up for the Lambda function.
public struct EC2UnexpectedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var eC2ErrorCode: Swift.String?
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        eC2ErrorCode: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.eC2ErrorCode = eC2ErrorCode
        self.message = message
        self.type = type
    }
}

struct EC2UnexpectedExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
    let eC2ErrorCode: Swift.String?
}

extension EC2UnexpectedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eC2ErrorCode = "EC2ErrorCode"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let eC2ErrorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eC2ErrorCode)
        eC2ErrorCode = eC2ErrorCodeDecoded
    }
}

extension EFSIOException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EFSIOExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error occurred when reading from or writing to a connected file system.
public struct EFSIOException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct EFSIOExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension EFSIOExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EFSMountConnectivityException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EFSMountConnectivityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The function couldn't make a network connection to the configured file system.
public struct EFSMountConnectivityException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct EFSMountConnectivityExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension EFSMountConnectivityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EFSMountFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EFSMountFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The function couldn't mount the configured file system due to a permission or configuration issue.
public struct EFSMountFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct EFSMountFailureExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension EFSMountFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EFSMountTimeoutException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EFSMountTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The function was able to make a network connection to the configured file system, but the mount operation timed out.
public struct EFSMountTimeoutException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct EFSMountTimeoutExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension EFSMountTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ENILimitReachedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ENILimitReachedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Lambda was not able to create an elastic network interface in the VPC, specified as part of Lambda function configuration, because the limit for network interfaces has been reached.
public struct ENILimitReachedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct ENILimitReachedExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension ENILimitReachedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes {
    public enum EndPointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kafkaBootstrapServers
        case sdkUnknown(Swift.String)

        public static var allCases: [EndPointType] {
            return [
                .kafkaBootstrapServers,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kafkaBootstrapServers: return "KAFKA_BOOTSTRAP_SERVERS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndPointType(rawValue: rawValue) ?? EndPointType.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes.Environment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case variables = "Variables"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .variables)
            for (dictKey0, environmentvariables0) in variables {
                try variablesContainer.encode(environmentvariables0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:Swift.String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, environmentvariablevalue0) in variablesContainer {
                if let environmentvariablevalue0 = environmentvariablevalue0 {
                    variablesDecoded0?[key0] = environmentvariablevalue0
                }
            }
        }
        variables = variablesDecoded0
    }
}

extension LambdaClientTypes {
    /// A function's environment variable settings. You can use environment variables to adjust your function's behavior without updating code. An environment variable is a pair of strings that are stored in a function's version-specific configuration.
    public struct Environment: Swift.Equatable {
        /// Environment variable key-value pairs. For more information, see [Using Lambda environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html).
        public var variables: [Swift.String:Swift.String]?

        public init (
            variables: [Swift.String:Swift.String]? = nil
        )
        {
            self.variables = variables
        }
    }

}

extension LambdaClientTypes.EnvironmentError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes {
    /// Error messages for environment variables that couldn't be applied.
    public struct EnvironmentError: Swift.Equatable {
        /// The error code.
        public var errorCode: Swift.String?
        /// The error message.
        public var message: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.message = message
        }
    }

}

extension LambdaClientTypes.EnvironmentResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "Error"
        case variables = "Variables"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .variables)
            for (dictKey0, environmentvariables0) in variables {
                try variablesContainer.encode(environmentvariables0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:Swift.String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, environmentvariablevalue0) in variablesContainer {
                if let environmentvariablevalue0 = environmentvariablevalue0 {
                    variablesDecoded0?[key0] = environmentvariablevalue0
                }
            }
        }
        variables = variablesDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EnvironmentError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LambdaClientTypes {
    /// The results of an operation to update or read environment variables. If the operation is successful, the response contains the environment variables. If it failed, the response contains details about the error.
    public struct EnvironmentResponse: Swift.Equatable {
        /// Error messages for environment variables that couldn't be applied.
        public var error: LambdaClientTypes.EnvironmentError?
        /// Environment variable key-value pairs.
        public var variables: [Swift.String:Swift.String]?

        public init (
            error: LambdaClientTypes.EnvironmentError? = nil,
            variables: [Swift.String:Swift.String]? = nil
        )
        {
            self.error = error
            self.variables = variables
        }
    }

}

extension LambdaClientTypes.EventSourceMappingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case eventSourceArn = "EventSourceArn"
        case filterCriteria = "FilterCriteria"
        case functionArn = "FunctionArn"
        case functionResponseTypes = "FunctionResponseTypes"
        case lastModified = "LastModified"
        case lastProcessingResult = "LastProcessingResult"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case selfManagedEventSource = "SelfManagedEventSource"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case state = "State"
        case stateTransitionReason = "StateTransitionReason"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        case uUID = "UUID"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchSize = batchSize {
            try encodeContainer.encode(batchSize, forKey: .batchSize)
        }
        if let bisectBatchOnFunctionError = bisectBatchOnFunctionError {
            try encodeContainer.encode(bisectBatchOnFunctionError, forKey: .bisectBatchOnFunctionError)
        }
        if let destinationConfig = destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let eventSourceArn = eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let filterCriteria = filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let functionArn = functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let functionResponseTypes = functionResponseTypes {
            var functionResponseTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functionResponseTypes)
            for functionresponsetypelist0 in functionResponseTypes {
                try functionResponseTypesContainer.encode(functionresponsetypelist0.rawValue)
            }
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified.timeIntervalSince1970, forKey: .lastModified)
        }
        if let lastProcessingResult = lastProcessingResult {
            try encodeContainer.encode(lastProcessingResult, forKey: .lastProcessingResult)
        }
        if let maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds {
            try encodeContainer.encode(maximumBatchingWindowInSeconds, forKey: .maximumBatchingWindowInSeconds)
        }
        if let maximumRecordAgeInSeconds = maximumRecordAgeInSeconds {
            try encodeContainer.encode(maximumRecordAgeInSeconds, forKey: .maximumRecordAgeInSeconds)
        }
        if let maximumRetryAttempts = maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
        if let parallelizationFactor = parallelizationFactor {
            try encodeContainer.encode(parallelizationFactor, forKey: .parallelizationFactor)
        }
        if let queues = queues {
            var queuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queues)
            for queues0 in queues {
                try queuesContainer.encode(queues0)
            }
        }
        if let selfManagedEventSource = selfManagedEventSource {
            try encodeContainer.encode(selfManagedEventSource, forKey: .selfManagedEventSource)
        }
        if let sourceAccessConfigurations = sourceAccessConfigurations {
            var sourceAccessConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceAccessConfigurations)
            for sourceaccessconfigurations0 in sourceAccessConfigurations {
                try sourceAccessConfigurationsContainer.encode(sourceaccessconfigurations0)
            }
        }
        if let startingPosition = startingPosition {
            try encodeContainer.encode(startingPosition.rawValue, forKey: .startingPosition)
        }
        if let startingPositionTimestamp = startingPositionTimestamp {
            try encodeContainer.encode(startingPositionTimestamp.timeIntervalSince1970, forKey: .startingPositionTimestamp)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let stateTransitionReason = stateTransitionReason {
            try encodeContainer.encode(stateTransitionReason, forKey: .stateTransitionReason)
        }
        if let topics = topics {
            var topicsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topics)
            for topics0 in topics {
                try topicsContainer.encode(topics0)
            }
        }
        if let tumblingWindowInSeconds = tumblingWindowInSeconds {
            try encodeContainer.encode(tumblingWindowInSeconds, forKey: .tumblingWindowInSeconds)
        }
        if let uUID = uUID {
            try encodeContainer.encode(uUID, forKey: .uUID)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uUIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uUID)
        uUID = uUIDDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lastProcessingResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastProcessingResult)
        lastProcessingResult = lastProcessingResultDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let stateTransitionReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateTransitionReason)
        stateTransitionReason = stateTransitionReasonDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let topicsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .topics)
        var topicsDecoded0:[Swift.String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [Swift.String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queues)
        var queuesDecoded0:[Swift.String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [Swift.String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[LambdaClientTypes.SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [LambdaClientTypes.SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[LambdaClientTypes.FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [LambdaClientTypes.FunctionResponseType]()
            for string0 in functionResponseTypesContainer {
                if let string0 = string0 {
                    functionResponseTypesDecoded0?.append(string0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
    }
}

extension LambdaClientTypes {
    /// A mapping between an Amazon Web Services resource and a Lambda function. For details, see [CreateEventSourceMapping].
    public struct EventSourceMappingConfiguration: Swift.Equatable {
        /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB). Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100. Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
        public var batchSize: Swift.Int?
        /// (Streams only) If the function returns an error, split the batch in two and retry. The default value is false.
        public var bisectBatchOnFunctionError: Swift.Bool?
        /// (Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
        public var destinationConfig: LambdaClientTypes.DestinationConfig?
        /// The Amazon Resource Name (ARN) of the event source.
        public var eventSourceArn: Swift.String?
        /// (Streams and Amazon SQS) An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html).
        public var filterCriteria: LambdaClientTypes.FilterCriteria?
        /// The ARN of the Lambda function.
        public var functionArn: Swift.String?
        /// (Streams only) A list of current response type enums applied to the event source mapping.
        public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
        /// The date that the event source mapping was last updated or that its state changed.
        public var lastModified: ClientRuntime.Date?
        /// The result of the last Lambda invocation of your function.
        public var lastProcessingResult: Swift.String?
        /// (Streams and Amazon SQS standard queues) The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. Default: 0 Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
        public var maximumBatchingWindowInSeconds: Swift.Int?
        /// (Streams only) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records.
        public var maximumRecordAgeInSeconds: Swift.Int?
        /// (Streams only) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
        public var maximumRetryAttempts: Swift.Int?
        /// (Streams only) The number of batches to process concurrently from each shard. The default value is 1.
        public var parallelizationFactor: Swift.Int?
        /// (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
        public var queues: [Swift.String]?
        /// The self-managed Apache Kafka cluster for your event source.
        public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
        /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
        public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
        /// The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK stream sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams.
        public var startingPosition: LambdaClientTypes.EventSourcePosition?
        /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading.
        public var startingPositionTimestamp: ClientRuntime.Date?
        /// The state of the event source mapping. It can be one of the following: Creating, Enabling, Enabled, Disabling, Disabled, Updating, or Deleting.
        public var state: Swift.String?
        /// Indicates whether a user or Lambda made the last change to the event source mapping.
        public var stateTransitionReason: Swift.String?
        /// The name of the Kafka topic.
        public var topics: [Swift.String]?
        /// (Streams only) The duration in seconds of a processing window. The range is 1900 seconds.
        public var tumblingWindowInSeconds: Swift.Int?
        /// The identifier of the event source mapping.
        public var uUID: Swift.String?

        public init (
            batchSize: Swift.Int? = nil,
            bisectBatchOnFunctionError: Swift.Bool? = nil,
            destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
            eventSourceArn: Swift.String? = nil,
            filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
            functionArn: Swift.String? = nil,
            functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
            lastModified: ClientRuntime.Date? = nil,
            lastProcessingResult: Swift.String? = nil,
            maximumBatchingWindowInSeconds: Swift.Int? = nil,
            maximumRecordAgeInSeconds: Swift.Int? = nil,
            maximumRetryAttempts: Swift.Int? = nil,
            parallelizationFactor: Swift.Int? = nil,
            queues: [Swift.String]? = nil,
            selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
            sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
            startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
            startingPositionTimestamp: ClientRuntime.Date? = nil,
            state: Swift.String? = nil,
            stateTransitionReason: Swift.String? = nil,
            topics: [Swift.String]? = nil,
            tumblingWindowInSeconds: Swift.Int? = nil,
            uUID: Swift.String? = nil
        )
        {
            self.batchSize = batchSize
            self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
            self.destinationConfig = destinationConfig
            self.eventSourceArn = eventSourceArn
            self.filterCriteria = filterCriteria
            self.functionArn = functionArn
            self.functionResponseTypes = functionResponseTypes
            self.lastModified = lastModified
            self.lastProcessingResult = lastProcessingResult
            self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
            self.parallelizationFactor = parallelizationFactor
            self.queues = queues
            self.selfManagedEventSource = selfManagedEventSource
            self.sourceAccessConfigurations = sourceAccessConfigurations
            self.startingPosition = startingPosition
            self.startingPositionTimestamp = startingPositionTimestamp
            self.state = state
            self.stateTransitionReason = stateTransitionReason
            self.topics = topics
            self.tumblingWindowInSeconds = tumblingWindowInSeconds
            self.uUID = uUID
        }
    }

}

extension LambdaClientTypes {
    public enum EventSourcePosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case atTimestamp
        case latest
        case trimHorizon
        case sdkUnknown(Swift.String)

        public static var allCases: [EventSourcePosition] {
            return [
                .atTimestamp,
                .latest,
                .trimHorizon,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .atTimestamp: return "AT_TIMESTAMP"
            case .latest: return "LATEST"
            case .trimHorizon: return "TRIM_HORIZON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventSourcePosition(rawValue: rawValue) ?? EventSourcePosition.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes.FileSystemConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case localMountPath = "LocalMountPath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let localMountPath = localMountPath {
            try encodeContainer.encode(localMountPath, forKey: .localMountPath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let localMountPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localMountPath)
        localMountPath = localMountPathDecoded
    }
}

extension LambdaClientTypes {
    /// Details about the connection between a Lambda function and an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public struct FileSystemConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
        /// This member is required.
        public var arn: Swift.String?
        /// The path where the function can access the file system, starting with /mnt/.
        /// This member is required.
        public var localMountPath: Swift.String?

        public init (
            arn: Swift.String? = nil,
            localMountPath: Swift.String? = nil
        )
        {
            self.arn = arn
            self.localMountPath = localMountPath
        }
    }

}

extension LambdaClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pattern = "Pattern"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pattern = pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pattern)
        pattern = patternDecoded
    }
}

extension LambdaClientTypes {
    /// A structure within a FilterCriteria object that defines an event filtering pattern.
    public struct Filter: Swift.Equatable {
        /// A filter pattern. For more information on the syntax of a filter pattern, see [ Filter rule syntax](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax).
        public var pattern: Swift.String?

        public init (
            pattern: Swift.String? = nil
        )
        {
            self.pattern = pattern
        }
    }

}

extension LambdaClientTypes.FilterCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LambdaClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LambdaClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension LambdaClientTypes {
    /// An object that contains the filters for an event source.
    public struct FilterCriteria: Swift.Equatable {
        /// A list of filters.
        public var filters: [LambdaClientTypes.Filter]?

        public init (
            filters: [LambdaClientTypes.Filter]? = nil
        )
        {
            self.filters = filters
        }
    }

}

extension LambdaClientTypes.FunctionCode: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageUri = "ImageUri"
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
        case s3ObjectVersion = "S3ObjectVersion"
        case zipFile = "ZipFile"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageUri = imageUri {
            try encodeContainer.encode(imageUri, forKey: .imageUri)
        }
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
        if let s3ObjectVersion = s3ObjectVersion {
            try encodeContainer.encode(s3ObjectVersion, forKey: .s3ObjectVersion)
        }
        if let zipFile = zipFile {
            try encodeContainer.encode(zipFile.base64EncodedString(), forKey: .zipFile)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zipFileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .zipFile)
        zipFile = zipFileDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let s3ObjectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ObjectVersion)
        s3ObjectVersion = s3ObjectVersionDecoded
        let imageUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageUri)
        imageUri = imageUriDecoded
    }
}

extension LambdaClientTypes {
    /// The code for the Lambda function. You can specify either an object in Amazon S3, upload a .zip file archive deployment package directly, or specify the URI of a container image.
    public struct FunctionCode: Swift.Equatable {
        /// URI of a [container image](https://docs.aws.amazon.com/lambda/latest/dg/lambda-images.html) in the Amazon ECR registry.
        public var imageUri: Swift.String?
        /// An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.
        public var s3Bucket: Swift.String?
        /// The Amazon S3 key of the deployment package.
        public var s3Key: Swift.String?
        /// For versioned objects, the version of the deployment package object to use.
        public var s3ObjectVersion: Swift.String?
        /// The base64-encoded contents of the deployment package. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for you.
        public var zipFile: ClientRuntime.Data?

        public init (
            imageUri: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil,
            s3ObjectVersion: Swift.String? = nil,
            zipFile: ClientRuntime.Data? = nil
        )
        {
            self.imageUri = imageUri
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
            self.zipFile = zipFile
        }
    }

}

extension LambdaClientTypes.FunctionCodeLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageUri = "ImageUri"
        case location = "Location"
        case repositoryType = "RepositoryType"
        case resolvedImageUri = "ResolvedImageUri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageUri = imageUri {
            try encodeContainer.encode(imageUri, forKey: .imageUri)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let repositoryType = repositoryType {
            try encodeContainer.encode(repositoryType, forKey: .repositoryType)
        }
        if let resolvedImageUri = resolvedImageUri {
            try encodeContainer.encode(resolvedImageUri, forKey: .resolvedImageUri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryType)
        repositoryType = repositoryTypeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let imageUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageUri)
        imageUri = imageUriDecoded
        let resolvedImageUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolvedImageUri)
        resolvedImageUri = resolvedImageUriDecoded
    }
}

extension LambdaClientTypes {
    /// Details about a function's deployment package.
    public struct FunctionCodeLocation: Swift.Equatable {
        /// URI of a container image in the Amazon ECR registry.
        public var imageUri: Swift.String?
        /// A presigned URL that you can use to download the deployment package.
        public var location: Swift.String?
        /// The service that's hosting the file.
        public var repositoryType: Swift.String?
        /// The resolved URI for the image.
        public var resolvedImageUri: Swift.String?

        public init (
            imageUri: Swift.String? = nil,
            location: Swift.String? = nil,
            repositoryType: Swift.String? = nil,
            resolvedImageUri: Swift.String? = nil
        )
        {
            self.imageUri = imageUri
            self.location = location
            self.repositoryType = repositoryType
            self.resolvedImageUri = resolvedImageUri
        }
    }

}

extension LambdaClientTypes.FunctionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kMSKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architectures = architectures {
            var architecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .architectures)
            for architectureslist0 in architectures {
                try architecturesContainer.encode(architectureslist0.rawValue)
            }
        }
        if let codeSha256 = codeSha256 {
            try encodeContainer.encode(codeSha256, forKey: .codeSha256)
        }
        if codeSize != 0 {
            try encodeContainer.encode(codeSize, forKey: .codeSize)
        }
        if let deadLetterConfig = deadLetterConfig {
            try encodeContainer.encode(deadLetterConfig, forKey: .deadLetterConfig)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environment = environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let fileSystemConfigs = fileSystemConfigs {
            var fileSystemConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemConfigs)
            for filesystemconfiglist0 in fileSystemConfigs {
                try fileSystemConfigsContainer.encode(filesystemconfiglist0)
            }
        }
        if let functionArn = functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let functionName = functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let handler = handler {
            try encodeContainer.encode(handler, forKey: .handler)
        }
        if let imageConfigResponse = imageConfigResponse {
            try encodeContainer.encode(imageConfigResponse, forKey: .imageConfigResponse)
        }
        if let kMSKeyArn = kMSKeyArn {
            try encodeContainer.encode(kMSKeyArn, forKey: .kMSKeyArn)
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified, forKey: .lastModified)
        }
        if let lastUpdateStatus = lastUpdateStatus {
            try encodeContainer.encode(lastUpdateStatus.rawValue, forKey: .lastUpdateStatus)
        }
        if let lastUpdateStatusReason = lastUpdateStatusReason {
            try encodeContainer.encode(lastUpdateStatusReason, forKey: .lastUpdateStatusReason)
        }
        if let lastUpdateStatusReasonCode = lastUpdateStatusReasonCode {
            try encodeContainer.encode(lastUpdateStatusReasonCode.rawValue, forKey: .lastUpdateStatusReasonCode)
        }
        if let layers = layers {
            var layersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layers)
            for layersreferencelist0 in layers {
                try layersContainer.encode(layersreferencelist0)
            }
        }
        if let masterArn = masterArn {
            try encodeContainer.encode(masterArn, forKey: .masterArn)
        }
        if let memorySize = memorySize {
            try encodeContainer.encode(memorySize, forKey: .memorySize)
        }
        if let packageType = packageType {
            try encodeContainer.encode(packageType.rawValue, forKey: .packageType)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let runtime = runtime {
            try encodeContainer.encode(runtime.rawValue, forKey: .runtime)
        }
        if let signingJobArn = signingJobArn {
            try encodeContainer.encode(signingJobArn, forKey: .signingJobArn)
        }
        if let signingProfileVersionArn = signingProfileVersionArn {
            try encodeContainer.encode(signingProfileVersionArn, forKey: .signingProfileVersionArn)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
        if let stateReasonCode = stateReasonCode {
            try encodeContainer.encode(stateReasonCode.rawValue, forKey: .stateReasonCode)
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let tracingConfig = tracingConfig {
            try encodeContainer.encode(tracingConfig, forKey: .tracingConfig)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[LambdaClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [LambdaClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
    }
}

extension LambdaClientTypes {
    /// Details about a function's configuration.
    public struct FunctionConfiguration: Swift.Equatable {
        /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
        public var architectures: [LambdaClientTypes.Architecture]?
        /// The SHA256 hash of the function's deployment package.
        public var codeSha256: Swift.String?
        /// The size of the function's deployment package, in bytes.
        public var codeSize: Swift.Int
        /// The function's dead letter queue.
        public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
        /// The function's description.
        public var description: Swift.String?
        /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html).
        public var environment: LambdaClientTypes.EnvironmentResponse?
        /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
        public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
        /// The function's Amazon Resource Name (ARN).
        public var functionArn: Swift.String?
        /// The name of the function.
        public var functionName: Swift.String?
        /// The function that Lambda calls to begin executing your function.
        public var handler: Swift.String?
        /// The function's image configuration values.
        public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
        /// The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've configured a customer managed key.
        public var kMSKeyArn: Swift.String?
        /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
        public var lastModified: Swift.String?
        /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
        public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
        /// The reason for the last update that was performed on the function.
        public var lastUpdateStatusReason: Swift.String?
        /// The reason code for the last update that was performed on the function.
        public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
        /// The function's [ layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
        public var layers: [LambdaClientTypes.Layer]?
        /// For Lambda@Edge functions, the ARN of the main function.
        public var masterArn: Swift.String?
        /// The amount of memory available to the function at runtime.
        public var memorySize: Swift.Int?
        /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
        public var packageType: LambdaClientTypes.PackageType?
        /// The latest updated revision of the function or alias.
        public var revisionId: Swift.String?
        /// The function's execution role.
        public var role: Swift.String?
        /// The runtime environment for the Lambda function.
        public var runtime: LambdaClientTypes.Runtime?
        /// The ARN of the signing job.
        public var signingJobArn: Swift.String?
        /// The ARN of the signing profile version.
        public var signingProfileVersionArn: Swift.String?
        /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
        public var state: LambdaClientTypes.State?
        /// The reason for the function's current state.
        public var stateReason: Swift.String?
        /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
        public var stateReasonCode: LambdaClientTypes.StateReasonCode?
        /// The amount of time in seconds that Lambda allows a function to run before stopping it.
        public var timeout: Swift.Int?
        /// The function's X-Ray tracing configuration.
        public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
        /// The version of the Lambda function.
        public var version: Swift.String?
        /// The function's networking configuration.
        public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

        public init (
            architectures: [LambdaClientTypes.Architecture]? = nil,
            codeSha256: Swift.String? = nil,
            codeSize: Swift.Int = 0,
            deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
            description: Swift.String? = nil,
            environment: LambdaClientTypes.EnvironmentResponse? = nil,
            fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
            functionArn: Swift.String? = nil,
            functionName: Swift.String? = nil,
            handler: Swift.String? = nil,
            imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
            kMSKeyArn: Swift.String? = nil,
            lastModified: Swift.String? = nil,
            lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
            lastUpdateStatusReason: Swift.String? = nil,
            lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
            layers: [LambdaClientTypes.Layer]? = nil,
            masterArn: Swift.String? = nil,
            memorySize: Swift.Int? = nil,
            packageType: LambdaClientTypes.PackageType? = nil,
            revisionId: Swift.String? = nil,
            role: Swift.String? = nil,
            runtime: LambdaClientTypes.Runtime? = nil,
            signingJobArn: Swift.String? = nil,
            signingProfileVersionArn: Swift.String? = nil,
            state: LambdaClientTypes.State? = nil,
            stateReason: Swift.String? = nil,
            stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
            timeout: Swift.Int? = nil,
            tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
            version: Swift.String? = nil,
            vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
        )
        {
            self.architectures = architectures
            self.codeSha256 = codeSha256
            self.codeSize = codeSize
            self.deadLetterConfig = deadLetterConfig
            self.description = description
            self.environment = environment
            self.fileSystemConfigs = fileSystemConfigs
            self.functionArn = functionArn
            self.functionName = functionName
            self.handler = handler
            self.imageConfigResponse = imageConfigResponse
            self.kMSKeyArn = kMSKeyArn
            self.lastModified = lastModified
            self.lastUpdateStatus = lastUpdateStatus
            self.lastUpdateStatusReason = lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
            self.layers = layers
            self.masterArn = masterArn
            self.memorySize = memorySize
            self.packageType = packageType
            self.revisionId = revisionId
            self.role = role
            self.runtime = runtime
            self.signingJobArn = signingJobArn
            self.signingProfileVersionArn = signingProfileVersionArn
            self.state = state
            self.stateReason = stateReason
            self.stateReasonCode = stateReasonCode
            self.timeout = timeout
            self.tracingConfig = tracingConfig
            self.version = version
            self.vpcConfig = vpcConfig
        }
    }

}

extension LambdaClientTypes.FunctionEventInvokeConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case functionArn = "FunctionArn"
        case lastModified = "LastModified"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfig = destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let functionArn = functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified.timeIntervalSince1970, forKey: .lastModified)
        }
        if let maximumEventAgeInSeconds = maximumEventAgeInSeconds {
            try encodeContainer.encode(maximumEventAgeInSeconds, forKey: .maximumEventAgeInSeconds)
        }
        if let maximumRetryAttempts = maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

extension LambdaClientTypes {
    public struct FunctionEventInvokeConfig: Swift.Equatable {
        /// A destination for events after they have been sent to a function for processing. Destinations
        ///
        /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
        ///
        /// * Queue - The ARN of an SQS queue.
        ///
        /// * Topic - The ARN of an SNS topic.
        ///
        /// * Event Bus - The ARN of an Amazon EventBridge event bus.
        public var destinationConfig: LambdaClientTypes.DestinationConfig?
        /// The Amazon Resource Name (ARN) of the function.
        public var functionArn: Swift.String?
        /// The date and time that the configuration was last updated.
        public var lastModified: ClientRuntime.Date?
        /// The maximum age of a request that Lambda sends to a function for processing.
        public var maximumEventAgeInSeconds: Swift.Int?
        /// The maximum number of times to retry when the function returns an error.
        public var maximumRetryAttempts: Swift.Int?

        public init (
            destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
            functionArn: Swift.String? = nil,
            lastModified: ClientRuntime.Date? = nil,
            maximumEventAgeInSeconds: Swift.Int? = nil,
            maximumRetryAttempts: Swift.Int? = nil
        )
        {
            self.destinationConfig = destinationConfig
            self.functionArn = functionArn
            self.lastModified = lastModified
            self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
        }
    }

}

extension LambdaClientTypes {
    public enum FunctionResponseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case reportbatchitemfailures
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionResponseType] {
            return [
                .reportbatchitemfailures,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .reportbatchitemfailures: return "ReportBatchItemFailures"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FunctionResponseType(rawValue: rawValue) ?? FunctionResponseType.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes {
    public enum FunctionVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionVersion] {
            return [
                .all,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FunctionVersion(rawValue: rawValue) ?? FunctionVersion.sdkUnknown(rawValue)
        }
    }
}

extension GetAccountSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2016-08-19/account-settings"
    }
}

public struct GetAccountSettingsInput: Swift.Equatable {

}

struct GetAccountSettingsInputBody: Swift.Equatable {
}

extension GetAccountSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccountSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccountSettingsOutputError: Swift.Error, Swift.Equatable {
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAccountSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountLimit = output.accountLimit
            self.accountUsage = output.accountUsage
        } else {
            self.accountLimit = nil
            self.accountUsage = nil
        }
    }
}

public struct GetAccountSettingsOutputResponse: Swift.Equatable {
    /// Limits that are related to concurrency and code storage.
    public var accountLimit: LambdaClientTypes.AccountLimit?
    /// The number of functions and amount of storage in use.
    public var accountUsage: LambdaClientTypes.AccountUsage?

    public init (
        accountLimit: LambdaClientTypes.AccountLimit? = nil,
        accountUsage: LambdaClientTypes.AccountUsage? = nil
    )
    {
        self.accountLimit = accountLimit
        self.accountUsage = accountUsage
    }
}

struct GetAccountSettingsOutputResponseBody: Swift.Equatable {
    let accountLimit: LambdaClientTypes.AccountLimit?
    let accountUsage: LambdaClientTypes.AccountUsage?
}

extension GetAccountSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountLimit = "AccountLimit"
        case accountUsage = "AccountUsage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountLimitDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AccountLimit.self, forKey: .accountLimit)
        accountLimit = accountLimitDecoded
        let accountUsageDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AccountUsage.self, forKey: .accountUsage)
        accountUsage = accountUsageDecoded
    }
}

extension GetAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases/\(name.urlPercentEncoding())"
    }
}

public struct GetAliasInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.name = name
    }
}

struct GetAliasInputBody: Swift.Equatable {
}

extension GetAliasInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAliasOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aliasArn = output.aliasArn
            self.description = output.description
            self.functionVersion = output.functionVersion
            self.name = output.name
            self.revisionId = output.revisionId
            self.routingConfig = output.routingConfig
        } else {
            self.aliasArn = nil
            self.description = nil
            self.functionVersion = nil
            self.name = nil
            self.revisionId = nil
            self.routingConfig = nil
        }
    }
}

/// Provides configuration information about a Lambda function [alias](https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html).
public struct GetAliasOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the alias.
    public var aliasArn: Swift.String?
    /// A description of the alias.
    public var description: Swift.String?
    /// The function version that the alias invokes.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    public var name: Swift.String?
    /// A unique identifier that changes when you update the alias.
    public var revisionId: Swift.String?
    /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html) of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init (
        aliasArn: Swift.String? = nil,
        description: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    )
    {
        self.aliasArn = aliasArn
        self.description = description
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

struct GetAliasOutputResponseBody: Swift.Equatable {
    let aliasArn: Swift.String?
    let name: Swift.String?
    let functionVersion: Swift.String?
    let description: Swift.String?
    let routingConfig: LambdaClientTypes.AliasRoutingConfiguration?
    let revisionId: Swift.String?
}

extension GetAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasArn = "AliasArn"
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasArn)
        aliasArn = aliasArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension GetCodeSigningConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let codeSigningConfigArn = codeSigningConfigArn else {
            return nil
        }
        return "/2020-04-22/code-signing-configs/\(codeSigningConfigArn.urlPercentEncoding())"
    }
}

public struct GetCodeSigningConfigInput: Swift.Equatable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?

    public init (
        codeSigningConfigArn: Swift.String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
    }
}

struct GetCodeSigningConfigInputBody: Swift.Equatable {
}

extension GetCodeSigningConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCodeSigningConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCodeSigningConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCodeSigningConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCodeSigningConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCodeSigningConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.codeSigningConfig = output.codeSigningConfig
        } else {
            self.codeSigningConfig = nil
        }
    }
}

public struct GetCodeSigningConfigOutputResponse: Swift.Equatable {
    /// The code signing configuration
    /// This member is required.
    public var codeSigningConfig: LambdaClientTypes.CodeSigningConfig?

    public init (
        codeSigningConfig: LambdaClientTypes.CodeSigningConfig? = nil
    )
    {
        self.codeSigningConfig = codeSigningConfig
    }
}

struct GetCodeSigningConfigOutputResponseBody: Swift.Equatable {
    let codeSigningConfig: LambdaClientTypes.CodeSigningConfig?
}

extension GetCodeSigningConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfig = "CodeSigningConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.CodeSigningConfig.self, forKey: .codeSigningConfig)
        codeSigningConfig = codeSigningConfigDecoded
    }
}

extension GetEventSourceMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let uUID = uUID else {
            return nil
        }
        return "/2015-03-31/event-source-mappings/\(uUID.urlPercentEncoding())"
    }
}

public struct GetEventSourceMappingInput: Swift.Equatable {
    /// The identifier of the event source mapping.
    /// This member is required.
    public var uUID: Swift.String?

    public init (
        uUID: Swift.String? = nil
    )
    {
        self.uUID = uUID
    }
}

struct GetEventSourceMappingInputBody: Swift.Equatable {
}

extension GetEventSourceMappingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetEventSourceMappingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEventSourceMappingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEventSourceMappingOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEventSourceMappingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEventSourceMappingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchSize = output.batchSize
            self.bisectBatchOnFunctionError = output.bisectBatchOnFunctionError
            self.destinationConfig = output.destinationConfig
            self.eventSourceArn = output.eventSourceArn
            self.filterCriteria = output.filterCriteria
            self.functionArn = output.functionArn
            self.functionResponseTypes = output.functionResponseTypes
            self.lastModified = output.lastModified
            self.lastProcessingResult = output.lastProcessingResult
            self.maximumBatchingWindowInSeconds = output.maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = output.maximumRecordAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
            self.parallelizationFactor = output.parallelizationFactor
            self.queues = output.queues
            self.selfManagedEventSource = output.selfManagedEventSource
            self.sourceAccessConfigurations = output.sourceAccessConfigurations
            self.startingPosition = output.startingPosition
            self.startingPositionTimestamp = output.startingPositionTimestamp
            self.state = output.state
            self.stateTransitionReason = output.stateTransitionReason
            self.topics = output.topics
            self.tumblingWindowInSeconds = output.tumblingWindowInSeconds
            self.uUID = output.uUID
        } else {
            self.batchSize = nil
            self.bisectBatchOnFunctionError = nil
            self.destinationConfig = nil
            self.eventSourceArn = nil
            self.filterCriteria = nil
            self.functionArn = nil
            self.functionResponseTypes = nil
            self.lastModified = nil
            self.lastProcessingResult = nil
            self.maximumBatchingWindowInSeconds = nil
            self.maximumRecordAgeInSeconds = nil
            self.maximumRetryAttempts = nil
            self.parallelizationFactor = nil
            self.queues = nil
            self.selfManagedEventSource = nil
            self.sourceAccessConfigurations = nil
            self.startingPosition = nil
            self.startingPositionTimestamp = nil
            self.state = nil
            self.stateTransitionReason = nil
            self.topics = nil
            self.tumblingWindowInSeconds = nil
            self.uUID = nil
        }
    }
}

/// A mapping between an Amazon Web Services resource and a Lambda function. For details, see [CreateEventSourceMapping].
public struct GetEventSourceMappingOutputResponse: Swift.Equatable {
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB). Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100. Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var batchSize: Swift.Int?
    /// (Streams only) If the function returns an error, split the batch in two and retry. The default value is false.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The Amazon Resource Name (ARN) of the event source.
    public var eventSourceArn: Swift.String?
    /// (Streams and Amazon SQS) An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html).
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// The ARN of the Lambda function.
    public var functionArn: Swift.String?
    /// (Streams only) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The date that the event source mapping was last updated or that its state changed.
    public var lastModified: ClientRuntime.Date?
    /// The result of the last Lambda invocation of your function.
    public var lastProcessingResult: Swift.String?
    /// (Streams and Amazon SQS standard queues) The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. Default: 0 Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Streams only) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records.
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Streams only) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
    public var maximumRetryAttempts: Swift.Int?
    /// (Streams only) The number of batches to process concurrently from each shard. The default value is 1.
    public var parallelizationFactor: Swift.Int?
    /// (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// The self-managed Apache Kafka cluster for your event source.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK stream sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading.
    public var startingPositionTimestamp: ClientRuntime.Date?
    /// The state of the event source mapping. It can be one of the following: Creating, Enabling, Enabled, Disabling, Disabled, Updating, or Deleting.
    public var state: Swift.String?
    /// Indicates whether a user or Lambda made the last change to the event source mapping.
    public var stateTransitionReason: Swift.String?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Streams only) The duration in seconds of a processing window. The range is 1900 seconds.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    public var uUID: Swift.String?

    public init (
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        eventSourceArn: Swift.String? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        functionArn: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        lastModified: ClientRuntime.Date? = nil,
        lastProcessingResult: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        queues: [Swift.String]? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: ClientRuntime.Date? = nil,
        state: Swift.String? = nil,
        stateTransitionReason: Swift.String? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uUID: Swift.String? = nil
    )
    {
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.eventSourceArn = eventSourceArn
        self.filterCriteria = filterCriteria
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.selfManagedEventSource = selfManagedEventSource
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uUID = uUID
    }
}

struct GetEventSourceMappingOutputResponseBody: Swift.Equatable {
    let uUID: Swift.String?
    let startingPosition: LambdaClientTypes.EventSourcePosition?
    let startingPositionTimestamp: ClientRuntime.Date?
    let batchSize: Swift.Int?
    let maximumBatchingWindowInSeconds: Swift.Int?
    let parallelizationFactor: Swift.Int?
    let eventSourceArn: Swift.String?
    let filterCriteria: LambdaClientTypes.FilterCriteria?
    let functionArn: Swift.String?
    let lastModified: ClientRuntime.Date?
    let lastProcessingResult: Swift.String?
    let state: Swift.String?
    let stateTransitionReason: Swift.String?
    let destinationConfig: LambdaClientTypes.DestinationConfig?
    let topics: [Swift.String]?
    let queues: [Swift.String]?
    let sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    let selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    let maximumRecordAgeInSeconds: Swift.Int?
    let bisectBatchOnFunctionError: Swift.Bool?
    let maximumRetryAttempts: Swift.Int?
    let tumblingWindowInSeconds: Swift.Int?
    let functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
}

extension GetEventSourceMappingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case eventSourceArn = "EventSourceArn"
        case filterCriteria = "FilterCriteria"
        case functionArn = "FunctionArn"
        case functionResponseTypes = "FunctionResponseTypes"
        case lastModified = "LastModified"
        case lastProcessingResult = "LastProcessingResult"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case selfManagedEventSource = "SelfManagedEventSource"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case state = "State"
        case stateTransitionReason = "StateTransitionReason"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        case uUID = "UUID"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uUIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uUID)
        uUID = uUIDDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lastProcessingResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastProcessingResult)
        lastProcessingResult = lastProcessingResultDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let stateTransitionReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateTransitionReason)
        stateTransitionReason = stateTransitionReasonDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let topicsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .topics)
        var topicsDecoded0:[Swift.String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [Swift.String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queues)
        var queuesDecoded0:[Swift.String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [Swift.String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[LambdaClientTypes.SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [LambdaClientTypes.SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[LambdaClientTypes.FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [LambdaClientTypes.FunctionResponseType]()
            for string0 in functionResponseTypesContainer {
                if let string0 = string0 {
                    functionResponseTypesDecoded0?.append(string0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
    }
}

extension GetFunctionCodeSigningConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2020-06-30/functions/\(functionName.urlPercentEncoding())/code-signing-config"
    }
}

public struct GetFunctionCodeSigningConfigInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init (
        functionName: Swift.String? = nil
    )
    {
        self.functionName = functionName
    }
}

struct GetFunctionCodeSigningConfigInputBody: Swift.Equatable {
}

extension GetFunctionCodeSigningConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionCodeSigningConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFunctionCodeSigningConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionCodeSigningConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionCodeSigningConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFunctionCodeSigningConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.codeSigningConfigArn = output.codeSigningConfigArn
            self.functionName = output.functionName
        } else {
            self.codeSigningConfigArn = nil
            self.functionName = nil
        }
    }
}

public struct GetFunctionCodeSigningConfigOutputResponse: Swift.Equatable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init (
        codeSigningConfigArn: Swift.String? = nil,
        functionName: Swift.String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.functionName = functionName
    }
}

struct GetFunctionCodeSigningConfigOutputResponseBody: Swift.Equatable {
    let codeSigningConfigArn: Swift.String?
    let functionName: Swift.String?
}

extension GetFunctionCodeSigningConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfigArn = "CodeSigningConfigArn"
        case functionName = "FunctionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSigningConfigArn)
        codeSigningConfigArn = codeSigningConfigArnDecoded
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
    }
}

extension GetFunctionConcurrencyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2019-09-30/functions/\(functionName.urlPercentEncoding())/concurrency"
    }
}

public struct GetFunctionConcurrencyInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - my-function.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init (
        functionName: Swift.String? = nil
    )
    {
        self.functionName = functionName
    }
}

struct GetFunctionConcurrencyInputBody: Swift.Equatable {
}

extension GetFunctionConcurrencyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionConcurrencyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFunctionConcurrencyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionConcurrencyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionConcurrencyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFunctionConcurrencyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reservedConcurrentExecutions = output.reservedConcurrentExecutions
        } else {
            self.reservedConcurrentExecutions = nil
        }
    }
}

public struct GetFunctionConcurrencyOutputResponse: Swift.Equatable {
    /// The number of simultaneous executions that are reserved for the function.
    public var reservedConcurrentExecutions: Swift.Int?

    public init (
        reservedConcurrentExecutions: Swift.Int? = nil
    )
    {
        self.reservedConcurrentExecutions = reservedConcurrentExecutions
    }
}

struct GetFunctionConcurrencyOutputResponseBody: Swift.Equatable {
    let reservedConcurrentExecutions: Swift.Int?
}

extension GetFunctionConcurrencyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reservedConcurrentExecutions)
        reservedConcurrentExecutions = reservedConcurrentExecutionsDecoded
    }
}

extension GetFunctionConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let qualifier = qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension GetFunctionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/configuration"
    }
}

public struct GetFunctionConfigurationInput: Swift.Equatable {
    /// The name of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version or alias to get details about a published version of the function.
    public var qualifier: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct GetFunctionConfigurationInputBody: Swift.Equatable {
}

extension GetFunctionConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFunctionConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionConfigurationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFunctionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.architectures = output.architectures
            self.codeSha256 = output.codeSha256
            self.codeSize = output.codeSize
            self.deadLetterConfig = output.deadLetterConfig
            self.description = output.description
            self.environment = output.environment
            self.fileSystemConfigs = output.fileSystemConfigs
            self.functionArn = output.functionArn
            self.functionName = output.functionName
            self.handler = output.handler
            self.imageConfigResponse = output.imageConfigResponse
            self.kMSKeyArn = output.kMSKeyArn
            self.lastModified = output.lastModified
            self.lastUpdateStatus = output.lastUpdateStatus
            self.lastUpdateStatusReason = output.lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = output.lastUpdateStatusReasonCode
            self.layers = output.layers
            self.masterArn = output.masterArn
            self.memorySize = output.memorySize
            self.packageType = output.packageType
            self.revisionId = output.revisionId
            self.role = output.role
            self.runtime = output.runtime
            self.signingJobArn = output.signingJobArn
            self.signingProfileVersionArn = output.signingProfileVersionArn
            self.state = output.state
            self.stateReason = output.stateReason
            self.stateReasonCode = output.stateReasonCode
            self.timeout = output.timeout
            self.tracingConfig = output.tracingConfig
            self.version = output.version
            self.vpcConfig = output.vpcConfig
        } else {
            self.architectures = nil
            self.codeSha256 = nil
            self.codeSize = 0
            self.deadLetterConfig = nil
            self.description = nil
            self.environment = nil
            self.fileSystemConfigs = nil
            self.functionArn = nil
            self.functionName = nil
            self.handler = nil
            self.imageConfigResponse = nil
            self.kMSKeyArn = nil
            self.lastModified = nil
            self.lastUpdateStatus = nil
            self.lastUpdateStatusReason = nil
            self.lastUpdateStatusReasonCode = nil
            self.layers = nil
            self.masterArn = nil
            self.memorySize = nil
            self.packageType = nil
            self.revisionId = nil
            self.role = nil
            self.runtime = nil
            self.signingJobArn = nil
            self.signingProfileVersionArn = nil
            self.state = nil
            self.stateReason = nil
            self.stateReasonCode = nil
            self.timeout = nil
            self.tracingConfig = nil
            self.version = nil
            self.vpcConfig = nil
        }
    }
}

/// Details about a function's configuration.
public struct GetFunctionConfigurationOutputResponse: Swift.Equatable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html).
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin executing your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've configured a customer managed key.
    public var kMSKeyArn: Swift.String?
    /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's [ layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public var layers: [LambdaClientTypes.Layer]?
    /// For Lambda@Edge functions, the ARN of the main function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The runtime environment for the Lambda function.
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init (
        architectures: [LambdaClientTypes.Architecture]? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kMSKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    )
    {
        self.architectures = architectures
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kMSKeyArn = kMSKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

struct GetFunctionConfigurationOutputResponseBody: Swift.Equatable {
    let functionName: Swift.String?
    let functionArn: Swift.String?
    let runtime: LambdaClientTypes.Runtime?
    let role: Swift.String?
    let handler: Swift.String?
    let codeSize: Swift.Int
    let description: Swift.String?
    let timeout: Swift.Int?
    let memorySize: Swift.Int?
    let lastModified: Swift.String?
    let codeSha256: Swift.String?
    let version: Swift.String?
    let vpcConfig: LambdaClientTypes.VpcConfigResponse?
    let deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    let environment: LambdaClientTypes.EnvironmentResponse?
    let kMSKeyArn: Swift.String?
    let tracingConfig: LambdaClientTypes.TracingConfigResponse?
    let masterArn: Swift.String?
    let revisionId: Swift.String?
    let layers: [LambdaClientTypes.Layer]?
    let state: LambdaClientTypes.State?
    let stateReason: Swift.String?
    let stateReasonCode: LambdaClientTypes.StateReasonCode?
    let lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    let lastUpdateStatusReason: Swift.String?
    let lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    let fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    let packageType: LambdaClientTypes.PackageType?
    let imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    let signingProfileVersionArn: Swift.String?
    let signingJobArn: Swift.String?
    let architectures: [LambdaClientTypes.Architecture]?
}

extension GetFunctionConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kMSKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[LambdaClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [LambdaClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
    }
}

extension GetFunctionEventInvokeConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let qualifier = qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension GetFunctionEventInvokeConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config"
    }
}

public struct GetFunctionEventInvokeConfigInput: Swift.Equatable {
    /// The name of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// A version number or alias name.
    public var qualifier: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct GetFunctionEventInvokeConfigInputBody: Swift.Equatable {
}

extension GetFunctionEventInvokeConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionEventInvokeConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFunctionEventInvokeConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionEventInvokeConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionEventInvokeConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFunctionEventInvokeConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinationConfig = output.destinationConfig
            self.functionArn = output.functionArn
            self.lastModified = output.lastModified
            self.maximumEventAgeInSeconds = output.maximumEventAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
        } else {
            self.destinationConfig = nil
            self.functionArn = nil
            self.lastModified = nil
            self.maximumEventAgeInSeconds = nil
            self.maximumRetryAttempts = nil
        }
    }
}

public struct GetFunctionEventInvokeConfigOutputResponse: Swift.Equatable {
    /// A destination for events after they have been sent to a function for processing. Destinations
    ///
    /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    /// * Queue - The ARN of an SQS queue.
    ///
    /// * Topic - The ARN of an SNS topic.
    ///
    /// * Event Bus - The ARN of an Amazon EventBridge event bus.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The Amazon Resource Name (ARN) of the function.
    public var functionArn: Swift.String?
    /// The date and time that the configuration was last updated.
    public var lastModified: ClientRuntime.Date?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?

    public init (
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionArn: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionArn = functionArn
        self.lastModified = lastModified
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
    }
}

struct GetFunctionEventInvokeConfigOutputResponseBody: Swift.Equatable {
    let lastModified: ClientRuntime.Date?
    let functionArn: Swift.String?
    let maximumRetryAttempts: Swift.Int?
    let maximumEventAgeInSeconds: Swift.Int?
    let destinationConfig: LambdaClientTypes.DestinationConfig?
}

extension GetFunctionEventInvokeConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case functionArn = "FunctionArn"
        case lastModified = "LastModified"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

extension GetFunctionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let qualifier = qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension GetFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())"
    }
}

public struct GetFunctionInput: Swift.Equatable {
    /// The name of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version or alias to get details about a published version of the function.
    public var qualifier: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct GetFunctionInputBody: Swift.Equatable {
}

extension GetFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFunctionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.concurrency = output.concurrency
            self.configuration = output.configuration
            self.tags = output.tags
        } else {
            self.code = nil
            self.concurrency = nil
            self.configuration = nil
            self.tags = nil
        }
    }
}

public struct GetFunctionOutputResponse: Swift.Equatable {
    /// The deployment package of the function or version.
    public var code: LambdaClientTypes.FunctionCodeLocation?
    /// The function's [reserved concurrency](https://docs.aws.amazon.com/lambda/latest/dg/concurrent-executions.html).
    public var concurrency: LambdaClientTypes.Concurrency?
    /// The configuration of the function or version.
    public var configuration: LambdaClientTypes.FunctionConfiguration?
    /// The function's [tags](https://docs.aws.amazon.com/lambda/latest/dg/tagging.html).
    public var tags: [Swift.String:Swift.String]?

    public init (
        code: LambdaClientTypes.FunctionCodeLocation? = nil,
        concurrency: LambdaClientTypes.Concurrency? = nil,
        configuration: LambdaClientTypes.FunctionConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.code = code
        self.concurrency = concurrency
        self.configuration = configuration
        self.tags = tags
    }
}

struct GetFunctionOutputResponseBody: Swift.Equatable {
    let configuration: LambdaClientTypes.FunctionConfiguration?
    let code: LambdaClientTypes.FunctionCodeLocation?
    let tags: [Swift.String:Swift.String]?
    let concurrency: LambdaClientTypes.Concurrency?
}

extension GetFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case concurrency = "Concurrency"
        case configuration = "Configuration"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FunctionConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let codeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FunctionCodeLocation.self, forKey: .code)
        code = codeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let concurrencyDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Concurrency.self, forKey: .concurrency)
        concurrency = concurrencyDecoded
    }
}

extension GetLayerVersionByArnInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "find", value: "LayerVersion"))
        if let arn = arn {
            let arnQueryItem = ClientRuntime.URLQueryItem(name: "Arn".urlPercentEncoding(), value: Swift.String(arn).urlPercentEncoding())
            items.append(arnQueryItem)
        }
        return items
    }
}

extension GetLayerVersionByArnInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2018-10-31/layers"
    }
}

public struct GetLayerVersionByArnInput: Swift.Equatable {
    /// The ARN of the layer version.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetLayerVersionByArnInputBody: Swift.Equatable {
}

extension GetLayerVersionByArnInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLayerVersionByArnOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLayerVersionByArnOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLayerVersionByArnOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLayerVersionByArnOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLayerVersionByArnOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.compatibleArchitectures = output.compatibleArchitectures
            self.compatibleRuntimes = output.compatibleRuntimes
            self.content = output.content
            self.createdDate = output.createdDate
            self.description = output.description
            self.layerArn = output.layerArn
            self.layerVersionArn = output.layerVersionArn
            self.licenseInfo = output.licenseInfo
            self.version = output.version
        } else {
            self.compatibleArchitectures = nil
            self.compatibleRuntimes = nil
            self.content = nil
            self.createdDate = nil
            self.description = nil
            self.layerArn = nil
            self.layerVersionArn = nil
            self.licenseInfo = nil
            self.version = 0
        }
    }
}

public struct GetLayerVersionByArnOutputResponse: Swift.Equatable {
    /// A list of compatible [instruction set architectures](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
    /// The layer's compatible runtimes.
    public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
    /// Details about the layer version.
    public var content: LambdaClientTypes.LayerVersionContentOutput?
    /// The date that the layer version was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var createdDate: Swift.String?
    /// The description of the version.
    public var description: Swift.String?
    /// The ARN of the layer.
    public var layerArn: Swift.String?
    /// The ARN of the layer version.
    public var layerVersionArn: Swift.String?
    /// The layer's software license.
    public var licenseInfo: Swift.String?
    /// The version number.
    public var version: Swift.Int

    public init (
        compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
        compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
        content: LambdaClientTypes.LayerVersionContentOutput? = nil,
        createdDate: Swift.String? = nil,
        description: Swift.String? = nil,
        layerArn: Swift.String? = nil,
        layerVersionArn: Swift.String? = nil,
        licenseInfo: Swift.String? = nil,
        version: Swift.Int = 0
    )
    {
        self.compatibleArchitectures = compatibleArchitectures
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.createdDate = createdDate
        self.description = description
        self.layerArn = layerArn
        self.layerVersionArn = layerVersionArn
        self.licenseInfo = licenseInfo
        self.version = version
    }
}

struct GetLayerVersionByArnOutputResponseBody: Swift.Equatable {
    let content: LambdaClientTypes.LayerVersionContentOutput?
    let layerArn: Swift.String?
    let layerVersionArn: Swift.String?
    let description: Swift.String?
    let createdDate: Swift.String?
    let version: Swift.Int
    let compatibleRuntimes: [LambdaClientTypes.Runtime]?
    let licenseInfo: Swift.String?
    let compatibleArchitectures: [LambdaClientTypes.Architecture]?
}

extension GetLayerVersionByArnOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleArchitectures = "CompatibleArchitectures"
        case compatibleRuntimes = "CompatibleRuntimes"
        case content = "Content"
        case createdDate = "CreatedDate"
        case description = "Description"
        case layerArn = "LayerArn"
        case layerVersionArn = "LayerVersionArn"
        case licenseInfo = "LicenseInfo"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LayerVersionContentOutput.self, forKey: .content)
        content = contentDecoded
        let layerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerArn)
        layerArn = layerArnDecoded
        let layerVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerVersionArn)
        layerVersionArn = layerVersionArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decode(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let compatibleRuntimesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Runtime?].self, forKey: .compatibleRuntimes)
        var compatibleRuntimesDecoded0:[LambdaClientTypes.Runtime]? = nil
        if let compatibleRuntimesContainer = compatibleRuntimesContainer {
            compatibleRuntimesDecoded0 = [LambdaClientTypes.Runtime]()
            for string0 in compatibleRuntimesContainer {
                if let string0 = string0 {
                    compatibleRuntimesDecoded0?.append(string0)
                }
            }
        }
        compatibleRuntimes = compatibleRuntimesDecoded0
        let licenseInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseInfo)
        licenseInfo = licenseInfoDecoded
        let compatibleArchitecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .compatibleArchitectures)
        var compatibleArchitecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let compatibleArchitecturesContainer = compatibleArchitecturesContainer {
            compatibleArchitecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in compatibleArchitecturesContainer {
                if let string0 = string0 {
                    compatibleArchitecturesDecoded0?.append(string0)
                }
            }
        }
        compatibleArchitectures = compatibleArchitecturesDecoded0
    }
}

extension GetLayerVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let layerName = layerName else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)"
    }
}

public struct GetLayerVersionInput: Swift.Equatable {
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int

    public init (
        layerName: Swift.String? = nil,
        versionNumber: Swift.Int = 0
    )
    {
        self.layerName = layerName
        self.versionNumber = versionNumber
    }
}

struct GetLayerVersionInputBody: Swift.Equatable {
}

extension GetLayerVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLayerVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLayerVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLayerVersionOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLayerVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLayerVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.compatibleArchitectures = output.compatibleArchitectures
            self.compatibleRuntimes = output.compatibleRuntimes
            self.content = output.content
            self.createdDate = output.createdDate
            self.description = output.description
            self.layerArn = output.layerArn
            self.layerVersionArn = output.layerVersionArn
            self.licenseInfo = output.licenseInfo
            self.version = output.version
        } else {
            self.compatibleArchitectures = nil
            self.compatibleRuntimes = nil
            self.content = nil
            self.createdDate = nil
            self.description = nil
            self.layerArn = nil
            self.layerVersionArn = nil
            self.licenseInfo = nil
            self.version = 0
        }
    }
}

public struct GetLayerVersionOutputResponse: Swift.Equatable {
    /// A list of compatible [instruction set architectures](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
    /// The layer's compatible runtimes.
    public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
    /// Details about the layer version.
    public var content: LambdaClientTypes.LayerVersionContentOutput?
    /// The date that the layer version was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var createdDate: Swift.String?
    /// The description of the version.
    public var description: Swift.String?
    /// The ARN of the layer.
    public var layerArn: Swift.String?
    /// The ARN of the layer version.
    public var layerVersionArn: Swift.String?
    /// The layer's software license.
    public var licenseInfo: Swift.String?
    /// The version number.
    public var version: Swift.Int

    public init (
        compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
        compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
        content: LambdaClientTypes.LayerVersionContentOutput? = nil,
        createdDate: Swift.String? = nil,
        description: Swift.String? = nil,
        layerArn: Swift.String? = nil,
        layerVersionArn: Swift.String? = nil,
        licenseInfo: Swift.String? = nil,
        version: Swift.Int = 0
    )
    {
        self.compatibleArchitectures = compatibleArchitectures
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.createdDate = createdDate
        self.description = description
        self.layerArn = layerArn
        self.layerVersionArn = layerVersionArn
        self.licenseInfo = licenseInfo
        self.version = version
    }
}

struct GetLayerVersionOutputResponseBody: Swift.Equatable {
    let content: LambdaClientTypes.LayerVersionContentOutput?
    let layerArn: Swift.String?
    let layerVersionArn: Swift.String?
    let description: Swift.String?
    let createdDate: Swift.String?
    let version: Swift.Int
    let compatibleRuntimes: [LambdaClientTypes.Runtime]?
    let licenseInfo: Swift.String?
    let compatibleArchitectures: [LambdaClientTypes.Architecture]?
}

extension GetLayerVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleArchitectures = "CompatibleArchitectures"
        case compatibleRuntimes = "CompatibleRuntimes"
        case content = "Content"
        case createdDate = "CreatedDate"
        case description = "Description"
        case layerArn = "LayerArn"
        case layerVersionArn = "LayerVersionArn"
        case licenseInfo = "LicenseInfo"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LayerVersionContentOutput.self, forKey: .content)
        content = contentDecoded
        let layerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerArn)
        layerArn = layerArnDecoded
        let layerVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerVersionArn)
        layerVersionArn = layerVersionArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decode(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let compatibleRuntimesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Runtime?].self, forKey: .compatibleRuntimes)
        var compatibleRuntimesDecoded0:[LambdaClientTypes.Runtime]? = nil
        if let compatibleRuntimesContainer = compatibleRuntimesContainer {
            compatibleRuntimesDecoded0 = [LambdaClientTypes.Runtime]()
            for string0 in compatibleRuntimesContainer {
                if let string0 = string0 {
                    compatibleRuntimesDecoded0?.append(string0)
                }
            }
        }
        compatibleRuntimes = compatibleRuntimesDecoded0
        let licenseInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseInfo)
        licenseInfo = licenseInfoDecoded
        let compatibleArchitecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .compatibleArchitectures)
        var compatibleArchitecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let compatibleArchitecturesContainer = compatibleArchitecturesContainer {
            compatibleArchitecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in compatibleArchitecturesContainer {
                if let string0 = string0 {
                    compatibleArchitecturesDecoded0?.append(string0)
                }
            }
        }
        compatibleArchitectures = compatibleArchitecturesDecoded0
    }
}

extension GetLayerVersionPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let layerName = layerName else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)/policy"
    }
}

public struct GetLayerVersionPolicyInput: Swift.Equatable {
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int

    public init (
        layerName: Swift.String? = nil,
        versionNumber: Swift.Int = 0
    )
    {
        self.layerName = layerName
        self.versionNumber = versionNumber
    }
}

struct GetLayerVersionPolicyInputBody: Swift.Equatable {
}

extension GetLayerVersionPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLayerVersionPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLayerVersionPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLayerVersionPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLayerVersionPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLayerVersionPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

public struct GetLayerVersionPolicyOutputResponse: Swift.Equatable {
    /// The policy document.
    public var policy: Swift.String?
    /// A unique identifier for the current revision of the policy.
    public var revisionId: Swift.String?

    public init (
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct GetLayerVersionPolicyOutputResponseBody: Swift.Equatable {
    let policy: Swift.String?
    let revisionId: Swift.String?
}

extension GetLayerVersionPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension GetPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let qualifier = qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension GetPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/policy"
    }
}

public struct GetPolicyInput: Swift.Equatable {
    /// The name of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version or alias to get the policy for that resource.
    public var qualifier: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct GetPolicyInputBody: Swift.Equatable {
}

extension GetPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

public struct GetPolicyOutputResponse: Swift.Equatable {
    /// The resource-based policy.
    public var policy: Swift.String?
    /// A unique identifier for the current revision of the policy.
    public var revisionId: Swift.String?

    public init (
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct GetPolicyOutputResponseBody: Swift.Equatable {
    let policy: Swift.String?
    let revisionId: Swift.String?
}

extension GetPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension GetProvisionedConcurrencyConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let qualifier = qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension GetProvisionedConcurrencyConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2019-09-30/functions/\(functionName.urlPercentEncoding())/provisioned-concurrency"
    }
}

public struct GetProvisionedConcurrencyConfigInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - my-function.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The version number or alias name.
    /// This member is required.
    public var qualifier: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct GetProvisionedConcurrencyConfigInputBody: Swift.Equatable {
}

extension GetProvisionedConcurrencyConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetProvisionedConcurrencyConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProvisionedConcurrencyConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedConcurrencyConfigNotFoundException" : self = .provisionedConcurrencyConfigNotFoundException(try ProvisionedConcurrencyConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProvisionedConcurrencyConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case provisionedConcurrencyConfigNotFoundException(ProvisionedConcurrencyConfigNotFoundException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProvisionedConcurrencyConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetProvisionedConcurrencyConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.allocatedProvisionedConcurrentExecutions = output.allocatedProvisionedConcurrentExecutions
            self.availableProvisionedConcurrentExecutions = output.availableProvisionedConcurrentExecutions
            self.lastModified = output.lastModified
            self.requestedProvisionedConcurrentExecutions = output.requestedProvisionedConcurrentExecutions
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.allocatedProvisionedConcurrentExecutions = nil
            self.availableProvisionedConcurrentExecutions = nil
            self.lastModified = nil
            self.requestedProvisionedConcurrentExecutions = nil
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct GetProvisionedConcurrencyConfigOutputResponse: Swift.Equatable {
    /// The amount of provisioned concurrency allocated.
    public var allocatedProvisionedConcurrentExecutions: Swift.Int?
    /// The amount of provisioned concurrency available.
    public var availableProvisionedConcurrentExecutions: Swift.Int?
    /// The date and time that a user last updated the configuration, in [ISO 8601 format](https://www.iso.org/iso-8601-date-and-time-format.html).
    public var lastModified: Swift.String?
    /// The amount of provisioned concurrency requested.
    public var requestedProvisionedConcurrentExecutions: Swift.Int?
    /// The status of the allocation process.
    public var status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum?
    /// For failed allocations, the reason that provisioned concurrency could not be allocated.
    public var statusReason: Swift.String?

    public init (
        allocatedProvisionedConcurrentExecutions: Swift.Int? = nil,
        availableProvisionedConcurrentExecutions: Swift.Int? = nil,
        lastModified: Swift.String? = nil,
        requestedProvisionedConcurrentExecutions: Swift.Int? = nil,
        status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
        self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
        self.lastModified = lastModified
        self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
        self.status = status
        self.statusReason = statusReason
    }
}

struct GetProvisionedConcurrencyConfigOutputResponseBody: Swift.Equatable {
    let requestedProvisionedConcurrentExecutions: Swift.Int?
    let availableProvisionedConcurrentExecutions: Swift.Int?
    let allocatedProvisionedConcurrentExecutions: Swift.Int?
    let status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum?
    let statusReason: Swift.String?
    let lastModified: Swift.String?
}

extension GetProvisionedConcurrencyConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedProvisionedConcurrentExecutions = "AllocatedProvisionedConcurrentExecutions"
        case availableProvisionedConcurrentExecutions = "AvailableProvisionedConcurrentExecutions"
        case lastModified = "LastModified"
        case requestedProvisionedConcurrentExecutions = "RequestedProvisionedConcurrentExecutions"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .requestedProvisionedConcurrentExecutions)
        requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutionsDecoded
        let availableProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .availableProvisionedConcurrentExecutions)
        availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutionsDecoded
        let allocatedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedProvisionedConcurrentExecutions)
        allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ProvisionedConcurrencyStatusEnum.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension LambdaClientTypes.ImageConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case command = "Command"
        case entryPoint = "EntryPoint"
        case workingDirectory = "WorkingDirectory"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let command = command {
            var commandContainer = encodeContainer.nestedUnkeyedContainer(forKey: .command)
            for stringlist0 in command {
                try commandContainer.encode(stringlist0)
            }
        }
        if let entryPoint = entryPoint {
            var entryPointContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entryPoint)
            for stringlist0 in entryPoint {
                try entryPointContainer.encode(stringlist0)
            }
        }
        if let workingDirectory = workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryPointContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entryPoint)
        var entryPointDecoded0:[Swift.String]? = nil
        if let entryPointContainer = entryPointContainer {
            entryPointDecoded0 = [Swift.String]()
            for string0 in entryPointContainer {
                if let string0 = string0 {
                    entryPointDecoded0?.append(string0)
                }
            }
        }
        entryPoint = entryPointDecoded0
        let commandContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .command)
        var commandDecoded0:[Swift.String]? = nil
        if let commandContainer = commandContainer {
            commandDecoded0 = [Swift.String]()
            for string0 in commandContainer {
                if let string0 = string0 {
                    commandDecoded0?.append(string0)
                }
            }
        }
        command = commandDecoded0
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
    }
}

extension LambdaClientTypes {
    /// Configuration values that override the container image Dockerfile settings. See [Container settings](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms).
    public struct ImageConfig: Swift.Equatable {
        /// Specifies parameters that you want to pass in with ENTRYPOINT.
        public var command: [Swift.String]?
        /// Specifies the entry point to their application, which is typically the location of the runtime executable.
        public var entryPoint: [Swift.String]?
        /// Specifies the working directory.
        public var workingDirectory: Swift.String?

        public init (
            command: [Swift.String]? = nil,
            entryPoint: [Swift.String]? = nil,
            workingDirectory: Swift.String? = nil
        )
        {
            self.command = command
            self.entryPoint = entryPoint
            self.workingDirectory = workingDirectory
        }
    }

}

extension LambdaClientTypes.ImageConfigError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes {
    /// Error response to GetFunctionConfiguration.
    public struct ImageConfigError: Swift.Equatable {
        /// Error code.
        public var errorCode: Swift.String?
        /// Error message.
        public var message: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.message = message
        }
    }

}

extension LambdaClientTypes.ImageConfigResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "Error"
        case imageConfig = "ImageConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let imageConfig = imageConfig {
            try encodeContainer.encode(imageConfig, forKey: .imageConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfig.self, forKey: .imageConfig)
        imageConfig = imageConfigDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfigError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LambdaClientTypes {
    /// Response to GetFunctionConfiguration request.
    public struct ImageConfigResponse: Swift.Equatable {
        /// Error response to GetFunctionConfiguration.
        public var error: LambdaClientTypes.ImageConfigError?
        /// Configuration values that override the container image Dockerfile.
        public var imageConfig: LambdaClientTypes.ImageConfig?

        public init (
            error: LambdaClientTypes.ImageConfigError? = nil,
            imageConfig: LambdaClientTypes.ImageConfig? = nil
        )
        {
            self.error = error
            self.imageConfig = imageConfig
        }
    }

}

extension InvalidCodeSignatureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidCodeSignatureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The code signature failed the integrity check. Lambda always blocks deployment if the integrity check fails, even if code signing policy is set to WARN.
public struct InvalidCodeSignatureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InvalidCodeSignatureExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension InvalidCodeSignatureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One of the parameters in the request is invalid.
public struct InvalidParameterValueException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The exception message.
    public var message: Swift.String?
    /// The exception type.
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestContentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestContentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request body could not be parsed as JSON.
public struct InvalidRequestContentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The exception message.
    public var message: Swift.String?
    /// The exception type.
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InvalidRequestContentExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension InvalidRequestContentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRuntimeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRuntimeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The runtime or runtime version specified is not supported.
public struct InvalidRuntimeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InvalidRuntimeExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension InvalidRuntimeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSecurityGroupIDException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidSecurityGroupIDExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Security Group ID provided in the Lambda function VPC configuration is invalid.
public struct InvalidSecurityGroupIDException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InvalidSecurityGroupIDExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension InvalidSecurityGroupIDExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnetIDException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidSubnetIDExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Subnet ID provided in the Lambda function VPC configuration is invalid.
public struct InvalidSubnetIDException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InvalidSubnetIDExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension InvalidSubnetIDExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidZipFileException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidZipFileExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Lambda could not unzip the deployment package.
public struct InvalidZipFileException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InvalidZipFileExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension InvalidZipFileExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes {
    public enum InvocationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dryrun
        case event
        case requestresponse
        case sdkUnknown(Swift.String)

        public static var allCases: [InvocationType] {
            return [
                .dryrun,
                .event,
                .requestresponse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dryrun: return "DryRun"
            case .event: return "Event"
            case .requestresponse: return "RequestResponse"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InvocationType(rawValue: rawValue) ?? InvocationType.sdkUnknown(rawValue)
        }
    }
}

public struct InvokeAsyncInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InvokeAsyncInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InvokeAsyncInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<InvokeAsyncOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let invokeArgs = input.operationInput.invokeArgs {
            let invokeArgsdata = invokeArgs
            let invokeArgsbody = ClientRuntime.HttpBody.stream(invokeArgsdata)
            input.builder.withBody(invokeArgsbody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InvokeAsyncInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InvokeAsyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension InvokeAsyncInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invokeArgs = "InvokeArgs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invokeArgs = invokeArgs {
            try encodeContainer.encode(invokeArgs.toBytes().toData(), forKey: .invokeArgs)
        }
    }
}

extension InvokeAsyncInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2014-11-13/functions/\(functionName.urlPercentEncoding())/invoke-async"
    }
}

@available(*, deprecated)
public struct InvokeAsyncInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - my-function.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The JSON that you want to provide to your Lambda function as input.
    /// This member is required.
    public var invokeArgs: ClientRuntime.ByteStream?

    public init (
        functionName: Swift.String? = nil,
        invokeArgs: ClientRuntime.ByteStream? = nil
    )
    {
        self.functionName = functionName
        self.invokeArgs = invokeArgs
    }
}

struct InvokeAsyncInputBody: Swift.Equatable {
    let invokeArgs: ClientRuntime.ByteStream?
}

extension InvokeAsyncInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invokeArgs = "InvokeArgs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invokeArgsDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .invokeArgs)
        invokeArgs = invokeArgsDecoded
    }
}

extension InvokeAsyncOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InvokeAsyncOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidRequestContentException" : self = .invalidRequestContentException(try InvalidRequestContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRuntimeException" : self = .invalidRuntimeException(try InvalidRuntimeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InvokeAsyncOutputError: Swift.Error, Swift.Equatable {
    case invalidRequestContentException(InvalidRequestContentException)
    case invalidRuntimeException(InvalidRuntimeException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InvokeAsyncOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        self.status = httpResponse.statusCode.rawValue
    }
}

/// A success response (202 Accepted) indicates that the request is queued for invocation.
@available(*, deprecated)
public struct InvokeAsyncOutputResponse: Swift.Equatable {
    /// The status code.
    public var status: Swift.Int

    public init (
        status: Swift.Int = 0
    )
    {
        self.status = status
    }
}

struct InvokeAsyncOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
}

extension InvokeAsyncOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

public struct InvokeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InvokeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InvokeInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<InvokeOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let payload = input.operationInput.payload {
            let payloaddata = payload
            let payloadbody = ClientRuntime.HttpBody.data(payloaddata)
            input.builder.withBody(payloadbody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InvokeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InvokeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension InvokeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload = "Payload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payload = payload {
            try encodeContainer.encode(payload.base64EncodedString(), forKey: .payload)
        }
    }
}

extension InvokeInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientContext = clientContext {
            items.add(Header(name: "X-Amz-Client-Context", value: Swift.String(clientContext)))
        }
        if let invocationType = invocationType {
            items.add(Header(name: "X-Amz-Invocation-Type", value: Swift.String(invocationType.rawValue)))
        }
        if let logType = logType {
            items.add(Header(name: "X-Amz-Log-Type", value: Swift.String(logType.rawValue)))
        }
        return items
    }
}

extension InvokeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let qualifier = qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension InvokeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/invocations"
    }
}

public struct InvokeInput: Swift.Equatable {
    /// Up to 3583 bytes of base64-encoded data about the invoking client to pass to the function in the context object.
    public var clientContext: Swift.String?
    /// The name of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Choose from the following options.
    ///
    /// * RequestResponse (default) - Invoke the function synchronously. Keep the connection open until the function returns a response or times out. The API response includes the function response and additional data.
    ///
    /// * Event - Invoke the function asynchronously. Send events that fail multiple times to the function's dead-letter queue (if it's configured). The API response only includes a status code.
    ///
    /// * DryRun - Validate parameter values and verify that the user or role has permission to invoke the function.
    public var invocationType: LambdaClientTypes.InvocationType?
    /// Set to Tail to include the execution log in the response. Applies to synchronously invoked functions only.
    public var logType: LambdaClientTypes.LogType?
    /// The JSON that you want to provide to your Lambda function as input. You can enter the JSON directly. For example, --payload '{ "key": "value" }'. You can also specify a file path. For example, --payload file://payload.json.
    public var payload: ClientRuntime.Data?
    /// Specify a version or alias to invoke a published version of the function.
    public var qualifier: Swift.String?

    public init (
        clientContext: Swift.String? = nil,
        functionName: Swift.String? = nil,
        invocationType: LambdaClientTypes.InvocationType? = nil,
        logType: LambdaClientTypes.LogType? = nil,
        payload: ClientRuntime.Data? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.clientContext = clientContext
        self.functionName = functionName
        self.invocationType = invocationType
        self.logType = logType
        self.payload = payload
        self.qualifier = qualifier
    }
}

struct InvokeInputBody: Swift.Equatable {
    let payload: ClientRuntime.Data?
}

extension InvokeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload = "Payload"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension InvokeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InvokeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EC2AccessDeniedException" : self = .eC2AccessDeniedException(try EC2AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EC2ThrottledException" : self = .eC2ThrottledException(try EC2ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EC2UnexpectedException" : self = .eC2UnexpectedException(try EC2UnexpectedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EFSIOException" : self = .eFSIOException(try EFSIOException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EFSMountConnectivityException" : self = .eFSMountConnectivityException(try EFSMountConnectivityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EFSMountFailureException" : self = .eFSMountFailureException(try EFSMountFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EFSMountTimeoutException" : self = .eFSMountTimeoutException(try EFSMountTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ENILimitReachedException" : self = .eNILimitReachedException(try ENILimitReachedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestContentException" : self = .invalidRequestContentException(try InvalidRequestContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRuntimeException" : self = .invalidRuntimeException(try InvalidRuntimeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurityGroupIDException" : self = .invalidSecurityGroupIDException(try InvalidSecurityGroupIDException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnetIDException" : self = .invalidSubnetIDException(try InvalidSubnetIDException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidZipFileException" : self = .invalidZipFileException(try InvalidZipFileException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSAccessDeniedException" : self = .kMSAccessDeniedException(try KMSAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabledException" : self = .kMSDisabledException(try KMSDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFoundException" : self = .kMSNotFoundException(try KMSNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTooLargeException" : self = .requestTooLargeException(try RequestTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotReadyException" : self = .resourceNotReadyException(try ResourceNotReadyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetIPAddressLimitReachedException" : self = .subnetIPAddressLimitReachedException(try SubnetIPAddressLimitReachedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedMediaTypeException" : self = .unsupportedMediaTypeException(try UnsupportedMediaTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InvokeOutputError: Swift.Error, Swift.Equatable {
    case eC2AccessDeniedException(EC2AccessDeniedException)
    case eC2ThrottledException(EC2ThrottledException)
    case eC2UnexpectedException(EC2UnexpectedException)
    case eFSIOException(EFSIOException)
    case eFSMountConnectivityException(EFSMountConnectivityException)
    case eFSMountFailureException(EFSMountFailureException)
    case eFSMountTimeoutException(EFSMountTimeoutException)
    case eNILimitReachedException(ENILimitReachedException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestContentException(InvalidRequestContentException)
    case invalidRuntimeException(InvalidRuntimeException)
    case invalidSecurityGroupIDException(InvalidSecurityGroupIDException)
    case invalidSubnetIDException(InvalidSubnetIDException)
    case invalidZipFileException(InvalidZipFileException)
    case kMSAccessDeniedException(KMSAccessDeniedException)
    case kMSDisabledException(KMSDisabledException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case kMSNotFoundException(KMSNotFoundException)
    case requestTooLargeException(RequestTooLargeException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceNotReadyException(ResourceNotReadyException)
    case serviceException(ServiceException)
    case subnetIPAddressLimitReachedException(SubnetIPAddressLimitReachedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unsupportedMediaTypeException(UnsupportedMediaTypeException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InvokeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let executedVersionHeaderValue = httpResponse.headers.value(for: "X-Amz-Executed-Version") {
            self.executedVersion = executedVersionHeaderValue
        } else {
            self.executedVersion = nil
        }
        if let functionErrorHeaderValue = httpResponse.headers.value(for: "X-Amz-Function-Error") {
            self.functionError = functionErrorHeaderValue
        } else {
            self.functionError = nil
        }
        if let logResultHeaderValue = httpResponse.headers.value(for: "X-Amz-Log-Result") {
            self.logResult = logResultHeaderValue
        } else {
            self.logResult = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.payload = data
        } else {
            self.payload = nil
        }
        self.statusCode = httpResponse.statusCode.rawValue
    }
}

public struct InvokeOutputResponse: Swift.Equatable {
    /// The version of the function that executed. When you invoke a function with an alias, this indicates which version the alias resolved to.
    public var executedVersion: Swift.String?
    /// If present, indicates that an error occurred during function execution. Details about the error are included in the response payload.
    public var functionError: Swift.String?
    /// The last 4 KB of the execution log, which is base64 encoded.
    public var logResult: Swift.String?
    /// The response from the function, or an error object.
    public var payload: ClientRuntime.Data?
    /// The HTTP status code is in the 200 range for a successful request. For the RequestResponse invocation type, this status code is 200. For the Event invocation type, this status code is 202. For the DryRun invocation type, the status code is 204.
    public var statusCode: Swift.Int

    public init (
        executedVersion: Swift.String? = nil,
        functionError: Swift.String? = nil,
        logResult: Swift.String? = nil,
        payload: ClientRuntime.Data? = nil,
        statusCode: Swift.Int = 0
    )
    {
        self.executedVersion = executedVersion
        self.functionError = functionError
        self.logResult = logResult
        self.payload = payload
        self.statusCode = statusCode
    }
}

struct InvokeOutputResponseBody: Swift.Equatable {
    let statusCode: Swift.Int
    let payload: ClientRuntime.Data?
}

extension InvokeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload = "Payload"
        case statusCode = "StatusCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decode(Swift.Int.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension KMSAccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KMSAccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Lambda was unable to decrypt the environment variables because KMS access was denied. Check the Lambda function's KMS permissions.
public struct KMSAccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct KMSAccessDeniedExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension KMSAccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSDisabledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KMSDisabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Lambda was unable to decrypt the environment variables because the KMS key used is disabled. Check the Lambda function's KMS key settings.
public struct KMSDisabledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct KMSDisabledExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension KMSDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSInvalidStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KMSInvalidStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Lambda was unable to decrypt the environment variables because the KMS key used is in an invalid state for Decrypt. Check the function's KMS key settings.
public struct KMSInvalidStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct KMSInvalidStateExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension KMSInvalidStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KMSNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Lambda was unable to decrypt the environment variables because the KMS key was not found. Check the function's KMS key settings.
public struct KMSNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct KMSNotFoundExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension KMSNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes {
    public enum LastUpdateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inprogress
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [LastUpdateStatus] {
            return [
                .failed,
                .inprogress,
                .successful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LastUpdateStatus(rawValue: rawValue) ?? LastUpdateStatus.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes {
    public enum LastUpdateStatusReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enilimitexceeded
        case imageaccessdenied
        case imagedeleted
        case insufficientrolepermissions
        case internalerror
        case invalidconfiguration
        case invalidimage
        case invalidsecuritygroup
        case invalidsubnet
        case subnetoutofipaddresses
        case sdkUnknown(Swift.String)

        public static var allCases: [LastUpdateStatusReasonCode] {
            return [
                .enilimitexceeded,
                .imageaccessdenied,
                .imagedeleted,
                .insufficientrolepermissions,
                .internalerror,
                .invalidconfiguration,
                .invalidimage,
                .invalidsecuritygroup,
                .invalidsubnet,
                .subnetoutofipaddresses,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enilimitexceeded: return "EniLimitExceeded"
            case .imageaccessdenied: return "ImageAccessDenied"
            case .imagedeleted: return "ImageDeleted"
            case .insufficientrolepermissions: return "InsufficientRolePermissions"
            case .internalerror: return "InternalError"
            case .invalidconfiguration: return "InvalidConfiguration"
            case .invalidimage: return "InvalidImage"
            case .invalidsecuritygroup: return "InvalidSecurityGroup"
            case .invalidsubnet: return "InvalidSubnet"
            case .subnetoutofipaddresses: return "SubnetOutOfIPAddresses"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LastUpdateStatusReasonCode(rawValue: rawValue) ?? LastUpdateStatusReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes.Layer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case codeSize = "CodeSize"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if codeSize != 0 {
            try encodeContainer.encode(codeSize, forKey: .codeSize)
        }
        if let signingJobArn = signingJobArn {
            try encodeContainer.encode(signingJobArn, forKey: .signingJobArn)
        }
        if let signingProfileVersionArn = signingProfileVersionArn {
            try encodeContainer.encode(signingProfileVersionArn, forKey: .signingProfileVersionArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let codeSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
    }
}

extension LambdaClientTypes {
    /// An [Lambda layer](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public struct Layer: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the function layer.
        public var arn: Swift.String?
        /// The size of the layer archive in bytes.
        public var codeSize: Swift.Int
        /// The Amazon Resource Name (ARN) of a signing job.
        public var signingJobArn: Swift.String?
        /// The Amazon Resource Name (ARN) for a signing profile version.
        public var signingProfileVersionArn: Swift.String?

        public init (
            arn: Swift.String? = nil,
            codeSize: Swift.Int = 0,
            signingJobArn: Swift.String? = nil,
            signingProfileVersionArn: Swift.String? = nil
        )
        {
            self.arn = arn
            self.codeSize = codeSize
            self.signingJobArn = signingJobArn
            self.signingProfileVersionArn = signingProfileVersionArn
        }
    }

}

extension LambdaClientTypes.LayerVersionContentInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
        case s3ObjectVersion = "S3ObjectVersion"
        case zipFile = "ZipFile"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
        if let s3ObjectVersion = s3ObjectVersion {
            try encodeContainer.encode(s3ObjectVersion, forKey: .s3ObjectVersion)
        }
        if let zipFile = zipFile {
            try encodeContainer.encode(zipFile.base64EncodedString(), forKey: .zipFile)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let s3ObjectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ObjectVersion)
        s3ObjectVersion = s3ObjectVersionDecoded
        let zipFileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .zipFile)
        zipFile = zipFileDecoded
    }
}

extension LambdaClientTypes {
    /// A ZIP archive that contains the contents of an [Lambda layer](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html). You can specify either an Amazon S3 location, or upload a layer archive directly.
    public struct LayerVersionContentInput: Swift.Equatable {
        /// The Amazon S3 bucket of the layer archive.
        public var s3Bucket: Swift.String?
        /// The Amazon S3 key of the layer archive.
        public var s3Key: Swift.String?
        /// For versioned objects, the version of the layer archive object to use.
        public var s3ObjectVersion: Swift.String?
        /// The base64-encoded contents of the layer archive. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for you.
        public var zipFile: ClientRuntime.Data?

        public init (
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil,
            s3ObjectVersion: Swift.String? = nil,
            zipFile: ClientRuntime.Data? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
            self.zipFile = zipFile
        }
    }

}

extension LambdaClientTypes.LayerVersionContentOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case location = "Location"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeSha256 = codeSha256 {
            try encodeContainer.encode(codeSha256, forKey: .codeSha256)
        }
        if codeSize != 0 {
            try encodeContainer.encode(codeSize, forKey: .codeSize)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let signingJobArn = signingJobArn {
            try encodeContainer.encode(signingJobArn, forKey: .signingJobArn)
        }
        if let signingProfileVersionArn = signingProfileVersionArn {
            try encodeContainer.encode(signingProfileVersionArn, forKey: .signingProfileVersionArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let codeSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
    }
}

extension LambdaClientTypes {
    /// Details about a version of an [Lambda layer](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public struct LayerVersionContentOutput: Swift.Equatable {
        /// The SHA-256 hash of the layer archive.
        public var codeSha256: Swift.String?
        /// The size of the layer archive in bytes.
        public var codeSize: Swift.Int
        /// A link to the layer archive in Amazon S3 that is valid for 10 minutes.
        public var location: Swift.String?
        /// The Amazon Resource Name (ARN) of a signing job.
        public var signingJobArn: Swift.String?
        /// The Amazon Resource Name (ARN) for a signing profile version.
        public var signingProfileVersionArn: Swift.String?

        public init (
            codeSha256: Swift.String? = nil,
            codeSize: Swift.Int = 0,
            location: Swift.String? = nil,
            signingJobArn: Swift.String? = nil,
            signingProfileVersionArn: Swift.String? = nil
        )
        {
            self.codeSha256 = codeSha256
            self.codeSize = codeSize
            self.location = location
            self.signingJobArn = signingJobArn
            self.signingProfileVersionArn = signingProfileVersionArn
        }
    }

}

extension LambdaClientTypes.LayerVersionsListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleArchitectures = "CompatibleArchitectures"
        case compatibleRuntimes = "CompatibleRuntimes"
        case createdDate = "CreatedDate"
        case description = "Description"
        case layerVersionArn = "LayerVersionArn"
        case licenseInfo = "LicenseInfo"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleArchitectures = compatibleArchitectures {
            var compatibleArchitecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .compatibleArchitectures)
            for compatiblearchitectures0 in compatibleArchitectures {
                try compatibleArchitecturesContainer.encode(compatiblearchitectures0.rawValue)
            }
        }
        if let compatibleRuntimes = compatibleRuntimes {
            var compatibleRuntimesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .compatibleRuntimes)
            for compatibleruntimes0 in compatibleRuntimes {
                try compatibleRuntimesContainer.encode(compatibleruntimes0.rawValue)
            }
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let layerVersionArn = layerVersionArn {
            try encodeContainer.encode(layerVersionArn, forKey: .layerVersionArn)
        }
        if let licenseInfo = licenseInfo {
            try encodeContainer.encode(licenseInfo, forKey: .licenseInfo)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerVersionArn)
        layerVersionArn = layerVersionArnDecoded
        let versionDecoded = try containerValues.decode(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let compatibleRuntimesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Runtime?].self, forKey: .compatibleRuntimes)
        var compatibleRuntimesDecoded0:[LambdaClientTypes.Runtime]? = nil
        if let compatibleRuntimesContainer = compatibleRuntimesContainer {
            compatibleRuntimesDecoded0 = [LambdaClientTypes.Runtime]()
            for string0 in compatibleRuntimesContainer {
                if let string0 = string0 {
                    compatibleRuntimesDecoded0?.append(string0)
                }
            }
        }
        compatibleRuntimes = compatibleRuntimesDecoded0
        let licenseInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseInfo)
        licenseInfo = licenseInfoDecoded
        let compatibleArchitecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .compatibleArchitectures)
        var compatibleArchitecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let compatibleArchitecturesContainer = compatibleArchitecturesContainer {
            compatibleArchitecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in compatibleArchitecturesContainer {
                if let string0 = string0 {
                    compatibleArchitecturesDecoded0?.append(string0)
                }
            }
        }
        compatibleArchitectures = compatibleArchitecturesDecoded0
    }
}

extension LambdaClientTypes {
    /// Details about a version of an [Lambda layer](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public struct LayerVersionsListItem: Swift.Equatable {
        /// A list of compatible [instruction set architectures](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
        public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
        /// The layer's compatible runtimes.
        public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
        /// The date that the version was created, in ISO 8601 format. For example, 2018-11-27T15:10:45.123+0000.
        public var createdDate: Swift.String?
        /// The description of the version.
        public var description: Swift.String?
        /// The ARN of the layer version.
        public var layerVersionArn: Swift.String?
        /// The layer's open-source license.
        public var licenseInfo: Swift.String?
        /// The version number.
        public var version: Swift.Int

        public init (
            compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
            compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
            createdDate: Swift.String? = nil,
            description: Swift.String? = nil,
            layerVersionArn: Swift.String? = nil,
            licenseInfo: Swift.String? = nil,
            version: Swift.Int = 0
        )
        {
            self.compatibleArchitectures = compatibleArchitectures
            self.compatibleRuntimes = compatibleRuntimes
            self.createdDate = createdDate
            self.description = description
            self.layerVersionArn = layerVersionArn
            self.licenseInfo = licenseInfo
            self.version = version
        }
    }

}

extension LambdaClientTypes.LayersListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case latestMatchingVersion = "LatestMatchingVersion"
        case layerArn = "LayerArn"
        case layerName = "LayerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let latestMatchingVersion = latestMatchingVersion {
            try encodeContainer.encode(latestMatchingVersion, forKey: .latestMatchingVersion)
        }
        if let layerArn = layerArn {
            try encodeContainer.encode(layerArn, forKey: .layerArn)
        }
        if let layerName = layerName {
            try encodeContainer.encode(layerName, forKey: .layerName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerName)
        layerName = layerNameDecoded
        let layerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerArn)
        layerArn = layerArnDecoded
        let latestMatchingVersionDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LayerVersionsListItem.self, forKey: .latestMatchingVersion)
        latestMatchingVersion = latestMatchingVersionDecoded
    }
}

extension LambdaClientTypes {
    /// Details about an [Lambda layer](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public struct LayersListItem: Swift.Equatable {
        /// The newest version of the layer.
        public var latestMatchingVersion: LambdaClientTypes.LayerVersionsListItem?
        /// The Amazon Resource Name (ARN) of the function layer.
        public var layerArn: Swift.String?
        /// The name of the layer.
        public var layerName: Swift.String?

        public init (
            latestMatchingVersion: LambdaClientTypes.LayerVersionsListItem? = nil,
            layerArn: Swift.String? = nil,
            layerName: Swift.String? = nil
        )
        {
            self.latestMatchingVersion = latestMatchingVersion
            self.layerArn = layerArn
            self.layerName = layerName
        }
    }

}

extension ListAliasesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let functionVersion = functionVersion {
            let functionVersionQueryItem = ClientRuntime.URLQueryItem(name: "FunctionVersion".urlPercentEncoding(), value: Swift.String(functionVersion).urlPercentEncoding())
            items.append(functionVersionQueryItem)
        }
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListAliasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases"
    }
}

public struct ListAliasesInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a function version to only list aliases that invoke that version.
    public var functionVersion: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// Limit the number of aliases returned.
    public var maxItems: Swift.Int?

    public init (
        functionName: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.functionName = functionName
        self.functionVersion = functionVersion
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListAliasesInputBody: Swift.Equatable {
}

extension ListAliasesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAliasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAliasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAliasesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAliasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAliasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aliases = output.aliases
            self.nextMarker = output.nextMarker
        } else {
            self.aliases = nil
            self.nextMarker = nil
        }
    }
}

public struct ListAliasesOutputResponse: Swift.Equatable {
    /// A list of aliases.
    public var aliases: [LambdaClientTypes.AliasConfiguration]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init (
        aliases: [LambdaClientTypes.AliasConfiguration]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.aliases = aliases
        self.nextMarker = nextMarker
    }
}

struct ListAliasesOutputResponseBody: Swift.Equatable {
    let nextMarker: Swift.String?
    let aliases: [LambdaClientTypes.AliasConfiguration]?
}

extension ListAliasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases = "Aliases"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let aliasesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.AliasConfiguration?].self, forKey: .aliases)
        var aliasesDecoded0:[LambdaClientTypes.AliasConfiguration]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [LambdaClientTypes.AliasConfiguration]()
            for structure0 in aliasesContainer {
                if let structure0 = structure0 {
                    aliasesDecoded0?.append(structure0)
                }
            }
        }
        aliases = aliasesDecoded0
    }
}

extension ListCodeSigningConfigsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListCodeSigningConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-04-22/code-signing-configs"
    }
}

public struct ListCodeSigningConfigsInput: Swift.Equatable {
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// Maximum number of items to return.
    public var maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListCodeSigningConfigsInputBody: Swift.Equatable {
}

extension ListCodeSigningConfigsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCodeSigningConfigsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCodeSigningConfigsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCodeSigningConfigsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCodeSigningConfigsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCodeSigningConfigsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.codeSigningConfigs = output.codeSigningConfigs
            self.nextMarker = output.nextMarker
        } else {
            self.codeSigningConfigs = nil
            self.nextMarker = nil
        }
    }
}

public struct ListCodeSigningConfigsOutputResponse: Swift.Equatable {
    /// The code signing configurations
    public var codeSigningConfigs: [LambdaClientTypes.CodeSigningConfig]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init (
        codeSigningConfigs: [LambdaClientTypes.CodeSigningConfig]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.codeSigningConfigs = codeSigningConfigs
        self.nextMarker = nextMarker
    }
}

struct ListCodeSigningConfigsOutputResponseBody: Swift.Equatable {
    let nextMarker: Swift.String?
    let codeSigningConfigs: [LambdaClientTypes.CodeSigningConfig]?
}

extension ListCodeSigningConfigsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfigs = "CodeSigningConfigs"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let codeSigningConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.CodeSigningConfig?].self, forKey: .codeSigningConfigs)
        var codeSigningConfigsDecoded0:[LambdaClientTypes.CodeSigningConfig]? = nil
        if let codeSigningConfigsContainer = codeSigningConfigsContainer {
            codeSigningConfigsDecoded0 = [LambdaClientTypes.CodeSigningConfig]()
            for structure0 in codeSigningConfigsContainer {
                if let structure0 = structure0 {
                    codeSigningConfigsDecoded0?.append(structure0)
                }
            }
        }
        codeSigningConfigs = codeSigningConfigsDecoded0
    }
}

extension ListEventSourceMappingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let functionName = functionName {
            let functionNameQueryItem = ClientRuntime.URLQueryItem(name: "FunctionName".urlPercentEncoding(), value: Swift.String(functionName).urlPercentEncoding())
            items.append(functionNameQueryItem)
        }
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        if let eventSourceArn = eventSourceArn {
            let eventSourceArnQueryItem = ClientRuntime.URLQueryItem(name: "EventSourceArn".urlPercentEncoding(), value: Swift.String(eventSourceArn).urlPercentEncoding())
            items.append(eventSourceArnQueryItem)
        }
        return items
    }
}

extension ListEventSourceMappingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2015-03-31/event-source-mappings"
    }
}

public struct ListEventSourceMappingsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the event source.
    ///
    /// * Amazon Kinesis - The ARN of the data stream or a stream consumer.
    ///
    /// * Amazon DynamoDB Streams - The ARN of the stream.
    ///
    /// * Amazon Simple Queue Service - The ARN of the queue.
    ///
    /// * Amazon Managed Streaming for Apache Kafka - The ARN of the cluster.
    public var eventSourceArn: Swift.String?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Version or Alias ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64 characters in length.
    public var functionName: Swift.String?
    /// A pagination token returned by a previous call.
    public var marker: Swift.String?
    /// The maximum number of event source mappings to return. Note that ListEventSourceMappings returns a maximum of 100 items in each response, even if you set the number higher.
    public var maxItems: Swift.Int?

    public init (
        eventSourceArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.eventSourceArn = eventSourceArn
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListEventSourceMappingsInputBody: Swift.Equatable {
}

extension ListEventSourceMappingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListEventSourceMappingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventSourceMappingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEventSourceMappingsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventSourceMappingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEventSourceMappingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSourceMappings = output.eventSourceMappings
            self.nextMarker = output.nextMarker
        } else {
            self.eventSourceMappings = nil
            self.nextMarker = nil
        }
    }
}

public struct ListEventSourceMappingsOutputResponse: Swift.Equatable {
    /// A list of event source mappings.
    public var eventSourceMappings: [LambdaClientTypes.EventSourceMappingConfiguration]?
    /// A pagination token that's returned when the response doesn't contain all event source mappings.
    public var nextMarker: Swift.String?

    public init (
        eventSourceMappings: [LambdaClientTypes.EventSourceMappingConfiguration]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.eventSourceMappings = eventSourceMappings
        self.nextMarker = nextMarker
    }
}

struct ListEventSourceMappingsOutputResponseBody: Swift.Equatable {
    let nextMarker: Swift.String?
    let eventSourceMappings: [LambdaClientTypes.EventSourceMappingConfiguration]?
}

extension ListEventSourceMappingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSourceMappings = "EventSourceMappings"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let eventSourceMappingsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.EventSourceMappingConfiguration?].self, forKey: .eventSourceMappings)
        var eventSourceMappingsDecoded0:[LambdaClientTypes.EventSourceMappingConfiguration]? = nil
        if let eventSourceMappingsContainer = eventSourceMappingsContainer {
            eventSourceMappingsDecoded0 = [LambdaClientTypes.EventSourceMappingConfiguration]()
            for structure0 in eventSourceMappingsContainer {
                if let structure0 = structure0 {
                    eventSourceMappingsDecoded0?.append(structure0)
                }
            }
        }
        eventSourceMappings = eventSourceMappingsDecoded0
    }
}

extension ListFunctionEventInvokeConfigsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListFunctionEventInvokeConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config/list"
    }
}

public struct ListFunctionEventInvokeConfigsInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - my-function.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// The maximum number of configurations to return.
    public var maxItems: Swift.Int?

    public init (
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListFunctionEventInvokeConfigsInputBody: Swift.Equatable {
}

extension ListFunctionEventInvokeConfigsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFunctionEventInvokeConfigsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFunctionEventInvokeConfigsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFunctionEventInvokeConfigsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFunctionEventInvokeConfigsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFunctionEventInvokeConfigsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.functionEventInvokeConfigs = output.functionEventInvokeConfigs
            self.nextMarker = output.nextMarker
        } else {
            self.functionEventInvokeConfigs = nil
            self.nextMarker = nil
        }
    }
}

public struct ListFunctionEventInvokeConfigsOutputResponse: Swift.Equatable {
    /// A list of configurations.
    public var functionEventInvokeConfigs: [LambdaClientTypes.FunctionEventInvokeConfig]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init (
        functionEventInvokeConfigs: [LambdaClientTypes.FunctionEventInvokeConfig]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.functionEventInvokeConfigs = functionEventInvokeConfigs
        self.nextMarker = nextMarker
    }
}

struct ListFunctionEventInvokeConfigsOutputResponseBody: Swift.Equatable {
    let functionEventInvokeConfigs: [LambdaClientTypes.FunctionEventInvokeConfig]?
    let nextMarker: Swift.String?
}

extension ListFunctionEventInvokeConfigsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionEventInvokeConfigs = "FunctionEventInvokeConfigs"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionEventInvokeConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionEventInvokeConfig?].self, forKey: .functionEventInvokeConfigs)
        var functionEventInvokeConfigsDecoded0:[LambdaClientTypes.FunctionEventInvokeConfig]? = nil
        if let functionEventInvokeConfigsContainer = functionEventInvokeConfigsContainer {
            functionEventInvokeConfigsDecoded0 = [LambdaClientTypes.FunctionEventInvokeConfig]()
            for structure0 in functionEventInvokeConfigsContainer {
                if let structure0 = structure0 {
                    functionEventInvokeConfigsDecoded0?.append(structure0)
                }
            }
        }
        functionEventInvokeConfigs = functionEventInvokeConfigsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension ListFunctionsByCodeSigningConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListFunctionsByCodeSigningConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let codeSigningConfigArn = codeSigningConfigArn else {
            return nil
        }
        return "/2020-04-22/code-signing-configs/\(codeSigningConfigArn.urlPercentEncoding())/functions"
    }
}

public struct ListFunctionsByCodeSigningConfigInput: Swift.Equatable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// Maximum number of items to return.
    public var maxItems: Swift.Int?

    public init (
        codeSigningConfigArn: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListFunctionsByCodeSigningConfigInputBody: Swift.Equatable {
}

extension ListFunctionsByCodeSigningConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFunctionsByCodeSigningConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFunctionsByCodeSigningConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFunctionsByCodeSigningConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFunctionsByCodeSigningConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFunctionsByCodeSigningConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.functionArns = output.functionArns
            self.nextMarker = output.nextMarker
        } else {
            self.functionArns = nil
            self.nextMarker = nil
        }
    }
}

public struct ListFunctionsByCodeSigningConfigOutputResponse: Swift.Equatable {
    /// The function ARNs.
    public var functionArns: [Swift.String]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init (
        functionArns: [Swift.String]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.functionArns = functionArns
        self.nextMarker = nextMarker
    }
}

struct ListFunctionsByCodeSigningConfigOutputResponseBody: Swift.Equatable {
    let nextMarker: Swift.String?
    let functionArns: [Swift.String]?
}

extension ListFunctionsByCodeSigningConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionArns = "FunctionArns"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let functionArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .functionArns)
        var functionArnsDecoded0:[Swift.String]? = nil
        if let functionArnsContainer = functionArnsContainer {
            functionArnsDecoded0 = [Swift.String]()
            for string0 in functionArnsContainer {
                if let string0 = string0 {
                    functionArnsDecoded0?.append(string0)
                }
            }
        }
        functionArns = functionArnsDecoded0
    }
}

extension ListFunctionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let masterRegion = masterRegion {
            let masterRegionQueryItem = ClientRuntime.URLQueryItem(name: "MasterRegion".urlPercentEncoding(), value: Swift.String(masterRegion).urlPercentEncoding())
            items.append(masterRegionQueryItem)
        }
        if let functionVersion = functionVersion {
            let functionVersionQueryItem = ClientRuntime.URLQueryItem(name: "FunctionVersion".urlPercentEncoding(), value: Swift.String(functionVersion.rawValue).urlPercentEncoding())
            items.append(functionVersionQueryItem)
        }
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListFunctionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2015-03-31/functions"
    }
}

public struct ListFunctionsInput: Swift.Equatable {
    /// Set to ALL to include entries for all published versions of each function.
    public var functionVersion: LambdaClientTypes.FunctionVersion?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// For Lambda@Edge functions, the Amazon Web Services Region of the master function. For example, us-east-1 filters the list of functions to only include Lambda@Edge functions replicated from a master function in US East (N. Virginia). If specified, you must set FunctionVersion to ALL.
    public var masterRegion: Swift.String?
    /// The maximum number of functions to return in the response. Note that ListFunctions returns a maximum of 50 items in each response, even if you set the number higher.
    public var maxItems: Swift.Int?

    public init (
        functionVersion: LambdaClientTypes.FunctionVersion? = nil,
        marker: Swift.String? = nil,
        masterRegion: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.functionVersion = functionVersion
        self.marker = marker
        self.masterRegion = masterRegion
        self.maxItems = maxItems
    }
}

struct ListFunctionsInputBody: Swift.Equatable {
}

extension ListFunctionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFunctionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFunctionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFunctionsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFunctionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFunctionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.functions = output.functions
            self.nextMarker = output.nextMarker
        } else {
            self.functions = nil
            self.nextMarker = nil
        }
    }
}

/// A list of Lambda functions.
public struct ListFunctionsOutputResponse: Swift.Equatable {
    /// A list of Lambda functions.
    public var functions: [LambdaClientTypes.FunctionConfiguration]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init (
        functions: [LambdaClientTypes.FunctionConfiguration]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.functions = functions
        self.nextMarker = nextMarker
    }
}

struct ListFunctionsOutputResponseBody: Swift.Equatable {
    let nextMarker: Swift.String?
    let functions: [LambdaClientTypes.FunctionConfiguration]?
}

extension ListFunctionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functions = "Functions"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let functionsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionConfiguration?].self, forKey: .functions)
        var functionsDecoded0:[LambdaClientTypes.FunctionConfiguration]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [LambdaClientTypes.FunctionConfiguration]()
            for structure0 in functionsContainer {
                if let structure0 = structure0 {
                    functionsDecoded0?.append(structure0)
                }
            }
        }
        functions = functionsDecoded0
    }
}

extension ListLayerVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let compatibleRuntime = compatibleRuntime {
            let compatibleRuntimeQueryItem = ClientRuntime.URLQueryItem(name: "CompatibleRuntime".urlPercentEncoding(), value: Swift.String(compatibleRuntime.rawValue).urlPercentEncoding())
            items.append(compatibleRuntimeQueryItem)
        }
        if let compatibleArchitecture = compatibleArchitecture {
            let compatibleArchitectureQueryItem = ClientRuntime.URLQueryItem(name: "CompatibleArchitecture".urlPercentEncoding(), value: Swift.String(compatibleArchitecture.rawValue).urlPercentEncoding())
            items.append(compatibleArchitectureQueryItem)
        }
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListLayerVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let layerName = layerName else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions"
    }
}

public struct ListLayerVersionsInput: Swift.Equatable {
    /// The compatible [instruction set architecture](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitecture: LambdaClientTypes.Architecture?
    /// A runtime identifier. For example, go1.x.
    public var compatibleRuntime: LambdaClientTypes.Runtime?
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// A pagination token returned by a previous call.
    public var marker: Swift.String?
    /// The maximum number of versions to return.
    public var maxItems: Swift.Int?

    public init (
        compatibleArchitecture: LambdaClientTypes.Architecture? = nil,
        compatibleRuntime: LambdaClientTypes.Runtime? = nil,
        layerName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.compatibleArchitecture = compatibleArchitecture
        self.compatibleRuntime = compatibleRuntime
        self.layerName = layerName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListLayerVersionsInputBody: Swift.Equatable {
}

extension ListLayerVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLayerVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLayerVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLayerVersionsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLayerVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLayerVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.layerVersions = output.layerVersions
            self.nextMarker = output.nextMarker
        } else {
            self.layerVersions = nil
            self.nextMarker = nil
        }
    }
}

public struct ListLayerVersionsOutputResponse: Swift.Equatable {
    /// A list of versions.
    public var layerVersions: [LambdaClientTypes.LayerVersionsListItem]?
    /// A pagination token returned when the response doesn't contain all versions.
    public var nextMarker: Swift.String?

    public init (
        layerVersions: [LambdaClientTypes.LayerVersionsListItem]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.layerVersions = layerVersions
        self.nextMarker = nextMarker
    }
}

struct ListLayerVersionsOutputResponseBody: Swift.Equatable {
    let nextMarker: Swift.String?
    let layerVersions: [LambdaClientTypes.LayerVersionsListItem]?
}

extension ListLayerVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerVersions = "LayerVersions"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let layerVersionsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.LayerVersionsListItem?].self, forKey: .layerVersions)
        var layerVersionsDecoded0:[LambdaClientTypes.LayerVersionsListItem]? = nil
        if let layerVersionsContainer = layerVersionsContainer {
            layerVersionsDecoded0 = [LambdaClientTypes.LayerVersionsListItem]()
            for structure0 in layerVersionsContainer {
                if let structure0 = structure0 {
                    layerVersionsDecoded0?.append(structure0)
                }
            }
        }
        layerVersions = layerVersionsDecoded0
    }
}

extension ListLayersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let compatibleRuntime = compatibleRuntime {
            let compatibleRuntimeQueryItem = ClientRuntime.URLQueryItem(name: "CompatibleRuntime".urlPercentEncoding(), value: Swift.String(compatibleRuntime.rawValue).urlPercentEncoding())
            items.append(compatibleRuntimeQueryItem)
        }
        if let compatibleArchitecture = compatibleArchitecture {
            let compatibleArchitectureQueryItem = ClientRuntime.URLQueryItem(name: "CompatibleArchitecture".urlPercentEncoding(), value: Swift.String(compatibleArchitecture.rawValue).urlPercentEncoding())
            items.append(compatibleArchitectureQueryItem)
        }
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListLayersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2018-10-31/layers"
    }
}

public struct ListLayersInput: Swift.Equatable {
    /// The compatible [instruction set architecture](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitecture: LambdaClientTypes.Architecture?
    /// A runtime identifier. For example, go1.x.
    public var compatibleRuntime: LambdaClientTypes.Runtime?
    /// A pagination token returned by a previous call.
    public var marker: Swift.String?
    /// The maximum number of layers to return.
    public var maxItems: Swift.Int?

    public init (
        compatibleArchitecture: LambdaClientTypes.Architecture? = nil,
        compatibleRuntime: LambdaClientTypes.Runtime? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.compatibleArchitecture = compatibleArchitecture
        self.compatibleRuntime = compatibleRuntime
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListLayersInputBody: Swift.Equatable {
}

extension ListLayersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLayersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLayersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLayersOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLayersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLayersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.layers = output.layers
            self.nextMarker = output.nextMarker
        } else {
            self.layers = nil
            self.nextMarker = nil
        }
    }
}

public struct ListLayersOutputResponse: Swift.Equatable {
    /// A list of function layers.
    public var layers: [LambdaClientTypes.LayersListItem]?
    /// A pagination token returned when the response doesn't contain all layers.
    public var nextMarker: Swift.String?

    public init (
        layers: [LambdaClientTypes.LayersListItem]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.layers = layers
        self.nextMarker = nextMarker
    }
}

struct ListLayersOutputResponseBody: Swift.Equatable {
    let nextMarker: Swift.String?
    let layers: [LambdaClientTypes.LayersListItem]?
}

extension ListLayersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layers = "Layers"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let layersContainer = try containerValues.decodeIfPresent([LambdaClientTypes.LayersListItem?].self, forKey: .layers)
        var layersDecoded0:[LambdaClientTypes.LayersListItem]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [LambdaClientTypes.LayersListItem]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
    }
}

extension ListProvisionedConcurrencyConfigsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "List", value: "ALL"))
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListProvisionedConcurrencyConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2019-09-30/functions/\(functionName.urlPercentEncoding())/provisioned-concurrency"
    }
}

public struct ListProvisionedConcurrencyConfigsInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - my-function.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// Specify a number to limit the number of configurations returned.
    public var maxItems: Swift.Int?

    public init (
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListProvisionedConcurrencyConfigsInputBody: Swift.Equatable {
}

extension ListProvisionedConcurrencyConfigsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListProvisionedConcurrencyConfigsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProvisionedConcurrencyConfigsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProvisionedConcurrencyConfigsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProvisionedConcurrencyConfigsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProvisionedConcurrencyConfigsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextMarker = output.nextMarker
            self.provisionedConcurrencyConfigs = output.provisionedConcurrencyConfigs
        } else {
            self.nextMarker = nil
            self.provisionedConcurrencyConfigs = nil
        }
    }
}

public struct ListProvisionedConcurrencyConfigsOutputResponse: Swift.Equatable {
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?
    /// A list of provisioned concurrency configurations.
    public var provisionedConcurrencyConfigs: [LambdaClientTypes.ProvisionedConcurrencyConfigListItem]?

    public init (
        nextMarker: Swift.String? = nil,
        provisionedConcurrencyConfigs: [LambdaClientTypes.ProvisionedConcurrencyConfigListItem]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.provisionedConcurrencyConfigs = provisionedConcurrencyConfigs
    }
}

struct ListProvisionedConcurrencyConfigsOutputResponseBody: Swift.Equatable {
    let provisionedConcurrencyConfigs: [LambdaClientTypes.ProvisionedConcurrencyConfigListItem]?
    let nextMarker: Swift.String?
}

extension ListProvisionedConcurrencyConfigsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextMarker = "NextMarker"
        case provisionedConcurrencyConfigs = "ProvisionedConcurrencyConfigs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedConcurrencyConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.ProvisionedConcurrencyConfigListItem?].self, forKey: .provisionedConcurrencyConfigs)
        var provisionedConcurrencyConfigsDecoded0:[LambdaClientTypes.ProvisionedConcurrencyConfigListItem]? = nil
        if let provisionedConcurrencyConfigsContainer = provisionedConcurrencyConfigsContainer {
            provisionedConcurrencyConfigsDecoded0 = [LambdaClientTypes.ProvisionedConcurrencyConfigListItem]()
            for structure0 in provisionedConcurrencyConfigsContainer {
                if let structure0 = structure0 {
                    provisionedConcurrencyConfigsDecoded0?.append(structure0)
                }
            }
        }
        provisionedConcurrencyConfigs = provisionedConcurrencyConfigsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension ListTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resource = resource else {
            return nil
        }
        return "/2017-03-31/tags/\(resource.urlPercentEncoding())"
    }
}

public struct ListTagsInput: Swift.Equatable {
    /// The function's Amazon Resource Name (ARN). Note: Lambda does not support adding tags to aliases or versions.
    /// This member is required.
    public var resource: Swift.String?

    public init (
        resource: Swift.String? = nil
    )
    {
        self.resource = resource
    }
}

struct ListTagsInputBody: Swift.Equatable {
}

extension ListTagsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsOutputResponse: Swift.Equatable {
    /// The function's tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListVersionsByFunctionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListVersionsByFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/versions"
    }
}

public struct ListVersionsByFunctionInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// The maximum number of versions to return. Note that ListVersionsByFunction returns a maximum of 50 items in each response, even if you set the number higher.
    public var maxItems: Swift.Int?

    public init (
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListVersionsByFunctionInputBody: Swift.Equatable {
}

extension ListVersionsByFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListVersionsByFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVersionsByFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVersionsByFunctionOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVersionsByFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListVersionsByFunctionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextMarker = output.nextMarker
            self.versions = output.versions
        } else {
            self.nextMarker = nil
            self.versions = nil
        }
    }
}

public struct ListVersionsByFunctionOutputResponse: Swift.Equatable {
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?
    /// A list of Lambda function versions.
    public var versions: [LambdaClientTypes.FunctionConfiguration]?

    public init (
        nextMarker: Swift.String? = nil,
        versions: [LambdaClientTypes.FunctionConfiguration]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.versions = versions
    }
}

struct ListVersionsByFunctionOutputResponseBody: Swift.Equatable {
    let nextMarker: Swift.String?
    let versions: [LambdaClientTypes.FunctionConfiguration]?
}

extension ListVersionsByFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextMarker = "NextMarker"
        case versions = "Versions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let versionsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionConfiguration?].self, forKey: .versions)
        var versionsDecoded0:[LambdaClientTypes.FunctionConfiguration]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [LambdaClientTypes.FunctionConfiguration]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension LambdaClientTypes {
    public enum LogType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case tail
        case sdkUnknown(Swift.String)

        public static var allCases: [LogType] {
            return [
                .none,
                .tail,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "None"
            case .tail: return "Tail"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogType(rawValue: rawValue) ?? LogType.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes.OnFailure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension LambdaClientTypes {
    /// A destination for events that failed processing.
    public struct OnFailure: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the destination resource.
        public var destination: Swift.String?

        public init (
            destination: Swift.String? = nil
        )
        {
            self.destination = destination
        }
    }

}

extension LambdaClientTypes.OnSuccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension LambdaClientTypes {
    /// A destination for events that were processed successfully.
    public struct OnSuccess: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the destination resource.
        public var destination: Swift.String?

        public init (
            destination: Swift.String? = nil
        )
        {
            self.destination = destination
        }
    }

}

extension LambdaClientTypes {
    public enum PackageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case image
        case zip
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageType] {
            return [
                .image,
                .zip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .image: return "Image"
            case .zip: return "Zip"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageType(rawValue: rawValue) ?? PackageType.sdkUnknown(rawValue)
        }
    }
}

extension PolicyLengthExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PolicyLengthExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The permissions policy for the resource is too large. [Learn more](https://docs.aws.amazon.com/lambda/latest/dg/limits.html)
public struct PolicyLengthExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct PolicyLengthExceededExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension PolicyLengthExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PreconditionFailedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PreconditionFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The RevisionId provided does not match the latest RevisionId for the Lambda function or alias. Call the GetFunction or the GetAlias API to retrieve the latest RevisionId for your resource.
public struct PreconditionFailedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The exception message.
    public var message: Swift.String?
    /// The exception type.
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct PreconditionFailedExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension PreconditionFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes.ProvisionedConcurrencyConfigListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedProvisionedConcurrentExecutions = "AllocatedProvisionedConcurrentExecutions"
        case availableProvisionedConcurrentExecutions = "AvailableProvisionedConcurrentExecutions"
        case functionArn = "FunctionArn"
        case lastModified = "LastModified"
        case requestedProvisionedConcurrentExecutions = "RequestedProvisionedConcurrentExecutions"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions {
            try encodeContainer.encode(allocatedProvisionedConcurrentExecutions, forKey: .allocatedProvisionedConcurrentExecutions)
        }
        if let availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions {
            try encodeContainer.encode(availableProvisionedConcurrentExecutions, forKey: .availableProvisionedConcurrentExecutions)
        }
        if let functionArn = functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified, forKey: .lastModified)
        }
        if let requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions {
            try encodeContainer.encode(requestedProvisionedConcurrentExecutions, forKey: .requestedProvisionedConcurrentExecutions)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let requestedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .requestedProvisionedConcurrentExecutions)
        requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutionsDecoded
        let availableProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .availableProvisionedConcurrentExecutions)
        availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutionsDecoded
        let allocatedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedProvisionedConcurrentExecutions)
        allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ProvisionedConcurrencyStatusEnum.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension LambdaClientTypes {
    /// Details about the provisioned concurrency configuration for a function alias or version.
    public struct ProvisionedConcurrencyConfigListItem: Swift.Equatable {
        /// The amount of provisioned concurrency allocated.
        public var allocatedProvisionedConcurrentExecutions: Swift.Int?
        /// The amount of provisioned concurrency available.
        public var availableProvisionedConcurrentExecutions: Swift.Int?
        /// The Amazon Resource Name (ARN) of the alias or version.
        public var functionArn: Swift.String?
        /// The date and time that a user last updated the configuration, in [ISO 8601 format](https://www.iso.org/iso-8601-date-and-time-format.html).
        public var lastModified: Swift.String?
        /// The amount of provisioned concurrency requested.
        public var requestedProvisionedConcurrentExecutions: Swift.Int?
        /// The status of the allocation process.
        public var status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum?
        /// For failed allocations, the reason that provisioned concurrency could not be allocated.
        public var statusReason: Swift.String?

        public init (
            allocatedProvisionedConcurrentExecutions: Swift.Int? = nil,
            availableProvisionedConcurrentExecutions: Swift.Int? = nil,
            functionArn: Swift.String? = nil,
            lastModified: Swift.String? = nil,
            requestedProvisionedConcurrentExecutions: Swift.Int? = nil,
            status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
            self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
            self.functionArn = functionArn
            self.lastModified = lastModified
            self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension ProvisionedConcurrencyConfigNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ProvisionedConcurrencyConfigNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified configuration does not exist.
public struct ProvisionedConcurrencyConfigNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct ProvisionedConcurrencyConfigNotFoundExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension ProvisionedConcurrencyConfigNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes {
    public enum ProvisionedConcurrencyStatusEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedConcurrencyStatusEnum] {
            return [
                .failed,
                .inProgress,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisionedConcurrencyStatusEnum(rawValue: rawValue) ?? ProvisionedConcurrencyStatusEnum.sdkUnknown(rawValue)
        }
    }
}

extension PublishLayerVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleArchitectures = "CompatibleArchitectures"
        case compatibleRuntimes = "CompatibleRuntimes"
        case content = "Content"
        case description = "Description"
        case licenseInfo = "LicenseInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleArchitectures = compatibleArchitectures {
            var compatibleArchitecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .compatibleArchitectures)
            for compatiblearchitectures0 in compatibleArchitectures {
                try compatibleArchitecturesContainer.encode(compatiblearchitectures0.rawValue)
            }
        }
        if let compatibleRuntimes = compatibleRuntimes {
            var compatibleRuntimesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .compatibleRuntimes)
            for compatibleruntimes0 in compatibleRuntimes {
                try compatibleRuntimesContainer.encode(compatibleruntimes0.rawValue)
            }
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let licenseInfo = licenseInfo {
            try encodeContainer.encode(licenseInfo, forKey: .licenseInfo)
        }
    }
}

extension PublishLayerVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let layerName = layerName else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions"
    }
}

public struct PublishLayerVersionInput: Swift.Equatable {
    /// A list of compatible [instruction set architectures](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
    /// A list of compatible [function runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Used for filtering with [ListLayers] and [ListLayerVersions].
    public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
    /// The function layer archive.
    /// This member is required.
    public var content: LambdaClientTypes.LayerVersionContentInput?
    /// The description of the version.
    public var description: Swift.String?
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// The layer's software license. It can be any of the following:
    ///
    /// * An [SPDX license identifier](https://spdx.org/licenses/). For example, MIT.
    ///
    /// * The URL of a license hosted on the internet. For example, https://opensource.org/licenses/MIT.
    ///
    /// * The full text of the license.
    public var licenseInfo: Swift.String?

    public init (
        compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
        compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
        content: LambdaClientTypes.LayerVersionContentInput? = nil,
        description: Swift.String? = nil,
        layerName: Swift.String? = nil,
        licenseInfo: Swift.String? = nil
    )
    {
        self.compatibleArchitectures = compatibleArchitectures
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.description = description
        self.layerName = layerName
        self.licenseInfo = licenseInfo
    }
}

struct PublishLayerVersionInputBody: Swift.Equatable {
    let description: Swift.String?
    let content: LambdaClientTypes.LayerVersionContentInput?
    let compatibleRuntimes: [LambdaClientTypes.Runtime]?
    let licenseInfo: Swift.String?
    let compatibleArchitectures: [LambdaClientTypes.Architecture]?
}

extension PublishLayerVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleArchitectures = "CompatibleArchitectures"
        case compatibleRuntimes = "CompatibleRuntimes"
        case content = "Content"
        case description = "Description"
        case licenseInfo = "LicenseInfo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let contentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LayerVersionContentInput.self, forKey: .content)
        content = contentDecoded
        let compatibleRuntimesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Runtime?].self, forKey: .compatibleRuntimes)
        var compatibleRuntimesDecoded0:[LambdaClientTypes.Runtime]? = nil
        if let compatibleRuntimesContainer = compatibleRuntimesContainer {
            compatibleRuntimesDecoded0 = [LambdaClientTypes.Runtime]()
            for string0 in compatibleRuntimesContainer {
                if let string0 = string0 {
                    compatibleRuntimesDecoded0?.append(string0)
                }
            }
        }
        compatibleRuntimes = compatibleRuntimesDecoded0
        let licenseInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseInfo)
        licenseInfo = licenseInfoDecoded
        let compatibleArchitecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .compatibleArchitectures)
        var compatibleArchitecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let compatibleArchitecturesContainer = compatibleArchitecturesContainer {
            compatibleArchitecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in compatibleArchitecturesContainer {
                if let string0 = string0 {
                    compatibleArchitecturesDecoded0?.append(string0)
                }
            }
        }
        compatibleArchitectures = compatibleArchitecturesDecoded0
    }
}

extension PublishLayerVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PublishLayerVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CodeStorageExceededException" : self = .codeStorageExceededException(try CodeStorageExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PublishLayerVersionOutputError: Swift.Error, Swift.Equatable {
    case codeStorageExceededException(CodeStorageExceededException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PublishLayerVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PublishLayerVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.compatibleArchitectures = output.compatibleArchitectures
            self.compatibleRuntimes = output.compatibleRuntimes
            self.content = output.content
            self.createdDate = output.createdDate
            self.description = output.description
            self.layerArn = output.layerArn
            self.layerVersionArn = output.layerVersionArn
            self.licenseInfo = output.licenseInfo
            self.version = output.version
        } else {
            self.compatibleArchitectures = nil
            self.compatibleRuntimes = nil
            self.content = nil
            self.createdDate = nil
            self.description = nil
            self.layerArn = nil
            self.layerVersionArn = nil
            self.licenseInfo = nil
            self.version = 0
        }
    }
}

public struct PublishLayerVersionOutputResponse: Swift.Equatable {
    /// A list of compatible [instruction set architectures](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
    /// The layer's compatible runtimes.
    public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
    /// Details about the layer version.
    public var content: LambdaClientTypes.LayerVersionContentOutput?
    /// The date that the layer version was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var createdDate: Swift.String?
    /// The description of the version.
    public var description: Swift.String?
    /// The ARN of the layer.
    public var layerArn: Swift.String?
    /// The ARN of the layer version.
    public var layerVersionArn: Swift.String?
    /// The layer's software license.
    public var licenseInfo: Swift.String?
    /// The version number.
    public var version: Swift.Int

    public init (
        compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
        compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
        content: LambdaClientTypes.LayerVersionContentOutput? = nil,
        createdDate: Swift.String? = nil,
        description: Swift.String? = nil,
        layerArn: Swift.String? = nil,
        layerVersionArn: Swift.String? = nil,
        licenseInfo: Swift.String? = nil,
        version: Swift.Int = 0
    )
    {
        self.compatibleArchitectures = compatibleArchitectures
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.createdDate = createdDate
        self.description = description
        self.layerArn = layerArn
        self.layerVersionArn = layerVersionArn
        self.licenseInfo = licenseInfo
        self.version = version
    }
}

struct PublishLayerVersionOutputResponseBody: Swift.Equatable {
    let content: LambdaClientTypes.LayerVersionContentOutput?
    let layerArn: Swift.String?
    let layerVersionArn: Swift.String?
    let description: Swift.String?
    let createdDate: Swift.String?
    let version: Swift.Int
    let compatibleRuntimes: [LambdaClientTypes.Runtime]?
    let licenseInfo: Swift.String?
    let compatibleArchitectures: [LambdaClientTypes.Architecture]?
}

extension PublishLayerVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleArchitectures = "CompatibleArchitectures"
        case compatibleRuntimes = "CompatibleRuntimes"
        case content = "Content"
        case createdDate = "CreatedDate"
        case description = "Description"
        case layerArn = "LayerArn"
        case layerVersionArn = "LayerVersionArn"
        case licenseInfo = "LicenseInfo"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LayerVersionContentOutput.self, forKey: .content)
        content = contentDecoded
        let layerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerArn)
        layerArn = layerArnDecoded
        let layerVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerVersionArn)
        layerVersionArn = layerVersionArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decode(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let compatibleRuntimesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Runtime?].self, forKey: .compatibleRuntimes)
        var compatibleRuntimesDecoded0:[LambdaClientTypes.Runtime]? = nil
        if let compatibleRuntimesContainer = compatibleRuntimesContainer {
            compatibleRuntimesDecoded0 = [LambdaClientTypes.Runtime]()
            for string0 in compatibleRuntimesContainer {
                if let string0 = string0 {
                    compatibleRuntimesDecoded0?.append(string0)
                }
            }
        }
        compatibleRuntimes = compatibleRuntimesDecoded0
        let licenseInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseInfo)
        licenseInfo = licenseInfoDecoded
        let compatibleArchitecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .compatibleArchitectures)
        var compatibleArchitecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let compatibleArchitecturesContainer = compatibleArchitecturesContainer {
            compatibleArchitecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in compatibleArchitecturesContainer {
                if let string0 = string0 {
                    compatibleArchitecturesDecoded0?.append(string0)
                }
            }
        }
        compatibleArchitectures = compatibleArchitecturesDecoded0
    }
}

extension PublishVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSha256 = "CodeSha256"
        case description = "Description"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeSha256 = codeSha256 {
            try encodeContainer.encode(codeSha256, forKey: .codeSha256)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

extension PublishVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/versions"
    }
}

public struct PublishVersionInput: Swift.Equatable {
    /// Only publish a version if the hash value matches the value that's specified. Use this option to avoid publishing a version if the function code has changed since you last updated it. You can get the hash for the version that you uploaded from the output of [UpdateFunctionCode].
    public var codeSha256: Swift.String?
    /// A description for the version to override the description in the function configuration.
    public var description: Swift.String?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Only update the function if the revision ID matches the ID that's specified. Use this option to avoid publishing a version if the function configuration has changed since you last updated it.
    public var revisionId: Swift.String?

    public init (
        codeSha256: Swift.String? = nil,
        description: Swift.String? = nil,
        functionName: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.codeSha256 = codeSha256
        self.description = description
        self.functionName = functionName
        self.revisionId = revisionId
    }
}

struct PublishVersionInputBody: Swift.Equatable {
    let codeSha256: Swift.String?
    let description: Swift.String?
    let revisionId: Swift.String?
}

extension PublishVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSha256 = "CodeSha256"
        case description = "Description"
        case revisionId = "RevisionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension PublishVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PublishVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CodeStorageExceededException" : self = .codeStorageExceededException(try CodeStorageExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PublishVersionOutputError: Swift.Error, Swift.Equatable {
    case codeStorageExceededException(CodeStorageExceededException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PublishVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PublishVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.architectures = output.architectures
            self.codeSha256 = output.codeSha256
            self.codeSize = output.codeSize
            self.deadLetterConfig = output.deadLetterConfig
            self.description = output.description
            self.environment = output.environment
            self.fileSystemConfigs = output.fileSystemConfigs
            self.functionArn = output.functionArn
            self.functionName = output.functionName
            self.handler = output.handler
            self.imageConfigResponse = output.imageConfigResponse
            self.kMSKeyArn = output.kMSKeyArn
            self.lastModified = output.lastModified
            self.lastUpdateStatus = output.lastUpdateStatus
            self.lastUpdateStatusReason = output.lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = output.lastUpdateStatusReasonCode
            self.layers = output.layers
            self.masterArn = output.masterArn
            self.memorySize = output.memorySize
            self.packageType = output.packageType
            self.revisionId = output.revisionId
            self.role = output.role
            self.runtime = output.runtime
            self.signingJobArn = output.signingJobArn
            self.signingProfileVersionArn = output.signingProfileVersionArn
            self.state = output.state
            self.stateReason = output.stateReason
            self.stateReasonCode = output.stateReasonCode
            self.timeout = output.timeout
            self.tracingConfig = output.tracingConfig
            self.version = output.version
            self.vpcConfig = output.vpcConfig
        } else {
            self.architectures = nil
            self.codeSha256 = nil
            self.codeSize = 0
            self.deadLetterConfig = nil
            self.description = nil
            self.environment = nil
            self.fileSystemConfigs = nil
            self.functionArn = nil
            self.functionName = nil
            self.handler = nil
            self.imageConfigResponse = nil
            self.kMSKeyArn = nil
            self.lastModified = nil
            self.lastUpdateStatus = nil
            self.lastUpdateStatusReason = nil
            self.lastUpdateStatusReasonCode = nil
            self.layers = nil
            self.masterArn = nil
            self.memorySize = nil
            self.packageType = nil
            self.revisionId = nil
            self.role = nil
            self.runtime = nil
            self.signingJobArn = nil
            self.signingProfileVersionArn = nil
            self.state = nil
            self.stateReason = nil
            self.stateReasonCode = nil
            self.timeout = nil
            self.tracingConfig = nil
            self.version = nil
            self.vpcConfig = nil
        }
    }
}

/// Details about a function's configuration.
public struct PublishVersionOutputResponse: Swift.Equatable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html).
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin executing your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've configured a customer managed key.
    public var kMSKeyArn: Swift.String?
    /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's [ layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public var layers: [LambdaClientTypes.Layer]?
    /// For Lambda@Edge functions, the ARN of the main function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The runtime environment for the Lambda function.
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init (
        architectures: [LambdaClientTypes.Architecture]? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kMSKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    )
    {
        self.architectures = architectures
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kMSKeyArn = kMSKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

struct PublishVersionOutputResponseBody: Swift.Equatable {
    let functionName: Swift.String?
    let functionArn: Swift.String?
    let runtime: LambdaClientTypes.Runtime?
    let role: Swift.String?
    let handler: Swift.String?
    let codeSize: Swift.Int
    let description: Swift.String?
    let timeout: Swift.Int?
    let memorySize: Swift.Int?
    let lastModified: Swift.String?
    let codeSha256: Swift.String?
    let version: Swift.String?
    let vpcConfig: LambdaClientTypes.VpcConfigResponse?
    let deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    let environment: LambdaClientTypes.EnvironmentResponse?
    let kMSKeyArn: Swift.String?
    let tracingConfig: LambdaClientTypes.TracingConfigResponse?
    let masterArn: Swift.String?
    let revisionId: Swift.String?
    let layers: [LambdaClientTypes.Layer]?
    let state: LambdaClientTypes.State?
    let stateReason: Swift.String?
    let stateReasonCode: LambdaClientTypes.StateReasonCode?
    let lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    let lastUpdateStatusReason: Swift.String?
    let lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    let fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    let packageType: LambdaClientTypes.PackageType?
    let imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    let signingProfileVersionArn: Swift.String?
    let signingJobArn: Swift.String?
    let architectures: [LambdaClientTypes.Architecture]?
}

extension PublishVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kMSKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[LambdaClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [LambdaClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
    }
}

extension PutFunctionCodeSigningConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfigArn = "CodeSigningConfigArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeSigningConfigArn = codeSigningConfigArn {
            try encodeContainer.encode(codeSigningConfigArn, forKey: .codeSigningConfigArn)
        }
    }
}

extension PutFunctionCodeSigningConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2020-06-30/functions/\(functionName.urlPercentEncoding())/code-signing-config"
    }
}

public struct PutFunctionCodeSigningConfigInput: Swift.Equatable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init (
        codeSigningConfigArn: Swift.String? = nil,
        functionName: Swift.String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.functionName = functionName
    }
}

struct PutFunctionCodeSigningConfigInputBody: Swift.Equatable {
    let codeSigningConfigArn: Swift.String?
}

extension PutFunctionCodeSigningConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfigArn = "CodeSigningConfigArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSigningConfigArn)
        codeSigningConfigArn = codeSigningConfigArnDecoded
    }
}

extension PutFunctionCodeSigningConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutFunctionCodeSigningConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CodeSigningConfigNotFoundException" : self = .codeSigningConfigNotFoundException(try CodeSigningConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutFunctionCodeSigningConfigOutputError: Swift.Error, Swift.Equatable {
    case codeSigningConfigNotFoundException(CodeSigningConfigNotFoundException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutFunctionCodeSigningConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutFunctionCodeSigningConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.codeSigningConfigArn = output.codeSigningConfigArn
            self.functionName = output.functionName
        } else {
            self.codeSigningConfigArn = nil
            self.functionName = nil
        }
    }
}

public struct PutFunctionCodeSigningConfigOutputResponse: Swift.Equatable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init (
        codeSigningConfigArn: Swift.String? = nil,
        functionName: Swift.String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.functionName = functionName
    }
}

struct PutFunctionCodeSigningConfigOutputResponseBody: Swift.Equatable {
    let codeSigningConfigArn: Swift.String?
    let functionName: Swift.String?
}

extension PutFunctionCodeSigningConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfigArn = "CodeSigningConfigArn"
        case functionName = "FunctionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSigningConfigArn)
        codeSigningConfigArn = codeSigningConfigArnDecoded
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
    }
}

extension PutFunctionConcurrencyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reservedConcurrentExecutions = reservedConcurrentExecutions {
            try encodeContainer.encode(reservedConcurrentExecutions, forKey: .reservedConcurrentExecutions)
        }
    }
}

extension PutFunctionConcurrencyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2017-10-31/functions/\(functionName.urlPercentEncoding())/concurrency"
    }
}

public struct PutFunctionConcurrencyInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - my-function.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The number of simultaneous executions to reserve for the function.
    /// This member is required.
    public var reservedConcurrentExecutions: Swift.Int?

    public init (
        functionName: Swift.String? = nil,
        reservedConcurrentExecutions: Swift.Int? = nil
    )
    {
        self.functionName = functionName
        self.reservedConcurrentExecutions = reservedConcurrentExecutions
    }
}

struct PutFunctionConcurrencyInputBody: Swift.Equatable {
    let reservedConcurrentExecutions: Swift.Int?
}

extension PutFunctionConcurrencyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reservedConcurrentExecutions)
        reservedConcurrentExecutions = reservedConcurrentExecutionsDecoded
    }
}

extension PutFunctionConcurrencyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutFunctionConcurrencyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutFunctionConcurrencyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutFunctionConcurrencyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutFunctionConcurrencyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reservedConcurrentExecutions = output.reservedConcurrentExecutions
        } else {
            self.reservedConcurrentExecutions = nil
        }
    }
}

public struct PutFunctionConcurrencyOutputResponse: Swift.Equatable {
    /// The number of concurrent executions that are reserved for this function. For more information, see [Managing Concurrency](https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html).
    public var reservedConcurrentExecutions: Swift.Int?

    public init (
        reservedConcurrentExecutions: Swift.Int? = nil
    )
    {
        self.reservedConcurrentExecutions = reservedConcurrentExecutions
    }
}

struct PutFunctionConcurrencyOutputResponseBody: Swift.Equatable {
    let reservedConcurrentExecutions: Swift.Int?
}

extension PutFunctionConcurrencyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reservedConcurrentExecutions)
        reservedConcurrentExecutions = reservedConcurrentExecutionsDecoded
    }
}

extension PutFunctionEventInvokeConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfig = destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let maximumEventAgeInSeconds = maximumEventAgeInSeconds {
            try encodeContainer.encode(maximumEventAgeInSeconds, forKey: .maximumEventAgeInSeconds)
        }
        if let maximumRetryAttempts = maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
    }
}

extension PutFunctionEventInvokeConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let qualifier = qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension PutFunctionEventInvokeConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config"
    }
}

public struct PutFunctionEventInvokeConfigInput: Swift.Equatable {
    /// A destination for events after they have been sent to a function for processing. Destinations
    ///
    /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    /// * Queue - The ARN of an SQS queue.
    ///
    /// * Topic - The ARN of an SNS topic.
    ///
    /// * Event Bus - The ARN of an Amazon EventBridge event bus.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The name of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?
    /// A version number or alias name.
    public var qualifier: Swift.String?

    public init (
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionName: Swift.String? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionName = functionName
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.qualifier = qualifier
    }
}

struct PutFunctionEventInvokeConfigInputBody: Swift.Equatable {
    let maximumRetryAttempts: Swift.Int?
    let maximumEventAgeInSeconds: Swift.Int?
    let destinationConfig: LambdaClientTypes.DestinationConfig?
}

extension PutFunctionEventInvokeConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

extension PutFunctionEventInvokeConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutFunctionEventInvokeConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutFunctionEventInvokeConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutFunctionEventInvokeConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutFunctionEventInvokeConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinationConfig = output.destinationConfig
            self.functionArn = output.functionArn
            self.lastModified = output.lastModified
            self.maximumEventAgeInSeconds = output.maximumEventAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
        } else {
            self.destinationConfig = nil
            self.functionArn = nil
            self.lastModified = nil
            self.maximumEventAgeInSeconds = nil
            self.maximumRetryAttempts = nil
        }
    }
}

public struct PutFunctionEventInvokeConfigOutputResponse: Swift.Equatable {
    /// A destination for events after they have been sent to a function for processing. Destinations
    ///
    /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    /// * Queue - The ARN of an SQS queue.
    ///
    /// * Topic - The ARN of an SNS topic.
    ///
    /// * Event Bus - The ARN of an Amazon EventBridge event bus.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The Amazon Resource Name (ARN) of the function.
    public var functionArn: Swift.String?
    /// The date and time that the configuration was last updated.
    public var lastModified: ClientRuntime.Date?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?

    public init (
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionArn: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionArn = functionArn
        self.lastModified = lastModified
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
    }
}

struct PutFunctionEventInvokeConfigOutputResponseBody: Swift.Equatable {
    let lastModified: ClientRuntime.Date?
    let functionArn: Swift.String?
    let maximumRetryAttempts: Swift.Int?
    let maximumEventAgeInSeconds: Swift.Int?
    let destinationConfig: LambdaClientTypes.DestinationConfig?
}

extension PutFunctionEventInvokeConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case functionArn = "FunctionArn"
        case lastModified = "LastModified"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

extension PutProvisionedConcurrencyConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case provisionedConcurrentExecutions = "ProvisionedConcurrentExecutions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let provisionedConcurrentExecutions = provisionedConcurrentExecutions {
            try encodeContainer.encode(provisionedConcurrentExecutions, forKey: .provisionedConcurrentExecutions)
        }
    }
}

extension PutProvisionedConcurrencyConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let qualifier = qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension PutProvisionedConcurrencyConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2019-09-30/functions/\(functionName.urlPercentEncoding())/provisioned-concurrency"
    }
}

public struct PutProvisionedConcurrencyConfigInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - my-function.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The amount of provisioned concurrency to allocate for the version or alias.
    /// This member is required.
    public var provisionedConcurrentExecutions: Swift.Int?
    /// The version number or alias name.
    /// This member is required.
    public var qualifier: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        provisionedConcurrentExecutions: Swift.Int? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.provisionedConcurrentExecutions = provisionedConcurrentExecutions
        self.qualifier = qualifier
    }
}

struct PutProvisionedConcurrencyConfigInputBody: Swift.Equatable {
    let provisionedConcurrentExecutions: Swift.Int?
}

extension PutProvisionedConcurrencyConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case provisionedConcurrentExecutions = "ProvisionedConcurrentExecutions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedConcurrentExecutions)
        provisionedConcurrentExecutions = provisionedConcurrentExecutionsDecoded
    }
}

extension PutProvisionedConcurrencyConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutProvisionedConcurrencyConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutProvisionedConcurrencyConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutProvisionedConcurrencyConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutProvisionedConcurrencyConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.allocatedProvisionedConcurrentExecutions = output.allocatedProvisionedConcurrentExecutions
            self.availableProvisionedConcurrentExecutions = output.availableProvisionedConcurrentExecutions
            self.lastModified = output.lastModified
            self.requestedProvisionedConcurrentExecutions = output.requestedProvisionedConcurrentExecutions
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.allocatedProvisionedConcurrentExecutions = nil
            self.availableProvisionedConcurrentExecutions = nil
            self.lastModified = nil
            self.requestedProvisionedConcurrentExecutions = nil
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct PutProvisionedConcurrencyConfigOutputResponse: Swift.Equatable {
    /// The amount of provisioned concurrency allocated.
    public var allocatedProvisionedConcurrentExecutions: Swift.Int?
    /// The amount of provisioned concurrency available.
    public var availableProvisionedConcurrentExecutions: Swift.Int?
    /// The date and time that a user last updated the configuration, in [ISO 8601 format](https://www.iso.org/iso-8601-date-and-time-format.html).
    public var lastModified: Swift.String?
    /// The amount of provisioned concurrency requested.
    public var requestedProvisionedConcurrentExecutions: Swift.Int?
    /// The status of the allocation process.
    public var status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum?
    /// For failed allocations, the reason that provisioned concurrency could not be allocated.
    public var statusReason: Swift.String?

    public init (
        allocatedProvisionedConcurrentExecutions: Swift.Int? = nil,
        availableProvisionedConcurrentExecutions: Swift.Int? = nil,
        lastModified: Swift.String? = nil,
        requestedProvisionedConcurrentExecutions: Swift.Int? = nil,
        status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
        self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
        self.lastModified = lastModified
        self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
        self.status = status
        self.statusReason = statusReason
    }
}

struct PutProvisionedConcurrencyConfigOutputResponseBody: Swift.Equatable {
    let requestedProvisionedConcurrentExecutions: Swift.Int?
    let availableProvisionedConcurrentExecutions: Swift.Int?
    let allocatedProvisionedConcurrentExecutions: Swift.Int?
    let status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum?
    let statusReason: Swift.String?
    let lastModified: Swift.String?
}

extension PutProvisionedConcurrencyConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedProvisionedConcurrentExecutions = "AllocatedProvisionedConcurrentExecutions"
        case availableProvisionedConcurrentExecutions = "AvailableProvisionedConcurrentExecutions"
        case lastModified = "LastModified"
        case requestedProvisionedConcurrentExecutions = "RequestedProvisionedConcurrentExecutions"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .requestedProvisionedConcurrentExecutions)
        requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutionsDecoded
        let availableProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .availableProvisionedConcurrentExecutions)
        availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutionsDecoded
        let allocatedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedProvisionedConcurrentExecutions)
        allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ProvisionedConcurrencyStatusEnum.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension RemoveLayerVersionPermissionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let revisionId = revisionId {
            let revisionIdQueryItem = ClientRuntime.URLQueryItem(name: "RevisionId".urlPercentEncoding(), value: Swift.String(revisionId).urlPercentEncoding())
            items.append(revisionIdQueryItem)
        }
        return items
    }
}

extension RemoveLayerVersionPermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let layerName = layerName else {
            return nil
        }
        guard let statementId = statementId else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)/policy/\(statementId.urlPercentEncoding())"
    }
}

public struct RemoveLayerVersionPermissionInput: Swift.Equatable {
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// Only update the policy if the revision ID matches the ID specified. Use this option to avoid modifying a policy that has changed since you last read it.
    public var revisionId: Swift.String?
    /// The identifier that was specified when the statement was added.
    /// This member is required.
    public var statementId: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int

    public init (
        layerName: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        statementId: Swift.String? = nil,
        versionNumber: Swift.Int = 0
    )
    {
        self.layerName = layerName
        self.revisionId = revisionId
        self.statementId = statementId
        self.versionNumber = versionNumber
    }
}

struct RemoveLayerVersionPermissionInputBody: Swift.Equatable {
}

extension RemoveLayerVersionPermissionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RemoveLayerVersionPermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveLayerVersionPermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveLayerVersionPermissionOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveLayerVersionPermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveLayerVersionPermissionOutputResponse: Swift.Equatable {

}

extension RemovePermissionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let qualifier = qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        if let revisionId = revisionId {
            let revisionIdQueryItem = ClientRuntime.URLQueryItem(name: "RevisionId".urlPercentEncoding(), value: Swift.String(revisionId).urlPercentEncoding())
            items.append(revisionIdQueryItem)
        }
        return items
    }
}

extension RemovePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        guard let statementId = statementId else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/policy/\(statementId.urlPercentEncoding())"
    }
}

public struct RemovePermissionInput: Swift.Equatable {
    /// The name of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version or alias to remove permissions from a published version of the function.
    public var qualifier: Swift.String?
    /// Only update the policy if the revision ID matches the ID that's specified. Use this option to avoid modifying a policy that has changed since you last read it.
    public var revisionId: Swift.String?
    /// Statement ID of the permission to remove.
    /// This member is required.
    public var statementId: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
        self.revisionId = revisionId
        self.statementId = statementId
    }
}

struct RemovePermissionInputBody: Swift.Equatable {
}

extension RemovePermissionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RemovePermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemovePermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemovePermissionOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemovePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemovePermissionOutputResponse: Swift.Equatable {

}

extension RequestTooLargeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RequestTooLargeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request payload exceeded the Invoke request body JSON input limit. For more information, see [Limits](https://docs.aws.amazon.com/lambda/latest/dg/limits.html).
public struct RequestTooLargeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct RequestTooLargeExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension RequestTooLargeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource already exists, or another operation is in progress.
public struct ResourceConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The exception message.
    public var message: Swift.String?
    /// The exception type.
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct ResourceConflictExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension ResourceConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation conflicts with the resource's availability. For example, you attempted to update an EventSource Mapping in CREATING, or tried to delete a EventSource mapping currently in the UPDATING state.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource specified in the request does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotReadyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotReadyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The function is inactive and its VPC connection is no longer available. Wait for the VPC connection to reestablish and try again.
public struct ResourceNotReadyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The exception message.
    public var message: Swift.String?
    /// The exception type.
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct ResourceNotReadyExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension ResourceNotReadyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes {
    public enum Runtime: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dotnetcore10
        case dotnetcore20
        case dotnetcore21
        case dotnetcore31
        case go1x
        case java11
        case java8
        case java8al2
        case nodejs
        case nodejs10x
        case nodejs12x
        case nodejs14x
        case nodejs43
        case nodejs43edge
        case nodejs610
        case nodejs810
        case provided
        case providedal2
        case python27
        case python36
        case python37
        case python38
        case python39
        case ruby25
        case ruby27
        case sdkUnknown(Swift.String)

        public static var allCases: [Runtime] {
            return [
                .dotnetcore10,
                .dotnetcore20,
                .dotnetcore21,
                .dotnetcore31,
                .go1x,
                .java11,
                .java8,
                .java8al2,
                .nodejs,
                .nodejs10x,
                .nodejs12x,
                .nodejs14x,
                .nodejs43,
                .nodejs43edge,
                .nodejs610,
                .nodejs810,
                .provided,
                .providedal2,
                .python27,
                .python36,
                .python37,
                .python38,
                .python39,
                .ruby25,
                .ruby27,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dotnetcore10: return "dotnetcore1.0"
            case .dotnetcore20: return "dotnetcore2.0"
            case .dotnetcore21: return "dotnetcore2.1"
            case .dotnetcore31: return "dotnetcore3.1"
            case .go1x: return "go1.x"
            case .java11: return "java11"
            case .java8: return "java8"
            case .java8al2: return "java8.al2"
            case .nodejs: return "nodejs"
            case .nodejs10x: return "nodejs10.x"
            case .nodejs12x: return "nodejs12.x"
            case .nodejs14x: return "nodejs14.x"
            case .nodejs43: return "nodejs4.3"
            case .nodejs43edge: return "nodejs4.3-edge"
            case .nodejs610: return "nodejs6.10"
            case .nodejs810: return "nodejs8.10"
            case .provided: return "provided"
            case .providedal2: return "provided.al2"
            case .python27: return "python2.7"
            case .python36: return "python3.6"
            case .python37: return "python3.7"
            case .python38: return "python3.8"
            case .python39: return "python3.9"
            case .ruby25: return "ruby2.5"
            case .ruby27: return "ruby2.7"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Runtime(rawValue: rawValue) ?? Runtime.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes.SelfManagedEventSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .endpoints)
            for (dictKey0, endpoints0) in endpoints {
                try endpointsContainer.encode(endpoints0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .endpoints)
        var endpointsDecoded0: [Swift.String:[Swift.String]]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, endpointlists0) in endpointsContainer {
                var endpointlists0Decoded0: [Swift.String]? = nil
                if let endpointlists0 = endpointlists0 {
                    endpointlists0Decoded0 = [Swift.String]()
                    for string1 in endpointlists0 {
                        if let string1 = string1 {
                            endpointlists0Decoded0?.append(string1)
                        }
                    }
                }
                endpointsDecoded0?[key0] = endpointlists0Decoded0
            }
        }
        endpoints = endpointsDecoded0
    }
}

extension LambdaClientTypes {
    /// The self-managed Apache Kafka cluster for your event source.
    public struct SelfManagedEventSource: Swift.Equatable {
        /// The list of bootstrap servers for your Kafka brokers in the following format: "KAFKA_BOOTSTRAP_SERVERS": ["abc.xyz.com:xxxx","abc2.xyz.com:xxxx"].
        public var endpoints: [Swift.String:[Swift.String]]?

        public init (
            endpoints: [Swift.String:[Swift.String]]? = nil
        )
        {
            self.endpoints = endpoints
        }
    }

}

extension ServiceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Lambda service encountered an internal error.
public struct ServiceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct ServiceExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension ServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes.SourceAccessConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case uRI = "URI"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uRI = uRI {
            try encodeContainer.encode(uRI, forKey: .uRI)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SourceAccessType.self, forKey: .type)
        type = typeDecoded
        let uRIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uRI)
        uRI = uRIDecoded
    }
}

extension LambdaClientTypes {
    /// To secure and define access to your event source, you can specify the authentication protocol, VPC components, or virtual host.
    public struct SourceAccessConfiguration: Swift.Equatable {
        /// The type of authentication protocol, VPC components, or virtual host for your event source. For example: "Type":"SASL_SCRAM_512_AUTH".
        ///
        /// * BASIC_AUTH - (Amazon MQ) The Secrets Manager secret that stores your broker credentials.
        ///
        /// * BASIC_AUTH - (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL/PLAIN authentication of your Apache Kafka brokers.
        ///
        /// * VPC_SUBNET - The subnets associated with your VPC. Lambda connects to these subnets to fetch data from your self-managed Apache Kafka cluster.
        ///
        /// * VPC_SECURITY_GROUP - The VPC security group used to manage access to your self-managed Apache Kafka brokers.
        ///
        /// * SASL_SCRAM_256_AUTH - The Secrets Manager ARN of your secret key used for SASL SCRAM-256 authentication of your self-managed Apache Kafka brokers.
        ///
        /// * SASL_SCRAM_512_AUTH - The Secrets Manager ARN of your secret key used for SASL SCRAM-512 authentication of your self-managed Apache Kafka brokers.
        ///
        /// * VIRTUAL_HOST - (Amazon MQ) The name of the virtual host in your RabbitMQ broker. Lambda uses this RabbitMQ host as the event source. This property cannot be specified in an UpdateEventSourceMapping API call.
        ///
        /// * CLIENT_CERTIFICATE_TLS_AUTH - (Amazon MSK, Self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the certificate chain (X.509 PEM), private key (PKCS#8 PEM), and private key password (optional) used for mutual TLS authentication of your MSK/Apache Kafka brokers.
        ///
        /// * SERVER_ROOT_CA_CERTIFICATE - (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the root CA certificate (X.509 PEM) used for TLS encryption of your Apache Kafka brokers.
        public var type: LambdaClientTypes.SourceAccessType?
        /// The value for your chosen configuration in Type. For example: "URI": "arn:aws:secretsmanager:us-east-1:01234567890:secret:MyBrokerSecretName".
        public var uRI: Swift.String?

        public init (
            type: LambdaClientTypes.SourceAccessType? = nil,
            uRI: Swift.String? = nil
        )
        {
            self.type = type
            self.uRI = uRI
        }
    }

}

extension LambdaClientTypes {
    public enum SourceAccessType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case basicAuth
        case clientCertificateTlsAuth
        case saslScram256Auth
        case saslScram512Auth
        case serverRootCaCertificate
        case virtualHost
        case vpcSecurityGroup
        case vpcSubnet
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceAccessType] {
            return [
                .basicAuth,
                .clientCertificateTlsAuth,
                .saslScram256Auth,
                .saslScram512Auth,
                .serverRootCaCertificate,
                .virtualHost,
                .vpcSecurityGroup,
                .vpcSubnet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .basicAuth: return "BASIC_AUTH"
            case .clientCertificateTlsAuth: return "CLIENT_CERTIFICATE_TLS_AUTH"
            case .saslScram256Auth: return "SASL_SCRAM_256_AUTH"
            case .saslScram512Auth: return "SASL_SCRAM_512_AUTH"
            case .serverRootCaCertificate: return "SERVER_ROOT_CA_CERTIFICATE"
            case .virtualHost: return "VIRTUAL_HOST"
            case .vpcSecurityGroup: return "VPC_SECURITY_GROUP"
            case .vpcSubnet: return "VPC_SUBNET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceAccessType(rawValue: rawValue) ?? SourceAccessType.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes {
    public enum State: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case failed
        case inactive
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .active,
                .failed,
                .inactive,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .failed: return "Failed"
            case .inactive: return "Inactive"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = State(rawValue: rawValue) ?? State.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes {
    public enum StateReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case enilimitexceeded
        case idle
        case imageaccessdenied
        case imagedeleted
        case insufficientrolepermissions
        case internalerror
        case invalidconfiguration
        case invalidimage
        case invalidsecuritygroup
        case invalidsubnet
        case restoring
        case subnetoutofipaddresses
        case sdkUnknown(Swift.String)

        public static var allCases: [StateReasonCode] {
            return [
                .creating,
                .enilimitexceeded,
                .idle,
                .imageaccessdenied,
                .imagedeleted,
                .insufficientrolepermissions,
                .internalerror,
                .invalidconfiguration,
                .invalidimage,
                .invalidsecuritygroup,
                .invalidsubnet,
                .restoring,
                .subnetoutofipaddresses,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "Creating"
            case .enilimitexceeded: return "EniLimitExceeded"
            case .idle: return "Idle"
            case .imageaccessdenied: return "ImageAccessDenied"
            case .imagedeleted: return "ImageDeleted"
            case .insufficientrolepermissions: return "InsufficientRolePermissions"
            case .internalerror: return "InternalError"
            case .invalidconfiguration: return "InvalidConfiguration"
            case .invalidimage: return "InvalidImage"
            case .invalidsecuritygroup: return "InvalidSecurityGroup"
            case .invalidsubnet: return "InvalidSubnet"
            case .restoring: return "Restoring"
            case .subnetoutofipaddresses: return "SubnetOutOfIPAddresses"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StateReasonCode(rawValue: rawValue) ?? StateReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension SubnetIPAddressLimitReachedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SubnetIPAddressLimitReachedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Lambda was not able to set up VPC access for the Lambda function because one or more configured subnets has no available IP addresses.
public struct SubnetIPAddressLimitReachedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct SubnetIPAddressLimitReachedExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension SubnetIPAddressLimitReachedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resource = resource else {
            return nil
        }
        return "/2017-03-31/tags/\(resource.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The function's Amazon Resource Name (ARN).
    /// This member is required.
    public var resource: Swift.String?
    /// A list of tags to apply to the function.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resource: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resource = resource
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension LambdaClientTypes {
    public enum ThrottleReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case callerratelimitexceeded
        case concurrentinvocationlimitexceeded
        case functioninvocationratelimitexceeded
        case reservedfunctionconcurrentinvocationlimitexceeded
        case reservedfunctioninvocationratelimitexceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ThrottleReason] {
            return [
                .callerratelimitexceeded,
                .concurrentinvocationlimitexceeded,
                .functioninvocationratelimitexceeded,
                .reservedfunctionconcurrentinvocationlimitexceeded,
                .reservedfunctioninvocationratelimitexceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .callerratelimitexceeded: return "CallerRateLimitExceeded"
            case .concurrentinvocationlimitexceeded: return "ConcurrentInvocationLimitExceeded"
            case .functioninvocationratelimitexceeded: return "FunctionInvocationRateLimitExceeded"
            case .reservedfunctionconcurrentinvocationlimitexceeded: return "ReservedFunctionConcurrentInvocationLimitExceeded"
            case .reservedfunctioninvocationratelimitexceeded: return "ReservedFunctionInvocationRateLimitExceeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThrottleReason(rawValue: rawValue) ?? ThrottleReason.sdkUnknown(rawValue)
        }
    }
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
            self.type = output.type
        } else {
            self.reason = nil
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request throughput limit was exceeded.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var reason: LambdaClientTypes.ThrottleReason?
    /// The number of seconds the caller should wait before retrying.
    public var retryAfterSeconds: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        reason: LambdaClientTypes.ThrottleReason? = nil,
        retryAfterSeconds: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.reason = reason
        self.retryAfterSeconds = retryAfterSeconds
        self.type = type
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
    let reason: LambdaClientTypes.ThrottleReason?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason = "Reason"
        case type = "Type"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ThrottleReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension LambdaClientTypes.TracingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode = "Mode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingMode.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension LambdaClientTypes {
    /// The function's [X-Ray](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html) tracing configuration. To sample and record incoming requests, set Mode to Active.
    public struct TracingConfig: Swift.Equatable {
        /// The tracing mode.
        public var mode: LambdaClientTypes.TracingMode?

        public init (
            mode: LambdaClientTypes.TracingMode? = nil
        )
        {
            self.mode = mode
        }
    }

}

extension LambdaClientTypes.TracingConfigResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode = "Mode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingMode.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension LambdaClientTypes {
    /// The function's X-Ray tracing configuration.
    public struct TracingConfigResponse: Swift.Equatable {
        /// The tracing mode.
        public var mode: LambdaClientTypes.TracingMode?

        public init (
            mode: LambdaClientTypes.TracingMode? = nil
        )
        {
            self.mode = mode
        }
    }

}

extension LambdaClientTypes {
    public enum TracingMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case passthrough
        case sdkUnknown(Swift.String)

        public static var allCases: [TracingMode] {
            return [
                .active,
                .passthrough,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .passthrough: return "PassThrough"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TracingMode(rawValue: rawValue) ?? TracingMode.sdkUnknown(rawValue)
        }
    }
}

extension UnsupportedMediaTypeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedMediaTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The content type of the Invoke request body is not JSON.
public struct UnsupportedMediaTypeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct UnsupportedMediaTypeExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension UnsupportedMediaTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resource = resource else {
            return nil
        }
        return "/2017-03-31/tags/\(resource.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The function's Amazon Resource Name (ARN).
    /// This member is required.
    public var resource: Swift.String?
    /// A list of tag keys to remove from the function.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resource: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resource = resource
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionVersion = functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let routingConfig = routingConfig {
            try encodeContainer.encode(routingConfig, forKey: .routingConfig)
        }
    }
}

extension UpdateAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases/\(name.urlPercentEncoding())"
    }
}

public struct UpdateAliasInput: Swift.Equatable {
    /// A description of the alias.
    public var description: Swift.String?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The function version that the alias invokes.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?
    /// Only update the alias if the revision ID matches the ID that's specified. Use this option to avoid modifying an alias that has changed since you last read it.
    public var revisionId: Swift.String?
    /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html#configuring-alias-routing) of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init (
        description: Swift.String? = nil,
        functionName: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    )
    {
        self.description = description
        self.functionName = functionName
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

struct UpdateAliasInputBody: Swift.Equatable {
    let functionVersion: Swift.String?
    let description: Swift.String?
    let routingConfig: LambdaClientTypes.AliasRoutingConfiguration?
    let revisionId: Swift.String?
}

extension UpdateAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension UpdateAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAliasOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aliasArn = output.aliasArn
            self.description = output.description
            self.functionVersion = output.functionVersion
            self.name = output.name
            self.revisionId = output.revisionId
            self.routingConfig = output.routingConfig
        } else {
            self.aliasArn = nil
            self.description = nil
            self.functionVersion = nil
            self.name = nil
            self.revisionId = nil
            self.routingConfig = nil
        }
    }
}

/// Provides configuration information about a Lambda function [alias](https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html).
public struct UpdateAliasOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the alias.
    public var aliasArn: Swift.String?
    /// A description of the alias.
    public var description: Swift.String?
    /// The function version that the alias invokes.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    public var name: Swift.String?
    /// A unique identifier that changes when you update the alias.
    public var revisionId: Swift.String?
    /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html) of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init (
        aliasArn: Swift.String? = nil,
        description: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    )
    {
        self.aliasArn = aliasArn
        self.description = description
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

struct UpdateAliasOutputResponseBody: Swift.Equatable {
    let aliasArn: Swift.String?
    let name: Swift.String?
    let functionVersion: Swift.String?
    let description: Swift.String?
    let routingConfig: LambdaClientTypes.AliasRoutingConfiguration?
    let revisionId: Swift.String?
}

extension UpdateAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasArn = "AliasArn"
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasArn)
        aliasArn = aliasArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension UpdateCodeSigningConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPublishers = "AllowedPublishers"
        case codeSigningPolicies = "CodeSigningPolicies"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPublishers = allowedPublishers {
            try encodeContainer.encode(allowedPublishers, forKey: .allowedPublishers)
        }
        if let codeSigningPolicies = codeSigningPolicies {
            try encodeContainer.encode(codeSigningPolicies, forKey: .codeSigningPolicies)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateCodeSigningConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let codeSigningConfigArn = codeSigningConfigArn else {
            return nil
        }
        return "/2020-04-22/code-signing-configs/\(codeSigningConfigArn.urlPercentEncoding())"
    }
}

public struct UpdateCodeSigningConfigInput: Swift.Equatable {
    /// Signing profiles for this code signing configuration.
    public var allowedPublishers: LambdaClientTypes.AllowedPublishers?
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// The code signing policy.
    public var codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies?
    /// Descriptive name for this code signing configuration.
    public var description: Swift.String?

    public init (
        allowedPublishers: LambdaClientTypes.AllowedPublishers? = nil,
        codeSigningConfigArn: Swift.String? = nil,
        codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies? = nil,
        description: Swift.String? = nil
    )
    {
        self.allowedPublishers = allowedPublishers
        self.codeSigningConfigArn = codeSigningConfigArn
        self.codeSigningPolicies = codeSigningPolicies
        self.description = description
    }
}

struct UpdateCodeSigningConfigInputBody: Swift.Equatable {
    let description: Swift.String?
    let allowedPublishers: LambdaClientTypes.AllowedPublishers?
    let codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies?
}

extension UpdateCodeSigningConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPublishers = "AllowedPublishers"
        case codeSigningPolicies = "CodeSigningPolicies"
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let allowedPublishersDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AllowedPublishers.self, forKey: .allowedPublishers)
        allowedPublishers = allowedPublishersDecoded
        let codeSigningPoliciesDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.CodeSigningPolicies.self, forKey: .codeSigningPolicies)
        codeSigningPolicies = codeSigningPoliciesDecoded
    }
}

extension UpdateCodeSigningConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCodeSigningConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCodeSigningConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCodeSigningConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateCodeSigningConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.codeSigningConfig = output.codeSigningConfig
        } else {
            self.codeSigningConfig = nil
        }
    }
}

public struct UpdateCodeSigningConfigOutputResponse: Swift.Equatable {
    /// The code signing configuration
    /// This member is required.
    public var codeSigningConfig: LambdaClientTypes.CodeSigningConfig?

    public init (
        codeSigningConfig: LambdaClientTypes.CodeSigningConfig? = nil
    )
    {
        self.codeSigningConfig = codeSigningConfig
    }
}

struct UpdateCodeSigningConfigOutputResponseBody: Swift.Equatable {
    let codeSigningConfig: LambdaClientTypes.CodeSigningConfig?
}

extension UpdateCodeSigningConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfig = "CodeSigningConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.CodeSigningConfig.self, forKey: .codeSigningConfig)
        codeSigningConfig = codeSigningConfigDecoded
    }
}

extension UpdateEventSourceMappingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case enabled = "Enabled"
        case filterCriteria = "FilterCriteria"
        case functionName = "FunctionName"
        case functionResponseTypes = "FunctionResponseTypes"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchSize = batchSize {
            try encodeContainer.encode(batchSize, forKey: .batchSize)
        }
        if let bisectBatchOnFunctionError = bisectBatchOnFunctionError {
            try encodeContainer.encode(bisectBatchOnFunctionError, forKey: .bisectBatchOnFunctionError)
        }
        if let destinationConfig = destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let filterCriteria = filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let functionName = functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let functionResponseTypes = functionResponseTypes {
            var functionResponseTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functionResponseTypes)
            for functionresponsetypelist0 in functionResponseTypes {
                try functionResponseTypesContainer.encode(functionresponsetypelist0.rawValue)
            }
        }
        if let maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds {
            try encodeContainer.encode(maximumBatchingWindowInSeconds, forKey: .maximumBatchingWindowInSeconds)
        }
        if let maximumRecordAgeInSeconds = maximumRecordAgeInSeconds {
            try encodeContainer.encode(maximumRecordAgeInSeconds, forKey: .maximumRecordAgeInSeconds)
        }
        if let maximumRetryAttempts = maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
        if let parallelizationFactor = parallelizationFactor {
            try encodeContainer.encode(parallelizationFactor, forKey: .parallelizationFactor)
        }
        if let sourceAccessConfigurations = sourceAccessConfigurations {
            var sourceAccessConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceAccessConfigurations)
            for sourceaccessconfigurations0 in sourceAccessConfigurations {
                try sourceAccessConfigurationsContainer.encode(sourceaccessconfigurations0)
            }
        }
        if let tumblingWindowInSeconds = tumblingWindowInSeconds {
            try encodeContainer.encode(tumblingWindowInSeconds, forKey: .tumblingWindowInSeconds)
        }
    }
}

extension UpdateEventSourceMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let uUID = uUID else {
            return nil
        }
        return "/2015-03-31/event-source-mappings/\(uUID.urlPercentEncoding())"
    }
}

public struct UpdateEventSourceMappingInput: Swift.Equatable {
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB).
    ///
    /// * Amazon Kinesis - Default 100. Max 10,000.
    ///
    /// * Amazon DynamoDB Streams - Default 100. Max 1,000.
    ///
    /// * Amazon Simple Queue Service - Default 10. For standard queues the max is 10,000. For FIFO queues the max is 10.
    ///
    /// * Amazon Managed Streaming for Apache Kafka - Default 100. Max 10,000.
    ///
    /// * Self-Managed Apache Kafka - Default 100. Max 10,000.
    ///
    /// * Amazon MQ (ActiveMQ and RabbitMQ) - Default 100. Max 10,000.
    public var batchSize: Swift.Int?
    /// (Streams only) If the function returns an error, split the batch in two and retry.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// When true, the event source mapping is active. When false, Lambda pauses polling and invocation. Default: True
    public var enabled: Swift.Bool?
    /// (Streams and Amazon SQS) An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html).
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Version or Alias ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64 characters in length.
    public var functionName: Swift.String?
    /// (Streams and Amazon SQS) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// (Streams and Amazon SQS standard queues) The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. Default: 0 Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Streams only) Discard records older than the specified age. The default value is infinite (-1).
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Streams only) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records will be retried until the record expires.
    public var maximumRetryAttempts: Swift.Int?
    /// (Streams only) The number of batches to process from each shard concurrently.
    public var parallelizationFactor: Swift.Int?
    /// An array of authentication protocols or VPC components required to secure your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// (Streams only) The duration in seconds of a processing window. The range is between 1 second up to 900 seconds.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    /// This member is required.
    public var uUID: Swift.String?

    public init (
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        enabled: Swift.Bool? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        functionName: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uUID: Swift.String? = nil
    )
    {
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.enabled = enabled
        self.filterCriteria = filterCriteria
        self.functionName = functionName
        self.functionResponseTypes = functionResponseTypes
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uUID = uUID
    }
}

struct UpdateEventSourceMappingInputBody: Swift.Equatable {
    let functionName: Swift.String?
    let enabled: Swift.Bool?
    let batchSize: Swift.Int?
    let filterCriteria: LambdaClientTypes.FilterCriteria?
    let maximumBatchingWindowInSeconds: Swift.Int?
    let destinationConfig: LambdaClientTypes.DestinationConfig?
    let maximumRecordAgeInSeconds: Swift.Int?
    let bisectBatchOnFunctionError: Swift.Bool?
    let maximumRetryAttempts: Swift.Int?
    let parallelizationFactor: Swift.Int?
    let sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    let tumblingWindowInSeconds: Swift.Int?
    let functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
}

extension UpdateEventSourceMappingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case enabled = "Enabled"
        case filterCriteria = "FilterCriteria"
        case functionName = "FunctionName"
        case functionResponseTypes = "FunctionResponseTypes"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[LambdaClientTypes.SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [LambdaClientTypes.SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[LambdaClientTypes.FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [LambdaClientTypes.FunctionResponseType]()
            for string0 in functionResponseTypesContainer {
                if let string0 = string0 {
                    functionResponseTypesDecoded0?.append(string0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
    }
}

extension UpdateEventSourceMappingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEventSourceMappingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEventSourceMappingOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEventSourceMappingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateEventSourceMappingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchSize = output.batchSize
            self.bisectBatchOnFunctionError = output.bisectBatchOnFunctionError
            self.destinationConfig = output.destinationConfig
            self.eventSourceArn = output.eventSourceArn
            self.filterCriteria = output.filterCriteria
            self.functionArn = output.functionArn
            self.functionResponseTypes = output.functionResponseTypes
            self.lastModified = output.lastModified
            self.lastProcessingResult = output.lastProcessingResult
            self.maximumBatchingWindowInSeconds = output.maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = output.maximumRecordAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
            self.parallelizationFactor = output.parallelizationFactor
            self.queues = output.queues
            self.selfManagedEventSource = output.selfManagedEventSource
            self.sourceAccessConfigurations = output.sourceAccessConfigurations
            self.startingPosition = output.startingPosition
            self.startingPositionTimestamp = output.startingPositionTimestamp
            self.state = output.state
            self.stateTransitionReason = output.stateTransitionReason
            self.topics = output.topics
            self.tumblingWindowInSeconds = output.tumblingWindowInSeconds
            self.uUID = output.uUID
        } else {
            self.batchSize = nil
            self.bisectBatchOnFunctionError = nil
            self.destinationConfig = nil
            self.eventSourceArn = nil
            self.filterCriteria = nil
            self.functionArn = nil
            self.functionResponseTypes = nil
            self.lastModified = nil
            self.lastProcessingResult = nil
            self.maximumBatchingWindowInSeconds = nil
            self.maximumRecordAgeInSeconds = nil
            self.maximumRetryAttempts = nil
            self.parallelizationFactor = nil
            self.queues = nil
            self.selfManagedEventSource = nil
            self.sourceAccessConfigurations = nil
            self.startingPosition = nil
            self.startingPositionTimestamp = nil
            self.state = nil
            self.stateTransitionReason = nil
            self.topics = nil
            self.tumblingWindowInSeconds = nil
            self.uUID = nil
        }
    }
}

/// A mapping between an Amazon Web Services resource and a Lambda function. For details, see [CreateEventSourceMapping].
public struct UpdateEventSourceMappingOutputResponse: Swift.Equatable {
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB). Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100. Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var batchSize: Swift.Int?
    /// (Streams only) If the function returns an error, split the batch in two and retry. The default value is false.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The Amazon Resource Name (ARN) of the event source.
    public var eventSourceArn: Swift.String?
    /// (Streams and Amazon SQS) An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html).
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// The ARN of the Lambda function.
    public var functionArn: Swift.String?
    /// (Streams only) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The date that the event source mapping was last updated or that its state changed.
    public var lastModified: ClientRuntime.Date?
    /// The result of the last Lambda invocation of your function.
    public var lastProcessingResult: Swift.String?
    /// (Streams and Amazon SQS standard queues) The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. Default: 0 Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Streams only) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records.
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Streams only) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
    public var maximumRetryAttempts: Swift.Int?
    /// (Streams only) The number of batches to process concurrently from each shard. The default value is 1.
    public var parallelizationFactor: Swift.Int?
    /// (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// The self-managed Apache Kafka cluster for your event source.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK stream sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading.
    public var startingPositionTimestamp: ClientRuntime.Date?
    /// The state of the event source mapping. It can be one of the following: Creating, Enabling, Enabled, Disabling, Disabled, Updating, or Deleting.
    public var state: Swift.String?
    /// Indicates whether a user or Lambda made the last change to the event source mapping.
    public var stateTransitionReason: Swift.String?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Streams only) The duration in seconds of a processing window. The range is 1900 seconds.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    public var uUID: Swift.String?

    public init (
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        eventSourceArn: Swift.String? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        functionArn: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        lastModified: ClientRuntime.Date? = nil,
        lastProcessingResult: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        queues: [Swift.String]? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: ClientRuntime.Date? = nil,
        state: Swift.String? = nil,
        stateTransitionReason: Swift.String? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uUID: Swift.String? = nil
    )
    {
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.eventSourceArn = eventSourceArn
        self.filterCriteria = filterCriteria
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.selfManagedEventSource = selfManagedEventSource
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uUID = uUID
    }
}

struct UpdateEventSourceMappingOutputResponseBody: Swift.Equatable {
    let uUID: Swift.String?
    let startingPosition: LambdaClientTypes.EventSourcePosition?
    let startingPositionTimestamp: ClientRuntime.Date?
    let batchSize: Swift.Int?
    let maximumBatchingWindowInSeconds: Swift.Int?
    let parallelizationFactor: Swift.Int?
    let eventSourceArn: Swift.String?
    let filterCriteria: LambdaClientTypes.FilterCriteria?
    let functionArn: Swift.String?
    let lastModified: ClientRuntime.Date?
    let lastProcessingResult: Swift.String?
    let state: Swift.String?
    let stateTransitionReason: Swift.String?
    let destinationConfig: LambdaClientTypes.DestinationConfig?
    let topics: [Swift.String]?
    let queues: [Swift.String]?
    let sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    let selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    let maximumRecordAgeInSeconds: Swift.Int?
    let bisectBatchOnFunctionError: Swift.Bool?
    let maximumRetryAttempts: Swift.Int?
    let tumblingWindowInSeconds: Swift.Int?
    let functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
}

extension UpdateEventSourceMappingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case eventSourceArn = "EventSourceArn"
        case filterCriteria = "FilterCriteria"
        case functionArn = "FunctionArn"
        case functionResponseTypes = "FunctionResponseTypes"
        case lastModified = "LastModified"
        case lastProcessingResult = "LastProcessingResult"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case selfManagedEventSource = "SelfManagedEventSource"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case state = "State"
        case stateTransitionReason = "StateTransitionReason"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        case uUID = "UUID"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uUIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uUID)
        uUID = uUIDDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lastProcessingResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastProcessingResult)
        lastProcessingResult = lastProcessingResultDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let stateTransitionReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateTransitionReason)
        stateTransitionReason = stateTransitionReasonDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let topicsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .topics)
        var topicsDecoded0:[Swift.String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [Swift.String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queues)
        var queuesDecoded0:[Swift.String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [Swift.String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[LambdaClientTypes.SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [LambdaClientTypes.SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[LambdaClientTypes.FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [LambdaClientTypes.FunctionResponseType]()
            for string0 in functionResponseTypesContainer {
                if let string0 = string0 {
                    functionResponseTypesDecoded0?.append(string0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
    }
}

extension UpdateFunctionCodeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case dryRun = "DryRun"
        case imageUri = "ImageUri"
        case publish = "Publish"
        case revisionId = "RevisionId"
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
        case s3ObjectVersion = "S3ObjectVersion"
        case zipFile = "ZipFile"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architectures = architectures {
            var architecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .architectures)
            for architectureslist0 in architectures {
                try architecturesContainer.encode(architectureslist0.rawValue)
            }
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let imageUri = imageUri {
            try encodeContainer.encode(imageUri, forKey: .imageUri)
        }
        if publish != false {
            try encodeContainer.encode(publish, forKey: .publish)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
        if let s3ObjectVersion = s3ObjectVersion {
            try encodeContainer.encode(s3ObjectVersion, forKey: .s3ObjectVersion)
        }
        if let zipFile = zipFile {
            try encodeContainer.encode(zipFile.base64EncodedString(), forKey: .zipFile)
        }
    }
}

extension UpdateFunctionCodeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/code"
    }
}

public struct UpdateFunctionCodeInput: Swift.Equatable {
    /// The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64). The default value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// Set to true to validate the request parameters and access permissions without modifying the function code.
    public var dryRun: Swift.Bool
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - my-function.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// URI of a container image in the Amazon ECR registry.
    public var imageUri: Swift.String?
    /// Set to true to publish a new version of the function after updating the code. This has the same effect as calling [PublishVersion] separately.
    public var publish: Swift.Bool
    /// Only update the function if the revision ID matches the ID that's specified. Use this option to avoid modifying a function that has changed since you last read it.
    public var revisionId: Swift.String?
    /// An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.
    public var s3Bucket: Swift.String?
    /// The Amazon S3 key of the deployment package.
    public var s3Key: Swift.String?
    /// For versioned objects, the version of the deployment package object to use.
    public var s3ObjectVersion: Swift.String?
    /// The base64-encoded contents of the deployment package. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for you.
    public var zipFile: ClientRuntime.Data?

    public init (
        architectures: [LambdaClientTypes.Architecture]? = nil,
        dryRun: Swift.Bool = false,
        functionName: Swift.String? = nil,
        imageUri: Swift.String? = nil,
        publish: Swift.Bool = false,
        revisionId: Swift.String? = nil,
        s3Bucket: Swift.String? = nil,
        s3Key: Swift.String? = nil,
        s3ObjectVersion: Swift.String? = nil,
        zipFile: ClientRuntime.Data? = nil
    )
    {
        self.architectures = architectures
        self.dryRun = dryRun
        self.functionName = functionName
        self.imageUri = imageUri
        self.publish = publish
        self.revisionId = revisionId
        self.s3Bucket = s3Bucket
        self.s3Key = s3Key
        self.s3ObjectVersion = s3ObjectVersion
        self.zipFile = zipFile
    }
}

struct UpdateFunctionCodeInputBody: Swift.Equatable {
    let zipFile: ClientRuntime.Data?
    let s3Bucket: Swift.String?
    let s3Key: Swift.String?
    let s3ObjectVersion: Swift.String?
    let imageUri: Swift.String?
    let publish: Swift.Bool
    let dryRun: Swift.Bool
    let revisionId: Swift.String?
    let architectures: [LambdaClientTypes.Architecture]?
}

extension UpdateFunctionCodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case dryRun = "DryRun"
        case imageUri = "ImageUri"
        case publish = "Publish"
        case revisionId = "RevisionId"
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
        case s3ObjectVersion = "S3ObjectVersion"
        case zipFile = "ZipFile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zipFileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .zipFile)
        zipFile = zipFileDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let s3ObjectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ObjectVersion)
        s3ObjectVersion = s3ObjectVersionDecoded
        let imageUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageUri)
        imageUri = imageUriDecoded
        let publishDecoded = try containerValues.decode(Swift.Bool.self, forKey: .publish)
        publish = publishDecoded
        let dryRunDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
    }
}

extension UpdateFunctionCodeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFunctionCodeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CodeSigningConfigNotFoundException" : self = .codeSigningConfigNotFoundException(try CodeSigningConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CodeStorageExceededException" : self = .codeStorageExceededException(try CodeStorageExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CodeVerificationFailedException" : self = .codeVerificationFailedException(try CodeVerificationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCodeSignatureException" : self = .invalidCodeSignatureException(try InvalidCodeSignatureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFunctionCodeOutputError: Swift.Error, Swift.Equatable {
    case codeSigningConfigNotFoundException(CodeSigningConfigNotFoundException)
    case codeStorageExceededException(CodeStorageExceededException)
    case codeVerificationFailedException(CodeVerificationFailedException)
    case invalidCodeSignatureException(InvalidCodeSignatureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFunctionCodeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFunctionCodeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.architectures = output.architectures
            self.codeSha256 = output.codeSha256
            self.codeSize = output.codeSize
            self.deadLetterConfig = output.deadLetterConfig
            self.description = output.description
            self.environment = output.environment
            self.fileSystemConfigs = output.fileSystemConfigs
            self.functionArn = output.functionArn
            self.functionName = output.functionName
            self.handler = output.handler
            self.imageConfigResponse = output.imageConfigResponse
            self.kMSKeyArn = output.kMSKeyArn
            self.lastModified = output.lastModified
            self.lastUpdateStatus = output.lastUpdateStatus
            self.lastUpdateStatusReason = output.lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = output.lastUpdateStatusReasonCode
            self.layers = output.layers
            self.masterArn = output.masterArn
            self.memorySize = output.memorySize
            self.packageType = output.packageType
            self.revisionId = output.revisionId
            self.role = output.role
            self.runtime = output.runtime
            self.signingJobArn = output.signingJobArn
            self.signingProfileVersionArn = output.signingProfileVersionArn
            self.state = output.state
            self.stateReason = output.stateReason
            self.stateReasonCode = output.stateReasonCode
            self.timeout = output.timeout
            self.tracingConfig = output.tracingConfig
            self.version = output.version
            self.vpcConfig = output.vpcConfig
        } else {
            self.architectures = nil
            self.codeSha256 = nil
            self.codeSize = 0
            self.deadLetterConfig = nil
            self.description = nil
            self.environment = nil
            self.fileSystemConfigs = nil
            self.functionArn = nil
            self.functionName = nil
            self.handler = nil
            self.imageConfigResponse = nil
            self.kMSKeyArn = nil
            self.lastModified = nil
            self.lastUpdateStatus = nil
            self.lastUpdateStatusReason = nil
            self.lastUpdateStatusReasonCode = nil
            self.layers = nil
            self.masterArn = nil
            self.memorySize = nil
            self.packageType = nil
            self.revisionId = nil
            self.role = nil
            self.runtime = nil
            self.signingJobArn = nil
            self.signingProfileVersionArn = nil
            self.state = nil
            self.stateReason = nil
            self.stateReasonCode = nil
            self.timeout = nil
            self.tracingConfig = nil
            self.version = nil
            self.vpcConfig = nil
        }
    }
}

/// Details about a function's configuration.
public struct UpdateFunctionCodeOutputResponse: Swift.Equatable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html).
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin executing your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've configured a customer managed key.
    public var kMSKeyArn: Swift.String?
    /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's [ layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public var layers: [LambdaClientTypes.Layer]?
    /// For Lambda@Edge functions, the ARN of the main function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The runtime environment for the Lambda function.
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init (
        architectures: [LambdaClientTypes.Architecture]? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kMSKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    )
    {
        self.architectures = architectures
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kMSKeyArn = kMSKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

struct UpdateFunctionCodeOutputResponseBody: Swift.Equatable {
    let functionName: Swift.String?
    let functionArn: Swift.String?
    let runtime: LambdaClientTypes.Runtime?
    let role: Swift.String?
    let handler: Swift.String?
    let codeSize: Swift.Int
    let description: Swift.String?
    let timeout: Swift.Int?
    let memorySize: Swift.Int?
    let lastModified: Swift.String?
    let codeSha256: Swift.String?
    let version: Swift.String?
    let vpcConfig: LambdaClientTypes.VpcConfigResponse?
    let deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    let environment: LambdaClientTypes.EnvironmentResponse?
    let kMSKeyArn: Swift.String?
    let tracingConfig: LambdaClientTypes.TracingConfigResponse?
    let masterArn: Swift.String?
    let revisionId: Swift.String?
    let layers: [LambdaClientTypes.Layer]?
    let state: LambdaClientTypes.State?
    let stateReason: Swift.String?
    let stateReasonCode: LambdaClientTypes.StateReasonCode?
    let lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    let lastUpdateStatusReason: Swift.String?
    let lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    let fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    let packageType: LambdaClientTypes.PackageType?
    let imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    let signingProfileVersionArn: Swift.String?
    let signingJobArn: Swift.String?
    let architectures: [LambdaClientTypes.Architecture]?
}

extension UpdateFunctionCodeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kMSKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[LambdaClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [LambdaClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
    }
}

extension UpdateFunctionConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case handler = "Handler"
        case imageConfig = "ImageConfig"
        case kMSKeyArn = "KMSKeyArn"
        case layers = "Layers"
        case memorySize = "MemorySize"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deadLetterConfig = deadLetterConfig {
            try encodeContainer.encode(deadLetterConfig, forKey: .deadLetterConfig)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environment = environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let fileSystemConfigs = fileSystemConfigs {
            var fileSystemConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemConfigs)
            for filesystemconfiglist0 in fileSystemConfigs {
                try fileSystemConfigsContainer.encode(filesystemconfiglist0)
            }
        }
        if let handler = handler {
            try encodeContainer.encode(handler, forKey: .handler)
        }
        if let imageConfig = imageConfig {
            try encodeContainer.encode(imageConfig, forKey: .imageConfig)
        }
        if let kMSKeyArn = kMSKeyArn {
            try encodeContainer.encode(kMSKeyArn, forKey: .kMSKeyArn)
        }
        if let layers = layers {
            var layersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layers)
            for layerlist0 in layers {
                try layersContainer.encode(layerlist0)
            }
        }
        if let memorySize = memorySize {
            try encodeContainer.encode(memorySize, forKey: .memorySize)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let runtime = runtime {
            try encodeContainer.encode(runtime.rawValue, forKey: .runtime)
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let tracingConfig = tracingConfig {
            try encodeContainer.encode(tracingConfig, forKey: .tracingConfig)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

extension UpdateFunctionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/configuration"
    }
}

public struct UpdateFunctionConfigurationInput: Swift.Equatable {
    /// A dead letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see [Dead Letter Queues](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq).
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// A description of the function.
    public var description: Swift.String?
    /// Environment variables that are accessible from function code during execution.
    public var environment: LambdaClientTypes.Environment?
    /// Connection settings for an Amazon EFS file system.
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - my-function.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The name of the method within your code that Lambda calls to execute your function. Handler is required if the deployment package is a .zip file archive. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see [Programming Model](https://docs.aws.amazon.com/lambda/latest/dg/programming-model-v2.html).
    public var handler: Swift.String?
    /// [Container image configuration values](https://docs.aws.amazon.com/lambda/latest/dg/images-parms.html) that override the values in the container image Docker file.
    public var imageConfig: LambdaClientTypes.ImageConfig?
    /// The ARN of the Amazon Web Services Key Management Service (KMS) key that's used to encrypt your function's environment variables. If it's not provided, Lambda uses a default service key.
    public var kMSKeyArn: Swift.String?
    /// A list of [function layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) to add to the function's execution environment. Specify each layer by its ARN, including the version.
    public var layers: [Swift.String]?
    /// The amount of [memory available to the function](https://docs.aws.amazon.com/lambda/latest/dg/configuration-memory.html) at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
    public var memorySize: Swift.Int?
    /// Only update the function if the revision ID matches the ID that's specified. Use this option to avoid modifying a function that has changed since you last read it.
    public var revisionId: Swift.String?
    /// The Amazon Resource Name (ARN) of the function's execution role.
    public var role: Swift.String?
    /// The identifier of the function's [runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive.
    public var runtime: LambdaClientTypes.Runtime?
    /// The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For additional information, see [Lambda execution environment](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html).
    public var timeout: Swift.Int?
    /// Set Mode to Active to sample and trace a subset of incoming requests with [X-Ray](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html).
    public var tracingConfig: LambdaClientTypes.TracingConfig?
    /// For network connectivity to Amazon Web Services resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can only access resources and the internet through that VPC. For more information, see [VPC Settings](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
    public var vpcConfig: LambdaClientTypes.VpcConfig?

    public init (
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.Environment? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfig: LambdaClientTypes.ImageConfig? = nil,
        kMSKeyArn: Swift.String? = nil,
        layers: [Swift.String]? = nil,
        memorySize: Swift.Int? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfig? = nil,
        vpcConfig: LambdaClientTypes.VpcConfig? = nil
    )
    {
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.fileSystemConfigs = fileSystemConfigs
        self.functionName = functionName
        self.handler = handler
        self.imageConfig = imageConfig
        self.kMSKeyArn = kMSKeyArn
        self.layers = layers
        self.memorySize = memorySize
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.vpcConfig = vpcConfig
    }
}

struct UpdateFunctionConfigurationInputBody: Swift.Equatable {
    let role: Swift.String?
    let handler: Swift.String?
    let description: Swift.String?
    let timeout: Swift.Int?
    let memorySize: Swift.Int?
    let vpcConfig: LambdaClientTypes.VpcConfig?
    let environment: LambdaClientTypes.Environment?
    let runtime: LambdaClientTypes.Runtime?
    let deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    let kMSKeyArn: Swift.String?
    let tracingConfig: LambdaClientTypes.TracingConfig?
    let revisionId: Swift.String?
    let layers: [Swift.String]?
    let fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    let imageConfig: LambdaClientTypes.ImageConfig?
}

extension UpdateFunctionConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case handler = "Handler"
        case imageConfig = "ImageConfig"
        case kMSKeyArn = "KMSKeyArn"
        case layers = "Layers"
        case memorySize = "MemorySize"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfig.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layers)
        var layersDecoded0:[Swift.String]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [Swift.String]()
            for string0 in layersContainer {
                if let string0 = string0 {
                    layersDecoded0?.append(string0)
                }
            }
        }
        layers = layersDecoded0
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let imageConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfig.self, forKey: .imageConfig)
        imageConfig = imageConfigDecoded
    }
}

extension UpdateFunctionConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFunctionConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CodeSigningConfigNotFoundException" : self = .codeSigningConfigNotFoundException(try CodeSigningConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CodeVerificationFailedException" : self = .codeVerificationFailedException(try CodeVerificationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCodeSignatureException" : self = .invalidCodeSignatureException(try InvalidCodeSignatureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFunctionConfigurationOutputError: Swift.Error, Swift.Equatable {
    case codeSigningConfigNotFoundException(CodeSigningConfigNotFoundException)
    case codeVerificationFailedException(CodeVerificationFailedException)
    case invalidCodeSignatureException(InvalidCodeSignatureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFunctionConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFunctionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.architectures = output.architectures
            self.codeSha256 = output.codeSha256
            self.codeSize = output.codeSize
            self.deadLetterConfig = output.deadLetterConfig
            self.description = output.description
            self.environment = output.environment
            self.fileSystemConfigs = output.fileSystemConfigs
            self.functionArn = output.functionArn
            self.functionName = output.functionName
            self.handler = output.handler
            self.imageConfigResponse = output.imageConfigResponse
            self.kMSKeyArn = output.kMSKeyArn
            self.lastModified = output.lastModified
            self.lastUpdateStatus = output.lastUpdateStatus
            self.lastUpdateStatusReason = output.lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = output.lastUpdateStatusReasonCode
            self.layers = output.layers
            self.masterArn = output.masterArn
            self.memorySize = output.memorySize
            self.packageType = output.packageType
            self.revisionId = output.revisionId
            self.role = output.role
            self.runtime = output.runtime
            self.signingJobArn = output.signingJobArn
            self.signingProfileVersionArn = output.signingProfileVersionArn
            self.state = output.state
            self.stateReason = output.stateReason
            self.stateReasonCode = output.stateReasonCode
            self.timeout = output.timeout
            self.tracingConfig = output.tracingConfig
            self.version = output.version
            self.vpcConfig = output.vpcConfig
        } else {
            self.architectures = nil
            self.codeSha256 = nil
            self.codeSize = 0
            self.deadLetterConfig = nil
            self.description = nil
            self.environment = nil
            self.fileSystemConfigs = nil
            self.functionArn = nil
            self.functionName = nil
            self.handler = nil
            self.imageConfigResponse = nil
            self.kMSKeyArn = nil
            self.lastModified = nil
            self.lastUpdateStatus = nil
            self.lastUpdateStatusReason = nil
            self.lastUpdateStatusReasonCode = nil
            self.layers = nil
            self.masterArn = nil
            self.memorySize = nil
            self.packageType = nil
            self.revisionId = nil
            self.role = nil
            self.runtime = nil
            self.signingJobArn = nil
            self.signingProfileVersionArn = nil
            self.state = nil
            self.stateReason = nil
            self.stateReasonCode = nil
            self.timeout = nil
            self.tracingConfig = nil
            self.version = nil
            self.vpcConfig = nil
        }
    }
}

/// Details about a function's configuration.
public struct UpdateFunctionConfigurationOutputResponse: Swift.Equatable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html).
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin executing your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've configured a customer managed key.
    public var kMSKeyArn: Swift.String?
    /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's [ layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public var layers: [LambdaClientTypes.Layer]?
    /// For Lambda@Edge functions, the ARN of the main function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The runtime environment for the Lambda function.
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init (
        architectures: [LambdaClientTypes.Architecture]? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kMSKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    )
    {
        self.architectures = architectures
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kMSKeyArn = kMSKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

struct UpdateFunctionConfigurationOutputResponseBody: Swift.Equatable {
    let functionName: Swift.String?
    let functionArn: Swift.String?
    let runtime: LambdaClientTypes.Runtime?
    let role: Swift.String?
    let handler: Swift.String?
    let codeSize: Swift.Int
    let description: Swift.String?
    let timeout: Swift.Int?
    let memorySize: Swift.Int?
    let lastModified: Swift.String?
    let codeSha256: Swift.String?
    let version: Swift.String?
    let vpcConfig: LambdaClientTypes.VpcConfigResponse?
    let deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    let environment: LambdaClientTypes.EnvironmentResponse?
    let kMSKeyArn: Swift.String?
    let tracingConfig: LambdaClientTypes.TracingConfigResponse?
    let masterArn: Swift.String?
    let revisionId: Swift.String?
    let layers: [LambdaClientTypes.Layer]?
    let state: LambdaClientTypes.State?
    let stateReason: Swift.String?
    let stateReasonCode: LambdaClientTypes.StateReasonCode?
    let lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    let lastUpdateStatusReason: Swift.String?
    let lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    let fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    let packageType: LambdaClientTypes.PackageType?
    let imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    let signingProfileVersionArn: Swift.String?
    let signingJobArn: Swift.String?
    let architectures: [LambdaClientTypes.Architecture]?
}

extension UpdateFunctionConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kMSKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[LambdaClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [LambdaClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
    }
}

extension UpdateFunctionEventInvokeConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfig = destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let maximumEventAgeInSeconds = maximumEventAgeInSeconds {
            try encodeContainer.encode(maximumEventAgeInSeconds, forKey: .maximumEventAgeInSeconds)
        }
        if let maximumRetryAttempts = maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
    }
}

extension UpdateFunctionEventInvokeConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let qualifier = qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension UpdateFunctionEventInvokeConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config"
    }
}

public struct UpdateFunctionEventInvokeConfigInput: Swift.Equatable {
    /// A destination for events after they have been sent to a function for processing. Destinations
    ///
    /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    /// * Queue - The ARN of an SQS queue.
    ///
    /// * Topic - The ARN of an SNS topic.
    ///
    /// * Event Bus - The ARN of an Amazon EventBridge event bus.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The name of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?
    /// A version number or alias name.
    public var qualifier: Swift.String?

    public init (
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionName: Swift.String? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionName = functionName
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.qualifier = qualifier
    }
}

struct UpdateFunctionEventInvokeConfigInputBody: Swift.Equatable {
    let maximumRetryAttempts: Swift.Int?
    let maximumEventAgeInSeconds: Swift.Int?
    let destinationConfig: LambdaClientTypes.DestinationConfig?
}

extension UpdateFunctionEventInvokeConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

extension UpdateFunctionEventInvokeConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFunctionEventInvokeConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFunctionEventInvokeConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFunctionEventInvokeConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFunctionEventInvokeConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinationConfig = output.destinationConfig
            self.functionArn = output.functionArn
            self.lastModified = output.lastModified
            self.maximumEventAgeInSeconds = output.maximumEventAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
        } else {
            self.destinationConfig = nil
            self.functionArn = nil
            self.lastModified = nil
            self.maximumEventAgeInSeconds = nil
            self.maximumRetryAttempts = nil
        }
    }
}

public struct UpdateFunctionEventInvokeConfigOutputResponse: Swift.Equatable {
    /// A destination for events after they have been sent to a function for processing. Destinations
    ///
    /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    /// * Queue - The ARN of an SQS queue.
    ///
    /// * Topic - The ARN of an SNS topic.
    ///
    /// * Event Bus - The ARN of an Amazon EventBridge event bus.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The Amazon Resource Name (ARN) of the function.
    public var functionArn: Swift.String?
    /// The date and time that the configuration was last updated.
    public var lastModified: ClientRuntime.Date?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?

    public init (
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionArn: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionArn = functionArn
        self.lastModified = lastModified
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
    }
}

struct UpdateFunctionEventInvokeConfigOutputResponseBody: Swift.Equatable {
    let lastModified: ClientRuntime.Date?
    let functionArn: Swift.String?
    let maximumRetryAttempts: Swift.Int?
    let maximumEventAgeInSeconds: Swift.Int?
    let destinationConfig: LambdaClientTypes.DestinationConfig?
}

extension UpdateFunctionEventInvokeConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case functionArn = "FunctionArn"
        case lastModified = "LastModified"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

extension LambdaClientTypes.VpcConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension LambdaClientTypes {
    /// The VPC security groups and subnets that are attached to a Lambda function. For more information, see [VPC Settings](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
    public struct VpcConfig: Swift.Equatable {
        /// A list of VPC security groups IDs.
        public var securityGroupIds: [Swift.String]?
        /// A list of VPC subnet IDs.
        public var subnetIds: [Swift.String]?

        public init (
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension LambdaClientTypes.VpcConfigResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension LambdaClientTypes {
    /// The VPC security groups and subnets that are attached to a Lambda function.
    public struct VpcConfigResponse: Swift.Equatable {
        /// A list of VPC security groups IDs.
        public var securityGroupIds: [Swift.String]?
        /// A list of VPC subnet IDs.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init (
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}
