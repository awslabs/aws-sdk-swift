// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class EksClient {
    let client: SdkHttpClient
    let config: EksClientConfiguration
    let serviceName = "EKS"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: EksClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class EksClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> EksClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try EksClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension EksClient: EksClientProtocol {
    /// <p>Associate encryption configuration to an existing cluster.</p>
    ///         <p>You can use this API to enable encryption on existing clusters which do not have
    ///             encryption already enabled. This allows you to implement a defense-in-depth security
    ///             strategy without migrating applications to new EKS clusters.</p>
    public func associateEncryptionConfig(input: AssociateEncryptionConfigInput, completion: @escaping (SdkResult<AssociateEncryptionConfigOutputResponse, AssociateEncryptionConfigOutputError>) -> Void)
    {
        guard let clusterName = input.clusterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component clusterName unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(clusterName)/encryption-config/associate"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateEncryptionConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateEncryptionConfigInput, AssociateEncryptionConfigOutputResponse, AssociateEncryptionConfigOutputError>(id: "associateEncryptionConfig")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<AssociateEncryptionConfigOutputResponse>, SdkError<AssociateEncryptionConfigOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: AssociateEncryptionConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateEncryptionConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateEncryptionConfigInput, AssociateEncryptionConfigOutputResponse, AssociateEncryptionConfigOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AssociateEncryptionConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Associate an identity provider configuration to a cluster.</p>
    ///         <p>If you want to authenticate identities using an identity provider, you can create an
    ///             identity provider configuration and associate it to your cluster. After configuring
    ///             authentication to your cluster you can create Kubernetes <code>roles</code> and
    ///                 <code>clusterroles</code> to assign permissions to the roles, and then bind the
    ///             roles to the identities using Kubernetes <code>rolebindings</code> and
    ///                 <code>clusterrolebindings</code>. For more information see <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">Using RBAC
    ///                 Authorization</a> in the Kubernetes documentation.</p>
    public func associateIdentityProviderConfig(input: AssociateIdentityProviderConfigInput, completion: @escaping (SdkResult<AssociateIdentityProviderConfigOutputResponse, AssociateIdentityProviderConfigOutputError>) -> Void)
    {
        guard let clusterName = input.clusterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component clusterName unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(clusterName)/identity-provider-configs/associate"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateIdentityProviderConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateIdentityProviderConfigInput, AssociateIdentityProviderConfigOutputResponse, AssociateIdentityProviderConfigOutputError>(id: "associateIdentityProviderConfig")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<AssociateIdentityProviderConfigOutputResponse>, SdkError<AssociateIdentityProviderConfigOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: AssociateIdentityProviderConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateIdentityProviderConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateIdentityProviderConfigInput, AssociateIdentityProviderConfigOutputResponse, AssociateIdentityProviderConfigOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AssociateIdentityProviderConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an Amazon EKS add-on.</p>
    ///         <p>Amazon EKS add-ons help to automate the provisioning and lifecycle management of common
    ///             operational software for Amazon EKS clusters. Amazon EKS add-ons can only be used with Amazon EKS
    ///             clusters running version 1.18 with platform version <code>eks.3</code> or later because
    ///             add-ons rely on the Server-side Apply Kubernetes feature, which is only available in
    ///             Kubernetes 1.18 and later.</p>
    public func createAddon(input: CreateAddonInput, completion: @escaping (SdkResult<CreateAddonOutputResponse, CreateAddonOutputError>) -> Void)
    {
        guard let clusterName = input.clusterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component clusterName unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(clusterName)/addons"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createAddon")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateAddonInput, CreateAddonOutputResponse, CreateAddonOutputError>(id: "createAddon")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateAddonOutputResponse>, SdkError<CreateAddonOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateAddonInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateAddonInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateAddonInput, CreateAddonOutputResponse, CreateAddonOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateAddonInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an Amazon EKS control plane. </p>
    ///         <p>The Amazon EKS control plane consists of control plane instances that run the Kubernetes
    ///             software, such as <code>etcd</code> and the API server. The control plane runs in an
    ///             account managed by AWS, and the Kubernetes API is exposed via the Amazon EKS API server
    ///             endpoint. Each Amazon EKS cluster control plane is single-tenant and unique and runs on its
    ///             own set of Amazon EC2 instances.</p>
    ///         <p>The cluster control plane is provisioned across multiple Availability Zones and
    ///             fronted by an Elastic Load Balancing Network Load Balancer. Amazon EKS also provisions elastic network interfaces in your VPC
    ///             subnets to provide connectivity from the control plane instances to the nodes (for
    ///             example, to support <code>kubectl exec</code>, <code>logs</code>, and <code>proxy</code>
    ///             data flows).</p>
    ///         <p>Amazon EKS nodes run in your AWS account and connect to your cluster's control plane via
    ///             the Kubernetes API server endpoint and a certificate file that is created for your
    ///             cluster.</p>
    ///
    ///         <p>Cluster creation typically takes several minutes. After you create an Amazon EKS cluster,
    ///             you must configure your Kubernetes tooling to communicate with the API server and launch
    ///             nodes into your cluster. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/managing-auth.html">Managing Cluster
    ///                 Authentication</a> and <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-workers.html">Launching Amazon EKS nodes</a> in the <i>Amazon EKS User Guide</i>.</p>
    public func createCluster(input: CreateClusterInput, completion: @escaping (SdkResult<CreateClusterOutputResponse, CreateClusterOutputError>) -> Void)
    {
        let urlPath = "/clusters"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createCluster")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateClusterInput, CreateClusterOutputResponse, CreateClusterOutputError>(id: "createCluster")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateClusterOutputResponse>, SdkError<CreateClusterOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateClusterInput, CreateClusterOutputResponse, CreateClusterOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an AWS Fargate profile for your Amazon EKS cluster. You must have at least one Fargate
    ///             profile in a cluster to be able to run pods on Fargate.</p>
    ///         <p>The Fargate profile allows an administrator to declare which pods run on Fargate and specify
    ///             which pods run on which Fargate profile. This declaration is done through the profile’s
    ///             selectors. Each profile can have up to five selectors that contain a namespace and
    ///             labels. A namespace is required for every selector. The label field consists of multiple
    ///             optional key-value pairs. Pods that match the selectors are scheduled on Fargate. If a
    ///             to-be-scheduled pod matches any of the selectors in the Fargate profile, then that pod is
    ///             run on Fargate.</p>
    ///         <p>When you create a Fargate profile, you must specify a pod execution role to use with the
    ///             pods that are scheduled with the profile. This role is added to the cluster's Kubernetes
    ///                 <a href="https://kubernetes.io/docs/admin/authorization/rbac/">Role Based Access
    ///                 Control</a> (RBAC) for authorization so that the <code>kubelet</code> that is
    ///             running on the Fargate infrastructure can register with your Amazon EKS cluster so that it can
    ///             appear in your cluster as a node. The pod execution role also provides IAM permissions
    ///             to the Fargate infrastructure to allow read access to Amazon ECR image repositories. For more
    ///             information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/pod-execution-role.html">Pod Execution Role</a> in the <i>Amazon EKS User Guide</i>.</p>
    ///         <p>Fargate profiles are immutable. However, you can create a new updated profile to replace
    ///             an existing profile and then delete the original after the updated profile has finished
    ///             creating.</p>
    ///         <p>If any Fargate profiles in a cluster are in the <code>DELETING</code> status, you must
    ///             wait for that Fargate profile to finish deleting before you can create any other profiles
    ///             in that cluster.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/fargate-profile.html">AWS Fargate Profile</a> in the <i>Amazon EKS User Guide</i>.</p>
    public func createFargateProfile(input: CreateFargateProfileInput, completion: @escaping (SdkResult<CreateFargateProfileOutputResponse, CreateFargateProfileOutputError>) -> Void)
    {
        guard let clusterName = input.clusterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component clusterName unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(clusterName)/fargate-profiles"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createFargateProfile")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateFargateProfileInput, CreateFargateProfileOutputResponse, CreateFargateProfileOutputError>(id: "createFargateProfile")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateFargateProfileOutputResponse>, SdkError<CreateFargateProfileOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateFargateProfileInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateFargateProfileInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateFargateProfileInput, CreateFargateProfileOutputResponse, CreateFargateProfileOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateFargateProfileInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a managed node group for an Amazon EKS cluster. You can only create a node group
    ///             for your cluster that is equal to the current Kubernetes version for the cluster. All
    ///             node groups are created with the latest AMI release version for the respective minor
    ///             Kubernetes version of the cluster, unless you deploy a custom AMI using a launch
    ///             template. For more information about using launch templates, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch
    ///                 template support</a>.</p>
    ///         <p>An Amazon EKS managed node group is an Amazon EC2 Auto Scaling group and associated Amazon EC2 instances that
    ///             are managed by AWS for an Amazon EKS cluster. Each node group uses a version of the Amazon EKS
    ///             optimized Amazon Linux 2 AMI. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html">Managed
    ///                 Node Groups</a> in the <i>Amazon EKS User Guide</i>. </p>
    public func createNodegroup(input: CreateNodegroupInput, completion: @escaping (SdkResult<CreateNodegroupOutputResponse, CreateNodegroupOutputError>) -> Void)
    {
        guard let clusterName = input.clusterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component clusterName unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(clusterName)/node-groups"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createNodegroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateNodegroupInput, CreateNodegroupOutputResponse, CreateNodegroupOutputError>(id: "createNodegroup")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateNodegroupOutputResponse>, SdkError<CreateNodegroupOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateNodegroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateNodegroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateNodegroupInput, CreateNodegroupOutputResponse, CreateNodegroupOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateNodegroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Delete an Amazon EKS add-on.</p>
    ///         <p>When you remove the add-on, it will also be deleted from the cluster. You can always
    ///             manually start an add-on on the cluster using the Kubernetes API.</p>
    public func deleteAddon(input: DeleteAddonInput, completion: @escaping (SdkResult<DeleteAddonOutputResponse, DeleteAddonOutputError>) -> Void)
    {
        guard let clusterName = input.clusterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component clusterName unexpectedly nil"))))
            return
        }
        guard let addonName = input.addonName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component addonName unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(clusterName)/addons/\(addonName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteAddon")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteAddonInput, DeleteAddonOutputResponse, DeleteAddonOutputError>(id: "deleteAddon")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteAddonInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteAddonInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteAddonInput, DeleteAddonOutputResponse, DeleteAddonOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the Amazon EKS cluster control plane.</p>
    ///         <p>If you have active services in your cluster that are associated with a load balancer,
    ///             you must delete those services before deleting the cluster so that the load balancers
    ///             are deleted properly. Otherwise, you can have orphaned resources in your VPC that
    ///             prevent you from being able to delete the VPC. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/delete-cluster.html">Deleting a
    ///                 Cluster</a> in the <i>Amazon EKS User Guide</i>.</p>
    ///         <p>If you have managed node groups or Fargate profiles attached to the cluster, you must
    ///             delete them first. For more information, see <a>DeleteNodegroup</a> and <a>DeleteFargateProfile</a>.</p>
    public func deleteCluster(input: DeleteClusterInput, completion: @escaping (SdkResult<DeleteClusterOutputResponse, DeleteClusterOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(name)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteCluster")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteClusterInput, DeleteClusterOutputResponse, DeleteClusterOutputError>(id: "deleteCluster")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteClusterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteClusterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteClusterInput, DeleteClusterOutputResponse, DeleteClusterOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an AWS Fargate profile.</p>
    ///         <p>When you delete a Fargate profile, any pods running on Fargate that were created with the
    ///             profile are deleted. If those pods match another Fargate profile, then they are scheduled
    ///             on Fargate with that profile. If they no longer match any Fargate profiles, then they are not
    ///             scheduled on Fargate and they may remain in a pending state.</p>
    ///         <p>Only one Fargate profile in a cluster can be in the <code>DELETING</code> status at a
    ///             time. You must wait for a Fargate profile to finish deleting before you can delete any
    ///             other profiles in that cluster.</p>
    public func deleteFargateProfile(input: DeleteFargateProfileInput, completion: @escaping (SdkResult<DeleteFargateProfileOutputResponse, DeleteFargateProfileOutputError>) -> Void)
    {
        guard let clusterName = input.clusterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component clusterName unexpectedly nil"))))
            return
        }
        guard let fargateProfileName = input.fargateProfileName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component fargateProfileName unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(clusterName)/fargate-profiles/\(fargateProfileName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteFargateProfile")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteFargateProfileInput, DeleteFargateProfileOutputResponse, DeleteFargateProfileOutputError>(id: "deleteFargateProfile")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteFargateProfileInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteFargateProfileInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteFargateProfileInput, DeleteFargateProfileOutputResponse, DeleteFargateProfileOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an Amazon EKS node group for a cluster.</p>
    public func deleteNodegroup(input: DeleteNodegroupInput, completion: @escaping (SdkResult<DeleteNodegroupOutputResponse, DeleteNodegroupOutputError>) -> Void)
    {
        guard let clusterName = input.clusterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component clusterName unexpectedly nil"))))
            return
        }
        guard let nodegroupName = input.nodegroupName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component nodegroupName unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(clusterName)/node-groups/\(nodegroupName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteNodegroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteNodegroupInput, DeleteNodegroupOutputResponse, DeleteNodegroupOutputError>(id: "deleteNodegroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteNodegroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteNodegroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteNodegroupInput, DeleteNodegroupOutputResponse, DeleteNodegroupOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes an Amazon EKS add-on.</p>
    public func describeAddon(input: DescribeAddonInput, completion: @escaping (SdkResult<DescribeAddonOutputResponse, DescribeAddonOutputError>) -> Void)
    {
        guard let clusterName = input.clusterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component clusterName unexpectedly nil"))))
            return
        }
        guard let addonName = input.addonName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component addonName unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(clusterName)/addons/\(addonName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeAddon")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeAddonInput, DescribeAddonOutputResponse, DescribeAddonOutputError>(id: "describeAddon")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeAddonInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeAddonInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeAddonInput, DescribeAddonOutputResponse, DescribeAddonOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the Kubernetes versions that the add-on can be used with.</p>
    public func describeAddonVersions(input: DescribeAddonVersionsInput, completion: @escaping (SdkResult<DescribeAddonVersionsOutputResponse, DescribeAddonVersionsOutputError>) -> Void)
    {
        let urlPath = "/addons/supported-versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeAddonVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeAddonVersionsInput, DescribeAddonVersionsOutputResponse, DescribeAddonVersionsOutputError>(id: "describeAddonVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeAddonVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeAddonVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeAddonVersionsInput, DescribeAddonVersionsOutputResponse, DescribeAddonVersionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns descriptive information about an Amazon EKS cluster.</p>
    ///         <p>The API server endpoint and certificate authority data returned by this operation are
    ///             required for <code>kubelet</code> and <code>kubectl</code> to communicate with your
    ///             Kubernetes API server. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html">Create a
    ///                 kubeconfig for Amazon EKS</a>.</p>
    ///         <note>
    ///             <p>The API server endpoint and certificate authority data aren't available until the
    ///                 cluster reaches the <code>ACTIVE</code> state.</p>
    ///         </note>
    public func describeCluster(input: DescribeClusterInput, completion: @escaping (SdkResult<DescribeClusterOutputResponse, DescribeClusterOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(name)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeCluster")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeClusterInput, DescribeClusterOutputResponse, DescribeClusterOutputError>(id: "describeCluster")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeClusterInput, DescribeClusterOutputResponse, DescribeClusterOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns descriptive information about an AWS Fargate profile.</p>
    public func describeFargateProfile(input: DescribeFargateProfileInput, completion: @escaping (SdkResult<DescribeFargateProfileOutputResponse, DescribeFargateProfileOutputError>) -> Void)
    {
        guard let clusterName = input.clusterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component clusterName unexpectedly nil"))))
            return
        }
        guard let fargateProfileName = input.fargateProfileName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component fargateProfileName unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(clusterName)/fargate-profiles/\(fargateProfileName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeFargateProfile")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeFargateProfileInput, DescribeFargateProfileOutputResponse, DescribeFargateProfileOutputError>(id: "describeFargateProfile")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeFargateProfileInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeFargateProfileInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeFargateProfileInput, DescribeFargateProfileOutputResponse, DescribeFargateProfileOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns descriptive information about an identity provider configuration.</p>
    public func describeIdentityProviderConfig(input: DescribeIdentityProviderConfigInput, completion: @escaping (SdkResult<DescribeIdentityProviderConfigOutputResponse, DescribeIdentityProviderConfigOutputError>) -> Void)
    {
        guard let clusterName = input.clusterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component clusterName unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(clusterName)/identity-provider-configs/describe"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeIdentityProviderConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeIdentityProviderConfigInput, DescribeIdentityProviderConfigOutputResponse, DescribeIdentityProviderConfigOutputError>(id: "describeIdentityProviderConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeIdentityProviderConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeIdentityProviderConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeIdentityProviderConfigInput, DescribeIdentityProviderConfigOutputResponse, DescribeIdentityProviderConfigOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeIdentityProviderConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns descriptive information about an Amazon EKS node group.</p>
    public func describeNodegroup(input: DescribeNodegroupInput, completion: @escaping (SdkResult<DescribeNodegroupOutputResponse, DescribeNodegroupOutputError>) -> Void)
    {
        guard let clusterName = input.clusterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component clusterName unexpectedly nil"))))
            return
        }
        guard let nodegroupName = input.nodegroupName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component nodegroupName unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(clusterName)/node-groups/\(nodegroupName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeNodegroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeNodegroupInput, DescribeNodegroupOutputResponse, DescribeNodegroupOutputError>(id: "describeNodegroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeNodegroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeNodegroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeNodegroupInput, DescribeNodegroupOutputResponse, DescribeNodegroupOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns descriptive information about an update against your Amazon EKS cluster or
    ///             associated managed node group.</p>
    ///         <p>When the status of the update is <code>Succeeded</code>, the update is complete. If an
    ///             update fails, the status is <code>Failed</code>, and an error detail explains the reason
    ///             for the failure.</p>
    public func describeUpdate(input: DescribeUpdateInput, completion: @escaping (SdkResult<DescribeUpdateOutputResponse, DescribeUpdateOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        guard let updateId = input.updateId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component updateId unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(name)/updates/\(updateId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeUpdate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeUpdateInput, DescribeUpdateOutputResponse, DescribeUpdateOutputError>(id: "describeUpdate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeUpdateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeUpdateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeUpdateInput, DescribeUpdateOutputResponse, DescribeUpdateOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Disassociates an identity provider configuration from a cluster. If you disassociate
    ///             an identity provider from your cluster, users included in the provider can no longer
    ///             access the cluster. However, you can still access the cluster with AWS IAM
    ///             users.</p>
    public func disassociateIdentityProviderConfig(input: DisassociateIdentityProviderConfigInput, completion: @escaping (SdkResult<DisassociateIdentityProviderConfigOutputResponse, DisassociateIdentityProviderConfigOutputError>) -> Void)
    {
        guard let clusterName = input.clusterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component clusterName unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(clusterName)/identity-provider-configs/disassociate"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disassociateIdentityProviderConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisassociateIdentityProviderConfigInput, DisassociateIdentityProviderConfigOutputResponse, DisassociateIdentityProviderConfigOutputError>(id: "disassociateIdentityProviderConfig")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<DisassociateIdentityProviderConfigOutputResponse>, SdkError<DisassociateIdentityProviderConfigOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: DisassociateIdentityProviderConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisassociateIdentityProviderConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisassociateIdentityProviderConfigInput, DisassociateIdentityProviderConfigOutputResponse, DisassociateIdentityProviderConfigOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DisassociateIdentityProviderConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the available add-ons.</p>
    public func listAddons(input: ListAddonsInput, completion: @escaping (SdkResult<ListAddonsOutputResponse, ListAddonsOutputError>) -> Void)
    {
        guard let clusterName = input.clusterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component clusterName unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(clusterName)/addons"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listAddons")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListAddonsInput, ListAddonsOutputResponse, ListAddonsOutputError>(id: "listAddons")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListAddonsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListAddonsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListAddonsInput, ListAddonsOutputResponse, ListAddonsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the Amazon EKS clusters in your AWS account in the specified Region.</p>
    public func listClusters(input: ListClustersInput, completion: @escaping (SdkResult<ListClustersOutputResponse, ListClustersOutputError>) -> Void)
    {
        let urlPath = "/clusters"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listClusters")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListClustersInput, ListClustersOutputResponse, ListClustersOutputError>(id: "listClusters")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListClustersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListClustersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListClustersInput, ListClustersOutputResponse, ListClustersOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the AWS Fargate profiles associated with the specified cluster in your AWS
    ///             account in the specified Region.</p>
    public func listFargateProfiles(input: ListFargateProfilesInput, completion: @escaping (SdkResult<ListFargateProfilesOutputResponse, ListFargateProfilesOutputError>) -> Void)
    {
        guard let clusterName = input.clusterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component clusterName unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(clusterName)/fargate-profiles"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listFargateProfiles")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListFargateProfilesInput, ListFargateProfilesOutputResponse, ListFargateProfilesOutputError>(id: "listFargateProfiles")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListFargateProfilesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListFargateProfilesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListFargateProfilesInput, ListFargateProfilesOutputResponse, ListFargateProfilesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>A list of identity provider configurations.</p>
    public func listIdentityProviderConfigs(input: ListIdentityProviderConfigsInput, completion: @escaping (SdkResult<ListIdentityProviderConfigsOutputResponse, ListIdentityProviderConfigsOutputError>) -> Void)
    {
        guard let clusterName = input.clusterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component clusterName unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(clusterName)/identity-provider-configs"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listIdentityProviderConfigs")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListIdentityProviderConfigsInput, ListIdentityProviderConfigsOutputResponse, ListIdentityProviderConfigsOutputError>(id: "listIdentityProviderConfigs")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListIdentityProviderConfigsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListIdentityProviderConfigsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListIdentityProviderConfigsInput, ListIdentityProviderConfigsOutputResponse, ListIdentityProviderConfigsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the Amazon EKS managed node groups associated with the specified cluster in your
    ///             AWS account in the specified Region. Self-managed node groups are not listed.</p>
    public func listNodegroups(input: ListNodegroupsInput, completion: @escaping (SdkResult<ListNodegroupsOutputResponse, ListNodegroupsOutputError>) -> Void)
    {
        guard let clusterName = input.clusterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component clusterName unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(clusterName)/node-groups"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listNodegroups")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListNodegroupsInput, ListNodegroupsOutputResponse, ListNodegroupsOutputError>(id: "listNodegroups")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListNodegroupsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListNodegroupsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListNodegroupsInput, ListNodegroupsOutputResponse, ListNodegroupsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List the tags for an Amazon EKS resource.</p>
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the updates associated with an Amazon EKS cluster or managed node group in your AWS
    ///             account, in the specified Region.</p>
    public func listUpdates(input: ListUpdatesInput, completion: @escaping (SdkResult<ListUpdatesOutputResponse, ListUpdatesOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(name)/updates"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listUpdates")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListUpdatesInput, ListUpdatesOutputResponse, ListUpdatesOutputError>(id: "listUpdates")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListUpdatesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListUpdatesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListUpdatesInput, ListUpdatesOutputResponse, ListUpdatesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Associates the specified tags to a resource with the specified
    ///                 <code>resourceArn</code>. If existing tags on a resource are not specified in the
    ///             request parameters, they are not changed. When a resource is deleted, the tags
    ///             associated with that resource are deleted as well. Tags that you create for Amazon EKS
    ///             resources do not propagate to any other resources associated with the cluster. For
    ///             example, if you tag a cluster with this operation, that tag does not automatically
    ///             propagate to the subnets and nodes associated with the cluster.</p>
    public func tagResource(input: TagResourceInput, completion: @escaping (SdkResult<TagResourceOutputResponse, TagResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes specified tags from a resource.</p>
    public func untagResource(input: UntagResourceInput, completion: @escaping (SdkResult<UntagResourceOutputResponse, UntagResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates an Amazon EKS add-on.</p>
    public func updateAddon(input: UpdateAddonInput, completion: @escaping (SdkResult<UpdateAddonOutputResponse, UpdateAddonOutputError>) -> Void)
    {
        guard let clusterName = input.clusterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component clusterName unexpectedly nil"))))
            return
        }
        guard let addonName = input.addonName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component addonName unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(clusterName)/addons/\(addonName)/update"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateAddon")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateAddonInput, UpdateAddonOutputResponse, UpdateAddonOutputError>(id: "updateAddon")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<UpdateAddonOutputResponse>, SdkError<UpdateAddonOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: UpdateAddonInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateAddonInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateAddonInput, UpdateAddonOutputResponse, UpdateAddonOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateAddonInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates an Amazon EKS cluster configuration. Your cluster continues to function during the
    ///             update. The response output includes an update ID that you can use to track the status
    ///             of your cluster update with the <a>DescribeUpdate</a> API operation.</p>
    ///         <p>You can use this API operation to enable or disable exporting the Kubernetes control
    ///             plane logs for your cluster to CloudWatch Logs. By default, cluster control plane logs aren't
    ///             exported to CloudWatch Logs. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/control-plane-logs.html">Amazon EKS
    ///                 Cluster Control Plane Logs</a> in the
    ///             <i>
    ///                <i>Amazon EKS User Guide</i>
    ///             </i>.</p>
    ///         <note>
    ///             <p>CloudWatch Logs ingestion, archive storage, and data scanning rates apply to exported
    ///                 control plane logs. For more information, see <a href="http://aws.amazon.com/cloudwatch/pricing/">Amazon CloudWatch Pricing</a>.</p>
    ///         </note>
    ///         <p>You can also use this API operation to enable or disable public and private access to
    ///             your cluster's Kubernetes API server endpoint. By default, public access is enabled, and
    ///             private access is disabled. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html">Amazon EKS Cluster
    ///                 Endpoint Access Control</a> in the <i>
    ///                <i>Amazon EKS User Guide</i>
    ///             </i>. </p>
    ///         <important>
    ///             <p>You can't update the subnets or security group IDs for an existing cluster.</p>
    ///         </important>
    ///         <p>Cluster updates are asynchronous, and they should finish within a few minutes. During
    ///             an update, the cluster status moves to <code>UPDATING</code> (this status transition is
    ///             eventually consistent). When the update is complete (either <code>Failed</code> or
    ///                 <code>Successful</code>), the cluster status moves to <code>Active</code>.</p>
    public func updateClusterConfig(input: UpdateClusterConfigInput, completion: @escaping (SdkResult<UpdateClusterConfigOutputResponse, UpdateClusterConfigOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(name)/update-config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateClusterConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateClusterConfigInput, UpdateClusterConfigOutputResponse, UpdateClusterConfigOutputError>(id: "updateClusterConfig")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<UpdateClusterConfigOutputResponse>, SdkError<UpdateClusterConfigOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: UpdateClusterConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateClusterConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateClusterConfigInput, UpdateClusterConfigOutputResponse, UpdateClusterConfigOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateClusterConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates an Amazon EKS cluster to the specified Kubernetes version. Your cluster continues
    ///             to function during the update. The response output includes an update ID that you can
    ///             use to track the status of your cluster update with the <a>DescribeUpdate</a>
    ///             API operation.</p>
    ///         <p>Cluster updates are asynchronous, and they should finish within a few minutes. During
    ///             an update, the cluster status moves to <code>UPDATING</code> (this status transition is
    ///             eventually consistent). When the update is complete (either <code>Failed</code> or
    ///                 <code>Successful</code>), the cluster status moves to <code>Active</code>.</p>
    ///         <p>If your cluster has managed node groups attached to it, all of your node groups’
    ///             Kubernetes versions must match the cluster’s Kubernetes version in order to update the
    ///             cluster to a new Kubernetes version.</p>
    public func updateClusterVersion(input: UpdateClusterVersionInput, completion: @escaping (SdkResult<UpdateClusterVersionOutputResponse, UpdateClusterVersionOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(name)/updates"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateClusterVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateClusterVersionInput, UpdateClusterVersionOutputResponse, UpdateClusterVersionOutputError>(id: "updateClusterVersion")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<UpdateClusterVersionOutputResponse>, SdkError<UpdateClusterVersionOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: UpdateClusterVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateClusterVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateClusterVersionInput, UpdateClusterVersionOutputResponse, UpdateClusterVersionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateClusterVersionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates an Amazon EKS managed node group configuration. Your node group continues to
    ///             function during the update. The response output includes an update ID that you can use
    ///             to track the status of your node group update with the <a>DescribeUpdate</a>
    ///             API operation. Currently you can update the Kubernetes labels for a node group or the
    ///             scaling configuration.</p>
    public func updateNodegroupConfig(input: UpdateNodegroupConfigInput, completion: @escaping (SdkResult<UpdateNodegroupConfigOutputResponse, UpdateNodegroupConfigOutputError>) -> Void)
    {
        guard let clusterName = input.clusterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component clusterName unexpectedly nil"))))
            return
        }
        guard let nodegroupName = input.nodegroupName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component nodegroupName unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(clusterName)/node-groups/\(nodegroupName)/update-config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateNodegroupConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateNodegroupConfigInput, UpdateNodegroupConfigOutputResponse, UpdateNodegroupConfigOutputError>(id: "updateNodegroupConfig")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<UpdateNodegroupConfigOutputResponse>, SdkError<UpdateNodegroupConfigOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: UpdateNodegroupConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateNodegroupConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateNodegroupConfigInput, UpdateNodegroupConfigOutputResponse, UpdateNodegroupConfigOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateNodegroupConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the Kubernetes version or AMI version of an Amazon EKS managed node group.</p>
    ///         <p>You can update a node group using a launch template only if the node group was
    ///             originally deployed with a launch template. If you need to update a custom AMI in a node
    ///             group that was deployed with a launch template, then update your custom AMI, specify the
    ///             new ID in a new version of the launch template, and then update the node group to the
    ///             new version of the launch template.</p>
    ///         <p>If you update without a launch template, then you can update to the latest available
    ///             AMI version of a node group's current Kubernetes version by not specifying a Kubernetes
    ///             version in the request. You can update to the latest AMI version of your cluster's
    ///             current Kubernetes version by specifying your cluster's Kubernetes version in the
    ///             request. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/eks-linux-ami-versions.html">Amazon EKS
    ///                 optimized Amazon Linux 2 AMI versions</a> in the <i>Amazon EKS User Guide</i>.</p>
    ///         <p>You cannot roll back a node group to an earlier Kubernetes version or AMI
    ///             version.</p>
    ///         <p>When a node in a managed node group is terminated due to a scaling action or update,
    ///             the pods in that node are drained first. Amazon EKS attempts to drain the nodes gracefully
    ///             and will fail if it is unable to do so. You can <code>force</code> the update if Amazon EKS
    ///             is unable to drain the nodes as a result of a pod disruption budget issue.</p>
    public func updateNodegroupVersion(input: UpdateNodegroupVersionInput, completion: @escaping (SdkResult<UpdateNodegroupVersionOutputResponse, UpdateNodegroupVersionOutputError>) -> Void)
    {
        guard let clusterName = input.clusterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component clusterName unexpectedly nil"))))
            return
        }
        guard let nodegroupName = input.nodegroupName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component nodegroupName unexpectedly nil"))))
            return
        }
        let urlPath = "/clusters/\(clusterName)/node-groups/\(nodegroupName)/update-version"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateNodegroupVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "eks.\(config.region).amazonaws.com")
                      .withSigningName(value: "eks")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateNodegroupVersionInput, UpdateNodegroupVersionOutputResponse, UpdateNodegroupVersionOutputError>(id: "updateNodegroupVersion")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<UpdateNodegroupVersionOutputResponse>, SdkError<UpdateNodegroupVersionOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: UpdateNodegroupVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateNodegroupVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateNodegroupVersionInput, UpdateNodegroupVersionOutputResponse, UpdateNodegroupVersionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateNodegroupVersionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
