// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension EksClient {
    /// <p>Associate encryption configuration to an existing cluster.</p>
    ///         <p>You can use this API to enable encryption on existing clusters which do not have
    ///             encryption already enabled. This allows you to implement a defense-in-depth security
    ///             strategy without migrating applications to new EKS clusters.</p>
    func associateEncryptionConfig(input: AssociateEncryptionConfigInput) async throws -> AssociateEncryptionConfigOutputResponse
    {
        typealias associateEncryptionConfigContinuation = CheckedContinuation<AssociateEncryptionConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: associateEncryptionConfigContinuation) in
            associateEncryptionConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Associate an identity provider configuration to a cluster.</p>
    ///         <p>If you want to authenticate identities using an identity provider, you can create an
    ///             identity provider configuration and associate it to your cluster. After configuring
    ///             authentication to your cluster you can create Kubernetes <code>roles</code> and
    ///                 <code>clusterroles</code> to assign permissions to the roles, and then bind the
    ///             roles to the identities using Kubernetes <code>rolebindings</code> and
    ///                 <code>clusterrolebindings</code>. For more information see <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">Using RBAC
    ///                 Authorization</a> in the Kubernetes documentation.</p>
    func associateIdentityProviderConfig(input: AssociateIdentityProviderConfigInput) async throws -> AssociateIdentityProviderConfigOutputResponse
    {
        typealias associateIdentityProviderConfigContinuation = CheckedContinuation<AssociateIdentityProviderConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: associateIdentityProviderConfigContinuation) in
            associateIdentityProviderConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates an Amazon EKS add-on.</p>
    ///         <p>Amazon EKS add-ons help to automate the provisioning and lifecycle management of common
    ///             operational software for Amazon EKS clusters. Amazon EKS add-ons can only be used with Amazon EKS
    ///             clusters running version 1.18 with platform version <code>eks.3</code> or later because
    ///             add-ons rely on the Server-side Apply Kubernetes feature, which is only available in
    ///             Kubernetes 1.18 and later.</p>
    func createAddon(input: CreateAddonInput) async throws -> CreateAddonOutputResponse
    {
        typealias createAddonContinuation = CheckedContinuation<CreateAddonOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createAddonContinuation) in
            createAddon(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates an Amazon EKS control plane. </p>
    ///         <p>The Amazon EKS control plane consists of control plane instances that run the Kubernetes
    ///             software, such as <code>etcd</code> and the API server. The control plane runs in an
    ///             account managed by AWS, and the Kubernetes API is exposed via the Amazon EKS API server
    ///             endpoint. Each Amazon EKS cluster control plane is single-tenant and unique and runs on its
    ///             own set of Amazon EC2 instances.</p>
    ///         <p>The cluster control plane is provisioned across multiple Availability Zones and
    ///             fronted by an Elastic Load Balancing Network Load Balancer. Amazon EKS also provisions elastic network interfaces in your VPC
    ///             subnets to provide connectivity from the control plane instances to the nodes (for
    ///             example, to support <code>kubectl exec</code>, <code>logs</code>, and <code>proxy</code>
    ///             data flows).</p>
    ///         <p>Amazon EKS nodes run in your AWS account and connect to your cluster's control plane via
    ///             the Kubernetes API server endpoint and a certificate file that is created for your
    ///             cluster.</p>
    ///
    ///         <p>Cluster creation typically takes several minutes. After you create an Amazon EKS cluster,
    ///             you must configure your Kubernetes tooling to communicate with the API server and launch
    ///             nodes into your cluster. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/managing-auth.html">Managing Cluster
    ///                 Authentication</a> and <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-workers.html">Launching Amazon EKS nodes</a> in the <i>Amazon EKS User Guide</i>.</p>
    func createCluster(input: CreateClusterInput) async throws -> CreateClusterOutputResponse
    {
        typealias createClusterContinuation = CheckedContinuation<CreateClusterOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createClusterContinuation) in
            createCluster(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates an AWS Fargate profile for your Amazon EKS cluster. You must have at least one Fargate
    ///             profile in a cluster to be able to run pods on Fargate.</p>
    ///         <p>The Fargate profile allows an administrator to declare which pods run on Fargate and specify
    ///             which pods run on which Fargate profile. This declaration is done through the profile’s
    ///             selectors. Each profile can have up to five selectors that contain a namespace and
    ///             labels. A namespace is required for every selector. The label field consists of multiple
    ///             optional key-value pairs. Pods that match the selectors are scheduled on Fargate. If a
    ///             to-be-scheduled pod matches any of the selectors in the Fargate profile, then that pod is
    ///             run on Fargate.</p>
    ///         <p>When you create a Fargate profile, you must specify a pod execution role to use with the
    ///             pods that are scheduled with the profile. This role is added to the cluster's Kubernetes
    ///                 <a href="https://kubernetes.io/docs/admin/authorization/rbac/">Role Based Access
    ///                 Control</a> (RBAC) for authorization so that the <code>kubelet</code> that is
    ///             running on the Fargate infrastructure can register with your Amazon EKS cluster so that it can
    ///             appear in your cluster as a node. The pod execution role also provides IAM permissions
    ///             to the Fargate infrastructure to allow read access to Amazon ECR image repositories. For more
    ///             information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/pod-execution-role.html">Pod Execution Role</a> in the <i>Amazon EKS User Guide</i>.</p>
    ///         <p>Fargate profiles are immutable. However, you can create a new updated profile to replace
    ///             an existing profile and then delete the original after the updated profile has finished
    ///             creating.</p>
    ///         <p>If any Fargate profiles in a cluster are in the <code>DELETING</code> status, you must
    ///             wait for that Fargate profile to finish deleting before you can create any other profiles
    ///             in that cluster.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/fargate-profile.html">AWS Fargate Profile</a> in the <i>Amazon EKS User Guide</i>.</p>
    func createFargateProfile(input: CreateFargateProfileInput) async throws -> CreateFargateProfileOutputResponse
    {
        typealias createFargateProfileContinuation = CheckedContinuation<CreateFargateProfileOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createFargateProfileContinuation) in
            createFargateProfile(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a managed node group for an Amazon EKS cluster. You can only create a node group
    ///             for your cluster that is equal to the current Kubernetes version for the cluster. All
    ///             node groups are created with the latest AMI release version for the respective minor
    ///             Kubernetes version of the cluster, unless you deploy a custom AMI using a launch
    ///             template. For more information about using launch templates, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch
    ///                 template support</a>.</p>
    ///         <p>An Amazon EKS managed node group is an Amazon EC2 Auto Scaling group and associated Amazon EC2 instances that
    ///             are managed by AWS for an Amazon EKS cluster. Each node group uses a version of the Amazon EKS
    ///             optimized Amazon Linux 2 AMI. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html">Managed
    ///                 Node Groups</a> in the <i>Amazon EKS User Guide</i>. </p>
    func createNodegroup(input: CreateNodegroupInput) async throws -> CreateNodegroupOutputResponse
    {
        typealias createNodegroupContinuation = CheckedContinuation<CreateNodegroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createNodegroupContinuation) in
            createNodegroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Delete an Amazon EKS add-on.</p>
    ///         <p>When you remove the add-on, it will also be deleted from the cluster. You can always
    ///             manually start an add-on on the cluster using the Kubernetes API.</p>
    func deleteAddon(input: DeleteAddonInput) async throws -> DeleteAddonOutputResponse
    {
        typealias deleteAddonContinuation = CheckedContinuation<DeleteAddonOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteAddonContinuation) in
            deleteAddon(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the Amazon EKS cluster control plane.</p>
    ///         <p>If you have active services in your cluster that are associated with a load balancer,
    ///             you must delete those services before deleting the cluster so that the load balancers
    ///             are deleted properly. Otherwise, you can have orphaned resources in your VPC that
    ///             prevent you from being able to delete the VPC. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/delete-cluster.html">Deleting a
    ///                 Cluster</a> in the <i>Amazon EKS User Guide</i>.</p>
    ///         <p>If you have managed node groups or Fargate profiles attached to the cluster, you must
    ///             delete them first. For more information, see <a>DeleteNodegroup</a> and <a>DeleteFargateProfile</a>.</p>
    func deleteCluster(input: DeleteClusterInput) async throws -> DeleteClusterOutputResponse
    {
        typealias deleteClusterContinuation = CheckedContinuation<DeleteClusterOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteClusterContinuation) in
            deleteCluster(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes an AWS Fargate profile.</p>
    ///         <p>When you delete a Fargate profile, any pods running on Fargate that were created with the
    ///             profile are deleted. If those pods match another Fargate profile, then they are scheduled
    ///             on Fargate with that profile. If they no longer match any Fargate profiles, then they are not
    ///             scheduled on Fargate and they may remain in a pending state.</p>
    ///         <p>Only one Fargate profile in a cluster can be in the <code>DELETING</code> status at a
    ///             time. You must wait for a Fargate profile to finish deleting before you can delete any
    ///             other profiles in that cluster.</p>
    func deleteFargateProfile(input: DeleteFargateProfileInput) async throws -> DeleteFargateProfileOutputResponse
    {
        typealias deleteFargateProfileContinuation = CheckedContinuation<DeleteFargateProfileOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteFargateProfileContinuation) in
            deleteFargateProfile(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes an Amazon EKS node group for a cluster.</p>
    func deleteNodegroup(input: DeleteNodegroupInput) async throws -> DeleteNodegroupOutputResponse
    {
        typealias deleteNodegroupContinuation = CheckedContinuation<DeleteNodegroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteNodegroupContinuation) in
            deleteNodegroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes an Amazon EKS add-on.</p>
    func describeAddon(input: DescribeAddonInput) async throws -> DescribeAddonOutputResponse
    {
        typealias describeAddonContinuation = CheckedContinuation<DescribeAddonOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeAddonContinuation) in
            describeAddon(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes the Kubernetes versions that the add-on can be used with.</p>
    func describeAddonVersions(input: DescribeAddonVersionsInput) async throws -> DescribeAddonVersionsOutputResponse
    {
        typealias describeAddonVersionsContinuation = CheckedContinuation<DescribeAddonVersionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeAddonVersionsContinuation) in
            describeAddonVersions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns descriptive information about an Amazon EKS cluster.</p>
    ///         <p>The API server endpoint and certificate authority data returned by this operation are
    ///             required for <code>kubelet</code> and <code>kubectl</code> to communicate with your
    ///             Kubernetes API server. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html">Create a
    ///                 kubeconfig for Amazon EKS</a>.</p>
    ///         <note>
    ///             <p>The API server endpoint and certificate authority data aren't available until the
    ///                 cluster reaches the <code>ACTIVE</code> state.</p>
    ///         </note>
    func describeCluster(input: DescribeClusterInput) async throws -> DescribeClusterOutputResponse
    {
        typealias describeClusterContinuation = CheckedContinuation<DescribeClusterOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeClusterContinuation) in
            describeCluster(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns descriptive information about an AWS Fargate profile.</p>
    func describeFargateProfile(input: DescribeFargateProfileInput) async throws -> DescribeFargateProfileOutputResponse
    {
        typealias describeFargateProfileContinuation = CheckedContinuation<DescribeFargateProfileOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeFargateProfileContinuation) in
            describeFargateProfile(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns descriptive information about an identity provider configuration.</p>
    func describeIdentityProviderConfig(input: DescribeIdentityProviderConfigInput) async throws -> DescribeIdentityProviderConfigOutputResponse
    {
        typealias describeIdentityProviderConfigContinuation = CheckedContinuation<DescribeIdentityProviderConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeIdentityProviderConfigContinuation) in
            describeIdentityProviderConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns descriptive information about an Amazon EKS node group.</p>
    func describeNodegroup(input: DescribeNodegroupInput) async throws -> DescribeNodegroupOutputResponse
    {
        typealias describeNodegroupContinuation = CheckedContinuation<DescribeNodegroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeNodegroupContinuation) in
            describeNodegroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns descriptive information about an update against your Amazon EKS cluster or
    ///             associated managed node group.</p>
    ///         <p>When the status of the update is <code>Succeeded</code>, the update is complete. If an
    ///             update fails, the status is <code>Failed</code>, and an error detail explains the reason
    ///             for the failure.</p>
    func describeUpdate(input: DescribeUpdateInput) async throws -> DescribeUpdateOutputResponse
    {
        typealias describeUpdateContinuation = CheckedContinuation<DescribeUpdateOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeUpdateContinuation) in
            describeUpdate(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Disassociates an identity provider configuration from a cluster. If you disassociate
    ///             an identity provider from your cluster, users included in the provider can no longer
    ///             access the cluster. However, you can still access the cluster with AWS IAM
    ///             users.</p>
    func disassociateIdentityProviderConfig(input: DisassociateIdentityProviderConfigInput) async throws -> DisassociateIdentityProviderConfigOutputResponse
    {
        typealias disassociateIdentityProviderConfigContinuation = CheckedContinuation<DisassociateIdentityProviderConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: disassociateIdentityProviderConfigContinuation) in
            disassociateIdentityProviderConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the available add-ons.</p>
    func listAddons(input: ListAddonsInput) async throws -> ListAddonsOutputResponse
    {
        typealias listAddonsContinuation = CheckedContinuation<ListAddonsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listAddonsContinuation) in
            listAddons(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the Amazon EKS clusters in your AWS account in the specified Region.</p>
    func listClusters(input: ListClustersInput) async throws -> ListClustersOutputResponse
    {
        typealias listClustersContinuation = CheckedContinuation<ListClustersOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listClustersContinuation) in
            listClusters(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the AWS Fargate profiles associated with the specified cluster in your AWS
    ///             account in the specified Region.</p>
    func listFargateProfiles(input: ListFargateProfilesInput) async throws -> ListFargateProfilesOutputResponse
    {
        typealias listFargateProfilesContinuation = CheckedContinuation<ListFargateProfilesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFargateProfilesContinuation) in
            listFargateProfiles(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>A list of identity provider configurations.</p>
    func listIdentityProviderConfigs(input: ListIdentityProviderConfigsInput) async throws -> ListIdentityProviderConfigsOutputResponse
    {
        typealias listIdentityProviderConfigsContinuation = CheckedContinuation<ListIdentityProviderConfigsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listIdentityProviderConfigsContinuation) in
            listIdentityProviderConfigs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the Amazon EKS managed node groups associated with the specified cluster in your
    ///             AWS account in the specified Region. Self-managed node groups are not listed.</p>
    func listNodegroups(input: ListNodegroupsInput) async throws -> ListNodegroupsOutputResponse
    {
        typealias listNodegroupsContinuation = CheckedContinuation<ListNodegroupsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listNodegroupsContinuation) in
            listNodegroups(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>List the tags for an Amazon EKS resource.</p>
    func listTagsForResource(input: ListTagsForResourceInput) async throws -> ListTagsForResourceOutputResponse
    {
        typealias listTagsForResourceContinuation = CheckedContinuation<ListTagsForResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsForResourceContinuation) in
            listTagsForResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the updates associated with an Amazon EKS cluster or managed node group in your AWS
    ///             account, in the specified Region.</p>
    func listUpdates(input: ListUpdatesInput) async throws -> ListUpdatesOutputResponse
    {
        typealias listUpdatesContinuation = CheckedContinuation<ListUpdatesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listUpdatesContinuation) in
            listUpdates(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Associates the specified tags to a resource with the specified
    ///                 <code>resourceArn</code>. If existing tags on a resource are not specified in the
    ///             request parameters, they are not changed. When a resource is deleted, the tags
    ///             associated with that resource are deleted as well. Tags that you create for Amazon EKS
    ///             resources do not propagate to any other resources associated with the cluster. For
    ///             example, if you tag a cluster with this operation, that tag does not automatically
    ///             propagate to the subnets and nodes associated with the cluster.</p>
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes specified tags from a resource.</p>
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates an Amazon EKS add-on.</p>
    func updateAddon(input: UpdateAddonInput) async throws -> UpdateAddonOutputResponse
    {
        typealias updateAddonContinuation = CheckedContinuation<UpdateAddonOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateAddonContinuation) in
            updateAddon(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates an Amazon EKS cluster configuration. Your cluster continues to function during the
    ///             update. The response output includes an update ID that you can use to track the status
    ///             of your cluster update with the <a>DescribeUpdate</a> API operation.</p>
    ///         <p>You can use this API operation to enable or disable exporting the Kubernetes control
    ///             plane logs for your cluster to CloudWatch Logs. By default, cluster control plane logs aren't
    ///             exported to CloudWatch Logs. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/control-plane-logs.html">Amazon EKS
    ///                 Cluster Control Plane Logs</a> in the
    ///             <i>
    ///                <i>Amazon EKS User Guide</i>
    ///             </i>.</p>
    ///         <note>
    ///             <p>CloudWatch Logs ingestion, archive storage, and data scanning rates apply to exported
    ///                 control plane logs. For more information, see <a href="http://aws.amazon.com/cloudwatch/pricing/">Amazon CloudWatch Pricing</a>.</p>
    ///         </note>
    ///         <p>You can also use this API operation to enable or disable public and private access to
    ///             your cluster's Kubernetes API server endpoint. By default, public access is enabled, and
    ///             private access is disabled. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html">Amazon EKS Cluster
    ///                 Endpoint Access Control</a> in the <i>
    ///                <i>Amazon EKS User Guide</i>
    ///             </i>. </p>
    ///         <important>
    ///             <p>You can't update the subnets or security group IDs for an existing cluster.</p>
    ///         </important>
    ///         <p>Cluster updates are asynchronous, and they should finish within a few minutes. During
    ///             an update, the cluster status moves to <code>UPDATING</code> (this status transition is
    ///             eventually consistent). When the update is complete (either <code>Failed</code> or
    ///                 <code>Successful</code>), the cluster status moves to <code>Active</code>.</p>
    func updateClusterConfig(input: UpdateClusterConfigInput) async throws -> UpdateClusterConfigOutputResponse
    {
        typealias updateClusterConfigContinuation = CheckedContinuation<UpdateClusterConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateClusterConfigContinuation) in
            updateClusterConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates an Amazon EKS cluster to the specified Kubernetes version. Your cluster continues
    ///             to function during the update. The response output includes an update ID that you can
    ///             use to track the status of your cluster update with the <a>DescribeUpdate</a>
    ///             API operation.</p>
    ///         <p>Cluster updates are asynchronous, and they should finish within a few minutes. During
    ///             an update, the cluster status moves to <code>UPDATING</code> (this status transition is
    ///             eventually consistent). When the update is complete (either <code>Failed</code> or
    ///                 <code>Successful</code>), the cluster status moves to <code>Active</code>.</p>
    ///         <p>If your cluster has managed node groups attached to it, all of your node groups’
    ///             Kubernetes versions must match the cluster’s Kubernetes version in order to update the
    ///             cluster to a new Kubernetes version.</p>
    func updateClusterVersion(input: UpdateClusterVersionInput) async throws -> UpdateClusterVersionOutputResponse
    {
        typealias updateClusterVersionContinuation = CheckedContinuation<UpdateClusterVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateClusterVersionContinuation) in
            updateClusterVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates an Amazon EKS managed node group configuration. Your node group continues to
    ///             function during the update. The response output includes an update ID that you can use
    ///             to track the status of your node group update with the <a>DescribeUpdate</a>
    ///             API operation. Currently you can update the Kubernetes labels for a node group or the
    ///             scaling configuration.</p>
    func updateNodegroupConfig(input: UpdateNodegroupConfigInput) async throws -> UpdateNodegroupConfigOutputResponse
    {
        typealias updateNodegroupConfigContinuation = CheckedContinuation<UpdateNodegroupConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateNodegroupConfigContinuation) in
            updateNodegroupConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates the Kubernetes version or AMI version of an Amazon EKS managed node group.</p>
    ///         <p>You can update a node group using a launch template only if the node group was
    ///             originally deployed with a launch template. If you need to update a custom AMI in a node
    ///             group that was deployed with a launch template, then update your custom AMI, specify the
    ///             new ID in a new version of the launch template, and then update the node group to the
    ///             new version of the launch template.</p>
    ///         <p>If you update without a launch template, then you can update to the latest available
    ///             AMI version of a node group's current Kubernetes version by not specifying a Kubernetes
    ///             version in the request. You can update to the latest AMI version of your cluster's
    ///             current Kubernetes version by specifying your cluster's Kubernetes version in the
    ///             request. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/eks-linux-ami-versions.html">Amazon EKS
    ///                 optimized Amazon Linux 2 AMI versions</a> in the <i>Amazon EKS User Guide</i>.</p>
    ///         <p>You cannot roll back a node group to an earlier Kubernetes version or AMI
    ///             version.</p>
    ///         <p>When a node in a managed node group is terminated due to a scaling action or update,
    ///             the pods in that node are drained first. Amazon EKS attempts to drain the nodes gracefully
    ///             and will fail if it is unable to do so. You can <code>force</code> the update if Amazon EKS
    ///             is unable to drain the nodes as a result of a pod disruption budget issue.</p>
    func updateNodegroupVersion(input: UpdateNodegroupVersionInput) async throws -> UpdateNodegroupVersionOutputResponse
    {
        typealias updateNodegroupVersionContinuation = CheckedContinuation<UpdateNodegroupVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateNodegroupVersionContinuation) in
            updateNodegroupVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
