// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class FirehoseClient {
    let client: SdkHttpClient
    let config: FirehoseClientConfiguration
    let serviceName = "Firehose"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: FirehoseClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class FirehoseClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> FirehoseClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try FirehoseClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension FirehoseClient: FirehoseClientProtocol {
    /// <p>Creates a Kinesis Data Firehose delivery stream.</p>
    ///
    ///          <p>By default, you can create up to 50 delivery streams per AWS Region.</p>
    ///          <p>This is an asynchronous operation that immediately returns. The initial status of the
    ///          delivery stream is <code>CREATING</code>. After the delivery stream is created, its status
    ///          is <code>ACTIVE</code> and it now accepts data. If the delivery stream creation fails, the
    ///          status transitions to <code>CREATING_FAILED</code>. Attempts to send data to a delivery
    ///          stream that is not in the <code>ACTIVE</code> state cause an exception. To check the state
    ///          of a delivery stream, use <a>DescribeDeliveryStream</a>.</p>
    ///          <p>If the status of a delivery stream is <code>CREATING_FAILED</code>, this status
    ///          doesn't change, and you can't invoke <code>CreateDeliveryStream</code> again on it.
    ///          However, you can invoke the <a>DeleteDeliveryStream</a> operation to delete
    ///          it.</p>
    ///          <p>A Kinesis Data Firehose delivery stream can be configured to receive records directly
    ///          from providers using <a>PutRecord</a> or <a>PutRecordBatch</a>, or it
    ///          can be configured to use an existing Kinesis stream as its source. To specify a Kinesis
    ///          data stream as input, set the <code>DeliveryStreamType</code> parameter to
    ///             <code>KinesisStreamAsSource</code>, and provide the Kinesis stream Amazon Resource Name
    ///          (ARN) and role ARN in the <code>KinesisStreamSourceConfiguration</code>
    ///          parameter.</p>
    ///          <p>To create a delivery stream with server-side encryption (SSE) enabled, include <a>DeliveryStreamEncryptionConfigurationInput</a> in your request. This is
    ///          optional. You can also invoke <a>StartDeliveryStreamEncryption</a> to turn on
    ///          SSE for an existing delivery stream that doesn't have SSE enabled.</p>
    ///          <p>A delivery stream is configured with a single destination: Amazon S3, Amazon ES,
    ///          Amazon Redshift, or Splunk. You must specify only one of the following destination
    ///          configuration parameters: <code>ExtendedS3DestinationConfiguration</code>,
    ///             <code>S3DestinationConfiguration</code>,
    ///             <code>ElasticsearchDestinationConfiguration</code>,
    ///             <code>RedshiftDestinationConfiguration</code>, or
    ///             <code>SplunkDestinationConfiguration</code>.</p>
    ///          <p>When you specify <code>S3DestinationConfiguration</code>, you can also provide the
    ///          following optional values: BufferingHints, <code>EncryptionConfiguration</code>, and
    ///             <code>CompressionFormat</code>. By default, if no <code>BufferingHints</code> value is
    ///          provided, Kinesis Data Firehose buffers data up to 5 MB or for 5 minutes, whichever
    ///          condition is satisfied first. <code>BufferingHints</code> is a hint, so there are some
    ///          cases where the service cannot adhere to these conditions strictly. For example, record
    ///          boundaries might be such that the size is a little over or under the configured buffering
    ///          size. By default, no encryption is performed. We strongly recommend that you enable
    ///          encryption to ensure secure data storage in Amazon S3.</p>
    ///
    ///          <p>A few notes about Amazon Redshift as a destination:</p>
    ///          <ul>
    ///             <li>
    ///                <p>An Amazon Redshift destination requires an S3 bucket as intermediate location.
    ///                Kinesis Data Firehose first delivers data to Amazon S3 and then uses
    ///                   <code>COPY</code> syntax to load data into an Amazon Redshift table. This is
    ///                specified in the <code>RedshiftDestinationConfiguration.S3Configuration</code>
    ///                parameter.</p>
    ///
    ///             </li>
    ///             <li>
    ///                <p>The compression formats <code>SNAPPY</code> or <code>ZIP</code> cannot be
    ///                specified in <code>RedshiftDestinationConfiguration.S3Configuration</code> because
    ///                the Amazon Redshift <code>COPY</code> operation that reads from the S3 bucket doesn't
    ///                support these compression formats.</p>
    ///             </li>
    ///             <li>
    ///                <p>We strongly recommend that you use the user name and password you provide
    ///                exclusively with Kinesis Data Firehose, and that the permissions for the account are
    ///                restricted for Amazon Redshift <code>INSERT</code> permissions.</p>
    ///
    ///             </li>
    ///          </ul>
    ///          <p>Kinesis Data Firehose assumes the IAM role that is configured as part of the
    ///          destination. The role should allow the Kinesis Data Firehose principal to assume the role,
    ///          and the role should have permissions that allow the service to deliver the data. For more
    ///          information, see <a href="https://docs.aws.amazon.com/firehose/latest/dev/controlling-access.html#using-iam-s3">Grant Kinesis Data
    ///             Firehose Access to an Amazon S3 Destination</a> in the <i>Amazon Kinesis Data
    ///             Firehose Developer Guide</i>.</p>
    public func createDeliveryStream(input: CreateDeliveryStreamInput, completion: @escaping (SdkResult<CreateDeliveryStreamOutput, CreateDeliveryStreamOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createDeliveryStream")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "firehose.\(config.region).amazonaws.com")
                      .withSigningName(value: "firehose")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateDeliveryStreamInput, CreateDeliveryStreamOutput, CreateDeliveryStreamOutputError>(id: "createDeliveryStream")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateDeliveryStreamInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateDeliveryStreamInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateDeliveryStreamInput, CreateDeliveryStreamOutput, CreateDeliveryStreamOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateDeliveryStreamInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateDeliveryStreamInput, CreateDeliveryStreamOutput, CreateDeliveryStreamOutputError>(xAmzTarget: "Firehose_20150804.CreateDeliveryStream"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a delivery stream and its data.</p>
    ///          <p>To check the state of a delivery stream, use <a>DescribeDeliveryStream</a>. You can delete a delivery stream only if it is in one of the following states:
    ///             <code>ACTIVE</code>, <code>DELETING</code>, <code>CREATING_FAILED</code>, or
    ///             <code>DELETING_FAILED</code>. You can't delete a delivery stream that is in the
    ///             <code>CREATING</code> state. While the deletion request is in process, the delivery
    ///          stream is in the <code>DELETING</code> state.</p>
    ///          <p>While the delivery stream is in the <code>DELETING</code> state, the service might
    ///          continue to accept records, but it doesn't make any guarantees with respect to delivering
    ///          the data. Therefore, as a best practice, first stop any applications that are sending
    ///          records before you delete a delivery stream.</p>
    public func deleteDeliveryStream(input: DeleteDeliveryStreamInput, completion: @escaping (SdkResult<DeleteDeliveryStreamOutput, DeleteDeliveryStreamOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteDeliveryStream")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "firehose.\(config.region).amazonaws.com")
                      .withSigningName(value: "firehose")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteDeliveryStreamInput, DeleteDeliveryStreamOutput, DeleteDeliveryStreamOutputError>(id: "deleteDeliveryStream")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteDeliveryStreamInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteDeliveryStreamInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteDeliveryStreamInput, DeleteDeliveryStreamOutput, DeleteDeliveryStreamOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteDeliveryStreamInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteDeliveryStreamInput, DeleteDeliveryStreamOutput, DeleteDeliveryStreamOutputError>(xAmzTarget: "Firehose_20150804.DeleteDeliveryStream"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the specified delivery stream and its status. For example, after your
    ///          delivery stream is created, call <code>DescribeDeliveryStream</code> to see whether the
    ///          delivery stream is <code>ACTIVE</code> and therefore ready for data to be sent to it. </p>
    ///          <p>If the status of a delivery stream is <code>CREATING_FAILED</code>, this status
    ///          doesn't change, and you can't invoke <a>CreateDeliveryStream</a> again on it.
    ///          However, you can invoke the <a>DeleteDeliveryStream</a> operation to delete it.
    ///          If the status is <code>DELETING_FAILED</code>, you can force deletion by invoking <a>DeleteDeliveryStream</a> again but with <a>DeleteDeliveryStreamInput$AllowForceDelete</a> set to true.</p>
    public func describeDeliveryStream(input: DescribeDeliveryStreamInput, completion: @escaping (SdkResult<DescribeDeliveryStreamOutput, DescribeDeliveryStreamOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeDeliveryStream")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "firehose.\(config.region).amazonaws.com")
                      .withSigningName(value: "firehose")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeDeliveryStreamInput, DescribeDeliveryStreamOutput, DescribeDeliveryStreamOutputError>(id: "describeDeliveryStream")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeDeliveryStreamInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeDeliveryStreamInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeDeliveryStreamInput, DescribeDeliveryStreamOutput, DescribeDeliveryStreamOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeDeliveryStreamInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeDeliveryStreamInput, DescribeDeliveryStreamOutput, DescribeDeliveryStreamOutputError>(xAmzTarget: "Firehose_20150804.DescribeDeliveryStream"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists your delivery streams in alphabetical order of their names.</p>
    ///          <p>The number of delivery streams might be too large to return using a single call to
    ///             <code>ListDeliveryStreams</code>. You can limit the number of delivery streams returned,
    ///          using the <code>Limit</code> parameter. To determine whether there are more delivery
    ///          streams to list, check the value of <code>HasMoreDeliveryStreams</code> in the output. If
    ///          there are more delivery streams to list, you can request them by calling this operation
    ///          again and setting the <code>ExclusiveStartDeliveryStreamName</code> parameter to the name
    ///          of the last delivery stream returned in the last call.</p>
    public func listDeliveryStreams(input: ListDeliveryStreamsInput, completion: @escaping (SdkResult<ListDeliveryStreamsOutput, ListDeliveryStreamsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDeliveryStreams")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "firehose.\(config.region).amazonaws.com")
                      .withSigningName(value: "firehose")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDeliveryStreamsInput, ListDeliveryStreamsOutput, ListDeliveryStreamsOutputError>(id: "listDeliveryStreams")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDeliveryStreamsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDeliveryStreamsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDeliveryStreamsInput, ListDeliveryStreamsOutput, ListDeliveryStreamsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListDeliveryStreamsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListDeliveryStreamsInput, ListDeliveryStreamsOutput, ListDeliveryStreamsOutputError>(xAmzTarget: "Firehose_20150804.ListDeliveryStreams"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the tags for the specified delivery stream. This operation has a limit of five
    ///          transactions per second per account. </p>
    public func listTagsForDeliveryStream(input: ListTagsForDeliveryStreamInput, completion: @escaping (SdkResult<ListTagsForDeliveryStreamOutput, ListTagsForDeliveryStreamOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForDeliveryStream")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "firehose.\(config.region).amazonaws.com")
                      .withSigningName(value: "firehose")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForDeliveryStreamInput, ListTagsForDeliveryStreamOutput, ListTagsForDeliveryStreamOutputError>(id: "listTagsForDeliveryStream")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForDeliveryStreamInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForDeliveryStreamInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForDeliveryStreamInput, ListTagsForDeliveryStreamOutput, ListTagsForDeliveryStreamOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForDeliveryStreamInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListTagsForDeliveryStreamInput, ListTagsForDeliveryStreamOutput, ListTagsForDeliveryStreamOutputError>(xAmzTarget: "Firehose_20150804.ListTagsForDeliveryStream"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Writes a single data record into an Amazon Kinesis Data Firehose delivery stream. To
    ///          write multiple data records into a delivery stream, use <a>PutRecordBatch</a>.
    ///          Applications using these operations are referred to as producers.</p>
    ///          <p>By default, each delivery stream can take in up to 2,000 transactions per second,
    ///          5,000 records per second, or 5 MB per second. If you use <a>PutRecord</a> and
    ///             <a>PutRecordBatch</a>, the limits are an aggregate across these two
    ///          operations for each delivery stream. For more information about limits and how to request
    ///          an increase, see <a href="https://docs.aws.amazon.com/firehose/latest/dev/limits.html">Amazon
    ///             Kinesis Data Firehose Limits</a>. </p>
    ///          <p>You must specify the name of the delivery stream and the data record when using <a>PutRecord</a>. The data record consists of a data blob that can be up to 1,000
    ///          KB in size, and any kind of data. For example, it can be a segment from a log file,
    ///          geographic location data, website clickstream data, and so on.</p>
    ///          <p>Kinesis Data Firehose buffers records before delivering them to the destination. To
    ///          disambiguate the data blobs at the destination, a common solution is to use delimiters in
    ///          the data, such as a newline (<code>\n</code>) or some other character unique within the
    ///          data. This allows the consumer application to parse individual data items when reading the
    ///          data from the destination.</p>
    ///          <p>The <code>PutRecord</code> operation returns a <code>RecordId</code>, which is a
    ///          unique string assigned to each record. Producer applications can use this ID for purposes
    ///          such as auditability and investigation.</p>
    ///          <p>If the <code>PutRecord</code> operation throws a
    ///             <code>ServiceUnavailableException</code>, back off and retry. If the exception persists,
    ///          it is possible that the throughput limits have been exceeded for the delivery stream. </p>
    ///          <p>Data records sent to Kinesis Data Firehose are stored for 24 hours from the time they
    ///          are added to a delivery stream as it tries to send the records to the destination. If the
    ///          destination is unreachable for more than 24 hours, the data is no longer
    ///          available.</p>
    ///
    ///          <important>
    ///             <p>Don't concatenate two or more base64 strings to form the data fields of your records.
    ///             Instead, concatenate the raw data, then perform base64 encoding.</p>
    ///          </important>
    public func putRecord(input: PutRecordInput, completion: @escaping (SdkResult<PutRecordOutput, PutRecordOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putRecord")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "firehose.\(config.region).amazonaws.com")
                      .withSigningName(value: "firehose")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutRecordInput, PutRecordOutput, PutRecordOutputError>(id: "putRecord")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutRecordInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutRecordInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutRecordInput, PutRecordOutput, PutRecordOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: PutRecordInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<PutRecordInput, PutRecordOutput, PutRecordOutputError>(xAmzTarget: "Firehose_20150804.PutRecord"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Writes multiple data records into a delivery stream in a single call, which can
    ///          achieve higher throughput per producer than when writing single records. To write single
    ///          data records into a delivery stream, use <a>PutRecord</a>. Applications using
    ///          these operations are referred to as producers.</p>
    ///          <p>For information about service quota, see <a href="https://docs.aws.amazon.com/firehose/latest/dev/limits.html">Amazon Kinesis Data Firehose
    ///          Quota</a>.</p>
    ///          <p>Each <a>PutRecordBatch</a> request supports up to 500 records. Each record
    ///          in the request can be as large as 1,000 KB (before 64-bit encoding), up to a limit of 4 MB
    ///          for the entire request. These limits cannot be changed.</p>
    ///          <p>You must specify the name of the delivery stream and the data record when using <a>PutRecord</a>. The data record consists of a data blob that can be up to 1,000
    ///          KB in size, and any kind of data. For example, it could be a segment from a log file,
    ///          geographic location data, website clickstream data, and so on.</p>
    ///          <p>Kinesis Data Firehose buffers records before delivering them to the destination. To
    ///          disambiguate the data blobs at the destination, a common solution is to use delimiters in
    ///          the data, such as a newline (<code>\n</code>) or some other character unique within the
    ///          data. This allows the consumer application to parse individual data items when reading the
    ///          data from the destination.</p>
    ///          <p>The <a>PutRecordBatch</a> response includes a count of failed records,
    ///             <code>FailedPutCount</code>, and an array of responses, <code>RequestResponses</code>.
    ///          Even if the <a>PutRecordBatch</a> call succeeds, the value of
    ///             <code>FailedPutCount</code> may be greater than 0, indicating that there are records for
    ///          which the operation didn't succeed. Each entry in the <code>RequestResponses</code> array
    ///          provides additional information about the processed record. It directly correlates with a
    ///          record in the request array using the same ordering, from the top to the bottom. The
    ///          response array always includes the same number of records as the request array.
    ///             <code>RequestResponses</code> includes both successfully and unsuccessfully processed
    ///          records. Kinesis Data Firehose tries to process all records in each <a>PutRecordBatch</a> request. A single record failure does not stop the processing
    ///          of subsequent records. </p>
    ///          <p>A successfully processed record includes a <code>RecordId</code> value, which is
    ///          unique for the record. An unsuccessfully processed record includes <code>ErrorCode</code>
    ///          and <code>ErrorMessage</code> values. <code>ErrorCode</code> reflects the type of error,
    ///          and is one of the following values: <code>ServiceUnavailableException</code> or
    ///             <code>InternalFailure</code>. <code>ErrorMessage</code> provides more detailed
    ///          information about the error.</p>
    ///          <p>If there is an internal server error or a timeout, the write might have completed or
    ///          it might have failed. If <code>FailedPutCount</code> is greater than 0, retry the request,
    ///          resending only those records that might have failed processing. This minimizes the possible
    ///          duplicate records and also reduces the total bytes sent (and corresponding charges). We
    ///          recommend that you handle any duplicates at the destination.</p>
    ///          <p>If <a>PutRecordBatch</a> throws <code>ServiceUnavailableException</code>,
    ///          back off and retry. If the exception persists, it is possible that the throughput limits
    ///          have been exceeded for the delivery stream.</p>
    ///
    ///          <p>Data records sent to Kinesis Data Firehose are stored for 24 hours from the time they
    ///          are added to a delivery stream as it attempts to send the records to the destination. If
    ///          the destination is unreachable for more than 24 hours, the data is no longer
    ///          available.</p>
    ///          <important>
    ///             <p>Don't concatenate two or more base64 strings to form the data fields of your records.
    ///             Instead, concatenate the raw data, then perform base64 encoding.</p>
    ///          </important>
    public func putRecordBatch(input: PutRecordBatchInput, completion: @escaping (SdkResult<PutRecordBatchOutput, PutRecordBatchOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putRecordBatch")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "firehose.\(config.region).amazonaws.com")
                      .withSigningName(value: "firehose")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutRecordBatchInput, PutRecordBatchOutput, PutRecordBatchOutputError>(id: "putRecordBatch")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutRecordBatchInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutRecordBatchInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutRecordBatchInput, PutRecordBatchOutput, PutRecordBatchOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: PutRecordBatchInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<PutRecordBatchInput, PutRecordBatchOutput, PutRecordBatchOutputError>(xAmzTarget: "Firehose_20150804.PutRecordBatch"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Enables server-side encryption (SSE) for the delivery stream. </p>
    ///          <p>This operation is asynchronous. It returns immediately. When you invoke it, Kinesis Data
    ///          Firehose first sets the encryption status of the stream to <code>ENABLING</code>, and then
    ///          to <code>ENABLED</code>. The encryption status of a delivery stream is the
    ///             <code>Status</code> property in <a>DeliveryStreamEncryptionConfiguration</a>.
    ///          If the operation fails, the encryption status changes to <code>ENABLING_FAILED</code>. You
    ///          can continue to read and write data to your delivery stream while the encryption status is
    ///             <code>ENABLING</code>, but the data is not encrypted. It can take up to 5 seconds after
    ///          the encryption status changes to <code>ENABLED</code> before all records written to the
    ///          delivery stream are encrypted. To find out whether a record or a batch of records was
    ///          encrypted, check the response elements <a>PutRecordOutput$Encrypted</a> and
    ///             <a>PutRecordBatchOutput$Encrypted</a>, respectively.</p>
    ///          <p>To check the encryption status of a delivery stream, use <a>DescribeDeliveryStream</a>.</p>
    ///          <p>Even if encryption is currently enabled for a delivery stream, you can still invoke this
    ///          operation on it to change the ARN of the CMK or both its type and ARN. If you invoke this
    ///          method to change the CMK, and the old CMK is of type <code>CUSTOMER_MANAGED_CMK</code>,
    ///          Kinesis Data Firehose schedules the grant it had on the old CMK for retirement. If the new
    ///          CMK is of type <code>CUSTOMER_MANAGED_CMK</code>, Kinesis Data Firehose creates a grant
    ///          that enables it to use the new CMK to encrypt and decrypt data and to manage the
    ///          grant.</p>
    ///          <p>If a delivery stream already has encryption enabled and then you invoke this operation
    ///          to change the ARN of the CMK or both its type and ARN and you get
    ///             <code>ENABLING_FAILED</code>, this only means that the attempt to change the CMK failed.
    ///          In this case, encryption remains enabled with the old CMK.</p>
    ///          <p>If the encryption status of your delivery stream is <code>ENABLING_FAILED</code>, you
    ///          can invoke this operation again with a valid CMK. The CMK must be enabled and the key
    ///          policy mustn't explicitly deny the permission for Kinesis Data Firehose to invoke KMS
    ///          encrypt and decrypt operations.</p>
    ///          <p>You can enable SSE for a delivery stream only if it's a delivery stream that uses
    ///             <code>DirectPut</code> as its source. </p>
    ///          <p>The <code>StartDeliveryStreamEncryption</code> and
    ///             <code>StopDeliveryStreamEncryption</code> operations have a combined limit of 25 calls
    ///          per delivery stream per 24 hours. For example, you reach the limit if you call
    ///             <code>StartDeliveryStreamEncryption</code> 13 times and
    ///             <code>StopDeliveryStreamEncryption</code> 12 times for the same delivery stream in a
    ///          24-hour period.</p>
    public func startDeliveryStreamEncryption(input: StartDeliveryStreamEncryptionInput, completion: @escaping (SdkResult<StartDeliveryStreamEncryptionOutput, StartDeliveryStreamEncryptionOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startDeliveryStreamEncryption")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "firehose.\(config.region).amazonaws.com")
                      .withSigningName(value: "firehose")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartDeliveryStreamEncryptionInput, StartDeliveryStreamEncryptionOutput, StartDeliveryStreamEncryptionOutputError>(id: "startDeliveryStreamEncryption")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StartDeliveryStreamEncryptionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartDeliveryStreamEncryptionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartDeliveryStreamEncryptionInput, StartDeliveryStreamEncryptionOutput, StartDeliveryStreamEncryptionOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: StartDeliveryStreamEncryptionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<StartDeliveryStreamEncryptionInput, StartDeliveryStreamEncryptionOutput, StartDeliveryStreamEncryptionOutputError>(xAmzTarget: "Firehose_20150804.StartDeliveryStreamEncryption"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Disables server-side encryption (SSE) for the delivery stream. </p>
    ///          <p>This operation is asynchronous. It returns immediately. When you invoke it, Kinesis Data
    ///          Firehose first sets the encryption status of the stream to <code>DISABLING</code>, and then
    ///          to <code>DISABLED</code>. You can continue to read and write data to your stream while its
    ///          status is <code>DISABLING</code>. It can take up to 5 seconds after the encryption status
    ///          changes to <code>DISABLED</code> before all records written to the delivery stream are no
    ///          longer subject to encryption. To find out whether a record or a batch of records was
    ///          encrypted, check the response elements <a>PutRecordOutput$Encrypted</a> and
    ///             <a>PutRecordBatchOutput$Encrypted</a>, respectively.</p>
    ///          <p>To check the encryption state of a delivery stream, use <a>DescribeDeliveryStream</a>. </p>
    ///          <p>If SSE is enabled using a customer managed CMK and then you invoke
    ///             <code>StopDeliveryStreamEncryption</code>, Kinesis Data Firehose schedules the related
    ///          KMS grant for retirement and then retires it after it ensures that it is finished
    ///          delivering records to the destination.</p>
    ///          <p>The <code>StartDeliveryStreamEncryption</code> and
    ///             <code>StopDeliveryStreamEncryption</code> operations have a combined limit of 25 calls
    ///          per delivery stream per 24 hours. For example, you reach the limit if you call
    ///             <code>StartDeliveryStreamEncryption</code> 13 times and
    ///             <code>StopDeliveryStreamEncryption</code> 12 times for the same delivery stream in a
    ///          24-hour period.</p>
    public func stopDeliveryStreamEncryption(input: StopDeliveryStreamEncryptionInput, completion: @escaping (SdkResult<StopDeliveryStreamEncryptionOutput, StopDeliveryStreamEncryptionOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "stopDeliveryStreamEncryption")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "firehose.\(config.region).amazonaws.com")
                      .withSigningName(value: "firehose")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StopDeliveryStreamEncryptionInput, StopDeliveryStreamEncryptionOutput, StopDeliveryStreamEncryptionOutputError>(id: "stopDeliveryStreamEncryption")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StopDeliveryStreamEncryptionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StopDeliveryStreamEncryptionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StopDeliveryStreamEncryptionInput, StopDeliveryStreamEncryptionOutput, StopDeliveryStreamEncryptionOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: StopDeliveryStreamEncryptionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<StopDeliveryStreamEncryptionInput, StopDeliveryStreamEncryptionOutput, StopDeliveryStreamEncryptionOutputError>(xAmzTarget: "Firehose_20150804.StopDeliveryStreamEncryption"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds or updates tags for the specified delivery stream. A tag is a key-value pair
    ///          that you can define and assign to AWS resources. If you specify a tag that already exists,
    ///          the tag value is replaced with the value that you specify in the request. Tags are
    ///          metadata. For example, you can add friendly names and descriptions or other types of
    ///          information that can help you distinguish the delivery stream. For more information about
    ///          tags, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using Cost Allocation Tags</a> in the <i>AWS Billing and Cost Management
    ///             User Guide</i>. </p>
    ///          <p>Each delivery stream can have up to 50 tags. </p>
    ///          <p>This operation has a limit of five transactions per second per account. </p>
    public func tagDeliveryStream(input: TagDeliveryStreamInput, completion: @escaping (SdkResult<TagDeliveryStreamOutput, TagDeliveryStreamOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagDeliveryStream")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "firehose.\(config.region).amazonaws.com")
                      .withSigningName(value: "firehose")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagDeliveryStreamInput, TagDeliveryStreamOutput, TagDeliveryStreamOutputError>(id: "tagDeliveryStream")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagDeliveryStreamInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagDeliveryStreamInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TagDeliveryStreamInput, TagDeliveryStreamOutput, TagDeliveryStreamOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: TagDeliveryStreamInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<TagDeliveryStreamInput, TagDeliveryStreamOutput, TagDeliveryStreamOutputError>(xAmzTarget: "Firehose_20150804.TagDeliveryStream"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes tags from the specified delivery stream. Removed tags are deleted, and you
    ///          can't recover them after this operation successfully completes.</p>
    ///          <p>If you specify a tag that doesn't exist, the operation ignores it.</p>
    ///          <p>This operation has a limit of five transactions per second per account. </p>
    public func untagDeliveryStream(input: UntagDeliveryStreamInput, completion: @escaping (SdkResult<UntagDeliveryStreamOutput, UntagDeliveryStreamOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagDeliveryStream")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "firehose.\(config.region).amazonaws.com")
                      .withSigningName(value: "firehose")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagDeliveryStreamInput, UntagDeliveryStreamOutput, UntagDeliveryStreamOutputError>(id: "untagDeliveryStream")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagDeliveryStreamInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagDeliveryStreamInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UntagDeliveryStreamInput, UntagDeliveryStreamOutput, UntagDeliveryStreamOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UntagDeliveryStreamInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UntagDeliveryStreamInput, UntagDeliveryStreamOutput, UntagDeliveryStreamOutputError>(xAmzTarget: "Firehose_20150804.UntagDeliveryStream"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the specified destination of the specified delivery stream.</p>
    ///
    ///          <p>Use this operation to change the destination type (for example, to replace the Amazon
    ///          S3 destination with Amazon Redshift) or change the parameters associated with a destination
    ///          (for example, to change the bucket name of the Amazon S3 destination). The update might not
    ///          occur immediately. The target delivery stream remains active while the configurations are
    ///          updated, so data writes to the delivery stream can continue during this process. The
    ///          updated configurations are usually effective within a few minutes.</p>
    ///          <p>Switching between Amazon ES and other services is not supported. For an Amazon ES
    ///          destination, you can only update to another Amazon ES destination.</p>
    ///          <p>If the destination type is the same, Kinesis Data Firehose merges the configuration
    ///          parameters specified with the destination configuration that already exists on the delivery
    ///          stream. If any of the parameters are not specified in the call, the existing values are
    ///          retained. For example, in the Amazon S3 destination, if <a>EncryptionConfiguration</a> is not specified, then the existing
    ///             <code>EncryptionConfiguration</code> is maintained on the destination.</p>
    ///          <p>If the destination type is not the same, for example, changing the destination from
    ///          Amazon S3 to Amazon Redshift, Kinesis Data Firehose does not merge any parameters. In this
    ///          case, all parameters must be specified.</p>
    ///
    ///          <p>Kinesis Data Firehose uses <code>CurrentDeliveryStreamVersionId</code> to avoid race
    ///          conditions and conflicting merges. This is a required field, and the service updates the
    ///          configuration only if the existing configuration has a version ID that matches. After the
    ///          update is applied successfully, the version ID is updated, and can be retrieved using <a>DescribeDeliveryStream</a>. Use the new version ID to set
    ///             <code>CurrentDeliveryStreamVersionId</code> in the next call.</p>
    public func updateDestination(input: UpdateDestinationInput, completion: @escaping (SdkResult<UpdateDestinationOutput, UpdateDestinationOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateDestination")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "firehose.\(config.region).amazonaws.com")
                      .withSigningName(value: "firehose")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateDestinationInput, UpdateDestinationOutput, UpdateDestinationOutputError>(id: "updateDestination")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateDestinationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateDestinationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateDestinationInput, UpdateDestinationOutput, UpdateDestinationOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateDestinationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateDestinationInput, UpdateDestinationOutput, UpdateDestinationOutputError>(xAmzTarget: "Firehose_20150804.UpdateDestination"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
