// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccountActionRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccountActionRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Account Action is required in order to continue the request.
public struct AccountActionRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The Exception Error Message.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccountActionRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccountActionRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request cannot be processed because some parameter is not valid or the project state prevents the operation from being performed.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The Exception Error Message.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MobileClientTypes.BundleDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availablePlatforms
        case bundleId
        case description
        case iconUrl
        case title
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availablePlatforms = availablePlatforms {
            var availablePlatformsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availablePlatforms)
            for platform0 in availablePlatforms {
                try availablePlatformsContainer.encode(platform0.rawValue)
            }
        }
        if let bundleId = self.bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let iconUrl = self.iconUrl {
            try encodeContainer.encode(iconUrl, forKey: .iconUrl)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let iconUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iconUrl)
        iconUrl = iconUrlDecoded
        let availablePlatformsContainer = try containerValues.decodeIfPresent([MobileClientTypes.Platform?].self, forKey: .availablePlatforms)
        var availablePlatformsDecoded0:[MobileClientTypes.Platform]? = nil
        if let availablePlatformsContainer = availablePlatformsContainer {
            availablePlatformsDecoded0 = [MobileClientTypes.Platform]()
            for string0 in availablePlatformsContainer {
                if let string0 = string0 {
                    availablePlatformsDecoded0?.append(string0)
                }
            }
        }
        availablePlatforms = availablePlatformsDecoded0
    }
}

extension MobileClientTypes {
    /// The details of the bundle.
    public struct BundleDetails: Swift.Equatable {
        /// Developer desktop or mobile app or website platforms.
        public var availablePlatforms: [MobileClientTypes.Platform]?
        /// Unique bundle identifier.
        public var bundleId: Swift.String?
        /// Description of the download bundle.
        public var description: Swift.String?
        /// Icon for the download bundle.
        public var iconUrl: Swift.String?
        /// Title of the download bundle.
        public var title: Swift.String?
        /// Version of the download bundle.
        public var version: Swift.String?

        public init (
            availablePlatforms: [MobileClientTypes.Platform]? = nil,
            bundleId: Swift.String? = nil,
            description: Swift.String? = nil,
            iconUrl: Swift.String? = nil,
            title: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.availablePlatforms = availablePlatforms
            self.bundleId = bundleId
            self.description = description
            self.iconUrl = iconUrl
            self.title = title
            self.version = version
        }
    }

}

public struct CreateProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProjectInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let contents = input.operationInput.contents {
            let contentsdata = contents
            let contentsbody = ClientRuntime.HttpBody.data(contentsdata)
            input.builder.withBody(contentsbody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contents
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contents = self.contents {
            try encodeContainer.encode(contents.base64EncodedString(), forKey: .contents)
        }
    }
}

extension CreateProjectInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let snapshotId = snapshotId {
                let snapshotIdQueryItem = ClientRuntime.URLQueryItem(name: "snapshotId".urlPercentEncoding(), value: Swift.String(snapshotId).urlPercentEncoding())
                items.append(snapshotIdQueryItem)
            }
            if let name = name {
                let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
                items.append(nameQueryItem)
            }
            if let region = region {
                let regionQueryItem = ClientRuntime.URLQueryItem(name: "region".urlPercentEncoding(), value: Swift.String(region).urlPercentEncoding())
                items.append(regionQueryItem)
            }
            return items
        }
    }
}

extension CreateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/projects"
    }
}

/// Request structure used to request a project be created.
public struct CreateProjectInput: Swift.Equatable {
    /// ZIP or YAML file which contains configuration settings to be used when creating the project. This may be the contents of the file downloaded from the URL provided in an export project operation.
    public var contents: ClientRuntime.Data?
    /// Name of the project.
    public var name: Swift.String?
    /// Default region where project resources should be created.
    public var region: Swift.String?
    /// Unique identifier for an exported snapshot of project configuration. This snapshot identifier is included in the share URL when a project is exported.
    public var snapshotId: Swift.String?

    public init (
        contents: ClientRuntime.Data? = nil,
        name: Swift.String? = nil,
        region: Swift.String? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.contents = contents
        self.name = name
        self.region = region
        self.snapshotId = snapshotId
    }
}

struct CreateProjectInputBody: Swift.Equatable {
    let contents: ClientRuntime.Data?
}

extension CreateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contents
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentsDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .contents)
        contents = contentsDecoded
    }
}

extension CreateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateProjectOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
        } else {
            self.details = nil
        }
    }
}

/// Result structure used in response to a request to create a project.
public struct CreateProjectOutputResponse: Swift.Equatable {
    /// Detailed information about the created AWS Mobile Hub project.
    public var details: MobileClientTypes.ProjectDetails?

    public init (
        details: MobileClientTypes.ProjectDetails? = nil
    )
    {
        self.details = details
    }
}

struct CreateProjectOutputResponseBody: Swift.Equatable {
    let details: MobileClientTypes.ProjectDetails?
}

extension CreateProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(MobileClientTypes.ProjectDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

extension DeleteProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectId = projectId else {
            return nil
        }
        return "/projects/\(projectId.urlPercentEncoding())"
    }
}

/// Request structure used to request a project be deleted.
public struct DeleteProjectInput: Swift.Equatable {
    /// Unique project identifier.
    /// This member is required.
    public var projectId: Swift.String?

    public init (
        projectId: Swift.String? = nil
    )
    {
        self.projectId = projectId
    }
}

struct DeleteProjectInputBody: Swift.Equatable {
}

extension DeleteProjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteProjectOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deletedResources = output.deletedResources
            self.orphanedResources = output.orphanedResources
        } else {
            self.deletedResources = nil
            self.orphanedResources = nil
        }
    }
}

/// Result structure used in response to request to delete a project.
public struct DeleteProjectOutputResponse: Swift.Equatable {
    /// Resources which were deleted.
    public var deletedResources: [MobileClientTypes.Resource]?
    /// Resources which were not deleted, due to a risk of losing potentially important data or files.
    public var orphanedResources: [MobileClientTypes.Resource]?

    public init (
        deletedResources: [MobileClientTypes.Resource]? = nil,
        orphanedResources: [MobileClientTypes.Resource]? = nil
    )
    {
        self.deletedResources = deletedResources
        self.orphanedResources = orphanedResources
    }
}

struct DeleteProjectOutputResponseBody: Swift.Equatable {
    let deletedResources: [MobileClientTypes.Resource]?
    let orphanedResources: [MobileClientTypes.Resource]?
}

extension DeleteProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletedResources
        case orphanedResources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletedResourcesContainer = try containerValues.decodeIfPresent([MobileClientTypes.Resource?].self, forKey: .deletedResources)
        var deletedResourcesDecoded0:[MobileClientTypes.Resource]? = nil
        if let deletedResourcesContainer = deletedResourcesContainer {
            deletedResourcesDecoded0 = [MobileClientTypes.Resource]()
            for structure0 in deletedResourcesContainer {
                if let structure0 = structure0 {
                    deletedResourcesDecoded0?.append(structure0)
                }
            }
        }
        deletedResources = deletedResourcesDecoded0
        let orphanedResourcesContainer = try containerValues.decodeIfPresent([MobileClientTypes.Resource?].self, forKey: .orphanedResources)
        var orphanedResourcesDecoded0:[MobileClientTypes.Resource]? = nil
        if let orphanedResourcesContainer = orphanedResourcesContainer {
            orphanedResourcesDecoded0 = [MobileClientTypes.Resource]()
            for structure0 in orphanedResourcesContainer {
                if let structure0 = structure0 {
                    orphanedResourcesDecoded0?.append(structure0)
                }
            }
        }
        orphanedResources = orphanedResourcesDecoded0
    }
}

extension DescribeBundleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bundleId = bundleId else {
            return nil
        }
        return "/bundles/\(bundleId.urlPercentEncoding())"
    }
}

/// Request structure to request the details of a specific bundle.
public struct DescribeBundleInput: Swift.Equatable {
    /// Unique bundle identifier.
    /// This member is required.
    public var bundleId: Swift.String?

    public init (
        bundleId: Swift.String? = nil
    )
    {
        self.bundleId = bundleId
    }
}

struct DescribeBundleInputBody: Swift.Equatable {
}

extension DescribeBundleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBundleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBundleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeBundleOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBundleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeBundleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
        } else {
            self.details = nil
        }
    }
}

/// Result structure contains the details of the bundle.
public struct DescribeBundleOutputResponse: Swift.Equatable {
    /// The details of the bundle.
    public var details: MobileClientTypes.BundleDetails?

    public init (
        details: MobileClientTypes.BundleDetails? = nil
    )
    {
        self.details = details
    }
}

struct DescribeBundleOutputResponseBody: Swift.Equatable {
    let details: MobileClientTypes.BundleDetails?
}

extension DescribeBundleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(MobileClientTypes.BundleDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

extension DescribeProjectInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if syncFromResources != false {
                let syncFromResourcesQueryItem = ClientRuntime.URLQueryItem(name: "syncFromResources".urlPercentEncoding(), value: Swift.String(syncFromResources).urlPercentEncoding())
                items.append(syncFromResourcesQueryItem)
            }
            guard let projectId = projectId else {
                let message = "Creating a URL Query Item failed. projectId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let projectIdQueryItem = ClientRuntime.URLQueryItem(name: "projectId".urlPercentEncoding(), value: Swift.String(projectId).urlPercentEncoding())
            items.append(projectIdQueryItem)
            return items
        }
    }
}

extension DescribeProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/project"
    }
}

/// Request structure used to request details about a project.
public struct DescribeProjectInput: Swift.Equatable {
    /// Unique project identifier.
    /// This member is required.
    public var projectId: Swift.String?
    /// If set to true, causes AWS Mobile Hub to synchronize information from other services, e.g., update state of AWS CloudFormation stacks in the AWS Mobile Hub project.
    public var syncFromResources: Swift.Bool

    public init (
        projectId: Swift.String? = nil,
        syncFromResources: Swift.Bool = false
    )
    {
        self.projectId = projectId
        self.syncFromResources = syncFromResources
    }
}

struct DescribeProjectInputBody: Swift.Equatable {
}

extension DescribeProjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeProjectOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
        } else {
            self.details = nil
        }
    }
}

/// Result structure used for requests of project details.
public struct DescribeProjectOutputResponse: Swift.Equatable {
    /// Detailed information about an AWS Mobile Hub project.
    public var details: MobileClientTypes.ProjectDetails?

    public init (
        details: MobileClientTypes.ProjectDetails? = nil
    )
    {
        self.details = details
    }
}

struct DescribeProjectOutputResponseBody: Swift.Equatable {
    let details: MobileClientTypes.ProjectDetails?
}

extension DescribeProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(MobileClientTypes.ProjectDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

extension ExportBundleInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let projectId = projectId {
                let projectIdQueryItem = ClientRuntime.URLQueryItem(name: "projectId".urlPercentEncoding(), value: Swift.String(projectId).urlPercentEncoding())
                items.append(projectIdQueryItem)
            }
            if let platform = platform {
                let platformQueryItem = ClientRuntime.URLQueryItem(name: "platform".urlPercentEncoding(), value: Swift.String(platform.rawValue).urlPercentEncoding())
                items.append(platformQueryItem)
            }
            return items
        }
    }
}

extension ExportBundleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bundleId = bundleId else {
            return nil
        }
        return "/bundles/\(bundleId.urlPercentEncoding())"
    }
}

/// Request structure used to request generation of custom SDK and tool packages required to integrate mobile web or app clients with backed AWS resources.
public struct ExportBundleInput: Swift.Equatable {
    /// Unique bundle identifier.
    /// This member is required.
    public var bundleId: Swift.String?
    /// Developer desktop or target application platform.
    public var platform: MobileClientTypes.Platform?
    /// Unique project identifier.
    public var projectId: Swift.String?

    public init (
        bundleId: Swift.String? = nil,
        platform: MobileClientTypes.Platform? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.bundleId = bundleId
        self.platform = platform
        self.projectId = projectId
    }
}

struct ExportBundleInputBody: Swift.Equatable {
}

extension ExportBundleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ExportBundleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportBundleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ExportBundleOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportBundleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ExportBundleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.downloadUrl = output.downloadUrl
        } else {
            self.downloadUrl = nil
        }
    }
}

/// Result structure which contains link to download custom-generated SDK and tool packages used to integrate mobile web or app clients with backed AWS resources.
public struct ExportBundleOutputResponse: Swift.Equatable {
    /// URL which contains the custom-generated SDK and tool packages used to integrate the client mobile app or web app with the AWS resources created by the AWS Mobile Hub project.
    public var downloadUrl: Swift.String?

    public init (
        downloadUrl: Swift.String? = nil
    )
    {
        self.downloadUrl = downloadUrl
    }
}

struct ExportBundleOutputResponseBody: Swift.Equatable {
    let downloadUrl: Swift.String?
}

extension ExportBundleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downloadUrl
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let downloadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .downloadUrl)
        downloadUrl = downloadUrlDecoded
    }
}

extension ExportProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectId = projectId else {
            return nil
        }
        return "/exports/\(projectId.urlPercentEncoding())"
    }
}

/// Request structure used in requests to export project configuration details.
public struct ExportProjectInput: Swift.Equatable {
    /// Unique project identifier.
    /// This member is required.
    public var projectId: Swift.String?

    public init (
        projectId: Swift.String? = nil
    )
    {
        self.projectId = projectId
    }
}

struct ExportProjectInputBody: Swift.Equatable {
}

extension ExportProjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ExportProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ExportProjectOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ExportProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.downloadUrl = output.downloadUrl
            self.shareUrl = output.shareUrl
            self.snapshotId = output.snapshotId
        } else {
            self.downloadUrl = nil
            self.shareUrl = nil
            self.snapshotId = nil
        }
    }
}

/// Result structure used for requests to export project configuration details.
public struct ExportProjectOutputResponse: Swift.Equatable {
    /// URL which can be used to download the exported project configuation file(s).
    public var downloadUrl: Swift.String?
    /// URL which can be shared to allow other AWS users to create their own project in AWS Mobile Hub with the same configuration as the specified project. This URL pertains to a snapshot in time of the project configuration that is created when this API is called. If you want to share additional changes to your project configuration, then you will need to create and share a new snapshot by calling this method again.
    public var shareUrl: Swift.String?
    /// Unique identifier for the exported snapshot of the project configuration. This snapshot identifier is included in the share URL.
    public var snapshotId: Swift.String?

    public init (
        downloadUrl: Swift.String? = nil,
        shareUrl: Swift.String? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.downloadUrl = downloadUrl
        self.shareUrl = shareUrl
        self.snapshotId = snapshotId
    }
}

struct ExportProjectOutputResponseBody: Swift.Equatable {
    let downloadUrl: Swift.String?
    let shareUrl: Swift.String?
    let snapshotId: Swift.String?
}

extension ExportProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downloadUrl
        case shareUrl
        case snapshotId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let downloadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .downloadUrl)
        downloadUrl = downloadUrlDecoded
        let shareUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareUrl)
        shareUrl = shareUrlDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
    }
}

extension InternalFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service has encountered an unexpected error condition which prevents it from servicing the request.
public struct InternalFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The Exception Error Message.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There are too many AWS Mobile Hub projects in the account or the account has exceeded the maximum number of resources in some AWS service. You should create another sub-account using AWS Organizations or remove some resources and retry your request.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The Exception Error Message.
    public var message: Swift.String?
    /// The Exception Error Message.
    public var retryAfterSeconds: Swift.String?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListBundlesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListBundlesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/bundles"
    }
}

/// Request structure to request all available bundles.
public struct ListBundlesInput: Swift.Equatable {
    /// Maximum number of records to list in a single response.
    public var maxResults: Swift.Int
    /// Pagination token. Set to null to start listing bundles from start. If non-null pagination token is returned in a result, then pass its value in here in another request to list more bundles.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBundlesInputBody: Swift.Equatable {
}

extension ListBundlesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBundlesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBundlesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListBundlesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBundlesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListBundlesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bundleList = output.bundleList
            self.nextToken = output.nextToken
        } else {
            self.bundleList = nil
            self.nextToken = nil
        }
    }
}

/// Result structure contains a list of all available bundles with details.
public struct ListBundlesOutputResponse: Swift.Equatable {
    /// A list of bundles.
    public var bundleList: [MobileClientTypes.BundleDetails]?
    /// Pagination token. If non-null pagination token is returned in a result, then pass its value in another request to fetch more entries.
    public var nextToken: Swift.String?

    public init (
        bundleList: [MobileClientTypes.BundleDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.bundleList = bundleList
        self.nextToken = nextToken
    }
}

struct ListBundlesOutputResponseBody: Swift.Equatable {
    let bundleList: [MobileClientTypes.BundleDetails]?
    let nextToken: Swift.String?
}

extension ListBundlesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleList
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleListContainer = try containerValues.decodeIfPresent([MobileClientTypes.BundleDetails?].self, forKey: .bundleList)
        var bundleListDecoded0:[MobileClientTypes.BundleDetails]? = nil
        if let bundleListContainer = bundleListContainer {
            bundleListDecoded0 = [MobileClientTypes.BundleDetails]()
            for structure0 in bundleListContainer {
                if let structure0 = structure0 {
                    bundleListDecoded0?.append(structure0)
                }
            }
        }
        bundleList = bundleListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProjectsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListProjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/projects"
    }
}

/// Request structure used to request projects list in AWS Mobile Hub.
public struct ListProjectsInput: Swift.Equatable {
    /// Maximum number of records to list in a single response.
    public var maxResults: Swift.Int
    /// Pagination token. Set to null to start listing projects from start. If non-null pagination token is returned in a result, then pass its value in here in another request to list more projects.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProjectsInputBody: Swift.Equatable {
}

extension ListProjectsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListProjectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListProjectsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListProjectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

/// Result structure used for requests to list projects in AWS Mobile Hub.
public struct ListProjectsOutputResponse: Swift.Equatable {
    /// Pagination token. Set to null to start listing records from start. If non-null pagination token is returned in a result, then pass its value in here in another request to list more entries.
    public var nextToken: Swift.String?
    /// List of projects.
    public var projects: [MobileClientTypes.ProjectSummary]?

    public init (
        nextToken: Swift.String? = nil,
        projects: [MobileClientTypes.ProjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListProjectsOutputResponseBody: Swift.Equatable {
    let projects: [MobileClientTypes.ProjectSummary]?
    let nextToken: Swift.String?
}

extension ListProjectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case projects
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectsContainer = try containerValues.decodeIfPresent([MobileClientTypes.ProjectSummary?].self, forKey: .projects)
        var projectsDecoded0:[MobileClientTypes.ProjectSummary]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [MobileClientTypes.ProjectSummary]()
            for structure0 in projectsContainer {
                if let structure0 = structure0 {
                    projectsDecoded0?.append(structure0)
                }
            }
        }
        projects = projectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// No entity can be found with the specified identifier.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The Exception Error Message.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MobileClientTypes {
    /// Developer desktop or target mobile app or website platform.
    public enum Platform: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case android
        case javascript
        case linux
        case objc
        case osx
        case swift
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [Platform] {
            return [
                .android,
                .javascript,
                .linux,
                .objc,
                .osx,
                .swift,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .android: return "ANDROID"
            case .javascript: return "JAVASCRIPT"
            case .linux: return "LINUX"
            case .objc: return "OBJC"
            case .osx: return "OSX"
            case .swift: return "SWIFT"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Platform(rawValue: rawValue) ?? Platform.sdkUnknown(rawValue)
        }
    }
}

extension MobileClientTypes.ProjectDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleUrl
        case createdDate
        case lastUpdatedDate
        case name
        case projectId
        case region
        case resources
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consoleUrl = self.consoleUrl {
            try encodeContainer.encode(consoleUrl, forKey: .consoleUrl)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let lastUpdatedDate = self.lastUpdatedDate {
            try encodeContainer.encodeTimestamp(lastUpdatedDate, format: .epochSeconds, forKey: .lastUpdatedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resource0 in resources {
                try resourcesContainer.encode(resource0)
            }
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MobileClientTypes.ProjectState.self, forKey: .state)
        state = stateDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let consoleUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .consoleUrl)
        consoleUrl = consoleUrlDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([MobileClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[MobileClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [MobileClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension MobileClientTypes {
    /// Detailed information about an AWS Mobile Hub project.
    public struct ProjectDetails: Swift.Equatable {
        /// Website URL for this project in the AWS Mobile Hub console.
        public var consoleUrl: Swift.String?
        /// Date the project was created.
        public var createdDate: ClientRuntime.Date?
        /// Date of the last modification of the project.
        public var lastUpdatedDate: ClientRuntime.Date?
        /// Name of the project.
        public var name: Swift.String?
        /// Unique project identifier.
        public var projectId: Swift.String?
        /// Default region to use for AWS resource creation in the AWS Mobile Hub project.
        public var region: Swift.String?
        /// List of AWS resources associated with a project.
        public var resources: [MobileClientTypes.Resource]?
        /// Synchronization state for a project.
        public var state: MobileClientTypes.ProjectState?

        public init (
            consoleUrl: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            lastUpdatedDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            projectId: Swift.String? = nil,
            region: Swift.String? = nil,
            resources: [MobileClientTypes.Resource]? = nil,
            state: MobileClientTypes.ProjectState? = nil
        )
        {
            self.consoleUrl = consoleUrl
            self.createdDate = createdDate
            self.lastUpdatedDate = lastUpdatedDate
            self.name = name
            self.projectId = projectId
            self.region = region
            self.resources = resources
            self.state = state
        }
    }

}

extension MobileClientTypes {
    /// Synchronization state for a project.
    public enum ProjectState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case importing
        case normal
        case syncing
        case sdkUnknown(Swift.String)

        public static var allCases: [ProjectState] {
            return [
                .importing,
                .normal,
                .syncing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .importing: return "IMPORTING"
            case .normal: return "NORMAL"
            case .syncing: return "SYNCING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProjectState(rawValue: rawValue) ?? ProjectState.sdkUnknown(rawValue)
        }
    }
}

extension MobileClientTypes.ProjectSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case projectId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
    }
}

extension MobileClientTypes {
    /// Summary information about an AWS Mobile Hub project.
    public struct ProjectSummary: Swift.Equatable {
        /// Name of the project.
        public var name: Swift.String?
        /// Unique project identifier.
        public var projectId: Swift.String?

        public init (
            name: Swift.String? = nil,
            projectId: Swift.String? = nil
        )
        {
            self.name = name
            self.projectId = projectId
        }
    }

}

extension MobileClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case attributes
        case feature
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let feature = self.feature {
            try encodeContainer.encode(feature, forKey: .feature)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let featureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .feature)
        feature = featureDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension MobileClientTypes {
    /// Information about an instance of an AWS resource associated with a project.
    public struct Resource: Swift.Equatable {
        /// AWS resource name which uniquely identifies the resource in AWS systems.
        public var arn: Swift.String?
        /// Key-value attribute pairs.
        public var attributes: [Swift.String:Swift.String]?
        /// Identifies which feature in AWS Mobile Hub is associated with this AWS resource.
        public var feature: Swift.String?
        /// Name of the AWS resource (e.g., for an Amazon S3 bucket this is the name of the bucket).
        public var name: Swift.String?
        /// Simplified name for type of AWS resource (e.g., bucket is an Amazon S3 bucket).
        public var type: Swift.String?

        public init (
            arn: Swift.String? = nil,
            attributes: [Swift.String:Swift.String]? = nil,
            feature: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.attributes = attributes
            self.feature = feature
            self.name = name
            self.type = type
        }
    }

}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service is temporarily unavailable. The request should be retried after some time delay.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The Exception Error Message.
    public var message: Swift.String?
    /// The Exception Error Message.
    public var retryAfterSeconds: Swift.String?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Too many requests have been received for this AWS account in too short a time. The request should be retried after some time delay.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The Exception Error Message.
    public var message: Swift.String?
    /// The Exception Error Message.
    public var retryAfterSeconds: Swift.String?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Credentials of the caller are insufficient to authorize the request.
public struct UnauthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The Exception Error Message.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProjectInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateProjectOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let contents = input.operationInput.contents {
            let contentsdata = contents
            let contentsbody = ClientRuntime.HttpBody.data(contentsdata)
            input.builder.withBody(contentsbody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contents
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contents = self.contents {
            try encodeContainer.encode(contents.base64EncodedString(), forKey: .contents)
        }
    }
}

extension UpdateProjectInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let projectId = projectId else {
                let message = "Creating a URL Query Item failed. projectId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let projectIdQueryItem = ClientRuntime.URLQueryItem(name: "projectId".urlPercentEncoding(), value: Swift.String(projectId).urlPercentEncoding())
            items.append(projectIdQueryItem)
            return items
        }
    }
}

extension UpdateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update"
    }
}

/// Request structure used for requests to update project configuration.
public struct UpdateProjectInput: Swift.Equatable {
    /// ZIP or YAML file which contains project configuration to be updated. This should be the contents of the file downloaded from the URL provided in an export project operation.
    public var contents: ClientRuntime.Data?
    /// Unique project identifier.
    /// This member is required.
    public var projectId: Swift.String?

    public init (
        contents: ClientRuntime.Data? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.contents = contents
        self.projectId = projectId
    }
}

struct UpdateProjectInputBody: Swift.Equatable {
    let contents: ClientRuntime.Data?
}

extension UpdateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contents
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentsDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .contents)
        contents = contentsDecoded
    }
}

extension UpdateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccountActionRequiredException" : self = .accountActionRequiredException(try AccountActionRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateProjectOutputError: Swift.Error, Swift.Equatable {
    case accountActionRequiredException(AccountActionRequiredException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
        } else {
            self.details = nil
        }
    }
}

/// Result structure used for requests to updated project configuration.
public struct UpdateProjectOutputResponse: Swift.Equatable {
    /// Detailed information about the updated AWS Mobile Hub project.
    public var details: MobileClientTypes.ProjectDetails?

    public init (
        details: MobileClientTypes.ProjectDetails? = nil
    )
    {
        self.details = details
    }
}

struct UpdateProjectOutputResponseBody: Swift.Equatable {
    let details: MobileClientTypes.ProjectDetails?
}

extension UpdateProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(MobileClientTypes.ProjectDetails.self, forKey: .details)
        details = detailsDecoded
    }
}
