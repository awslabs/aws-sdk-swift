// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct BatchMeterUsageInputBodyMiddleware: Middleware {
    public let id: String = "BatchMeterUsageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchMeterUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchMeterUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchMeterUsageInput>
    public typealias MOutput = OperationOutput<BatchMeterUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchMeterUsageOutputError>
}

extension BatchMeterUsageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchMeterUsageInput(productCode: \(String(describing: productCode)), usageRecords: \(String(describing: usageRecords)))"}
}

extension BatchMeterUsageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case productCode = "ProductCode"
        case usageRecords = "UsageRecords"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productCode = productCode {
            try encodeContainer.encode(productCode, forKey: .productCode)
        }
        if let usageRecords = usageRecords {
            var usageRecordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usageRecords)
            for usagerecordlist0 in usageRecords {
                try usageRecordsContainer.encode(usagerecordlist0)
            }
        }
    }
}

public struct BatchMeterUsageInputHeadersMiddleware: Middleware {
    public let id: String = "BatchMeterUsageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchMeterUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchMeterUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchMeterUsageInput>
    public typealias MOutput = OperationOutput<BatchMeterUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchMeterUsageOutputError>
}

public struct BatchMeterUsageInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchMeterUsageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchMeterUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchMeterUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchMeterUsageInput>
    public typealias MOutput = OperationOutput<BatchMeterUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchMeterUsageOutputError>
}

/// <p>A BatchMeterUsageRequest contains UsageRecords, which indicate quantities of usage
///             within your application.</p>
public struct BatchMeterUsageInput: Equatable {
    /// <p>Product code is used to uniquely identify a product in AWS Marketplace. The product
    ///             code should be the same as the one used during the publishing of a new
    ///             product.</p>
    public let productCode: String?
    /// <p>The set of UsageRecords to submit. BatchMeterUsage accepts up to 25 UsageRecords at
    ///             a time.</p>
    public let usageRecords: [UsageRecord]?

    public init (
        productCode: String? = nil,
        usageRecords: [UsageRecord]? = nil
    )
    {
        self.productCode = productCode
        self.usageRecords = usageRecords
    }
}

struct BatchMeterUsageInputBody: Equatable {
    public let usageRecords: [UsageRecord]?
    public let productCode: String?
}

extension BatchMeterUsageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case productCode = "ProductCode"
        case usageRecords = "UsageRecords"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageRecordsContainer = try containerValues.decodeIfPresent([UsageRecord?].self, forKey: .usageRecords)
        var usageRecordsDecoded0:[UsageRecord]? = nil
        if let usageRecordsContainer = usageRecordsContainer {
            usageRecordsDecoded0 = [UsageRecord]()
            for structure0 in usageRecordsContainer {
                if let structure0 = structure0 {
                    usageRecordsDecoded0?.append(structure0)
                }
            }
        }
        usageRecords = usageRecordsDecoded0
        let productCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productCode)
        productCode = productCodeDecoded
    }
}

extension BatchMeterUsageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchMeterUsageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DisabledApiException" : self = .disabledApiException(try DisabledApiException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCustomerIdentifierException" : self = .invalidCustomerIdentifierException(try InvalidCustomerIdentifierException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidProductCodeException" : self = .invalidProductCodeException(try InvalidProductCodeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagException" : self = .invalidTagException(try InvalidTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUsageAllocationsException" : self = .invalidUsageAllocationsException(try InvalidUsageAllocationsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUsageDimensionException" : self = .invalidUsageDimensionException(try InvalidUsageDimensionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TimestampOutOfBoundsException" : self = .timestampOutOfBoundsException(try TimestampOutOfBoundsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchMeterUsageOutputError: Equatable {
    case disabledApiException(DisabledApiException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidCustomerIdentifierException(InvalidCustomerIdentifierException)
    case invalidProductCodeException(InvalidProductCodeException)
    case invalidTagException(InvalidTagException)
    case invalidUsageAllocationsException(InvalidUsageAllocationsException)
    case invalidUsageDimensionException(InvalidUsageDimensionException)
    case throttlingException(ThrottlingException)
    case timestampOutOfBoundsException(TimestampOutOfBoundsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchMeterUsageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchMeterUsageOutputResponse(results: \(String(describing: results)), unprocessedRecords: \(String(describing: unprocessedRecords)))"}
}

extension BatchMeterUsageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchMeterUsageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.results = output.results
            self.unprocessedRecords = output.unprocessedRecords
        } else {
            self.results = nil
            self.unprocessedRecords = nil
        }
    }
}

/// <p>Contains the UsageRecords processed by BatchMeterUsage and any records that have
///             failed due to transient error.</p>
public struct BatchMeterUsageOutputResponse: Equatable {
    /// <p>Contains all UsageRecords processed by BatchMeterUsage. These records were either
    ///             honored by AWS Marketplace Metering Service or were invalid.</p>
    public let results: [UsageRecordResult]?
    /// <p>Contains all UsageRecords that were not processed by BatchMeterUsage. This is a
    ///             list of UsageRecords. You can retry the failed request by making another BatchMeterUsage
    ///             call with this list as input in the BatchMeterUsageRequest.</p>
    public let unprocessedRecords: [UsageRecord]?

    public init (
        results: [UsageRecordResult]? = nil,
        unprocessedRecords: [UsageRecord]? = nil
    )
    {
        self.results = results
        self.unprocessedRecords = unprocessedRecords
    }
}

struct BatchMeterUsageOutputResponseBody: Equatable {
    public let results: [UsageRecordResult]?
    public let unprocessedRecords: [UsageRecord]?
}

extension BatchMeterUsageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case results = "Results"
        case unprocessedRecords = "UnprocessedRecords"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([UsageRecordResult?].self, forKey: .results)
        var resultsDecoded0:[UsageRecordResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [UsageRecordResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
        let unprocessedRecordsContainer = try containerValues.decodeIfPresent([UsageRecord?].self, forKey: .unprocessedRecords)
        var unprocessedRecordsDecoded0:[UsageRecord]? = nil
        if let unprocessedRecordsContainer = unprocessedRecordsContainer {
            unprocessedRecordsDecoded0 = [UsageRecord]()
            for structure0 in unprocessedRecordsContainer {
                if let structure0 = structure0 {
                    unprocessedRecordsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedRecords = unprocessedRecordsDecoded0
    }
}

extension CustomerNotEntitledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomerNotEntitledException(message: \(String(describing: message)))"}
}

extension CustomerNotEntitledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CustomerNotEntitledExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception thrown when the customer does not have a valid subscription for the
///             product.</p>
public struct CustomerNotEntitledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CustomerNotEntitledExceptionBody: Equatable {
    public let message: String?
}

extension CustomerNotEntitledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DisabledApiException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisabledApiException(message: \(String(describing: message)))"}
}

extension DisabledApiException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisabledApiExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The API is disabled in the Region.</p>
public struct DisabledApiException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DisabledApiExceptionBody: Equatable {
    public let message: String?
}

extension DisabledApiExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicateRequestException(message: \(String(describing: message)))"}
}

extension DuplicateRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DuplicateRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A metering record has already been emitted by the same EC2 instance, ECS task, or
///             EKS pod for the given {usageDimension, timestamp} with a different
///             usageQuantity.</p>
public struct DuplicateRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateRequestExceptionBody: Equatable {
    public let message: String?
}

extension DuplicateRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ExpiredTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExpiredTokenException(message: \(String(describing: message)))"}
}

extension ExpiredTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExpiredTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The submitted registration token has expired. This can happen if the buyer's
///             browser takes too long to redirect to your page, the buyer has resubmitted the
///             registration token, or your application has held on to the registration token for too
///             long. Your SaaS registration website should redeem this token as soon as it is submitted
///             by the buyer's browser.</p>
public struct ExpiredTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ExpiredTokenExceptionBody: Equatable {
    public let message: String?
}

extension ExpiredTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServiceErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceErrorException(message: \(String(describing: message)))"}
}

extension InternalServiceErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServiceErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal error has occurred. Retry your request. If the problem persists, post a
///             message with details on the AWS forums.</p>
public struct InternalServiceErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorExceptionBody: Equatable {
    public let message: String?
}

extension InternalServiceErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCustomerIdentifierException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidCustomerIdentifierException(message: \(String(describing: message)))"}
}

extension InvalidCustomerIdentifierException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidCustomerIdentifierExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have metered usage for a CustomerIdentifier that does not exist.</p>
public struct InvalidCustomerIdentifierException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCustomerIdentifierExceptionBody: Equatable {
    public let message: String?
}

extension InvalidCustomerIdentifierExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEndpointRegionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidEndpointRegionException(message: \(String(describing: message)))"}
}

extension InvalidEndpointRegionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidEndpointRegionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The endpoint being called is in a AWS Region different from your EC2 instance, ECS
///             task, or EKS pod. The Region of the Metering Service endpoint and the AWS Region of the
///             resource must match.</p>
public struct InvalidEndpointRegionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEndpointRegionExceptionBody: Equatable {
    public let message: String?
}

extension InvalidEndpointRegionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidProductCodeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidProductCodeException(message: \(String(describing: message)))"}
}

extension InvalidProductCodeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidProductCodeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The product code passed does not match the product code used for publishing the
///             product.</p>
public struct InvalidProductCodeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidProductCodeExceptionBody: Equatable {
    public let message: String?
}

extension InvalidProductCodeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPublicKeyVersionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPublicKeyVersionException(message: \(String(describing: message)))"}
}

extension InvalidPublicKeyVersionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidPublicKeyVersionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Public Key version is invalid.</p>
public struct InvalidPublicKeyVersionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPublicKeyVersionExceptionBody: Equatable {
    public let message: String?
}

extension InvalidPublicKeyVersionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRegionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRegionException(message: \(String(describing: message)))"}
}

extension InvalidRegionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRegionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>RegisterUsage must be called in the same AWS Region the ECS task was launched in.
///             This prevents a container from hardcoding a Region (e.g. withRegion(“us-east-1”) when
///             calling RegisterUsage.</p>
public struct InvalidRegionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRegionExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRegionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTagException(message: \(String(describing: message)))"}
}

extension InvalidTagException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTagExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The tag is invalid, or the number of tags is greater than 5.</p>
public struct InvalidTagException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTagExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTagExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTokenException(message: \(String(describing: message)))"}
}

extension InvalidTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Registration token is invalid.</p>
public struct InvalidTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidUsageAllocationsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidUsageAllocationsException(message: \(String(describing: message)))"}
}

extension InvalidUsageAllocationsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidUsageAllocationsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The usage allocation objects are invalid, or the number of allocations is greater
///             than 500 for a single usage record.</p>
public struct InvalidUsageAllocationsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidUsageAllocationsExceptionBody: Equatable {
    public let message: String?
}

extension InvalidUsageAllocationsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidUsageDimensionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidUsageDimensionException(message: \(String(describing: message)))"}
}

extension InvalidUsageDimensionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidUsageDimensionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The usage dimension does not match one of the UsageDimensions associated with
///             products.</p>
public struct InvalidUsageDimensionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidUsageDimensionExceptionBody: Equatable {
    public let message: String?
}

extension InvalidUsageDimensionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct MeterUsageInputBodyMiddleware: Middleware {
    public let id: String = "MeterUsageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MeterUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<MeterUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MeterUsageInput>
    public typealias MOutput = OperationOutput<MeterUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MeterUsageOutputError>
}

extension MeterUsageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MeterUsageInput(dryRun: \(String(describing: dryRun)), productCode: \(String(describing: productCode)), timestamp: \(String(describing: timestamp)), usageAllocations: \(String(describing: usageAllocations)), usageDimension: \(String(describing: usageDimension)), usageQuantity: \(String(describing: usageQuantity)))"}
}

extension MeterUsageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case productCode = "ProductCode"
        case timestamp = "Timestamp"
        case usageAllocations = "UsageAllocations"
        case usageDimension = "UsageDimension"
        case usageQuantity = "UsageQuantity"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dryRun = dryRun {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let productCode = productCode {
            try encodeContainer.encode(productCode, forKey: .productCode)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if let usageAllocations = usageAllocations {
            var usageAllocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usageAllocations)
            for usageallocations0 in usageAllocations {
                try usageAllocationsContainer.encode(usageallocations0)
            }
        }
        if let usageDimension = usageDimension {
            try encodeContainer.encode(usageDimension, forKey: .usageDimension)
        }
        if let usageQuantity = usageQuantity {
            try encodeContainer.encode(usageQuantity, forKey: .usageQuantity)
        }
    }
}

public struct MeterUsageInputHeadersMiddleware: Middleware {
    public let id: String = "MeterUsageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MeterUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<MeterUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MeterUsageInput>
    public typealias MOutput = OperationOutput<MeterUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MeterUsageOutputError>
}

public struct MeterUsageInputQueryItemMiddleware: Middleware {
    public let id: String = "MeterUsageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MeterUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<MeterUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MeterUsageInput>
    public typealias MOutput = OperationOutput<MeterUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MeterUsageOutputError>
}

public struct MeterUsageInput: Equatable {
    /// <p>Checks whether you have the permissions required for the action, but does not make
    ///             the request. If you have the permissions, the request returns DryRunOperation;
    ///             otherwise, it returns UnauthorizedException. Defaults to <code>false</code> if not
    ///             specified.</p>
    public let dryRun: Bool?
    /// <p>Product code is used to uniquely identify a product in AWS Marketplace. The product
    ///             code should be the same as the one used during the publishing of a new
    ///             product.</p>
    public let productCode: String?
    /// <p>Timestamp, in UTC, for which the usage is being reported. Your application can
    ///             meter usage for up to one hour in the past. Make sure the timestamp value is not before
    ///             the start of the software usage.</p>
    public let timestamp: Date?
    /// <p>The set of UsageAllocations to submit.</p>
    ///         <p>The sum of all UsageAllocation quantities must equal the
    ///             UsageQuantity of the MeterUsage request, and each UsageAllocation must have a
    ///             unique set of tags (include no tags).</p>
    public let usageAllocations: [UsageAllocation]?
    /// <p>It will be one of the fcp dimension name provided during the publishing of the
    ///             product.</p>
    public let usageDimension: String?
    /// <p>Consumption value for the hour. Defaults to <code>0</code> if not
    ///             specified.</p>
    public let usageQuantity: Int?

    public init (
        dryRun: Bool? = nil,
        productCode: String? = nil,
        timestamp: Date? = nil,
        usageAllocations: [UsageAllocation]? = nil,
        usageDimension: String? = nil,
        usageQuantity: Int? = nil
    )
    {
        self.dryRun = dryRun
        self.productCode = productCode
        self.timestamp = timestamp
        self.usageAllocations = usageAllocations
        self.usageDimension = usageDimension
        self.usageQuantity = usageQuantity
    }
}

struct MeterUsageInputBody: Equatable {
    public let productCode: String?
    public let timestamp: Date?
    public let usageDimension: String?
    public let usageQuantity: Int?
    public let dryRun: Bool?
    public let usageAllocations: [UsageAllocation]?
}

extension MeterUsageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case productCode = "ProductCode"
        case timestamp = "Timestamp"
        case usageAllocations = "UsageAllocations"
        case usageDimension = "UsageDimension"
        case usageQuantity = "UsageQuantity"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let usageDimensionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .usageDimension)
        usageDimension = usageDimensionDecoded
        let usageQuantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .usageQuantity)
        usageQuantity = usageQuantityDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
        let usageAllocationsContainer = try containerValues.decodeIfPresent([UsageAllocation?].self, forKey: .usageAllocations)
        var usageAllocationsDecoded0:[UsageAllocation]? = nil
        if let usageAllocationsContainer = usageAllocationsContainer {
            usageAllocationsDecoded0 = [UsageAllocation]()
            for structure0 in usageAllocationsContainer {
                if let structure0 = structure0 {
                    usageAllocationsDecoded0?.append(structure0)
                }
            }
        }
        usageAllocations = usageAllocationsDecoded0
    }
}

extension MeterUsageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MeterUsageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CustomerNotEntitledException" : self = .customerNotEntitledException(try CustomerNotEntitledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRequestException" : self = .duplicateRequestException(try DuplicateRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointRegionException" : self = .invalidEndpointRegionException(try InvalidEndpointRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidProductCodeException" : self = .invalidProductCodeException(try InvalidProductCodeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagException" : self = .invalidTagException(try InvalidTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUsageAllocationsException" : self = .invalidUsageAllocationsException(try InvalidUsageAllocationsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUsageDimensionException" : self = .invalidUsageDimensionException(try InvalidUsageDimensionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TimestampOutOfBoundsException" : self = .timestampOutOfBoundsException(try TimestampOutOfBoundsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum MeterUsageOutputError: Equatable {
    case customerNotEntitledException(CustomerNotEntitledException)
    case duplicateRequestException(DuplicateRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidEndpointRegionException(InvalidEndpointRegionException)
    case invalidProductCodeException(InvalidProductCodeException)
    case invalidTagException(InvalidTagException)
    case invalidUsageAllocationsException(InvalidUsageAllocationsException)
    case invalidUsageDimensionException(InvalidUsageDimensionException)
    case throttlingException(ThrottlingException)
    case timestampOutOfBoundsException(TimestampOutOfBoundsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MeterUsageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MeterUsageOutputResponse(meteringRecordId: \(String(describing: meteringRecordId)))"}
}

extension MeterUsageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MeterUsageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.meteringRecordId = output.meteringRecordId
        } else {
            self.meteringRecordId = nil
        }
    }
}

public struct MeterUsageOutputResponse: Equatable {
    /// <p>Metering record id.</p>
    public let meteringRecordId: String?

    public init (
        meteringRecordId: String? = nil
    )
    {
        self.meteringRecordId = meteringRecordId
    }
}

struct MeterUsageOutputResponseBody: Equatable {
    public let meteringRecordId: String?
}

extension MeterUsageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case meteringRecordId = "MeteringRecordId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meteringRecordIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meteringRecordId)
        meteringRecordId = meteringRecordIdDecoded
    }
}

extension PlatformNotSupportedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PlatformNotSupportedException(message: \(String(describing: message)))"}
}

extension PlatformNotSupportedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PlatformNotSupportedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS Marketplace does not support metering usage from the underlying platform.
///             Currently, Amazon ECS, Amazon EKS, and AWS Fargate are supported.</p>
public struct PlatformNotSupportedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PlatformNotSupportedExceptionBody: Equatable {
    public let message: String?
}

extension PlatformNotSupportedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct RegisterUsageInputBodyMiddleware: Middleware {
    public let id: String = "RegisterUsageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterUsageInput>
    public typealias MOutput = OperationOutput<RegisterUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterUsageOutputError>
}

extension RegisterUsageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterUsageInput(nonce: \(String(describing: nonce)), productCode: \(String(describing: productCode)), publicKeyVersion: \(String(describing: publicKeyVersion)))"}
}

extension RegisterUsageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nonce = "Nonce"
        case productCode = "ProductCode"
        case publicKeyVersion = "PublicKeyVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nonce = nonce {
            try encodeContainer.encode(nonce, forKey: .nonce)
        }
        if let productCode = productCode {
            try encodeContainer.encode(productCode, forKey: .productCode)
        }
        if let publicKeyVersion = publicKeyVersion {
            try encodeContainer.encode(publicKeyVersion, forKey: .publicKeyVersion)
        }
    }
}

public struct RegisterUsageInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterUsageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterUsageInput>
    public typealias MOutput = OperationOutput<RegisterUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterUsageOutputError>
}

public struct RegisterUsageInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterUsageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterUsageInput>
    public typealias MOutput = OperationOutput<RegisterUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterUsageOutputError>
}

public struct RegisterUsageInput: Equatable {
    /// <p>(Optional) To scope down the registration to a specific running software instance
    ///             and guard against replay attacks.</p>
    public let nonce: String?
    /// <p>Product code is used to uniquely identify a product in AWS Marketplace. The product
    ///             code should be the same as the one used during the publishing of a new
    ///             product.</p>
    public let productCode: String?
    /// <p>Public Key Version provided by AWS Marketplace</p>
    public let publicKeyVersion: Int?

    public init (
        nonce: String? = nil,
        productCode: String? = nil,
        publicKeyVersion: Int? = nil
    )
    {
        self.nonce = nonce
        self.productCode = productCode
        self.publicKeyVersion = publicKeyVersion
    }
}

struct RegisterUsageInputBody: Equatable {
    public let productCode: String?
    public let publicKeyVersion: Int?
    public let nonce: String?
}

extension RegisterUsageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nonce = "Nonce"
        case productCode = "ProductCode"
        case publicKeyVersion = "PublicKeyVersion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let publicKeyVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .publicKeyVersion)
        publicKeyVersion = publicKeyVersionDecoded
        let nonceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nonce)
        nonce = nonceDecoded
    }
}

extension RegisterUsageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterUsageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CustomerNotEntitledException" : self = .customerNotEntitledException(try CustomerNotEntitledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledApiException" : self = .disabledApiException(try DisabledApiException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidProductCodeException" : self = .invalidProductCodeException(try InvalidProductCodeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPublicKeyVersionException" : self = .invalidPublicKeyVersionException(try InvalidPublicKeyVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRegionException" : self = .invalidRegionException(try InvalidRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PlatformNotSupportedException" : self = .platformNotSupportedException(try PlatformNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterUsageOutputError: Equatable {
    case customerNotEntitledException(CustomerNotEntitledException)
    case disabledApiException(DisabledApiException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidProductCodeException(InvalidProductCodeException)
    case invalidPublicKeyVersionException(InvalidPublicKeyVersionException)
    case invalidRegionException(InvalidRegionException)
    case platformNotSupportedException(PlatformNotSupportedException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterUsageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterUsageOutputResponse(publicKeyRotationTimestamp: \(String(describing: publicKeyRotationTimestamp)), signature: \(String(describing: signature)))"}
}

extension RegisterUsageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterUsageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.publicKeyRotationTimestamp = output.publicKeyRotationTimestamp
            self.signature = output.signature
        } else {
            self.publicKeyRotationTimestamp = nil
            self.signature = nil
        }
    }
}

public struct RegisterUsageOutputResponse: Equatable {
    /// <p>(Optional) Only included when public key version has expired</p>
    public let publicKeyRotationTimestamp: Date?
    /// <p>JWT Token</p>
    public let signature: String?

    public init (
        publicKeyRotationTimestamp: Date? = nil,
        signature: String? = nil
    )
    {
        self.publicKeyRotationTimestamp = publicKeyRotationTimestamp
        self.signature = signature
    }
}

struct RegisterUsageOutputResponseBody: Equatable {
    public let publicKeyRotationTimestamp: Date?
    public let signature: String?
}

extension RegisterUsageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case publicKeyRotationTimestamp = "PublicKeyRotationTimestamp"
        case signature = "Signature"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyRotationTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .publicKeyRotationTimestamp)
        publicKeyRotationTimestamp = publicKeyRotationTimestampDecoded
        let signatureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signature)
        signature = signatureDecoded
    }
}

public struct ResolveCustomerInputBodyMiddleware: Middleware {
    public let id: String = "ResolveCustomerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResolveCustomerInput>,
                  next: H) -> Swift.Result<OperationOutput<ResolveCustomerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResolveCustomerInput>
    public typealias MOutput = OperationOutput<ResolveCustomerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResolveCustomerOutputError>
}

extension ResolveCustomerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResolveCustomerInput(registrationToken: \(String(describing: registrationToken)))"}
}

extension ResolveCustomerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case registrationToken = "RegistrationToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registrationToken = registrationToken {
            try encodeContainer.encode(registrationToken, forKey: .registrationToken)
        }
    }
}

public struct ResolveCustomerInputHeadersMiddleware: Middleware {
    public let id: String = "ResolveCustomerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResolveCustomerInput>,
                  next: H) -> Swift.Result<OperationOutput<ResolveCustomerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResolveCustomerInput>
    public typealias MOutput = OperationOutput<ResolveCustomerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResolveCustomerOutputError>
}

public struct ResolveCustomerInputQueryItemMiddleware: Middleware {
    public let id: String = "ResolveCustomerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResolveCustomerInput>,
                  next: H) -> Swift.Result<OperationOutput<ResolveCustomerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResolveCustomerInput>
    public typealias MOutput = OperationOutput<ResolveCustomerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResolveCustomerOutputError>
}

/// <p>Contains input to the ResolveCustomer operation.</p>
public struct ResolveCustomerInput: Equatable {
    /// <p>When a buyer visits your website during the registration process, the buyer submits
    ///             a registration token through the browser. The registration token is resolved to obtain a
    ///             CustomerIdentifier and product code.</p>
    public let registrationToken: String?

    public init (
        registrationToken: String? = nil
    )
    {
        self.registrationToken = registrationToken
    }
}

struct ResolveCustomerInputBody: Equatable {
    public let registrationToken: String?
}

extension ResolveCustomerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case registrationToken = "RegistrationToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registrationToken)
        registrationToken = registrationTokenDecoded
    }
}

extension ResolveCustomerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResolveCustomerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DisabledApiException" : self = .disabledApiException(try DisabledApiException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredTokenException" : self = .expiredTokenException(try ExpiredTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTokenException" : self = .invalidTokenException(try InvalidTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResolveCustomerOutputError: Equatable {
    case disabledApiException(DisabledApiException)
    case expiredTokenException(ExpiredTokenException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidTokenException(InvalidTokenException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResolveCustomerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResolveCustomerOutputResponse(customerIdentifier: \(String(describing: customerIdentifier)), productCode: \(String(describing: productCode)))"}
}

extension ResolveCustomerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResolveCustomerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customerIdentifier = output.customerIdentifier
            self.productCode = output.productCode
        } else {
            self.customerIdentifier = nil
            self.productCode = nil
        }
    }
}

/// <p>The result of the ResolveCustomer operation. Contains the CustomerIdentifier and
///             product code.</p>
public struct ResolveCustomerOutputResponse: Equatable {
    /// <p>The CustomerIdentifier is used to identify an individual customer in your
    ///             application. Calls to BatchMeterUsage require CustomerIdentifiers for each
    ///             UsageRecord.</p>
    public let customerIdentifier: String?
    /// <p>The product code is returned to confirm that the buyer is registering for your
    ///             product. Subsequent BatchMeterUsage calls should be made using this product
    ///             code.</p>
    public let productCode: String?

    public init (
        customerIdentifier: String? = nil,
        productCode: String? = nil
    )
    {
        self.customerIdentifier = customerIdentifier
        self.productCode = productCode
    }
}

struct ResolveCustomerOutputResponseBody: Equatable {
    public let customerIdentifier: String?
    public let productCode: String?
}

extension ResolveCustomerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customerIdentifier = "CustomerIdentifier"
        case productCode = "ProductCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerIdentifier)
        customerIdentifier = customerIdentifierDecoded
        let productCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productCode)
        productCode = productCodeDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Metadata assigned to an allocation. Each tag is made up of a key and a value.</p>
public struct Tag: Equatable {
    /// <p>One part of a key-value pair that makes up a tag. A key is a label that acts like a
    ///             category for the specific tag values.</p>
    public let key: String?
    /// <p>One part of a key-value pair that makes up a tag. A value acts as a descriptor within
    ///             a tag category (key). The value can be empty or null.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The calls to the API are throttled.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TimestampOutOfBoundsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimestampOutOfBoundsException(message: \(String(describing: message)))"}
}

extension TimestampOutOfBoundsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TimestampOutOfBoundsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The timestamp value passed in the meterUsage() is out of allowed range.</p>
public struct TimestampOutOfBoundsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TimestampOutOfBoundsExceptionBody: Equatable {
    public let message: String?
}

extension TimestampOutOfBoundsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UsageAllocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedUsageQuantity = "AllocatedUsageQuantity"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocatedUsageQuantity = allocatedUsageQuantity {
            try encodeContainer.encode(allocatedUsageQuantity, forKey: .allocatedUsageQuantity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allocatedUsageQuantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .allocatedUsageQuantity)
        allocatedUsageQuantity = allocatedUsageQuantityDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UsageAllocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UsageAllocation(allocatedUsageQuantity: \(String(describing: allocatedUsageQuantity)), tags: \(String(describing: tags)))"}
}

/// <p>Usage allocations allow you to split usage into buckets by tags.</p>
///         <p>Each UsageAllocation indicates the usage quantity for a specific set of tags.</p>
public struct UsageAllocation: Equatable {
    /// <p>The total quantity allocated to this bucket of usage.</p>
    public let allocatedUsageQuantity: Int?
    /// <p>The set of tags that define the bucket of usage. For the bucket of items with no
    ///             tags, this parameter can be left out.</p>
    public let tags: [Tag]?

    public init (
        allocatedUsageQuantity: Int? = nil,
        tags: [Tag]? = nil
    )
    {
        self.allocatedUsageQuantity = allocatedUsageQuantity
        self.tags = tags
    }
}

extension UsageRecord: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customerIdentifier = "CustomerIdentifier"
        case dimension = "Dimension"
        case quantity = "Quantity"
        case timestamp = "Timestamp"
        case usageAllocations = "UsageAllocations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerIdentifier = customerIdentifier {
            try encodeContainer.encode(customerIdentifier, forKey: .customerIdentifier)
        }
        if let dimension = dimension {
            try encodeContainer.encode(dimension, forKey: .dimension)
        }
        if let quantity = quantity {
            try encodeContainer.encode(quantity, forKey: .quantity)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if let usageAllocations = usageAllocations {
            var usageAllocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usageAllocations)
            for usageallocations0 in usageAllocations {
                try usageAllocationsContainer.encode(usageallocations0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let customerIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerIdentifier)
        customerIdentifier = customerIdentifierDecoded
        let dimensionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dimension)
        dimension = dimensionDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        let usageAllocationsContainer = try containerValues.decodeIfPresent([UsageAllocation?].self, forKey: .usageAllocations)
        var usageAllocationsDecoded0:[UsageAllocation]? = nil
        if let usageAllocationsContainer = usageAllocationsContainer {
            usageAllocationsDecoded0 = [UsageAllocation]()
            for structure0 in usageAllocationsContainer {
                if let structure0 = structure0 {
                    usageAllocationsDecoded0?.append(structure0)
                }
            }
        }
        usageAllocations = usageAllocationsDecoded0
    }
}

extension UsageRecord: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UsageRecord(customerIdentifier: \(String(describing: customerIdentifier)), dimension: \(String(describing: dimension)), quantity: \(String(describing: quantity)), timestamp: \(String(describing: timestamp)), usageAllocations: \(String(describing: usageAllocations)))"}
}

/// <p>A UsageRecord indicates a quantity of usage for a given product, customer,
///             dimension and time.</p>
///         <p>Multiple requests with the same UsageRecords as input will be deduplicated to
///             prevent double charges.</p>
public struct UsageRecord: Equatable {
    /// <p>The CustomerIdentifier is obtained through the ResolveCustomer operation and
    ///             represents an individual buyer in your application.</p>
    public let customerIdentifier: String?
    /// <p>During the process of registering a product on AWS Marketplace, up to eight
    ///             dimensions are specified. These represent different units of value in your
    ///             application.</p>
    public let dimension: String?
    /// <p>The quantity of usage consumed by the customer for the given dimension and time.
    ///             Defaults to <code>0</code> if not specified.</p>
    public let quantity: Int?
    /// <p>Timestamp, in UTC, for which the usage is being reported.</p>
    ///         <p>Your application can meter usage for up to one hour in the past. Make sure the
    ///             timestamp value is not before the start of the software usage.</p>
    public let timestamp: Date?
    /// <p>The set of UsageAllocations to submit. The sum of all UsageAllocation quantities
    ///             must equal the Quantity of the UsageRecord.</p>
    public let usageAllocations: [UsageAllocation]?

    public init (
        customerIdentifier: String? = nil,
        dimension: String? = nil,
        quantity: Int? = nil,
        timestamp: Date? = nil,
        usageAllocations: [UsageAllocation]? = nil
    )
    {
        self.customerIdentifier = customerIdentifier
        self.dimension = dimension
        self.quantity = quantity
        self.timestamp = timestamp
        self.usageAllocations = usageAllocations
    }
}

extension UsageRecordResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case meteringRecordId = "MeteringRecordId"
        case status = "Status"
        case usageRecord = "UsageRecord"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let meteringRecordId = meteringRecordId {
            try encodeContainer.encode(meteringRecordId, forKey: .meteringRecordId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let usageRecord = usageRecord {
            try encodeContainer.encode(usageRecord, forKey: .usageRecord)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageRecordDecoded = try containerValues.decodeIfPresent(UsageRecord.self, forKey: .usageRecord)
        usageRecord = usageRecordDecoded
        let meteringRecordIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meteringRecordId)
        meteringRecordId = meteringRecordIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(UsageRecordResultStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UsageRecordResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UsageRecordResult(meteringRecordId: \(String(describing: meteringRecordId)), status: \(String(describing: status)), usageRecord: \(String(describing: usageRecord)))"}
}

/// <p>A UsageRecordResult indicates the status of a given UsageRecord processed by
///             BatchMeterUsage.</p>
public struct UsageRecordResult: Equatable {
    /// <p>The MeteringRecordId is a unique identifier for this metering event.</p>
    public let meteringRecordId: String?
    /// <p>The UsageRecordResult Status indicates the status of an individual UsageRecord
    ///             processed by BatchMeterUsage.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <i>Success</i>- The UsageRecord was accepted and honored by
    ///                     BatchMeterUsage.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <i>CustomerNotSubscribed</i>- The CustomerIdentifier specified is
    ///                     not subscribed to your product. The UsageRecord was not honored. Future
    ///                     UsageRecords for this customer will fail until the customer subscribes to your
    ///                     product.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <i>DuplicateRecord</i>- Indicates that the UsageRecord was invalid
    ///                     and not honored. A previously metered UsageRecord had the same customer,
    ///                     dimension, and time, but a different quantity.</p>
    ///             </li>
    ///          </ul>
    public let status: UsageRecordResultStatus?
    /// <p>The UsageRecord that was part of the BatchMeterUsage request.</p>
    public let usageRecord: UsageRecord?

    public init (
        meteringRecordId: String? = nil,
        status: UsageRecordResultStatus? = nil,
        usageRecord: UsageRecord? = nil
    )
    {
        self.meteringRecordId = meteringRecordId
        self.status = status
        self.usageRecord = usageRecord
    }
}

public enum UsageRecordResultStatus {
    case customerNotSubscribed
    case duplicateRecord
    case success
    case sdkUnknown(String)
}

extension UsageRecordResultStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UsageRecordResultStatus] {
        return [
            .customerNotSubscribed,
            .duplicateRecord,
            .success,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .customerNotSubscribed: return "CustomerNotSubscribed"
        case .duplicateRecord: return "DuplicateRecord"
        case .success: return "Success"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UsageRecordResultStatus(rawValue: rawValue) ?? UsageRecordResultStatus.sdkUnknown(rawValue)
    }
}
