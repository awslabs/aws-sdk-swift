// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateEventIntegrationInputBodyMiddleware: Middleware {
    public let id: String = "CreateEventIntegrationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventIntegrationInput>
    public typealias MOutput = OperationOutput<CreateEventIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventIntegrationOutputError>
}

extension CreateEventIntegrationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEventIntegrationInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), eventBridgeBus: \(String(describing: eventBridgeBus)), eventFilter: \(String(describing: eventFilter)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateEventIntegrationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case eventBridgeBus = "EventBridgeBus"
        case eventFilter = "EventFilter"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventBridgeBus = eventBridgeBus {
            try encodeContainer.encode(eventBridgeBus, forKey: .eventBridgeBus)
        }
        if let eventFilter = eventFilter {
            try encodeContainer.encode(eventFilter, forKey: .eventFilter)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateEventIntegrationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateEventIntegrationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventIntegrationInput>
    public typealias MOutput = OperationOutput<CreateEventIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventIntegrationOutputError>
}

public struct CreateEventIntegrationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEventIntegrationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventIntegrationInput>
    public typealias MOutput = OperationOutput<CreateEventIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventIntegrationOutputError>
}

public struct CreateEventIntegrationInput: Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///       request.</p>
    public var clientToken: String?
    /// <p>The description of the event integration.</p>
    public let description: String?
    /// <p>The Eventbridge bus.</p>
    public let eventBridgeBus: String?
    /// <p>The event filter.</p>
    public let eventFilter: EventFilter?
    /// <p>The name of the event integration.</p>
    public let name: String?
    /// <p>One or more tags.</p>
    public let tags: [String:String]?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        eventBridgeBus: String? = nil,
        eventFilter: EventFilter? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.eventBridgeBus = eventBridgeBus
        self.eventFilter = eventFilter
        self.name = name
        self.tags = tags
    }
}

struct CreateEventIntegrationInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let eventFilter: EventFilter?
    public let eventBridgeBus: String?
    public let clientToken: String?
    public let tags: [String:String]?
}

extension CreateEventIntegrationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case eventBridgeBus = "EventBridgeBus"
        case eventFilter = "EventFilter"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let eventFilterDecoded = try containerValues.decodeIfPresent(EventFilter.self, forKey: .eventFilter)
        eventFilter = eventFilterDecoded
        let eventBridgeBusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventBridgeBus)
        eventBridgeBus = eventBridgeBusDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEventIntegrationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEventIntegrationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededException" : self = .resourceQuotaExceededException(try ResourceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEventIntegrationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceQuotaExceededException(ResourceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEventIntegrationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEventIntegrationOutputResponse(eventIntegrationArn: \(String(describing: eventIntegrationArn)))"}
}

extension CreateEventIntegrationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateEventIntegrationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventIntegrationArn = output.eventIntegrationArn
        } else {
            self.eventIntegrationArn = nil
        }
    }
}

public struct CreateEventIntegrationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the event integration. </p>
    public let eventIntegrationArn: String?

    public init (
        eventIntegrationArn: String? = nil
    )
    {
        self.eventIntegrationArn = eventIntegrationArn
    }
}

struct CreateEventIntegrationOutputResponseBody: Equatable {
    public let eventIntegrationArn: String?
}

extension CreateEventIntegrationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventIntegrationArn = "EventIntegrationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIntegrationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventIntegrationArn)
        eventIntegrationArn = eventIntegrationArnDecoded
    }
}

extension DeleteEventIntegrationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEventIntegrationInput(name: \(String(describing: name)))"}
}

extension DeleteEventIntegrationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteEventIntegrationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEventIntegrationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventIntegrationInput>
    public typealias MOutput = OperationOutput<DeleteEventIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventIntegrationOutputError>
}

public struct DeleteEventIntegrationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEventIntegrationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventIntegrationInput>
    public typealias MOutput = OperationOutput<DeleteEventIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventIntegrationOutputError>
}

public struct DeleteEventIntegrationInput: Equatable {
    /// <p>The name of the event integration.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteEventIntegrationInputBody: Equatable {
}

extension DeleteEventIntegrationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteEventIntegrationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEventIntegrationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventIntegrationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventIntegrationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEventIntegrationOutputResponse()"}
}

extension DeleteEventIntegrationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEventIntegrationOutputResponse: Equatable {

    public init() {}
}

struct DeleteEventIntegrationOutputResponseBody: Equatable {
}

extension DeleteEventIntegrationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DuplicateResourceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicateResourceException(message: \(String(describing: message)))"}
}

extension DuplicateResourceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DuplicateResourceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource with the specified name already exists.</p>
public struct DuplicateResourceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateResourceExceptionBody: Equatable {
    public let message: String?
}

extension DuplicateResourceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EventFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case source = "Source"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
    }
}

extension EventFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventFilter(source: \(String(describing: source)))"}
}

/// <p>The Amazon AppIntegrations APIs are in preview release and are subject to change.</p>
///          <p>The event filter.</p>
public struct EventFilter: Equatable {
    /// <p>The source of the events.</p>
    public let source: String?

    public init (
        source: String? = nil
    )
    {
        self.source = source
    }
}

extension EventIntegration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case eventBridgeBus = "EventBridgeBus"
        case eventFilter = "EventFilter"
        case eventIntegrationArn = "EventIntegrationArn"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventBridgeBus = eventBridgeBus {
            try encodeContainer.encode(eventBridgeBus, forKey: .eventBridgeBus)
        }
        if let eventFilter = eventFilter {
            try encodeContainer.encode(eventFilter, forKey: .eventFilter)
        }
        if let eventIntegrationArn = eventIntegrationArn {
            try encodeContainer.encode(eventIntegrationArn, forKey: .eventIntegrationArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIntegrationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventIntegrationArn)
        eventIntegrationArn = eventIntegrationArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let eventFilterDecoded = try containerValues.decodeIfPresent(EventFilter.self, forKey: .eventFilter)
        eventFilter = eventFilterDecoded
        let eventBridgeBusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventBridgeBus)
        eventBridgeBus = eventBridgeBusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EventIntegration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventIntegration(description: \(String(describing: description)), eventBridgeBus: \(String(describing: eventBridgeBus)), eventFilter: \(String(describing: eventFilter)), eventIntegrationArn: \(String(describing: eventIntegrationArn)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

/// <p>The Amazon AppIntegrations APIs are in preview release and are subject to change.</p>
///          <p>The event integration.</p>
public struct EventIntegration: Equatable {
    /// <p>The event integration description.</p>
    public let description: String?
    /// <p>The Amazon Eventbridge bus for the event integration.</p>
    public let eventBridgeBus: String?
    /// <p>The event integration filter.</p>
    public let eventFilter: EventFilter?
    /// <p>The Amazon Resource Name (ARN) of the event integration.</p>
    public let eventIntegrationArn: String?
    /// <p>The name of the event integration.</p>
    public let name: String?
    /// <p>The tags.</p>
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        eventBridgeBus: String? = nil,
        eventFilter: EventFilter? = nil,
        eventIntegrationArn: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.eventBridgeBus = eventBridgeBus
        self.eventFilter = eventFilter
        self.eventIntegrationArn = eventIntegrationArn
        self.name = name
        self.tags = tags
    }
}

extension EventIntegrationAssociation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientAssociationMetadata = "ClientAssociationMetadata"
        case clientId = "ClientId"
        case eventBridgeRuleName = "EventBridgeRuleName"
        case eventIntegrationAssociationArn = "EventIntegrationAssociationArn"
        case eventIntegrationAssociationId = "EventIntegrationAssociationId"
        case eventIntegrationName = "EventIntegrationName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientAssociationMetadata = clientAssociationMetadata {
            var clientAssociationMetadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .clientAssociationMetadata)
            for (dictKey0, clientassociationmetadata0) in clientAssociationMetadata {
                try clientAssociationMetadataContainer.encode(clientassociationmetadata0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let eventBridgeRuleName = eventBridgeRuleName {
            try encodeContainer.encode(eventBridgeRuleName, forKey: .eventBridgeRuleName)
        }
        if let eventIntegrationAssociationArn = eventIntegrationAssociationArn {
            try encodeContainer.encode(eventIntegrationAssociationArn, forKey: .eventIntegrationAssociationArn)
        }
        if let eventIntegrationAssociationId = eventIntegrationAssociationId {
            try encodeContainer.encode(eventIntegrationAssociationId, forKey: .eventIntegrationAssociationId)
        }
        if let eventIntegrationName = eventIntegrationName {
            try encodeContainer.encode(eventIntegrationName, forKey: .eventIntegrationName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIntegrationAssociationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventIntegrationAssociationArn)
        eventIntegrationAssociationArn = eventIntegrationAssociationArnDecoded
        let eventIntegrationAssociationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventIntegrationAssociationId)
        eventIntegrationAssociationId = eventIntegrationAssociationIdDecoded
        let eventIntegrationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventIntegrationName)
        eventIntegrationName = eventIntegrationNameDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let eventBridgeRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventBridgeRuleName)
        eventBridgeRuleName = eventBridgeRuleNameDecoded
        let clientAssociationMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .clientAssociationMetadata)
        var clientAssociationMetadataDecoded0: [String:String]? = nil
        if let clientAssociationMetadataContainer = clientAssociationMetadataContainer {
            clientAssociationMetadataDecoded0 = [String:String]()
            for (key0, nonblankstring0) in clientAssociationMetadataContainer {
                if let nonblankstring0 = nonblankstring0 {
                    clientAssociationMetadataDecoded0?[key0] = nonblankstring0
                }
            }
        }
        clientAssociationMetadata = clientAssociationMetadataDecoded0
    }
}

extension EventIntegrationAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventIntegrationAssociation(clientAssociationMetadata: \(String(describing: clientAssociationMetadata)), clientId: \(String(describing: clientId)), eventBridgeRuleName: \(String(describing: eventBridgeRuleName)), eventIntegrationAssociationArn: \(String(describing: eventIntegrationAssociationArn)), eventIntegrationAssociationId: \(String(describing: eventIntegrationAssociationId)), eventIntegrationName: \(String(describing: eventIntegrationName)))"}
}

/// <p>The Amazon AppIntegrations APIs are in preview release and are subject to change.</p>
///          <p>The event integration association.</p>
public struct EventIntegrationAssociation: Equatable {
    /// <p>The metadata associated with the client.</p>
    public let clientAssociationMetadata: [String:String]?
    /// <p>The identifier for the client that is associated with the event integration.</p>
    public let clientId: String?
    /// <p>The name of the Eventbridge rule.</p>
    public let eventBridgeRuleName: String?
    /// <p>The Amazon Resource Name (ARN) for the event integration association.</p>
    public let eventIntegrationAssociationArn: String?
    /// <p>The identifier for the event integration association.</p>
    public let eventIntegrationAssociationId: String?
    /// <p>The name of the event integration.</p>
    public let eventIntegrationName: String?

    public init (
        clientAssociationMetadata: [String:String]? = nil,
        clientId: String? = nil,
        eventBridgeRuleName: String? = nil,
        eventIntegrationAssociationArn: String? = nil,
        eventIntegrationAssociationId: String? = nil,
        eventIntegrationName: String? = nil
    )
    {
        self.clientAssociationMetadata = clientAssociationMetadata
        self.clientId = clientId
        self.eventBridgeRuleName = eventBridgeRuleName
        self.eventIntegrationAssociationArn = eventIntegrationAssociationArn
        self.eventIntegrationAssociationId = eventIntegrationAssociationId
        self.eventIntegrationName = eventIntegrationName
    }
}

extension GetEventIntegrationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEventIntegrationInput(name: \(String(describing: name)))"}
}

extension GetEventIntegrationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetEventIntegrationInputHeadersMiddleware: Middleware {
    public let id: String = "GetEventIntegrationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEventIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEventIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEventIntegrationInput>
    public typealias MOutput = OperationOutput<GetEventIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEventIntegrationOutputError>
}

public struct GetEventIntegrationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEventIntegrationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEventIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEventIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEventIntegrationInput>
    public typealias MOutput = OperationOutput<GetEventIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEventIntegrationOutputError>
}

public struct GetEventIntegrationInput: Equatable {
    /// <p>The name of the event integration. </p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct GetEventIntegrationInputBody: Equatable {
}

extension GetEventIntegrationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetEventIntegrationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEventIntegrationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEventIntegrationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEventIntegrationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEventIntegrationOutputResponse(description: \(String(describing: description)), eventBridgeBus: \(String(describing: eventBridgeBus)), eventFilter: \(String(describing: eventFilter)), eventIntegrationArn: \(String(describing: eventIntegrationArn)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension GetEventIntegrationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEventIntegrationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.eventBridgeBus = output.eventBridgeBus
            self.eventFilter = output.eventFilter
            self.eventIntegrationArn = output.eventIntegrationArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.description = nil
            self.eventBridgeBus = nil
            self.eventFilter = nil
            self.eventIntegrationArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetEventIntegrationOutputResponse: Equatable {
    /// <p>The description of the event integration.</p>
    public let description: String?
    /// <p>The Eventbridge bus.</p>
    public let eventBridgeBus: String?
    /// <p>The event filter.</p>
    public let eventFilter: EventFilter?
    /// <p>The Amazon Resource Name (ARN) for the event integration.</p>
    public let eventIntegrationArn: String?
    /// <p>The name of the event integration. </p>
    public let name: String?
    /// <p>One or more tags.</p>
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        eventBridgeBus: String? = nil,
        eventFilter: EventFilter? = nil,
        eventIntegrationArn: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.eventBridgeBus = eventBridgeBus
        self.eventFilter = eventFilter
        self.eventIntegrationArn = eventIntegrationArn
        self.name = name
        self.tags = tags
    }
}

struct GetEventIntegrationOutputResponseBody: Equatable {
    public let name: String?
    public let description: String?
    public let eventIntegrationArn: String?
    public let eventBridgeBus: String?
    public let eventFilter: EventFilter?
    public let tags: [String:String]?
}

extension GetEventIntegrationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case eventBridgeBus = "EventBridgeBus"
        case eventFilter = "EventFilter"
        case eventIntegrationArn = "EventIntegrationArn"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let eventIntegrationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventIntegrationArn)
        eventIntegrationArn = eventIntegrationArnDecoded
        let eventBridgeBusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventBridgeBus)
        eventBridgeBus = eventBridgeBusDecoded
        let eventFilterDecoded = try containerValues.decodeIfPresent(EventFilter.self, forKey: .eventFilter)
        eventFilter = eventFilterDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension InternalServiceError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceError(message: \(String(describing: message)))"}
}

extension InternalServiceError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServiceErrorBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request processing failed due to an error or failure with the service.</p>
public struct InternalServiceError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorBody: Equatable {
    public let message: String?
}

extension InternalServiceErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request is not valid.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListEventIntegrationAssociationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEventIntegrationAssociationsInput(eventIntegrationName: \(String(describing: eventIntegrationName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEventIntegrationAssociationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListEventIntegrationAssociationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListEventIntegrationAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventIntegrationAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventIntegrationAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventIntegrationAssociationsInput>
    public typealias MOutput = OperationOutput<ListEventIntegrationAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventIntegrationAssociationsOutputError>
}

public struct ListEventIntegrationAssociationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEventIntegrationAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventIntegrationAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventIntegrationAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventIntegrationAssociationsInput>
    public typealias MOutput = OperationOutput<ListEventIntegrationAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventIntegrationAssociationsOutputError>
}

public struct ListEventIntegrationAssociationsInput: Equatable {
    /// <p>The name of the event integration. </p>
    public let eventIntegrationName: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        eventIntegrationName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.eventIntegrationName = eventIntegrationName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEventIntegrationAssociationsInputBody: Equatable {
}

extension ListEventIntegrationAssociationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListEventIntegrationAssociationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventIntegrationAssociationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEventIntegrationAssociationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventIntegrationAssociationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEventIntegrationAssociationsOutputResponse(eventIntegrationAssociations: \(String(describing: eventIntegrationAssociations)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEventIntegrationAssociationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEventIntegrationAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventIntegrationAssociations = output.eventIntegrationAssociations
            self.nextToken = output.nextToken
        } else {
            self.eventIntegrationAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventIntegrationAssociationsOutputResponse: Equatable {
    /// <p>The event integration associations.</p>
    public let eventIntegrationAssociations: [EventIntegrationAssociation]?
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?

    public init (
        eventIntegrationAssociations: [EventIntegrationAssociation]? = nil,
        nextToken: String? = nil
    )
    {
        self.eventIntegrationAssociations = eventIntegrationAssociations
        self.nextToken = nextToken
    }
}

struct ListEventIntegrationAssociationsOutputResponseBody: Equatable {
    public let eventIntegrationAssociations: [EventIntegrationAssociation]?
    public let nextToken: String?
}

extension ListEventIntegrationAssociationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventIntegrationAssociations = "EventIntegrationAssociations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIntegrationAssociationsContainer = try containerValues.decodeIfPresent([EventIntegrationAssociation?].self, forKey: .eventIntegrationAssociations)
        var eventIntegrationAssociationsDecoded0:[EventIntegrationAssociation]? = nil
        if let eventIntegrationAssociationsContainer = eventIntegrationAssociationsContainer {
            eventIntegrationAssociationsDecoded0 = [EventIntegrationAssociation]()
            for structure0 in eventIntegrationAssociationsContainer {
                if let structure0 = structure0 {
                    eventIntegrationAssociationsDecoded0?.append(structure0)
                }
            }
        }
        eventIntegrationAssociations = eventIntegrationAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEventIntegrationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEventIntegrationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEventIntegrationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListEventIntegrationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListEventIntegrationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventIntegrationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventIntegrationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventIntegrationsInput>
    public typealias MOutput = OperationOutput<ListEventIntegrationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventIntegrationsOutputError>
}

public struct ListEventIntegrationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEventIntegrationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventIntegrationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventIntegrationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventIntegrationsInput>
    public typealias MOutput = OperationOutput<ListEventIntegrationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventIntegrationsOutputError>
}

public struct ListEventIntegrationsInput: Equatable {
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEventIntegrationsInputBody: Equatable {
}

extension ListEventIntegrationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListEventIntegrationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventIntegrationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEventIntegrationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventIntegrationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEventIntegrationsOutputResponse(eventIntegrations: \(String(describing: eventIntegrations)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEventIntegrationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEventIntegrationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventIntegrations = output.eventIntegrations
            self.nextToken = output.nextToken
        } else {
            self.eventIntegrations = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventIntegrationsOutputResponse: Equatable {
    /// <p>The event integrations.</p>
    public let eventIntegrations: [EventIntegration]?
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?

    public init (
        eventIntegrations: [EventIntegration]? = nil,
        nextToken: String? = nil
    )
    {
        self.eventIntegrations = eventIntegrations
        self.nextToken = nextToken
    }
}

struct ListEventIntegrationsOutputResponseBody: Equatable {
    public let eventIntegrations: [EventIntegration]?
    public let nextToken: String?
}

extension ListEventIntegrationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventIntegrations = "EventIntegrations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIntegrationsContainer = try containerValues.decodeIfPresent([EventIntegration?].self, forKey: .eventIntegrations)
        var eventIntegrationsDecoded0:[EventIntegration]? = nil
        if let eventIntegrationsContainer = eventIntegrationsContainer {
            eventIntegrationsDecoded0 = [EventIntegration]()
            for structure0 in eventIntegrationsContainer {
                if let structure0 = structure0 {
                    eventIntegrationsDecoded0?.append(structure0)
                }
            }
        }
        eventIntegrations = eventIntegrationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource. </p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>Information about the tags.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ResourceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The allowed quota for the resource has been exceeded.</p>
public struct ResourceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ResourceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>One or more tags. </p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The throttling limit has been exceeded.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>The tag keys.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateEventIntegrationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateEventIntegrationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEventIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEventIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEventIntegrationInput>
    public typealias MOutput = OperationOutput<UpdateEventIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEventIntegrationOutputError>
}

extension UpdateEventIntegrationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEventIntegrationInput(description: \(String(describing: description)), name: \(String(describing: name)))"}
}

extension UpdateEventIntegrationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

public struct UpdateEventIntegrationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateEventIntegrationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEventIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEventIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEventIntegrationInput>
    public typealias MOutput = OperationOutput<UpdateEventIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEventIntegrationOutputError>
}

public struct UpdateEventIntegrationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateEventIntegrationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEventIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEventIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEventIntegrationInput>
    public typealias MOutput = OperationOutput<UpdateEventIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEventIntegrationOutputError>
}

public struct UpdateEventIntegrationInput: Equatable {
    /// <p>The description of the event inegration.</p>
    public let description: String?
    /// <p>The name of the event integration.</p>
    public let name: String?

    public init (
        description: String? = nil,
        name: String? = nil
    )
    {
        self.description = description
        self.name = name
    }
}

struct UpdateEventIntegrationInputBody: Equatable {
    public let description: String?
}

extension UpdateEventIntegrationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateEventIntegrationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEventIntegrationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEventIntegrationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEventIntegrationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEventIntegrationOutputResponse()"}
}

extension UpdateEventIntegrationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateEventIntegrationOutputResponse: Equatable {

    public init() {}
}

struct UpdateEventIntegrationOutputResponseBody: Equatable {
}

extension UpdateEventIntegrationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}
