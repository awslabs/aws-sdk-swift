// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AddTagsToResourceInputBodyMiddleware: Middleware {
    public let id: String = "AddTagsToResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToResourceOutputError>
}

extension AddTagsToResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsToResourceInput(resourceArn: \(String(describing: resourceArn)), tagList: \(String(describing: tagList)))"}
}

extension AddTagsToResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagList = "TagList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for taglist0 in tagList {
                try tagListContainer.encode(taglist0)
            }
        }
    }
}

public struct AddTagsToResourceInputHeadersMiddleware: Middleware {
    public let id: String = "AddTagsToResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "AddTagsToResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS CloudHSM resource to tag.</p>
    public let resourceArn: String?
    /// <p>One or more tags.</p>
    public let tagList: [Tag]?

    public init (
        resourceArn: String? = nil,
        tagList: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagList = tagList
    }
}

struct AddTagsToResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagList: [Tag]?
}

extension AddTagsToResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagList = "TagList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagList)
        var tagListDecoded0:[Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension AddTagsToResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddTagsToResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsToResourceOutputError: Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsToResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsToResourceOutputResponse(status: \(String(describing: status)))"}
}

extension AddTagsToResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddTagsToResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct AddTagsToResourceOutputResponse: Equatable {
    /// <p>The status of the operation.</p>
    public let status: String?

    public init (
        status: String? = nil
    )
    {
        self.status = status
    }
}

struct AddTagsToResourceOutputResponseBody: Equatable {
    public let status: String?
}

extension AddTagsToResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

public enum ClientVersion {
    case fiveOne
    case fiveThree
    case sdkUnknown(String)
}

extension ClientVersion : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ClientVersion] {
        return [
            .fiveOne,
            .fiveThree,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fiveOne: return "5.1"
        case .fiveThree: return "5.3"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ClientVersion(rawValue: rawValue) ?? ClientVersion.sdkUnknown(rawValue)
    }
}

extension CloudHsmInternalException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudHsmInternalException(message: \(String(describing: message)), retryable: \(String(describing: retryable)))"}
}

extension CloudHsmInternalException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CloudHsmInternalExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.retryable = output.retryable
        } else {
            self.message = nil
            self.retryable = false
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that an internal error occurred.</p>
public struct CloudHsmInternalException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>Additional information about the error.</p>
    public var message: String?
    /// <p>Indicates if the action can be retried.</p>
    public var retryable: Bool

    public init (
        message: String? = nil,
        retryable: Bool = false
    )
    {
        self.message = message
        self.retryable = retryable
    }
}

struct CloudHsmInternalExceptionBody: Equatable {
    public let message: String?
    public let retryable: Bool
}

extension CloudHsmInternalExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case retryable
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let retryableDecoded = try containerValues.decode(Bool.self, forKey: .retryable)
        retryable = retryableDecoded
    }
}

public enum CloudHsmObjectState {
    case degraded
    case ready
    case updating
    case sdkUnknown(String)
}

extension CloudHsmObjectState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CloudHsmObjectState] {
        return [
            .degraded,
            .ready,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .degraded: return "DEGRADED"
        case .ready: return "READY"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CloudHsmObjectState(rawValue: rawValue) ?? CloudHsmObjectState.sdkUnknown(rawValue)
    }
}

extension CloudHsmServiceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudHsmServiceException(message: \(String(describing: message)), retryable: \(String(describing: retryable)))"}
}

extension CloudHsmServiceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CloudHsmServiceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.retryable = output.retryable
        } else {
            self.message = nil
            self.retryable = false
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that an exception occurred in the AWS CloudHSM service.</p>
public struct CloudHsmServiceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Additional information about the error.</p>
    public var message: String?
    /// <p>Indicates if the action can be retried.</p>
    public var retryable: Bool

    public init (
        message: String? = nil,
        retryable: Bool = false
    )
    {
        self.message = message
        self.retryable = retryable
    }
}

struct CloudHsmServiceExceptionBody: Equatable {
    public let message: String?
    public let retryable: Bool
}

extension CloudHsmServiceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case retryable
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let retryableDecoded = try containerValues.decode(Bool.self, forKey: .retryable)
        retryable = retryableDecoded
    }
}

public struct CreateHapgInputBodyMiddleware: Middleware {
    public let id: String = "CreateHapgInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHapgInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHapgInput>
    public typealias MOutput = OperationOutput<CreateHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHapgOutputError>
}

extension CreateHapgInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHapgInput(label: \(String(describing: label)))"}
}

extension CreateHapgInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case label = "Label"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let label = label {
            try encodeContainer.encode(label, forKey: .label)
        }
    }
}

public struct CreateHapgInputHeadersMiddleware: Middleware {
    public let id: String = "CreateHapgInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHapgInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHapgInput>
    public typealias MOutput = OperationOutput<CreateHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHapgOutputError>
}

public struct CreateHapgInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateHapgInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHapgInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHapgInput>
    public typealias MOutput = OperationOutput<CreateHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHapgOutputError>
}

/// <p>Contains the inputs for the <a>CreateHapgRequest</a> action.</p>
public struct CreateHapgInput: Equatable {
    /// <p>The label of the new high-availability partition group.</p>
    public let label: String?

    public init (
        label: String? = nil
    )
    {
        self.label = label
    }
}

struct CreateHapgInputBody: Equatable {
    public let label: String?
}

extension CreateHapgInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case label = "Label"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .label)
        label = labelDecoded
    }
}

extension CreateHapgOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHapgOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHapgOutputError: Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHapgOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHapgOutputResponse(hapgArn: \(String(describing: hapgArn)))"}
}

extension CreateHapgOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateHapgOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hapgArn = output.hapgArn
        } else {
            self.hapgArn = nil
        }
    }
}

/// <p>Contains the output of the <a>CreateHAPartitionGroup</a> action.</p>
public struct CreateHapgOutputResponse: Equatable {
    /// <p>The ARN of the high-availability partition group.</p>
    public let hapgArn: String?

    public init (
        hapgArn: String? = nil
    )
    {
        self.hapgArn = hapgArn
    }
}

struct CreateHapgOutputResponseBody: Equatable {
    public let hapgArn: String?
}

extension CreateHapgOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hapgArn = "HapgArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
    }
}

public struct CreateHsmInputBodyMiddleware: Middleware {
    public let id: String = "CreateHsmInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHsmInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHsmInput>
    public typealias MOutput = OperationOutput<CreateHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHsmOutputError>
}

extension CreateHsmInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHsmInput(clientToken: \(String(describing: clientToken)), eniIp: \(String(describing: eniIp)), externalId: \(String(describing: externalId)), iamRoleArn: \(String(describing: iamRoleArn)), sshKey: \(String(describing: sshKey)), subnetId: \(String(describing: subnetId)), subscriptionType: \(String(describing: subscriptionType)), syslogIp: \(String(describing: syslogIp)))"}
}

extension CreateHsmInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case eniIp = "EniIp"
        case externalId = "ExternalId"
        case iamRoleArn = "IamRoleArn"
        case sshKey = "SshKey"
        case subnetId = "SubnetId"
        case subscriptionType = "SubscriptionType"
        case syslogIp = "SyslogIp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let eniIp = eniIp {
            try encodeContainer.encode(eniIp, forKey: .eniIp)
        }
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let sshKey = sshKey {
            try encodeContainer.encode(sshKey, forKey: .sshKey)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let subscriptionType = subscriptionType {
            try encodeContainer.encode(subscriptionType.rawValue, forKey: .subscriptionType)
        }
        if let syslogIp = syslogIp {
            try encodeContainer.encode(syslogIp, forKey: .syslogIp)
        }
    }
}

public struct CreateHsmInputHeadersMiddleware: Middleware {
    public let id: String = "CreateHsmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHsmInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHsmInput>
    public typealias MOutput = OperationOutput<CreateHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHsmOutputError>
}

public struct CreateHsmInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateHsmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHsmInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHsmInput>
    public typealias MOutput = OperationOutput<CreateHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHsmOutputError>
}

/// <p>Contains the inputs for the <code>CreateHsm</code> operation.</p>
public struct CreateHsmInput: Equatable {
    /// <p>A user-defined token to ensure idempotence. Subsequent calls to this operation with the
    ///       same token will be ignored.</p>
    public let clientToken: String?
    /// <p>The IP address to assign to the HSM's ENI.</p>
    ///          <p>If an IP address is not specified, an IP address will be randomly chosen from the CIDR
    ///       range of the subnet.</p>
    public let eniIp: String?
    /// <p>The external ID from <code>IamRoleArn</code>, if present.</p>
    public let externalId: String?
    /// <p>The ARN of an IAM role to enable the AWS CloudHSM service to allocate an ENI on your
    ///       behalf.</p>
    public let iamRoleArn: String?
    /// <p>The SSH public key to install on the HSM.</p>
    public let sshKey: String?
    /// <p>The identifier of the subnet in your VPC in which to place the HSM.</p>
    public let subnetId: String?
    /// <p>Specifies the type of subscription for the HSM.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>PRODUCTION</b> - The HSM is being used in a production
    ///           environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>TRIAL</b> - The HSM is being used in a product
    ///           trial.</p>
    ///             </li>
    ///          </ul>
    public let subscriptionType: SubscriptionType?
    /// <p>The IP address for the syslog monitoring server. The AWS CloudHSM service only supports one
    ///       syslog monitoring server.</p>
    public let syslogIp: String?

    public init (
        clientToken: String? = nil,
        eniIp: String? = nil,
        externalId: String? = nil,
        iamRoleArn: String? = nil,
        sshKey: String? = nil,
        subnetId: String? = nil,
        subscriptionType: SubscriptionType? = nil,
        syslogIp: String? = nil
    )
    {
        self.clientToken = clientToken
        self.eniIp = eniIp
        self.externalId = externalId
        self.iamRoleArn = iamRoleArn
        self.sshKey = sshKey
        self.subnetId = subnetId
        self.subscriptionType = subscriptionType
        self.syslogIp = syslogIp
    }
}

struct CreateHsmInputBody: Equatable {
    public let subnetId: String?
    public let sshKey: String?
    public let eniIp: String?
    public let iamRoleArn: String?
    public let externalId: String?
    public let subscriptionType: SubscriptionType?
    public let clientToken: String?
    public let syslogIp: String?
}

extension CreateHsmInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case eniIp = "EniIp"
        case externalId = "ExternalId"
        case iamRoleArn = "IamRoleArn"
        case sshKey = "SshKey"
        case subnetId = "SubnetId"
        case subscriptionType = "SubscriptionType"
        case syslogIp = "SyslogIp"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let sshKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshKey)
        sshKey = sshKeyDecoded
        let eniIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eniIp)
        eniIp = eniIpDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let subscriptionTypeDecoded = try containerValues.decodeIfPresent(SubscriptionType.self, forKey: .subscriptionType)
        subscriptionType = subscriptionTypeDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let syslogIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .syslogIp)
        syslogIp = syslogIpDecoded
    }
}

extension CreateHsmOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHsmOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHsmOutputError: Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHsmOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHsmOutputResponse(hsmArn: \(String(describing: hsmArn)))"}
}

extension CreateHsmOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateHsmOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hsmArn = output.hsmArn
        } else {
            self.hsmArn = nil
        }
    }
}

/// <p>Contains the output of the <code>CreateHsm</code> operation.</p>
public struct CreateHsmOutputResponse: Equatable {
    /// <p>The ARN of the HSM.</p>
    public let hsmArn: String?

    public init (
        hsmArn: String? = nil
    )
    {
        self.hsmArn = hsmArn
    }
}

struct CreateHsmOutputResponseBody: Equatable {
    public let hsmArn: String?
}

extension CreateHsmOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hsmArn = "HsmArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
    }
}

public struct CreateLunaClientInputBodyMiddleware: Middleware {
    public let id: String = "CreateLunaClientInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLunaClientInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLunaClientInput>
    public typealias MOutput = OperationOutput<CreateLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLunaClientOutputError>
}

extension CreateLunaClientInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLunaClientInput(certificate: \(String(describing: certificate)), label: \(String(describing: label)))"}
}

extension CreateLunaClientInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
        case label = "Label"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let label = label {
            try encodeContainer.encode(label, forKey: .label)
        }
    }
}

public struct CreateLunaClientInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLunaClientInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLunaClientInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLunaClientInput>
    public typealias MOutput = OperationOutput<CreateLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLunaClientOutputError>
}

public struct CreateLunaClientInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLunaClientInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLunaClientInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLunaClientInput>
    public typealias MOutput = OperationOutput<CreateLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLunaClientOutputError>
}

/// <p>Contains the inputs for the <a>CreateLunaClient</a> action.</p>
public struct CreateLunaClientInput: Equatable {
    /// <p>The contents of a Base64-Encoded X.509 v3 certificate to be installed on the HSMs used
    ///       by this client.</p>
    public let certificate: String?
    /// <p>The label for the client.</p>
    public let label: String?

    public init (
        certificate: String? = nil,
        label: String? = nil
    )
    {
        self.certificate = certificate
        self.label = label
    }
}

struct CreateLunaClientInputBody: Equatable {
    public let label: String?
    public let certificate: String?
}

extension CreateLunaClientInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
        case label = "Label"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .label)
        label = labelDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

extension CreateLunaClientOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLunaClientOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLunaClientOutputError: Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLunaClientOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLunaClientOutputResponse(clientArn: \(String(describing: clientArn)))"}
}

extension CreateLunaClientOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateLunaClientOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientArn = output.clientArn
        } else {
            self.clientArn = nil
        }
    }
}

/// <p>Contains the output of the <a>CreateLunaClient</a> action.</p>
public struct CreateLunaClientOutputResponse: Equatable {
    /// <p>The ARN of the client.</p>
    public let clientArn: String?

    public init (
        clientArn: String? = nil
    )
    {
        self.clientArn = clientArn
    }
}

struct CreateLunaClientOutputResponseBody: Equatable {
    public let clientArn: String?
}

extension CreateLunaClientOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientArn = "ClientArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
    }
}

public struct DeleteHapgInputBodyMiddleware: Middleware {
    public let id: String = "DeleteHapgInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHapgInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHapgInput>
    public typealias MOutput = OperationOutput<DeleteHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHapgOutputError>
}

extension DeleteHapgInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteHapgInput(hapgArn: \(String(describing: hapgArn)))"}
}

extension DeleteHapgInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hapgArn = "HapgArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hapgArn = hapgArn {
            try encodeContainer.encode(hapgArn, forKey: .hapgArn)
        }
    }
}

public struct DeleteHapgInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteHapgInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHapgInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHapgInput>
    public typealias MOutput = OperationOutput<DeleteHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHapgOutputError>
}

public struct DeleteHapgInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteHapgInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHapgInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHapgInput>
    public typealias MOutput = OperationOutput<DeleteHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHapgOutputError>
}

/// <p>Contains the inputs for the <a>DeleteHapg</a> action.</p>
public struct DeleteHapgInput: Equatable {
    /// <p>The ARN of the high-availability partition group to delete.</p>
    public let hapgArn: String?

    public init (
        hapgArn: String? = nil
    )
    {
        self.hapgArn = hapgArn
    }
}

struct DeleteHapgInputBody: Equatable {
    public let hapgArn: String?
}

extension DeleteHapgInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hapgArn = "HapgArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
    }
}

extension DeleteHapgOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteHapgOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteHapgOutputError: Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteHapgOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteHapgOutputResponse(status: \(String(describing: status)))"}
}

extension DeleteHapgOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteHapgOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

/// <p>Contains the output of the <a>DeleteHapg</a> action.</p>
public struct DeleteHapgOutputResponse: Equatable {
    /// <p>The status of the action.</p>
    public let status: String?

    public init (
        status: String? = nil
    )
    {
        self.status = status
    }
}

struct DeleteHapgOutputResponseBody: Equatable {
    public let status: String?
}

extension DeleteHapgOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

public struct DeleteHsmInputBodyMiddleware: Middleware {
    public let id: String = "DeleteHsmInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHsmInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHsmInput>
    public typealias MOutput = OperationOutput<DeleteHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHsmOutputError>
}

extension DeleteHsmInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteHsmInput(hsmArn: \(String(describing: hsmArn)))"}
}

extension DeleteHsmInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hsmArn = "HsmArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hsmArn = hsmArn {
            try encodeContainer.encode(hsmArn, forKey: .hsmArn)
        }
    }
}

public struct DeleteHsmInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteHsmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHsmInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHsmInput>
    public typealias MOutput = OperationOutput<DeleteHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHsmOutputError>
}

public struct DeleteHsmInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteHsmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHsmInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHsmInput>
    public typealias MOutput = OperationOutput<DeleteHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHsmOutputError>
}

/// <p>Contains the inputs for the <a>DeleteHsm</a> operation.</p>
public struct DeleteHsmInput: Equatable {
    /// <p>The ARN of the HSM to delete.</p>
    public let hsmArn: String?

    public init (
        hsmArn: String? = nil
    )
    {
        self.hsmArn = hsmArn
    }
}

struct DeleteHsmInputBody: Equatable {
    public let hsmArn: String?
}

extension DeleteHsmInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hsmArn = "HsmArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
    }
}

extension DeleteHsmOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteHsmOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteHsmOutputError: Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteHsmOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteHsmOutputResponse(status: \(String(describing: status)))"}
}

extension DeleteHsmOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteHsmOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

/// <p>Contains the output of the <a>DeleteHsm</a> operation.</p>
public struct DeleteHsmOutputResponse: Equatable {
    /// <p>The status of the operation.</p>
    public let status: String?

    public init (
        status: String? = nil
    )
    {
        self.status = status
    }
}

struct DeleteHsmOutputResponseBody: Equatable {
    public let status: String?
}

extension DeleteHsmOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

public struct DeleteLunaClientInputBodyMiddleware: Middleware {
    public let id: String = "DeleteLunaClientInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLunaClientInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLunaClientInput>
    public typealias MOutput = OperationOutput<DeleteLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLunaClientOutputError>
}

extension DeleteLunaClientInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLunaClientInput(clientArn: \(String(describing: clientArn)))"}
}

extension DeleteLunaClientInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientArn = "ClientArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientArn = clientArn {
            try encodeContainer.encode(clientArn, forKey: .clientArn)
        }
    }
}

public struct DeleteLunaClientInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLunaClientInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLunaClientInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLunaClientInput>
    public typealias MOutput = OperationOutput<DeleteLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLunaClientOutputError>
}

public struct DeleteLunaClientInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLunaClientInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLunaClientInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLunaClientInput>
    public typealias MOutput = OperationOutput<DeleteLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLunaClientOutputError>
}

public struct DeleteLunaClientInput: Equatable {
    /// <p>The ARN of the client to delete.</p>
    public let clientArn: String?

    public init (
        clientArn: String? = nil
    )
    {
        self.clientArn = clientArn
    }
}

struct DeleteLunaClientInputBody: Equatable {
    public let clientArn: String?
}

extension DeleteLunaClientInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientArn = "ClientArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
    }
}

extension DeleteLunaClientOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLunaClientOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLunaClientOutputError: Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLunaClientOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLunaClientOutputResponse(status: \(String(describing: status)))"}
}

extension DeleteLunaClientOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteLunaClientOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct DeleteLunaClientOutputResponse: Equatable {
    /// <p>The status of the action.</p>
    public let status: String?

    public init (
        status: String? = nil
    )
    {
        self.status = status
    }
}

struct DeleteLunaClientOutputResponseBody: Equatable {
    public let status: String?
}

extension DeleteLunaClientOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

public struct DescribeHapgInputBodyMiddleware: Middleware {
    public let id: String = "DescribeHapgInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHapgInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHapgInput>
    public typealias MOutput = OperationOutput<DescribeHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHapgOutputError>
}

extension DescribeHapgInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeHapgInput(hapgArn: \(String(describing: hapgArn)))"}
}

extension DescribeHapgInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hapgArn = "HapgArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hapgArn = hapgArn {
            try encodeContainer.encode(hapgArn, forKey: .hapgArn)
        }
    }
}

public struct DescribeHapgInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeHapgInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHapgInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHapgInput>
    public typealias MOutput = OperationOutput<DescribeHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHapgOutputError>
}

public struct DescribeHapgInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeHapgInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHapgInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHapgInput>
    public typealias MOutput = OperationOutput<DescribeHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHapgOutputError>
}

/// <p>Contains the inputs for the <a>DescribeHapg</a> action.</p>
public struct DescribeHapgInput: Equatable {
    /// <p>The ARN of the high-availability partition group to describe.</p>
    public let hapgArn: String?

    public init (
        hapgArn: String? = nil
    )
    {
        self.hapgArn = hapgArn
    }
}

struct DescribeHapgInputBody: Equatable {
    public let hapgArn: String?
}

extension DescribeHapgInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hapgArn = "HapgArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
    }
}

extension DescribeHapgOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeHapgOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeHapgOutputError: Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHapgOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeHapgOutputResponse(hapgArn: \(String(describing: hapgArn)), hapgSerial: \(String(describing: hapgSerial)), hsmsLastActionFailed: \(String(describing: hsmsLastActionFailed)), hsmsPendingDeletion: \(String(describing: hsmsPendingDeletion)), hsmsPendingRegistration: \(String(describing: hsmsPendingRegistration)), label: \(String(describing: label)), lastModifiedTimestamp: \(String(describing: lastModifiedTimestamp)), partitionSerialList: \(String(describing: partitionSerialList)), state: \(String(describing: state)))"}
}

extension DescribeHapgOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeHapgOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hapgArn = output.hapgArn
            self.hapgSerial = output.hapgSerial
            self.hsmsLastActionFailed = output.hsmsLastActionFailed
            self.hsmsPendingDeletion = output.hsmsPendingDeletion
            self.hsmsPendingRegistration = output.hsmsPendingRegistration
            self.label = output.label
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.partitionSerialList = output.partitionSerialList
            self.state = output.state
        } else {
            self.hapgArn = nil
            self.hapgSerial = nil
            self.hsmsLastActionFailed = nil
            self.hsmsPendingDeletion = nil
            self.hsmsPendingRegistration = nil
            self.label = nil
            self.lastModifiedTimestamp = nil
            self.partitionSerialList = nil
            self.state = nil
        }
    }
}

/// <p>Contains the output of the <a>DescribeHapg</a> action.</p>
public struct DescribeHapgOutputResponse: Equatable {
    /// <p>The ARN of the high-availability partition group.</p>
    public let hapgArn: String?
    /// <p>The serial number of the high-availability partition group.</p>
    public let hapgSerial: String?
    /// <p></p>
    public let hsmsLastActionFailed: [String]?
    /// <p></p>
    public let hsmsPendingDeletion: [String]?
    /// <p></p>
    public let hsmsPendingRegistration: [String]?
    /// <p>The label for the high-availability partition group.</p>
    public let label: String?
    /// <p>The date and time the high-availability partition group was last modified.</p>
    public let lastModifiedTimestamp: String?
    /// <p>The list of partition serial numbers that belong to the high-availability partition
    ///       group.</p>
    public let partitionSerialList: [String]?
    /// <p>The state of the high-availability partition group.</p>
    public let state: CloudHsmObjectState?

    public init (
        hapgArn: String? = nil,
        hapgSerial: String? = nil,
        hsmsLastActionFailed: [String]? = nil,
        hsmsPendingDeletion: [String]? = nil,
        hsmsPendingRegistration: [String]? = nil,
        label: String? = nil,
        lastModifiedTimestamp: String? = nil,
        partitionSerialList: [String]? = nil,
        state: CloudHsmObjectState? = nil
    )
    {
        self.hapgArn = hapgArn
        self.hapgSerial = hapgSerial
        self.hsmsLastActionFailed = hsmsLastActionFailed
        self.hsmsPendingDeletion = hsmsPendingDeletion
        self.hsmsPendingRegistration = hsmsPendingRegistration
        self.label = label
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.partitionSerialList = partitionSerialList
        self.state = state
    }
}

struct DescribeHapgOutputResponseBody: Equatable {
    public let hapgArn: String?
    public let hapgSerial: String?
    public let hsmsLastActionFailed: [String]?
    public let hsmsPendingDeletion: [String]?
    public let hsmsPendingRegistration: [String]?
    public let label: String?
    public let lastModifiedTimestamp: String?
    public let partitionSerialList: [String]?
    public let state: CloudHsmObjectState?
}

extension DescribeHapgOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hapgArn = "HapgArn"
        case hapgSerial = "HapgSerial"
        case hsmsLastActionFailed = "HsmsLastActionFailed"
        case hsmsPendingDeletion = "HsmsPendingDeletion"
        case hsmsPendingRegistration = "HsmsPendingRegistration"
        case label = "Label"
        case lastModifiedTimestamp = "LastModifiedTimestamp"
        case partitionSerialList = "PartitionSerialList"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
        let hapgSerialDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hapgSerial)
        hapgSerial = hapgSerialDecoded
        let hsmsLastActionFailedContainer = try containerValues.decodeIfPresent([String?].self, forKey: .hsmsLastActionFailed)
        var hsmsLastActionFailedDecoded0:[String]? = nil
        if let hsmsLastActionFailedContainer = hsmsLastActionFailedContainer {
            hsmsLastActionFailedDecoded0 = [String]()
            for string0 in hsmsLastActionFailedContainer {
                if let string0 = string0 {
                    hsmsLastActionFailedDecoded0?.append(string0)
                }
            }
        }
        hsmsLastActionFailed = hsmsLastActionFailedDecoded0
        let hsmsPendingDeletionContainer = try containerValues.decodeIfPresent([String?].self, forKey: .hsmsPendingDeletion)
        var hsmsPendingDeletionDecoded0:[String]? = nil
        if let hsmsPendingDeletionContainer = hsmsPendingDeletionContainer {
            hsmsPendingDeletionDecoded0 = [String]()
            for string0 in hsmsPendingDeletionContainer {
                if let string0 = string0 {
                    hsmsPendingDeletionDecoded0?.append(string0)
                }
            }
        }
        hsmsPendingDeletion = hsmsPendingDeletionDecoded0
        let hsmsPendingRegistrationContainer = try containerValues.decodeIfPresent([String?].self, forKey: .hsmsPendingRegistration)
        var hsmsPendingRegistrationDecoded0:[String]? = nil
        if let hsmsPendingRegistrationContainer = hsmsPendingRegistrationContainer {
            hsmsPendingRegistrationDecoded0 = [String]()
            for string0 in hsmsPendingRegistrationContainer {
                if let string0 = string0 {
                    hsmsPendingRegistrationDecoded0?.append(string0)
                }
            }
        }
        hsmsPendingRegistration = hsmsPendingRegistrationDecoded0
        let labelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .label)
        label = labelDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let partitionSerialListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .partitionSerialList)
        var partitionSerialListDecoded0:[String]? = nil
        if let partitionSerialListContainer = partitionSerialListContainer {
            partitionSerialListDecoded0 = [String]()
            for string0 in partitionSerialListContainer {
                if let string0 = string0 {
                    partitionSerialListDecoded0?.append(string0)
                }
            }
        }
        partitionSerialList = partitionSerialListDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(CloudHsmObjectState.self, forKey: .state)
        state = stateDecoded
    }
}

public struct DescribeHsmInputBodyMiddleware: Middleware {
    public let id: String = "DescribeHsmInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHsmInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHsmInput>
    public typealias MOutput = OperationOutput<DescribeHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHsmOutputError>
}

extension DescribeHsmInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeHsmInput(hsmArn: \(String(describing: hsmArn)), hsmSerialNumber: \(String(describing: hsmSerialNumber)))"}
}

extension DescribeHsmInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hsmArn = "HsmArn"
        case hsmSerialNumber = "HsmSerialNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hsmArn = hsmArn {
            try encodeContainer.encode(hsmArn, forKey: .hsmArn)
        }
        if let hsmSerialNumber = hsmSerialNumber {
            try encodeContainer.encode(hsmSerialNumber, forKey: .hsmSerialNumber)
        }
    }
}

public struct DescribeHsmInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeHsmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHsmInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHsmInput>
    public typealias MOutput = OperationOutput<DescribeHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHsmOutputError>
}

public struct DescribeHsmInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeHsmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHsmInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHsmInput>
    public typealias MOutput = OperationOutput<DescribeHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHsmOutputError>
}

/// <p>Contains the inputs for the <a>DescribeHsm</a> operation.</p>
public struct DescribeHsmInput: Equatable {
    /// <p>The ARN of the HSM. Either the <code>HsmArn</code> or the <code>SerialNumber</code>
    ///       parameter must be specified.</p>
    public let hsmArn: String?
    /// <p>The serial number of the HSM. Either the <code>HsmArn</code> or the
    ///         <code>HsmSerialNumber</code> parameter must be specified.</p>
    public let hsmSerialNumber: String?

    public init (
        hsmArn: String? = nil,
        hsmSerialNumber: String? = nil
    )
    {
        self.hsmArn = hsmArn
        self.hsmSerialNumber = hsmSerialNumber
    }
}

struct DescribeHsmInputBody: Equatable {
    public let hsmArn: String?
    public let hsmSerialNumber: String?
}

extension DescribeHsmInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hsmArn = "HsmArn"
        case hsmSerialNumber = "HsmSerialNumber"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
        let hsmSerialNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hsmSerialNumber)
        hsmSerialNumber = hsmSerialNumberDecoded
    }
}

extension DescribeHsmOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeHsmOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeHsmOutputError: Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHsmOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeHsmOutputResponse(availabilityZone: \(String(describing: availabilityZone)), eniId: \(String(describing: eniId)), eniIp: \(String(describing: eniIp)), hsmArn: \(String(describing: hsmArn)), hsmType: \(String(describing: hsmType)), iamRoleArn: \(String(describing: iamRoleArn)), partitions: \(String(describing: partitions)), serialNumber: \(String(describing: serialNumber)), serverCertLastUpdated: \(String(describing: serverCertLastUpdated)), serverCertUri: \(String(describing: serverCertUri)), softwareVersion: \(String(describing: softwareVersion)), sshKeyLastUpdated: \(String(describing: sshKeyLastUpdated)), sshPublicKey: \(String(describing: sshPublicKey)), status: \(String(describing: status)), statusDetails: \(String(describing: statusDetails)), subnetId: \(String(describing: subnetId)), subscriptionEndDate: \(String(describing: subscriptionEndDate)), subscriptionStartDate: \(String(describing: subscriptionStartDate)), subscriptionType: \(String(describing: subscriptionType)), vendorName: \(String(describing: vendorName)), vpcId: \(String(describing: vpcId)))"}
}

extension DescribeHsmOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeHsmOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.availabilityZone = output.availabilityZone
            self.eniId = output.eniId
            self.eniIp = output.eniIp
            self.hsmArn = output.hsmArn
            self.hsmType = output.hsmType
            self.iamRoleArn = output.iamRoleArn
            self.partitions = output.partitions
            self.serialNumber = output.serialNumber
            self.serverCertLastUpdated = output.serverCertLastUpdated
            self.serverCertUri = output.serverCertUri
            self.softwareVersion = output.softwareVersion
            self.sshKeyLastUpdated = output.sshKeyLastUpdated
            self.sshPublicKey = output.sshPublicKey
            self.status = output.status
            self.statusDetails = output.statusDetails
            self.subnetId = output.subnetId
            self.subscriptionEndDate = output.subscriptionEndDate
            self.subscriptionStartDate = output.subscriptionStartDate
            self.subscriptionType = output.subscriptionType
            self.vendorName = output.vendorName
            self.vpcId = output.vpcId
        } else {
            self.availabilityZone = nil
            self.eniId = nil
            self.eniIp = nil
            self.hsmArn = nil
            self.hsmType = nil
            self.iamRoleArn = nil
            self.partitions = nil
            self.serialNumber = nil
            self.serverCertLastUpdated = nil
            self.serverCertUri = nil
            self.softwareVersion = nil
            self.sshKeyLastUpdated = nil
            self.sshPublicKey = nil
            self.status = nil
            self.statusDetails = nil
            self.subnetId = nil
            self.subscriptionEndDate = nil
            self.subscriptionStartDate = nil
            self.subscriptionType = nil
            self.vendorName = nil
            self.vpcId = nil
        }
    }
}

/// <p>Contains the output of the <a>DescribeHsm</a> operation.</p>
public struct DescribeHsmOutputResponse: Equatable {
    /// <p>The Availability Zone that the HSM is in.</p>
    public let availabilityZone: String?
    /// <p>The identifier of the elastic network interface (ENI) attached to the HSM.</p>
    public let eniId: String?
    /// <p>The IP address assigned to the HSM's ENI.</p>
    public let eniIp: String?
    /// <p>The ARN of the HSM.</p>
    public let hsmArn: String?
    /// <p>The HSM model type.</p>
    public let hsmType: String?
    /// <p>The ARN of the IAM role assigned to the HSM.</p>
    public let iamRoleArn: String?
    /// <p>The list of partitions on the HSM.</p>
    public let partitions: [String]?
    /// <p>The serial number of the HSM.</p>
    public let serialNumber: String?
    /// <p>The date and time that the server certificate was last updated.</p>
    public let serverCertLastUpdated: String?
    /// <p>The URI of the certificate server.</p>
    public let serverCertUri: String?
    /// <p>The HSM software version.</p>
    public let softwareVersion: String?
    /// <p>The date and time that the SSH key was last updated.</p>
    public let sshKeyLastUpdated: String?
    /// <p>The public SSH key.</p>
    public let sshPublicKey: String?
    /// <p>The status of the HSM.</p>
    public let status: HsmStatus?
    /// <p>Contains additional information about the status of the HSM.</p>
    public let statusDetails: String?
    /// <p>The identifier of the subnet that the HSM is in.</p>
    public let subnetId: String?
    /// <p>The subscription end date.</p>
    public let subscriptionEndDate: String?
    /// <p>The subscription start date.</p>
    public let subscriptionStartDate: String?
    /// <p>Specifies the type of subscription for the HSM.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>PRODUCTION</b> - The HSM is being used in a production
    ///           environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>TRIAL</b> - The HSM is being used in a product
    ///           trial.</p>
    ///             </li>
    ///          </ul>
    public let subscriptionType: SubscriptionType?
    /// <p>The name of the HSM vendor.</p>
    public let vendorName: String?
    /// <p>The identifier of the VPC that the HSM is in.</p>
    public let vpcId: String?

    public init (
        availabilityZone: String? = nil,
        eniId: String? = nil,
        eniIp: String? = nil,
        hsmArn: String? = nil,
        hsmType: String? = nil,
        iamRoleArn: String? = nil,
        partitions: [String]? = nil,
        serialNumber: String? = nil,
        serverCertLastUpdated: String? = nil,
        serverCertUri: String? = nil,
        softwareVersion: String? = nil,
        sshKeyLastUpdated: String? = nil,
        sshPublicKey: String? = nil,
        status: HsmStatus? = nil,
        statusDetails: String? = nil,
        subnetId: String? = nil,
        subscriptionEndDate: String? = nil,
        subscriptionStartDate: String? = nil,
        subscriptionType: SubscriptionType? = nil,
        vendorName: String? = nil,
        vpcId: String? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.eniId = eniId
        self.eniIp = eniIp
        self.hsmArn = hsmArn
        self.hsmType = hsmType
        self.iamRoleArn = iamRoleArn
        self.partitions = partitions
        self.serialNumber = serialNumber
        self.serverCertLastUpdated = serverCertLastUpdated
        self.serverCertUri = serverCertUri
        self.softwareVersion = softwareVersion
        self.sshKeyLastUpdated = sshKeyLastUpdated
        self.sshPublicKey = sshPublicKey
        self.status = status
        self.statusDetails = statusDetails
        self.subnetId = subnetId
        self.subscriptionEndDate = subscriptionEndDate
        self.subscriptionStartDate = subscriptionStartDate
        self.subscriptionType = subscriptionType
        self.vendorName = vendorName
        self.vpcId = vpcId
    }
}

struct DescribeHsmOutputResponseBody: Equatable {
    public let hsmArn: String?
    public let status: HsmStatus?
    public let statusDetails: String?
    public let availabilityZone: String?
    public let eniId: String?
    public let eniIp: String?
    public let subscriptionType: SubscriptionType?
    public let subscriptionStartDate: String?
    public let subscriptionEndDate: String?
    public let vpcId: String?
    public let subnetId: String?
    public let iamRoleArn: String?
    public let serialNumber: String?
    public let vendorName: String?
    public let hsmType: String?
    public let softwareVersion: String?
    public let sshPublicKey: String?
    public let sshKeyLastUpdated: String?
    public let serverCertUri: String?
    public let serverCertLastUpdated: String?
    public let partitions: [String]?
}

extension DescribeHsmOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case eniId = "EniId"
        case eniIp = "EniIp"
        case hsmArn = "HsmArn"
        case hsmType = "HsmType"
        case iamRoleArn = "IamRoleArn"
        case partitions = "Partitions"
        case serialNumber = "SerialNumber"
        case serverCertLastUpdated = "ServerCertLastUpdated"
        case serverCertUri = "ServerCertUri"
        case softwareVersion = "SoftwareVersion"
        case sshKeyLastUpdated = "SshKeyLastUpdated"
        case sshPublicKey = "SshPublicKey"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case subnetId = "SubnetId"
        case subscriptionEndDate = "SubscriptionEndDate"
        case subscriptionStartDate = "SubscriptionStartDate"
        case subscriptionType = "SubscriptionType"
        case vendorName = "VendorName"
        case vpcId = "VpcId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(HsmStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let eniIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eniId)
        eniId = eniIdDecoded
        let eniIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eniIp)
        eniIp = eniIpDecoded
        let subscriptionTypeDecoded = try containerValues.decodeIfPresent(SubscriptionType.self, forKey: .subscriptionType)
        subscriptionType = subscriptionTypeDecoded
        let subscriptionStartDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionStartDate)
        subscriptionStartDate = subscriptionStartDateDecoded
        let subscriptionEndDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionEndDate)
        subscriptionEndDate = subscriptionEndDateDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let vendorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vendorName)
        vendorName = vendorNameDecoded
        let hsmTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hsmType)
        hsmType = hsmTypeDecoded
        let softwareVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .softwareVersion)
        softwareVersion = softwareVersionDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let sshKeyLastUpdatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshKeyLastUpdated)
        sshKeyLastUpdated = sshKeyLastUpdatedDecoded
        let serverCertUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverCertUri)
        serverCertUri = serverCertUriDecoded
        let serverCertLastUpdatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverCertLastUpdated)
        serverCertLastUpdated = serverCertLastUpdatedDecoded
        let partitionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .partitions)
        var partitionsDecoded0:[String]? = nil
        if let partitionsContainer = partitionsContainer {
            partitionsDecoded0 = [String]()
            for string0 in partitionsContainer {
                if let string0 = string0 {
                    partitionsDecoded0?.append(string0)
                }
            }
        }
        partitions = partitionsDecoded0
    }
}

public struct DescribeLunaClientInputBodyMiddleware: Middleware {
    public let id: String = "DescribeLunaClientInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLunaClientInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLunaClientInput>
    public typealias MOutput = OperationOutput<DescribeLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLunaClientOutputError>
}

extension DescribeLunaClientInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLunaClientInput(certificateFingerprint: \(String(describing: certificateFingerprint)), clientArn: \(String(describing: clientArn)))"}
}

extension DescribeLunaClientInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateFingerprint = "CertificateFingerprint"
        case clientArn = "ClientArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateFingerprint = certificateFingerprint {
            try encodeContainer.encode(certificateFingerprint, forKey: .certificateFingerprint)
        }
        if let clientArn = clientArn {
            try encodeContainer.encode(clientArn, forKey: .clientArn)
        }
    }
}

public struct DescribeLunaClientInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLunaClientInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLunaClientInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLunaClientInput>
    public typealias MOutput = OperationOutput<DescribeLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLunaClientOutputError>
}

public struct DescribeLunaClientInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLunaClientInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLunaClientInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLunaClientInput>
    public typealias MOutput = OperationOutput<DescribeLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLunaClientOutputError>
}

public struct DescribeLunaClientInput: Equatable {
    /// <p>The certificate fingerprint.</p>
    public let certificateFingerprint: String?
    /// <p>The ARN of the client.</p>
    public let clientArn: String?

    public init (
        certificateFingerprint: String? = nil,
        clientArn: String? = nil
    )
    {
        self.certificateFingerprint = certificateFingerprint
        self.clientArn = clientArn
    }
}

struct DescribeLunaClientInputBody: Equatable {
    public let clientArn: String?
    public let certificateFingerprint: String?
}

extension DescribeLunaClientInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateFingerprint = "CertificateFingerprint"
        case clientArn = "ClientArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
        let certificateFingerprintDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateFingerprint)
        certificateFingerprint = certificateFingerprintDecoded
    }
}

extension DescribeLunaClientOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLunaClientOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLunaClientOutputError: Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLunaClientOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLunaClientOutputResponse(certificate: \(String(describing: certificate)), certificateFingerprint: \(String(describing: certificateFingerprint)), clientArn: \(String(describing: clientArn)), label: \(String(describing: label)), lastModifiedTimestamp: \(String(describing: lastModifiedTimestamp)))"}
}

extension DescribeLunaClientOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeLunaClientOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificate = output.certificate
            self.certificateFingerprint = output.certificateFingerprint
            self.clientArn = output.clientArn
            self.label = output.label
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
        } else {
            self.certificate = nil
            self.certificateFingerprint = nil
            self.clientArn = nil
            self.label = nil
            self.lastModifiedTimestamp = nil
        }
    }
}

public struct DescribeLunaClientOutputResponse: Equatable {
    /// <p>The certificate installed on the HSMs used by this client.</p>
    public let certificate: String?
    /// <p>The certificate fingerprint.</p>
    public let certificateFingerprint: String?
    /// <p>The ARN of the client.</p>
    public let clientArn: String?
    /// <p>The label of the client.</p>
    public let label: String?
    /// <p>The date and time the client was last modified.</p>
    public let lastModifiedTimestamp: String?

    public init (
        certificate: String? = nil,
        certificateFingerprint: String? = nil,
        clientArn: String? = nil,
        label: String? = nil,
        lastModifiedTimestamp: String? = nil
    )
    {
        self.certificate = certificate
        self.certificateFingerprint = certificateFingerprint
        self.clientArn = clientArn
        self.label = label
        self.lastModifiedTimestamp = lastModifiedTimestamp
    }
}

struct DescribeLunaClientOutputResponseBody: Equatable {
    public let clientArn: String?
    public let certificate: String?
    public let certificateFingerprint: String?
    public let lastModifiedTimestamp: String?
    public let label: String?
}

extension DescribeLunaClientOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
        case certificateFingerprint = "CertificateFingerprint"
        case clientArn = "ClientArn"
        case label = "Label"
        case lastModifiedTimestamp = "LastModifiedTimestamp"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificate)
        certificate = certificateDecoded
        let certificateFingerprintDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateFingerprint)
        certificateFingerprint = certificateFingerprintDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let labelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .label)
        label = labelDecoded
    }
}

public struct GetConfigInputBodyMiddleware: Middleware {
    public let id: String = "GetConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConfigInput>
    public typealias MOutput = OperationOutput<GetConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConfigOutputError>
}

extension GetConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConfigInput(clientArn: \(String(describing: clientArn)), clientVersion: \(String(describing: clientVersion)), hapgList: \(String(describing: hapgList)))"}
}

extension GetConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientArn = "ClientArn"
        case clientVersion = "ClientVersion"
        case hapgList = "HapgList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientArn = clientArn {
            try encodeContainer.encode(clientArn, forKey: .clientArn)
        }
        if let clientVersion = clientVersion {
            try encodeContainer.encode(clientVersion.rawValue, forKey: .clientVersion)
        }
        if let hapgList = hapgList {
            var hapgListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hapgList)
            for hapglist0 in hapgList {
                try hapgListContainer.encode(hapglist0)
            }
        }
    }
}

public struct GetConfigInputHeadersMiddleware: Middleware {
    public let id: String = "GetConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConfigInput>
    public typealias MOutput = OperationOutput<GetConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConfigOutputError>
}

public struct GetConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "GetConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConfigInput>
    public typealias MOutput = OperationOutput<GetConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConfigOutputError>
}

public struct GetConfigInput: Equatable {
    /// <p>The ARN of the client.</p>
    public let clientArn: String?
    /// <p>The client version.</p>
    public let clientVersion: ClientVersion?
    /// <p>A list of ARNs that identify the high-availability partition groups that are associated
    ///       with the client.</p>
    public let hapgList: [String]?

    public init (
        clientArn: String? = nil,
        clientVersion: ClientVersion? = nil,
        hapgList: [String]? = nil
    )
    {
        self.clientArn = clientArn
        self.clientVersion = clientVersion
        self.hapgList = hapgList
    }
}

struct GetConfigInputBody: Equatable {
    public let clientArn: String?
    public let clientVersion: ClientVersion?
    public let hapgList: [String]?
}

extension GetConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientArn = "ClientArn"
        case clientVersion = "ClientVersion"
        case hapgList = "HapgList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
        let clientVersionDecoded = try containerValues.decodeIfPresent(ClientVersion.self, forKey: .clientVersion)
        clientVersion = clientVersionDecoded
        let hapgListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .hapgList)
        var hapgListDecoded0:[String]? = nil
        if let hapgListContainer = hapgListContainer {
            hapgListDecoded0 = [String]()
            for string0 in hapgListContainer {
                if let string0 = string0 {
                    hapgListDecoded0?.append(string0)
                }
            }
        }
        hapgList = hapgListDecoded0
    }
}

extension GetConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConfigOutputError: Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConfigOutputResponse(configCred: \(String(describing: configCred)), configFile: \(String(describing: configFile)), configType: \(String(describing: configType)))"}
}

extension GetConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configCred = output.configCred
            self.configFile = output.configFile
            self.configType = output.configType
        } else {
            self.configCred = nil
            self.configFile = nil
            self.configType = nil
        }
    }
}

public struct GetConfigOutputResponse: Equatable {
    /// <p>The certificate file containing the server.pem files of the HSMs.</p>
    public let configCred: String?
    /// <p>The chrystoki.conf configuration file.</p>
    public let configFile: String?
    /// <p>The type of credentials.</p>
    public let configType: String?

    public init (
        configCred: String? = nil,
        configFile: String? = nil,
        configType: String? = nil
    )
    {
        self.configCred = configCred
        self.configFile = configFile
        self.configType = configType
    }
}

struct GetConfigOutputResponseBody: Equatable {
    public let configType: String?
    public let configFile: String?
    public let configCred: String?
}

extension GetConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configCred = "ConfigCred"
        case configFile = "ConfigFile"
        case configType = "ConfigType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configType)
        configType = configTypeDecoded
        let configFileDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configFile)
        configFile = configFileDecoded
        let configCredDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configCred)
        configCred = configCredDecoded
    }
}

public enum HsmStatus {
    case degraded
    case pending
    case running
    case suspended
    case terminated
    case terminating
    case updating
    case sdkUnknown(String)
}

extension HsmStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HsmStatus] {
        return [
            .degraded,
            .pending,
            .running,
            .suspended,
            .terminated,
            .terminating,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .degraded: return "DEGRADED"
        case .pending: return "PENDING"
        case .running: return "RUNNING"
        case .suspended: return "SUSPENDED"
        case .terminated: return "TERMINATED"
        case .terminating: return "TERMINATING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HsmStatus(rawValue: rawValue) ?? HsmStatus.sdkUnknown(rawValue)
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)), retryable: \(String(describing: retryable)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.retryable = output.retryable
        } else {
            self.message = nil
            self.retryable = false
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that one or more of the request parameters are not valid.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Additional information about the error.</p>
    public var message: String?
    /// <p>Indicates if the action can be retried.</p>
    public var retryable: Bool

    public init (
        message: String? = nil,
        retryable: Bool = false
    )
    {
        self.message = message
        self.retryable = retryable
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
    public let retryable: Bool
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case retryable
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let retryableDecoded = try containerValues.decode(Bool.self, forKey: .retryable)
        retryable = retryableDecoded
    }
}

extension ListAvailableZonesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAvailableZonesInput()"}
}

extension ListAvailableZonesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAvailableZonesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAvailableZonesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAvailableZonesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAvailableZonesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAvailableZonesInput>
    public typealias MOutput = OperationOutput<ListAvailableZonesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAvailableZonesOutputError>
}

public struct ListAvailableZonesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAvailableZonesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAvailableZonesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAvailableZonesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAvailableZonesInput>
    public typealias MOutput = OperationOutput<ListAvailableZonesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAvailableZonesOutputError>
}

/// <p>Contains the inputs for the <a>ListAvailableZones</a> action.</p>
public struct ListAvailableZonesInput: Equatable {

    public init() {}
}

struct ListAvailableZonesInputBody: Equatable {
}

extension ListAvailableZonesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAvailableZonesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAvailableZonesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAvailableZonesOutputError: Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAvailableZonesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAvailableZonesOutputResponse(aZList: \(String(describing: aZList)))"}
}

extension ListAvailableZonesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAvailableZonesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aZList = output.aZList
        } else {
            self.aZList = nil
        }
    }
}

public struct ListAvailableZonesOutputResponse: Equatable {
    /// <p>The list of Availability Zones that have available AWS CloudHSM capacity.</p>
    public let aZList: [String]?

    public init (
        aZList: [String]? = nil
    )
    {
        self.aZList = aZList
    }
}

struct ListAvailableZonesOutputResponseBody: Equatable {
    public let aZList: [String]?
}

extension ListAvailableZonesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aZList = "AZList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aZListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .aZList)
        var aZListDecoded0:[String]? = nil
        if let aZListContainer = aZListContainer {
            aZListDecoded0 = [String]()
            for string0 in aZListContainer {
                if let string0 = string0 {
                    aZListDecoded0?.append(string0)
                }
            }
        }
        aZList = aZListDecoded0
    }
}

public struct ListHapgsInputBodyMiddleware: Middleware {
    public let id: String = "ListHapgsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListHapgsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListHapgsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListHapgsInput>
    public typealias MOutput = OperationOutput<ListHapgsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListHapgsOutputError>
}

extension ListHapgsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListHapgsInput(nextToken: \(String(describing: nextToken)))"}
}

extension ListHapgsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListHapgsInputHeadersMiddleware: Middleware {
    public let id: String = "ListHapgsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListHapgsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListHapgsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListHapgsInput>
    public typealias MOutput = OperationOutput<ListHapgsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListHapgsOutputError>
}

public struct ListHapgsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListHapgsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListHapgsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListHapgsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListHapgsInput>
    public typealias MOutput = OperationOutput<ListHapgsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListHapgsOutputError>
}

public struct ListHapgsInput: Equatable {
    /// <p>The <code>NextToken</code> value from a previous call to <code>ListHapgs</code>. Pass
    ///       null if this is the first call.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListHapgsInputBody: Equatable {
    public let nextToken: String?
}

extension ListHapgsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListHapgsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHapgsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListHapgsOutputError: Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHapgsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListHapgsOutputResponse(hapgList: \(String(describing: hapgList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListHapgsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListHapgsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hapgList = output.hapgList
            self.nextToken = output.nextToken
        } else {
            self.hapgList = nil
            self.nextToken = nil
        }
    }
}

public struct ListHapgsOutputResponse: Equatable {
    /// <p>The list of high-availability partition groups.</p>
    public let hapgList: [String]?
    /// <p>If not null, more results are available. Pass this value to <code>ListHapgs</code> to
    ///       retrieve the next set of items.</p>
    public let nextToken: String?

    public init (
        hapgList: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.hapgList = hapgList
        self.nextToken = nextToken
    }
}

struct ListHapgsOutputResponseBody: Equatable {
    public let hapgList: [String]?
    public let nextToken: String?
}

extension ListHapgsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hapgList = "HapgList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .hapgList)
        var hapgListDecoded0:[String]? = nil
        if let hapgListContainer = hapgListContainer {
            hapgListDecoded0 = [String]()
            for string0 in hapgListContainer {
                if let string0 = string0 {
                    hapgListDecoded0?.append(string0)
                }
            }
        }
        hapgList = hapgListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListHsmsInputBodyMiddleware: Middleware {
    public let id: String = "ListHsmsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListHsmsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListHsmsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListHsmsInput>
    public typealias MOutput = OperationOutput<ListHsmsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListHsmsOutputError>
}

extension ListHsmsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListHsmsInput(nextToken: \(String(describing: nextToken)))"}
}

extension ListHsmsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListHsmsInputHeadersMiddleware: Middleware {
    public let id: String = "ListHsmsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListHsmsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListHsmsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListHsmsInput>
    public typealias MOutput = OperationOutput<ListHsmsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListHsmsOutputError>
}

public struct ListHsmsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListHsmsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListHsmsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListHsmsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListHsmsInput>
    public typealias MOutput = OperationOutput<ListHsmsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListHsmsOutputError>
}

public struct ListHsmsInput: Equatable {
    /// <p>The <code>NextToken</code> value from a previous call to <code>ListHsms</code>. Pass
    ///       null if this is the first call.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListHsmsInputBody: Equatable {
    public let nextToken: String?
}

extension ListHsmsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListHsmsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHsmsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListHsmsOutputError: Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHsmsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListHsmsOutputResponse(hsmList: \(String(describing: hsmList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListHsmsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListHsmsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hsmList = output.hsmList
            self.nextToken = output.nextToken
        } else {
            self.hsmList = nil
            self.nextToken = nil
        }
    }
}

/// <p>Contains the output of the <code>ListHsms</code> operation.</p>
public struct ListHsmsOutputResponse: Equatable {
    /// <p>The list of ARNs that identify the HSMs.</p>
    public let hsmList: [String]?
    /// <p>If not null, more results are available. Pass this value to <code>ListHsms</code> to
    ///       retrieve the next set of items.</p>
    public let nextToken: String?

    public init (
        hsmList: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.hsmList = hsmList
        self.nextToken = nextToken
    }
}

struct ListHsmsOutputResponseBody: Equatable {
    public let hsmList: [String]?
    public let nextToken: String?
}

extension ListHsmsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hsmList = "HsmList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .hsmList)
        var hsmListDecoded0:[String]? = nil
        if let hsmListContainer = hsmListContainer {
            hsmListDecoded0 = [String]()
            for string0 in hsmListContainer {
                if let string0 = string0 {
                    hsmListDecoded0?.append(string0)
                }
            }
        }
        hsmList = hsmListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListLunaClientsInputBodyMiddleware: Middleware {
    public let id: String = "ListLunaClientsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLunaClientsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLunaClientsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLunaClientsInput>
    public typealias MOutput = OperationOutput<ListLunaClientsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLunaClientsOutputError>
}

extension ListLunaClientsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLunaClientsInput(nextToken: \(String(describing: nextToken)))"}
}

extension ListLunaClientsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListLunaClientsInputHeadersMiddleware: Middleware {
    public let id: String = "ListLunaClientsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLunaClientsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLunaClientsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLunaClientsInput>
    public typealias MOutput = OperationOutput<ListLunaClientsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLunaClientsOutputError>
}

public struct ListLunaClientsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLunaClientsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLunaClientsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLunaClientsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLunaClientsInput>
    public typealias MOutput = OperationOutput<ListLunaClientsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLunaClientsOutputError>
}

public struct ListLunaClientsInput: Equatable {
    /// <p>The <code>NextToken</code> value from a previous call to <code>ListLunaClients</code>.
    ///       Pass null if this is the first call.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListLunaClientsInputBody: Equatable {
    public let nextToken: String?
}

extension ListLunaClientsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLunaClientsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLunaClientsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLunaClientsOutputError: Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLunaClientsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLunaClientsOutputResponse(clientList: \(String(describing: clientList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLunaClientsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListLunaClientsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientList = output.clientList
            self.nextToken = output.nextToken
        } else {
            self.clientList = nil
            self.nextToken = nil
        }
    }
}

public struct ListLunaClientsOutputResponse: Equatable {
    /// <p>The list of clients.</p>
    public let clientList: [String]?
    /// <p>If not null, more results are available. Pass this to <code>ListLunaClients</code> to
    ///       retrieve the next set of items.</p>
    public let nextToken: String?

    public init (
        clientList: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.clientList = clientList
        self.nextToken = nextToken
    }
}

struct ListLunaClientsOutputResponseBody: Equatable {
    public let clientList: [String]?
    public let nextToken: String?
}

extension ListLunaClientsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientList = "ClientList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .clientList)
        var clientListDecoded0:[String]? = nil
        if let clientListContainer = clientListContainer {
            clientListDecoded0 = [String]()
            for string0 in clientListContainer {
                if let string0 = string0 {
                    clientListDecoded0?.append(string0)
                }
            }
        }
        clientList = clientListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS CloudHSM resource.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tagList: \(String(describing: tagList)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>One or more tags.</p>
    public let tagList: [Tag]?

    public init (
        tagList: [Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tagList: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagList)
        var tagListDecoded0:[Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

public struct ModifyHapgInputBodyMiddleware: Middleware {
    public let id: String = "ModifyHapgInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyHapgInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyHapgInput>
    public typealias MOutput = OperationOutput<ModifyHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyHapgOutputError>
}

extension ModifyHapgInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyHapgInput(hapgArn: \(String(describing: hapgArn)), label: \(String(describing: label)), partitionSerialList: \(String(describing: partitionSerialList)))"}
}

extension ModifyHapgInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hapgArn = "HapgArn"
        case label = "Label"
        case partitionSerialList = "PartitionSerialList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hapgArn = hapgArn {
            try encodeContainer.encode(hapgArn, forKey: .hapgArn)
        }
        if let label = label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let partitionSerialList = partitionSerialList {
            var partitionSerialListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionSerialList)
            for partitionseriallist0 in partitionSerialList {
                try partitionSerialListContainer.encode(partitionseriallist0)
            }
        }
    }
}

public struct ModifyHapgInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyHapgInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyHapgInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyHapgInput>
    public typealias MOutput = OperationOutput<ModifyHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyHapgOutputError>
}

public struct ModifyHapgInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyHapgInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyHapgInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyHapgInput>
    public typealias MOutput = OperationOutput<ModifyHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyHapgOutputError>
}

public struct ModifyHapgInput: Equatable {
    /// <p>The ARN of the high-availability partition group to modify.</p>
    public let hapgArn: String?
    /// <p>The new label for the high-availability partition group.</p>
    public let label: String?
    /// <p>The list of partition serial numbers to make members of the high-availability partition
    ///       group.</p>
    public let partitionSerialList: [String]?

    public init (
        hapgArn: String? = nil,
        label: String? = nil,
        partitionSerialList: [String]? = nil
    )
    {
        self.hapgArn = hapgArn
        self.label = label
        self.partitionSerialList = partitionSerialList
    }
}

struct ModifyHapgInputBody: Equatable {
    public let hapgArn: String?
    public let label: String?
    public let partitionSerialList: [String]?
}

extension ModifyHapgInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hapgArn = "HapgArn"
        case label = "Label"
        case partitionSerialList = "PartitionSerialList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
        let labelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .label)
        label = labelDecoded
        let partitionSerialListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .partitionSerialList)
        var partitionSerialListDecoded0:[String]? = nil
        if let partitionSerialListContainer = partitionSerialListContainer {
            partitionSerialListDecoded0 = [String]()
            for string0 in partitionSerialListContainer {
                if let string0 = string0 {
                    partitionSerialListDecoded0?.append(string0)
                }
            }
        }
        partitionSerialList = partitionSerialListDecoded0
    }
}

extension ModifyHapgOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyHapgOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyHapgOutputError: Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyHapgOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyHapgOutputResponse(hapgArn: \(String(describing: hapgArn)))"}
}

extension ModifyHapgOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyHapgOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hapgArn = output.hapgArn
        } else {
            self.hapgArn = nil
        }
    }
}

public struct ModifyHapgOutputResponse: Equatable {
    /// <p>The ARN of the high-availability partition group.</p>
    public let hapgArn: String?

    public init (
        hapgArn: String? = nil
    )
    {
        self.hapgArn = hapgArn
    }
}

struct ModifyHapgOutputResponseBody: Equatable {
    public let hapgArn: String?
}

extension ModifyHapgOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hapgArn = "HapgArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
    }
}

public struct ModifyHsmInputBodyMiddleware: Middleware {
    public let id: String = "ModifyHsmInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyHsmInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyHsmInput>
    public typealias MOutput = OperationOutput<ModifyHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyHsmOutputError>
}

extension ModifyHsmInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyHsmInput(eniIp: \(String(describing: eniIp)), externalId: \(String(describing: externalId)), hsmArn: \(String(describing: hsmArn)), iamRoleArn: \(String(describing: iamRoleArn)), subnetId: \(String(describing: subnetId)), syslogIp: \(String(describing: syslogIp)))"}
}

extension ModifyHsmInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eniIp = "EniIp"
        case externalId = "ExternalId"
        case hsmArn = "HsmArn"
        case iamRoleArn = "IamRoleArn"
        case subnetId = "SubnetId"
        case syslogIp = "SyslogIp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eniIp = eniIp {
            try encodeContainer.encode(eniIp, forKey: .eniIp)
        }
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let hsmArn = hsmArn {
            try encodeContainer.encode(hsmArn, forKey: .hsmArn)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let syslogIp = syslogIp {
            try encodeContainer.encode(syslogIp, forKey: .syslogIp)
        }
    }
}

public struct ModifyHsmInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyHsmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyHsmInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyHsmInput>
    public typealias MOutput = OperationOutput<ModifyHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyHsmOutputError>
}

public struct ModifyHsmInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyHsmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyHsmInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyHsmInput>
    public typealias MOutput = OperationOutput<ModifyHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyHsmOutputError>
}

/// <p>Contains the inputs for the <a>ModifyHsm</a> operation.</p>
public struct ModifyHsmInput: Equatable {
    /// <p>The new IP address for the elastic network interface (ENI) attached to the
    ///       HSM.</p>
    ///          <p>If the HSM is moved to a different subnet, and an IP address is not specified, an IP
    ///       address will be randomly chosen from the CIDR range of the new subnet.</p>
    public let eniIp: String?
    /// <p>The new external ID.</p>
    public let externalId: String?
    /// <p>The ARN of the HSM to modify.</p>
    public let hsmArn: String?
    /// <p>The new IAM role ARN.</p>
    public let iamRoleArn: String?
    /// <p>The new identifier of the subnet that the HSM is in. The new subnet must be in the same
    ///       Availability Zone as the current subnet.</p>
    public let subnetId: String?
    /// <p>The new IP address for the syslog monitoring server. The AWS CloudHSM service only supports
    ///       one syslog monitoring server.</p>
    public let syslogIp: String?

    public init (
        eniIp: String? = nil,
        externalId: String? = nil,
        hsmArn: String? = nil,
        iamRoleArn: String? = nil,
        subnetId: String? = nil,
        syslogIp: String? = nil
    )
    {
        self.eniIp = eniIp
        self.externalId = externalId
        self.hsmArn = hsmArn
        self.iamRoleArn = iamRoleArn
        self.subnetId = subnetId
        self.syslogIp = syslogIp
    }
}

struct ModifyHsmInputBody: Equatable {
    public let hsmArn: String?
    public let subnetId: String?
    public let eniIp: String?
    public let iamRoleArn: String?
    public let externalId: String?
    public let syslogIp: String?
}

extension ModifyHsmInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eniIp = "EniIp"
        case externalId = "ExternalId"
        case hsmArn = "HsmArn"
        case iamRoleArn = "IamRoleArn"
        case subnetId = "SubnetId"
        case syslogIp = "SyslogIp"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let eniIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eniIp)
        eniIp = eniIpDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let syslogIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .syslogIp)
        syslogIp = syslogIpDecoded
    }
}

extension ModifyHsmOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyHsmOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyHsmOutputError: Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyHsmOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyHsmOutputResponse(hsmArn: \(String(describing: hsmArn)))"}
}

extension ModifyHsmOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyHsmOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hsmArn = output.hsmArn
        } else {
            self.hsmArn = nil
        }
    }
}

/// <p>Contains the output of the <a>ModifyHsm</a> operation.</p>
public struct ModifyHsmOutputResponse: Equatable {
    /// <p>The ARN of the HSM.</p>
    public let hsmArn: String?

    public init (
        hsmArn: String? = nil
    )
    {
        self.hsmArn = hsmArn
    }
}

struct ModifyHsmOutputResponseBody: Equatable {
    public let hsmArn: String?
}

extension ModifyHsmOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hsmArn = "HsmArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
    }
}

public struct ModifyLunaClientInputBodyMiddleware: Middleware {
    public let id: String = "ModifyLunaClientInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyLunaClientInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyLunaClientInput>
    public typealias MOutput = OperationOutput<ModifyLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyLunaClientOutputError>
}

extension ModifyLunaClientInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyLunaClientInput(certificate: \(String(describing: certificate)), clientArn: \(String(describing: clientArn)))"}
}

extension ModifyLunaClientInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
        case clientArn = "ClientArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let clientArn = clientArn {
            try encodeContainer.encode(clientArn, forKey: .clientArn)
        }
    }
}

public struct ModifyLunaClientInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyLunaClientInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyLunaClientInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyLunaClientInput>
    public typealias MOutput = OperationOutput<ModifyLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyLunaClientOutputError>
}

public struct ModifyLunaClientInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyLunaClientInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyLunaClientInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyLunaClientInput>
    public typealias MOutput = OperationOutput<ModifyLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyLunaClientOutputError>
}

public struct ModifyLunaClientInput: Equatable {
    /// <p>The new certificate for the client.</p>
    public let certificate: String?
    /// <p>The ARN of the client.</p>
    public let clientArn: String?

    public init (
        certificate: String? = nil,
        clientArn: String? = nil
    )
    {
        self.certificate = certificate
        self.clientArn = clientArn
    }
}

struct ModifyLunaClientInputBody: Equatable {
    public let clientArn: String?
    public let certificate: String?
}

extension ModifyLunaClientInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
        case clientArn = "ClientArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

extension ModifyLunaClientOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyLunaClientOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyLunaClientOutputError: Equatable {
    case cloudHsmServiceException(CloudHsmServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyLunaClientOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyLunaClientOutputResponse(clientArn: \(String(describing: clientArn)))"}
}

extension ModifyLunaClientOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyLunaClientOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientArn = output.clientArn
        } else {
            self.clientArn = nil
        }
    }
}

public struct ModifyLunaClientOutputResponse: Equatable {
    /// <p>The ARN of the client.</p>
    public let clientArn: String?

    public init (
        clientArn: String? = nil
    )
    {
        self.clientArn = clientArn
    }
}

struct ModifyLunaClientOutputResponseBody: Equatable {
    public let clientArn: String?
}

extension ModifyLunaClientOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientArn = "ClientArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
    }
}

public struct RemoveTagsFromResourceInputBodyMiddleware: Middleware {
    public let id: String = "RemoveTagsFromResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromResourceOutputError>
}

extension RemoveTagsFromResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsFromResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeyList: \(String(describing: tagKeyList)))"}
}

extension RemoveTagsFromResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeyList = "TagKeyList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeyList = tagKeyList {
            var tagKeyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeyList)
            for tagkeylist0 in tagKeyList {
                try tagKeyListContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct RemoveTagsFromResourceInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveTagsFromResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveTagsFromResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS CloudHSM resource.</p>
    public let resourceArn: String?
    /// <p>The tag key or keys to remove.</p>
    ///          <p>Specify only the tag key to remove (not the value). To overwrite the value for an
    ///       existing tag, use <a>AddTagsToResource</a>.</p>
    public let tagKeyList: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeyList: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeyList = tagKeyList
    }
}

struct RemoveTagsFromResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeyList: [String]?
}

extension RemoveTagsFromResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeyList = "TagKeyList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeyListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeyList)
        var tagKeyListDecoded0:[String]? = nil
        if let tagKeyListContainer = tagKeyListContainer {
            tagKeyListDecoded0 = [String]()
            for string0 in tagKeyListContainer {
                if let string0 = string0 {
                    tagKeyListDecoded0?.append(string0)
                }
            }
        }
        tagKeyList = tagKeyListDecoded0
    }
}

extension RemoveTagsFromResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTagsFromResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsFromResourceOutputError: Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsFromResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsFromResourceOutputResponse(status: \(String(describing: status)))"}
}

extension RemoveTagsFromResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RemoveTagsFromResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct RemoveTagsFromResourceOutputResponse: Equatable {
    /// <p>The status of the operation.</p>
    public let status: String?

    public init (
        status: String? = nil
    )
    {
        self.status = status
    }
}

struct RemoveTagsFromResourceOutputResponseBody: Equatable {
    public let status: String?
}

extension RemoveTagsFromResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

/// <p>Specifies the type of subscription for the HSM.</p>
///          <ul>
///             <li>
///                <p>
///                   <b>PRODUCTION</b> - The HSM is being used in a production
///           environment.</p>
///             </li>
///             <li>
///                <p>
///                   <b>TRIAL</b> - The HSM is being used in a product
///           trial.</p>
///             </li>
///          </ul>
public enum SubscriptionType {
    case production
    case sdkUnknown(String)
}

extension SubscriptionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SubscriptionType] {
        return [
            .production,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .production: return "PRODUCTION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SubscriptionType(rawValue: rawValue) ?? SubscriptionType.sdkUnknown(rawValue)
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A key-value pair that identifies or specifies metadata about an AWS CloudHSM
///       resource.</p>
public struct Tag: Equatable {
    /// <p>The key of the tag.</p>
    public let key: String?
    /// <p>The value of the tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}
