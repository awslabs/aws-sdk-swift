// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccountInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId
        case accountName
        case emailAddress
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let accountName = accountName {
            try encodeContainer.encode(accountName, forKey: .accountName)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let accountNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountName)
        accountName = accountNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
    }
}

extension AccountInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountInfo(accountId: \(String(describing: accountId)), accountName: \(String(describing: accountName)), emailAddress: \(String(describing: emailAddress)))"}
}

/// <p>Provides information about your AWS account.</p>
public struct AccountInfo: Equatable {
    /// <p>The identifier of the AWS account that is assigned to the user.</p>
    public let accountId: String?
    /// <p>The display name of the AWS account that is assigned to the user.</p>
    public let accountName: String?
    /// <p>The email address of the AWS account that is assigned to the user.</p>
    public let emailAddress: String?

    public init (
        accountId: String? = nil,
        accountName: String? = nil,
        emailAddress: String? = nil
    )
    {
        self.accountId = accountId
        self.accountName = accountName
        self.emailAddress = emailAddress
    }
}

extension GetRoleCredentialsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRoleCredentialsInput(accessToken: \(String(describing: accessToken)), accountId: \(String(describing: accountId)), roleName: \(String(describing: roleName)))"}
}

extension GetRoleCredentialsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetRoleCredentialsInputHeadersMiddleware: Middleware {
    public let id: String = "GetRoleCredentialsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRoleCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRoleCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accessToken = input.operationInput.accessToken {
            input.builder.withHeader(name: "x-amz-sso_bearer_token", value: String(accessToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRoleCredentialsInput>
    public typealias MOutput = OperationOutput<GetRoleCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRoleCredentialsOutputError>
}

public struct GetRoleCredentialsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRoleCredentialsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRoleCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRoleCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            let accountIdQueryItem = URLQueryItem(name: "account_id".urlPercentEncoding(), value: String(accountId).urlPercentEncoding())
            input.builder.withQueryItem(accountIdQueryItem)
        }
        if let roleName = input.operationInput.roleName {
            let roleNameQueryItem = URLQueryItem(name: "role_name".urlPercentEncoding(), value: String(roleName).urlPercentEncoding())
            input.builder.withQueryItem(roleNameQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRoleCredentialsInput>
    public typealias MOutput = OperationOutput<GetRoleCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRoleCredentialsOutputError>
}

public struct GetRoleCredentialsInput: Equatable {
    /// <p>The token issued by the <code>CreateToken</code> API call. For more information, see
    ///         <a href="https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/API_CreateToken.html">CreateToken</a> in the <i>AWS SSO OIDC API Reference Guide</i>.</p>
    public let accessToken: String?
    /// <p>The identifier for the AWS account that is assigned to the user.</p>
    public let accountId: String?
    /// <p>The friendly name of the role that is assigned to the user.</p>
    public let roleName: String?

    public init (
        accessToken: String? = nil,
        accountId: String? = nil,
        roleName: String? = nil
    )
    {
        self.accessToken = accessToken
        self.accountId = accountId
        self.roleName = roleName
    }
}

struct GetRoleCredentialsInputBody: Equatable {
}

extension GetRoleCredentialsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetRoleCredentialsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRoleCredentialsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRoleCredentialsOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRoleCredentialsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRoleCredentialsOutputResponse(roleCredentials: \(String(describing: roleCredentials)))"}
}

extension GetRoleCredentialsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRoleCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.roleCredentials = output.roleCredentials
        } else {
            self.roleCredentials = nil
        }
    }
}

public struct GetRoleCredentialsOutputResponse: Equatable {
    /// <p>The credentials for the role that is assigned to the user.</p>
    public let roleCredentials: RoleCredentials?

    public init (
        roleCredentials: RoleCredentials? = nil
    )
    {
        self.roleCredentials = roleCredentials
    }
}

struct GetRoleCredentialsOutputResponseBody: Equatable {
    public let roleCredentials: RoleCredentials?
}

extension GetRoleCredentialsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case roleCredentials
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleCredentialsDecoded = try containerValues.decodeIfPresent(RoleCredentials.self, forKey: .roleCredentials)
        roleCredentials = roleCredentialsDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that a problem occurred with the input to the request. For example, a required
///       parameter might be missing or out of range.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAccountRolesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccountRolesInput(accessToken: \(String(describing: accessToken)), accountId: \(String(describing: accountId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAccountRolesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAccountRolesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAccountRolesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccountRolesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccountRolesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accessToken = input.operationInput.accessToken {
            input.builder.withHeader(name: "x-amz-sso_bearer_token", value: String(accessToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccountRolesInput>
    public typealias MOutput = OperationOutput<ListAccountRolesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccountRolesOutputError>
}

public struct ListAccountRolesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAccountRolesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccountRolesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccountRolesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            let accountIdQueryItem = URLQueryItem(name: "account_id".urlPercentEncoding(), value: String(accountId).urlPercentEncoding())
            input.builder.withQueryItem(accountIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next_token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "max_result".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccountRolesInput>
    public typealias MOutput = OperationOutput<ListAccountRolesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccountRolesOutputError>
}

public struct ListAccountRolesInput: Equatable {
    /// <p>The token issued by the <code>CreateToken</code> API call. For more information, see
    ///         <a href="https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/API_CreateToken.html">CreateToken</a> in the <i>AWS SSO OIDC API Reference Guide</i>.</p>
    public let accessToken: String?
    /// <p>The identifier for the AWS account that is assigned to the user.</p>
    public let accountId: String?
    /// <p>The number of items that clients can request per page.</p>
    public let maxResults: Int?
    /// <p>The page token from the previous response output when you request subsequent pages.</p>
    public let nextToken: String?

    public init (
        accessToken: String? = nil,
        accountId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.accessToken = accessToken
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAccountRolesInputBody: Equatable {
}

extension ListAccountRolesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAccountRolesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccountRolesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccountRolesOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccountRolesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccountRolesOutputResponse(nextToken: \(String(describing: nextToken)), roleList: \(String(describing: roleList)))"}
}

extension ListAccountRolesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAccountRolesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.roleList = output.roleList
        } else {
            self.nextToken = nil
            self.roleList = nil
        }
    }
}

public struct ListAccountRolesOutputResponse: Equatable {
    /// <p>The page token client that is used to retrieve the list of accounts.</p>
    public let nextToken: String?
    /// <p>A paginated response with the list of roles and the next token if more results are available.</p>
    public let roleList: [RoleInfo]?

    public init (
        nextToken: String? = nil,
        roleList: [RoleInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.roleList = roleList
    }
}

struct ListAccountRolesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let roleList: [RoleInfo]?
}

extension ListAccountRolesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case roleList
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let roleListContainer = try containerValues.decodeIfPresent([RoleInfo?].self, forKey: .roleList)
        var roleListDecoded0:[RoleInfo]? = nil
        if let roleListContainer = roleListContainer {
            roleListDecoded0 = [RoleInfo]()
            for structure0 in roleListContainer {
                if let structure0 = structure0 {
                    roleListDecoded0?.append(structure0)
                }
            }
        }
        roleList = roleListDecoded0
    }
}

extension ListAccountsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccountsInput(accessToken: \(String(describing: accessToken)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAccountsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAccountsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAccountsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccountsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accessToken = input.operationInput.accessToken {
            input.builder.withHeader(name: "x-amz-sso_bearer_token", value: String(accessToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccountsInput>
    public typealias MOutput = OperationOutput<ListAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccountsOutputError>
}

public struct ListAccountsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAccountsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccountsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next_token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "max_result".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccountsInput>
    public typealias MOutput = OperationOutput<ListAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccountsOutputError>
}

public struct ListAccountsInput: Equatable {
    /// <p>The token issued by the <code>CreateToken</code> API call. For more information, see
    ///         <a href="https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/API_CreateToken.html">CreateToken</a> in the <i>AWS SSO OIDC API Reference Guide</i>.</p>
    public let accessToken: String?
    /// <p>This is the number of items clients can request per page.</p>
    public let maxResults: Int?
    /// <p>(Optional) When requesting subsequent pages, this is the page token from the previous response output.</p>
    public let nextToken: String?

    public init (
        accessToken: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.accessToken = accessToken
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAccountsInputBody: Equatable {
}

extension ListAccountsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAccountsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccountsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccountsOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccountsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccountsOutputResponse(accountList: \(String(describing: accountList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAccountsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAccountsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountList = output.accountList
            self.nextToken = output.nextToken
        } else {
            self.accountList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountsOutputResponse: Equatable {
    /// <p>A paginated response with the list of account information and the next token if more results are available.</p>
    public let accountList: [AccountInfo]?
    /// <p>The page token client that is used to retrieve the list of accounts.</p>
    public let nextToken: String?

    public init (
        accountList: [AccountInfo]? = nil,
        nextToken: String? = nil
    )
    {
        self.accountList = accountList
        self.nextToken = nextToken
    }
}

struct ListAccountsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let accountList: [AccountInfo]?
}

extension ListAccountsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountList
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let accountListContainer = try containerValues.decodeIfPresent([AccountInfo?].self, forKey: .accountList)
        var accountListDecoded0:[AccountInfo]? = nil
        if let accountListContainer = accountListContainer {
            accountListDecoded0 = [AccountInfo]()
            for structure0 in accountListContainer {
                if let structure0 = structure0 {
                    accountListDecoded0?.append(structure0)
                }
            }
        }
        accountList = accountListDecoded0
    }
}

extension LogoutInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LogoutInput(accessToken: \(String(describing: accessToken)))"}
}

extension LogoutInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct LogoutInputHeadersMiddleware: Middleware {
    public let id: String = "LogoutInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<LogoutInput>,
                  next: H) -> Swift.Result<OperationOutput<LogoutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accessToken = input.operationInput.accessToken {
            input.builder.withHeader(name: "x-amz-sso_bearer_token", value: String(accessToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<LogoutInput>
    public typealias MOutput = OperationOutput<LogoutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<LogoutOutputError>
}

public struct LogoutInputQueryItemMiddleware: Middleware {
    public let id: String = "LogoutInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<LogoutInput>,
                  next: H) -> Swift.Result<OperationOutput<LogoutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<LogoutInput>
    public typealias MOutput = OperationOutput<LogoutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<LogoutOutputError>
}

public struct LogoutInput: Equatable {
    /// <p>The token issued by the <code>CreateToken</code> API call. For more information, see
    ///         <a href="https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/API_CreateToken.html">CreateToken</a> in the <i>AWS SSO OIDC API Reference Guide</i>.</p>
    public let accessToken: String?

    public init (
        accessToken: String? = nil
    )
    {
        self.accessToken = accessToken
    }
}

struct LogoutInputBody: Equatable {
}

extension LogoutInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension LogoutOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension LogoutOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum LogoutOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension LogoutOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LogoutOutputResponse()"}
}

extension LogoutOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct LogoutOutputResponse: Equatable {

    public init() {}
}

struct LogoutOutputResponseBody: Equatable {
}

extension LogoutOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource doesn't exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RoleCredentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessKeyId
        case expiration
        case secretAccessKey
        case sessionToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if expiration != 0 {
            try encodeContainer.encode(expiration, forKey: .expiration)
        }
        if let secretAccessKey = secretAccessKey {
            try encodeContainer.encode(secretAccessKey, forKey: .secretAccessKey)
        }
        if let sessionToken = sessionToken {
            try encodeContainer.encode(sessionToken, forKey: .sessionToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let sessionTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
        let expirationDecoded = try containerValues.decode(Int.self, forKey: .expiration)
        expiration = expirationDecoded
    }
}

extension RoleCredentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RoleCredentials(accessKeyId: \(String(describing: accessKeyId)), expiration: \(String(describing: expiration)), secretAccessKey: \(String(describing: secretAccessKey)), sessionToken: \(String(describing: sessionToken)))"}
}

/// <p>Provides information about the role credentials that are assigned to the user.</p>
public struct RoleCredentials: Equatable {
    /// <p>The identifier used for the temporary security credentials. For more information, see
    ///         <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html">Using Temporary Security Credentials to Request Access to AWS Resources</a> in the
    ///         <i>AWS IAM User Guide</i>.</p>
    public let accessKeyId: String?
    /// <p>The date on which temporary security credentials expire.</p>
    public let expiration: Int
    /// <p>The key that is used to sign the request. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html">Using Temporary Security Credentials to Request Access to AWS Resources</a> in the
    ///         <i>AWS IAM User Guide</i>.</p>
    public let secretAccessKey: String?
    /// <p>The token used for temporary credentials. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html">Using Temporary Security Credentials to Request Access to AWS Resources</a> in the
    ///         <i>AWS IAM User Guide</i>.</p>
    public let sessionToken: String?

    public init (
        accessKeyId: String? = nil,
        expiration: Int = 0,
        secretAccessKey: String? = nil,
        sessionToken: String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.expiration = expiration
        self.secretAccessKey = secretAccessKey
        self.sessionToken = sessionToken
    }
}

extension RoleInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId
        case roleName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let roleName = roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension RoleInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RoleInfo(accountId: \(String(describing: accountId)), roleName: \(String(describing: roleName)))"}
}

/// <p>Provides information about the role that is assigned to the user.</p>
public struct RoleInfo: Equatable {
    /// <p>The identifier of the AWS account assigned to the user.</p>
    public let accountId: String?
    /// <p>The friendly name of the role that is assigned to the user.</p>
    public let roleName: String?

    public init (
        accountId: String? = nil,
        roleName: String? = nil
    )
    {
        self.accountId = accountId
        self.roleName = roleName
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the request is being made too frequently and is more than what the server can handle.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnauthorizedException(message: \(String(describing: message)))"}
}

extension UnauthorizedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the request is not authorized. This can happen due to an invalid access token in the request.</p>
public struct UnauthorizedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Equatable {
    public let message: String?
}

extension UnauthorizedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
