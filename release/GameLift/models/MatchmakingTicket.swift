// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

/// <p>Ticket generated to track the progress of a matchmaking request. Each ticket is
///             uniquely identified by a ticket ID, supplied by the requester, when creating a
///             matchmaking request with <a>StartMatchmaking</a>. Tickets can be retrieved by
///             calling <a>DescribeMatchmaking</a> with the ticket ID.</p>
public struct MatchmakingTicket: Equatable {
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html">ARN</a>) associated with the GameLift matchmaking configuration resource that is used with this ticket.</p>
    public let configurationArn: String?
    /// <p>Name of the <a>MatchmakingConfiguration</a> that is used with this
    ///             ticket. Matchmaking configurations determine how players are grouped into a match and
    ///             how a new game session is created for the match.</p>
    public let configurationName: String?
    /// <p>Time stamp indicating when this matchmaking request stopped being processed due to
    ///             success, failure, or cancellation. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    public let endTime: Date?
    /// <p>Average amount of time (in seconds) that players are currently waiting for a match.
    ///             If there is not enough recent data, this property may be empty.</p>
    public let estimatedWaitTime: Int?
    /// <p>Identifier and connection information of the game session created for the match. This
    ///             information is added to the ticket only after the matchmaking request has been
    ///             successfully completed. This parameter is not set when FlexMatch is being used without
    ///             GameLift hosting.</p>
    public let gameSessionConnectionInfo: GameSessionConnectionInfo?
    /// <p>A set of <code>Player</code> objects, each representing a player to find matches
    ///             for. Players are identified by a unique player ID and may include latency data for use
    ///             during matchmaking. If the ticket is in status <code>COMPLETED</code>, the
    ///             <code>Player</code> objects include the team the players were assigned to in the
    ///             resulting match.</p>
    public let players: [Player]?
    /// <p>Time stamp indicating when this matchmaking request was received. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    public let startTime: Date?
    /// <p>Current status of the matchmaking request.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <b>QUEUED</b> -- The matchmaking request has been
    ///                     received and is currently waiting to be processed.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>SEARCHING</b> -- The matchmaking request is
    ///                     currently being processed. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>REQUIRES_ACCEPTANCE</b> -- A match has been
    ///                     proposed and the players must accept the match (see <a>AcceptMatch</a>). This status is used only with requests that use a matchmaking configuration
    ///                     with a player acceptance requirement.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>PLACING</b> -- The FlexMatch engine has matched
    ///                     players and is in the process of placing a new game session for the
    ///                     match.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>COMPLETED</b> -- Players have been matched and a
    ///                     game session is ready to host the players. A ticket in this state contains the
    ///                     necessary connection information for players.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>FAILED</b> -- The matchmaking request was not
    ///                     completed.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>CANCELLED</b> -- The matchmaking request was
    ///                     canceled. This may be the result of a call to <a>StopMatchmaking</a>
    ///                     or a proposed match that one or more players failed to accept.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>TIMED_OUT</b> -- The matchmaking request was not
    ///                     successful within the duration specified in the matchmaking configuration.
    ///                 </p>
    ///             </li>
    ///          </ul>
    ///         <note>
    ///             <p>Matchmaking requests that fail to successfully complete (statuses FAILED,
    ///                 CANCELLED, TIMED_OUT) can be resubmitted as new requests with new ticket
    ///                 IDs.</p>
    ///         </note>
    public let status: MatchmakingConfigurationStatus?
    /// <p>Additional information about the current status.</p>
    public let statusMessage: String?
    /// <p>Code to explain the current status. For example, a status reason may indicate when
    ///             a ticket has returned to <code>SEARCHING</code> status after a proposed match fails to
    ///             receive player acceptances.</p>
    public let statusReason: String?
    /// <p>A unique identifier for a matchmaking ticket.</p>
    public let ticketId: String?

    public init (
        configurationArn: String? = nil,
        configurationName: String? = nil,
        endTime: Date? = nil,
        estimatedWaitTime: Int? = nil,
        gameSessionConnectionInfo: GameSessionConnectionInfo? = nil,
        players: [Player]? = nil,
        startTime: Date? = nil,
        status: MatchmakingConfigurationStatus? = nil,
        statusMessage: String? = nil,
        statusReason: String? = nil,
        ticketId: String? = nil
    )
    {
        self.configurationArn = configurationArn
        self.configurationName = configurationName
        self.endTime = endTime
        self.estimatedWaitTime = estimatedWaitTime
        self.gameSessionConnectionInfo = gameSessionConnectionInfo
        self.players = players
        self.startTime = startTime
        self.status = status
        self.statusMessage = statusMessage
        self.statusReason = statusReason
        self.ticketId = ticketId
    }
}
