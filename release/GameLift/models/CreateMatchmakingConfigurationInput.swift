// Code generated by smithy-swift-codegen. DO NOT EDIT!



/// <p>Represents the input for a request operation.</p>
public struct CreateMatchmakingConfigurationInput: Equatable {
    /// <p>A flag that determines whether a match that was created with this configuration must
    ///             be accepted by the matched players. To require acceptance, set to <code>TRUE</code>.
    ///             With this option enabled, matchmaking tickets use the status
    ///             <code>REQUIRES_ACCEPTANCE</code> to indicate when a completed potential match is
    ///             waiting for player acceptance. </p>
    public let acceptanceRequired: Bool?
    /// <p>The length of time (in seconds) to wait for players to accept a proposed match, if
    ///             acceptance is required. </p>
    public let acceptanceTimeoutSeconds: Int?
    /// <p>The number of player slots in a match to keep open for future players. For example, if the configuration's rule set specifies
    ///             a match for a single 12-person team, and the additional player count is set to 2, only 10 players are selected for the match. This parameter is not used if <code>FlexMatchMode</code> is set to
    ///             <code>STANDALONE</code>.</p>
    public let additionalPlayerCount: Int?
    /// <p>The method used to backfill game sessions that are created with this matchmaking
    ///             configuration. Specify <code>MANUAL</code> when your game manages backfill requests
    ///             manually or does not use the match backfill feature. Specify <code>AUTOMATIC</code> to
    ///             have GameLift create a <a>StartMatchBackfill</a> request whenever a game
    ///             session has one or more open slots. Learn more about manual and automatic backfill in
    ///             <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-backfill.html"> Backfill Existing Games with FlexMatch</a>. Automatic backfill is not
    ///             available when <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
    public let backfillMode: BackfillMode?
    /// <p>Information to be added to all events related to this matchmaking configuration.
    ///         </p>
    public let customEventData: String?
    /// <p>A human-readable description of the matchmaking configuration. </p>
    public let description: String?
    /// <p>Indicates whether this matchmaking configuration is being used with GameLift hosting or
    ///             as a standalone matchmaking solution. </p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <b>STANDALONE</b> - FlexMatch forms matches and returns
    ///                 match information, including players and team assignments, in a
    ///                 <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-events.html#match-events-matchmakingsucceeded">
    ///                     MatchmakingSucceeded</a> event.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>WITH_QUEUE</b> - FlexMatch forms matches and uses the specified GameLift queue to
    ///                 start a game session for the match. </p>
    ///             </li>
    ///          </ul>
    public let flexMatchMode: FlexMatchMode?
    /// <p>A set of custom properties for a game session, formatted as key:value pairs. These properties are passed to a game server process in the
    ///     <a>GameSession</a> object with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>). This information is added to the new <a>GameSession</a>
    ///             object that is created for a successful match. This parameter is not used if
    ///             <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
    public let gameProperties: [GameProperty]?
    /// <p>A set of custom game session properties, formatted as a single string value. This data is passed to a game server process in the
    ///     <a>GameSession</a> object with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>). This information is added to the new <a>GameSession</a> object
    ///             that is created for a successful match. This parameter is not used if
    ///             <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
    public let gameSessionData: String?
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html">ARN</a>) that is assigned to a GameLift game session queue resource and uniquely identifies it. ARNs are unique across all Regions. Format is <code>arn:aws:gamelift:<region>::gamesessionqueue/<queue name></code>. Queues can be located in any Region. Queues are used to start new
    ///             GameLift-hosted game sessions for matches that are created with this matchmaking
    ///             configuration. If <code>FlexMatchMode</code> is set to <code>STANDALONE</code>, do not
    ///             set this parameter.  </p>
    public let gameSessionQueueArns: [String]?
    /// <p>A unique identifier for the matchmaking configuration. This name is used to identify the configuration associated with a
    ///             matchmaking request or ticket.</p>
    public let name: String?
    /// <p>An SNS topic ARN that is set up to receive matchmaking notifications. See <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-notification.html">
    ///             Setting up notifications for matchmaking</a> for more information.</p>
    public let notificationTarget: String?
    /// <p>The maximum duration, in seconds, that a matchmaking ticket can remain in process
    ///             before timing out. Requests that fail due to timing out can be resubmitted as
    ///             needed.</p>
    public let requestTimeoutSeconds: Int?
    /// <p>A unique identifier for the matchmaking rule set to use with this configuration. You can use either the rule set name or ARN
    ///             value. A matchmaking configuration can only use rule sets that are defined in the same
    ///             Region.</p>
    public let ruleSetName: String?
    /// <p>A list of labels to assign to the new matchmaking configuration resource. Tags are developer-defined
    ///             key-value pairs. Tagging
    ///             AWS resources are useful for resource management, access management and cost allocation.
    ///             For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging AWS Resources</a> in the
    ///             <i>AWS General Reference</i>. Once the resource is created, you can
    ///             use <a>TagResource</a>, <a>UntagResource</a>, and
    ///             <a>ListTagsForResource</a> to add, remove, and view tags. The
    ///             maximum tag limit may be lower than stated. See the AWS General Reference for actual
    ///             tagging limits.</p>
    public let tags: [Tag]?

    public init (
        acceptanceRequired: Bool? = nil,
        acceptanceTimeoutSeconds: Int? = nil,
        additionalPlayerCount: Int? = nil,
        backfillMode: BackfillMode? = nil,
        customEventData: String? = nil,
        description: String? = nil,
        flexMatchMode: FlexMatchMode? = nil,
        gameProperties: [GameProperty]? = nil,
        gameSessionData: String? = nil,
        gameSessionQueueArns: [String]? = nil,
        name: String? = nil,
        notificationTarget: String? = nil,
        requestTimeoutSeconds: Int? = nil,
        ruleSetName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.acceptanceRequired = acceptanceRequired
        self.acceptanceTimeoutSeconds = acceptanceTimeoutSeconds
        self.additionalPlayerCount = additionalPlayerCount
        self.backfillMode = backfillMode
        self.customEventData = customEventData
        self.description = description
        self.flexMatchMode = flexMatchMode
        self.gameProperties = gameProperties
        self.gameSessionData = gameSessionData
        self.gameSessionQueueArns = gameSessionQueueArns
        self.name = name
        self.notificationTarget = notificationTarget
        self.requestTimeoutSeconds = requestTimeoutSeconds
        self.ruleSetName = ruleSetName
        self.tags = tags
    }
}

extension CreateMatchmakingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMatchmakingConfigurationInput(acceptanceRequired: \(String(describing: acceptanceRequired)), acceptanceTimeoutSeconds: \(String(describing: acceptanceTimeoutSeconds)), additionalPlayerCount: \(String(describing: additionalPlayerCount)), backfillMode: \(String(describing: backfillMode)), customEventData: \(String(describing: customEventData)), description: \(String(describing: description)), flexMatchMode: \(String(describing: flexMatchMode)), gameProperties: \(String(describing: gameProperties)), gameSessionData: \(String(describing: gameSessionData)), gameSessionQueueArns: \(String(describing: gameSessionQueueArns)), name: \(String(describing: name)), notificationTarget: \(String(describing: notificationTarget)), requestTimeoutSeconds: \(String(describing: requestTimeoutSeconds)), ruleSetName: \(String(describing: ruleSetName)), tags: \(String(describing: tags)))"}
}
