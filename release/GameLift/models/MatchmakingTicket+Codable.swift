// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension MatchmakingTicket: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationArn = "ConfigurationArn"
        case configurationName = "ConfigurationName"
        case endTime = "EndTime"
        case estimatedWaitTime = "EstimatedWaitTime"
        case gameSessionConnectionInfo = "GameSessionConnectionInfo"
        case players = "Players"
        case startTime = "StartTime"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case statusReason = "StatusReason"
        case ticketId = "TicketId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationArn = configurationArn {
            try encodeContainer.encode(configurationArn, forKey: .configurationArn)
        }
        if let configurationName = configurationName {
            try encodeContainer.encode(configurationName, forKey: .configurationName)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let estimatedWaitTime = estimatedWaitTime {
            try encodeContainer.encode(estimatedWaitTime, forKey: .estimatedWaitTime)
        }
        if let gameSessionConnectionInfo = gameSessionConnectionInfo {
            try encodeContainer.encode(gameSessionConnectionInfo, forKey: .gameSessionConnectionInfo)
        }
        if let players = players {
            var playersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .players)
            for playerlist0 in players {
                try playersContainer.encode(playerlist0)
            }
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let ticketId = ticketId {
            try encodeContainer.encode(ticketId, forKey: .ticketId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ticketIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ticketId)
        ticketId = ticketIdDecoded
        let configurationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationName)
        configurationName = configurationNameDecoded
        let configurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationArn)
        configurationArn = configurationArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MatchmakingConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let playersContainer = try containerValues.decodeIfPresent([Player?].self, forKey: .players)
        var playersDecoded0:[Player]? = nil
        if let playersContainer = playersContainer {
            playersDecoded0 = [Player]()
            for structure0 in playersContainer {
                if let structure0 = structure0 {
                    playersDecoded0?.append(structure0)
                }
            }
        }
        players = playersDecoded0
        let gameSessionConnectionInfoDecoded = try containerValues.decodeIfPresent(GameSessionConnectionInfo.self, forKey: .gameSessionConnectionInfo)
        gameSessionConnectionInfo = gameSessionConnectionInfoDecoded
        let estimatedWaitTimeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .estimatedWaitTime)
        estimatedWaitTime = estimatedWaitTimeDecoded
    }
}
