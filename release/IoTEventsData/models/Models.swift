// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AcknowledgeActionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case note
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noteDecoded = try containerValues.decodeIfPresent(String.self, forKey: .note)
        note = noteDecoded
    }
}

extension AcknowledgeActionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcknowledgeActionConfiguration(note: \(String(describing: note)))"}
}

/// <p>Contains the configuration information of an acknowledge action.</p>
public struct AcknowledgeActionConfiguration: Equatable {
    /// <p>The note that you can leave when you acknowledge the alarm.</p>
    public let note: String?

    public init (
        note: String? = nil
    )
    {
        self.note = note
    }
}

extension AcknowledgeAlarmActionRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alarmModelName
        case keyValue
        case note
        case requestId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelName = alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let keyValue = keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let noteDecoded = try containerValues.decodeIfPresent(String.self, forKey: .note)
        note = noteDecoded
    }
}

extension AcknowledgeAlarmActionRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcknowledgeAlarmActionRequest(alarmModelName: \(String(describing: alarmModelName)), keyValue: \(String(describing: keyValue)), note: \(String(describing: note)), requestId: \(String(describing: requestId)))"}
}

/// <p>Information needed to acknowledge the alarm.</p>
public struct AcknowledgeAlarmActionRequest: Equatable {
    /// <p>The name of the alarm model.</p>
    public let alarmModelName: String?
    /// <p>The value of the key used as a filter to select only the alarms associated with the
    /// <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key">key</a>.</p>
    public let keyValue: String?
    /// <p>The note that you can leave when you acknowledge the alarm.</p>
    public let note: String?
    /// <p>The request ID. Each ID must be unique within each batch.</p>
    public let requestId: String?

    public init (
        alarmModelName: String? = nil,
        keyValue: String? = nil,
        note: String? = nil,
        requestId: String? = nil
    )
    {
        self.alarmModelName = alarmModelName
        self.keyValue = keyValue
        self.note = note
        self.requestId = requestId
    }
}

extension Alarm: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alarmModelName
        case alarmModelVersion
        case alarmState
        case creationTime
        case keyValue
        case lastUpdateTime
        case severity
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelName = alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let alarmModelVersion = alarmModelVersion {
            try encodeContainer.encode(alarmModelVersion, forKey: .alarmModelVersion)
        }
        if let alarmState = alarmState {
            try encodeContainer.encode(alarmState, forKey: .alarmState)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let keyValue = keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let alarmModelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelVersion)
        alarmModelVersion = alarmModelVersionDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let alarmStateDecoded = try containerValues.decodeIfPresent(AlarmState.self, forKey: .alarmState)
        alarmState = alarmStateDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .severity)
        severity = severityDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension Alarm: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Alarm(alarmModelName: \(String(describing: alarmModelName)), alarmModelVersion: \(String(describing: alarmModelVersion)), alarmState: \(String(describing: alarmState)), creationTime: \(String(describing: creationTime)), keyValue: \(String(describing: keyValue)), lastUpdateTime: \(String(describing: lastUpdateTime)), severity: \(String(describing: severity)))"}
}

/// <p>Contains information about an alarm.</p>
public struct Alarm: Equatable {
    /// <p>The name of the alarm model.</p>
    public let alarmModelName: String?
    /// <p>The version of the alarm model.</p>
    public let alarmModelVersion: String?
    /// <p>Contains information about the current state of the alarm.</p>
    public let alarmState: AlarmState?
    /// <p>The time the alarm was created, in the Unix epoch format.</p>
    public let creationTime: Date?
    /// <p>The value of the key used as a filter to select only the alarms associated with the
    /// <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key">key</a>.</p>
    public let keyValue: String?
    /// <p>The time the alarm was last updated, in the Unix epoch format.</p>
    public let lastUpdateTime: Date?
    /// <p>A non-negative integer that reflects the severity level of the alarm.</p>
    public let severity: Int?

    public init (
        alarmModelName: String? = nil,
        alarmModelVersion: String? = nil,
        alarmState: AlarmState? = nil,
        creationTime: Date? = nil,
        keyValue: String? = nil,
        lastUpdateTime: Date? = nil,
        severity: Int? = nil
    )
    {
        self.alarmModelName = alarmModelName
        self.alarmModelVersion = alarmModelVersion
        self.alarmState = alarmState
        self.creationTime = creationTime
        self.keyValue = keyValue
        self.lastUpdateTime = lastUpdateTime
        self.severity = severity
    }
}

extension AlarmState: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customerAction
        case ruleEvaluation
        case stateName
        case systemEvent
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerAction = customerAction {
            try encodeContainer.encode(customerAction, forKey: .customerAction)
        }
        if let ruleEvaluation = ruleEvaluation {
            try encodeContainer.encode(ruleEvaluation, forKey: .ruleEvaluation)
        }
        if let stateName = stateName {
            try encodeContainer.encode(stateName.rawValue, forKey: .stateName)
        }
        if let systemEvent = systemEvent {
            try encodeContainer.encode(systemEvent, forKey: .systemEvent)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateNameDecoded = try containerValues.decodeIfPresent(AlarmStateName.self, forKey: .stateName)
        stateName = stateNameDecoded
        let ruleEvaluationDecoded = try containerValues.decodeIfPresent(RuleEvaluation.self, forKey: .ruleEvaluation)
        ruleEvaluation = ruleEvaluationDecoded
        let customerActionDecoded = try containerValues.decodeIfPresent(CustomerAction.self, forKey: .customerAction)
        customerAction = customerActionDecoded
        let systemEventDecoded = try containerValues.decodeIfPresent(SystemEvent.self, forKey: .systemEvent)
        systemEvent = systemEventDecoded
    }
}

extension AlarmState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlarmState(customerAction: \(String(describing: customerAction)), ruleEvaluation: \(String(describing: ruleEvaluation)), stateName: \(String(describing: stateName)), systemEvent: \(String(describing: systemEvent)))"}
}

/// <p>Contains information about the current state of the alarm.</p>
public struct AlarmState: Equatable {
    /// <p>Contains information about the action that you can take to respond to the alarm.</p>
    public let customerAction: CustomerAction?
    /// <p>Information needed to evaluate data.</p>
    public let ruleEvaluation: RuleEvaluation?
    /// <p>The name of the alarm state. The state name can be one of the following values:</p>
    ///          <ul>
    ///             <li>
    /// 		             <p>
    ///                   <code>DISABLED</code> - When the alarm is in the <code>DISABLED</code> state,
    /// 		it isn't ready to evaluate data. To enable the alarm,
    /// 		you must change the alarm to the <code>NORMAL</code> state.</p>
    /// 	           </li>
    ///             <li>
    /// 		             <p>
    ///                   <code>NORMAL</code> - When the alarm is in the <code>NORMAL</code> state,
    /// 		it's ready to evaluate data.</p>
    /// 	           </li>
    ///             <li>
    /// 		             <p>
    ///                   <code>ACTIVE</code> - If the alarm is in the <code>ACTIVE</code> state,
    /// 		the alarm is invoked.</p>
    /// 	           </li>
    ///             <li>
    /// 		             <p>
    ///                   <code>ACKNOWLEDGED</code> - When the alarm is in the <code>ACKNOWLEDGED</code> state,
    /// 		the alarm was invoked and you acknowledged the alarm.</p>
    /// 	           </li>
    ///             <li>
    /// 		             <p>
    ///                   <code>SNOOZE_DISABLED</code> - When the alarm is in the <code>SNOOZE_DISABLED</code> state,
    /// 		the alarm is disabled for a specified period of time. After the snooze time,
    /// 		the alarm automatically changes to the <code>NORMAL</code> state. </p>
    /// 	           </li>
    ///             <li>
    /// 		             <p>
    ///                   <code>LATCHED</code> - When the alarm is in the <code>LATCHED</code> state,
    /// 		the alarm was invoked. However, the data that the alarm is currently evaluating is within the specified range.
    /// 		To change the alarm to the <code>NORMAL</code> state, you must acknowledge the alarm.</p>
    /// 	           </li>
    ///          </ul>
    public let stateName: AlarmStateName?
    /// <p>Contains information about alarm state changes.</p>
    public let systemEvent: SystemEvent?

    public init (
        customerAction: CustomerAction? = nil,
        ruleEvaluation: RuleEvaluation? = nil,
        stateName: AlarmStateName? = nil,
        systemEvent: SystemEvent? = nil
    )
    {
        self.customerAction = customerAction
        self.ruleEvaluation = ruleEvaluation
        self.stateName = stateName
        self.systemEvent = systemEvent
    }
}

public enum AlarmStateName {
    case acknowledged
    case active
    case disabled
    case latched
    case normal
    case snoozeDisabled
    case sdkUnknown(String)
}

extension AlarmStateName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AlarmStateName] {
        return [
            .acknowledged,
            .active,
            .disabled,
            .latched,
            .normal,
            .snoozeDisabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .acknowledged: return "ACKNOWLEDGED"
        case .active: return "ACTIVE"
        case .disabled: return "DISABLED"
        case .latched: return "LATCHED"
        case .normal: return "NORMAL"
        case .snoozeDisabled: return "SNOOZE_DISABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AlarmStateName(rawValue: rawValue) ?? AlarmStateName.sdkUnknown(rawValue)
    }
}

extension AlarmSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alarmModelName
        case alarmModelVersion
        case creationTime
        case keyValue
        case lastUpdateTime
        case stateName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelName = alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let alarmModelVersion = alarmModelVersion {
            try encodeContainer.encode(alarmModelVersion, forKey: .alarmModelVersion)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let keyValue = keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let stateName = stateName {
            try encodeContainer.encode(stateName.rawValue, forKey: .stateName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let alarmModelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelVersion)
        alarmModelVersion = alarmModelVersionDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let stateNameDecoded = try containerValues.decodeIfPresent(AlarmStateName.self, forKey: .stateName)
        stateName = stateNameDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension AlarmSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlarmSummary(alarmModelName: \(String(describing: alarmModelName)), alarmModelVersion: \(String(describing: alarmModelVersion)), creationTime: \(String(describing: creationTime)), keyValue: \(String(describing: keyValue)), lastUpdateTime: \(String(describing: lastUpdateTime)), stateName: \(String(describing: stateName)))"}
}

/// <p>Contains a summary of an alarm.</p>
public struct AlarmSummary: Equatable {
    /// <p>The name of the alarm model.</p>
    public let alarmModelName: String?
    /// <p>The version of the alarm model.</p>
    public let alarmModelVersion: String?
    /// <p>The time the alarm was created, in the Unix epoch format.</p>
    public let creationTime: Date?
    /// <p>The value of the key used as a filter to select only the alarms associated with the
    /// <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key">key</a>.</p>
    public let keyValue: String?
    /// <p>The time the alarm was last updated, in the Unix epoch format.</p>
    public let lastUpdateTime: Date?
    /// <p>The name of the alarm state. The state name can be one of the following values:</p>
    ///          <ul>
    ///             <li>
    /// 		             <p>
    ///                   <code>DISABLED</code> - When the alarm is in the <code>DISABLED</code> state,
    /// 		it isn't ready to evaluate data. To enable the alarm,
    /// 		you must change the alarm to the <code>NORMAL</code> state.</p>
    /// 	           </li>
    ///             <li>
    /// 		             <p>
    ///                   <code>NORMAL</code> - When the alarm is in the <code>NORMAL</code> state,
    /// 		it's ready to evaluate data.</p>
    /// 	           </li>
    ///             <li>
    /// 		             <p>
    ///                   <code>ACTIVE</code> - If the alarm is in the <code>ACTIVE</code> state,
    /// 		the alarm is invoked.</p>
    /// 	           </li>
    ///             <li>
    /// 		             <p>
    ///                   <code>ACKNOWLEDGED</code> - When the alarm is in the <code>ACKNOWLEDGED</code> state,
    /// 		the alarm was invoked and you acknowledged the alarm.</p>
    /// 	           </li>
    ///             <li>
    /// 		             <p>
    ///                   <code>SNOOZE_DISABLED</code> - When the alarm is in the <code>SNOOZE_DISABLED</code> state,
    /// 		the alarm is disabled for a specified period of time. After the snooze time,
    /// 		the alarm automatically changes to the <code>NORMAL</code> state. </p>
    /// 	           </li>
    ///             <li>
    /// 		             <p>
    ///                   <code>LATCHED</code> - When the alarm is in the <code>LATCHED</code> state,
    /// 		the alarm was invoked. However, the data that the alarm is currently evaluating is within the specified range.
    /// 		To change the alarm to the <code>NORMAL</code> state, you must acknowledge the alarm.</p>
    /// 	           </li>
    ///          </ul>
    public let stateName: AlarmStateName?

    public init (
        alarmModelName: String? = nil,
        alarmModelVersion: String? = nil,
        creationTime: Date? = nil,
        keyValue: String? = nil,
        lastUpdateTime: Date? = nil,
        stateName: AlarmStateName? = nil
    )
    {
        self.alarmModelName = alarmModelName
        self.alarmModelVersion = alarmModelVersion
        self.creationTime = creationTime
        self.keyValue = keyValue
        self.lastUpdateTime = lastUpdateTime
        self.stateName = stateName
    }
}

public struct BatchAcknowledgeAlarmInputBodyMiddleware: Middleware {
    public let id: String = "BatchAcknowledgeAlarmInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchAcknowledgeAlarmInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchAcknowledgeAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchAcknowledgeAlarmInput>
    public typealias MOutput = OperationOutput<BatchAcknowledgeAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchAcknowledgeAlarmOutputError>
}

extension BatchAcknowledgeAlarmInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAcknowledgeAlarmInput(acknowledgeActionRequests: \(String(describing: acknowledgeActionRequests)))"}
}

extension BatchAcknowledgeAlarmInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acknowledgeActionRequests
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acknowledgeActionRequests = acknowledgeActionRequests {
            var acknowledgeActionRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .acknowledgeActionRequests)
            for acknowledgealarmactionrequests0 in acknowledgeActionRequests {
                try acknowledgeActionRequestsContainer.encode(acknowledgealarmactionrequests0)
            }
        }
    }
}

public struct BatchAcknowledgeAlarmInputHeadersMiddleware: Middleware {
    public let id: String = "BatchAcknowledgeAlarmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchAcknowledgeAlarmInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchAcknowledgeAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchAcknowledgeAlarmInput>
    public typealias MOutput = OperationOutput<BatchAcknowledgeAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchAcknowledgeAlarmOutputError>
}

public struct BatchAcknowledgeAlarmInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchAcknowledgeAlarmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchAcknowledgeAlarmInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchAcknowledgeAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchAcknowledgeAlarmInput>
    public typealias MOutput = OperationOutput<BatchAcknowledgeAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchAcknowledgeAlarmOutputError>
}

public struct BatchAcknowledgeAlarmInput: Equatable {
    /// <p>The list of acknowledge action requests. You can specify up to 10 requests per operation.</p>
    public let acknowledgeActionRequests: [AcknowledgeAlarmActionRequest]?

    public init (
        acknowledgeActionRequests: [AcknowledgeAlarmActionRequest]? = nil
    )
    {
        self.acknowledgeActionRequests = acknowledgeActionRequests
    }
}

struct BatchAcknowledgeAlarmInputBody: Equatable {
    public let acknowledgeActionRequests: [AcknowledgeAlarmActionRequest]?
}

extension BatchAcknowledgeAlarmInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acknowledgeActionRequests
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acknowledgeActionRequestsContainer = try containerValues.decodeIfPresent([AcknowledgeAlarmActionRequest?].self, forKey: .acknowledgeActionRequests)
        var acknowledgeActionRequestsDecoded0:[AcknowledgeAlarmActionRequest]? = nil
        if let acknowledgeActionRequestsContainer = acknowledgeActionRequestsContainer {
            acknowledgeActionRequestsDecoded0 = [AcknowledgeAlarmActionRequest]()
            for structure0 in acknowledgeActionRequestsContainer {
                if let structure0 = structure0 {
                    acknowledgeActionRequestsDecoded0?.append(structure0)
                }
            }
        }
        acknowledgeActionRequests = acknowledgeActionRequestsDecoded0
    }
}

extension BatchAcknowledgeAlarmOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchAcknowledgeAlarmOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchAcknowledgeAlarmOutputError: Swift.Error, Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchAcknowledgeAlarmOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAcknowledgeAlarmOutputResponse(errorEntries: \(String(describing: errorEntries)))"}
}

extension BatchAcknowledgeAlarmOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchAcknowledgeAlarmOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchAcknowledgeAlarmOutputResponse: Equatable {
    /// <p>A list of errors associated with the request, or <code>null</code> if there are no errors.
    /// Each error entry contains an entry ID that helps you identify the entry that failed.</p>
    public let errorEntries: [BatchAlarmActionErrorEntry]?

    public init (
        errorEntries: [BatchAlarmActionErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchAcknowledgeAlarmOutputResponseBody: Equatable {
    public let errorEntries: [BatchAlarmActionErrorEntry]?
}

extension BatchAcknowledgeAlarmOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorEntries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([BatchAlarmActionErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[BatchAlarmActionErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [BatchAlarmActionErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

extension BatchAlarmActionErrorEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode
        case errorMessage
        case requestId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension BatchAlarmActionErrorEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAlarmActionErrorEntry(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), requestId: \(String(describing: requestId)))"}
}

/// <p>Contains error messages associated with one of the following requests:</p>
///          <ul>
///             <li>
///                <p>
///                   <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchAcknowledgeAlarm.html">BatchAcknowledgeAlarm</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchDisableAlarm.html">BatchDisableAlarm</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchEnableAlarm.html">BatchEnableAlarm</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchResetAlarm.html">BatchResetAlarm</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchSnoozeAlarm.html">BatchSnoozeAlarm</a>
///                </p>
///             </li>
///          </ul>
public struct BatchAlarmActionErrorEntry: Equatable {
    /// <p>The error code.</p>
    public let errorCode: ErrorCode?
    /// <p>A message that describes the error.</p>
    public let errorMessage: String?
    /// <p>The request ID. Each ID must be unique within each batch.</p>
    public let requestId: String?

    public init (
        errorCode: ErrorCode? = nil,
        errorMessage: String? = nil,
        requestId: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.requestId = requestId
    }
}

public struct BatchDisableAlarmInputBodyMiddleware: Middleware {
    public let id: String = "BatchDisableAlarmInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisableAlarmInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisableAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisableAlarmInput>
    public typealias MOutput = OperationOutput<BatchDisableAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisableAlarmOutputError>
}

extension BatchDisableAlarmInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDisableAlarmInput(disableActionRequests: \(String(describing: disableActionRequests)))"}
}

extension BatchDisableAlarmInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case disableActionRequests
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disableActionRequests = disableActionRequests {
            var disableActionRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .disableActionRequests)
            for disablealarmactionrequests0 in disableActionRequests {
                try disableActionRequestsContainer.encode(disablealarmactionrequests0)
            }
        }
    }
}

public struct BatchDisableAlarmInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDisableAlarmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisableAlarmInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisableAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisableAlarmInput>
    public typealias MOutput = OperationOutput<BatchDisableAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisableAlarmOutputError>
}

public struct BatchDisableAlarmInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDisableAlarmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisableAlarmInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisableAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisableAlarmInput>
    public typealias MOutput = OperationOutput<BatchDisableAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisableAlarmOutputError>
}

public struct BatchDisableAlarmInput: Equatable {
    /// <p>The list of disable action requests. You can specify up to 10 requests per operation.</p>
    public let disableActionRequests: [DisableAlarmActionRequest]?

    public init (
        disableActionRequests: [DisableAlarmActionRequest]? = nil
    )
    {
        self.disableActionRequests = disableActionRequests
    }
}

struct BatchDisableAlarmInputBody: Equatable {
    public let disableActionRequests: [DisableAlarmActionRequest]?
}

extension BatchDisableAlarmInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case disableActionRequests
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disableActionRequestsContainer = try containerValues.decodeIfPresent([DisableAlarmActionRequest?].self, forKey: .disableActionRequests)
        var disableActionRequestsDecoded0:[DisableAlarmActionRequest]? = nil
        if let disableActionRequestsContainer = disableActionRequestsContainer {
            disableActionRequestsDecoded0 = [DisableAlarmActionRequest]()
            for structure0 in disableActionRequestsContainer {
                if let structure0 = structure0 {
                    disableActionRequestsDecoded0?.append(structure0)
                }
            }
        }
        disableActionRequests = disableActionRequestsDecoded0
    }
}

extension BatchDisableAlarmOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDisableAlarmOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDisableAlarmOutputError: Swift.Error, Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDisableAlarmOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDisableAlarmOutputResponse(errorEntries: \(String(describing: errorEntries)))"}
}

extension BatchDisableAlarmOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDisableAlarmOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchDisableAlarmOutputResponse: Equatable {
    /// <p>A list of errors associated with the request, or <code>null</code> if there are no errors.
    /// Each error entry contains an entry ID that helps you identify the entry that failed.</p>
    public let errorEntries: [BatchAlarmActionErrorEntry]?

    public init (
        errorEntries: [BatchAlarmActionErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchDisableAlarmOutputResponseBody: Equatable {
    public let errorEntries: [BatchAlarmActionErrorEntry]?
}

extension BatchDisableAlarmOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorEntries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([BatchAlarmActionErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[BatchAlarmActionErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [BatchAlarmActionErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

public struct BatchEnableAlarmInputBodyMiddleware: Middleware {
    public let id: String = "BatchEnableAlarmInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchEnableAlarmInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchEnableAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchEnableAlarmInput>
    public typealias MOutput = OperationOutput<BatchEnableAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchEnableAlarmOutputError>
}

extension BatchEnableAlarmInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchEnableAlarmInput(enableActionRequests: \(String(describing: enableActionRequests)))"}
}

extension BatchEnableAlarmInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enableActionRequests
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableActionRequests = enableActionRequests {
            var enableActionRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .enableActionRequests)
            for enablealarmactionrequests0 in enableActionRequests {
                try enableActionRequestsContainer.encode(enablealarmactionrequests0)
            }
        }
    }
}

public struct BatchEnableAlarmInputHeadersMiddleware: Middleware {
    public let id: String = "BatchEnableAlarmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchEnableAlarmInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchEnableAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchEnableAlarmInput>
    public typealias MOutput = OperationOutput<BatchEnableAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchEnableAlarmOutputError>
}

public struct BatchEnableAlarmInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchEnableAlarmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchEnableAlarmInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchEnableAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchEnableAlarmInput>
    public typealias MOutput = OperationOutput<BatchEnableAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchEnableAlarmOutputError>
}

public struct BatchEnableAlarmInput: Equatable {
    /// <p>The list of enable action requests. You can specify up to 10 requests per operation.</p>
    public let enableActionRequests: [EnableAlarmActionRequest]?

    public init (
        enableActionRequests: [EnableAlarmActionRequest]? = nil
    )
    {
        self.enableActionRequests = enableActionRequests
    }
}

struct BatchEnableAlarmInputBody: Equatable {
    public let enableActionRequests: [EnableAlarmActionRequest]?
}

extension BatchEnableAlarmInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case enableActionRequests
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableActionRequestsContainer = try containerValues.decodeIfPresent([EnableAlarmActionRequest?].self, forKey: .enableActionRequests)
        var enableActionRequestsDecoded0:[EnableAlarmActionRequest]? = nil
        if let enableActionRequestsContainer = enableActionRequestsContainer {
            enableActionRequestsDecoded0 = [EnableAlarmActionRequest]()
            for structure0 in enableActionRequestsContainer {
                if let structure0 = structure0 {
                    enableActionRequestsDecoded0?.append(structure0)
                }
            }
        }
        enableActionRequests = enableActionRequestsDecoded0
    }
}

extension BatchEnableAlarmOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchEnableAlarmOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchEnableAlarmOutputError: Swift.Error, Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchEnableAlarmOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchEnableAlarmOutputResponse(errorEntries: \(String(describing: errorEntries)))"}
}

extension BatchEnableAlarmOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchEnableAlarmOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchEnableAlarmOutputResponse: Equatable {
    /// <p>A list of errors associated with the request, or <code>null</code> if there are no errors.
    /// Each error entry contains an entry ID that helps you identify the entry that failed.</p>
    public let errorEntries: [BatchAlarmActionErrorEntry]?

    public init (
        errorEntries: [BatchAlarmActionErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchEnableAlarmOutputResponseBody: Equatable {
    public let errorEntries: [BatchAlarmActionErrorEntry]?
}

extension BatchEnableAlarmOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorEntries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([BatchAlarmActionErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[BatchAlarmActionErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [BatchAlarmActionErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

extension BatchPutMessageErrorEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode
        case errorMessage
        case messageId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension BatchPutMessageErrorEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchPutMessageErrorEntry(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), messageId: \(String(describing: messageId)))"}
}

/// <p>Contains information about the errors encountered.</p>
public struct BatchPutMessageErrorEntry: Equatable {
    /// <p>The error code.</p>
    public let errorCode: ErrorCode?
    /// <p>A message that describes the error.</p>
    public let errorMessage: String?
    /// <p>The ID of the message that caused the error. (See the value corresponding to the
    ///         <code>"messageId"</code> key in the <code>"message"</code> object.)</p>
    public let messageId: String?

    public init (
        errorCode: ErrorCode? = nil,
        errorMessage: String? = nil,
        messageId: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.messageId = messageId
    }
}

public struct BatchPutMessageInputBodyMiddleware: Middleware {
    public let id: String = "BatchPutMessageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchPutMessageInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchPutMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchPutMessageInput>
    public typealias MOutput = OperationOutput<BatchPutMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchPutMessageOutputError>
}

extension BatchPutMessageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchPutMessageInput(messages: \(String(describing: messages)))"}
}

extension BatchPutMessageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case messages
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messages = messages {
            var messagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messages)
            for messages0 in messages {
                try messagesContainer.encode(messages0)
            }
        }
    }
}

public struct BatchPutMessageInputHeadersMiddleware: Middleware {
    public let id: String = "BatchPutMessageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchPutMessageInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchPutMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchPutMessageInput>
    public typealias MOutput = OperationOutput<BatchPutMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchPutMessageOutputError>
}

public struct BatchPutMessageInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchPutMessageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchPutMessageInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchPutMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchPutMessageInput>
    public typealias MOutput = OperationOutput<BatchPutMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchPutMessageOutputError>
}

public struct BatchPutMessageInput: Equatable {
    /// <p>The list of messages to send. Each message has the following format: <code>'{ "messageId":
    ///         "string", "inputName": "string", "payload": "string"}'</code>
    ///          </p>
    public let messages: [Message]?

    public init (
        messages: [Message]? = nil
    )
    {
        self.messages = messages
    }
}

struct BatchPutMessageInputBody: Equatable {
    public let messages: [Message]?
}

extension BatchPutMessageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messages
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messagesContainer = try containerValues.decodeIfPresent([Message?].self, forKey: .messages)
        var messagesDecoded0:[Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
    }
}

extension BatchPutMessageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchPutMessageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchPutMessageOutputError: Swift.Error, Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchPutMessageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchPutMessageOutputResponse(batchPutMessageErrorEntries: \(String(describing: batchPutMessageErrorEntries)))"}
}

extension BatchPutMessageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchPutMessageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.batchPutMessageErrorEntries = output.batchPutMessageErrorEntries
        } else {
            self.batchPutMessageErrorEntries = nil
        }
    }
}

public struct BatchPutMessageOutputResponse: Equatable {
    /// <p>A list of any errors encountered when sending the messages.</p>
    public let batchPutMessageErrorEntries: [BatchPutMessageErrorEntry]?

    public init (
        batchPutMessageErrorEntries: [BatchPutMessageErrorEntry]? = nil
    )
    {
        self.batchPutMessageErrorEntries = batchPutMessageErrorEntries
    }
}

struct BatchPutMessageOutputResponseBody: Equatable {
    public let batchPutMessageErrorEntries: [BatchPutMessageErrorEntry]?
}

extension BatchPutMessageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case batchPutMessageErrorEntries = "BatchPutMessageErrorEntries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchPutMessageErrorEntriesContainer = try containerValues.decodeIfPresent([BatchPutMessageErrorEntry?].self, forKey: .batchPutMessageErrorEntries)
        var batchPutMessageErrorEntriesDecoded0:[BatchPutMessageErrorEntry]? = nil
        if let batchPutMessageErrorEntriesContainer = batchPutMessageErrorEntriesContainer {
            batchPutMessageErrorEntriesDecoded0 = [BatchPutMessageErrorEntry]()
            for structure0 in batchPutMessageErrorEntriesContainer {
                if let structure0 = structure0 {
                    batchPutMessageErrorEntriesDecoded0?.append(structure0)
                }
            }
        }
        batchPutMessageErrorEntries = batchPutMessageErrorEntriesDecoded0
    }
}

public struct BatchResetAlarmInputBodyMiddleware: Middleware {
    public let id: String = "BatchResetAlarmInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchResetAlarmInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchResetAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchResetAlarmInput>
    public typealias MOutput = OperationOutput<BatchResetAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchResetAlarmOutputError>
}

extension BatchResetAlarmInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchResetAlarmInput(resetActionRequests: \(String(describing: resetActionRequests)))"}
}

extension BatchResetAlarmInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resetActionRequests
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resetActionRequests = resetActionRequests {
            var resetActionRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resetActionRequests)
            for resetalarmactionrequests0 in resetActionRequests {
                try resetActionRequestsContainer.encode(resetalarmactionrequests0)
            }
        }
    }
}

public struct BatchResetAlarmInputHeadersMiddleware: Middleware {
    public let id: String = "BatchResetAlarmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchResetAlarmInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchResetAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchResetAlarmInput>
    public typealias MOutput = OperationOutput<BatchResetAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchResetAlarmOutputError>
}

public struct BatchResetAlarmInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchResetAlarmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchResetAlarmInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchResetAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchResetAlarmInput>
    public typealias MOutput = OperationOutput<BatchResetAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchResetAlarmOutputError>
}

public struct BatchResetAlarmInput: Equatable {
    /// <p>The list of reset action requests. You can specify up to 10 requests per operation.</p>
    public let resetActionRequests: [ResetAlarmActionRequest]?

    public init (
        resetActionRequests: [ResetAlarmActionRequest]? = nil
    )
    {
        self.resetActionRequests = resetActionRequests
    }
}

struct BatchResetAlarmInputBody: Equatable {
    public let resetActionRequests: [ResetAlarmActionRequest]?
}

extension BatchResetAlarmInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resetActionRequests
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resetActionRequestsContainer = try containerValues.decodeIfPresent([ResetAlarmActionRequest?].self, forKey: .resetActionRequests)
        var resetActionRequestsDecoded0:[ResetAlarmActionRequest]? = nil
        if let resetActionRequestsContainer = resetActionRequestsContainer {
            resetActionRequestsDecoded0 = [ResetAlarmActionRequest]()
            for structure0 in resetActionRequestsContainer {
                if let structure0 = structure0 {
                    resetActionRequestsDecoded0?.append(structure0)
                }
            }
        }
        resetActionRequests = resetActionRequestsDecoded0
    }
}

extension BatchResetAlarmOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchResetAlarmOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchResetAlarmOutputError: Swift.Error, Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchResetAlarmOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchResetAlarmOutputResponse(errorEntries: \(String(describing: errorEntries)))"}
}

extension BatchResetAlarmOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchResetAlarmOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchResetAlarmOutputResponse: Equatable {
    /// <p>A list of errors associated with the request, or <code>null</code> if there are no errors.
    /// Each error entry contains an entry ID that helps you identify the entry that failed.</p>
    public let errorEntries: [BatchAlarmActionErrorEntry]?

    public init (
        errorEntries: [BatchAlarmActionErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchResetAlarmOutputResponseBody: Equatable {
    public let errorEntries: [BatchAlarmActionErrorEntry]?
}

extension BatchResetAlarmOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorEntries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([BatchAlarmActionErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[BatchAlarmActionErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [BatchAlarmActionErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

public struct BatchSnoozeAlarmInputBodyMiddleware: Middleware {
    public let id: String = "BatchSnoozeAlarmInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchSnoozeAlarmInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchSnoozeAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchSnoozeAlarmInput>
    public typealias MOutput = OperationOutput<BatchSnoozeAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchSnoozeAlarmOutputError>
}

extension BatchSnoozeAlarmInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchSnoozeAlarmInput(snoozeActionRequests: \(String(describing: snoozeActionRequests)))"}
}

extension BatchSnoozeAlarmInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case snoozeActionRequests
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snoozeActionRequests = snoozeActionRequests {
            var snoozeActionRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .snoozeActionRequests)
            for snoozealarmactionrequests0 in snoozeActionRequests {
                try snoozeActionRequestsContainer.encode(snoozealarmactionrequests0)
            }
        }
    }
}

public struct BatchSnoozeAlarmInputHeadersMiddleware: Middleware {
    public let id: String = "BatchSnoozeAlarmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchSnoozeAlarmInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchSnoozeAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchSnoozeAlarmInput>
    public typealias MOutput = OperationOutput<BatchSnoozeAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchSnoozeAlarmOutputError>
}

public struct BatchSnoozeAlarmInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchSnoozeAlarmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchSnoozeAlarmInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchSnoozeAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchSnoozeAlarmInput>
    public typealias MOutput = OperationOutput<BatchSnoozeAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchSnoozeAlarmOutputError>
}

public struct BatchSnoozeAlarmInput: Equatable {
    /// <p>The list of snooze action requests. You can specify up to 10 requests per operation.</p>
    public let snoozeActionRequests: [SnoozeAlarmActionRequest]?

    public init (
        snoozeActionRequests: [SnoozeAlarmActionRequest]? = nil
    )
    {
        self.snoozeActionRequests = snoozeActionRequests
    }
}

struct BatchSnoozeAlarmInputBody: Equatable {
    public let snoozeActionRequests: [SnoozeAlarmActionRequest]?
}

extension BatchSnoozeAlarmInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case snoozeActionRequests
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snoozeActionRequestsContainer = try containerValues.decodeIfPresent([SnoozeAlarmActionRequest?].self, forKey: .snoozeActionRequests)
        var snoozeActionRequestsDecoded0:[SnoozeAlarmActionRequest]? = nil
        if let snoozeActionRequestsContainer = snoozeActionRequestsContainer {
            snoozeActionRequestsDecoded0 = [SnoozeAlarmActionRequest]()
            for structure0 in snoozeActionRequestsContainer {
                if let structure0 = structure0 {
                    snoozeActionRequestsDecoded0?.append(structure0)
                }
            }
        }
        snoozeActionRequests = snoozeActionRequestsDecoded0
    }
}

extension BatchSnoozeAlarmOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchSnoozeAlarmOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchSnoozeAlarmOutputError: Swift.Error, Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchSnoozeAlarmOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchSnoozeAlarmOutputResponse(errorEntries: \(String(describing: errorEntries)))"}
}

extension BatchSnoozeAlarmOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchSnoozeAlarmOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchSnoozeAlarmOutputResponse: Equatable {
    /// <p>A list of errors associated with the request, or <code>null</code> if there are no errors.
    /// Each error entry contains an entry ID that helps you identify the entry that failed.</p>
    public let errorEntries: [BatchAlarmActionErrorEntry]?

    public init (
        errorEntries: [BatchAlarmActionErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchSnoozeAlarmOutputResponseBody: Equatable {
    public let errorEntries: [BatchAlarmActionErrorEntry]?
}

extension BatchSnoozeAlarmOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorEntries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([BatchAlarmActionErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[BatchAlarmActionErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [BatchAlarmActionErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

extension BatchUpdateDetectorErrorEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode
        case errorMessage
        case messageId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension BatchUpdateDetectorErrorEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchUpdateDetectorErrorEntry(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), messageId: \(String(describing: messageId)))"}
}

/// <p>Information about the error that occurred when attempting to update a detector.</p>
public struct BatchUpdateDetectorErrorEntry: Equatable {
    /// <p>The error code.</p>
    public let errorCode: ErrorCode?
    /// <p>A message that describes the error.</p>
    public let errorMessage: String?
    /// <p>The <code>"messageId"</code> of the update request that caused the error. (The value of
    ///       the <code>"messageId"</code> in the update request <code>"Detector"</code> object.)</p>
    public let messageId: String?

    public init (
        errorCode: ErrorCode? = nil,
        errorMessage: String? = nil,
        messageId: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.messageId = messageId
    }
}

public struct BatchUpdateDetectorInputBodyMiddleware: Middleware {
    public let id: String = "BatchUpdateDetectorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchUpdateDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchUpdateDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchUpdateDetectorInput>
    public typealias MOutput = OperationOutput<BatchUpdateDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchUpdateDetectorOutputError>
}

extension BatchUpdateDetectorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchUpdateDetectorInput(detectors: \(String(describing: detectors)))"}
}

extension BatchUpdateDetectorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detectors
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectors = detectors {
            var detectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .detectors)
            for updatedetectorrequests0 in detectors {
                try detectorsContainer.encode(updatedetectorrequests0)
            }
        }
    }
}

public struct BatchUpdateDetectorInputHeadersMiddleware: Middleware {
    public let id: String = "BatchUpdateDetectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchUpdateDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchUpdateDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchUpdateDetectorInput>
    public typealias MOutput = OperationOutput<BatchUpdateDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchUpdateDetectorOutputError>
}

public struct BatchUpdateDetectorInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchUpdateDetectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchUpdateDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchUpdateDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchUpdateDetectorInput>
    public typealias MOutput = OperationOutput<BatchUpdateDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchUpdateDetectorOutputError>
}

public struct BatchUpdateDetectorInput: Equatable {
    /// <p>The list of detectors (instances) to update, along with the values to update.</p>
    public let detectors: [UpdateDetectorRequest]?

    public init (
        detectors: [UpdateDetectorRequest]? = nil
    )
    {
        self.detectors = detectors
    }
}

struct BatchUpdateDetectorInputBody: Equatable {
    public let detectors: [UpdateDetectorRequest]?
}

extension BatchUpdateDetectorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectors
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorsContainer = try containerValues.decodeIfPresent([UpdateDetectorRequest?].self, forKey: .detectors)
        var detectorsDecoded0:[UpdateDetectorRequest]? = nil
        if let detectorsContainer = detectorsContainer {
            detectorsDecoded0 = [UpdateDetectorRequest]()
            for structure0 in detectorsContainer {
                if let structure0 = structure0 {
                    detectorsDecoded0?.append(structure0)
                }
            }
        }
        detectors = detectorsDecoded0
    }
}

extension BatchUpdateDetectorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchUpdateDetectorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchUpdateDetectorOutputError: Swift.Error, Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchUpdateDetectorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchUpdateDetectorOutputResponse(batchUpdateDetectorErrorEntries: \(String(describing: batchUpdateDetectorErrorEntries)))"}
}

extension BatchUpdateDetectorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchUpdateDetectorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.batchUpdateDetectorErrorEntries = output.batchUpdateDetectorErrorEntries
        } else {
            self.batchUpdateDetectorErrorEntries = nil
        }
    }
}

public struct BatchUpdateDetectorOutputResponse: Equatable {
    /// <p>A list of those detector updates that resulted in errors. (If an error is listed here, the
    ///       specific update did not occur.)</p>
    public let batchUpdateDetectorErrorEntries: [BatchUpdateDetectorErrorEntry]?

    public init (
        batchUpdateDetectorErrorEntries: [BatchUpdateDetectorErrorEntry]? = nil
    )
    {
        self.batchUpdateDetectorErrorEntries = batchUpdateDetectorErrorEntries
    }
}

struct BatchUpdateDetectorOutputResponseBody: Equatable {
    public let batchUpdateDetectorErrorEntries: [BatchUpdateDetectorErrorEntry]?
}

extension BatchUpdateDetectorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case batchUpdateDetectorErrorEntries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchUpdateDetectorErrorEntriesContainer = try containerValues.decodeIfPresent([BatchUpdateDetectorErrorEntry?].self, forKey: .batchUpdateDetectorErrorEntries)
        var batchUpdateDetectorErrorEntriesDecoded0:[BatchUpdateDetectorErrorEntry]? = nil
        if let batchUpdateDetectorErrorEntriesContainer = batchUpdateDetectorErrorEntriesContainer {
            batchUpdateDetectorErrorEntriesDecoded0 = [BatchUpdateDetectorErrorEntry]()
            for structure0 in batchUpdateDetectorErrorEntriesContainer {
                if let structure0 = structure0 {
                    batchUpdateDetectorErrorEntriesDecoded0?.append(structure0)
                }
            }
        }
        batchUpdateDetectorErrorEntries = batchUpdateDetectorErrorEntriesDecoded0
    }
}

public enum ComparisonOperator {
    case equal
    case greater
    case greaterOrEqual
    case less
    case lessOrEqual
    case notEqual
    case sdkUnknown(String)
}

extension ComparisonOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ComparisonOperator] {
        return [
            .equal,
            .greater,
            .greaterOrEqual,
            .less,
            .lessOrEqual,
            .notEqual,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .equal: return "EQUAL"
        case .greater: return "GREATER"
        case .greaterOrEqual: return "GREATER_OR_EQUAL"
        case .less: return "LESS"
        case .lessOrEqual: return "LESS_OR_EQUAL"
        case .notEqual: return "NOT_EQUAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
    }
}

extension CustomerAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acknowledgeActionConfiguration
        case actionName
        case disableActionConfiguration
        case enableActionConfiguration
        case resetActionConfiguration
        case snoozeActionConfiguration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acknowledgeActionConfiguration = acknowledgeActionConfiguration {
            try encodeContainer.encode(acknowledgeActionConfiguration, forKey: .acknowledgeActionConfiguration)
        }
        if let actionName = actionName {
            try encodeContainer.encode(actionName.rawValue, forKey: .actionName)
        }
        if let disableActionConfiguration = disableActionConfiguration {
            try encodeContainer.encode(disableActionConfiguration, forKey: .disableActionConfiguration)
        }
        if let enableActionConfiguration = enableActionConfiguration {
            try encodeContainer.encode(enableActionConfiguration, forKey: .enableActionConfiguration)
        }
        if let resetActionConfiguration = resetActionConfiguration {
            try encodeContainer.encode(resetActionConfiguration, forKey: .resetActionConfiguration)
        }
        if let snoozeActionConfiguration = snoozeActionConfiguration {
            try encodeContainer.encode(snoozeActionConfiguration, forKey: .snoozeActionConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionNameDecoded = try containerValues.decodeIfPresent(CustomerActionName.self, forKey: .actionName)
        actionName = actionNameDecoded
        let snoozeActionConfigurationDecoded = try containerValues.decodeIfPresent(SnoozeActionConfiguration.self, forKey: .snoozeActionConfiguration)
        snoozeActionConfiguration = snoozeActionConfigurationDecoded
        let enableActionConfigurationDecoded = try containerValues.decodeIfPresent(EnableActionConfiguration.self, forKey: .enableActionConfiguration)
        enableActionConfiguration = enableActionConfigurationDecoded
        let disableActionConfigurationDecoded = try containerValues.decodeIfPresent(DisableActionConfiguration.self, forKey: .disableActionConfiguration)
        disableActionConfiguration = disableActionConfigurationDecoded
        let acknowledgeActionConfigurationDecoded = try containerValues.decodeIfPresent(AcknowledgeActionConfiguration.self, forKey: .acknowledgeActionConfiguration)
        acknowledgeActionConfiguration = acknowledgeActionConfigurationDecoded
        let resetActionConfigurationDecoded = try containerValues.decodeIfPresent(ResetActionConfiguration.self, forKey: .resetActionConfiguration)
        resetActionConfiguration = resetActionConfigurationDecoded
    }
}

extension CustomerAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomerAction(acknowledgeActionConfiguration: \(String(describing: acknowledgeActionConfiguration)), actionName: \(String(describing: actionName)), disableActionConfiguration: \(String(describing: disableActionConfiguration)), enableActionConfiguration: \(String(describing: enableActionConfiguration)), resetActionConfiguration: \(String(describing: resetActionConfiguration)), snoozeActionConfiguration: \(String(describing: snoozeActionConfiguration)))"}
}

/// <p>Contains information about the action that you can take to respond to the alarm.</p>
public struct CustomerAction: Equatable {
    /// <p>Contains the configuration information of an acknowledge action.</p>
    public let acknowledgeActionConfiguration: AcknowledgeActionConfiguration?
    /// <p>The name of the action. The action name can be one of the following values:</p>
    ///          <ul>
    ///             <li>
    /// 			            <p>
    ///                   <code>SNOOZE</code> - When you snooze the alarm, the alarm state changes to <code>SNOOZE_DISABLED</code>.</p>
    /// 		          </li>
    ///             <li>
    /// 			            <p>
    ///                   <code>ENABLE</code> - When you enable the alarm, the alarm state changes to <code>NORMAL</code>.</p>
    /// 		          </li>
    ///             <li>
    /// 			            <p>
    ///                   <code>DISABLE</code> - When you disable the alarm, the alarm state changes to <code>DISABLED</code>.</p>
    /// 		          </li>
    ///             <li>
    /// 			            <p>
    ///                   <code>ACKNOWLEDGE</code> - When you acknowledge the alarm, the alarm state changes to <code>ACKNOWLEDGED</code>.</p>
    /// 		          </li>
    ///             <li>
    /// 			            <p>
    ///                   <code>RESET</code> - When you reset the alarm, the alarm state changes to <code>NORMAL</code>.</p>
    /// 		          </li>
    ///          </ul>
    ///          <p>For more information, see the <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_AlarmState.html">AlarmState</a> API.</p>
    public let actionName: CustomerActionName?
    /// <p>Contains the configuration information of a disable action.</p>
    public let disableActionConfiguration: DisableActionConfiguration?
    /// <p>Contains the configuration information of an enable action.</p>
    public let enableActionConfiguration: EnableActionConfiguration?
    /// <p>Contains the configuration information of a reset action.</p>
    public let resetActionConfiguration: ResetActionConfiguration?
    /// <p>Contains the configuration information of a snooze action.</p>
    public let snoozeActionConfiguration: SnoozeActionConfiguration?

    public init (
        acknowledgeActionConfiguration: AcknowledgeActionConfiguration? = nil,
        actionName: CustomerActionName? = nil,
        disableActionConfiguration: DisableActionConfiguration? = nil,
        enableActionConfiguration: EnableActionConfiguration? = nil,
        resetActionConfiguration: ResetActionConfiguration? = nil,
        snoozeActionConfiguration: SnoozeActionConfiguration? = nil
    )
    {
        self.acknowledgeActionConfiguration = acknowledgeActionConfiguration
        self.actionName = actionName
        self.disableActionConfiguration = disableActionConfiguration
        self.enableActionConfiguration = enableActionConfiguration
        self.resetActionConfiguration = resetActionConfiguration
        self.snoozeActionConfiguration = snoozeActionConfiguration
    }
}

public enum CustomerActionName {
    case acknowledge
    case disable
    case enable
    case reset
    case snooze
    case sdkUnknown(String)
}

extension CustomerActionName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CustomerActionName] {
        return [
            .acknowledge,
            .disable,
            .enable,
            .reset,
            .snooze,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .acknowledge: return "ACKNOWLEDGE"
        case .disable: return "DISABLE"
        case .enable: return "ENABLE"
        case .reset: return "RESET"
        case .snooze: return "SNOOZE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CustomerActionName(rawValue: rawValue) ?? CustomerActionName.sdkUnknown(rawValue)
    }
}

extension DescribeAlarmInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAlarmInput(alarmModelName: \(String(describing: alarmModelName)), keyValue: \(String(describing: keyValue)))"}
}

extension DescribeAlarmInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAlarmInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAlarmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAlarmInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAlarmInput>
    public typealias MOutput = OperationOutput<DescribeAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAlarmOutputError>
}

public struct DescribeAlarmInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAlarmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAlarmInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let keyValue = input.operationInput.keyValue {
            let keyValueQueryItem = URLQueryItem(name: "keyValue".urlPercentEncoding(), value: String(keyValue).urlPercentEncoding())
            input.builder.withQueryItem(keyValueQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAlarmInput>
    public typealias MOutput = OperationOutput<DescribeAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAlarmOutputError>
}

public struct DescribeAlarmInput: Equatable {
    /// <p>The name of the alarm model.</p>
    public let alarmModelName: String?
    /// <p>The value of the key used as a filter to select only the alarms associated with the
    /// <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key">key</a>.</p>
    public let keyValue: String?

    public init (
        alarmModelName: String? = nil,
        keyValue: String? = nil
    )
    {
        self.alarmModelName = alarmModelName
        self.keyValue = keyValue
    }
}

struct DescribeAlarmInputBody: Equatable {
}

extension DescribeAlarmInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAlarmOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAlarmOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAlarmOutputError: Swift.Error, Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAlarmOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAlarmOutputResponse(alarm: \(String(describing: alarm)))"}
}

extension DescribeAlarmOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAlarmOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.alarm = output.alarm
        } else {
            self.alarm = nil
        }
    }
}

public struct DescribeAlarmOutputResponse: Equatable {
    /// <p>Contains information about an alarm.</p>
    public let alarm: Alarm?

    public init (
        alarm: Alarm? = nil
    )
    {
        self.alarm = alarm
    }
}

struct DescribeAlarmOutputResponseBody: Equatable {
    public let alarm: Alarm?
}

extension DescribeAlarmOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alarm
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmDecoded = try containerValues.decodeIfPresent(Alarm.self, forKey: .alarm)
        alarm = alarmDecoded
    }
}

extension DescribeDetectorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDetectorInput(detectorModelName: \(String(describing: detectorModelName)), keyValue: \(String(describing: keyValue)))"}
}

extension DescribeDetectorInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDetectorInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDetectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDetectorInput>
    public typealias MOutput = OperationOutput<DescribeDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDetectorOutputError>
}

public struct DescribeDetectorInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDetectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let keyValue = input.operationInput.keyValue {
            let keyValueQueryItem = URLQueryItem(name: "keyValue".urlPercentEncoding(), value: String(keyValue).urlPercentEncoding())
            input.builder.withQueryItem(keyValueQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDetectorInput>
    public typealias MOutput = OperationOutput<DescribeDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDetectorOutputError>
}

public struct DescribeDetectorInput: Equatable {
    /// <p>The name of the detector model whose detectors (instances) you want information
    ///       about.</p>
    public let detectorModelName: String?
    /// <p>A filter used to limit results to detectors (instances) created because of the given key
    ///       ID.</p>
    public let keyValue: String?

    public init (
        detectorModelName: String? = nil,
        keyValue: String? = nil
    )
    {
        self.detectorModelName = detectorModelName
        self.keyValue = keyValue
    }
}

struct DescribeDetectorInputBody: Equatable {
}

extension DescribeDetectorInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDetectorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDetectorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDetectorOutputError: Swift.Error, Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDetectorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDetectorOutputResponse(detector: \(String(describing: detector)))"}
}

extension DescribeDetectorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDetectorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.detector = output.detector
        } else {
            self.detector = nil
        }
    }
}

public struct DescribeDetectorOutputResponse: Equatable {
    /// <p>Information about the detector (instance).</p>
    public let detector: Detector?

    public init (
        detector: Detector? = nil
    )
    {
        self.detector = detector
    }
}

struct DescribeDetectorOutputResponseBody: Equatable {
    public let detector: Detector?
}

extension DescribeDetectorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detector
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorDecoded = try containerValues.decodeIfPresent(Detector.self, forKey: .detector)
        detector = detectorDecoded
    }
}

extension Detector: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime
        case detectorModelName
        case detectorModelVersion
        case keyValue
        case lastUpdateTime
        case state
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let detectorModelName = detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
        if let detectorModelVersion = detectorModelVersion {
            try encodeContainer.encode(detectorModelVersion, forKey: .detectorModelVersion)
        }
        if let keyValue = keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let detectorModelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorModelVersion)
        detectorModelVersion = detectorModelVersionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DetectorState.self, forKey: .state)
        state = stateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension Detector: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Detector(creationTime: \(String(describing: creationTime)), detectorModelName: \(String(describing: detectorModelName)), detectorModelVersion: \(String(describing: detectorModelVersion)), keyValue: \(String(describing: keyValue)), lastUpdateTime: \(String(describing: lastUpdateTime)), state: \(String(describing: state)))"}
}

/// <p>Information about the detector (instance).</p>
public struct Detector: Equatable {
    /// <p>The time the detector (instance) was created.</p>
    public let creationTime: Date?
    /// <p>The name of the detector model that created this detector (instance).</p>
    public let detectorModelName: String?
    /// <p>The version of the detector model that created this detector (instance).</p>
    public let detectorModelVersion: String?
    /// <p>The value of the key (identifying the device or system) that caused the creation of this
    ///       detector (instance).</p>
    public let keyValue: String?
    /// <p>The time the detector (instance) was last updated.</p>
    public let lastUpdateTime: Date?
    /// <p>The current state of the detector (instance).</p>
    public let state: DetectorState?

    public init (
        creationTime: Date? = nil,
        detectorModelName: String? = nil,
        detectorModelVersion: String? = nil,
        keyValue: String? = nil,
        lastUpdateTime: Date? = nil,
        state: DetectorState? = nil
    )
    {
        self.creationTime = creationTime
        self.detectorModelName = detectorModelName
        self.detectorModelVersion = detectorModelVersion
        self.keyValue = keyValue
        self.lastUpdateTime = lastUpdateTime
        self.state = state
    }
}

extension DetectorState: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stateName
        case timers
        case variables
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stateName = stateName {
            try encodeContainer.encode(stateName, forKey: .stateName)
        }
        if let timers = timers {
            var timersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .timers)
            for timers0 in timers {
                try timersContainer.encode(timers0)
            }
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variables)
            for variables0 in variables {
                try variablesContainer.encode(variables0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateName)
        stateName = stateNameDecoded
        let variablesContainer = try containerValues.decodeIfPresent([Variable?].self, forKey: .variables)
        var variablesDecoded0:[Variable]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Variable]()
            for structure0 in variablesContainer {
                if let structure0 = structure0 {
                    variablesDecoded0?.append(structure0)
                }
            }
        }
        variables = variablesDecoded0
        let timersContainer = try containerValues.decodeIfPresent([Timer?].self, forKey: .timers)
        var timersDecoded0:[Timer]? = nil
        if let timersContainer = timersContainer {
            timersDecoded0 = [Timer]()
            for structure0 in timersContainer {
                if let structure0 = structure0 {
                    timersDecoded0?.append(structure0)
                }
            }
        }
        timers = timersDecoded0
    }
}

extension DetectorState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectorState(stateName: \(String(describing: stateName)), timers: \(String(describing: timers)), variables: \(String(describing: variables)))"}
}

/// <p>Information about the current state of the detector instance.</p>
public struct DetectorState: Equatable {
    /// <p>The name of the state.</p>
    public let stateName: String?
    /// <p>The current state of the detector's timers.</p>
    public let timers: [Timer]?
    /// <p>The current values of the detector's variables.</p>
    public let variables: [Variable]?

    public init (
        stateName: String? = nil,
        timers: [Timer]? = nil,
        variables: [Variable]? = nil
    )
    {
        self.stateName = stateName
        self.timers = timers
        self.variables = variables
    }
}

extension DetectorStateDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stateName
        case timers
        case variables
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stateName = stateName {
            try encodeContainer.encode(stateName, forKey: .stateName)
        }
        if let timers = timers {
            var timersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .timers)
            for timerdefinitions0 in timers {
                try timersContainer.encode(timerdefinitions0)
            }
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variables)
            for variabledefinitions0 in variables {
                try variablesContainer.encode(variabledefinitions0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateName)
        stateName = stateNameDecoded
        let variablesContainer = try containerValues.decodeIfPresent([VariableDefinition?].self, forKey: .variables)
        var variablesDecoded0:[VariableDefinition]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [VariableDefinition]()
            for structure0 in variablesContainer {
                if let structure0 = structure0 {
                    variablesDecoded0?.append(structure0)
                }
            }
        }
        variables = variablesDecoded0
        let timersContainer = try containerValues.decodeIfPresent([TimerDefinition?].self, forKey: .timers)
        var timersDecoded0:[TimerDefinition]? = nil
        if let timersContainer = timersContainer {
            timersDecoded0 = [TimerDefinition]()
            for structure0 in timersContainer {
                if let structure0 = structure0 {
                    timersDecoded0?.append(structure0)
                }
            }
        }
        timers = timersDecoded0
    }
}

extension DetectorStateDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectorStateDefinition(stateName: \(String(describing: stateName)), timers: \(String(describing: timers)), variables: \(String(describing: variables)))"}
}

/// <p>The new state, variable values, and timer settings of the detector (instance).</p>
public struct DetectorStateDefinition: Equatable {
    /// <p>The name of the new state of the detector (instance).</p>
    public let stateName: String?
    /// <p>The new values of the detector's timers. Any timer whose value isn't specified is cleared,
    ///       and its timeout event won't occur.</p>
    public let timers: [TimerDefinition]?
    /// <p>The new values of the detector's variables. Any variable whose value isn't specified is
    ///       cleared.</p>
    public let variables: [VariableDefinition]?

    public init (
        stateName: String? = nil,
        timers: [TimerDefinition]? = nil,
        variables: [VariableDefinition]? = nil
    )
    {
        self.stateName = stateName
        self.timers = timers
        self.variables = variables
    }
}

extension DetectorStateSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stateName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stateName = stateName {
            try encodeContainer.encode(stateName, forKey: .stateName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateName)
        stateName = stateNameDecoded
    }
}

extension DetectorStateSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectorStateSummary(stateName: \(String(describing: stateName)))"}
}

/// <p>Information about the detector state.</p>
public struct DetectorStateSummary: Equatable {
    /// <p>The name of the state.</p>
    public let stateName: String?

    public init (
        stateName: String? = nil
    )
    {
        self.stateName = stateName
    }
}

extension DetectorSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime
        case detectorModelName
        case detectorModelVersion
        case keyValue
        case lastUpdateTime
        case state
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let detectorModelName = detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
        if let detectorModelVersion = detectorModelVersion {
            try encodeContainer.encode(detectorModelVersion, forKey: .detectorModelVersion)
        }
        if let keyValue = keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let detectorModelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorModelVersion)
        detectorModelVersion = detectorModelVersionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DetectorStateSummary.self, forKey: .state)
        state = stateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension DetectorSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectorSummary(creationTime: \(String(describing: creationTime)), detectorModelName: \(String(describing: detectorModelName)), detectorModelVersion: \(String(describing: detectorModelVersion)), keyValue: \(String(describing: keyValue)), lastUpdateTime: \(String(describing: lastUpdateTime)), state: \(String(describing: state)))"}
}

/// <p>Information about the detector (instance).</p>
public struct DetectorSummary: Equatable {
    /// <p>The time the detector (instance) was created.</p>
    public let creationTime: Date?
    /// <p>The name of the detector model that created this detector (instance).</p>
    public let detectorModelName: String?
    /// <p>The version of the detector model that created this detector (instance).</p>
    public let detectorModelVersion: String?
    /// <p>The value of the key (identifying the device or system) that caused the creation of this
    ///       detector (instance).</p>
    public let keyValue: String?
    /// <p>The time the detector (instance) was last updated.</p>
    public let lastUpdateTime: Date?
    /// <p>The current state of the detector (instance).</p>
    public let state: DetectorStateSummary?

    public init (
        creationTime: Date? = nil,
        detectorModelName: String? = nil,
        detectorModelVersion: String? = nil,
        keyValue: String? = nil,
        lastUpdateTime: Date? = nil,
        state: DetectorStateSummary? = nil
    )
    {
        self.creationTime = creationTime
        self.detectorModelName = detectorModelName
        self.detectorModelVersion = detectorModelVersion
        self.keyValue = keyValue
        self.lastUpdateTime = lastUpdateTime
        self.state = state
    }
}

extension DisableActionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case note
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noteDecoded = try containerValues.decodeIfPresent(String.self, forKey: .note)
        note = noteDecoded
    }
}

extension DisableActionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableActionConfiguration(note: \(String(describing: note)))"}
}

/// <p>Contains the configuration information of a disable action.</p>
public struct DisableActionConfiguration: Equatable {
    /// <p>The note that you can leave when you disable the alarm.</p>
    public let note: String?

    public init (
        note: String? = nil
    )
    {
        self.note = note
    }
}

extension DisableAlarmActionRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alarmModelName
        case keyValue
        case note
        case requestId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelName = alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let keyValue = keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let noteDecoded = try containerValues.decodeIfPresent(String.self, forKey: .note)
        note = noteDecoded
    }
}

extension DisableAlarmActionRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableAlarmActionRequest(alarmModelName: \(String(describing: alarmModelName)), keyValue: \(String(describing: keyValue)), note: \(String(describing: note)), requestId: \(String(describing: requestId)))"}
}

/// <p>Information used to disable the alarm.</p>
public struct DisableAlarmActionRequest: Equatable {
    /// <p>The name of the alarm model.</p>
    public let alarmModelName: String?
    /// <p>The value of the key used as a filter to select only the alarms associated with the
    /// <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key">key</a>.</p>
    public let keyValue: String?
    /// <p>The note that you can leave when you disable the alarm.</p>
    public let note: String?
    /// <p>The request ID. Each ID must be unique within each batch.</p>
    public let requestId: String?

    public init (
        alarmModelName: String? = nil,
        keyValue: String? = nil,
        note: String? = nil,
        requestId: String? = nil
    )
    {
        self.alarmModelName = alarmModelName
        self.keyValue = keyValue
        self.note = note
        self.requestId = requestId
    }
}

extension EnableActionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case note
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noteDecoded = try containerValues.decodeIfPresent(String.self, forKey: .note)
        note = noteDecoded
    }
}

extension EnableActionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableActionConfiguration(note: \(String(describing: note)))"}
}

/// <p>Contains the configuration information of an enable action.</p>
public struct EnableActionConfiguration: Equatable {
    /// <p>The note that you can leave when you enable the alarm.</p>
    public let note: String?

    public init (
        note: String? = nil
    )
    {
        self.note = note
    }
}

extension EnableAlarmActionRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alarmModelName
        case keyValue
        case note
        case requestId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelName = alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let keyValue = keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let noteDecoded = try containerValues.decodeIfPresent(String.self, forKey: .note)
        note = noteDecoded
    }
}

extension EnableAlarmActionRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableAlarmActionRequest(alarmModelName: \(String(describing: alarmModelName)), keyValue: \(String(describing: keyValue)), note: \(String(describing: note)), requestId: \(String(describing: requestId)))"}
}

/// <p>Information needed to enable the alarm.</p>
public struct EnableAlarmActionRequest: Equatable {
    /// <p>The name of the alarm model.</p>
    public let alarmModelName: String?
    /// <p>The value of the key used as a filter to select only the alarms associated with the
    /// <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key">key</a>.</p>
    public let keyValue: String?
    /// <p>The note that you can leave when you enable the alarm.</p>
    public let note: String?
    /// <p>The request ID. Each ID must be unique within each batch.</p>
    public let requestId: String?

    public init (
        alarmModelName: String? = nil,
        keyValue: String? = nil,
        note: String? = nil,
        requestId: String? = nil
    )
    {
        self.alarmModelName = alarmModelName
        self.keyValue = keyValue
        self.note = note
        self.requestId = requestId
    }
}

public enum ErrorCode {
    case internalfailureexception
    case invalidrequestexception
    case resourcenotfoundexception
    case serviceunavailableexception
    case throttlingexception
    case sdkUnknown(String)
}

extension ErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ErrorCode] {
        return [
            .internalfailureexception,
            .invalidrequestexception,
            .resourcenotfoundexception,
            .serviceunavailableexception,
            .throttlingexception,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .internalfailureexception: return "InternalFailureException"
        case .invalidrequestexception: return "InvalidRequestException"
        case .resourcenotfoundexception: return "ResourceNotFoundException"
        case .serviceunavailableexception: return "ServiceUnavailableException"
        case .throttlingexception: return "ThrottlingException"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
    }
}

public enum EventType {
    case stateChange
    case sdkUnknown(String)
}

extension EventType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventType] {
        return [
            .stateChange,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .stateChange: return "STATE_CHANGE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
    }
}

extension InternalFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalFailureException(message: \(String(describing: message)))"}
}

extension InternalFailureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal failure occurred.</p>
public struct InternalFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Equatable {
    public let message: String?
}

extension InternalFailureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was invalid.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAlarmsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAlarmsInput(alarmModelName: \(String(describing: alarmModelName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAlarmsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAlarmsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAlarmsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAlarmsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAlarmsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAlarmsInput>
    public typealias MOutput = OperationOutput<ListAlarmsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAlarmsOutputError>
}

public struct ListAlarmsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAlarmsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAlarmsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAlarmsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAlarmsInput>
    public typealias MOutput = OperationOutput<ListAlarmsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAlarmsOutputError>
}

public struct ListAlarmsInput: Equatable {
    /// <p>The name of the alarm model.</p>
    public let alarmModelName: String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int?
    /// <p>The token that you can use to return the next set of results.</p>
    public let nextToken: String?

    public init (
        alarmModelName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.alarmModelName = alarmModelName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAlarmsInputBody: Equatable {
}

extension ListAlarmsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAlarmsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAlarmsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAlarmsOutputError: Swift.Error, Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAlarmsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAlarmsOutputResponse(alarmSummaries: \(String(describing: alarmSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAlarmsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAlarmsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.alarmSummaries = output.alarmSummaries
            self.nextToken = output.nextToken
        } else {
            self.alarmSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAlarmsOutputResponse: Equatable {
    /// <p>A list that summarizes each alarm.</p>
    public let alarmSummaries: [AlarmSummary]?
    /// <p>The token that you can use to return the next set of results,
    /// or <code>null</code> if there are no more results.</p>
    public let nextToken: String?

    public init (
        alarmSummaries: [AlarmSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.alarmSummaries = alarmSummaries
        self.nextToken = nextToken
    }
}

struct ListAlarmsOutputResponseBody: Equatable {
    public let alarmSummaries: [AlarmSummary]?
    public let nextToken: String?
}

extension ListAlarmsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alarmSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmSummariesContainer = try containerValues.decodeIfPresent([AlarmSummary?].self, forKey: .alarmSummaries)
        var alarmSummariesDecoded0:[AlarmSummary]? = nil
        if let alarmSummariesContainer = alarmSummariesContainer {
            alarmSummariesDecoded0 = [AlarmSummary]()
            for structure0 in alarmSummariesContainer {
                if let structure0 = structure0 {
                    alarmSummariesDecoded0?.append(structure0)
                }
            }
        }
        alarmSummaries = alarmSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDetectorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDetectorsInput(detectorModelName: \(String(describing: detectorModelName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), stateName: \(String(describing: stateName)))"}
}

extension ListDetectorsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDetectorsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDetectorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDetectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDetectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDetectorsInput>
    public typealias MOutput = OperationOutput<ListDetectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDetectorsOutputError>
}

public struct ListDetectorsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDetectorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDetectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDetectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let stateName = input.operationInput.stateName {
            let stateNameQueryItem = URLQueryItem(name: "stateName".urlPercentEncoding(), value: String(stateName).urlPercentEncoding())
            input.builder.withQueryItem(stateNameQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDetectorsInput>
    public typealias MOutput = OperationOutput<ListDetectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDetectorsOutputError>
}

public struct ListDetectorsInput: Equatable {
    /// <p>The name of the detector model whose detectors (instances) are listed.</p>
    public let detectorModelName: String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int?
    /// <p>The token that you can use to return the next set of results.</p>
    public let nextToken: String?
    /// <p>A filter that limits results to those detectors (instances) in the given state.</p>
    public let stateName: String?

    public init (
        detectorModelName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        stateName: String? = nil
    )
    {
        self.detectorModelName = detectorModelName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stateName = stateName
    }
}

struct ListDetectorsInputBody: Equatable {
}

extension ListDetectorsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDetectorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDetectorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDetectorsOutputError: Swift.Error, Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDetectorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDetectorsOutputResponse(detectorSummaries: \(String(describing: detectorSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDetectorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDetectorsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.detectorSummaries = output.detectorSummaries
            self.nextToken = output.nextToken
        } else {
            self.detectorSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDetectorsOutputResponse: Equatable {
    /// <p>A list of summary information about the detectors (instances).</p>
    public let detectorSummaries: [DetectorSummary]?
    /// <p>The token that you can use to return the next set of results,
    /// or <code>null</code> if there are no more results.</p>
    public let nextToken: String?

    public init (
        detectorSummaries: [DetectorSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.detectorSummaries = detectorSummaries
        self.nextToken = nextToken
    }
}

struct ListDetectorsOutputResponseBody: Equatable {
    public let detectorSummaries: [DetectorSummary]?
    public let nextToken: String?
}

extension ListDetectorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectorSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorSummariesContainer = try containerValues.decodeIfPresent([DetectorSummary?].self, forKey: .detectorSummaries)
        var detectorSummariesDecoded0:[DetectorSummary]? = nil
        if let detectorSummariesContainer = detectorSummariesContainer {
            detectorSummariesDecoded0 = [DetectorSummary]()
            for structure0 in detectorSummariesContainer {
                if let structure0 = structure0 {
                    detectorSummariesDecoded0?.append(structure0)
                }
            }
        }
        detectorSummaries = detectorSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension Message: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputName
        case messageId
        case payload
        case timestamp
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputName = inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let payload = payload {
            try encodeContainer.encode(payload.base64EncodedString(), forKey: .payload)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let inputNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputName)
        inputName = inputNameDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .payload)
        payload = payloadDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(TimestampValue.self, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension Message: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Message(inputName: \(String(describing: inputName)), messageId: \(String(describing: messageId)), payload: \(String(describing: payload)), timestamp: \(String(describing: timestamp)))"}
}

/// <p>Information about a message.</p>
public struct Message: Equatable {
    /// <p>The name of the input into which the message payload is transformed.</p>
    public let inputName: String?
    /// <p>The ID to assign to the message. Within each batch sent, each <code>"messageId"</code>
    ///       must be unique.</p>
    public let messageId: String?
    /// <p>The payload of the message. This can be a JSON string or a Base-64-encoded string
    ///       representing binary data (in which case you must decode it).</p>
    public let payload: Data?
    /// <p>The timestamp associated with the message.</p>
    public let timestamp: TimestampValue?

    public init (
        inputName: String? = nil,
        messageId: String? = nil,
        payload: Data? = nil,
        timestamp: TimestampValue? = nil
    )
    {
        self.inputName = inputName
        self.messageId = messageId
        self.payload = payload
        self.timestamp = timestamp
    }
}

extension ResetActionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case note
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noteDecoded = try containerValues.decodeIfPresent(String.self, forKey: .note)
        note = noteDecoded
    }
}

extension ResetActionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetActionConfiguration(note: \(String(describing: note)))"}
}

/// <p>Contains the configuration information of a reset action.</p>
public struct ResetActionConfiguration: Equatable {
    /// <p>The note that you can leave when you reset the alarm.</p>
    public let note: String?

    public init (
        note: String? = nil
    )
    {
        self.note = note
    }
}

extension ResetAlarmActionRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alarmModelName
        case keyValue
        case note
        case requestId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelName = alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let keyValue = keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let noteDecoded = try containerValues.decodeIfPresent(String.self, forKey: .note)
        note = noteDecoded
    }
}

extension ResetAlarmActionRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetAlarmActionRequest(alarmModelName: \(String(describing: alarmModelName)), keyValue: \(String(describing: keyValue)), note: \(String(describing: note)), requestId: \(String(describing: requestId)))"}
}

/// <p>Information needed to reset the alarm.</p>
public struct ResetAlarmActionRequest: Equatable {
    /// <p>The name of the alarm model.</p>
    public let alarmModelName: String?
    /// <p>The value of the key used as a filter to select only the alarms associated with the
    /// <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key">key</a>.</p>
    public let keyValue: String?
    /// <p>The note that you can leave when you reset the alarm.</p>
    public let note: String?
    /// <p>The request ID. Each ID must be unique within each batch.</p>
    public let requestId: String?

    public init (
        alarmModelName: String? = nil,
        keyValue: String? = nil,
        note: String? = nil,
        requestId: String? = nil
    )
    {
        self.alarmModelName = alarmModelName
        self.keyValue = keyValue
        self.note = note
        self.requestId = requestId
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RuleEvaluation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case simpleRuleEvaluation
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simpleRuleEvaluation = simpleRuleEvaluation {
            try encodeContainer.encode(simpleRuleEvaluation, forKey: .simpleRuleEvaluation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simpleRuleEvaluationDecoded = try containerValues.decodeIfPresent(SimpleRuleEvaluation.self, forKey: .simpleRuleEvaluation)
        simpleRuleEvaluation = simpleRuleEvaluationDecoded
    }
}

extension RuleEvaluation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleEvaluation(simpleRuleEvaluation: \(String(describing: simpleRuleEvaluation)))"}
}

/// <p>Information needed to evaluate data.</p>
public struct RuleEvaluation: Equatable {
    /// <p>Information needed to compare two values with a comparison operator.</p>
    public let simpleRuleEvaluation: SimpleRuleEvaluation?

    public init (
        simpleRuleEvaluation: SimpleRuleEvaluation? = nil
    )
    {
        self.simpleRuleEvaluation = simpleRuleEvaluation
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service is currently unavailable.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SimpleRuleEvaluation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputPropertyValue
        case `operator` = "operator"
        case thresholdValue
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputPropertyValue = inputPropertyValue {
            try encodeContainer.encode(inputPropertyValue, forKey: .inputPropertyValue)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let thresholdValue = thresholdValue {
            try encodeContainer.encode(thresholdValue, forKey: .thresholdValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputPropertyValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputPropertyValue)
        inputPropertyValue = inputPropertyValueDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(ComparisonOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let thresholdValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thresholdValue)
        thresholdValue = thresholdValueDecoded
    }
}

extension SimpleRuleEvaluation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SimpleRuleEvaluation(inputPropertyValue: \(String(describing: inputPropertyValue)), operator: \(String(describing: `operator`)), thresholdValue: \(String(describing: thresholdValue)))"}
}

/// <p>Information needed to compare two values with a comparison operator.</p>
public struct SimpleRuleEvaluation: Equatable {
    /// <p>The comparison operator.</p>
    public let `operator`: ComparisonOperator?
    /// <p>The value of the input property, on the left side of the comparison operator.</p>
    public let inputPropertyValue: String?
    /// <p>The threshold value, on the right side of the comparison operator.</p>
    public let thresholdValue: String?

    public init (
        `operator`: ComparisonOperator? = nil,
        inputPropertyValue: String? = nil,
        thresholdValue: String? = nil
    )
    {
        self.`operator` = `operator`
        self.inputPropertyValue = inputPropertyValue
        self.thresholdValue = thresholdValue
    }
}

extension SnoozeActionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case note
        case snoozeDuration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let snoozeDuration = snoozeDuration {
            try encodeContainer.encode(snoozeDuration, forKey: .snoozeDuration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snoozeDurationDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .snoozeDuration)
        snoozeDuration = snoozeDurationDecoded
        let noteDecoded = try containerValues.decodeIfPresent(String.self, forKey: .note)
        note = noteDecoded
    }
}

extension SnoozeActionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnoozeActionConfiguration(note: \(String(describing: note)), snoozeDuration: \(String(describing: snoozeDuration)))"}
}

/// <p>Contains the configuration information of a snooze action.</p>
public struct SnoozeActionConfiguration: Equatable {
    /// <p>The note that you can leave when you snooze the alarm.</p>
    public let note: String?
    /// <p>The snooze time in seconds. The alarm automatically changes to the <code>NORMAL</code> state after this duration.</p>
    public let snoozeDuration: Int?

    public init (
        note: String? = nil,
        snoozeDuration: Int? = nil
    )
    {
        self.note = note
        self.snoozeDuration = snoozeDuration
    }
}

extension SnoozeAlarmActionRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alarmModelName
        case keyValue
        case note
        case requestId
        case snoozeDuration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelName = alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let keyValue = keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let snoozeDuration = snoozeDuration {
            try encodeContainer.encode(snoozeDuration, forKey: .snoozeDuration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let noteDecoded = try containerValues.decodeIfPresent(String.self, forKey: .note)
        note = noteDecoded
        let snoozeDurationDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .snoozeDuration)
        snoozeDuration = snoozeDurationDecoded
    }
}

extension SnoozeAlarmActionRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnoozeAlarmActionRequest(alarmModelName: \(String(describing: alarmModelName)), keyValue: \(String(describing: keyValue)), note: \(String(describing: note)), requestId: \(String(describing: requestId)), snoozeDuration: \(String(describing: snoozeDuration)))"}
}

/// <p>Information needed to snooze the alarm.</p>
public struct SnoozeAlarmActionRequest: Equatable {
    /// <p>The name of the alarm model.</p>
    public let alarmModelName: String?
    /// <p>The value of the key used as a filter to select only the alarms associated with the
    /// <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key">key</a>.</p>
    public let keyValue: String?
    /// <p>The note that you can leave when you snooze the alarm.</p>
    public let note: String?
    /// <p>The request ID. Each ID must be unique within each batch.</p>
    public let requestId: String?
    /// <p>The snooze time in seconds. The alarm automatically changes to the <code>NORMAL</code> state after this duration.</p>
    public let snoozeDuration: Int?

    public init (
        alarmModelName: String? = nil,
        keyValue: String? = nil,
        note: String? = nil,
        requestId: String? = nil,
        snoozeDuration: Int? = nil
    )
    {
        self.alarmModelName = alarmModelName
        self.keyValue = keyValue
        self.note = note
        self.requestId = requestId
        self.snoozeDuration = snoozeDuration
    }
}

extension StateChangeConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case triggerType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let triggerType = triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let triggerTypeDecoded = try containerValues.decodeIfPresent(TriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
    }
}

extension StateChangeConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StateChangeConfiguration(triggerType: \(String(describing: triggerType)))"}
}

/// <p>Contains the configuration information of alarm state changes.</p>
public struct StateChangeConfiguration: Equatable {
    /// <p>The trigger type. If the value is <code>SNOOZE_TIMEOUT</code>, the snooze duration ends
    ///       and the alarm automatically changes to the <code>NORMAL</code> state.</p>
    public let triggerType: TriggerType?

    public init (
        triggerType: TriggerType? = nil
    )
    {
        self.triggerType = triggerType
    }
}

extension SystemEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventType
        case stateChangeConfiguration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventType = eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let stateChangeConfiguration = stateChangeConfiguration {
            try encodeContainer.encode(stateChangeConfiguration, forKey: .stateChangeConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeDecoded = try containerValues.decodeIfPresent(EventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let stateChangeConfigurationDecoded = try containerValues.decodeIfPresent(StateChangeConfiguration.self, forKey: .stateChangeConfiguration)
        stateChangeConfiguration = stateChangeConfigurationDecoded
    }
}

extension SystemEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SystemEvent(eventType: \(String(describing: eventType)), stateChangeConfiguration: \(String(describing: stateChangeConfiguration)))"}
}

/// <p>Contains information about alarm state changes.</p>
public struct SystemEvent: Equatable {
    /// <p>The event type. If the value is <code>STATE_CHANGE</code>, the event contains information
    ///       about alarm state changes.</p>
    public let eventType: EventType?
    /// <p>Contains the configuration information of alarm state changes.</p>
    public let stateChangeConfiguration: StateChangeConfiguration?

    public init (
        eventType: EventType? = nil,
        stateChangeConfiguration: StateChangeConfiguration? = nil
    )
    {
        self.eventType = eventType
        self.stateChangeConfiguration = stateChangeConfiguration
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request could not be completed due to throttling.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Timer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case timestamp
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension Timer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Timer(name: \(String(describing: name)), timestamp: \(String(describing: timestamp)))"}
}

/// <p>The current state of a timer.</p>
public struct Timer: Equatable {
    /// <p>The name of the timer.</p>
    public let name: String?
    /// <p>The number of seconds which have elapsed on the timer.</p>
    public let timestamp: Date?

    public init (
        name: String? = nil,
        timestamp: Date? = nil
    )
    {
        self.name = name
        self.timestamp = timestamp
    }
}

extension TimerDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case seconds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let seconds = seconds {
            try encodeContainer.encode(seconds, forKey: .seconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let secondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .seconds)
        seconds = secondsDecoded
    }
}

extension TimerDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimerDefinition(name: \(String(describing: name)), seconds: \(String(describing: seconds)))"}
}

/// <p>The new setting of a timer.</p>
public struct TimerDefinition: Equatable {
    /// <p>The name of the timer.</p>
    public let name: String?
    /// <p>The new setting of the timer (the number of seconds before the timer elapses).</p>
    public let seconds: Int?

    public init (
        name: String? = nil,
        seconds: Int? = nil
    )
    {
        self.name = name
        self.seconds = seconds
    }
}

extension TimestampValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case timeInMillis
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timeInMillis = timeInMillis {
            try encodeContainer.encode(timeInMillis, forKey: .timeInMillis)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeInMillisDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeInMillis)
        timeInMillis = timeInMillisDecoded
    }
}

extension TimestampValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimestampValue(timeInMillis: \(String(describing: timeInMillis)))"}
}

/// <p>Contains information about a timestamp.</p>
public struct TimestampValue: Equatable {
    /// <p>The value of the timestamp, in the Unix epoch format.</p>
    public let timeInMillis: Int?

    public init (
        timeInMillis: Int? = nil
    )
    {
        self.timeInMillis = timeInMillis
    }
}

public enum TriggerType {
    case snoozeTimeout
    case sdkUnknown(String)
}

extension TriggerType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TriggerType] {
        return [
            .snoozeTimeout,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .snoozeTimeout: return "SNOOZE_TIMEOUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TriggerType(rawValue: rawValue) ?? TriggerType.sdkUnknown(rawValue)
    }
}

extension UpdateDetectorRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detectorModelName
        case keyValue
        case messageId
        case state
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorModelName = detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
        if let keyValue = keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DetectorStateDefinition.self, forKey: .state)
        state = stateDecoded
    }
}

extension UpdateDetectorRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDetectorRequest(detectorModelName: \(String(describing: detectorModelName)), keyValue: \(String(describing: keyValue)), messageId: \(String(describing: messageId)), state: \(String(describing: state)))"}
}

/// <p>Information used to update the detector (instance).</p>
public struct UpdateDetectorRequest: Equatable {
    /// <p>The name of the detector model that created the detectors (instances).</p>
    public let detectorModelName: String?
    /// <p>The value of the input key attribute (identifying the device or system) that caused the
    ///       creation of this detector (instance).</p>
    public let keyValue: String?
    /// <p>The ID to assign to the detector update <code>"message"</code>. Each
    ///         <code>"messageId"</code> must be unique within each batch sent.</p>
    public let messageId: String?
    /// <p>The new state, variable values, and timer settings of the detector (instance).</p>
    public let state: DetectorStateDefinition?

    public init (
        detectorModelName: String? = nil,
        keyValue: String? = nil,
        messageId: String? = nil,
        state: DetectorStateDefinition? = nil
    )
    {
        self.detectorModelName = detectorModelName
        self.keyValue = keyValue
        self.messageId = messageId
        self.state = state
    }
}

extension Variable: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Variable: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Variable(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>The current state of the variable.</p>
public struct Variable: Equatable {
    /// <p>The name of the variable.</p>
    public let name: String?
    /// <p>The current value of the variable.</p>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

extension VariableDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension VariableDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VariableDefinition(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>The new value of the variable.</p>
public struct VariableDefinition: Equatable {
    /// <p>The name of the variable.</p>
    public let name: String?
    /// <p>The new value of the variable.</p>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}
