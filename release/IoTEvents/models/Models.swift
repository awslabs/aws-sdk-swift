// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AcknowledgeFlow: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AcknowledgeFlow: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcknowledgeFlow(enabled: \(String(describing: enabled)))"}
}

/// <p>Specifies whether to get notified for alarm state changes.</p>
public struct AcknowledgeFlow: Equatable {
    /// <p>The value must be <code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, you
    ///       receive a notification when the alarm state changes. You must choose to acknowledge the
    ///       notification before the alarm state can return to <code>NORMAL</code>. If <code>FALSE</code>,
    ///       you won't receive notifications. The alarm automatically changes to the <code>NORMAL</code>
    ///       state when the input property value returns to the specified range.</p>
    public let enabled: Bool?

    public init (
        enabled: Bool? = nil
    )
    {
        self.enabled = enabled
    }
}

extension Action: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clearTimer
        case dynamoDB
        case dynamoDBv2
        case firehose
        case iotEvents
        case iotSiteWise
        case iotTopicPublish
        case lambda
        case resetTimer
        case setTimer
        case setVariable
        case sns
        case sqs
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clearTimer = clearTimer {
            try encodeContainer.encode(clearTimer, forKey: .clearTimer)
        }
        if let dynamoDB = dynamoDB {
            try encodeContainer.encode(dynamoDB, forKey: .dynamoDB)
        }
        if let dynamoDBv2 = dynamoDBv2 {
            try encodeContainer.encode(dynamoDBv2, forKey: .dynamoDBv2)
        }
        if let firehose = firehose {
            try encodeContainer.encode(firehose, forKey: .firehose)
        }
        if let iotEvents = iotEvents {
            try encodeContainer.encode(iotEvents, forKey: .iotEvents)
        }
        if let iotSiteWise = iotSiteWise {
            try encodeContainer.encode(iotSiteWise, forKey: .iotSiteWise)
        }
        if let iotTopicPublish = iotTopicPublish {
            try encodeContainer.encode(iotTopicPublish, forKey: .iotTopicPublish)
        }
        if let lambda = lambda {
            try encodeContainer.encode(lambda, forKey: .lambda)
        }
        if let resetTimer = resetTimer {
            try encodeContainer.encode(resetTimer, forKey: .resetTimer)
        }
        if let setTimer = setTimer {
            try encodeContainer.encode(setTimer, forKey: .setTimer)
        }
        if let setVariable = setVariable {
            try encodeContainer.encode(setVariable, forKey: .setVariable)
        }
        if let sns = sns {
            try encodeContainer.encode(sns, forKey: .sns)
        }
        if let sqs = sqs {
            try encodeContainer.encode(sqs, forKey: .sqs)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let setVariableDecoded = try containerValues.decodeIfPresent(SetVariableAction.self, forKey: .setVariable)
        setVariable = setVariableDecoded
        let snsDecoded = try containerValues.decodeIfPresent(SNSTopicPublishAction.self, forKey: .sns)
        sns = snsDecoded
        let iotTopicPublishDecoded = try containerValues.decodeIfPresent(IotTopicPublishAction.self, forKey: .iotTopicPublish)
        iotTopicPublish = iotTopicPublishDecoded
        let setTimerDecoded = try containerValues.decodeIfPresent(SetTimerAction.self, forKey: .setTimer)
        setTimer = setTimerDecoded
        let clearTimerDecoded = try containerValues.decodeIfPresent(ClearTimerAction.self, forKey: .clearTimer)
        clearTimer = clearTimerDecoded
        let resetTimerDecoded = try containerValues.decodeIfPresent(ResetTimerAction.self, forKey: .resetTimer)
        resetTimer = resetTimerDecoded
        let lambdaDecoded = try containerValues.decodeIfPresent(LambdaAction.self, forKey: .lambda)
        lambda = lambdaDecoded
        let iotEventsDecoded = try containerValues.decodeIfPresent(IotEventsAction.self, forKey: .iotEvents)
        iotEvents = iotEventsDecoded
        let sqsDecoded = try containerValues.decodeIfPresent(SqsAction.self, forKey: .sqs)
        sqs = sqsDecoded
        let firehoseDecoded = try containerValues.decodeIfPresent(FirehoseAction.self, forKey: .firehose)
        firehose = firehoseDecoded
        let dynamoDBDecoded = try containerValues.decodeIfPresent(DynamoDBAction.self, forKey: .dynamoDB)
        dynamoDB = dynamoDBDecoded
        let dynamoDBv2Decoded = try containerValues.decodeIfPresent(DynamoDBv2Action.self, forKey: .dynamoDBv2)
        dynamoDBv2 = dynamoDBv2Decoded
        let iotSiteWiseDecoded = try containerValues.decodeIfPresent(IotSiteWiseAction.self, forKey: .iotSiteWise)
        iotSiteWise = iotSiteWiseDecoded
    }
}

extension Action: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Action(clearTimer: \(String(describing: clearTimer)), dynamoDB: \(String(describing: dynamoDB)), dynamoDBv2: \(String(describing: dynamoDBv2)), firehose: \(String(describing: firehose)), iotEvents: \(String(describing: iotEvents)), iotSiteWise: \(String(describing: iotSiteWise)), iotTopicPublish: \(String(describing: iotTopicPublish)), lambda: \(String(describing: lambda)), resetTimer: \(String(describing: resetTimer)), setTimer: \(String(describing: setTimer)), setVariable: \(String(describing: setVariable)), sns: \(String(describing: sns)), sqs: \(String(describing: sqs)))"}
}

/// <p>An action to be performed when the <code>condition</code> is TRUE.</p>
public struct Action: Equatable {
    /// <p>Information needed to clear the timer.</p>
    public let clearTimer: ClearTimerAction?
    /// <p>Writes to the DynamoDB table that you created. The default action payload contains all
    ///       attribute-value pairs that have the information about the detector model instance and the
    ///       event that triggered the action. You can customize the <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html">payload</a>. One column of the
    ///       DynamoDB table receives all attribute-value pairs in the payload that you specify. For more
    ///       information, see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-event-actions.html">Actions</a> in
    ///         <i>AWS IoT Events Developer Guide</i>.</p>
    public let dynamoDB: DynamoDBAction?
    /// <p>Writes to the DynamoDB table that you created. The default action payload contains all
    ///       attribute-value pairs that have the information about the detector model instance and the
    ///       event that triggered the action. You can customize the <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html">payload</a>. A separate column of
    ///       the DynamoDB table receives one attribute-value pair in the payload that you specify. For more
    ///       information, see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-event-actions.html">Actions</a> in
    ///         <i>AWS IoT Events Developer Guide</i>.</p>
    public let dynamoDBv2: DynamoDBv2Action?
    /// <p>Sends information about the detector model instance and the event that triggered the
    ///       action to an Amazon Kinesis Data Firehose delivery stream.</p>
    public let firehose: FirehoseAction?
    /// <p>Sends AWS IoT Events input, which passes information about the detector model instance and the
    ///       event that triggered the action.</p>
    public let iotEvents: IotEventsAction?
    /// <p>Sends information about the detector model instance and the event that triggered the
    ///       action to an asset property in AWS IoT SiteWise .</p>
    public let iotSiteWise: IotSiteWiseAction?
    /// <p>Publishes an MQTT message with the given topic to the AWS IoT message broker.</p>
    public let iotTopicPublish: IotTopicPublishAction?
    /// <p>Calls a Lambda function, passing in information about the detector model instance and the
    ///       event that triggered the action.</p>
    public let lambda: LambdaAction?
    /// <p>Information needed to reset the timer.</p>
    public let resetTimer: ResetTimerAction?
    /// <p>Information needed to set the timer.</p>
    public let setTimer: SetTimerAction?
    /// <p>Sets a variable to a specified value.</p>
    public let setVariable: SetVariableAction?
    /// <p>Sends an Amazon SNS message.</p>
    public let sns: SNSTopicPublishAction?
    /// <p>Sends information about the detector model instance and the event that triggered the
    ///       action to an Amazon SQS queue.</p>
    public let sqs: SqsAction?

    public init (
        clearTimer: ClearTimerAction? = nil,
        dynamoDB: DynamoDBAction? = nil,
        dynamoDBv2: DynamoDBv2Action? = nil,
        firehose: FirehoseAction? = nil,
        iotEvents: IotEventsAction? = nil,
        iotSiteWise: IotSiteWiseAction? = nil,
        iotTopicPublish: IotTopicPublishAction? = nil,
        lambda: LambdaAction? = nil,
        resetTimer: ResetTimerAction? = nil,
        setTimer: SetTimerAction? = nil,
        setVariable: SetVariableAction? = nil,
        sns: SNSTopicPublishAction? = nil,
        sqs: SqsAction? = nil
    )
    {
        self.clearTimer = clearTimer
        self.dynamoDB = dynamoDB
        self.dynamoDBv2 = dynamoDBv2
        self.firehose = firehose
        self.iotEvents = iotEvents
        self.iotSiteWise = iotSiteWise
        self.iotTopicPublish = iotTopicPublish
        self.lambda = lambda
        self.resetTimer = resetTimer
        self.setTimer = setTimer
        self.setVariable = setVariable
        self.sns = sns
        self.sqs = sqs
    }
}

extension AlarmAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dynamoDB
        case dynamoDBv2
        case firehose
        case iotEvents
        case iotSiteWise
        case iotTopicPublish
        case lambda
        case sns
        case sqs
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dynamoDB = dynamoDB {
            try encodeContainer.encode(dynamoDB, forKey: .dynamoDB)
        }
        if let dynamoDBv2 = dynamoDBv2 {
            try encodeContainer.encode(dynamoDBv2, forKey: .dynamoDBv2)
        }
        if let firehose = firehose {
            try encodeContainer.encode(firehose, forKey: .firehose)
        }
        if let iotEvents = iotEvents {
            try encodeContainer.encode(iotEvents, forKey: .iotEvents)
        }
        if let iotSiteWise = iotSiteWise {
            try encodeContainer.encode(iotSiteWise, forKey: .iotSiteWise)
        }
        if let iotTopicPublish = iotTopicPublish {
            try encodeContainer.encode(iotTopicPublish, forKey: .iotTopicPublish)
        }
        if let lambda = lambda {
            try encodeContainer.encode(lambda, forKey: .lambda)
        }
        if let sns = sns {
            try encodeContainer.encode(sns, forKey: .sns)
        }
        if let sqs = sqs {
            try encodeContainer.encode(sqs, forKey: .sqs)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsDecoded = try containerValues.decodeIfPresent(SNSTopicPublishAction.self, forKey: .sns)
        sns = snsDecoded
        let iotTopicPublishDecoded = try containerValues.decodeIfPresent(IotTopicPublishAction.self, forKey: .iotTopicPublish)
        iotTopicPublish = iotTopicPublishDecoded
        let lambdaDecoded = try containerValues.decodeIfPresent(LambdaAction.self, forKey: .lambda)
        lambda = lambdaDecoded
        let iotEventsDecoded = try containerValues.decodeIfPresent(IotEventsAction.self, forKey: .iotEvents)
        iotEvents = iotEventsDecoded
        let sqsDecoded = try containerValues.decodeIfPresent(SqsAction.self, forKey: .sqs)
        sqs = sqsDecoded
        let firehoseDecoded = try containerValues.decodeIfPresent(FirehoseAction.self, forKey: .firehose)
        firehose = firehoseDecoded
        let dynamoDBDecoded = try containerValues.decodeIfPresent(DynamoDBAction.self, forKey: .dynamoDB)
        dynamoDB = dynamoDBDecoded
        let dynamoDBv2Decoded = try containerValues.decodeIfPresent(DynamoDBv2Action.self, forKey: .dynamoDBv2)
        dynamoDBv2 = dynamoDBv2Decoded
        let iotSiteWiseDecoded = try containerValues.decodeIfPresent(IotSiteWiseAction.self, forKey: .iotSiteWise)
        iotSiteWise = iotSiteWiseDecoded
    }
}

extension AlarmAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlarmAction(dynamoDB: \(String(describing: dynamoDB)), dynamoDBv2: \(String(describing: dynamoDBv2)), firehose: \(String(describing: firehose)), iotEvents: \(String(describing: iotEvents)), iotSiteWise: \(String(describing: iotSiteWise)), iotTopicPublish: \(String(describing: iotTopicPublish)), lambda: \(String(describing: lambda)), sns: \(String(describing: sns)), sqs: \(String(describing: sqs)))"}
}

/// <p>Specifies one of the following actions to receive notifications when the alarm state
///       changes.</p>
public struct AlarmAction: Equatable {
    /// <p>Defines an action to write to the Amazon DynamoDB table that you created. The standard action
    ///       payload contains all the information about the detector model instance and the event that
    ///       triggered the action. You can customize the <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html">payload</a>. One column of the
    ///       DynamoDB table receives all attribute-value pairs in the payload that you specify.</p>
    ///          <p>You must use expressions for all parameters in <code>DynamoDBAction</code>. The expressions
    ///       accept literals, operators, functions, references, and substitution templates.</p>
    ///          <p class="title">
    ///             <b>Examples</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>For literal values, the expressions must contain single quotes. For example, the value
    ///           for the <code>hashKeyType</code> parameter can be <code>'STRING'</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>For references, you must specify either variables or input values. For example, the
    ///           value for the <code>hashKeyField</code> parameter can be
    ///             <code>$input.GreenhouseInput.name</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>For a substitution template, you must use <code>${}</code>, and the template must be
    ///           in single quotes. A substitution template can also contain a combination of literals,
    ///           operators, functions, references, and substitution templates.</p>
    ///                <p>In the following example, the value for the <code>hashKeyValue</code> parameter uses a
    ///           substitution template. </p>
    ///                <p>
    ///                   <code>'${$input.GreenhouseInput.temperature * 6 / 5 + 32} in Fahrenheit'</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>For a string concatenation, you must use <code>+</code>. A string concatenation can
    ///           also contain a combination of literals, operators, functions, references, and substitution
    ///           templates.</p>
    ///                <p>In the following example, the value for the <code>tableName</code> parameter uses a
    ///           string concatenation. </p>
    ///                <p>
    ///                   <code>'GreenhouseTemperatureTable ' + $input.GreenhouseInput.date</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information,
    ///         see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html">Expressions</a>
    ///         in the <i>AWS IoT Events Developer Guide</i>.</p>
    ///          <p>If the defined payload type is a string, <code>DynamoDBAction</code> writes non-JSON data to
    ///       the DynamoDB table as binary data. The DynamoDB console displays the data as Base64-encoded text.
    ///       The value for the <code>payloadField</code> parameter is
    ///         <code><payload-field>_raw</code>.</p>
    public let dynamoDB: DynamoDBAction?
    /// <p>Defines an action to write to the Amazon DynamoDB table that you created. The default action
    ///       payload contains all the information about the detector model instance and the event that
    ///       triggered the action. You can customize the <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html">payload</a>. A separate column of
    ///       the DynamoDB table receives one attribute-value pair in the payload that you specify.</p>
    ///          <p>You must use expressions for all parameters in <code>DynamoDBv2Action</code>. The expressions
    ///       accept literals, operators, functions, references, and substitution templates.</p>
    ///          <p class="title">
    ///             <b>Examples</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>For literal values, the expressions must contain single quotes. For example, the value
    ///           for the <code>tableName</code> parameter can be
    ///           <code>'GreenhouseTemperatureTable'</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>For references, you must specify either variables or input values. For example, the
    ///           value for the <code>tableName</code> parameter can be
    ///           <code>$variable.ddbtableName</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>For a substitution template, you must use <code>${}</code>, and the template must be
    ///           in single quotes. A substitution template can also contain a combination of literals,
    ///           operators, functions, references, and substitution templates.</p>
    ///                <p>In the following example, the value for the <code>contentExpression</code> parameter
    ///           in <code>Payload</code> uses a substitution template. </p>
    ///                <p>
    ///                   <code>'{\"sensorID\": \"${$input.GreenhouseInput.sensor_id}\", \"temperature\":
    ///             \"${$input.GreenhouseInput.temperature * 9 / 5 + 32}\"}'</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>For a string concatenation, you must use <code>+</code>. A string concatenation can
    ///           also contain a combination of literals, operators, functions, references, and substitution
    ///           templates.</p>
    ///                <p>In the following example, the value for the <code>tableName</code> parameter uses a
    ///           string concatenation. </p>
    ///                <p>
    ///                   <code>'GreenhouseTemperatureTable ' + $input.GreenhouseInput.date</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information,
    ///         see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html">Expressions</a>
    ///         in the <i>AWS IoT Events Developer Guide</i>.</p>
    ///          <p>The value for the <code>type</code> parameter in <code>Payload</code> must be
    ///         <code>JSON</code>.</p>
    public let dynamoDBv2: DynamoDBv2Action?
    /// <p>Sends information about the detector model instance and the event that triggered the
    ///       action to an Amazon Kinesis Data Firehose delivery stream.</p>
    public let firehose: FirehoseAction?
    /// <p>Sends an AWS IoT Events input, passing in information about the detector model instance and the
    ///       event that triggered the action.</p>
    public let iotEvents: IotEventsAction?
    /// <p>Sends information about the detector model instance and the event that triggered the
    ///       action to a specified asset property in AWS IoT SiteWise.</p>
    ///          <p>You must use expressions for all parameters in <code>IotSiteWiseAction</code>. The
    ///       expressions accept literals, operators, functions, references, and substitutions
    ///       templates.</p>
    ///          <p class="title">
    ///             <b>Examples</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>For literal values, the expressions must contain single quotes. For example, the value
    ///           for the <code>propertyAlias</code> parameter can be
    ///             <code>'/company/windfarm/3/turbine/7/temperature'</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>For references, you must specify either variables or input values. For example, the
    ///           value for the <code>assetId</code> parameter can be
    ///             <code>$input.TurbineInput.assetId1</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>For a substitution template, you must use <code>${}</code>, and the template must be
    ///           in single quotes. A substitution template can also contain a combination of literals,
    ///           operators, functions, references, and substitution templates.</p>
    ///                <p>In the following example, the value for the <code>propertyAlias</code> parameter uses
    ///           a substitution template. </p>
    ///                <p>
    ///                   <code>'company/windfarm/${$input.TemperatureInput.sensorData.windfarmID}/turbine/
    ///             ${$input.TemperatureInput.sensorData.turbineID}/temperature'</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>You must specify either <code>propertyAlias</code> or both <code>assetId</code> and
    ///         <code>propertyId</code> to identify the target asset property in AWS IoT SiteWise.</p>
    ///          <p>For more information,
    ///         see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html">Expressions</a>
    ///         in the <i>AWS IoT Events Developer Guide</i>.</p>
    public let iotSiteWise: IotSiteWiseAction?
    /// <p>Information required to publish the MQTT message through the AWS IoT message broker.</p>
    public let iotTopicPublish: IotTopicPublishAction?
    /// <p>Calls a Lambda function, passing in information about the detector model instance and the
    ///       event that triggered the action.</p>
    public let lambda: LambdaAction?
    /// <p>Information required to publish the Amazon SNS message.</p>
    public let sns: SNSTopicPublishAction?
    /// <p>Sends information about the detector model instance and the event that triggered the
    ///       action to an Amazon SQS queue.</p>
    public let sqs: SqsAction?

    public init (
        dynamoDB: DynamoDBAction? = nil,
        dynamoDBv2: DynamoDBv2Action? = nil,
        firehose: FirehoseAction? = nil,
        iotEvents: IotEventsAction? = nil,
        iotSiteWise: IotSiteWiseAction? = nil,
        iotTopicPublish: IotTopicPublishAction? = nil,
        lambda: LambdaAction? = nil,
        sns: SNSTopicPublishAction? = nil,
        sqs: SqsAction? = nil
    )
    {
        self.dynamoDB = dynamoDB
        self.dynamoDBv2 = dynamoDBv2
        self.firehose = firehose
        self.iotEvents = iotEvents
        self.iotSiteWise = iotSiteWise
        self.iotTopicPublish = iotTopicPublish
        self.lambda = lambda
        self.sns = sns
        self.sqs = sqs
    }
}

extension AlarmCapabilities: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acknowledgeFlow
        case initializationConfiguration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acknowledgeFlow = acknowledgeFlow {
            try encodeContainer.encode(acknowledgeFlow, forKey: .acknowledgeFlow)
        }
        if let initializationConfiguration = initializationConfiguration {
            try encodeContainer.encode(initializationConfiguration, forKey: .initializationConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initializationConfigurationDecoded = try containerValues.decodeIfPresent(InitializationConfiguration.self, forKey: .initializationConfiguration)
        initializationConfiguration = initializationConfigurationDecoded
        let acknowledgeFlowDecoded = try containerValues.decodeIfPresent(AcknowledgeFlow.self, forKey: .acknowledgeFlow)
        acknowledgeFlow = acknowledgeFlowDecoded
    }
}

extension AlarmCapabilities: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlarmCapabilities(acknowledgeFlow: \(String(describing: acknowledgeFlow)), initializationConfiguration: \(String(describing: initializationConfiguration)))"}
}

/// <p>Contains the configuration information of alarm state changes.</p>
public struct AlarmCapabilities: Equatable {
    /// <p>Specifies whether to get notified for alarm state changes.</p>
    public let acknowledgeFlow: AcknowledgeFlow?
    /// <p>Specifies the default alarm state.
    /// The configuration applies to all alarms that were created based on this alarm model.</p>
    public let initializationConfiguration: InitializationConfiguration?

    public init (
        acknowledgeFlow: AcknowledgeFlow? = nil,
        initializationConfiguration: InitializationConfiguration? = nil
    )
    {
        self.acknowledgeFlow = acknowledgeFlow
        self.initializationConfiguration = initializationConfiguration
    }
}

extension AlarmEventActions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alarmActions
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmActions = alarmActions {
            var alarmActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .alarmActions)
            for alarmactions0 in alarmActions {
                try alarmActionsContainer.encode(alarmactions0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmActionsContainer = try containerValues.decodeIfPresent([AlarmAction?].self, forKey: .alarmActions)
        var alarmActionsDecoded0:[AlarmAction]? = nil
        if let alarmActionsContainer = alarmActionsContainer {
            alarmActionsDecoded0 = [AlarmAction]()
            for structure0 in alarmActionsContainer {
                if let structure0 = structure0 {
                    alarmActionsDecoded0?.append(structure0)
                }
            }
        }
        alarmActions = alarmActionsDecoded0
    }
}

extension AlarmEventActions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlarmEventActions(alarmActions: \(String(describing: alarmActions)))"}
}

/// <p>Contains information about one or more alarm actions.</p>
public struct AlarmEventActions: Equatable {
    /// <p>Specifies one or more supported actions to receive notifications when the alarm state
    ///       changes.</p>
    public let alarmActions: [AlarmAction]?

    public init (
        alarmActions: [AlarmAction]? = nil
    )
    {
        self.alarmActions = alarmActions
    }
}

extension AlarmModelSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alarmModelDescription
        case alarmModelName
        case creationTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelDescription = alarmModelDescription {
            try encodeContainer.encode(alarmModelDescription, forKey: .alarmModelDescription)
        }
        if let alarmModelName = alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let alarmModelDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelDescription)
        alarmModelDescription = alarmModelDescriptionDecoded
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
    }
}

extension AlarmModelSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlarmModelSummary(alarmModelDescription: \(String(describing: alarmModelDescription)), alarmModelName: \(String(describing: alarmModelName)), creationTime: \(String(describing: creationTime)))"}
}

/// <p>Contains a summary of an alarm model.</p>
public struct AlarmModelSummary: Equatable {
    /// <p>The description of the alarm model.</p>
    public let alarmModelDescription: String?
    /// <p>The name of the alarm model.</p>
    public let alarmModelName: String?
    /// <p>The time the alarm model was created, in the Unix epoch format.</p>
    public let creationTime: Date?

    public init (
        alarmModelDescription: String? = nil,
        alarmModelName: String? = nil,
        creationTime: Date? = nil
    )
    {
        self.alarmModelDescription = alarmModelDescription
        self.alarmModelName = alarmModelName
        self.creationTime = creationTime
    }
}

public enum AlarmModelVersionStatus {
    case activating
    case active
    case failed
    case inactive
    case sdkUnknown(String)
}

extension AlarmModelVersionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AlarmModelVersionStatus] {
        return [
            .activating,
            .active,
            .failed,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .activating: return "ACTIVATING"
        case .active: return "ACTIVE"
        case .failed: return "FAILED"
        case .inactive: return "INACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AlarmModelVersionStatus(rawValue: rawValue) ?? AlarmModelVersionStatus.sdkUnknown(rawValue)
    }
}

extension AlarmModelVersionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alarmModelArn
        case alarmModelName
        case alarmModelVersion
        case creationTime
        case lastUpdateTime
        case roleArn
        case status
        case statusMessage
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelArn = alarmModelArn {
            try encodeContainer.encode(alarmModelArn, forKey: .alarmModelArn)
        }
        if let alarmModelName = alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let alarmModelVersion = alarmModelVersion {
            try encodeContainer.encode(alarmModelVersion, forKey: .alarmModelVersion)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let alarmModelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelArn)
        alarmModelArn = alarmModelArnDecoded
        let alarmModelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelVersion)
        alarmModelVersion = alarmModelVersionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AlarmModelVersionStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension AlarmModelVersionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlarmModelVersionSummary(alarmModelArn: \(String(describing: alarmModelArn)), alarmModelName: \(String(describing: alarmModelName)), alarmModelVersion: \(String(describing: alarmModelVersion)), creationTime: \(String(describing: creationTime)), lastUpdateTime: \(String(describing: lastUpdateTime)), roleArn: \(String(describing: roleArn)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)))"}
}

/// <p>Contains a summary of an alarm model version.</p>
public struct AlarmModelVersionSummary: Equatable {
    /// <p>The ARN of the alarm model. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let alarmModelArn: String?
    /// <p>The name of the alarm model.</p>
    public let alarmModelName: String?
    /// <p>The version of the alarm model.</p>
    public let alarmModelVersion: String?
    /// <p>The time the alarm model was created, in the Unix epoch format.</p>
    public let creationTime: Date?
    /// <p>The time the alarm model was last updated, in the Unix epoch format.</p>
    public let lastUpdateTime: Date?
    /// <p>The ARN of the IAM role that allows the alarm to perform actions and access AWS resources. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let roleArn: String?
    /// <p>The status of the alarm model. The status can be one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code> - The alarm model is active and it's ready to evaluate data.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVATING</code> - AWS IoT Events is activating your alarm model.
    ///         Activating an alarm model can take up to a few minutes.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INACTIVE</code> - The alarm model is inactive, so it isn't ready to evaluate data.
    /// 	  Check your alarm model information and update the alarm model.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code> - You couldn't create or update the alarm model. Check your alarm model information
    ///         and try again.</p>
    ///             </li>
    ///          </ul>
    public let status: AlarmModelVersionStatus?
    /// <p>
    ///       Contains information about the status of the alarm model version.
    ///     </p>
    public let statusMessage: String?

    public init (
        alarmModelArn: String? = nil,
        alarmModelName: String? = nil,
        alarmModelVersion: String? = nil,
        creationTime: Date? = nil,
        lastUpdateTime: Date? = nil,
        roleArn: String? = nil,
        status: AlarmModelVersionStatus? = nil,
        statusMessage: String? = nil
    )
    {
        self.alarmModelArn = alarmModelArn
        self.alarmModelName = alarmModelName
        self.alarmModelVersion = alarmModelVersion
        self.creationTime = creationTime
        self.lastUpdateTime = lastUpdateTime
        self.roleArn = roleArn
        self.status = status
        self.statusMessage = statusMessage
    }
}

extension AlarmNotification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case notificationActions
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notificationActions = notificationActions {
            var notificationActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationActions)
            for notificationactions0 in notificationActions {
                try notificationActionsContainer.encode(notificationactions0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationActionsContainer = try containerValues.decodeIfPresent([NotificationAction?].self, forKey: .notificationActions)
        var notificationActionsDecoded0:[NotificationAction]? = nil
        if let notificationActionsContainer = notificationActionsContainer {
            notificationActionsDecoded0 = [NotificationAction]()
            for structure0 in notificationActionsContainer {
                if let structure0 = structure0 {
                    notificationActionsDecoded0?.append(structure0)
                }
            }
        }
        notificationActions = notificationActionsDecoded0
    }
}

extension AlarmNotification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlarmNotification(notificationActions: \(String(describing: notificationActions)))"}
}

/// <p>Contains information about one or more notification actions.</p>
public struct AlarmNotification: Equatable {
    /// <p>Contains the notification settings of an alarm model.
    /// The settings apply to all alarms that were created based on this alarm model.</p>
    public let notificationActions: [NotificationAction]?

    public init (
        notificationActions: [NotificationAction]? = nil
    )
    {
        self.notificationActions = notificationActions
    }
}

extension AlarmRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case simpleRule
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simpleRule = simpleRule {
            try encodeContainer.encode(simpleRule, forKey: .simpleRule)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simpleRuleDecoded = try containerValues.decodeIfPresent(SimpleRule.self, forKey: .simpleRule)
        simpleRule = simpleRuleDecoded
    }
}

extension AlarmRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlarmRule(simpleRule: \(String(describing: simpleRule)))"}
}

/// <p>Defines when your alarm is invoked.</p>
public struct AlarmRule: Equatable {
    /// <p>A rule that compares an input property value to a threshold value with a comparison operator.</p>
    public let simpleRule: SimpleRule?

    public init (
        simpleRule: SimpleRule? = nil
    )
    {
        self.simpleRule = simpleRule
    }
}

extension AnalysisResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case level
        case locations
        case message
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let level = level {
            try encodeContainer.encode(level.rawValue, forKey: .level)
        }
        if let locations = locations {
            var locationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .locations)
            for analysisresultlocations0 in locations {
                try locationsContainer.encode(analysisresultlocations0)
            }
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let levelDecoded = try containerValues.decodeIfPresent(AnalysisResultLevel.self, forKey: .level)
        level = levelDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let locationsContainer = try containerValues.decodeIfPresent([AnalysisResultLocation?].self, forKey: .locations)
        var locationsDecoded0:[AnalysisResultLocation]? = nil
        if let locationsContainer = locationsContainer {
            locationsDecoded0 = [AnalysisResultLocation]()
            for structure0 in locationsContainer {
                if let structure0 = structure0 {
                    locationsDecoded0?.append(structure0)
                }
            }
        }
        locations = locationsDecoded0
    }
}

extension AnalysisResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnalysisResult(level: \(String(describing: level)), locations: \(String(describing: locations)), message: \(String(describing: message)), type: \(String(describing: type)))"}
}

/// <p>Contains the result of the analysis.</p>
public struct AnalysisResult: Equatable {
    /// <p>The severity level of the analysis result. Based on the severity level, analysis results
    ///       fall into three general categories:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>INFO</code> - An information result tells you about a significant field in your
    ///           detector model. This type of result usually doesn't require immediate action.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>WARNING</code> - A warning result draws special attention to fields that might cause issues for your detector model.
    ///           We recommend that you review warnings and take necessary actions
    ///           before you use your detector model in production environments. Otherwise, the detector
    ///           model might not work as expected.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ERROR</code> - An error result notifies you about a problem found in your
    ///           detector model. You must fix all errors before you can publish your detector model.</p>
    ///             </li>
    ///          </ul>
    public let level: AnalysisResultLevel?
    /// <p>Contains one or more locations that you can use to locate the fields in your detector
    ///       model that the analysis result references.</p>
    public let locations: [AnalysisResultLocation]?
    /// <p>Contains additional information about the analysis result.</p>
    public let message: String?
    /// <p>The type of the analysis result. Analyses fall into the following types based on the
    ///       validators used to generate the analysis result:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>supported-actions</code> - You must specify AWS IoT Events supported actions that work
    ///           with other AWS services in a supported AWS Region.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>service-limits</code> - Resources or API operations can't exceed service
    ///           quotas (also known as limits). Update your detector model or request a quota
    ///           increase.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>structure</code> - The detector model must follow a structure that AWS IoT Events
    ///           supports. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>expression-syntax</code> - Your expression must follow the required
    ///           syntax.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>data-type</code> - Data types referenced in the detector model must be
    ///           compatible.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>referenced-data</code> - You must define the data referenced in your detector
    ///           model before you can use the data.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>referenced-resource</code> - Resources that the detector model uses must be
    ///           available.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-analyze-api.html">Running detector model
    ///         analyses</a> in the <i>AWS IoT Events Developer Guide</i>.</p>
    public let type: String?

    public init (
        level: AnalysisResultLevel? = nil,
        locations: [AnalysisResultLocation]? = nil,
        message: String? = nil,
        type: String? = nil
    )
    {
        self.level = level
        self.locations = locations
        self.message = message
        self.type = type
    }
}

public enum AnalysisResultLevel {
    case error
    case info
    case warning
    case sdkUnknown(String)
}

extension AnalysisResultLevel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AnalysisResultLevel] {
        return [
            .error,
            .info,
            .warning,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .error: return "ERROR"
        case .info: return "INFO"
        case .warning: return "WARNING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AnalysisResultLevel(rawValue: rawValue) ?? AnalysisResultLevel.sdkUnknown(rawValue)
    }
}

extension AnalysisResultLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case path
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
    }
}

extension AnalysisResultLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnalysisResultLocation(path: \(String(describing: path)))"}
}

/// <p>Contains information that you can use to locate the field in your detector model that the
///       analysis result references.</p>
public struct AnalysisResultLocation: Equatable {
    /// <p>A <a href="https://github.com/json-path/JsonPath">JsonPath</a> expression that
    ///       identifies the error field in your detector model.</p>
    public let path: String?

    public init (
        path: String? = nil
    )
    {
        self.path = path
    }
}

public enum AnalysisStatus {
    case complete
    case failed
    case running
    case sdkUnknown(String)
}

extension AnalysisStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AnalysisStatus] {
        return [
            .complete,
            .failed,
            .running,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .complete: return "COMPLETE"
        case .failed: return "FAILED"
        case .running: return "RUNNING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AnalysisStatus(rawValue: rawValue) ?? AnalysisStatus.sdkUnknown(rawValue)
    }
}

extension AssetPropertyTimestamp: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case offsetInNanos
        case timeInSeconds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let offsetInNanos = offsetInNanos {
            try encodeContainer.encode(offsetInNanos, forKey: .offsetInNanos)
        }
        if let timeInSeconds = timeInSeconds {
            try encodeContainer.encode(timeInSeconds, forKey: .timeInSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeInSecondsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeInSeconds)
        timeInSeconds = timeInSecondsDecoded
        let offsetInNanosDecoded = try containerValues.decodeIfPresent(String.self, forKey: .offsetInNanos)
        offsetInNanos = offsetInNanosDecoded
    }
}

extension AssetPropertyTimestamp: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetPropertyTimestamp(offsetInNanos: \(String(describing: offsetInNanos)), timeInSeconds: \(String(describing: timeInSeconds)))"}
}

/// <p>A structure that contains timestamp information. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_TimeInNanos.html">TimeInNanos</a> in the <i>AWS IoT SiteWise API Reference</i>.</p>
///          <p>You must use expressions for all parameters in <code>AssetPropertyTimestamp</code>. The
///       expressions accept literals, operators, functions, references, and substitution
///       templates.</p>
///          <p class="title">
///             <b>Examples</b>
///          </p>
///          <ul>
///             <li>
///                <p>For literal values, the expressions must contain single quotes. For example, the value
///           for the <code>timeInSeconds</code> parameter can be <code>'1586400675'</code>.</p>
///             </li>
///             <li>
///                <p>For references, you must specify either variables or input values. For example, the
///           value for the <code>offsetInNanos</code> parameter can be
///           <code>$variable.time</code>.</p>
///             </li>
///             <li>
///                <p>For a substitution template, you must use <code>${}</code>, and the template must be
///           in single quotes. A substitution template can also contain a combination of literals,
///           operators, functions, references, and substitution templates.</p>
///                <p>In the following example, the value for the <code>timeInSeconds</code> parameter uses
///           a substitution template.</p>
///                <p>
///                   <code>'${$input.TemperatureInput.sensorData.timestamp / 1000}'</code>
///                </p>
///             </li>
///          </ul>
///          <p>For more information,
///         see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html">Expressions</a>
///         in the <i>AWS IoT Events Developer Guide</i>.</p>
public struct AssetPropertyTimestamp: Equatable {
    /// <p>The nanosecond offset converted from <code>timeInSeconds</code>. The valid range is
    ///       between 0-999999999.</p>
    public let offsetInNanos: String?
    /// <p>The timestamp, in seconds, in the Unix epoch format. The valid range is between
    ///       1-31556889864403199.</p>
    public let timeInSeconds: String?

    public init (
        offsetInNanos: String? = nil,
        timeInSeconds: String? = nil
    )
    {
        self.offsetInNanos = offsetInNanos
        self.timeInSeconds = timeInSeconds
    }
}

extension AssetPropertyValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case quality
        case timestamp
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quality = quality {
            try encodeContainer.encode(quality, forKey: .quality)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(AssetPropertyVariant.self, forKey: .value)
        value = valueDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(AssetPropertyTimestamp.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let qualityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quality)
        quality = qualityDecoded
    }
}

extension AssetPropertyValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetPropertyValue(quality: \(String(describing: quality)), timestamp: \(String(describing: timestamp)), value: \(String(describing: value)))"}
}

/// <p>A structure that contains value information. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_AssetPropertyValue.html">AssetPropertyValue</a> in the <i>AWS IoT SiteWise API Reference</i>.</p>
///          <p>You must use expressions for all parameters in <code>AssetPropertyValue</code>. The
///       expressions accept literals, operators, functions, references, and substitution
///       templates.</p>
///          <p class="title">
///             <b>Examples</b>
///          </p>
///          <ul>
///             <li>
///                <p>For literal values, the expressions must contain single quotes. For example, the value
///           for the <code>quality</code> parameter can be <code>'GOOD'</code>.</p>
///             </li>
///             <li>
///                <p>For references, you must specify either variables or input values. For example, the
///           value for the <code>quality</code> parameter can be
///             <code>$input.TemperatureInput.sensorData.quality</code>.</p>
///             </li>
///          </ul>
///          <p>For more information,
///         see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html">Expressions</a>
///         in the <i>AWS IoT Events Developer Guide</i>.</p>
public struct AssetPropertyValue: Equatable {
    /// <p>The quality of the asset property value. The value must be <code>'GOOD'</code>,
    ///         <code>'BAD'</code>, or <code>'UNCERTAIN'</code>.</p>
    public let quality: String?
    /// <p>The timestamp associated with the asset property value. The default is the current event
    ///       time.</p>
    public let timestamp: AssetPropertyTimestamp?
    /// <p>The value to send to an asset property.</p>
    public let value: AssetPropertyVariant?

    public init (
        quality: String? = nil,
        timestamp: AssetPropertyTimestamp? = nil,
        value: AssetPropertyVariant? = nil
    )
    {
        self.quality = quality
        self.timestamp = timestamp
        self.value = value
    }
}

extension AssetPropertyVariant: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case booleanValue
        case doubleValue
        case integerValue
        case stringValue
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let booleanValue = booleanValue {
            try encodeContainer.encode(booleanValue, forKey: .booleanValue)
        }
        if let doubleValue = doubleValue {
            try encodeContainer.encode(doubleValue, forKey: .doubleValue)
        }
        if let integerValue = integerValue {
            try encodeContainer.encode(integerValue, forKey: .integerValue)
        }
        if let stringValue = stringValue {
            try encodeContainer.encode(stringValue, forKey: .stringValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stringValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stringValue)
        stringValue = stringValueDecoded
        let integerValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integerValue)
        integerValue = integerValueDecoded
        let doubleValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .doubleValue)
        doubleValue = doubleValueDecoded
        let booleanValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .booleanValue)
        booleanValue = booleanValueDecoded
    }
}

extension AssetPropertyVariant: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetPropertyVariant(booleanValue: \(String(describing: booleanValue)), doubleValue: \(String(describing: doubleValue)), integerValue: \(String(describing: integerValue)), stringValue: \(String(describing: stringValue)))"}
}

/// <p>A structure that contains an asset property value. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_Variant.html">Variant</a>
///       in the <i>AWS IoT SiteWise API Reference</i>.</p>
///          <p>You must use expressions for all parameters in <code>AssetPropertyVariant</code>. The
///       expressions accept literals, operators, functions, references, and substitution
///       templates.</p>
///          <p class="title">
///             <b>Examples</b>
///          </p>
///          <ul>
///             <li>
///                <p>For literal values, the expressions must contain single quotes. For example, the value
///           for the <code>integerValue</code> parameter can be <code>'100'</code>.</p>
///             </li>
///             <li>
///                <p>For references, you must specify either variables or parameters. For example, the
///           value for the <code>booleanValue</code> parameter can be
///           <code>$variable.offline</code>.</p>
///             </li>
///             <li>
///                <p>For a substitution template, you must use <code>${}</code>, and the template must be
///           in single quotes. A substitution template can also contain a combination of literals,
///           operators, functions, references, and substitution templates. </p>
///                <p>In the following example, the value for the <code>doubleValue</code> parameter uses a
///           substitution template. </p>
///                <p>
///                   <code>'${$input.TemperatureInput.sensorData.temperature * 6 / 5 + 32}'</code>
///                </p>
///             </li>
///          </ul>
///          <p>For more information,
///         see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html">Expressions</a>
///         in the <i>AWS IoT Events Developer Guide</i>.</p>
///          <p>You must specify one of the following value types, depending on the <code>dataType</code>
///       of the specified asset property. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_AssetProperty.html">AssetProperty</a> in the
///         <i>AWS IoT SiteWise API Reference</i>.</p>
public struct AssetPropertyVariant: Equatable {
    /// <p>The asset property value is a Boolean value that must be <code>'TRUE'</code> or
    ///         <code>'FALSE'</code>. You must use an expression, and the evaluated result should be a
    ///       Boolean value.</p>
    public let booleanValue: String?
    /// <p>The asset property value is a double. You must use an expression, and the evaluated result
    ///       should be a double.</p>
    public let doubleValue: String?
    /// <p>The asset property value is an integer. You must use an expression, and the evaluated
    ///       result should be an integer.</p>
    public let integerValue: String?
    /// <p>The asset property value is a string. You must use an expression, and the evaluated result
    ///       should be a string.</p>
    public let stringValue: String?

    public init (
        booleanValue: String? = nil,
        doubleValue: String? = nil,
        integerValue: String? = nil,
        stringValue: String? = nil
    )
    {
        self.booleanValue = booleanValue
        self.doubleValue = doubleValue
        self.integerValue = integerValue
        self.stringValue = stringValue
    }
}

extension Attribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jsonPath
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jsonPath = jsonPath {
            try encodeContainer.encode(jsonPath, forKey: .jsonPath)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jsonPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jsonPath)
        jsonPath = jsonPathDecoded
    }
}

extension Attribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Attribute(jsonPath: \(String(describing: jsonPath)))"}
}

/// <p>The attributes from the JSON payload that are made available by the input. Inputs are
///       derived from messages sent to the AWS IoT Events system using <code>BatchPutMessage</code>. Each such
///       message contains a JSON payload. Those attributes (and their paired values) specified here are
///       available for use in the <code>condition</code> expressions used by detectors. </p>
public struct Attribute: Equatable {
    /// <p>An expression that specifies an attribute-value pair in a JSON structure. Use this to
    ///       specify an attribute from the JSON payload that is made available by the input. Inputs are
    ///       derived from messages sent to AWS IoT Events (<code>BatchPutMessage</code>). Each such message contains
    ///       a JSON payload. The attribute (and its paired value) specified here are available for use in
    ///       the <code>condition</code> expressions used by detectors. </p>
    ///          <p>Syntax: <code><field-name>.<field-name>...</code>
    ///          </p>
    public let jsonPath: String?

    public init (
        jsonPath: String? = nil
    )
    {
        self.jsonPath = jsonPath
    }
}

extension ClearTimerAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case timerName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timerName = timerName {
            try encodeContainer.encode(timerName, forKey: .timerName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timerName)
        timerName = timerNameDecoded
    }
}

extension ClearTimerAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClearTimerAction(timerName: \(String(describing: timerName)))"}
}

/// <p>Information needed to clear the timer.</p>
public struct ClearTimerAction: Equatable {
    /// <p>The name of the timer to clear.</p>
    public let timerName: String?

    public init (
        timerName: String? = nil
    )
    {
        self.timerName = timerName
    }
}

public enum ComparisonOperator {
    case equal
    case greater
    case greaterOrEqual
    case less
    case lessOrEqual
    case notEqual
    case sdkUnknown(String)
}

extension ComparisonOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ComparisonOperator] {
        return [
            .equal,
            .greater,
            .greaterOrEqual,
            .less,
            .lessOrEqual,
            .notEqual,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .equal: return "EQUAL"
        case .greater: return "GREATER"
        case .greaterOrEqual: return "GREATER_OR_EQUAL"
        case .less: return "LESS"
        case .lessOrEqual: return "LESS_OR_EQUAL"
        case .notEqual: return "NOT_EQUAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
    }
}

public struct CreateAlarmModelInputBodyMiddleware: Middleware {
    public let id: String = "CreateAlarmModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAlarmModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAlarmModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAlarmModelInput>
    public typealias MOutput = OperationOutput<CreateAlarmModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAlarmModelOutputError>
}

extension CreateAlarmModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAlarmModelInput(alarmCapabilities: \(String(describing: alarmCapabilities)), alarmEventActions: \(String(describing: alarmEventActions)), alarmModelDescription: \(String(describing: alarmModelDescription)), alarmModelName: \(String(describing: alarmModelName)), alarmNotification: \(String(describing: alarmNotification)), alarmRule: \(String(describing: alarmRule)), key: \(String(describing: key)), roleArn: \(String(describing: roleArn)), severity: \(String(describing: severity)), tags: \(String(describing: tags)))"}
}

extension CreateAlarmModelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alarmCapabilities
        case alarmEventActions
        case alarmModelDescription
        case alarmModelName
        case alarmNotification
        case alarmRule
        case key
        case roleArn
        case severity
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmCapabilities = alarmCapabilities {
            try encodeContainer.encode(alarmCapabilities, forKey: .alarmCapabilities)
        }
        if let alarmEventActions = alarmEventActions {
            try encodeContainer.encode(alarmEventActions, forKey: .alarmEventActions)
        }
        if let alarmModelDescription = alarmModelDescription {
            try encodeContainer.encode(alarmModelDescription, forKey: .alarmModelDescription)
        }
        if let alarmModelName = alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let alarmNotification = alarmNotification {
            try encodeContainer.encode(alarmNotification, forKey: .alarmNotification)
        }
        if let alarmRule = alarmRule {
            try encodeContainer.encode(alarmRule, forKey: .alarmRule)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateAlarmModelInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAlarmModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAlarmModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAlarmModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAlarmModelInput>
    public typealias MOutput = OperationOutput<CreateAlarmModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAlarmModelOutputError>
}

public struct CreateAlarmModelInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAlarmModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAlarmModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAlarmModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAlarmModelInput>
    public typealias MOutput = OperationOutput<CreateAlarmModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAlarmModelOutputError>
}

public struct CreateAlarmModelInput: Equatable {
    /// <p>Contains the configuration information of alarm state changes.</p>
    public let alarmCapabilities: AlarmCapabilities?
    /// <p>Contains information about one or more alarm actions.</p>
    public let alarmEventActions: AlarmEventActions?
    /// <p>A description that tells you what the alarm model detects.</p>
    public let alarmModelDescription: String?
    /// <p>A unique name that helps you identify the alarm model. You can't change this name after
    ///       you create the alarm model.</p>
    public let alarmModelName: String?
    /// <p>Contains information about one or more notification actions.</p>
    public let alarmNotification: AlarmNotification?
    /// <p>Defines when your alarm is invoked.</p>
    public let alarmRule: AlarmRule?
    /// <p>An input attribute used as a key to create an alarm.
    /// AWS IoT Events routes <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_Input.html">inputs</a>
    /// associated with this key to the alarm.</p>
    public let key: String?
    /// <p>The ARN of the IAM role that allows the alarm to perform actions and access AWS resources. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let roleArn: String?
    /// <p>A non-negative integer that reflects the severity level of the alarm.</p>
    public let severity: Int?
    /// <p>A list of key-value pairs that contain metadata for the alarm model. The tags help you
    ///       manage the alarm model. For more information, see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/tagging-iotevents.html">Tagging your AWS IoT Events
    ///         resources</a> in the <i>AWS IoT Events Developer Guide</i>.</p>
    ///          <p>You can create up to 50 tags for one alarm model.</p>
    public let tags: [Tag]?

    public init (
        alarmCapabilities: AlarmCapabilities? = nil,
        alarmEventActions: AlarmEventActions? = nil,
        alarmModelDescription: String? = nil,
        alarmModelName: String? = nil,
        alarmNotification: AlarmNotification? = nil,
        alarmRule: AlarmRule? = nil,
        key: String? = nil,
        roleArn: String? = nil,
        severity: Int? = nil,
        tags: [Tag]? = nil
    )
    {
        self.alarmCapabilities = alarmCapabilities
        self.alarmEventActions = alarmEventActions
        self.alarmModelDescription = alarmModelDescription
        self.alarmModelName = alarmModelName
        self.alarmNotification = alarmNotification
        self.alarmRule = alarmRule
        self.key = key
        self.roleArn = roleArn
        self.severity = severity
        self.tags = tags
    }
}

struct CreateAlarmModelInputBody: Equatable {
    public let alarmModelName: String?
    public let alarmModelDescription: String?
    public let roleArn: String?
    public let tags: [Tag]?
    public let key: String?
    public let severity: Int?
    public let alarmRule: AlarmRule?
    public let alarmNotification: AlarmNotification?
    public let alarmEventActions: AlarmEventActions?
    public let alarmCapabilities: AlarmCapabilities?
}

extension CreateAlarmModelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alarmCapabilities
        case alarmEventActions
        case alarmModelDescription
        case alarmModelName
        case alarmNotification
        case alarmRule
        case key
        case roleArn
        case severity
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let alarmModelDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelDescription)
        alarmModelDescription = alarmModelDescriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .severity)
        severity = severityDecoded
        let alarmRuleDecoded = try containerValues.decodeIfPresent(AlarmRule.self, forKey: .alarmRule)
        alarmRule = alarmRuleDecoded
        let alarmNotificationDecoded = try containerValues.decodeIfPresent(AlarmNotification.self, forKey: .alarmNotification)
        alarmNotification = alarmNotificationDecoded
        let alarmEventActionsDecoded = try containerValues.decodeIfPresent(AlarmEventActions.self, forKey: .alarmEventActions)
        alarmEventActions = alarmEventActionsDecoded
        let alarmCapabilitiesDecoded = try containerValues.decodeIfPresent(AlarmCapabilities.self, forKey: .alarmCapabilities)
        alarmCapabilities = alarmCapabilitiesDecoded
    }
}

extension CreateAlarmModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAlarmModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAlarmModelOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAlarmModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAlarmModelOutputResponse(alarmModelArn: \(String(describing: alarmModelArn)), alarmModelVersion: \(String(describing: alarmModelVersion)), creationTime: \(String(describing: creationTime)), lastUpdateTime: \(String(describing: lastUpdateTime)), status: \(String(describing: status)))"}
}

extension CreateAlarmModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAlarmModelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.alarmModelArn = output.alarmModelArn
            self.alarmModelVersion = output.alarmModelVersion
            self.creationTime = output.creationTime
            self.lastUpdateTime = output.lastUpdateTime
            self.status = output.status
        } else {
            self.alarmModelArn = nil
            self.alarmModelVersion = nil
            self.creationTime = nil
            self.lastUpdateTime = nil
            self.status = nil
        }
    }
}

public struct CreateAlarmModelOutputResponse: Equatable {
    /// <p>The ARN of the alarm model. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let alarmModelArn: String?
    /// <p>The version of the alarm model.</p>
    public let alarmModelVersion: String?
    /// <p>The time the alarm model was created, in the Unix epoch format.</p>
    public let creationTime: Date?
    /// <p>The time the alarm model was last updated, in the Unix epoch format.</p>
    public let lastUpdateTime: Date?
    /// <p>The status of the alarm model. The status can be one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code> - The alarm model is active and it's ready to evaluate data.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVATING</code> - AWS IoT Events is activating your alarm model.
    ///         Activating an alarm model can take up to a few minutes.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INACTIVE</code> - The alarm model is inactive, so it isn't ready to evaluate data.
    /// 	  Check your alarm model information and update the alarm model.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code> - You couldn't create or update the alarm model. Check your alarm model information
    ///         and try again.</p>
    ///             </li>
    ///          </ul>
    public let status: AlarmModelVersionStatus?

    public init (
        alarmModelArn: String? = nil,
        alarmModelVersion: String? = nil,
        creationTime: Date? = nil,
        lastUpdateTime: Date? = nil,
        status: AlarmModelVersionStatus? = nil
    )
    {
        self.alarmModelArn = alarmModelArn
        self.alarmModelVersion = alarmModelVersion
        self.creationTime = creationTime
        self.lastUpdateTime = lastUpdateTime
        self.status = status
    }
}

struct CreateAlarmModelOutputResponseBody: Equatable {
    public let creationTime: Date?
    public let alarmModelArn: String?
    public let alarmModelVersion: String?
    public let lastUpdateTime: Date?
    public let status: AlarmModelVersionStatus?
}

extension CreateAlarmModelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alarmModelArn
        case alarmModelVersion
        case creationTime
        case lastUpdateTime
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let alarmModelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelArn)
        alarmModelArn = alarmModelArnDecoded
        let alarmModelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelVersion)
        alarmModelVersion = alarmModelVersionDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AlarmModelVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateDetectorModelInputBodyMiddleware: Middleware {
    public let id: String = "CreateDetectorModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDetectorModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDetectorModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDetectorModelInput>
    public typealias MOutput = OperationOutput<CreateDetectorModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDetectorModelOutputError>
}

extension CreateDetectorModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDetectorModelInput(detectorModelDefinition: \(String(describing: detectorModelDefinition)), detectorModelDescription: \(String(describing: detectorModelDescription)), detectorModelName: \(String(describing: detectorModelName)), evaluationMethod: \(String(describing: evaluationMethod)), key: \(String(describing: key)), roleArn: \(String(describing: roleArn)), tags: \(String(describing: tags)))"}
}

extension CreateDetectorModelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detectorModelDefinition
        case detectorModelDescription
        case detectorModelName
        case evaluationMethod
        case key
        case roleArn
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorModelDefinition = detectorModelDefinition {
            try encodeContainer.encode(detectorModelDefinition, forKey: .detectorModelDefinition)
        }
        if let detectorModelDescription = detectorModelDescription {
            try encodeContainer.encode(detectorModelDescription, forKey: .detectorModelDescription)
        }
        if let detectorModelName = detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
        if let evaluationMethod = evaluationMethod {
            try encodeContainer.encode(evaluationMethod.rawValue, forKey: .evaluationMethod)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateDetectorModelInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDetectorModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDetectorModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDetectorModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDetectorModelInput>
    public typealias MOutput = OperationOutput<CreateDetectorModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDetectorModelOutputError>
}

public struct CreateDetectorModelInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDetectorModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDetectorModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDetectorModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDetectorModelInput>
    public typealias MOutput = OperationOutput<CreateDetectorModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDetectorModelOutputError>
}

public struct CreateDetectorModelInput: Equatable {
    /// <p>Information that defines how the detectors operate.</p>
    public let detectorModelDefinition: DetectorModelDefinition?
    /// <p>A brief description of the detector model.</p>
    public let detectorModelDescription: String?
    /// <p>The name of the detector model.</p>
    public let detectorModelName: String?
    /// <p>Information about the order in which events are evaluated and how actions are executed.
    ///     </p>
    public let evaluationMethod: EvaluationMethod?
    /// <p>The input attribute key used to identify a device or system to create a detector (an
    ///       instance of the detector model) and then to route each input received to the appropriate
    ///       detector (instance). This parameter uses a JSON-path expression in the message payload of each
    ///       input to specify the attribute-value pair that is used to identify the device associated with
    ///       the input.</p>
    public let key: String?
    /// <p>The ARN of the role that grants permission to AWS IoT Events to perform its operations.</p>
    public let roleArn: String?
    /// <p>Metadata that can be used to manage the detector model.</p>
    public let tags: [Tag]?

    public init (
        detectorModelDefinition: DetectorModelDefinition? = nil,
        detectorModelDescription: String? = nil,
        detectorModelName: String? = nil,
        evaluationMethod: EvaluationMethod? = nil,
        key: String? = nil,
        roleArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.detectorModelDefinition = detectorModelDefinition
        self.detectorModelDescription = detectorModelDescription
        self.detectorModelName = detectorModelName
        self.evaluationMethod = evaluationMethod
        self.key = key
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateDetectorModelInputBody: Equatable {
    public let detectorModelName: String?
    public let detectorModelDefinition: DetectorModelDefinition?
    public let detectorModelDescription: String?
    public let key: String?
    public let roleArn: String?
    public let tags: [Tag]?
    public let evaluationMethod: EvaluationMethod?
}

extension CreateDetectorModelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectorModelDefinition
        case detectorModelDescription
        case detectorModelName
        case evaluationMethod
        case key
        case roleArn
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let detectorModelDefinitionDecoded = try containerValues.decodeIfPresent(DetectorModelDefinition.self, forKey: .detectorModelDefinition)
        detectorModelDefinition = detectorModelDefinitionDecoded
        let detectorModelDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorModelDescription)
        detectorModelDescription = detectorModelDescriptionDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let evaluationMethodDecoded = try containerValues.decodeIfPresent(EvaluationMethod.self, forKey: .evaluationMethod)
        evaluationMethod = evaluationMethodDecoded
    }
}

extension CreateDetectorModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDetectorModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDetectorModelOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDetectorModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDetectorModelOutputResponse(detectorModelConfiguration: \(String(describing: detectorModelConfiguration)))"}
}

extension CreateDetectorModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDetectorModelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.detectorModelConfiguration = output.detectorModelConfiguration
        } else {
            self.detectorModelConfiguration = nil
        }
    }
}

public struct CreateDetectorModelOutputResponse: Equatable {
    /// <p>Information about how the detector model is configured.</p>
    public let detectorModelConfiguration: DetectorModelConfiguration?

    public init (
        detectorModelConfiguration: DetectorModelConfiguration? = nil
    )
    {
        self.detectorModelConfiguration = detectorModelConfiguration
    }
}

struct CreateDetectorModelOutputResponseBody: Equatable {
    public let detectorModelConfiguration: DetectorModelConfiguration?
}

extension CreateDetectorModelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectorModelConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelConfigurationDecoded = try containerValues.decodeIfPresent(DetectorModelConfiguration.self, forKey: .detectorModelConfiguration)
        detectorModelConfiguration = detectorModelConfigurationDecoded
    }
}

public struct CreateInputInputBodyMiddleware: Middleware {
    public let id: String = "CreateInputInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInputInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInputInput>
    public typealias MOutput = OperationOutput<CreateInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInputOutputError>
}

extension CreateInputInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInputInput(inputDefinition: \(String(describing: inputDefinition)), inputDescription: \(String(describing: inputDescription)), inputName: \(String(describing: inputName)), tags: \(String(describing: tags)))"}
}

extension CreateInputInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputDefinition
        case inputDescription
        case inputName
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputDefinition = inputDefinition {
            try encodeContainer.encode(inputDefinition, forKey: .inputDefinition)
        }
        if let inputDescription = inputDescription {
            try encodeContainer.encode(inputDescription, forKey: .inputDescription)
        }
        if let inputName = inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateInputInputHeadersMiddleware: Middleware {
    public let id: String = "CreateInputInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInputInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInputInput>
    public typealias MOutput = OperationOutput<CreateInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInputOutputError>
}

public struct CreateInputInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateInputInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInputInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInputInput>
    public typealias MOutput = OperationOutput<CreateInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInputOutputError>
}

public struct CreateInputInput: Equatable {
    /// <p>The definition of the input.</p>
    public let inputDefinition: InputDefinition?
    /// <p>A brief description of the input.</p>
    public let inputDescription: String?
    /// <p>The name you want to give to the input.</p>
    public let inputName: String?
    /// <p>Metadata that can be used to manage the input.</p>
    public let tags: [Tag]?

    public init (
        inputDefinition: InputDefinition? = nil,
        inputDescription: String? = nil,
        inputName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.inputDefinition = inputDefinition
        self.inputDescription = inputDescription
        self.inputName = inputName
        self.tags = tags
    }
}

struct CreateInputInputBody: Equatable {
    public let inputName: String?
    public let inputDescription: String?
    public let inputDefinition: InputDefinition?
    public let tags: [Tag]?
}

extension CreateInputInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inputDefinition
        case inputDescription
        case inputName
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputName)
        inputName = inputNameDecoded
        let inputDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputDescription)
        inputDescription = inputDescriptionDecoded
        let inputDefinitionDecoded = try containerValues.decodeIfPresent(InputDefinition.self, forKey: .inputDefinition)
        inputDefinition = inputDefinitionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateInputOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateInputOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateInputOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInputOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInputOutputResponse(inputConfiguration: \(String(describing: inputConfiguration)))"}
}

extension CreateInputOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateInputOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.inputConfiguration = output.inputConfiguration
        } else {
            self.inputConfiguration = nil
        }
    }
}

public struct CreateInputOutputResponse: Equatable {
    /// <p>Information about the configuration of the input.</p>
    public let inputConfiguration: InputConfiguration?

    public init (
        inputConfiguration: InputConfiguration? = nil
    )
    {
        self.inputConfiguration = inputConfiguration
    }
}

struct CreateInputOutputResponseBody: Equatable {
    public let inputConfiguration: InputConfiguration?
}

extension CreateInputOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inputConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputConfigurationDecoded = try containerValues.decodeIfPresent(InputConfiguration.self, forKey: .inputConfiguration)
        inputConfiguration = inputConfigurationDecoded
    }
}

extension DeleteAlarmModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAlarmModelInput(alarmModelName: \(String(describing: alarmModelName)))"}
}

extension DeleteAlarmModelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAlarmModelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAlarmModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAlarmModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAlarmModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAlarmModelInput>
    public typealias MOutput = OperationOutput<DeleteAlarmModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAlarmModelOutputError>
}

public struct DeleteAlarmModelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAlarmModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAlarmModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAlarmModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAlarmModelInput>
    public typealias MOutput = OperationOutput<DeleteAlarmModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAlarmModelOutputError>
}

public struct DeleteAlarmModelInput: Equatable {
    /// <p>The name of the alarm model.</p>
    public let alarmModelName: String?

    public init (
        alarmModelName: String? = nil
    )
    {
        self.alarmModelName = alarmModelName
    }
}

struct DeleteAlarmModelInputBody: Equatable {
}

extension DeleteAlarmModelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAlarmModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAlarmModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAlarmModelOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAlarmModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAlarmModelOutputResponse()"}
}

extension DeleteAlarmModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAlarmModelOutputResponse: Equatable {

    public init() {}
}

struct DeleteAlarmModelOutputResponseBody: Equatable {
}

extension DeleteAlarmModelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDetectorModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDetectorModelInput(detectorModelName: \(String(describing: detectorModelName)))"}
}

extension DeleteDetectorModelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDetectorModelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDetectorModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDetectorModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDetectorModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDetectorModelInput>
    public typealias MOutput = OperationOutput<DeleteDetectorModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDetectorModelOutputError>
}

public struct DeleteDetectorModelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDetectorModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDetectorModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDetectorModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDetectorModelInput>
    public typealias MOutput = OperationOutput<DeleteDetectorModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDetectorModelOutputError>
}

public struct DeleteDetectorModelInput: Equatable {
    /// <p>The name of the detector model to be deleted.</p>
    public let detectorModelName: String?

    public init (
        detectorModelName: String? = nil
    )
    {
        self.detectorModelName = detectorModelName
    }
}

struct DeleteDetectorModelInputBody: Equatable {
}

extension DeleteDetectorModelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDetectorModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDetectorModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDetectorModelOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDetectorModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDetectorModelOutputResponse()"}
}

extension DeleteDetectorModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDetectorModelOutputResponse: Equatable {

    public init() {}
}

struct DeleteDetectorModelOutputResponseBody: Equatable {
}

extension DeleteDetectorModelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteInputInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInputInput(inputName: \(String(describing: inputName)))"}
}

extension DeleteInputInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteInputInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteInputInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInputInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInputInput>
    public typealias MOutput = OperationOutput<DeleteInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInputOutputError>
}

public struct DeleteInputInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteInputInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInputInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInputInput>
    public typealias MOutput = OperationOutput<DeleteInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInputOutputError>
}

public struct DeleteInputInput: Equatable {
    /// <p>The name of the input to delete.</p>
    public let inputName: String?

    public init (
        inputName: String? = nil
    )
    {
        self.inputName = inputName
    }
}

struct DeleteInputInputBody: Equatable {
}

extension DeleteInputInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteInputOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInputOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInputOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInputOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInputOutputResponse()"}
}

extension DeleteInputOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteInputOutputResponse: Equatable {

    public init() {}
}

struct DeleteInputOutputResponseBody: Equatable {
}

extension DeleteInputOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAlarmModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAlarmModelInput(alarmModelName: \(String(describing: alarmModelName)), alarmModelVersion: \(String(describing: alarmModelVersion)))"}
}

extension DescribeAlarmModelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAlarmModelInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAlarmModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAlarmModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAlarmModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAlarmModelInput>
    public typealias MOutput = OperationOutput<DescribeAlarmModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAlarmModelOutputError>
}

public struct DescribeAlarmModelInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAlarmModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAlarmModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAlarmModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let alarmModelVersion = input.operationInput.alarmModelVersion {
            let alarmModelVersionQueryItem = URLQueryItem(name: "version".urlPercentEncoding(), value: String(alarmModelVersion).urlPercentEncoding())
            input.builder.withQueryItem(alarmModelVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAlarmModelInput>
    public typealias MOutput = OperationOutput<DescribeAlarmModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAlarmModelOutputError>
}

public struct DescribeAlarmModelInput: Equatable {
    /// <p>The name of the alarm model.</p>
    public let alarmModelName: String?
    /// <p>The version of the alarm model.</p>
    public let alarmModelVersion: String?

    public init (
        alarmModelName: String? = nil,
        alarmModelVersion: String? = nil
    )
    {
        self.alarmModelName = alarmModelName
        self.alarmModelVersion = alarmModelVersion
    }
}

struct DescribeAlarmModelInputBody: Equatable {
}

extension DescribeAlarmModelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAlarmModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAlarmModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAlarmModelOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAlarmModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAlarmModelOutputResponse(alarmCapabilities: \(String(describing: alarmCapabilities)), alarmEventActions: \(String(describing: alarmEventActions)), alarmModelArn: \(String(describing: alarmModelArn)), alarmModelDescription: \(String(describing: alarmModelDescription)), alarmModelName: \(String(describing: alarmModelName)), alarmModelVersion: \(String(describing: alarmModelVersion)), alarmNotification: \(String(describing: alarmNotification)), alarmRule: \(String(describing: alarmRule)), creationTime: \(String(describing: creationTime)), key: \(String(describing: key)), lastUpdateTime: \(String(describing: lastUpdateTime)), roleArn: \(String(describing: roleArn)), severity: \(String(describing: severity)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)))"}
}

extension DescribeAlarmModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAlarmModelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.alarmCapabilities = output.alarmCapabilities
            self.alarmEventActions = output.alarmEventActions
            self.alarmModelArn = output.alarmModelArn
            self.alarmModelDescription = output.alarmModelDescription
            self.alarmModelName = output.alarmModelName
            self.alarmModelVersion = output.alarmModelVersion
            self.alarmNotification = output.alarmNotification
            self.alarmRule = output.alarmRule
            self.creationTime = output.creationTime
            self.key = output.key
            self.lastUpdateTime = output.lastUpdateTime
            self.roleArn = output.roleArn
            self.severity = output.severity
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.alarmCapabilities = nil
            self.alarmEventActions = nil
            self.alarmModelArn = nil
            self.alarmModelDescription = nil
            self.alarmModelName = nil
            self.alarmModelVersion = nil
            self.alarmNotification = nil
            self.alarmRule = nil
            self.creationTime = nil
            self.key = nil
            self.lastUpdateTime = nil
            self.roleArn = nil
            self.severity = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct DescribeAlarmModelOutputResponse: Equatable {
    /// <p>Contains the configuration information of alarm state changes.</p>
    public let alarmCapabilities: AlarmCapabilities?
    /// <p>Contains information about one or more alarm actions.</p>
    public let alarmEventActions: AlarmEventActions?
    /// <p>The ARN of the alarm model. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let alarmModelArn: String?
    /// <p>The description of the alarm model.</p>
    public let alarmModelDescription: String?
    /// <p>The name of the alarm model.</p>
    public let alarmModelName: String?
    /// <p>The version of the alarm model.</p>
    public let alarmModelVersion: String?
    /// <p>Contains information about one or more notification actions.</p>
    public let alarmNotification: AlarmNotification?
    /// <p>Defines when your alarm is invoked.</p>
    public let alarmRule: AlarmRule?
    /// <p>The time the alarm model was created, in the Unix epoch format.</p>
    public let creationTime: Date?
    /// <p>An input attribute used as a key to create an alarm.
    /// AWS IoT Events routes <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_Input.html">inputs</a>
    /// associated with this key to the alarm.</p>
    public let key: String?
    /// <p>The time the alarm model was last updated, in the Unix epoch format.</p>
    public let lastUpdateTime: Date?
    /// <p>The ARN of the IAM role that allows the alarm to perform actions and access AWS resources. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let roleArn: String?
    /// <p>A non-negative integer that reflects the severity level of the alarm.</p>
    public let severity: Int?
    /// <p>The status of the alarm model. The status can be one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code> - The alarm model is active and it's ready to evaluate data.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVATING</code> - AWS IoT Events is activating your alarm model.
    ///         Activating an alarm model can take up to a few minutes.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INACTIVE</code> - The alarm model is inactive, so it isn't ready to evaluate data.
    /// 	  Check your alarm model information and update the alarm model.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code> - You couldn't create or update the alarm model. Check your alarm model information
    ///         and try again.</p>
    ///             </li>
    ///          </ul>
    public let status: AlarmModelVersionStatus?
    /// <p>
    ///       Contains information about the status of the alarm model.
    ///     </p>
    public let statusMessage: String?

    public init (
        alarmCapabilities: AlarmCapabilities? = nil,
        alarmEventActions: AlarmEventActions? = nil,
        alarmModelArn: String? = nil,
        alarmModelDescription: String? = nil,
        alarmModelName: String? = nil,
        alarmModelVersion: String? = nil,
        alarmNotification: AlarmNotification? = nil,
        alarmRule: AlarmRule? = nil,
        creationTime: Date? = nil,
        key: String? = nil,
        lastUpdateTime: Date? = nil,
        roleArn: String? = nil,
        severity: Int? = nil,
        status: AlarmModelVersionStatus? = nil,
        statusMessage: String? = nil
    )
    {
        self.alarmCapabilities = alarmCapabilities
        self.alarmEventActions = alarmEventActions
        self.alarmModelArn = alarmModelArn
        self.alarmModelDescription = alarmModelDescription
        self.alarmModelName = alarmModelName
        self.alarmModelVersion = alarmModelVersion
        self.alarmNotification = alarmNotification
        self.alarmRule = alarmRule
        self.creationTime = creationTime
        self.key = key
        self.lastUpdateTime = lastUpdateTime
        self.roleArn = roleArn
        self.severity = severity
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct DescribeAlarmModelOutputResponseBody: Equatable {
    public let creationTime: Date?
    public let alarmModelArn: String?
    public let alarmModelVersion: String?
    public let lastUpdateTime: Date?
    public let status: AlarmModelVersionStatus?
    public let statusMessage: String?
    public let alarmModelName: String?
    public let alarmModelDescription: String?
    public let roleArn: String?
    public let key: String?
    public let severity: Int?
    public let alarmRule: AlarmRule?
    public let alarmNotification: AlarmNotification?
    public let alarmEventActions: AlarmEventActions?
    public let alarmCapabilities: AlarmCapabilities?
}

extension DescribeAlarmModelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alarmCapabilities
        case alarmEventActions
        case alarmModelArn
        case alarmModelDescription
        case alarmModelName
        case alarmModelVersion
        case alarmNotification
        case alarmRule
        case creationTime
        case key
        case lastUpdateTime
        case roleArn
        case severity
        case status
        case statusMessage
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let alarmModelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelArn)
        alarmModelArn = alarmModelArnDecoded
        let alarmModelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelVersion)
        alarmModelVersion = alarmModelVersionDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AlarmModelVersionStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let alarmModelDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelDescription)
        alarmModelDescription = alarmModelDescriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .severity)
        severity = severityDecoded
        let alarmRuleDecoded = try containerValues.decodeIfPresent(AlarmRule.self, forKey: .alarmRule)
        alarmRule = alarmRuleDecoded
        let alarmNotificationDecoded = try containerValues.decodeIfPresent(AlarmNotification.self, forKey: .alarmNotification)
        alarmNotification = alarmNotificationDecoded
        let alarmEventActionsDecoded = try containerValues.decodeIfPresent(AlarmEventActions.self, forKey: .alarmEventActions)
        alarmEventActions = alarmEventActionsDecoded
        let alarmCapabilitiesDecoded = try containerValues.decodeIfPresent(AlarmCapabilities.self, forKey: .alarmCapabilities)
        alarmCapabilities = alarmCapabilitiesDecoded
    }
}

extension DescribeDetectorModelAnalysisInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDetectorModelAnalysisInput(analysisId: \(String(describing: analysisId)))"}
}

extension DescribeDetectorModelAnalysisInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDetectorModelAnalysisInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDetectorModelAnalysisInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDetectorModelAnalysisInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDetectorModelAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDetectorModelAnalysisInput>
    public typealias MOutput = OperationOutput<DescribeDetectorModelAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDetectorModelAnalysisOutputError>
}

public struct DescribeDetectorModelAnalysisInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDetectorModelAnalysisInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDetectorModelAnalysisInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDetectorModelAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDetectorModelAnalysisInput>
    public typealias MOutput = OperationOutput<DescribeDetectorModelAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDetectorModelAnalysisOutputError>
}

public struct DescribeDetectorModelAnalysisInput: Equatable {
    /// <p>The ID of the analysis result that you want to retrieve.</p>
    public let analysisId: String?

    public init (
        analysisId: String? = nil
    )
    {
        self.analysisId = analysisId
    }
}

struct DescribeDetectorModelAnalysisInputBody: Equatable {
}

extension DescribeDetectorModelAnalysisInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDetectorModelAnalysisOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDetectorModelAnalysisOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDetectorModelAnalysisOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDetectorModelAnalysisOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDetectorModelAnalysisOutputResponse(status: \(String(describing: status)))"}
}

extension DescribeDetectorModelAnalysisOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDetectorModelAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct DescribeDetectorModelAnalysisOutputResponse: Equatable {
    /// <p>The status of the analysis activity. The status can be one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>RUNNING</code> - AWS IoT Events is analyzing your detector model. This process can take
    ///           several minutes to complete.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>COMPLETE</code> - AWS IoT Events finished analyzing your detector model.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code> - AWS IoT Events couldn't analyze your detector model. Try again
    ///           later.</p>
    ///             </li>
    ///          </ul>
    public let status: AnalysisStatus?

    public init (
        status: AnalysisStatus? = nil
    )
    {
        self.status = status
    }
}

struct DescribeDetectorModelAnalysisOutputResponseBody: Equatable {
    public let status: AnalysisStatus?
}

extension DescribeDetectorModelAnalysisOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AnalysisStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeDetectorModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDetectorModelInput(detectorModelName: \(String(describing: detectorModelName)), detectorModelVersion: \(String(describing: detectorModelVersion)))"}
}

extension DescribeDetectorModelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDetectorModelInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDetectorModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDetectorModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDetectorModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDetectorModelInput>
    public typealias MOutput = OperationOutput<DescribeDetectorModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDetectorModelOutputError>
}

public struct DescribeDetectorModelInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDetectorModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDetectorModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDetectorModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let detectorModelVersion = input.operationInput.detectorModelVersion {
            let detectorModelVersionQueryItem = URLQueryItem(name: "version".urlPercentEncoding(), value: String(detectorModelVersion).urlPercentEncoding())
            input.builder.withQueryItem(detectorModelVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDetectorModelInput>
    public typealias MOutput = OperationOutput<DescribeDetectorModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDetectorModelOutputError>
}

public struct DescribeDetectorModelInput: Equatable {
    /// <p>The name of the detector model.</p>
    public let detectorModelName: String?
    /// <p>The version of the detector model.</p>
    public let detectorModelVersion: String?

    public init (
        detectorModelName: String? = nil,
        detectorModelVersion: String? = nil
    )
    {
        self.detectorModelName = detectorModelName
        self.detectorModelVersion = detectorModelVersion
    }
}

struct DescribeDetectorModelInputBody: Equatable {
}

extension DescribeDetectorModelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDetectorModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDetectorModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDetectorModelOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDetectorModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDetectorModelOutputResponse(detectorModel: \(String(describing: detectorModel)))"}
}

extension DescribeDetectorModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDetectorModelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.detectorModel = output.detectorModel
        } else {
            self.detectorModel = nil
        }
    }
}

public struct DescribeDetectorModelOutputResponse: Equatable {
    /// <p>Information about the detector model.</p>
    public let detectorModel: DetectorModel?

    public init (
        detectorModel: DetectorModel? = nil
    )
    {
        self.detectorModel = detectorModel
    }
}

struct DescribeDetectorModelOutputResponseBody: Equatable {
    public let detectorModel: DetectorModel?
}

extension DescribeDetectorModelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectorModel
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelDecoded = try containerValues.decodeIfPresent(DetectorModel.self, forKey: .detectorModel)
        detectorModel = detectorModelDecoded
    }
}

extension DescribeInputInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInputInput(inputName: \(String(describing: inputName)))"}
}

extension DescribeInputInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeInputInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeInputInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInputInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInputInput>
    public typealias MOutput = OperationOutput<DescribeInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInputOutputError>
}

public struct DescribeInputInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeInputInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInputInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInputInput>
    public typealias MOutput = OperationOutput<DescribeInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInputOutputError>
}

public struct DescribeInputInput: Equatable {
    /// <p>The name of the input.</p>
    public let inputName: String?

    public init (
        inputName: String? = nil
    )
    {
        self.inputName = inputName
    }
}

struct DescribeInputInputBody: Equatable {
}

extension DescribeInputInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeInputOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInputOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInputOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInputOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInputOutputResponse(input: \(String(describing: input)))"}
}

extension DescribeInputOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeInputOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.input = output.input
        } else {
            self.input = nil
        }
    }
}

public struct DescribeInputOutputResponse: Equatable {
    /// <p>Information about the input.</p>
    public let input: Input?

    public init (
        input: Input? = nil
    )
    {
        self.input = input
    }
}

struct DescribeInputOutputResponseBody: Equatable {
    public let input: Input?
}

extension DescribeInputOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case input
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDecoded = try containerValues.decodeIfPresent(Input.self, forKey: .input)
        input = inputDecoded
    }
}

extension DescribeLoggingOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoggingOptionsInput()"}
}

extension DescribeLoggingOptionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeLoggingOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLoggingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoggingOptionsInput>
    public typealias MOutput = OperationOutput<DescribeLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoggingOptionsOutputError>
}

public struct DescribeLoggingOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLoggingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoggingOptionsInput>
    public typealias MOutput = OperationOutput<DescribeLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoggingOptionsOutputError>
}

public struct DescribeLoggingOptionsInput: Equatable {

    public init() {}
}

struct DescribeLoggingOptionsInputBody: Equatable {
}

extension DescribeLoggingOptionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeLoggingOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLoggingOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLoggingOptionsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoggingOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoggingOptionsOutputResponse(loggingOptions: \(String(describing: loggingOptions)))"}
}

extension DescribeLoggingOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeLoggingOptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.loggingOptions = output.loggingOptions
        } else {
            self.loggingOptions = nil
        }
    }
}

public struct DescribeLoggingOptionsOutputResponse: Equatable {
    /// <p>The current settings of the AWS IoT Events logging options.</p>
    public let loggingOptions: LoggingOptions?

    public init (
        loggingOptions: LoggingOptions? = nil
    )
    {
        self.loggingOptions = loggingOptions
    }
}

struct DescribeLoggingOptionsOutputResponseBody: Equatable {
    public let loggingOptions: LoggingOptions?
}

extension DescribeLoggingOptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loggingOptions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingOptionsDecoded = try containerValues.decodeIfPresent(LoggingOptions.self, forKey: .loggingOptions)
        loggingOptions = loggingOptionsDecoded
    }
}

extension DetectorDebugOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detectorModelName
        case keyValue
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorModelName = detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
        if let keyValue = keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
    }
}

extension DetectorDebugOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectorDebugOption(detectorModelName: \(String(describing: detectorModelName)), keyValue: \(String(describing: keyValue)))"}
}

/// <p>The detector model and the specific detectors (instances) for which the logging level is
///       given.</p>
public struct DetectorDebugOption: Equatable {
    /// <p>The name of the detector model.</p>
    public let detectorModelName: String?
    /// <p>The value of the input attribute key used to create the detector (the instance of the
    ///       detector model).</p>
    public let keyValue: String?

    public init (
        detectorModelName: String? = nil,
        keyValue: String? = nil
    )
    {
        self.detectorModelName = detectorModelName
        self.keyValue = keyValue
    }
}

extension DetectorModel: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detectorModelConfiguration
        case detectorModelDefinition
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorModelConfiguration = detectorModelConfiguration {
            try encodeContainer.encode(detectorModelConfiguration, forKey: .detectorModelConfiguration)
        }
        if let detectorModelDefinition = detectorModelDefinition {
            try encodeContainer.encode(detectorModelDefinition, forKey: .detectorModelDefinition)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelDefinitionDecoded = try containerValues.decodeIfPresent(DetectorModelDefinition.self, forKey: .detectorModelDefinition)
        detectorModelDefinition = detectorModelDefinitionDecoded
        let detectorModelConfigurationDecoded = try containerValues.decodeIfPresent(DetectorModelConfiguration.self, forKey: .detectorModelConfiguration)
        detectorModelConfiguration = detectorModelConfigurationDecoded
    }
}

extension DetectorModel: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectorModel(detectorModelConfiguration: \(String(describing: detectorModelConfiguration)), detectorModelDefinition: \(String(describing: detectorModelDefinition)))"}
}

/// <p>Information about the detector model.</p>
public struct DetectorModel: Equatable {
    /// <p>Information about how the detector is configured.</p>
    public let detectorModelConfiguration: DetectorModelConfiguration?
    /// <p>Information that defines how a detector operates.</p>
    public let detectorModelDefinition: DetectorModelDefinition?

    public init (
        detectorModelConfiguration: DetectorModelConfiguration? = nil,
        detectorModelDefinition: DetectorModelDefinition? = nil
    )
    {
        self.detectorModelConfiguration = detectorModelConfiguration
        self.detectorModelDefinition = detectorModelDefinition
    }
}

extension DetectorModelConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime
        case detectorModelArn
        case detectorModelDescription
        case detectorModelName
        case detectorModelVersion
        case evaluationMethod
        case key
        case lastUpdateTime
        case roleArn
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let detectorModelArn = detectorModelArn {
            try encodeContainer.encode(detectorModelArn, forKey: .detectorModelArn)
        }
        if let detectorModelDescription = detectorModelDescription {
            try encodeContainer.encode(detectorModelDescription, forKey: .detectorModelDescription)
        }
        if let detectorModelName = detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
        if let detectorModelVersion = detectorModelVersion {
            try encodeContainer.encode(detectorModelVersion, forKey: .detectorModelVersion)
        }
        if let evaluationMethod = evaluationMethod {
            try encodeContainer.encode(evaluationMethod.rawValue, forKey: .evaluationMethod)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let detectorModelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorModelVersion)
        detectorModelVersion = detectorModelVersionDecoded
        let detectorModelDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorModelDescription)
        detectorModelDescription = detectorModelDescriptionDecoded
        let detectorModelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorModelArn)
        detectorModelArn = detectorModelArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DetectorModelVersionStatus.self, forKey: .status)
        status = statusDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let evaluationMethodDecoded = try containerValues.decodeIfPresent(EvaluationMethod.self, forKey: .evaluationMethod)
        evaluationMethod = evaluationMethodDecoded
    }
}

extension DetectorModelConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectorModelConfiguration(creationTime: \(String(describing: creationTime)), detectorModelArn: \(String(describing: detectorModelArn)), detectorModelDescription: \(String(describing: detectorModelDescription)), detectorModelName: \(String(describing: detectorModelName)), detectorModelVersion: \(String(describing: detectorModelVersion)), evaluationMethod: \(String(describing: evaluationMethod)), key: \(String(describing: key)), lastUpdateTime: \(String(describing: lastUpdateTime)), roleArn: \(String(describing: roleArn)), status: \(String(describing: status)))"}
}

/// <p>Information about how the detector model is configured.</p>
public struct DetectorModelConfiguration: Equatable {
    /// <p>The time the detector model was created.</p>
    public let creationTime: Date?
    /// <p>The ARN of the detector model.</p>
    public let detectorModelArn: String?
    /// <p>A brief description of the detector model.</p>
    public let detectorModelDescription: String?
    /// <p>The name of the detector model.</p>
    public let detectorModelName: String?
    /// <p>The version of the detector model.</p>
    public let detectorModelVersion: String?
    /// <p>Information about the order in which events are evaluated and how actions are executed.
    ///     </p>
    public let evaluationMethod: EvaluationMethod?
    /// <p>The value used to identify a detector instance. When a device or system sends input, a new
    ///       detector instance with a unique key value is created. AWS IoT Events can continue to route input to its
    ///       corresponding detector instance based on this identifying information. </p>
    ///          <p>This parameter uses a JSON-path expression to select the attribute-value pair in the
    ///       message payload that is used for identification. To route the message to the correct detector
    ///       instance, the device must send a message payload that contains the same
    ///       attribute-value.</p>
    public let key: String?
    /// <p>The time the detector model was last updated.</p>
    public let lastUpdateTime: Date?
    /// <p>The ARN of the role that grants permission to AWS IoT Events to perform its operations.</p>
    public let roleArn: String?
    /// <p>The status of the detector model.</p>
    public let status: DetectorModelVersionStatus?

    public init (
        creationTime: Date? = nil,
        detectorModelArn: String? = nil,
        detectorModelDescription: String? = nil,
        detectorModelName: String? = nil,
        detectorModelVersion: String? = nil,
        evaluationMethod: EvaluationMethod? = nil,
        key: String? = nil,
        lastUpdateTime: Date? = nil,
        roleArn: String? = nil,
        status: DetectorModelVersionStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.detectorModelArn = detectorModelArn
        self.detectorModelDescription = detectorModelDescription
        self.detectorModelName = detectorModelName
        self.detectorModelVersion = detectorModelVersion
        self.evaluationMethod = evaluationMethod
        self.key = key
        self.lastUpdateTime = lastUpdateTime
        self.roleArn = roleArn
        self.status = status
    }
}

extension DetectorModelDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case initialStateName
        case states
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialStateName = initialStateName {
            try encodeContainer.encode(initialStateName, forKey: .initialStateName)
        }
        if let states = states {
            var statesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .states)
            for states0 in states {
                try statesContainer.encode(states0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statesContainer = try containerValues.decodeIfPresent([State?].self, forKey: .states)
        var statesDecoded0:[State]? = nil
        if let statesContainer = statesContainer {
            statesDecoded0 = [State]()
            for structure0 in statesContainer {
                if let structure0 = structure0 {
                    statesDecoded0?.append(structure0)
                }
            }
        }
        states = statesDecoded0
        let initialStateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .initialStateName)
        initialStateName = initialStateNameDecoded
    }
}

extension DetectorModelDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectorModelDefinition(initialStateName: \(String(describing: initialStateName)), states: \(String(describing: states)))"}
}

/// <p>Information that defines how a detector operates.</p>
public struct DetectorModelDefinition: Equatable {
    /// <p>The state that is entered at the creation of each detector (instance).</p>
    public let initialStateName: String?
    /// <p>Information about the states of the detector.</p>
    public let states: [State]?

    public init (
        initialStateName: String? = nil,
        states: [State]? = nil
    )
    {
        self.initialStateName = initialStateName
        self.states = states
    }
}

extension DetectorModelSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime
        case detectorModelDescription
        case detectorModelName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let detectorModelDescription = detectorModelDescription {
            try encodeContainer.encode(detectorModelDescription, forKey: .detectorModelDescription)
        }
        if let detectorModelName = detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let detectorModelDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorModelDescription)
        detectorModelDescription = detectorModelDescriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension DetectorModelSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectorModelSummary(creationTime: \(String(describing: creationTime)), detectorModelDescription: \(String(describing: detectorModelDescription)), detectorModelName: \(String(describing: detectorModelName)))"}
}

/// <p>Information about the detector model.</p>
public struct DetectorModelSummary: Equatable {
    /// <p>The time the detector model was created.</p>
    public let creationTime: Date?
    /// <p>A brief description of the detector model.</p>
    public let detectorModelDescription: String?
    /// <p>The name of the detector model.</p>
    public let detectorModelName: String?

    public init (
        creationTime: Date? = nil,
        detectorModelDescription: String? = nil,
        detectorModelName: String? = nil
    )
    {
        self.creationTime = creationTime
        self.detectorModelDescription = detectorModelDescription
        self.detectorModelName = detectorModelName
    }
}

public enum DetectorModelVersionStatus {
    case activating
    case active
    case deprecated
    case draft
    case failed
    case inactive
    case paused
    case sdkUnknown(String)
}

extension DetectorModelVersionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DetectorModelVersionStatus] {
        return [
            .activating,
            .active,
            .deprecated,
            .draft,
            .failed,
            .inactive,
            .paused,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .activating: return "ACTIVATING"
        case .active: return "ACTIVE"
        case .deprecated: return "DEPRECATED"
        case .draft: return "DRAFT"
        case .failed: return "FAILED"
        case .inactive: return "INACTIVE"
        case .paused: return "PAUSED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DetectorModelVersionStatus(rawValue: rawValue) ?? DetectorModelVersionStatus.sdkUnknown(rawValue)
    }
}

extension DetectorModelVersionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime
        case detectorModelArn
        case detectorModelName
        case detectorModelVersion
        case evaluationMethod
        case lastUpdateTime
        case roleArn
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let detectorModelArn = detectorModelArn {
            try encodeContainer.encode(detectorModelArn, forKey: .detectorModelArn)
        }
        if let detectorModelName = detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
        if let detectorModelVersion = detectorModelVersion {
            try encodeContainer.encode(detectorModelVersion, forKey: .detectorModelVersion)
        }
        if let evaluationMethod = evaluationMethod {
            try encodeContainer.encode(evaluationMethod.rawValue, forKey: .evaluationMethod)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let detectorModelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorModelVersion)
        detectorModelVersion = detectorModelVersionDecoded
        let detectorModelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorModelArn)
        detectorModelArn = detectorModelArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DetectorModelVersionStatus.self, forKey: .status)
        status = statusDecoded
        let evaluationMethodDecoded = try containerValues.decodeIfPresent(EvaluationMethod.self, forKey: .evaluationMethod)
        evaluationMethod = evaluationMethodDecoded
    }
}

extension DetectorModelVersionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectorModelVersionSummary(creationTime: \(String(describing: creationTime)), detectorModelArn: \(String(describing: detectorModelArn)), detectorModelName: \(String(describing: detectorModelName)), detectorModelVersion: \(String(describing: detectorModelVersion)), evaluationMethod: \(String(describing: evaluationMethod)), lastUpdateTime: \(String(describing: lastUpdateTime)), roleArn: \(String(describing: roleArn)), status: \(String(describing: status)))"}
}

/// <p>Information about the detector model version.</p>
public struct DetectorModelVersionSummary: Equatable {
    /// <p>The time the detector model version was created.</p>
    public let creationTime: Date?
    /// <p>The ARN of the detector model version.</p>
    public let detectorModelArn: String?
    /// <p>The name of the detector model.</p>
    public let detectorModelName: String?
    /// <p>The ID of the detector model version.</p>
    public let detectorModelVersion: String?
    /// <p>Information about the order in which events are evaluated and how actions are executed.
    ///     </p>
    public let evaluationMethod: EvaluationMethod?
    /// <p>The last time the detector model version was updated.</p>
    public let lastUpdateTime: Date?
    /// <p>The ARN of the role that grants the detector model permission to perform its tasks.</p>
    public let roleArn: String?
    /// <p>The status of the detector model version.</p>
    public let status: DetectorModelVersionStatus?

    public init (
        creationTime: Date? = nil,
        detectorModelArn: String? = nil,
        detectorModelName: String? = nil,
        detectorModelVersion: String? = nil,
        evaluationMethod: EvaluationMethod? = nil,
        lastUpdateTime: Date? = nil,
        roleArn: String? = nil,
        status: DetectorModelVersionStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.detectorModelArn = detectorModelArn
        self.detectorModelName = detectorModelName
        self.detectorModelVersion = detectorModelVersion
        self.evaluationMethod = evaluationMethod
        self.lastUpdateTime = lastUpdateTime
        self.roleArn = roleArn
        self.status = status
    }
}

extension DynamoDBAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hashKeyField
        case hashKeyType
        case hashKeyValue
        case operation
        case payload
        case payloadField
        case rangeKeyField
        case rangeKeyType
        case rangeKeyValue
        case tableName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hashKeyField = hashKeyField {
            try encodeContainer.encode(hashKeyField, forKey: .hashKeyField)
        }
        if let hashKeyType = hashKeyType {
            try encodeContainer.encode(hashKeyType, forKey: .hashKeyType)
        }
        if let hashKeyValue = hashKeyValue {
            try encodeContainer.encode(hashKeyValue, forKey: .hashKeyValue)
        }
        if let operation = operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let payload = payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if let payloadField = payloadField {
            try encodeContainer.encode(payloadField, forKey: .payloadField)
        }
        if let rangeKeyField = rangeKeyField {
            try encodeContainer.encode(rangeKeyField, forKey: .rangeKeyField)
        }
        if let rangeKeyType = rangeKeyType {
            try encodeContainer.encode(rangeKeyType, forKey: .rangeKeyType)
        }
        if let rangeKeyValue = rangeKeyValue {
            try encodeContainer.encode(rangeKeyValue, forKey: .rangeKeyValue)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hashKeyTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hashKeyType)
        hashKeyType = hashKeyTypeDecoded
        let hashKeyFieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hashKeyField)
        hashKeyField = hashKeyFieldDecoded
        let hashKeyValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hashKeyValue)
        hashKeyValue = hashKeyValueDecoded
        let rangeKeyTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rangeKeyType)
        rangeKeyType = rangeKeyTypeDecoded
        let rangeKeyFieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rangeKeyField)
        rangeKeyField = rangeKeyFieldDecoded
        let rangeKeyValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rangeKeyValue)
        rangeKeyValue = rangeKeyValueDecoded
        let operationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operation)
        operation = operationDecoded
        let payloadFieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .payloadField)
        payloadField = payloadFieldDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension DynamoDBAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DynamoDBAction(hashKeyField: \(String(describing: hashKeyField)), hashKeyType: \(String(describing: hashKeyType)), hashKeyValue: \(String(describing: hashKeyValue)), operation: \(String(describing: operation)), payload: \(String(describing: payload)), payloadField: \(String(describing: payloadField)), rangeKeyField: \(String(describing: rangeKeyField)), rangeKeyType: \(String(describing: rangeKeyType)), rangeKeyValue: \(String(describing: rangeKeyValue)), tableName: \(String(describing: tableName)))"}
}

/// <p>Defines an action to write to the Amazon DynamoDB table that you created. The standard action
///       payload contains all the information about the detector model instance and the event that
///       triggered the action. You can customize the <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html">payload</a>. One column of the
///       DynamoDB table receives all attribute-value pairs in the payload that you specify.</p>
///          <p>You must use expressions for all parameters in <code>DynamoDBAction</code>. The expressions
///       accept literals, operators, functions, references, and substitution templates.</p>
///          <p class="title">
///             <b>Examples</b>
///          </p>
///          <ul>
///             <li>
///                <p>For literal values, the expressions must contain single quotes. For example, the value
///           for the <code>hashKeyType</code> parameter can be <code>'STRING'</code>.</p>
///             </li>
///             <li>
///                <p>For references, you must specify either variables or input values. For example, the
///           value for the <code>hashKeyField</code> parameter can be
///             <code>$input.GreenhouseInput.name</code>.</p>
///             </li>
///             <li>
///                <p>For a substitution template, you must use <code>${}</code>, and the template must be
///           in single quotes. A substitution template can also contain a combination of literals,
///           operators, functions, references, and substitution templates.</p>
///                <p>In the following example, the value for the <code>hashKeyValue</code> parameter uses a
///           substitution template. </p>
///                <p>
///                   <code>'${$input.GreenhouseInput.temperature * 6 / 5 + 32} in Fahrenheit'</code>
///                </p>
///             </li>
///             <li>
///                <p>For a string concatenation, you must use <code>+</code>. A string concatenation can
///           also contain a combination of literals, operators, functions, references, and substitution
///           templates.</p>
///                <p>In the following example, the value for the <code>tableName</code> parameter uses a
///           string concatenation. </p>
///                <p>
///                   <code>'GreenhouseTemperatureTable ' + $input.GreenhouseInput.date</code>
///                </p>
///             </li>
///          </ul>
///          <p>For more information,
///         see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html">Expressions</a>
///         in the <i>AWS IoT Events Developer Guide</i>.</p>
///          <p>If the defined payload type is a string, <code>DynamoDBAction</code> writes non-JSON data to
///       the DynamoDB table as binary data. The DynamoDB console displays the data as Base64-encoded text.
///       The value for the <code>payloadField</code> parameter is
///         <code><payload-field>_raw</code>.</p>
public struct DynamoDBAction: Equatable {
    /// <p>The name of the hash key (also called the partition key). The <code>hashKeyField</code>
    ///       value must match the partition key of the target DynamoDB table.</p>
    public let hashKeyField: String?
    /// <p>The data type for the hash key (also called the partition key). You can specify the
    ///       following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>'STRING'</code> - The hash key is a string.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>'NUMBER'</code> - The hash key is a number.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you don't specify <code>hashKeyType</code>, the default value is
    ///       <code>'STRING'</code>.</p>
    public let hashKeyType: String?
    /// <p>The value of the hash key (also called the partition key).</p>
    public let hashKeyValue: String?
    /// <p>The type of operation to perform. You can specify the following values: </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>'INSERT'</code> - Insert data as a new item into the DynamoDB table. This item uses
    ///           the specified hash key as a partition key. If you specified a range key, the item uses the
    ///           range key as a sort key.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>'UPDATE'</code> - Update an existing item of the DynamoDB table with new data. This
    ///           item's partition key must match the specified hash key. If you specified a range key, the
    ///           range key must match the item's sort key.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>'DELETE'</code> - Delete an existing item of the DynamoDB table. This item's
    ///           partition key must match the specified hash key. If you specified a range key, the range
    ///           key must match the item's sort key.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you don't specify this parameter, AWS IoT Events triggers the <code>'INSERT'</code>
    ///       operation.</p>
    public let operation: String?
    /// <p>Information needed to configure the payload.</p>
    ///          <p>By default, AWS IoT Events generates a standard payload in JSON for any action. This action payload
    ///       contains all attribute-value pairs that have the information about the detector model instance
    ///       and the event triggered the action. To configure the action payload, you can use
    ///         <code>contentExpression</code>.</p>
    public let payload: Payload?
    /// <p>The name of the DynamoDB column that receives the action payload.</p>
    ///          <p>If you don't specify this parameter, the name of the DynamoDB column is
    ///       <code>payload</code>.</p>
    public let payloadField: String?
    /// <p>The name of the range key (also called the sort key). The <code>rangeKeyField</code> value
    ///       must match the sort key of the target DynamoDB table. </p>
    public let rangeKeyField: String?
    /// <p>The data type for the range key (also called the sort key), You can specify the following
    ///       values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>'STRING'</code> - The range key is a string.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>'NUMBER'</code> - The range key is number.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you don't specify <code>rangeKeyField</code>, the default value is
    ///         <code>'STRING'</code>.</p>
    public let rangeKeyType: String?
    /// <p>The value of the range key (also called the sort key).</p>
    public let rangeKeyValue: String?
    /// <p>The name of the DynamoDB table. The <code>tableName</code> value must match the table name of
    ///       the target DynamoDB table. </p>
    public let tableName: String?

    public init (
        hashKeyField: String? = nil,
        hashKeyType: String? = nil,
        hashKeyValue: String? = nil,
        operation: String? = nil,
        payload: Payload? = nil,
        payloadField: String? = nil,
        rangeKeyField: String? = nil,
        rangeKeyType: String? = nil,
        rangeKeyValue: String? = nil,
        tableName: String? = nil
    )
    {
        self.hashKeyField = hashKeyField
        self.hashKeyType = hashKeyType
        self.hashKeyValue = hashKeyValue
        self.operation = operation
        self.payload = payload
        self.payloadField = payloadField
        self.rangeKeyField = rangeKeyField
        self.rangeKeyType = rangeKeyType
        self.rangeKeyValue = rangeKeyValue
        self.tableName = tableName
    }
}

extension DynamoDBv2Action: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case payload
        case tableName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payload = payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension DynamoDBv2Action: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DynamoDBv2Action(payload: \(String(describing: payload)), tableName: \(String(describing: tableName)))"}
}

/// <p>Defines an action to write to the Amazon DynamoDB table that you created. The default action
///       payload contains all the information about the detector model instance and the event that
///       triggered the action. You can customize the <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html">payload</a>. A separate column of
///       the DynamoDB table receives one attribute-value pair in the payload that you specify.</p>
///          <p>You must use expressions for all parameters in <code>DynamoDBv2Action</code>. The expressions
///       accept literals, operators, functions, references, and substitution templates.</p>
///          <p class="title">
///             <b>Examples</b>
///          </p>
///          <ul>
///             <li>
///                <p>For literal values, the expressions must contain single quotes. For example, the value
///           for the <code>tableName</code> parameter can be
///           <code>'GreenhouseTemperatureTable'</code>.</p>
///             </li>
///             <li>
///                <p>For references, you must specify either variables or input values. For example, the
///           value for the <code>tableName</code> parameter can be
///           <code>$variable.ddbtableName</code>.</p>
///             </li>
///             <li>
///                <p>For a substitution template, you must use <code>${}</code>, and the template must be
///           in single quotes. A substitution template can also contain a combination of literals,
///           operators, functions, references, and substitution templates.</p>
///                <p>In the following example, the value for the <code>contentExpression</code> parameter
///           in <code>Payload</code> uses a substitution template. </p>
///                <p>
///                   <code>'{\"sensorID\": \"${$input.GreenhouseInput.sensor_id}\", \"temperature\":
///             \"${$input.GreenhouseInput.temperature * 9 / 5 + 32}\"}'</code>
///                </p>
///             </li>
///             <li>
///                <p>For a string concatenation, you must use <code>+</code>. A string concatenation can
///           also contain a combination of literals, operators, functions, references, and substitution
///           templates.</p>
///                <p>In the following example, the value for the <code>tableName</code> parameter uses a
///           string concatenation. </p>
///                <p>
///                   <code>'GreenhouseTemperatureTable ' + $input.GreenhouseInput.date</code>
///                </p>
///             </li>
///          </ul>
///          <p>For more information,
///         see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html">Expressions</a>
///         in the <i>AWS IoT Events Developer Guide</i>.</p>
///          <p>The value for the <code>type</code> parameter in <code>Payload</code> must be
///         <code>JSON</code>.</p>
public struct DynamoDBv2Action: Equatable {
    /// <p>Information needed to configure the payload.</p>
    ///          <p>By default, AWS IoT Events generates a standard payload in JSON for any action. This action payload
    ///       contains all attribute-value pairs that have the information about the detector model instance
    ///       and the event triggered the action. To configure the action payload, you can use
    ///         <code>contentExpression</code>.</p>
    public let payload: Payload?
    /// <p>The name of the DynamoDB table.</p>
    public let tableName: String?

    public init (
        payload: Payload? = nil,
        tableName: String? = nil
    )
    {
        self.payload = payload
        self.tableName = tableName
    }
}

extension EmailConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case content
        case from
        case recipients
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let from = from {
            try encodeContainer.encode(from, forKey: .from)
        }
        if let recipients = recipients {
            try encodeContainer.encode(recipients, forKey: .recipients)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDecoded = try containerValues.decodeIfPresent(String.self, forKey: .from)
        from = fromDecoded
        let contentDecoded = try containerValues.decodeIfPresent(EmailContent.self, forKey: .content)
        content = contentDecoded
        let recipientsDecoded = try containerValues.decodeIfPresent(EmailRecipients.self, forKey: .recipients)
        recipients = recipientsDecoded
    }
}

extension EmailConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EmailConfiguration(content: \(String(describing: content)), from: \(String(describing: from)), recipients: \(String(describing: recipients)))"}
}

/// <p>Contains the configuration information of email notifications.</p>
public struct EmailConfiguration: Equatable {
    /// <p>Contains the subject and message of an email.</p>
    public let content: EmailContent?
    /// <p>The email address that sends emails.</p>
    ///          <important>
    ///             <p>If you use the AWS IoT Events managed AWS Lambda function to manage your emails, you must <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html">verify
    ///           the email address that sends emails in Amazon SES</a>.</p>
    ///          </important>
    public let from: String?
    /// <p>Contains the information of one or more recipients who receive the emails.</p>
    ///          <important>
    ///             <p>You must <a href="https://docs.aws.amazon.com/singlesignon/latest/userguide/addusers.html">add the users that receive emails to your AWS SSO store</a>.</p>
    ///          </important>
    public let recipients: EmailRecipients?

    public init (
        content: EmailContent? = nil,
        from: String? = nil,
        recipients: EmailRecipients? = nil
    )
    {
        self.content = content
        self.from = from
        self.recipients = recipients
    }
}

extension EmailContent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalMessage
        case subject
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalMessage = additionalMessage {
            try encodeContainer.encode(additionalMessage, forKey: .additionalMessage)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subject)
        subject = subjectDecoded
        let additionalMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .additionalMessage)
        additionalMessage = additionalMessageDecoded
    }
}

extension EmailContent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EmailContent(additionalMessage: \(String(describing: additionalMessage)), subject: \(String(describing: subject)))"}
}

/// <p>Contains the subject and message of an email.</p>
public struct EmailContent: Equatable {
    /// <p>The message that you want to send. The message can be up to 200 characters.</p>
    public let additionalMessage: String?
    /// <p>The subject of the email.</p>
    public let subject: String?

    public init (
        additionalMessage: String? = nil,
        subject: String? = nil
    )
    {
        self.additionalMessage = additionalMessage
        self.subject = subject
    }
}

extension EmailRecipients: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case to
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let to = to {
            var toContainer = encodeContainer.nestedUnkeyedContainer(forKey: .to)
            for recipientdetails0 in to {
                try toContainer.encode(recipientdetails0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let toContainer = try containerValues.decodeIfPresent([RecipientDetail?].self, forKey: .to)
        var toDecoded0:[RecipientDetail]? = nil
        if let toContainer = toContainer {
            toDecoded0 = [RecipientDetail]()
            for structure0 in toContainer {
                if let structure0 = structure0 {
                    toDecoded0?.append(structure0)
                }
            }
        }
        to = toDecoded0
    }
}

extension EmailRecipients: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EmailRecipients(to: \(String(describing: to)))"}
}

/// <p>Contains the information of one or more recipients who receive the emails.</p>
///          <important>
///             <p>You must <a href="https://docs.aws.amazon.com/singlesignon/latest/userguide/addusers.html">add the users that receive emails to your AWS SSO store</a>.</p>
///          </important>
public struct EmailRecipients: Equatable {
    /// <p>Specifies one or more recipients who receive the email.</p>
    public let to: [RecipientDetail]?

    public init (
        to: [RecipientDetail]? = nil
    )
    {
        self.to = to
    }
}

public enum EvaluationMethod {
    case batch
    case serial
    case sdkUnknown(String)
}

extension EvaluationMethod : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EvaluationMethod] {
        return [
            .batch,
            .serial,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .batch: return "BATCH"
        case .serial: return "SERIAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EvaluationMethod(rawValue: rawValue) ?? EvaluationMethod.sdkUnknown(rawValue)
    }
}

extension Event: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions
        case condition
        case eventName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actions0 in actions {
                try actionsContainer.encode(actions0)
            }
        }
        if let condition = condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let eventName = eventName {
            try encodeContainer.encode(eventName, forKey: .eventName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventName)
        eventName = eventNameDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .condition)
        condition = conditionDecoded
        let actionsContainer = try containerValues.decodeIfPresent([Action?].self, forKey: .actions)
        var actionsDecoded0:[Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension Event: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Event(actions: \(String(describing: actions)), condition: \(String(describing: condition)), eventName: \(String(describing: eventName)))"}
}

/// <p>Specifies the <code>actions</code> to be performed when the <code>condition</code>
///       evaluates to TRUE.</p>
public struct Event: Equatable {
    /// <p>The actions to be performed.</p>
    public let actions: [Action]?
    /// <p>Optional. The Boolean expression that, when TRUE, causes the <code>actions</code> to be
    ///       performed. If not present, the actions are performed (=TRUE). If the expression result is not
    ///       a Boolean value, the actions are not performed (=FALSE).</p>
    public let condition: String?
    /// <p>The name of the event.</p>
    public let eventName: String?

    public init (
        actions: [Action]? = nil,
        condition: String? = nil,
        eventName: String? = nil
    )
    {
        self.actions = actions
        self.condition = condition
        self.eventName = eventName
    }
}

extension FirehoseAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deliveryStreamName
        case payload
        case separator
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryStreamName = deliveryStreamName {
            try encodeContainer.encode(deliveryStreamName, forKey: .deliveryStreamName)
        }
        if let payload = payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if let separator = separator {
            try encodeContainer.encode(separator, forKey: .separator)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryStreamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deliveryStreamName)
        deliveryStreamName = deliveryStreamNameDecoded
        let separatorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .separator)
        separator = separatorDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension FirehoseAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FirehoseAction(deliveryStreamName: \(String(describing: deliveryStreamName)), payload: \(String(describing: payload)), separator: \(String(describing: separator)))"}
}

/// <p>Sends information about the detector model instance and the event that triggered the
///       action to an Amazon Kinesis Data Firehose delivery stream.</p>
public struct FirehoseAction: Equatable {
    /// <p>The name of the Kinesis Data Firehose delivery stream where the data is written.</p>
    public let deliveryStreamName: String?
    /// <p>You can configure the action payload when you send a message to an Amazon Kinesis Data Firehose delivery
    ///       stream.</p>
    public let payload: Payload?
    /// <p>A character separator that is used to separate records written to the Kinesis Data
    ///       Firehose delivery stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows
    ///       newline), ',' (comma).</p>
    public let separator: String?

    public init (
        deliveryStreamName: String? = nil,
        payload: Payload? = nil,
        separator: String? = nil
    )
    {
        self.deliveryStreamName = deliveryStreamName
        self.payload = payload
        self.separator = separator
    }
}

extension GetDetectorModelAnalysisResultsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDetectorModelAnalysisResultsInput(analysisId: \(String(describing: analysisId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetDetectorModelAnalysisResultsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDetectorModelAnalysisResultsInputHeadersMiddleware: Middleware {
    public let id: String = "GetDetectorModelAnalysisResultsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDetectorModelAnalysisResultsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDetectorModelAnalysisResultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDetectorModelAnalysisResultsInput>
    public typealias MOutput = OperationOutput<GetDetectorModelAnalysisResultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDetectorModelAnalysisResultsOutputError>
}

public struct GetDetectorModelAnalysisResultsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDetectorModelAnalysisResultsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDetectorModelAnalysisResultsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDetectorModelAnalysisResultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDetectorModelAnalysisResultsInput>
    public typealias MOutput = OperationOutput<GetDetectorModelAnalysisResultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDetectorModelAnalysisResultsOutputError>
}

public struct GetDetectorModelAnalysisResultsInput: Equatable {
    /// <p>The ID of the analysis result that you want to retrieve.</p>
    public let analysisId: String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int?
    /// <p>The token that you can use to return the next set of results.</p>
    public let nextToken: String?

    public init (
        analysisId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.analysisId = analysisId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetDetectorModelAnalysisResultsInputBody: Equatable {
}

extension GetDetectorModelAnalysisResultsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDetectorModelAnalysisResultsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDetectorModelAnalysisResultsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDetectorModelAnalysisResultsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDetectorModelAnalysisResultsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDetectorModelAnalysisResultsOutputResponse(analysisResults: \(String(describing: analysisResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetDetectorModelAnalysisResultsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDetectorModelAnalysisResultsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.analysisResults = output.analysisResults
            self.nextToken = output.nextToken
        } else {
            self.analysisResults = nil
            self.nextToken = nil
        }
    }
}

public struct GetDetectorModelAnalysisResultsOutputResponse: Equatable {
    /// <p>Contains information about one or more analysis results.</p>
    public let analysisResults: [AnalysisResult]?
    /// <p>The token that you can use to return the next set of results,
    /// or <code>null</code> if there are no more results.</p>
    public let nextToken: String?

    public init (
        analysisResults: [AnalysisResult]? = nil,
        nextToken: String? = nil
    )
    {
        self.analysisResults = analysisResults
        self.nextToken = nextToken
    }
}

struct GetDetectorModelAnalysisResultsOutputResponseBody: Equatable {
    public let analysisResults: [AnalysisResult]?
    public let nextToken: String?
}

extension GetDetectorModelAnalysisResultsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analysisResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisResultsContainer = try containerValues.decodeIfPresent([AnalysisResult?].self, forKey: .analysisResults)
        var analysisResultsDecoded0:[AnalysisResult]? = nil
        if let analysisResultsContainer = analysisResultsContainer {
            analysisResultsDecoded0 = [AnalysisResult]()
            for structure0 in analysisResultsContainer {
                if let structure0 = structure0 {
                    analysisResultsDecoded0?.append(structure0)
                }
            }
        }
        analysisResults = analysisResultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension InitializationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case disabledOnInitialization
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabledOnInitialization = disabledOnInitialization {
            try encodeContainer.encode(disabledOnInitialization, forKey: .disabledOnInitialization)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disabledOnInitializationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .disabledOnInitialization)
        disabledOnInitialization = disabledOnInitializationDecoded
    }
}

extension InitializationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InitializationConfiguration(disabledOnInitialization: \(String(describing: disabledOnInitialization)))"}
}

/// <p>Specifies the default alarm state.
/// The configuration applies to all alarms that were created based on this alarm model.</p>
public struct InitializationConfiguration: Equatable {
    /// <p>The value must be <code>TRUE</code> or <code>FALSE</code>. If <code>FALSE</code>, all
    ///       alarm instances created based on the alarm model are activated. The default value is
    ///         <code>TRUE</code>.</p>
    public let disabledOnInitialization: Bool?

    public init (
        disabledOnInitialization: Bool? = nil
    )
    {
        self.disabledOnInitialization = disabledOnInitialization
    }
}

extension Input: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputConfiguration
        case inputDefinition
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputConfiguration = inputConfiguration {
            try encodeContainer.encode(inputConfiguration, forKey: .inputConfiguration)
        }
        if let inputDefinition = inputDefinition {
            try encodeContainer.encode(inputDefinition, forKey: .inputDefinition)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputConfigurationDecoded = try containerValues.decodeIfPresent(InputConfiguration.self, forKey: .inputConfiguration)
        inputConfiguration = inputConfigurationDecoded
        let inputDefinitionDecoded = try containerValues.decodeIfPresent(InputDefinition.self, forKey: .inputDefinition)
        inputDefinition = inputDefinitionDecoded
    }
}

extension Input: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Input(inputConfiguration: \(String(describing: inputConfiguration)), inputDefinition: \(String(describing: inputDefinition)))"}
}

/// <p>Information about the input.</p>
public struct Input: Equatable {
    /// <p>Information about the configuration of an input.</p>
    public let inputConfiguration: InputConfiguration?
    /// <p>The definition of the input.</p>
    public let inputDefinition: InputDefinition?

    public init (
        inputConfiguration: InputConfiguration? = nil,
        inputDefinition: InputDefinition? = nil
    )
    {
        self.inputConfiguration = inputConfiguration
        self.inputDefinition = inputDefinition
    }
}

extension InputConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime
        case inputArn
        case inputDescription
        case inputName
        case lastUpdateTime
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let inputArn = inputArn {
            try encodeContainer.encode(inputArn, forKey: .inputArn)
        }
        if let inputDescription = inputDescription {
            try encodeContainer.encode(inputDescription, forKey: .inputDescription)
        }
        if let inputName = inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputName)
        inputName = inputNameDecoded
        let inputDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputDescription)
        inputDescription = inputDescriptionDecoded
        let inputArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputArn)
        inputArn = inputArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(InputStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension InputConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputConfiguration(creationTime: \(String(describing: creationTime)), inputArn: \(String(describing: inputArn)), inputDescription: \(String(describing: inputDescription)), inputName: \(String(describing: inputName)), lastUpdateTime: \(String(describing: lastUpdateTime)), status: \(String(describing: status)))"}
}

/// <p>Information about the configuration of an input.</p>
public struct InputConfiguration: Equatable {
    /// <p>The time the input was created.</p>
    public let creationTime: Date?
    /// <p>The ARN of the input.</p>
    public let inputArn: String?
    /// <p>A brief description of the input.</p>
    public let inputDescription: String?
    /// <p>The name of the input.</p>
    public let inputName: String?
    /// <p>The last time the input was updated.</p>
    public let lastUpdateTime: Date?
    /// <p>The status of the input.</p>
    public let status: InputStatus?

    public init (
        creationTime: Date? = nil,
        inputArn: String? = nil,
        inputDescription: String? = nil,
        inputName: String? = nil,
        lastUpdateTime: Date? = nil,
        status: InputStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.inputArn = inputArn
        self.inputDescription = inputDescription
        self.inputName = inputName
        self.lastUpdateTime = lastUpdateTime
        self.status = status
    }
}

extension InputDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributes0 in attributes {
                try attributesContainer.encode(attributes0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension InputDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputDefinition(attributes: \(String(describing: attributes)))"}
}

/// <p>The definition of the input.</p>
public struct InputDefinition: Equatable {
    /// <p>The attributes from the JSON payload that are made available by the input. Inputs are
    ///       derived from messages sent to the AWS IoT Events system using <code>BatchPutMessage</code>. Each such
    ///       message contains a JSON payload, and those attributes (and their paired values) specified here
    ///       are available for use in the <code>condition</code> expressions used by detectors that monitor
    ///       this input. </p>
    public let attributes: [Attribute]?

    public init (
        attributes: [Attribute]? = nil
    )
    {
        self.attributes = attributes
    }
}

extension InputIdentifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iotEventsInputIdentifier
        case iotSiteWiseInputIdentifier
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iotEventsInputIdentifier = iotEventsInputIdentifier {
            try encodeContainer.encode(iotEventsInputIdentifier, forKey: .iotEventsInputIdentifier)
        }
        if let iotSiteWiseInputIdentifier = iotSiteWiseInputIdentifier {
            try encodeContainer.encode(iotSiteWiseInputIdentifier, forKey: .iotSiteWiseInputIdentifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotEventsInputIdentifierDecoded = try containerValues.decodeIfPresent(IotEventsInputIdentifier.self, forKey: .iotEventsInputIdentifier)
        iotEventsInputIdentifier = iotEventsInputIdentifierDecoded
        let iotSiteWiseInputIdentifierDecoded = try containerValues.decodeIfPresent(IotSiteWiseInputIdentifier.self, forKey: .iotSiteWiseInputIdentifier)
        iotSiteWiseInputIdentifier = iotSiteWiseInputIdentifierDecoded
    }
}

extension InputIdentifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputIdentifier(iotEventsInputIdentifier: \(String(describing: iotEventsInputIdentifier)), iotSiteWiseInputIdentifier: \(String(describing: iotSiteWiseInputIdentifier)))"}
}

/// <p>
///       The identifer of the input.
///     </p>
public struct InputIdentifier: Equatable {
    /// <p>
    ///       The identifier of the input routed to AWS IoT Events.
    ///     </p>
    public let iotEventsInputIdentifier: IotEventsInputIdentifier?
    /// <p>
    ///       The identifer of the input routed from AWS IoT SiteWise.
    ///     </p>
    public let iotSiteWiseInputIdentifier: IotSiteWiseInputIdentifier?

    public init (
        iotEventsInputIdentifier: IotEventsInputIdentifier? = nil,
        iotSiteWiseInputIdentifier: IotSiteWiseInputIdentifier? = nil
    )
    {
        self.iotEventsInputIdentifier = iotEventsInputIdentifier
        self.iotSiteWiseInputIdentifier = iotSiteWiseInputIdentifier
    }
}

public enum InputStatus {
    case active
    case creating
    case deleting
    case updating
    case sdkUnknown(String)
}

extension InputStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InputStatus] {
        return [
            .active,
            .creating,
            .deleting,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InputStatus(rawValue: rawValue) ?? InputStatus.sdkUnknown(rawValue)
    }
}

extension InputSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime
        case inputArn
        case inputDescription
        case inputName
        case lastUpdateTime
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let inputArn = inputArn {
            try encodeContainer.encode(inputArn, forKey: .inputArn)
        }
        if let inputDescription = inputDescription {
            try encodeContainer.encode(inputDescription, forKey: .inputDescription)
        }
        if let inputName = inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputName)
        inputName = inputNameDecoded
        let inputDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputDescription)
        inputDescription = inputDescriptionDecoded
        let inputArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputArn)
        inputArn = inputArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(InputStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension InputSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputSummary(creationTime: \(String(describing: creationTime)), inputArn: \(String(describing: inputArn)), inputDescription: \(String(describing: inputDescription)), inputName: \(String(describing: inputName)), lastUpdateTime: \(String(describing: lastUpdateTime)), status: \(String(describing: status)))"}
}

/// <p>Information about the input.</p>
public struct InputSummary: Equatable {
    /// <p>The time the input was created.</p>
    public let creationTime: Date?
    /// <p>The ARN of the input.</p>
    public let inputArn: String?
    /// <p>A brief description of the input.</p>
    public let inputDescription: String?
    /// <p>The name of the input.</p>
    public let inputName: String?
    /// <p>The last time the input was updated.</p>
    public let lastUpdateTime: Date?
    /// <p>The status of the input.</p>
    public let status: InputStatus?

    public init (
        creationTime: Date? = nil,
        inputArn: String? = nil,
        inputDescription: String? = nil,
        inputName: String? = nil,
        lastUpdateTime: Date? = nil,
        status: InputStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.inputArn = inputArn
        self.inputDescription = inputDescription
        self.inputName = inputName
        self.lastUpdateTime = lastUpdateTime
        self.status = status
    }
}

extension InternalFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalFailureException(message: \(String(describing: message)))"}
}

extension InternalFailureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal failure occurred.</p>
public struct InternalFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Equatable {
    public let message: String?
}

extension InternalFailureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was invalid.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IotEventsAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputName
        case payload
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputName = inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
        if let payload = payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputName)
        inputName = inputNameDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension IotEventsAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IotEventsAction(inputName: \(String(describing: inputName)), payload: \(String(describing: payload)))"}
}

/// <p>Sends an AWS IoT Events input, passing in information about the detector model instance and the
///       event that triggered the action.</p>
public struct IotEventsAction: Equatable {
    /// <p>The name of the AWS IoT Events input where the data is sent.</p>
    public let inputName: String?
    /// <p>You can configure the action payload when you send a message to an AWS IoT Events input.</p>
    public let payload: Payload?

    public init (
        inputName: String? = nil,
        payload: Payload? = nil
    )
    {
        self.inputName = inputName
        self.payload = payload
    }
}

extension IotEventsInputIdentifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputName = inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputName)
        inputName = inputNameDecoded
    }
}

extension IotEventsInputIdentifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IotEventsInputIdentifier(inputName: \(String(describing: inputName)))"}
}

/// <p>
///       The identifier of the input routed to AWS IoT Events.
///     </p>
public struct IotEventsInputIdentifier: Equatable {
    /// <p>
    ///       The name of the input routed to AWS IoT Events.
    ///     </p>
    public let inputName: String?

    public init (
        inputName: String? = nil
    )
    {
        self.inputName = inputName
    }
}

extension IotSiteWiseAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assetId
        case entryId
        case propertyAlias
        case propertyId
        case propertyValue
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let entryId = entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let propertyAlias = propertyAlias {
            try encodeContainer.encode(propertyAlias, forKey: .propertyAlias)
        }
        if let propertyId = propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
        if let propertyValue = propertyValue {
            try encodeContainer.encode(propertyValue, forKey: .propertyValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let assetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let propertyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
        let propertyAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .propertyAlias)
        propertyAlias = propertyAliasDecoded
        let propertyValueDecoded = try containerValues.decodeIfPresent(AssetPropertyValue.self, forKey: .propertyValue)
        propertyValue = propertyValueDecoded
    }
}

extension IotSiteWiseAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IotSiteWiseAction(assetId: \(String(describing: assetId)), entryId: \(String(describing: entryId)), propertyAlias: \(String(describing: propertyAlias)), propertyId: \(String(describing: propertyId)), propertyValue: \(String(describing: propertyValue)))"}
}

/// <p>Sends information about the detector model instance and the event that triggered the
///       action to a specified asset property in AWS IoT SiteWise.</p>
///          <p>You must use expressions for all parameters in <code>IotSiteWiseAction</code>. The
///       expressions accept literals, operators, functions, references, and substitutions
///       templates.</p>
///          <p class="title">
///             <b>Examples</b>
///          </p>
///          <ul>
///             <li>
///                <p>For literal values, the expressions must contain single quotes. For example, the value
///           for the <code>propertyAlias</code> parameter can be
///             <code>'/company/windfarm/3/turbine/7/temperature'</code>.</p>
///             </li>
///             <li>
///                <p>For references, you must specify either variables or input values. For example, the
///           value for the <code>assetId</code> parameter can be
///             <code>$input.TurbineInput.assetId1</code>.</p>
///             </li>
///             <li>
///                <p>For a substitution template, you must use <code>${}</code>, and the template must be
///           in single quotes. A substitution template can also contain a combination of literals,
///           operators, functions, references, and substitution templates.</p>
///                <p>In the following example, the value for the <code>propertyAlias</code> parameter uses
///           a substitution template. </p>
///                <p>
///                   <code>'company/windfarm/${$input.TemperatureInput.sensorData.windfarmID}/turbine/
///             ${$input.TemperatureInput.sensorData.turbineID}/temperature'</code>
///                </p>
///             </li>
///          </ul>
///          <p>You must specify either <code>propertyAlias</code> or both <code>assetId</code> and
///         <code>propertyId</code> to identify the target asset property in AWS IoT SiteWise.</p>
///          <p>For more information,
///         see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html">Expressions</a>
///         in the <i>AWS IoT Events Developer Guide</i>.</p>
public struct IotSiteWiseAction: Equatable {
    /// <p>The ID of the asset that has the specified property.</p>
    public let assetId: String?
    /// <p>A unique identifier for this entry. You can use the entry ID to track which data entry
    ///       causes an error in case of failure. The default is a new unique identifier.</p>
    public let entryId: String?
    /// <p>The alias of the asset property.</p>
    public let propertyAlias: String?
    /// <p>The ID of the asset property.</p>
    public let propertyId: String?
    /// <p>The value to send to the asset property. This value contains timestamp, quality, and value
    ///       (TQV) information. </p>
    public let propertyValue: AssetPropertyValue?

    public init (
        assetId: String? = nil,
        entryId: String? = nil,
        propertyAlias: String? = nil,
        propertyId: String? = nil,
        propertyValue: AssetPropertyValue? = nil
    )
    {
        self.assetId = assetId
        self.entryId = entryId
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
        self.propertyValue = propertyValue
    }
}

extension IotSiteWiseAssetModelPropertyIdentifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assetModelId
        case propertyId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetModelId = assetModelId {
            try encodeContainer.encode(assetModelId, forKey: .assetModelId)
        }
        if let propertyId = propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let propertyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
    }
}

extension IotSiteWiseAssetModelPropertyIdentifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IotSiteWiseAssetModelPropertyIdentifier(assetModelId: \(String(describing: assetModelId)), propertyId: \(String(describing: propertyId)))"}
}

/// <p>
///       The asset model property identifer of the input routed from AWS IoT SiteWise.
///     </p>
public struct IotSiteWiseAssetModelPropertyIdentifier: Equatable {
    /// <p>
    ///       The ID of the AWS IoT SiteWise asset model.
    ///     </p>
    public let assetModelId: String?
    /// <p>
    ///       The ID of the AWS IoT SiteWise asset property.
    ///     </p>
    public let propertyId: String?

    public init (
        assetModelId: String? = nil,
        propertyId: String? = nil
    )
    {
        self.assetModelId = assetModelId
        self.propertyId = propertyId
    }
}

extension IotSiteWiseInputIdentifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iotSiteWiseAssetModelPropertyIdentifier
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iotSiteWiseAssetModelPropertyIdentifier = iotSiteWiseAssetModelPropertyIdentifier {
            try encodeContainer.encode(iotSiteWiseAssetModelPropertyIdentifier, forKey: .iotSiteWiseAssetModelPropertyIdentifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotSiteWiseAssetModelPropertyIdentifierDecoded = try containerValues.decodeIfPresent(IotSiteWiseAssetModelPropertyIdentifier.self, forKey: .iotSiteWiseAssetModelPropertyIdentifier)
        iotSiteWiseAssetModelPropertyIdentifier = iotSiteWiseAssetModelPropertyIdentifierDecoded
    }
}

extension IotSiteWiseInputIdentifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IotSiteWiseInputIdentifier(iotSiteWiseAssetModelPropertyIdentifier: \(String(describing: iotSiteWiseAssetModelPropertyIdentifier)))"}
}

/// <p>
///       The identifer of the input routed from AWS IoT SiteWise.
///     </p>
public struct IotSiteWiseInputIdentifier: Equatable {
    /// <p>
    ///       The identifier of the AWS IoT SiteWise asset model property.
    ///     </p>
    public let iotSiteWiseAssetModelPropertyIdentifier: IotSiteWiseAssetModelPropertyIdentifier?

    public init (
        iotSiteWiseAssetModelPropertyIdentifier: IotSiteWiseAssetModelPropertyIdentifier? = nil
    )
    {
        self.iotSiteWiseAssetModelPropertyIdentifier = iotSiteWiseAssetModelPropertyIdentifier
    }
}

extension IotTopicPublishAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mqttTopic
        case payload
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mqttTopic = mqttTopic {
            try encodeContainer.encode(mqttTopic, forKey: .mqttTopic)
        }
        if let payload = payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mqttTopicDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mqttTopic)
        mqttTopic = mqttTopicDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension IotTopicPublishAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IotTopicPublishAction(mqttTopic: \(String(describing: mqttTopic)), payload: \(String(describing: payload)))"}
}

/// <p>Information required to publish the MQTT message through the AWS IoT message broker.</p>
public struct IotTopicPublishAction: Equatable {
    /// <p>The MQTT topic of the message. You can use a string expression that includes variables
    ///         (<code>$variable.<variable-name></code>) and input values
    ///         (<code>$input.<input-name>.<path-to-datum></code>) as the topic string.</p>
    public let mqttTopic: String?
    /// <p>You can configure the action payload when you publish a message to an AWS IoT Core
    ///       topic.</p>
    public let payload: Payload?

    public init (
        mqttTopic: String? = nil,
        payload: Payload? = nil
    )
    {
        self.mqttTopic = mqttTopic
        self.payload = payload
    }
}

extension LambdaAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case functionArn
        case payload
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let functionArn = functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let payload = payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension LambdaAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaAction(functionArn: \(String(describing: functionArn)), payload: \(String(describing: payload)))"}
}

/// <p>Calls a Lambda function, passing in information about the detector model instance and the
///       event that triggered the action.</p>
public struct LambdaAction: Equatable {
    /// <p>The ARN of the Lambda function that is executed.</p>
    public let functionArn: String?
    /// <p>You can configure the action payload when you send a message to a Lambda function.</p>
    public let payload: Payload?

    public init (
        functionArn: String? = nil,
        payload: Payload? = nil
    )
    {
        self.functionArn = functionArn
        self.payload = payload
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A limit was exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAlarmModelVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAlarmModelVersionsInput(alarmModelName: \(String(describing: alarmModelName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAlarmModelVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAlarmModelVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAlarmModelVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAlarmModelVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAlarmModelVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAlarmModelVersionsInput>
    public typealias MOutput = OperationOutput<ListAlarmModelVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAlarmModelVersionsOutputError>
}

public struct ListAlarmModelVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAlarmModelVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAlarmModelVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAlarmModelVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAlarmModelVersionsInput>
    public typealias MOutput = OperationOutput<ListAlarmModelVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAlarmModelVersionsOutputError>
}

public struct ListAlarmModelVersionsInput: Equatable {
    /// <p>The name of the alarm model.</p>
    public let alarmModelName: String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int?
    /// <p>The token that you can use to return the next set of results.</p>
    public let nextToken: String?

    public init (
        alarmModelName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.alarmModelName = alarmModelName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAlarmModelVersionsInputBody: Equatable {
}

extension ListAlarmModelVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAlarmModelVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAlarmModelVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAlarmModelVersionsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAlarmModelVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAlarmModelVersionsOutputResponse(alarmModelVersionSummaries: \(String(describing: alarmModelVersionSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAlarmModelVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAlarmModelVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.alarmModelVersionSummaries = output.alarmModelVersionSummaries
            self.nextToken = output.nextToken
        } else {
            self.alarmModelVersionSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAlarmModelVersionsOutputResponse: Equatable {
    /// <p>A list that summarizes each alarm model version.</p>
    public let alarmModelVersionSummaries: [AlarmModelVersionSummary]?
    /// <p>The token that you can use to return the next set of results,
    /// or <code>null</code> if there are no more results.</p>
    public let nextToken: String?

    public init (
        alarmModelVersionSummaries: [AlarmModelVersionSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.alarmModelVersionSummaries = alarmModelVersionSummaries
        self.nextToken = nextToken
    }
}

struct ListAlarmModelVersionsOutputResponseBody: Equatable {
    public let alarmModelVersionSummaries: [AlarmModelVersionSummary]?
    public let nextToken: String?
}

extension ListAlarmModelVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alarmModelVersionSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmModelVersionSummariesContainer = try containerValues.decodeIfPresent([AlarmModelVersionSummary?].self, forKey: .alarmModelVersionSummaries)
        var alarmModelVersionSummariesDecoded0:[AlarmModelVersionSummary]? = nil
        if let alarmModelVersionSummariesContainer = alarmModelVersionSummariesContainer {
            alarmModelVersionSummariesDecoded0 = [AlarmModelVersionSummary]()
            for structure0 in alarmModelVersionSummariesContainer {
                if let structure0 = structure0 {
                    alarmModelVersionSummariesDecoded0?.append(structure0)
                }
            }
        }
        alarmModelVersionSummaries = alarmModelVersionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAlarmModelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAlarmModelsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAlarmModelsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAlarmModelsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAlarmModelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAlarmModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAlarmModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAlarmModelsInput>
    public typealias MOutput = OperationOutput<ListAlarmModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAlarmModelsOutputError>
}

public struct ListAlarmModelsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAlarmModelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAlarmModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAlarmModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAlarmModelsInput>
    public typealias MOutput = OperationOutput<ListAlarmModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAlarmModelsOutputError>
}

public struct ListAlarmModelsInput: Equatable {
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int?
    /// <p>The token that you can use to return the next set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAlarmModelsInputBody: Equatable {
}

extension ListAlarmModelsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAlarmModelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAlarmModelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAlarmModelsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAlarmModelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAlarmModelsOutputResponse(alarmModelSummaries: \(String(describing: alarmModelSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAlarmModelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAlarmModelsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.alarmModelSummaries = output.alarmModelSummaries
            self.nextToken = output.nextToken
        } else {
            self.alarmModelSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAlarmModelsOutputResponse: Equatable {
    /// <p>A list that summarizes each alarm model.</p>
    public let alarmModelSummaries: [AlarmModelSummary]?
    /// <p>The token that you can use to return the next set of results,
    /// or <code>null</code> if there are no more results.</p>
    public let nextToken: String?

    public init (
        alarmModelSummaries: [AlarmModelSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.alarmModelSummaries = alarmModelSummaries
        self.nextToken = nextToken
    }
}

struct ListAlarmModelsOutputResponseBody: Equatable {
    public let alarmModelSummaries: [AlarmModelSummary]?
    public let nextToken: String?
}

extension ListAlarmModelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alarmModelSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmModelSummariesContainer = try containerValues.decodeIfPresent([AlarmModelSummary?].self, forKey: .alarmModelSummaries)
        var alarmModelSummariesDecoded0:[AlarmModelSummary]? = nil
        if let alarmModelSummariesContainer = alarmModelSummariesContainer {
            alarmModelSummariesDecoded0 = [AlarmModelSummary]()
            for structure0 in alarmModelSummariesContainer {
                if let structure0 = structure0 {
                    alarmModelSummariesDecoded0?.append(structure0)
                }
            }
        }
        alarmModelSummaries = alarmModelSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDetectorModelVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDetectorModelVersionsInput(detectorModelName: \(String(describing: detectorModelName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDetectorModelVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDetectorModelVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDetectorModelVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDetectorModelVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDetectorModelVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDetectorModelVersionsInput>
    public typealias MOutput = OperationOutput<ListDetectorModelVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDetectorModelVersionsOutputError>
}

public struct ListDetectorModelVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDetectorModelVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDetectorModelVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDetectorModelVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDetectorModelVersionsInput>
    public typealias MOutput = OperationOutput<ListDetectorModelVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDetectorModelVersionsOutputError>
}

public struct ListDetectorModelVersionsInput: Equatable {
    /// <p>The name of the detector model whose versions are returned.</p>
    public let detectorModelName: String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int?
    /// <p>The token that you can use to return the next set of results.</p>
    public let nextToken: String?

    public init (
        detectorModelName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.detectorModelName = detectorModelName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDetectorModelVersionsInputBody: Equatable {
}

extension ListDetectorModelVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDetectorModelVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDetectorModelVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDetectorModelVersionsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDetectorModelVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDetectorModelVersionsOutputResponse(detectorModelVersionSummaries: \(String(describing: detectorModelVersionSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDetectorModelVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDetectorModelVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.detectorModelVersionSummaries = output.detectorModelVersionSummaries
            self.nextToken = output.nextToken
        } else {
            self.detectorModelVersionSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDetectorModelVersionsOutputResponse: Equatable {
    /// <p>Summary information about the detector model versions.</p>
    public let detectorModelVersionSummaries: [DetectorModelVersionSummary]?
    /// <p>The token that you can use to return the next set of results,
    /// or <code>null</code> if there are no more results.</p>
    public let nextToken: String?

    public init (
        detectorModelVersionSummaries: [DetectorModelVersionSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.detectorModelVersionSummaries = detectorModelVersionSummaries
        self.nextToken = nextToken
    }
}

struct ListDetectorModelVersionsOutputResponseBody: Equatable {
    public let detectorModelVersionSummaries: [DetectorModelVersionSummary]?
    public let nextToken: String?
}

extension ListDetectorModelVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectorModelVersionSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelVersionSummariesContainer = try containerValues.decodeIfPresent([DetectorModelVersionSummary?].self, forKey: .detectorModelVersionSummaries)
        var detectorModelVersionSummariesDecoded0:[DetectorModelVersionSummary]? = nil
        if let detectorModelVersionSummariesContainer = detectorModelVersionSummariesContainer {
            detectorModelVersionSummariesDecoded0 = [DetectorModelVersionSummary]()
            for structure0 in detectorModelVersionSummariesContainer {
                if let structure0 = structure0 {
                    detectorModelVersionSummariesDecoded0?.append(structure0)
                }
            }
        }
        detectorModelVersionSummaries = detectorModelVersionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDetectorModelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDetectorModelsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDetectorModelsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDetectorModelsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDetectorModelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDetectorModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDetectorModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDetectorModelsInput>
    public typealias MOutput = OperationOutput<ListDetectorModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDetectorModelsOutputError>
}

public struct ListDetectorModelsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDetectorModelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDetectorModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDetectorModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDetectorModelsInput>
    public typealias MOutput = OperationOutput<ListDetectorModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDetectorModelsOutputError>
}

public struct ListDetectorModelsInput: Equatable {
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int?
    /// <p>The token that you can use to return the next set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDetectorModelsInputBody: Equatable {
}

extension ListDetectorModelsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDetectorModelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDetectorModelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDetectorModelsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDetectorModelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDetectorModelsOutputResponse(detectorModelSummaries: \(String(describing: detectorModelSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDetectorModelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDetectorModelsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.detectorModelSummaries = output.detectorModelSummaries
            self.nextToken = output.nextToken
        } else {
            self.detectorModelSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDetectorModelsOutputResponse: Equatable {
    /// <p>Summary information about the detector models.</p>
    public let detectorModelSummaries: [DetectorModelSummary]?
    /// <p>The token that you can use to return the next set of results,
    /// or <code>null</code> if there are no more results.</p>
    public let nextToken: String?

    public init (
        detectorModelSummaries: [DetectorModelSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.detectorModelSummaries = detectorModelSummaries
        self.nextToken = nextToken
    }
}

struct ListDetectorModelsOutputResponseBody: Equatable {
    public let detectorModelSummaries: [DetectorModelSummary]?
    public let nextToken: String?
}

extension ListDetectorModelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectorModelSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelSummariesContainer = try containerValues.decodeIfPresent([DetectorModelSummary?].self, forKey: .detectorModelSummaries)
        var detectorModelSummariesDecoded0:[DetectorModelSummary]? = nil
        if let detectorModelSummariesContainer = detectorModelSummariesContainer {
            detectorModelSummariesDecoded0 = [DetectorModelSummary]()
            for structure0 in detectorModelSummariesContainer {
                if let structure0 = structure0 {
                    detectorModelSummariesDecoded0?.append(structure0)
                }
            }
        }
        detectorModelSummaries = detectorModelSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListInputRoutingsInputBodyMiddleware: Middleware {
    public let id: String = "ListInputRoutingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInputRoutingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInputRoutingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInputRoutingsInput>
    public typealias MOutput = OperationOutput<ListInputRoutingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInputRoutingsOutputError>
}

extension ListInputRoutingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInputRoutingsInput(inputIdentifier: \(String(describing: inputIdentifier)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInputRoutingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputIdentifier
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputIdentifier = inputIdentifier {
            try encodeContainer.encode(inputIdentifier, forKey: .inputIdentifier)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListInputRoutingsInputHeadersMiddleware: Middleware {
    public let id: String = "ListInputRoutingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInputRoutingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInputRoutingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInputRoutingsInput>
    public typealias MOutput = OperationOutput<ListInputRoutingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInputRoutingsOutputError>
}

public struct ListInputRoutingsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListInputRoutingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInputRoutingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInputRoutingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInputRoutingsInput>
    public typealias MOutput = OperationOutput<ListInputRoutingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInputRoutingsOutputError>
}

public struct ListInputRoutingsInput: Equatable {
    /// <p>
    ///       The identifer of the routed input.
    ///     </p>
    public let inputIdentifier: InputIdentifier?
    /// <p>
    ///       The maximum number of results to be returned per request.
    ///     </p>
    public let maxResults: Int?
    /// <p>
    ///       The token that you can use to return the next set of results.
    ///     </p>
    public let nextToken: String?

    public init (
        inputIdentifier: InputIdentifier? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.inputIdentifier = inputIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInputRoutingsInputBody: Equatable {
    public let inputIdentifier: InputIdentifier?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListInputRoutingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inputIdentifier
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputIdentifierDecoded = try containerValues.decodeIfPresent(InputIdentifier.self, forKey: .inputIdentifier)
        inputIdentifier = inputIdentifierDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInputRoutingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInputRoutingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInputRoutingsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInputRoutingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInputRoutingsOutputResponse(nextToken: \(String(describing: nextToken)), routedResources: \(String(describing: routedResources)))"}
}

extension ListInputRoutingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListInputRoutingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.routedResources = output.routedResources
        } else {
            self.nextToken = nil
            self.routedResources = nil
        }
    }
}

public struct ListInputRoutingsOutputResponse: Equatable {
    /// <p>
    ///       The token that you can use to return the next set of results,
    /// or <code>null</code> if there are no more results.
    ///     </p>
    public let nextToken: String?
    /// <p>
    ///       Summary information about the routed resources.
    ///     </p>
    public let routedResources: [RoutedResource]?

    public init (
        nextToken: String? = nil,
        routedResources: [RoutedResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.routedResources = routedResources
    }
}

struct ListInputRoutingsOutputResponseBody: Equatable {
    public let routedResources: [RoutedResource]?
    public let nextToken: String?
}

extension ListInputRoutingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case routedResources
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routedResourcesContainer = try containerValues.decodeIfPresent([RoutedResource?].self, forKey: .routedResources)
        var routedResourcesDecoded0:[RoutedResource]? = nil
        if let routedResourcesContainer = routedResourcesContainer {
            routedResourcesDecoded0 = [RoutedResource]()
            for structure0 in routedResourcesContainer {
                if let structure0 = structure0 {
                    routedResourcesDecoded0?.append(structure0)
                }
            }
        }
        routedResources = routedResourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInputsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInputsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInputsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListInputsInputHeadersMiddleware: Middleware {
    public let id: String = "ListInputsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInputsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInputsInput>
    public typealias MOutput = OperationOutput<ListInputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInputsOutputError>
}

public struct ListInputsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListInputsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInputsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInputsInput>
    public typealias MOutput = OperationOutput<ListInputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInputsOutputError>
}

public struct ListInputsInput: Equatable {
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int?
    /// <p>The token that you can use to return the next set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInputsInputBody: Equatable {
}

extension ListInputsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListInputsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInputsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInputsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInputsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInputsOutputResponse(inputSummaries: \(String(describing: inputSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInputsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListInputsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.inputSummaries = output.inputSummaries
            self.nextToken = output.nextToken
        } else {
            self.inputSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListInputsOutputResponse: Equatable {
    /// <p>Summary information about the inputs.</p>
    public let inputSummaries: [InputSummary]?
    /// <p>The token that you can use to return the next set of results,
    /// or <code>null</code> if there are no more results.</p>
    public let nextToken: String?

    public init (
        inputSummaries: [InputSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.inputSummaries = inputSummaries
        self.nextToken = nextToken
    }
}

struct ListInputsOutputResponseBody: Equatable {
    public let inputSummaries: [InputSummary]?
    public let nextToken: String?
}

extension ListInputsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inputSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputSummariesContainer = try containerValues.decodeIfPresent([InputSummary?].self, forKey: .inputSummaries)
        var inputSummariesDecoded0:[InputSummary]? = nil
        if let inputSummariesContainer = inputSummariesContainer {
            inputSummariesDecoded0 = [InputSummary]()
            for structure0 in inputSummariesContainer {
                if let structure0 = structure0 {
                    inputSummariesDecoded0?.append(structure0)
                }
            }
        }
        inputSummaries = inputSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The ARN of the resource.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The list of tags assigned to the resource.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum LoggingLevel {
    case debug
    case error
    case info
    case sdkUnknown(String)
}

extension LoggingLevel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LoggingLevel] {
        return [
            .debug,
            .error,
            .info,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .debug: return "DEBUG"
        case .error: return "ERROR"
        case .info: return "INFO"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LoggingLevel(rawValue: rawValue) ?? LoggingLevel.sdkUnknown(rawValue)
    }
}

extension LoggingOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detectorDebugOptions
        case enabled
        case level
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorDebugOptions = detectorDebugOptions {
            var detectorDebugOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .detectorDebugOptions)
            for detectordebugoptions0 in detectorDebugOptions {
                try detectorDebugOptionsContainer.encode(detectordebugoptions0)
            }
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let level = level {
            try encodeContainer.encode(level.rawValue, forKey: .level)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let levelDecoded = try containerValues.decodeIfPresent(LoggingLevel.self, forKey: .level)
        level = levelDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let detectorDebugOptionsContainer = try containerValues.decodeIfPresent([DetectorDebugOption?].self, forKey: .detectorDebugOptions)
        var detectorDebugOptionsDecoded0:[DetectorDebugOption]? = nil
        if let detectorDebugOptionsContainer = detectorDebugOptionsContainer {
            detectorDebugOptionsDecoded0 = [DetectorDebugOption]()
            for structure0 in detectorDebugOptionsContainer {
                if let structure0 = structure0 {
                    detectorDebugOptionsDecoded0?.append(structure0)
                }
            }
        }
        detectorDebugOptions = detectorDebugOptionsDecoded0
    }
}

extension LoggingOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoggingOptions(detectorDebugOptions: \(String(describing: detectorDebugOptions)), enabled: \(String(describing: enabled)), level: \(String(describing: level)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>The values of the AWS IoT Events logging options.</p>
public struct LoggingOptions: Equatable {
    /// <p>Information that identifies those detector models and their detectors (instances) for
    ///       which the logging level is given.</p>
    public let detectorDebugOptions: [DetectorDebugOption]?
    /// <p>If TRUE, logging is enabled for AWS IoT Events.</p>
    public let enabled: Bool
    /// <p>The logging level.</p>
    public let level: LoggingLevel?
    /// <p>The ARN of the role that grants permission to AWS IoT Events to perform logging.</p>
    public let roleArn: String?

    public init (
        detectorDebugOptions: [DetectorDebugOption]? = nil,
        enabled: Bool = false,
        level: LoggingLevel? = nil,
        roleArn: String? = nil
    )
    {
        self.detectorDebugOptions = detectorDebugOptions
        self.enabled = enabled
        self.level = level
        self.roleArn = roleArn
    }
}

extension NotificationAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action
        case emailConfigurations
        case smsConfigurations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let emailConfigurations = emailConfigurations {
            var emailConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .emailConfigurations)
            for emailconfigurations0 in emailConfigurations {
                try emailConfigurationsContainer.encode(emailconfigurations0)
            }
        }
        if let smsConfigurations = smsConfigurations {
            var smsConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .smsConfigurations)
            for smsconfigurations0 in smsConfigurations {
                try smsConfigurationsContainer.encode(smsconfigurations0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(NotificationTargetActions.self, forKey: .action)
        action = actionDecoded
        let smsConfigurationsContainer = try containerValues.decodeIfPresent([SMSConfiguration?].self, forKey: .smsConfigurations)
        var smsConfigurationsDecoded0:[SMSConfiguration]? = nil
        if let smsConfigurationsContainer = smsConfigurationsContainer {
            smsConfigurationsDecoded0 = [SMSConfiguration]()
            for structure0 in smsConfigurationsContainer {
                if let structure0 = structure0 {
                    smsConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        smsConfigurations = smsConfigurationsDecoded0
        let emailConfigurationsContainer = try containerValues.decodeIfPresent([EmailConfiguration?].self, forKey: .emailConfigurations)
        var emailConfigurationsDecoded0:[EmailConfiguration]? = nil
        if let emailConfigurationsContainer = emailConfigurationsContainer {
            emailConfigurationsDecoded0 = [EmailConfiguration]()
            for structure0 in emailConfigurationsContainer {
                if let structure0 = structure0 {
                    emailConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        emailConfigurations = emailConfigurationsDecoded0
    }
}

extension NotificationAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotificationAction(action: \(String(describing: action)), emailConfigurations: \(String(describing: emailConfigurations)), smsConfigurations: \(String(describing: smsConfigurations)))"}
}

/// <p>Contains the notification settings of an alarm model.
/// The settings apply to all alarms that were created based on this alarm model.</p>
public struct NotificationAction: Equatable {
    /// <p>Specifies an AWS Lambda function to manage alarm notifications.
    /// You can create one or use the <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html">AWS Lambda function provided by AWS IoT Events</a>.</p>
    public let action: NotificationTargetActions?
    /// <p>Contains the configuration information of email notifications.</p>
    public let emailConfigurations: [EmailConfiguration]?
    /// <p>Contains the configuration information of SMS notifications.</p>
    public let smsConfigurations: [SMSConfiguration]?

    public init (
        action: NotificationTargetActions? = nil,
        emailConfigurations: [EmailConfiguration]? = nil,
        smsConfigurations: [SMSConfiguration]? = nil
    )
    {
        self.action = action
        self.emailConfigurations = emailConfigurations
        self.smsConfigurations = smsConfigurations
    }
}

extension NotificationTargetActions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lambdaAction
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaAction = lambdaAction {
            try encodeContainer.encode(lambdaAction, forKey: .lambdaAction)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaActionDecoded = try containerValues.decodeIfPresent(LambdaAction.self, forKey: .lambdaAction)
        lambdaAction = lambdaActionDecoded
    }
}

extension NotificationTargetActions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotificationTargetActions(lambdaAction: \(String(describing: lambdaAction)))"}
}

/// <p>Specifies an AWS Lambda function to manage alarm notifications.
/// You can create one or use the <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html">AWS Lambda function provided by AWS IoT Events</a>.</p>
public struct NotificationTargetActions: Equatable {
    /// <p>Calls a Lambda function, passing in information about the detector model instance and the
    ///       event that triggered the action.</p>
    public let lambdaAction: LambdaAction?

    public init (
        lambdaAction: LambdaAction? = nil
    )
    {
        self.lambdaAction = lambdaAction
    }
}

extension OnEnterLifecycle: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case events
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for events0 in events {
                try eventsContainer.encode(events0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([Event?].self, forKey: .events)
        var eventsDecoded0:[Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension OnEnterLifecycle: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OnEnterLifecycle(events: \(String(describing: events)))"}
}

/// <p>When entering this state, perform these <code>actions</code> if the <code>condition</code>
///       is TRUE.</p>
public struct OnEnterLifecycle: Equatable {
    /// <p>Specifies the actions that are performed when the state is entered and the
    ///         <code>condition</code> is <code>TRUE</code>.</p>
    public let events: [Event]?

    public init (
        events: [Event]? = nil
    )
    {
        self.events = events
    }
}

extension OnExitLifecycle: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case events
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for events0 in events {
                try eventsContainer.encode(events0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([Event?].self, forKey: .events)
        var eventsDecoded0:[Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension OnExitLifecycle: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OnExitLifecycle(events: \(String(describing: events)))"}
}

/// <p>When exiting this state, perform these <code>actions</code> if the specified
///         <code>condition</code> is <code>TRUE</code>.</p>
public struct OnExitLifecycle: Equatable {
    /// <p>Specifies the <code>actions</code> that are performed when the state is exited and the
    ///         <code>condition</code> is <code>TRUE</code>.</p>
    public let events: [Event]?

    public init (
        events: [Event]? = nil
    )
    {
        self.events = events
    }
}

extension OnInputLifecycle: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case events
        case transitionEvents
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for events0 in events {
                try eventsContainer.encode(events0)
            }
        }
        if let transitionEvents = transitionEvents {
            var transitionEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .transitionEvents)
            for transitionevents0 in transitionEvents {
                try transitionEventsContainer.encode(transitionevents0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([Event?].self, forKey: .events)
        var eventsDecoded0:[Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let transitionEventsContainer = try containerValues.decodeIfPresent([TransitionEvent?].self, forKey: .transitionEvents)
        var transitionEventsDecoded0:[TransitionEvent]? = nil
        if let transitionEventsContainer = transitionEventsContainer {
            transitionEventsDecoded0 = [TransitionEvent]()
            for structure0 in transitionEventsContainer {
                if let structure0 = structure0 {
                    transitionEventsDecoded0?.append(structure0)
                }
            }
        }
        transitionEvents = transitionEventsDecoded0
    }
}

extension OnInputLifecycle: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OnInputLifecycle(events: \(String(describing: events)), transitionEvents: \(String(describing: transitionEvents)))"}
}

/// <p>Specifies the actions performed when the <code>condition</code> evaluates to TRUE.</p>
public struct OnInputLifecycle: Equatable {
    /// <p>Specifies the actions performed when the <code>condition</code> evaluates to TRUE.</p>
    public let events: [Event]?
    /// <p>Specifies the actions performed, and the next state entered, when a <code>condition</code>
    ///       evaluates to TRUE.</p>
    public let transitionEvents: [TransitionEvent]?

    public init (
        events: [Event]? = nil,
        transitionEvents: [TransitionEvent]? = nil
    )
    {
        self.events = events
        self.transitionEvents = transitionEvents
    }
}

extension Payload: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentExpression
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentExpression = contentExpression {
            try encodeContainer.encode(contentExpression, forKey: .contentExpression)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentExpression)
        contentExpression = contentExpressionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(PayloadType.self, forKey: .type)
        type = typeDecoded
    }
}

extension Payload: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Payload(contentExpression: \(String(describing: contentExpression)), type: \(String(describing: type)))"}
}

/// <p>Information needed to configure the payload.</p>
///          <p>By default, AWS IoT Events generates a standard payload in JSON for any action. This action payload
///       contains all attribute-value pairs that have the information about the detector model instance
///       and the event triggered the action. To configure the action payload, you can use
///         <code>contentExpression</code>.</p>
public struct Payload: Equatable {
    /// <p>The content of the payload. You can use a string expression that includes quoted strings
    ///         (<code>'<string>'</code>), variables (<code>$variable.<variable-name></code>),
    ///       input values (<code>$input.<input-name>.<path-to-datum></code>), string
    ///       concatenations, and quoted strings that contain <code>${}</code> as the content. The
    ///       recommended maximum size of a content expression is 1 KB.</p>
    public let contentExpression: String?
    /// <p>The value of the payload type can be either <code>STRING</code> or
    ///       <code>JSON</code>.</p>
    public let type: PayloadType?

    public init (
        contentExpression: String? = nil,
        type: PayloadType? = nil
    )
    {
        self.contentExpression = contentExpression
        self.type = type
    }
}

public enum PayloadType {
    case json
    case string
    case sdkUnknown(String)
}

extension PayloadType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PayloadType] {
        return [
            .json,
            .string,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .json: return "JSON"
        case .string: return "STRING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PayloadType(rawValue: rawValue) ?? PayloadType.sdkUnknown(rawValue)
    }
}

public struct PutLoggingOptionsInputBodyMiddleware: Middleware {
    public let id: String = "PutLoggingOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLoggingOptionsInput>
    public typealias MOutput = OperationOutput<PutLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLoggingOptionsOutputError>
}

extension PutLoggingOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutLoggingOptionsInput(loggingOptions: \(String(describing: loggingOptions)))"}
}

extension PutLoggingOptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case loggingOptions
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggingOptions = loggingOptions {
            try encodeContainer.encode(loggingOptions, forKey: .loggingOptions)
        }
    }
}

public struct PutLoggingOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "PutLoggingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLoggingOptionsInput>
    public typealias MOutput = OperationOutput<PutLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLoggingOptionsOutputError>
}

public struct PutLoggingOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutLoggingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLoggingOptionsInput>
    public typealias MOutput = OperationOutput<PutLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLoggingOptionsOutputError>
}

public struct PutLoggingOptionsInput: Equatable {
    /// <p>The new values of the AWS IoT Events logging options.</p>
    public let loggingOptions: LoggingOptions?

    public init (
        loggingOptions: LoggingOptions? = nil
    )
    {
        self.loggingOptions = loggingOptions
    }
}

struct PutLoggingOptionsInputBody: Equatable {
    public let loggingOptions: LoggingOptions?
}

extension PutLoggingOptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loggingOptions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingOptionsDecoded = try containerValues.decodeIfPresent(LoggingOptions.self, forKey: .loggingOptions)
        loggingOptions = loggingOptionsDecoded
    }
}

extension PutLoggingOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLoggingOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutLoggingOptionsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLoggingOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutLoggingOptionsOutputResponse()"}
}

extension PutLoggingOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutLoggingOptionsOutputResponse: Equatable {

    public init() {}
}

struct PutLoggingOptionsOutputResponseBody: Equatable {
}

extension PutLoggingOptionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RecipientDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ssoIdentity
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ssoIdentity = ssoIdentity {
            try encodeContainer.encode(ssoIdentity, forKey: .ssoIdentity)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ssoIdentityDecoded = try containerValues.decodeIfPresent(SSOIdentity.self, forKey: .ssoIdentity)
        ssoIdentity = ssoIdentityDecoded
    }
}

extension RecipientDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecipientDetail(ssoIdentity: \(String(describing: ssoIdentity)))"}
}

/// <p>The information that identifies the recipient.</p>
public struct RecipientDetail: Equatable {
    /// <p>The AWS Single Sign-On (AWS SSO) authentication information.</p>
    public let ssoIdentity: SSOIdentity?

    public init (
        ssoIdentity: SSOIdentity? = nil
    )
    {
        self.ssoIdentity = ssoIdentity
    }
}

extension ResetTimerAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case timerName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timerName = timerName {
            try encodeContainer.encode(timerName, forKey: .timerName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timerName)
        timerName = timerNameDecoded
    }
}

extension ResetTimerAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetTimerAction(timerName: \(String(describing: timerName)))"}
}

/// <p>Information required to reset the timer. The timer is reset to the previously evaluated
///       result of the duration. The duration expression isn't reevaluated when you reset the
///       timer.</p>
public struct ResetTimerAction: Equatable {
    /// <p>The name of the timer to reset.</p>
    public let timerName: String?

    public init (
        timerName: String? = nil
    )
    {
        self.timerName = timerName
    }
}

extension ResourceAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAlreadyExistsException(message: \(String(describing: message)), resourceArn: \(String(describing: resourceArn)), resourceId: \(String(describing: resourceId)))"}
}

extension ResourceAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceArn = output.resourceArn
            self.resourceId = output.resourceId
        } else {
            self.message = nil
            self.resourceArn = nil
            self.resourceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource already exists.</p>
public struct ResourceAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?
    /// <p>The ARN of the resource.</p>
    public var resourceArn: String?
    /// <p>The ID of the resource.</p>
    public var resourceId: String?

    public init (
        message: String? = nil,
        resourceArn: String? = nil,
        resourceId: String? = nil
    )
    {
        self.message = message
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

struct ResourceAlreadyExistsExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceArn: String?
}

extension ResourceAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceArn
        case resourceId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource is in use.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RoutedResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension RoutedResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RoutedResource(arn: \(String(describing: arn)), name: \(String(describing: name)))"}
}

/// <p>
///       Contains information about the routed resource.
///     </p>
public struct RoutedResource: Equatable {
    /// <p>
    ///       The ARN of the routed resource. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.
    ///     </p>
    public let arn: String?
    /// <p>
    ///       The name of the routed resource.
    ///     </p>
    public let name: String?

    public init (
        arn: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

extension SMSConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalMessage
        case recipients
        case senderId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalMessage = additionalMessage {
            try encodeContainer.encode(additionalMessage, forKey: .additionalMessage)
        }
        if let recipients = recipients {
            var recipientsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recipients)
            for recipientdetails0 in recipients {
                try recipientsContainer.encode(recipientdetails0)
            }
        }
        if let senderId = senderId {
            try encodeContainer.encode(senderId, forKey: .senderId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let senderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .senderId)
        senderId = senderIdDecoded
        let additionalMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .additionalMessage)
        additionalMessage = additionalMessageDecoded
        let recipientsContainer = try containerValues.decodeIfPresent([RecipientDetail?].self, forKey: .recipients)
        var recipientsDecoded0:[RecipientDetail]? = nil
        if let recipientsContainer = recipientsContainer {
            recipientsDecoded0 = [RecipientDetail]()
            for structure0 in recipientsContainer {
                if let structure0 = structure0 {
                    recipientsDecoded0?.append(structure0)
                }
            }
        }
        recipients = recipientsDecoded0
    }
}

extension SMSConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SMSConfiguration(additionalMessage: \(String(describing: additionalMessage)), recipients: \(String(describing: recipients)), senderId: \(String(describing: senderId)))"}
}

/// <p>Contains the configuration information of SMS notifications.</p>
public struct SMSConfiguration: Equatable {
    /// <p>The message that you want to send. The message can be up to 200 characters.</p>
    public let additionalMessage: String?
    /// <p>Specifies one or more recipients who receive the message.</p>
    ///          <important>
    ///             <p>You must <a href="https://docs.aws.amazon.com/singlesignon/latest/userguide/addusers.html">add the users that receive SMS messages to your AWS SSO store</a>.</p>
    ///          </important>
    public let recipients: [RecipientDetail]?
    /// <p>The sender ID.</p>
    public let senderId: String?

    public init (
        additionalMessage: String? = nil,
        recipients: [RecipientDetail]? = nil,
        senderId: String? = nil
    )
    {
        self.additionalMessage = additionalMessage
        self.recipients = recipients
        self.senderId = senderId
    }
}

extension SNSTopicPublishAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case payload
        case targetArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payload = payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if let targetArn = targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension SNSTopicPublishAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SNSTopicPublishAction(payload: \(String(describing: payload)), targetArn: \(String(describing: targetArn)))"}
}

/// <p>Information required to publish the Amazon SNS message.</p>
public struct SNSTopicPublishAction: Equatable {
    /// <p>You can configure the action payload when you send a message as an Amazon SNS push
    ///       notification.</p>
    public let payload: Payload?
    /// <p>The ARN of the Amazon SNS target where the message is sent.</p>
    public let targetArn: String?

    public init (
        payload: Payload? = nil,
        targetArn: String? = nil
    )
    {
        self.payload = payload
        self.targetArn = targetArn
    }
}

extension SSOIdentity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityStoreId
        case userId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension SSOIdentity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SSOIdentity(identityStoreId: \(String(describing: identityStoreId)), userId: \(String(describing: userId)))"}
}

/// <p>Contains information about your identity source in AWS Single Sign-On. For more information, see
///       the <a href="https://docs.aws.amazon.com/singlesignon/latest/userguide/what-is.html">AWS Single Sign-On
///         User Guide</a>.</p>
public struct SSOIdentity: Equatable {
    /// <p>The ID of the AWS SSO identity store.</p>
    public let identityStoreId: String?
    /// <p>The user ID.</p>
    public let userId: String?

    public init (
        identityStoreId: String? = nil,
        userId: String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.userId = userId
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service is currently unavailable.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SetTimerAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case durationExpression
        case seconds
        case timerName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationExpression = durationExpression {
            try encodeContainer.encode(durationExpression, forKey: .durationExpression)
        }
        if let seconds = seconds {
            try encodeContainer.encode(seconds, forKey: .seconds)
        }
        if let timerName = timerName {
            try encodeContainer.encode(timerName, forKey: .timerName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timerName)
        timerName = timerNameDecoded
        let secondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .seconds)
        seconds = secondsDecoded
        let durationExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .durationExpression)
        durationExpression = durationExpressionDecoded
    }
}

extension SetTimerAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetTimerAction(durationExpression: \(String(describing: durationExpression)), seconds: \(String(describing: seconds)), timerName: \(String(describing: timerName)))"}
}

/// <p>Information needed to set the timer.</p>
public struct SetTimerAction: Equatable {
    /// <p>The duration of the timer, in seconds. You can use a string expression that includes
    ///       numbers, variables (<code>$variable.<variable-name></code>), and input values
    ///         (<code>$input.<input-name>.<path-to-datum></code>) as the duration. The range of
    ///       the duration is 1-31622400 seconds. To ensure accuracy, the minimum duration is 60 seconds.
    ///       The evaluated result of the duration is rounded down to the nearest whole number. </p>
    public let durationExpression: String?
    /// <p>The number of seconds until the timer expires. The minimum value is 60 seconds to ensure
    ///       accuracy. The maximum value is 31622400 seconds. </p>
    @available(*, deprecated, message: "seconds is deprecated. You can use durationExpression for SetTimerAction. The value of seconds can be used as a string expression for durationExpression.")
    public let seconds: Int?
    /// <p>The name of the timer.</p>
    public let timerName: String?

    public init (
        durationExpression: String? = nil,
        seconds: Int? = nil,
        timerName: String? = nil
    )
    {
        self.durationExpression = durationExpression
        self.seconds = seconds
        self.timerName = timerName
    }
}

extension SetVariableAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case value
        case variableName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
        if let variableName = variableName {
            try encodeContainer.encode(variableName, forKey: .variableName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .variableName)
        variableName = variableNameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SetVariableAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetVariableAction(value: \(String(describing: value)), variableName: \(String(describing: variableName)))"}
}

/// <p>Information about the variable and its new value.</p>
public struct SetVariableAction: Equatable {
    /// <p>The new value of the variable.</p>
    public let value: String?
    /// <p>The name of the variable.</p>
    public let variableName: String?

    public init (
        value: String? = nil,
        variableName: String? = nil
    )
    {
        self.value = value
        self.variableName = variableName
    }
}

extension SimpleRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comparisonOperator
        case inputProperty
        case threshold
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let inputProperty = inputProperty {
            try encodeContainer.encode(inputProperty, forKey: .inputProperty)
        }
        if let threshold = threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputPropertyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputProperty)
        inputProperty = inputPropertyDecoded
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .threshold)
        threshold = thresholdDecoded
    }
}

extension SimpleRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SimpleRule(comparisonOperator: \(String(describing: comparisonOperator)), inputProperty: \(String(describing: inputProperty)), threshold: \(String(describing: threshold)))"}
}

/// <p>A rule that compares an input property value to a threshold value with a comparison operator.</p>
public struct SimpleRule: Equatable {
    /// <p>The comparison operator.</p>
    public let comparisonOperator: ComparisonOperator?
    /// <p>The value on the left side of the comparison operator. You can specify an AWS IoT Events input
    ///       attribute as an input property.</p>
    public let inputProperty: String?
    /// <p>The value on the right side of the comparison operator. You can enter a number or specify
    ///       an AWS IoT Events input attribute.</p>
    public let threshold: String?

    public init (
        comparisonOperator: ComparisonOperator? = nil,
        inputProperty: String? = nil,
        threshold: String? = nil
    )
    {
        self.comparisonOperator = comparisonOperator
        self.inputProperty = inputProperty
        self.threshold = threshold
    }
}

extension SqsAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case payload
        case queueUrl
        case useBase64
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payload = payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if let queueUrl = queueUrl {
            try encodeContainer.encode(queueUrl, forKey: .queueUrl)
        }
        if let useBase64 = useBase64 {
            try encodeContainer.encode(useBase64, forKey: .useBase64)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queueUrl)
        queueUrl = queueUrlDecoded
        let useBase64Decoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useBase64)
        useBase64 = useBase64Decoded
        let payloadDecoded = try containerValues.decodeIfPresent(Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension SqsAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SqsAction(payload: \(String(describing: payload)), queueUrl: \(String(describing: queueUrl)), useBase64: \(String(describing: useBase64)))"}
}

/// <p>Sends information about the detector model instance and the event that triggered the
///       action to an Amazon SQS queue.</p>
public struct SqsAction: Equatable {
    /// <p>You can configure the action payload when you send a message to an Amazon SQS
    ///       queue.</p>
    public let payload: Payload?
    /// <p>The URL of the SQS queue where the data is written.</p>
    public let queueUrl: String?
    /// <p>Set this to TRUE if you want the data to be base-64 encoded before it is written to the
    ///       queue. Otherwise, set this to FALSE.</p>
    public let useBase64: Bool?

    public init (
        payload: Payload? = nil,
        queueUrl: String? = nil,
        useBase64: Bool? = nil
    )
    {
        self.payload = payload
        self.queueUrl = queueUrl
        self.useBase64 = useBase64
    }
}

public struct StartDetectorModelAnalysisInputBodyMiddleware: Middleware {
    public let id: String = "StartDetectorModelAnalysisInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDetectorModelAnalysisInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDetectorModelAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDetectorModelAnalysisInput>
    public typealias MOutput = OperationOutput<StartDetectorModelAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDetectorModelAnalysisOutputError>
}

extension StartDetectorModelAnalysisInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDetectorModelAnalysisInput(detectorModelDefinition: \(String(describing: detectorModelDefinition)))"}
}

extension StartDetectorModelAnalysisInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detectorModelDefinition
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorModelDefinition = detectorModelDefinition {
            try encodeContainer.encode(detectorModelDefinition, forKey: .detectorModelDefinition)
        }
    }
}

public struct StartDetectorModelAnalysisInputHeadersMiddleware: Middleware {
    public let id: String = "StartDetectorModelAnalysisInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDetectorModelAnalysisInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDetectorModelAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDetectorModelAnalysisInput>
    public typealias MOutput = OperationOutput<StartDetectorModelAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDetectorModelAnalysisOutputError>
}

public struct StartDetectorModelAnalysisInputQueryItemMiddleware: Middleware {
    public let id: String = "StartDetectorModelAnalysisInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDetectorModelAnalysisInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDetectorModelAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDetectorModelAnalysisInput>
    public typealias MOutput = OperationOutput<StartDetectorModelAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDetectorModelAnalysisOutputError>
}

public struct StartDetectorModelAnalysisInput: Equatable {
    /// <p>Information that defines how a detector operates.</p>
    public let detectorModelDefinition: DetectorModelDefinition?

    public init (
        detectorModelDefinition: DetectorModelDefinition? = nil
    )
    {
        self.detectorModelDefinition = detectorModelDefinition
    }
}

struct StartDetectorModelAnalysisInputBody: Equatable {
    public let detectorModelDefinition: DetectorModelDefinition?
}

extension StartDetectorModelAnalysisInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectorModelDefinition
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelDefinitionDecoded = try containerValues.decodeIfPresent(DetectorModelDefinition.self, forKey: .detectorModelDefinition)
        detectorModelDefinition = detectorModelDefinitionDecoded
    }
}

extension StartDetectorModelAnalysisOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDetectorModelAnalysisOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDetectorModelAnalysisOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDetectorModelAnalysisOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDetectorModelAnalysisOutputResponse(analysisId: \(String(describing: analysisId)))"}
}

extension StartDetectorModelAnalysisOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartDetectorModelAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.analysisId = output.analysisId
        } else {
            self.analysisId = nil
        }
    }
}

public struct StartDetectorModelAnalysisOutputResponse: Equatable {
    /// <p>The ID that you can use to retrieve the analysis result.</p>
    public let analysisId: String?

    public init (
        analysisId: String? = nil
    )
    {
        self.analysisId = analysisId
    }
}

struct StartDetectorModelAnalysisOutputResponseBody: Equatable {
    public let analysisId: String?
}

extension StartDetectorModelAnalysisOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analysisId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
    }
}

extension State: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case onEnter
        case onExit
        case onInput
        case stateName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let onEnter = onEnter {
            try encodeContainer.encode(onEnter, forKey: .onEnter)
        }
        if let onExit = onExit {
            try encodeContainer.encode(onExit, forKey: .onExit)
        }
        if let onInput = onInput {
            try encodeContainer.encode(onInput, forKey: .onInput)
        }
        if let stateName = stateName {
            try encodeContainer.encode(stateName, forKey: .stateName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateName)
        stateName = stateNameDecoded
        let onInputDecoded = try containerValues.decodeIfPresent(OnInputLifecycle.self, forKey: .onInput)
        onInput = onInputDecoded
        let onEnterDecoded = try containerValues.decodeIfPresent(OnEnterLifecycle.self, forKey: .onEnter)
        onEnter = onEnterDecoded
        let onExitDecoded = try containerValues.decodeIfPresent(OnExitLifecycle.self, forKey: .onExit)
        onExit = onExitDecoded
    }
}

extension State: CustomDebugStringConvertible {
    public var debugDescription: String {
        "State(onEnter: \(String(describing: onEnter)), onExit: \(String(describing: onExit)), onInput: \(String(describing: onInput)), stateName: \(String(describing: stateName)))"}
}

/// <p>Information that defines a state of a detector.</p>
public struct State: Equatable {
    /// <p>When entering this state, perform these <code>actions</code> if the <code>condition</code>
    ///       is TRUE.</p>
    public let onEnter: OnEnterLifecycle?
    /// <p>When exiting this state, perform these <code>actions</code> if the specified
    ///         <code>condition</code> is <code>TRUE</code>.</p>
    public let onExit: OnExitLifecycle?
    /// <p>When an input is received and the <code>condition</code> is TRUE, perform the specified
    ///         <code>actions</code>.</p>
    public let onInput: OnInputLifecycle?
    /// <p>The name of the state.</p>
    public let stateName: String?

    public init (
        onEnter: OnEnterLifecycle? = nil,
        onExit: OnExitLifecycle? = nil,
        onInput: OnInputLifecycle? = nil,
        stateName: String? = nil
    )
    {
        self.onEnter = onEnter
        self.onExit = onExit
        self.onInput = onInput
        self.stateName = stateName
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Metadata that can be used to manage the resource.</p>
public struct Tag: Equatable {
    /// <p>The tag's key.</p>
    public let key: String?
    /// <p>The tag's value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The ARN of the resource.</p>
    public let resourceArn: String?
    /// <p>The new or modified tags for the resource.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request could not be completed due to throttling.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TransitionEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions
        case condition
        case eventName
        case nextState
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actions0 in actions {
                try actionsContainer.encode(actions0)
            }
        }
        if let condition = condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let eventName = eventName {
            try encodeContainer.encode(eventName, forKey: .eventName)
        }
        if let nextState = nextState {
            try encodeContainer.encode(nextState, forKey: .nextState)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventName)
        eventName = eventNameDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .condition)
        condition = conditionDecoded
        let actionsContainer = try containerValues.decodeIfPresent([Action?].self, forKey: .actions)
        var actionsDecoded0:[Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let nextStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextState)
        nextState = nextStateDecoded
    }
}

extension TransitionEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TransitionEvent(actions: \(String(describing: actions)), condition: \(String(describing: condition)), eventName: \(String(describing: eventName)), nextState: \(String(describing: nextState)))"}
}

/// <p>Specifies the actions performed and the next state entered when a <code>condition</code>
///       evaluates to TRUE.</p>
public struct TransitionEvent: Equatable {
    /// <p>The actions to be performed.</p>
    public let actions: [Action]?
    /// <p>Required. A Boolean expression that when TRUE causes the actions to be performed and the
    ///         <code>nextState</code> to be entered.</p>
    public let condition: String?
    /// <p>The name of the transition event.</p>
    public let eventName: String?
    /// <p>The next state to enter.</p>
    public let nextState: String?

    public init (
        actions: [Action]? = nil,
        condition: String? = nil,
        eventName: String? = nil,
        nextState: String? = nil
    )
    {
        self.actions = actions
        self.condition = condition
        self.eventName = eventName
        self.nextState = nextState
    }
}

extension UnsupportedOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedOperationException(message: \(String(describing: message)))"}
}

extension UnsupportedOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested operation is not supported.</p>
public struct UnsupportedOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The ARN of the resource.</p>
    public let resourceArn: String?
    /// <p>A list of the keys of the tags to be removed from the resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAlarmModelInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAlarmModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAlarmModelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAlarmModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAlarmModelInput>
    public typealias MOutput = OperationOutput<UpdateAlarmModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAlarmModelOutputError>
}

extension UpdateAlarmModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAlarmModelInput(alarmCapabilities: \(String(describing: alarmCapabilities)), alarmEventActions: \(String(describing: alarmEventActions)), alarmModelDescription: \(String(describing: alarmModelDescription)), alarmModelName: \(String(describing: alarmModelName)), alarmNotification: \(String(describing: alarmNotification)), alarmRule: \(String(describing: alarmRule)), roleArn: \(String(describing: roleArn)), severity: \(String(describing: severity)))"}
}

extension UpdateAlarmModelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alarmCapabilities
        case alarmEventActions
        case alarmModelDescription
        case alarmNotification
        case alarmRule
        case roleArn
        case severity
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmCapabilities = alarmCapabilities {
            try encodeContainer.encode(alarmCapabilities, forKey: .alarmCapabilities)
        }
        if let alarmEventActions = alarmEventActions {
            try encodeContainer.encode(alarmEventActions, forKey: .alarmEventActions)
        }
        if let alarmModelDescription = alarmModelDescription {
            try encodeContainer.encode(alarmModelDescription, forKey: .alarmModelDescription)
        }
        if let alarmNotification = alarmNotification {
            try encodeContainer.encode(alarmNotification, forKey: .alarmNotification)
        }
        if let alarmRule = alarmRule {
            try encodeContainer.encode(alarmRule, forKey: .alarmRule)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
    }
}

public struct UpdateAlarmModelInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAlarmModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAlarmModelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAlarmModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAlarmModelInput>
    public typealias MOutput = OperationOutput<UpdateAlarmModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAlarmModelOutputError>
}

public struct UpdateAlarmModelInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAlarmModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAlarmModelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAlarmModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAlarmModelInput>
    public typealias MOutput = OperationOutput<UpdateAlarmModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAlarmModelOutputError>
}

public struct UpdateAlarmModelInput: Equatable {
    /// <p>Contains the configuration information of alarm state changes.</p>
    public let alarmCapabilities: AlarmCapabilities?
    /// <p>Contains information about one or more alarm actions.</p>
    public let alarmEventActions: AlarmEventActions?
    /// <p>The description of the alarm model.</p>
    public let alarmModelDescription: String?
    /// <p>The name of the alarm model.</p>
    public let alarmModelName: String?
    /// <p>Contains information about one or more notification actions.</p>
    public let alarmNotification: AlarmNotification?
    /// <p>Defines when your alarm is invoked.</p>
    public let alarmRule: AlarmRule?
    /// <p>The ARN of the IAM role that allows the alarm to perform actions and access AWS resources. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let roleArn: String?
    /// <p>A non-negative integer that reflects the severity level of the alarm.</p>
    public let severity: Int?

    public init (
        alarmCapabilities: AlarmCapabilities? = nil,
        alarmEventActions: AlarmEventActions? = nil,
        alarmModelDescription: String? = nil,
        alarmModelName: String? = nil,
        alarmNotification: AlarmNotification? = nil,
        alarmRule: AlarmRule? = nil,
        roleArn: String? = nil,
        severity: Int? = nil
    )
    {
        self.alarmCapabilities = alarmCapabilities
        self.alarmEventActions = alarmEventActions
        self.alarmModelDescription = alarmModelDescription
        self.alarmModelName = alarmModelName
        self.alarmNotification = alarmNotification
        self.alarmRule = alarmRule
        self.roleArn = roleArn
        self.severity = severity
    }
}

struct UpdateAlarmModelInputBody: Equatable {
    public let alarmModelDescription: String?
    public let roleArn: String?
    public let severity: Int?
    public let alarmRule: AlarmRule?
    public let alarmNotification: AlarmNotification?
    public let alarmEventActions: AlarmEventActions?
    public let alarmCapabilities: AlarmCapabilities?
}

extension UpdateAlarmModelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alarmCapabilities
        case alarmEventActions
        case alarmModelDescription
        case alarmNotification
        case alarmRule
        case roleArn
        case severity
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmModelDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelDescription)
        alarmModelDescription = alarmModelDescriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .severity)
        severity = severityDecoded
        let alarmRuleDecoded = try containerValues.decodeIfPresent(AlarmRule.self, forKey: .alarmRule)
        alarmRule = alarmRuleDecoded
        let alarmNotificationDecoded = try containerValues.decodeIfPresent(AlarmNotification.self, forKey: .alarmNotification)
        alarmNotification = alarmNotificationDecoded
        let alarmEventActionsDecoded = try containerValues.decodeIfPresent(AlarmEventActions.self, forKey: .alarmEventActions)
        alarmEventActions = alarmEventActionsDecoded
        let alarmCapabilitiesDecoded = try containerValues.decodeIfPresent(AlarmCapabilities.self, forKey: .alarmCapabilities)
        alarmCapabilities = alarmCapabilitiesDecoded
    }
}

extension UpdateAlarmModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAlarmModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAlarmModelOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAlarmModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAlarmModelOutputResponse(alarmModelArn: \(String(describing: alarmModelArn)), alarmModelVersion: \(String(describing: alarmModelVersion)), creationTime: \(String(describing: creationTime)), lastUpdateTime: \(String(describing: lastUpdateTime)), status: \(String(describing: status)))"}
}

extension UpdateAlarmModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAlarmModelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.alarmModelArn = output.alarmModelArn
            self.alarmModelVersion = output.alarmModelVersion
            self.creationTime = output.creationTime
            self.lastUpdateTime = output.lastUpdateTime
            self.status = output.status
        } else {
            self.alarmModelArn = nil
            self.alarmModelVersion = nil
            self.creationTime = nil
            self.lastUpdateTime = nil
            self.status = nil
        }
    }
}

public struct UpdateAlarmModelOutputResponse: Equatable {
    /// <p>The ARN of the alarm model. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let alarmModelArn: String?
    /// <p>The version of the alarm model.</p>
    public let alarmModelVersion: String?
    /// <p>The time the alarm model was created, in the Unix epoch format.</p>
    public let creationTime: Date?
    /// <p>The time the alarm model was last updated, in the Unix epoch format.</p>
    public let lastUpdateTime: Date?
    /// <p>The status of the alarm model. The status can be one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code> - The alarm model is active and it's ready to evaluate data.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVATING</code> - AWS IoT Events is activating your alarm model.
    ///         Activating an alarm model can take up to a few minutes.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INACTIVE</code> - The alarm model is inactive, so it isn't ready to evaluate data.
    /// 	  Check your alarm model information and update the alarm model.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code> - You couldn't create or update the alarm model. Check your alarm model information
    ///         and try again.</p>
    ///             </li>
    ///          </ul>
    public let status: AlarmModelVersionStatus?

    public init (
        alarmModelArn: String? = nil,
        alarmModelVersion: String? = nil,
        creationTime: Date? = nil,
        lastUpdateTime: Date? = nil,
        status: AlarmModelVersionStatus? = nil
    )
    {
        self.alarmModelArn = alarmModelArn
        self.alarmModelVersion = alarmModelVersion
        self.creationTime = creationTime
        self.lastUpdateTime = lastUpdateTime
        self.status = status
    }
}

struct UpdateAlarmModelOutputResponseBody: Equatable {
    public let creationTime: Date?
    public let alarmModelArn: String?
    public let alarmModelVersion: String?
    public let lastUpdateTime: Date?
    public let status: AlarmModelVersionStatus?
}

extension UpdateAlarmModelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alarmModelArn
        case alarmModelVersion
        case creationTime
        case lastUpdateTime
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let alarmModelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelArn)
        alarmModelArn = alarmModelArnDecoded
        let alarmModelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmModelVersion)
        alarmModelVersion = alarmModelVersionDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AlarmModelVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct UpdateDetectorModelInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDetectorModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDetectorModelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDetectorModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDetectorModelInput>
    public typealias MOutput = OperationOutput<UpdateDetectorModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDetectorModelOutputError>
}

extension UpdateDetectorModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDetectorModelInput(detectorModelDefinition: \(String(describing: detectorModelDefinition)), detectorModelDescription: \(String(describing: detectorModelDescription)), detectorModelName: \(String(describing: detectorModelName)), evaluationMethod: \(String(describing: evaluationMethod)), roleArn: \(String(describing: roleArn)))"}
}

extension UpdateDetectorModelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detectorModelDefinition
        case detectorModelDescription
        case evaluationMethod
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorModelDefinition = detectorModelDefinition {
            try encodeContainer.encode(detectorModelDefinition, forKey: .detectorModelDefinition)
        }
        if let detectorModelDescription = detectorModelDescription {
            try encodeContainer.encode(detectorModelDescription, forKey: .detectorModelDescription)
        }
        if let evaluationMethod = evaluationMethod {
            try encodeContainer.encode(evaluationMethod.rawValue, forKey: .evaluationMethod)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct UpdateDetectorModelInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDetectorModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDetectorModelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDetectorModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDetectorModelInput>
    public typealias MOutput = OperationOutput<UpdateDetectorModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDetectorModelOutputError>
}

public struct UpdateDetectorModelInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDetectorModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDetectorModelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDetectorModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDetectorModelInput>
    public typealias MOutput = OperationOutput<UpdateDetectorModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDetectorModelOutputError>
}

public struct UpdateDetectorModelInput: Equatable {
    /// <p>Information that defines how a detector operates.</p>
    public let detectorModelDefinition: DetectorModelDefinition?
    /// <p>A brief description of the detector model.</p>
    public let detectorModelDescription: String?
    /// <p>The name of the detector model that is updated.</p>
    public let detectorModelName: String?
    /// <p>Information about the order in which events are evaluated and how actions are executed.
    ///     </p>
    public let evaluationMethod: EvaluationMethod?
    /// <p>The ARN of the role that grants permission to AWS IoT Events to perform its operations.</p>
    public let roleArn: String?

    public init (
        detectorModelDefinition: DetectorModelDefinition? = nil,
        detectorModelDescription: String? = nil,
        detectorModelName: String? = nil,
        evaluationMethod: EvaluationMethod? = nil,
        roleArn: String? = nil
    )
    {
        self.detectorModelDefinition = detectorModelDefinition
        self.detectorModelDescription = detectorModelDescription
        self.detectorModelName = detectorModelName
        self.evaluationMethod = evaluationMethod
        self.roleArn = roleArn
    }
}

struct UpdateDetectorModelInputBody: Equatable {
    public let detectorModelDefinition: DetectorModelDefinition?
    public let detectorModelDescription: String?
    public let roleArn: String?
    public let evaluationMethod: EvaluationMethod?
}

extension UpdateDetectorModelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectorModelDefinition
        case detectorModelDescription
        case evaluationMethod
        case roleArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelDefinitionDecoded = try containerValues.decodeIfPresent(DetectorModelDefinition.self, forKey: .detectorModelDefinition)
        detectorModelDefinition = detectorModelDefinitionDecoded
        let detectorModelDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorModelDescription)
        detectorModelDescription = detectorModelDescriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let evaluationMethodDecoded = try containerValues.decodeIfPresent(EvaluationMethod.self, forKey: .evaluationMethod)
        evaluationMethod = evaluationMethodDecoded
    }
}

extension UpdateDetectorModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDetectorModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDetectorModelOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDetectorModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDetectorModelOutputResponse(detectorModelConfiguration: \(String(describing: detectorModelConfiguration)))"}
}

extension UpdateDetectorModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDetectorModelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.detectorModelConfiguration = output.detectorModelConfiguration
        } else {
            self.detectorModelConfiguration = nil
        }
    }
}

public struct UpdateDetectorModelOutputResponse: Equatable {
    /// <p>Information about how the detector model is configured.</p>
    public let detectorModelConfiguration: DetectorModelConfiguration?

    public init (
        detectorModelConfiguration: DetectorModelConfiguration? = nil
    )
    {
        self.detectorModelConfiguration = detectorModelConfiguration
    }
}

struct UpdateDetectorModelOutputResponseBody: Equatable {
    public let detectorModelConfiguration: DetectorModelConfiguration?
}

extension UpdateDetectorModelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectorModelConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelConfigurationDecoded = try containerValues.decodeIfPresent(DetectorModelConfiguration.self, forKey: .detectorModelConfiguration)
        detectorModelConfiguration = detectorModelConfigurationDecoded
    }
}

public struct UpdateInputInputBodyMiddleware: Middleware {
    public let id: String = "UpdateInputInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInputInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInputInput>
    public typealias MOutput = OperationOutput<UpdateInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInputOutputError>
}

extension UpdateInputInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateInputInput(inputDefinition: \(String(describing: inputDefinition)), inputDescription: \(String(describing: inputDescription)), inputName: \(String(describing: inputName)))"}
}

extension UpdateInputInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputDefinition
        case inputDescription
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputDefinition = inputDefinition {
            try encodeContainer.encode(inputDefinition, forKey: .inputDefinition)
        }
        if let inputDescription = inputDescription {
            try encodeContainer.encode(inputDescription, forKey: .inputDescription)
        }
    }
}

public struct UpdateInputInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateInputInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInputInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInputInput>
    public typealias MOutput = OperationOutput<UpdateInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInputOutputError>
}

public struct UpdateInputInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateInputInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInputInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInputInput>
    public typealias MOutput = OperationOutput<UpdateInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInputOutputError>
}

public struct UpdateInputInput: Equatable {
    /// <p>The definition of the input.</p>
    public let inputDefinition: InputDefinition?
    /// <p>A brief description of the input.</p>
    public let inputDescription: String?
    /// <p>The name of the input you want to update.</p>
    public let inputName: String?

    public init (
        inputDefinition: InputDefinition? = nil,
        inputDescription: String? = nil,
        inputName: String? = nil
    )
    {
        self.inputDefinition = inputDefinition
        self.inputDescription = inputDescription
        self.inputName = inputName
    }
}

struct UpdateInputInputBody: Equatable {
    public let inputDescription: String?
    public let inputDefinition: InputDefinition?
}

extension UpdateInputInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inputDefinition
        case inputDescription
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputDescription)
        inputDescription = inputDescriptionDecoded
        let inputDefinitionDecoded = try containerValues.decodeIfPresent(InputDefinition.self, forKey: .inputDefinition)
        inputDefinition = inputDefinitionDecoded
    }
}

extension UpdateInputOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInputOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateInputOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInputOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateInputOutputResponse(inputConfiguration: \(String(describing: inputConfiguration)))"}
}

extension UpdateInputOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateInputOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.inputConfiguration = output.inputConfiguration
        } else {
            self.inputConfiguration = nil
        }
    }
}

public struct UpdateInputOutputResponse: Equatable {
    /// <p>Information about the configuration of the input.</p>
    public let inputConfiguration: InputConfiguration?

    public init (
        inputConfiguration: InputConfiguration? = nil
    )
    {
        self.inputConfiguration = inputConfiguration
    }
}

struct UpdateInputOutputResponseBody: Equatable {
    public let inputConfiguration: InputConfiguration?
}

extension UpdateInputOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inputConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputConfigurationDecoded = try containerValues.decodeIfPresent(InputConfiguration.self, forKey: .inputConfiguration)
        inputConfiguration = inputConfigurationDecoded
    }
}
