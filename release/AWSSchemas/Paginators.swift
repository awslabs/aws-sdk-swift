// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[ListDiscoverersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDiscoverersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDiscoverersOutputResponse`
extension SchemasClient {
    public func listDiscoverersPaginated(input: ListDiscoverersInput) -> ClientRuntime.PaginatorSequence<ListDiscoverersInput, ListDiscoverersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDiscoverersInput, ListDiscoverersOutputResponse>(input: input, inputKey: \ListDiscoverersInput.nextToken, outputKey: \ListDiscoverersOutputResponse.nextToken, paginationFunction: self.listDiscoverers(input:))
    }
}

extension ListDiscoverersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDiscoverersInput {
        return ListDiscoverersInput(
            discovererIdPrefix: self.discovererIdPrefix,
            limit: self.limit,
            nextToken: token,
            sourceArnPrefix: self.sourceArnPrefix
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listDiscoverersPaginated`
/// to access the nested member `[SchemasClientTypes.DiscovererSummary]`
/// - Returns: `[SchemasClientTypes.DiscovererSummary]`
extension PaginatorSequence where Input == ListDiscoverersInput, Output == ListDiscoverersOutputResponse {
    func discoverers() async throws -> [SchemasClientTypes.DiscovererSummary] {
        return try await self.asyncCompactMap { item in item.discoverers }
    }
}

/// Paginate over `[ListRegistriesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListRegistriesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListRegistriesOutputResponse`
extension SchemasClient {
    public func listRegistriesPaginated(input: ListRegistriesInput) -> ClientRuntime.PaginatorSequence<ListRegistriesInput, ListRegistriesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListRegistriesInput, ListRegistriesOutputResponse>(input: input, inputKey: \ListRegistriesInput.nextToken, outputKey: \ListRegistriesOutputResponse.nextToken, paginationFunction: self.listRegistries(input:))
    }
}

extension ListRegistriesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRegistriesInput {
        return ListRegistriesInput(
            limit: self.limit,
            nextToken: token,
            registryNamePrefix: self.registryNamePrefix,
            scope: self.scope
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listRegistriesPaginated`
/// to access the nested member `[SchemasClientTypes.RegistrySummary]`
/// - Returns: `[SchemasClientTypes.RegistrySummary]`
extension PaginatorSequence where Input == ListRegistriesInput, Output == ListRegistriesOutputResponse {
    func registries() async throws -> [SchemasClientTypes.RegistrySummary] {
        return try await self.asyncCompactMap { item in item.registries }
    }
}

/// Paginate over `[ListSchemasOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListSchemasInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListSchemasOutputResponse`
extension SchemasClient {
    public func listSchemasPaginated(input: ListSchemasInput) -> ClientRuntime.PaginatorSequence<ListSchemasInput, ListSchemasOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSchemasInput, ListSchemasOutputResponse>(input: input, inputKey: \ListSchemasInput.nextToken, outputKey: \ListSchemasOutputResponse.nextToken, paginationFunction: self.listSchemas(input:))
    }
}

extension ListSchemasInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSchemasInput {
        return ListSchemasInput(
            limit: self.limit,
            nextToken: token,
            registryName: self.registryName,
            schemaNamePrefix: self.schemaNamePrefix
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listSchemasPaginated`
/// to access the nested member `[SchemasClientTypes.SchemaSummary]`
/// - Returns: `[SchemasClientTypes.SchemaSummary]`
extension PaginatorSequence where Input == ListSchemasInput, Output == ListSchemasOutputResponse {
    func schemas() async throws -> [SchemasClientTypes.SchemaSummary] {
        return try await self.asyncCompactMap { item in item.schemas }
    }
}

/// Paginate over `[ListSchemaVersionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListSchemaVersionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListSchemaVersionsOutputResponse`
extension SchemasClient {
    public func listSchemaVersionsPaginated(input: ListSchemaVersionsInput) -> ClientRuntime.PaginatorSequence<ListSchemaVersionsInput, ListSchemaVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSchemaVersionsInput, ListSchemaVersionsOutputResponse>(input: input, inputKey: \ListSchemaVersionsInput.nextToken, outputKey: \ListSchemaVersionsOutputResponse.nextToken, paginationFunction: self.listSchemaVersions(input:))
    }
}

extension ListSchemaVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSchemaVersionsInput {
        return ListSchemaVersionsInput(
            limit: self.limit,
            nextToken: token,
            registryName: self.registryName,
            schemaName: self.schemaName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listSchemaVersionsPaginated`
/// to access the nested member `[SchemasClientTypes.SchemaVersionSummary]`
/// - Returns: `[SchemasClientTypes.SchemaVersionSummary]`
extension PaginatorSequence where Input == ListSchemaVersionsInput, Output == ListSchemaVersionsOutputResponse {
    func schemaVersions() async throws -> [SchemasClientTypes.SchemaVersionSummary] {
        return try await self.asyncCompactMap { item in item.schemaVersions }
    }
}

/// Paginate over `[SearchSchemasOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[SearchSchemasInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `SearchSchemasOutputResponse`
extension SchemasClient {
    public func searchSchemasPaginated(input: SearchSchemasInput) -> ClientRuntime.PaginatorSequence<SearchSchemasInput, SearchSchemasOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchSchemasInput, SearchSchemasOutputResponse>(input: input, inputKey: \SearchSchemasInput.nextToken, outputKey: \SearchSchemasOutputResponse.nextToken, paginationFunction: self.searchSchemas(input:))
    }
}

extension SearchSchemasInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchSchemasInput {
        return SearchSchemasInput(
            keywords: self.keywords,
            limit: self.limit,
            nextToken: token,
            registryName: self.registryName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `searchSchemasPaginated`
/// to access the nested member `[SchemasClientTypes.SearchSchemaSummary]`
/// - Returns: `[SchemasClientTypes.SearchSchemaSummary]`
extension PaginatorSequence where Input == SearchSchemasInput, Output == SearchSchemasOutputResponse {
    func schemas() async throws -> [SchemasClientTypes.SearchSchemaSummary] {
        return try await self.asyncCompactMap { item in item.schemas }
    }
}
