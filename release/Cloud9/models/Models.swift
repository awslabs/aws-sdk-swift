// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(className: \(String(describing: className)), code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.className = output.className
            self.code = output.code
            self.message = output.message
        } else {
            self.className = nil
            self.code = 0
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The target request is invalid.</p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var className: String?
    public var code: Int
    public var message: String?

    public init (
        className: String? = nil,
        code: Int = 0,
        message: String? = nil
    )
    {
        self.className = className
        self.code = code
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
    public let className: String?
    public let code: Int
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case className
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let classNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .className)
        className = classNameDecoded
        let codeDecoded = try containerValues.decode(Int.self, forKey: .code)
        code = codeDecoded
    }
}

extension ConcurrentAccessException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentAccessException(className: \(String(describing: className)), code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension ConcurrentAccessException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentAccessExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.className = output.className
            self.code = output.code
            self.message = output.message
        } else {
            self.className = nil
            self.code = 0
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A concurrent access issue occurred.</p>
public struct ConcurrentAccessException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var className: String?
    public var code: Int
    public var message: String?

    public init (
        className: String? = nil,
        code: Int = 0,
        message: String? = nil
    )
    {
        self.className = className
        self.code = code
        self.message = message
    }
}

struct ConcurrentAccessExceptionBody: Equatable {
    public let message: String?
    public let className: String?
    public let code: Int
}

extension ConcurrentAccessExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case className
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let classNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .className)
        className = classNameDecoded
        let codeDecoded = try containerValues.decode(Int.self, forKey: .code)
        code = codeDecoded
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(className: \(String(describing: className)), code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.className = output.className
            self.code = output.code
            self.message = output.message
        } else {
            self.className = nil
            self.code = 0
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A conflict occurred.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var className: String?
    public var code: Int
    public var message: String?

    public init (
        className: String? = nil,
        code: Int = 0,
        message: String? = nil
    )
    {
        self.className = className
        self.code = code
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
    public let className: String?
    public let code: Int
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case className
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let classNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .className)
        className = classNameDecoded
        let codeDecoded = try containerValues.decode(Int.self, forKey: .code)
        code = codeDecoded
    }
}

public enum ConnectionType {
    case connectSsh
    case connectSsm
    case sdkUnknown(String)
}

extension ConnectionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectionType] {
        return [
            .connectSsh,
            .connectSsm,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .connectSsh: return "CONNECT_SSH"
        case .connectSsm: return "CONNECT_SSM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectionType(rawValue: rawValue) ?? ConnectionType.sdkUnknown(rawValue)
    }
}

public struct CreateEnvironmentEC2InputBodyMiddleware: Middleware {
    public let id: String = "CreateEnvironmentEC2InputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEnvironmentEC2Input>,
                  next: H) -> Swift.Result<OperationOutput<CreateEnvironmentEC2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEnvironmentEC2Input>
    public typealias MOutput = OperationOutput<CreateEnvironmentEC2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEnvironmentEC2OutputError>
}

extension CreateEnvironmentEC2Input: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEnvironmentEC2Input(automaticStopTimeMinutes: \(String(describing: automaticStopTimeMinutes)), clientRequestToken: \(String(describing: clientRequestToken)), connectionType: \(String(describing: connectionType)), description: \(String(describing: description)), imageId: \(String(describing: imageId)), instanceType: \(String(describing: instanceType)), name: \(String(describing: name)), ownerArn: \(String(describing: ownerArn)), subnetId: \(String(describing: subnetId)), tags: \(String(describing: tags)))"}
}

extension CreateEnvironmentEC2Input: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case automaticStopTimeMinutes
        case clientRequestToken
        case connectionType
        case description
        case imageId
        case instanceType
        case name
        case ownerArn
        case subnetId
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automaticStopTimeMinutes = automaticStopTimeMinutes {
            try encodeContainer.encode(automaticStopTimeMinutes, forKey: .automaticStopTimeMinutes)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let connectionType = connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerArn = ownerArn {
            try encodeContainer.encode(ownerArn, forKey: .ownerArn)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateEnvironmentEC2InputHeadersMiddleware: Middleware {
    public let id: String = "CreateEnvironmentEC2InputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEnvironmentEC2Input>,
                  next: H) -> Swift.Result<OperationOutput<CreateEnvironmentEC2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEnvironmentEC2Input>
    public typealias MOutput = OperationOutput<CreateEnvironmentEC2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEnvironmentEC2OutputError>
}

public struct CreateEnvironmentEC2InputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEnvironmentEC2InputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEnvironmentEC2Input>,
                  next: H) -> Swift.Result<OperationOutput<CreateEnvironmentEC2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEnvironmentEC2Input>
    public typealias MOutput = OperationOutput<CreateEnvironmentEC2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEnvironmentEC2OutputError>
}

public struct CreateEnvironmentEC2Input: Equatable {
    /// <p>The number of minutes until the running instance is shut down after the environment has last been used.</p>
    public let automaticStopTimeMinutes: Int?
    /// <p>A unique, case-sensitive string that helps AWS Cloud9 to ensure this operation completes no more than one time.</p>
    ///          <p>For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Client Tokens</a> in the <i>Amazon EC2 API Reference</i>.</p>
    public let clientRequestToken: String?
    /// <p>The connection type used for connecting to an Amazon EC2 environment. Valid values are <code>CONNECT_SSH</code> (default) and <code>CONNECT_SSM</code> (connected through AWS Systems Manager).</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/cloud9/latest/user-guide/ec2-ssm.html">Accessing no-ingress EC2 instances with AWS Systems Manager</a> in the <i>AWS Cloud9 User Guide</i>.</p>
    public let connectionType: ConnectionType?
    /// <p>The description of the environment to create.</p>
    public let description: String?
    /// <p>The identifier for the Amazon Machine Image (AMI) that's used to create the EC2 instance. To choose an AMI for the instance, you must specify a valid AMI alias or a valid AWS Systems Manager (SSM) path.</p>
    ///          <p>The default AMI is used if the parameter isn't explicitly assigned a value in the request.
    ///    </p>
    ///          <p>
    ///             <b>AMI aliases </b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Amazon Linux (default): <code>amazonlinux-1-x86_64</code>
    ///                   </b>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Linux 2: <code>amazonlinux-2-x86_64</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Ubuntu 18.04: <code>ubuntu-18.04-x86_64</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>
    ///             <b>SSM paths</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Amazon Linux (default): <code>resolve:ssm:/aws/service/cloud9/amis/amazonlinux-1-x86_64</code>
    ///                   </b>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Linux 2: <code>resolve:ssm:/aws/service/cloud9/amis/amazonlinux-2-x86_64</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Ubuntu 18.04: <code>resolve:ssm:/aws/service/cloud9/amis/ubuntu-18.04-x86_64</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let imageId: String?
    /// <p>The type of instance to connect to the environment (for example, <code>t2.micro</code>).</p>
    public let instanceType: String?
    /// <p>The name of the environment to create.</p>
    ///          <p>This name is visible to other AWS IAM users in the same AWS account.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the environment owner. This ARN can be the ARN of any AWS IAM principal. If this value is not specified, the ARN defaults to this environment's creator.</p>
    public let ownerArn: String?
    /// <p>The ID of the subnet in Amazon VPC that AWS Cloud9 will use to communicate with the Amazon EC2 instance.</p>
    public let subnetId: String?
    /// <p>An array of key-value pairs that will be associated with the new AWS Cloud9 development environment.</p>
    public let tags: [Tag]?

    public init (
        automaticStopTimeMinutes: Int? = nil,
        clientRequestToken: String? = nil,
        connectionType: ConnectionType? = nil,
        description: String? = nil,
        imageId: String? = nil,
        instanceType: String? = nil,
        name: String? = nil,
        ownerArn: String? = nil,
        subnetId: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.automaticStopTimeMinutes = automaticStopTimeMinutes
        self.clientRequestToken = clientRequestToken
        self.connectionType = connectionType
        self.description = description
        self.imageId = imageId
        self.instanceType = instanceType
        self.name = name
        self.ownerArn = ownerArn
        self.subnetId = subnetId
        self.tags = tags
    }
}

struct CreateEnvironmentEC2InputBody: Equatable {
    public let name: String?
    public let description: String?
    public let clientRequestToken: String?
    public let instanceType: String?
    public let subnetId: String?
    public let imageId: String?
    public let automaticStopTimeMinutes: Int?
    public let ownerArn: String?
    public let tags: [Tag]?
    public let connectionType: ConnectionType?
}

extension CreateEnvironmentEC2InputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case automaticStopTimeMinutes
        case clientRequestToken
        case connectionType
        case description
        case imageId
        case instanceType
        case name
        case ownerArn
        case subnetId
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let automaticStopTimeMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .automaticStopTimeMinutes)
        automaticStopTimeMinutes = automaticStopTimeMinutesDecoded
        let ownerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerArn)
        ownerArn = ownerArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
    }
}

extension CreateEnvironmentEC2OutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEnvironmentEC2OutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEnvironmentEC2OutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEnvironmentEC2OutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEnvironmentEC2OutputResponse(environmentId: \(String(describing: environmentId)))"}
}

extension CreateEnvironmentEC2OutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateEnvironmentEC2OutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.environmentId = output.environmentId
        } else {
            self.environmentId = nil
        }
    }
}

public struct CreateEnvironmentEC2OutputResponse: Equatable {
    /// <p>The ID of the environment that was created.</p>
    public let environmentId: String?

    public init (
        environmentId: String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

struct CreateEnvironmentEC2OutputResponseBody: Equatable {
    public let environmentId: String?
}

extension CreateEnvironmentEC2OutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case environmentId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
    }
}

public struct CreateEnvironmentMembershipInputBodyMiddleware: Middleware {
    public let id: String = "CreateEnvironmentMembershipInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEnvironmentMembershipInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEnvironmentMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEnvironmentMembershipInput>
    public typealias MOutput = OperationOutput<CreateEnvironmentMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEnvironmentMembershipOutputError>
}

extension CreateEnvironmentMembershipInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEnvironmentMembershipInput(environmentId: \(String(describing: environmentId)), permissions: \(String(describing: permissions)), userArn: \(String(describing: userArn)))"}
}

extension CreateEnvironmentMembershipInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case environmentId
        case permissions
        case userArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentId = environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let permissions = permissions {
            try encodeContainer.encode(permissions.rawValue, forKey: .permissions)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

public struct CreateEnvironmentMembershipInputHeadersMiddleware: Middleware {
    public let id: String = "CreateEnvironmentMembershipInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEnvironmentMembershipInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEnvironmentMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEnvironmentMembershipInput>
    public typealias MOutput = OperationOutput<CreateEnvironmentMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEnvironmentMembershipOutputError>
}

public struct CreateEnvironmentMembershipInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEnvironmentMembershipInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEnvironmentMembershipInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEnvironmentMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEnvironmentMembershipInput>
    public typealias MOutput = OperationOutput<CreateEnvironmentMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEnvironmentMembershipOutputError>
}

public struct CreateEnvironmentMembershipInput: Equatable {
    /// <p>The ID of the environment that contains the environment member you want to add.</p>
    public let environmentId: String?
    /// <p>The type of environment member permissions you want to associate with this environment member. Available values include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>read-only</code>: Has read-only access to the environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>read-write</code>: Has read-write access to the environment.</p>
    ///             </li>
    ///          </ul>
    public let permissions: MemberPermissions?
    /// <p>The Amazon Resource Name (ARN) of the environment member you want to add.</p>
    public let userArn: String?

    public init (
        environmentId: String? = nil,
        permissions: MemberPermissions? = nil,
        userArn: String? = nil
    )
    {
        self.environmentId = environmentId
        self.permissions = permissions
        self.userArn = userArn
    }
}

struct CreateEnvironmentMembershipInputBody: Equatable {
    public let environmentId: String?
    public let userArn: String?
    public let permissions: MemberPermissions?
}

extension CreateEnvironmentMembershipInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case environmentId
        case permissions
        case userArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
        let permissionsDecoded = try containerValues.decodeIfPresent(MemberPermissions.self, forKey: .permissions)
        permissions = permissionsDecoded
    }
}

extension CreateEnvironmentMembershipOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEnvironmentMembershipOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEnvironmentMembershipOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEnvironmentMembershipOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEnvironmentMembershipOutputResponse(membership: \(String(describing: membership)))"}
}

extension CreateEnvironmentMembershipOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateEnvironmentMembershipOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.membership = output.membership
        } else {
            self.membership = nil
        }
    }
}

public struct CreateEnvironmentMembershipOutputResponse: Equatable {
    /// <p>Information about the environment member that was added.</p>
    public let membership: EnvironmentMember?

    public init (
        membership: EnvironmentMember? = nil
    )
    {
        self.membership = membership
    }
}

struct CreateEnvironmentMembershipOutputResponseBody: Equatable {
    public let membership: EnvironmentMember?
}

extension CreateEnvironmentMembershipOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case membership
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membershipDecoded = try containerValues.decodeIfPresent(EnvironmentMember.self, forKey: .membership)
        membership = membershipDecoded
    }
}

public struct DeleteEnvironmentInputBodyMiddleware: Middleware {
    public let id: String = "DeleteEnvironmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEnvironmentInput>
    public typealias MOutput = OperationOutput<DeleteEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEnvironmentOutputError>
}

extension DeleteEnvironmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEnvironmentInput(environmentId: \(String(describing: environmentId)))"}
}

extension DeleteEnvironmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case environmentId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentId = environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
    }
}

public struct DeleteEnvironmentInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEnvironmentInput>
    public typealias MOutput = OperationOutput<DeleteEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEnvironmentOutputError>
}

public struct DeleteEnvironmentInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEnvironmentInput>
    public typealias MOutput = OperationOutput<DeleteEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEnvironmentOutputError>
}

public struct DeleteEnvironmentInput: Equatable {
    /// <p>The ID of the environment to delete.</p>
    public let environmentId: String?

    public init (
        environmentId: String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

struct DeleteEnvironmentInputBody: Equatable {
    public let environmentId: String?
}

extension DeleteEnvironmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case environmentId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
    }
}

public struct DeleteEnvironmentMembershipInputBodyMiddleware: Middleware {
    public let id: String = "DeleteEnvironmentMembershipInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEnvironmentMembershipInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEnvironmentMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEnvironmentMembershipInput>
    public typealias MOutput = OperationOutput<DeleteEnvironmentMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEnvironmentMembershipOutputError>
}

extension DeleteEnvironmentMembershipInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEnvironmentMembershipInput(environmentId: \(String(describing: environmentId)), userArn: \(String(describing: userArn)))"}
}

extension DeleteEnvironmentMembershipInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case environmentId
        case userArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentId = environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

public struct DeleteEnvironmentMembershipInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEnvironmentMembershipInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEnvironmentMembershipInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEnvironmentMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEnvironmentMembershipInput>
    public typealias MOutput = OperationOutput<DeleteEnvironmentMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEnvironmentMembershipOutputError>
}

public struct DeleteEnvironmentMembershipInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEnvironmentMembershipInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEnvironmentMembershipInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEnvironmentMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEnvironmentMembershipInput>
    public typealias MOutput = OperationOutput<DeleteEnvironmentMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEnvironmentMembershipOutputError>
}

public struct DeleteEnvironmentMembershipInput: Equatable {
    /// <p>The ID of the environment to delete the environment member from.</p>
    public let environmentId: String?
    /// <p>The Amazon Resource Name (ARN) of the environment member to delete from the environment.</p>
    public let userArn: String?

    public init (
        environmentId: String? = nil,
        userArn: String? = nil
    )
    {
        self.environmentId = environmentId
        self.userArn = userArn
    }
}

struct DeleteEnvironmentMembershipInputBody: Equatable {
    public let environmentId: String?
    public let userArn: String?
}

extension DeleteEnvironmentMembershipInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case environmentId
        case userArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension DeleteEnvironmentMembershipOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEnvironmentMembershipOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEnvironmentMembershipOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEnvironmentMembershipOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEnvironmentMembershipOutputResponse()"}
}

extension DeleteEnvironmentMembershipOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEnvironmentMembershipOutputResponse: Equatable {

    public init() {}
}

struct DeleteEnvironmentMembershipOutputResponseBody: Equatable {
}

extension DeleteEnvironmentMembershipOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteEnvironmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEnvironmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEnvironmentOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEnvironmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEnvironmentOutputResponse()"}
}

extension DeleteEnvironmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEnvironmentOutputResponse: Equatable {

    public init() {}
}

struct DeleteEnvironmentOutputResponseBody: Equatable {
}

extension DeleteEnvironmentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeEnvironmentMembershipsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentMembershipsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentMembershipsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentMembershipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentMembershipsInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentMembershipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentMembershipsOutputError>
}

extension DescribeEnvironmentMembershipsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEnvironmentMembershipsInput(environmentId: \(String(describing: environmentId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), permissions: \(String(describing: permissions)), userArn: \(String(describing: userArn)))"}
}

extension DescribeEnvironmentMembershipsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case environmentId
        case maxResults
        case nextToken
        case permissions
        case userArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentId = environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for permissionslist0 in permissions {
                try permissionsContainer.encode(permissionslist0.rawValue)
            }
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

public struct DescribeEnvironmentMembershipsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentMembershipsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentMembershipsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentMembershipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentMembershipsInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentMembershipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentMembershipsOutputError>
}

public struct DescribeEnvironmentMembershipsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentMembershipsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentMembershipsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentMembershipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentMembershipsInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentMembershipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentMembershipsOutputError>
}

public struct DescribeEnvironmentMembershipsInput: Equatable {
    /// <p>The ID of the environment to get environment member information about.</p>
    public let environmentId: String?
    /// <p>The maximum number of environment members to get information about.</p>
    public let maxResults: Int?
    /// <p>During a previous call, if there are more than 25 items in the list, only the first 25 items are returned, along with a unique string called a <i>next token</i>. To get the next batch of items in the list, call this operation again, adding the next token to the call. To get all of the items in the list, keep calling this operation with each subsequent next token that is returned, until no more next tokens are returned.</p>
    public let nextToken: String?
    /// <p>The type of environment member permissions to get information about. Available values include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>owner</code>: Owns the environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>read-only</code>: Has read-only access to the environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>read-write</code>: Has read-write access to the environment.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If no value is specified, information about all environment members are returned.</p>
    public let permissions: [Permissions]?
    /// <p>The Amazon Resource Name (ARN) of an individual environment member to get information about. If no value is specified, information about all environment members are returned.</p>
    public let userArn: String?

    public init (
        environmentId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        permissions: [Permissions]? = nil,
        userArn: String? = nil
    )
    {
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissions = permissions
        self.userArn = userArn
    }
}

struct DescribeEnvironmentMembershipsInputBody: Equatable {
    public let userArn: String?
    public let environmentId: String?
    public let permissions: [Permissions]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeEnvironmentMembershipsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case environmentId
        case maxResults
        case nextToken
        case permissions
        case userArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([Permissions?].self, forKey: .permissions)
        var permissionsDecoded0:[Permissions]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [Permissions]()
            for string0 in permissionsContainer {
                if let string0 = string0 {
                    permissionsDecoded0?.append(string0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeEnvironmentMembershipsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEnvironmentMembershipsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEnvironmentMembershipsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEnvironmentMembershipsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEnvironmentMembershipsOutputResponse(memberships: \(String(describing: memberships)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeEnvironmentMembershipsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEnvironmentMembershipsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.memberships = output.memberships
            self.nextToken = output.nextToken
        } else {
            self.memberships = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEnvironmentMembershipsOutputResponse: Equatable {
    /// <p>Information about the environment members for the environment.</p>
    public let memberships: [EnvironmentMember]?
    /// <p>If there are more than 25 items in the list, only the first 25 items are returned, along with a unique string called a <i>next token</i>. To get the next batch of items in the list, call this operation again, adding the next token to the call.</p>
    public let nextToken: String?

    public init (
        memberships: [EnvironmentMember]? = nil,
        nextToken: String? = nil
    )
    {
        self.memberships = memberships
        self.nextToken = nextToken
    }
}

struct DescribeEnvironmentMembershipsOutputResponseBody: Equatable {
    public let memberships: [EnvironmentMember]?
    public let nextToken: String?
}

extension DescribeEnvironmentMembershipsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case memberships
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membershipsContainer = try containerValues.decodeIfPresent([EnvironmentMember?].self, forKey: .memberships)
        var membershipsDecoded0:[EnvironmentMember]? = nil
        if let membershipsContainer = membershipsContainer {
            membershipsDecoded0 = [EnvironmentMember]()
            for structure0 in membershipsContainer {
                if let structure0 = structure0 {
                    membershipsDecoded0?.append(structure0)
                }
            }
        }
        memberships = membershipsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeEnvironmentStatusInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentStatusInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentStatusOutputError>
}

extension DescribeEnvironmentStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEnvironmentStatusInput(environmentId: \(String(describing: environmentId)))"}
}

extension DescribeEnvironmentStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case environmentId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentId = environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
    }
}

public struct DescribeEnvironmentStatusInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentStatusInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentStatusOutputError>
}

public struct DescribeEnvironmentStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentStatusInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentStatusOutputError>
}

public struct DescribeEnvironmentStatusInput: Equatable {
    /// <p>The ID of the environment to get status information about.</p>
    public let environmentId: String?

    public init (
        environmentId: String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

struct DescribeEnvironmentStatusInputBody: Equatable {
    public let environmentId: String?
}

extension DescribeEnvironmentStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case environmentId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
    }
}

extension DescribeEnvironmentStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEnvironmentStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEnvironmentStatusOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEnvironmentStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEnvironmentStatusOutputResponse(message: \(String(describing: message)), status: \(String(describing: status)))"}
}

extension DescribeEnvironmentStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEnvironmentStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.status = output.status
        } else {
            self.message = nil
            self.status = nil
        }
    }
}

public struct DescribeEnvironmentStatusOutputResponse: Equatable {
    /// <p>Any informational message about the status of the environment.</p>
    public let message: String?
    /// <p>The status of the environment. Available values include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>connecting</code>: The environment is connecting.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>creating</code>: The environment is being created.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: The environment is being deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>error</code>: The environment is in an error state.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ready</code>: The environment is ready.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>stopped</code>: The environment is stopped.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>stopping</code>: The environment is stopping.</p>
    ///             </li>
    ///          </ul>
    public let status: EnvironmentStatus?

    public init (
        message: String? = nil,
        status: EnvironmentStatus? = nil
    )
    {
        self.message = message
        self.status = status
    }
}

struct DescribeEnvironmentStatusOutputResponseBody: Equatable {
    public let status: EnvironmentStatus?
    public let message: String?
}

extension DescribeEnvironmentStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(EnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DescribeEnvironmentsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentsInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentsOutputError>
}

extension DescribeEnvironmentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEnvironmentsInput(environmentIds: \(String(describing: environmentIds)))"}
}

extension DescribeEnvironmentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case environmentIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentIds = environmentIds {
            var environmentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environmentIds)
            for boundedenvironmentidlist0 in environmentIds {
                try environmentIdsContainer.encode(boundedenvironmentidlist0)
            }
        }
    }
}

public struct DescribeEnvironmentsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentsInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentsOutputError>
}

public struct DescribeEnvironmentsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEnvironmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEnvironmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEnvironmentsInput>
    public typealias MOutput = OperationOutput<DescribeEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEnvironmentsOutputError>
}

public struct DescribeEnvironmentsInput: Equatable {
    /// <p>The IDs of individual environments to get information about.</p>
    public let environmentIds: [String]?

    public init (
        environmentIds: [String]? = nil
    )
    {
        self.environmentIds = environmentIds
    }
}

struct DescribeEnvironmentsInputBody: Equatable {
    public let environmentIds: [String]?
}

extension DescribeEnvironmentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case environmentIds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .environmentIds)
        var environmentIdsDecoded0:[String]? = nil
        if let environmentIdsContainer = environmentIdsContainer {
            environmentIdsDecoded0 = [String]()
            for string0 in environmentIdsContainer {
                if let string0 = string0 {
                    environmentIdsDecoded0?.append(string0)
                }
            }
        }
        environmentIds = environmentIdsDecoded0
    }
}

extension DescribeEnvironmentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEnvironmentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEnvironmentsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEnvironmentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEnvironmentsOutputResponse(environments: \(String(describing: environments)))"}
}

extension DescribeEnvironmentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEnvironmentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.environments = output.environments
        } else {
            self.environments = nil
        }
    }
}

public struct DescribeEnvironmentsOutputResponse: Equatable {
    /// <p>Information about the environments that are returned.</p>
    public let environments: [Environment]?

    public init (
        environments: [Environment]? = nil
    )
    {
        self.environments = environments
    }
}

struct DescribeEnvironmentsOutputResponseBody: Equatable {
    public let environments: [Environment]?
}

extension DescribeEnvironmentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case environments
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentsContainer = try containerValues.decodeIfPresent([Environment?].self, forKey: .environments)
        var environmentsDecoded0:[Environment]? = nil
        if let environmentsContainer = environmentsContainer {
            environmentsDecoded0 = [Environment]()
            for structure0 in environmentsContainer {
                if let structure0 = structure0 {
                    environmentsDecoded0?.append(structure0)
                }
            }
        }
        environments = environmentsDecoded0
    }
}

extension Environment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case connectionType
        case description
        case id
        case lifecycle
        case managedCredentialsStatus
        case name
        case ownerArn
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let connectionType = connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let managedCredentialsStatus = managedCredentialsStatus {
            try encodeContainer.encode(managedCredentialsStatus.rawValue, forKey: .managedCredentialsStatus)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerArn = ownerArn {
            try encodeContainer.encode(ownerArn, forKey: .ownerArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(EnvironmentType.self, forKey: .type)
        type = typeDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let ownerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerArn)
        ownerArn = ownerArnDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(EnvironmentLifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let managedCredentialsStatusDecoded = try containerValues.decodeIfPresent(ManagedCredentialsStatus.self, forKey: .managedCredentialsStatus)
        managedCredentialsStatus = managedCredentialsStatusDecoded
    }
}

extension Environment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Environment(arn: \(String(describing: arn)), connectionType: \(String(describing: connectionType)), description: \(String(describing: description)), id: \(String(describing: id)), lifecycle: \(String(describing: lifecycle)), managedCredentialsStatus: \(String(describing: managedCredentialsStatus)), name: \(String(describing: name)), ownerArn: \(String(describing: ownerArn)), type: \(String(describing: type)))"}
}

/// <p>Information about an AWS Cloud9 development environment.</p>
public struct Environment: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the environment.</p>
    public let arn: String?
    /// <p>The connection type used for connecting to an Amazon EC2 environment. <code>CONNECT_SSH</code> is selected by default.</p>
    public let connectionType: ConnectionType?
    /// <p>The description for the environment.</p>
    public let description: String?
    /// <p>The ID of the environment.</p>
    public let id: String?
    /// <p>The state of the environment in its creation or deletion lifecycle.</p>
    public let lifecycle: EnvironmentLifecycle?
    /// <p>Describes the status of AWS managed temporary credentials for the AWS Cloud9 environment. Available values
    ///       are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ENABLED_ON_CREATE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ENABLED_BY_OWNER</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DISABLED_BY_DEFAULT</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DISABLED_BY_OWNER</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DISABLED_BY_COLLABORATOR</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PENDING_REMOVAL_BY_COLLABORATOR</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PENDING_REMOVAL_BY_OWNER</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED_REMOVAL_BY_COLLABORATOR</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ENABLED_BY_OWNER</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DISABLED_BY_DEFAULT</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let managedCredentialsStatus: ManagedCredentialsStatus?
    /// <p>The name of the environment.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the environment owner.</p>
    public let ownerArn: String?
    /// <p>The type of environment. Valid values include the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ec2</code>: An Amazon Elastic Compute Cloud (Amazon EC2) instance connects to the environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ssh</code>: Your own server connects to the environment.</p>
    ///             </li>
    ///          </ul>
    public let type: EnvironmentType?

    public init (
        arn: String? = nil,
        connectionType: ConnectionType? = nil,
        description: String? = nil,
        id: String? = nil,
        lifecycle: EnvironmentLifecycle? = nil,
        managedCredentialsStatus: ManagedCredentialsStatus? = nil,
        name: String? = nil,
        ownerArn: String? = nil,
        type: EnvironmentType? = nil
    )
    {
        self.arn = arn
        self.connectionType = connectionType
        self.description = description
        self.id = id
        self.lifecycle = lifecycle
        self.managedCredentialsStatus = managedCredentialsStatus
        self.name = name
        self.ownerArn = ownerArn
        self.type = type
    }
}

extension EnvironmentLifecycle: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failureResource
        case reason
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureResource = failureResource {
            try encodeContainer.encode(failureResource, forKey: .failureResource)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(EnvironmentLifecycleStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
        let failureResourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureResource)
        failureResource = failureResourceDecoded
    }
}

extension EnvironmentLifecycle: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnvironmentLifecycle(failureResource: \(String(describing: failureResource)), reason: \(String(describing: reason)), status: \(String(describing: status)))"}
}

/// <p>Information about the current creation or deletion lifecycle state of an AWS Cloud9 development environment.</p>
public struct EnvironmentLifecycle: Equatable {
    /// <p>If the environment failed to delete, the Amazon Resource Name (ARN) of the related AWS resource.</p>
    public let failureResource: String?
    /// <p>Any informational message about the lifecycle state of the environment.</p>
    public let reason: String?
    /// <p>The current creation or deletion lifecycle state of the environment.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATING</code>: The environment is in the process of being created.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATED</code>: The environment was successfully created.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_FAILED</code>: The environment failed to be created.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETING</code>: The environment is in the process of being deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_FAILED</code>: The environment failed to delete.</p>
    ///             </li>
    ///          </ul>
    public let status: EnvironmentLifecycleStatus?

    public init (
        failureResource: String? = nil,
        reason: String? = nil,
        status: EnvironmentLifecycleStatus? = nil
    )
    {
        self.failureResource = failureResource
        self.reason = reason
        self.status = status
    }
}

public enum EnvironmentLifecycleStatus {
    case created
    case createFailed
    case creating
    case deleteFailed
    case deleting
    case sdkUnknown(String)
}

extension EnvironmentLifecycleStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EnvironmentLifecycleStatus] {
        return [
            .created,
            .createFailed,
            .creating,
            .deleteFailed,
            .deleting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .created: return "CREATED"
        case .createFailed: return "CREATE_FAILED"
        case .creating: return "CREATING"
        case .deleteFailed: return "DELETE_FAILED"
        case .deleting: return "DELETING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EnvironmentLifecycleStatus(rawValue: rawValue) ?? EnvironmentLifecycleStatus.sdkUnknown(rawValue)
    }
}

extension EnvironmentMember: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case environmentId
        case lastAccess
        case permissions
        case userArn
        case userId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentId = environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let lastAccess = lastAccess {
            try encodeContainer.encode(lastAccess.timeIntervalSince1970, forKey: .lastAccess)
        }
        if let permissions = permissions {
            try encodeContainer.encode(permissions.rawValue, forKey: .permissions)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsDecoded = try containerValues.decodeIfPresent(Permissions.self, forKey: .permissions)
        permissions = permissionsDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let lastAccessDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastAccess)
        lastAccess = lastAccessDecoded
    }
}

extension EnvironmentMember: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnvironmentMember(environmentId: \(String(describing: environmentId)), lastAccess: \(String(describing: lastAccess)), permissions: \(String(describing: permissions)), userArn: \(String(describing: userArn)), userId: \(String(describing: userId)))"}
}

/// <p>Information about an environment member for an AWS Cloud9 development environment.</p>
public struct EnvironmentMember: Equatable {
    /// <p>The ID of the environment for the environment member.</p>
    public let environmentId: String?
    /// <p>The time, expressed in epoch time format, when the environment member last opened the environment.</p>
    public let lastAccess: Date?
    /// <p>The type of environment member permissions associated with this environment member. Available values include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>owner</code>: Owns the environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>read-only</code>: Has read-only access to the environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>read-write</code>: Has read-write access to the environment.</p>
    ///             </li>
    ///          </ul>
    public let permissions: Permissions?
    /// <p>The Amazon Resource Name (ARN) of the environment member.</p>
    public let userArn: String?
    /// <p>The user ID in AWS Identity and Access Management (AWS IAM) of the environment member.</p>
    public let userId: String?

    public init (
        environmentId: String? = nil,
        lastAccess: Date? = nil,
        permissions: Permissions? = nil,
        userArn: String? = nil,
        userId: String? = nil
    )
    {
        self.environmentId = environmentId
        self.lastAccess = lastAccess
        self.permissions = permissions
        self.userArn = userArn
        self.userId = userId
    }
}

public enum EnvironmentStatus {
    case connecting
    case creating
    case deleting
    case error
    case ready
    case stopped
    case stopping
    case sdkUnknown(String)
}

extension EnvironmentStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EnvironmentStatus] {
        return [
            .connecting,
            .creating,
            .deleting,
            .error,
            .ready,
            .stopped,
            .stopping,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .connecting: return "connecting"
        case .creating: return "creating"
        case .deleting: return "deleting"
        case .error: return "error"
        case .ready: return "ready"
        case .stopped: return "stopped"
        case .stopping: return "stopping"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EnvironmentStatus(rawValue: rawValue) ?? EnvironmentStatus.sdkUnknown(rawValue)
    }
}

public enum EnvironmentType {
    case ec2
    case ssh
    case sdkUnknown(String)
}

extension EnvironmentType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EnvironmentType] {
        return [
            .ec2,
            .ssh,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ec2: return "ec2"
        case .ssh: return "ssh"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EnvironmentType(rawValue: rawValue) ?? EnvironmentType.sdkUnknown(rawValue)
    }
}

extension ForbiddenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForbiddenException(className: \(String(describing: className)), code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension ForbiddenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.className = output.className
            self.code = output.code
            self.message = output.message
        } else {
            self.className = nil
            self.code = 0
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An access permissions issue occurred.</p>
public struct ForbiddenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var className: String?
    public var code: Int
    public var message: String?

    public init (
        className: String? = nil,
        code: Int = 0,
        message: String? = nil
    )
    {
        self.className = className
        self.code = code
        self.message = message
    }
}

struct ForbiddenExceptionBody: Equatable {
    public let message: String?
    public let className: String?
    public let code: Int
}

extension ForbiddenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case className
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let classNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .className)
        className = classNameDecoded
        let codeDecoded = try containerValues.decode(Int.self, forKey: .code)
        code = codeDecoded
    }
}

extension InternalServerErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerErrorException(className: \(String(describing: className)), code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension InternalServerErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.className = output.className
            self.code = output.code
            self.message = output.message
        } else {
            self.className = nil
            self.code = 0
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal server error occurred.</p>
public struct InternalServerErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var className: String?
    public var code: Int
    public var message: String?

    public init (
        className: String? = nil,
        code: Int = 0,
        message: String? = nil
    )
    {
        self.className = className
        self.code = code
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Equatable {
    public let message: String?
    public let className: String?
    public let code: Int
}

extension InternalServerErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case className
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let classNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .className)
        className = classNameDecoded
        let codeDecoded = try containerValues.decode(Int.self, forKey: .code)
        code = codeDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(className: \(String(describing: className)), code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.className = output.className
            self.code = output.code
            self.message = output.message
        } else {
            self.className = nil
            self.code = 0
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A service limit was exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var className: String?
    public var code: Int
    public var message: String?

    public init (
        className: String? = nil,
        code: Int = 0,
        message: String? = nil
    )
    {
        self.className = className
        self.code = code
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
    public let className: String?
    public let code: Int
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case className
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let classNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .className)
        className = classNameDecoded
        let codeDecoded = try containerValues.decode(Int.self, forKey: .code)
        code = codeDecoded
    }
}

public struct ListEnvironmentsInputBodyMiddleware: Middleware {
    public let id: String = "ListEnvironmentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEnvironmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEnvironmentsInput>
    public typealias MOutput = OperationOutput<ListEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEnvironmentsOutputError>
}

extension ListEnvironmentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEnvironmentsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEnvironmentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListEnvironmentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListEnvironmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEnvironmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEnvironmentsInput>
    public typealias MOutput = OperationOutput<ListEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEnvironmentsOutputError>
}

public struct ListEnvironmentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEnvironmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEnvironmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEnvironmentsInput>
    public typealias MOutput = OperationOutput<ListEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEnvironmentsOutputError>
}

public struct ListEnvironmentsInput: Equatable {
    /// <p>The maximum number of environments to get identifiers for.</p>
    public let maxResults: Int?
    /// <p>During a previous call, if there are more than 25 items in the list, only the first 25 items are returned, along with a unique string called a <i>next token</i>. To get the next batch of items in the list, call this operation again, adding the next token to the call. To get all of the items in the list, keep calling this operation with each subsequent next token that is returned, until no more next tokens are returned.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListEnvironmentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEnvironmentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEnvironmentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEnvironmentsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEnvironmentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEnvironmentsOutputResponse(environmentIds: \(String(describing: environmentIds)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEnvironmentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEnvironmentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.environmentIds = output.environmentIds
            self.nextToken = output.nextToken
        } else {
            self.environmentIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentsOutputResponse: Equatable {
    /// <p>The list of environment identifiers.</p>
    public let environmentIds: [String]?
    /// <p>If there are more than 25 items in the list, only the first 25 items are returned, along with a unique string called a <i>next token</i>. To get the next batch of items in the list, call this operation again, adding the next token to the call.</p>
    public let nextToken: String?

    public init (
        environmentIds: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.environmentIds = environmentIds
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let environmentIds: [String]?
}

extension ListEnvironmentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case environmentIds
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let environmentIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .environmentIds)
        var environmentIdsDecoded0:[String]? = nil
        if let environmentIdsContainer = environmentIdsContainer {
            environmentIdsDecoded0 = [String]()
            for string0 in environmentIdsContainer {
                if let string0 = string0 {
                    environmentIdsDecoded0?.append(string0)
                }
            }
        }
        environmentIds = environmentIdsDecoded0
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceARN: \(String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS Cloud9 development environment to get the tags for.</p>
    public let resourceARN: String?

    public init (
        resourceARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceARN: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The list of tags associated with the AWS Cloud9 development environment.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum ManagedCredentialsStatus {
    case disabledByCollaborator
    case disabledByDefault
    case disabledByOwner
    case enabledByOwner
    case enabledOnCreate
    case failedRemovalByCollaborator
    case failedRemovalByOwner
    case pendingRemovalByCollaborator
    case pendingRemovalByOwner
    case pendingStartRemovalByCollaborator
    case pendingStartRemovalByOwner
    case sdkUnknown(String)
}

extension ManagedCredentialsStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ManagedCredentialsStatus] {
        return [
            .disabledByCollaborator,
            .disabledByDefault,
            .disabledByOwner,
            .enabledByOwner,
            .enabledOnCreate,
            .failedRemovalByCollaborator,
            .failedRemovalByOwner,
            .pendingRemovalByCollaborator,
            .pendingRemovalByOwner,
            .pendingStartRemovalByCollaborator,
            .pendingStartRemovalByOwner,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabledByCollaborator: return "DISABLED_BY_COLLABORATOR"
        case .disabledByDefault: return "DISABLED_BY_DEFAULT"
        case .disabledByOwner: return "DISABLED_BY_OWNER"
        case .enabledByOwner: return "ENABLED_BY_OWNER"
        case .enabledOnCreate: return "ENABLED_ON_CREATE"
        case .failedRemovalByCollaborator: return "FAILED_REMOVAL_BY_COLLABORATOR"
        case .failedRemovalByOwner: return "FAILED_REMOVAL_BY_OWNER"
        case .pendingRemovalByCollaborator: return "PENDING_REMOVAL_BY_COLLABORATOR"
        case .pendingRemovalByOwner: return "PENDING_REMOVAL_BY_OWNER"
        case .pendingStartRemovalByCollaborator: return "PENDING_START_REMOVAL_BY_COLLABORATOR"
        case .pendingStartRemovalByOwner: return "PENDING_START_REMOVAL_BY_OWNER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ManagedCredentialsStatus(rawValue: rawValue) ?? ManagedCredentialsStatus.sdkUnknown(rawValue)
    }
}

public enum MemberPermissions {
    case readOnly
    case readWrite
    case sdkUnknown(String)
}

extension MemberPermissions : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MemberPermissions] {
        return [
            .readOnly,
            .readWrite,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .readOnly: return "read-only"
        case .readWrite: return "read-write"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MemberPermissions(rawValue: rawValue) ?? MemberPermissions.sdkUnknown(rawValue)
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(className: \(String(describing: className)), code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.className = output.className
            self.code = output.code
            self.message = output.message
        } else {
            self.className = nil
            self.code = 0
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The target resource cannot be found.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var className: String?
    public var code: Int
    public var message: String?

    public init (
        className: String? = nil,
        code: Int = 0,
        message: String? = nil
    )
    {
        self.className = className
        self.code = code
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
    public let className: String?
    public let code: Int
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case className
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let classNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .className)
        className = classNameDecoded
        let codeDecoded = try containerValues.decode(Int.self, forKey: .code)
        code = codeDecoded
    }
}

public enum Permissions {
    case owner
    case readOnly
    case readWrite
    case sdkUnknown(String)
}

extension Permissions : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Permissions] {
        return [
            .owner,
            .readOnly,
            .readWrite,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .owner: return "owner"
        case .readOnly: return "read-only"
        case .readWrite: return "read-write"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Permissions(rawValue: rawValue) ?? Permissions.sdkUnknown(rawValue)
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

/// <p>Metadata that is associated with AWS resources. In particular, a name-value pair that can be associated with an AWS Cloud9 development environment. There are two types of tags: <i>user tags</i> and <i>system tags</i>. A user tag is created by the user. A system tag is automatically created by AWS services. A system tag is prefixed with "aws:" and cannot be modified by the user.</p>
public struct Tag: Equatable {
    /// <p>The <b>name</b> part of a tag.</p>
    public let key: String?
    /// <p>The <b>value</b> part of a tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS Cloud9 development environment to add tags to.</p>
    public let resourceARN: String?
    /// <p>The list of tags to add to the given AWS Cloud9 development environment.</p>
    public let tags: [Tag]?

    public init (
        resourceARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentAccessException" : self = .concurrentAccessException(try ConcurrentAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentAccessException(ConcurrentAccessException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(className: \(String(describing: className)), code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.className = output.className
            self.code = output.code
            self.message = output.message
        } else {
            self.className = nil
            self.code = 0
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Too many service requests were made over the given time period.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var className: String?
    public var code: Int
    public var message: String?

    public init (
        className: String? = nil,
        code: Int = 0,
        message: String? = nil
    )
    {
        self.className = className
        self.code = code
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
    public let className: String?
    public let code: Int
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case className
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let classNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .className)
        className = classNameDecoded
        let codeDecoded = try containerValues.decode(Int.self, forKey: .code)
        code = codeDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceARN: \(String(describing: resourceARN)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS Cloud9 development environment to remove tags from.</p>
    public let resourceARN: String?
    /// <p>The tag names of the tags to remove from the given AWS Cloud9 development environment.</p>
    public let tagKeys: [String]?

    public init (
        resourceARN: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentAccessException" : self = .concurrentAccessException(try ConcurrentAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentAccessException(ConcurrentAccessException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateEnvironmentInputBodyMiddleware: Middleware {
    public let id: String = "UpdateEnvironmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEnvironmentOutputError>
}

extension UpdateEnvironmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEnvironmentInput(description: \(String(describing: description)), environmentId: \(String(describing: environmentId)), name: \(String(describing: name)))"}
}

extension UpdateEnvironmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case environmentId
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environmentId = environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateEnvironmentInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEnvironmentOutputError>
}

public struct UpdateEnvironmentInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEnvironmentOutputError>
}

public struct UpdateEnvironmentInput: Equatable {
    /// <p>Any new or replacement description for the environment.</p>
    public let description: String?
    /// <p>The ID of the environment to change settings.</p>
    public let environmentId: String?
    /// <p>A replacement name for the environment.</p>
    public let name: String?

    public init (
        description: String? = nil,
        environmentId: String? = nil,
        name: String? = nil
    )
    {
        self.description = description
        self.environmentId = environmentId
        self.name = name
    }
}

struct UpdateEnvironmentInputBody: Equatable {
    public let environmentId: String?
    public let name: String?
    public let description: String?
}

extension UpdateEnvironmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case environmentId
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

public struct UpdateEnvironmentMembershipInputBodyMiddleware: Middleware {
    public let id: String = "UpdateEnvironmentMembershipInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEnvironmentMembershipInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEnvironmentMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEnvironmentMembershipInput>
    public typealias MOutput = OperationOutput<UpdateEnvironmentMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEnvironmentMembershipOutputError>
}

extension UpdateEnvironmentMembershipInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEnvironmentMembershipInput(environmentId: \(String(describing: environmentId)), permissions: \(String(describing: permissions)), userArn: \(String(describing: userArn)))"}
}

extension UpdateEnvironmentMembershipInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case environmentId
        case permissions
        case userArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentId = environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let permissions = permissions {
            try encodeContainer.encode(permissions.rawValue, forKey: .permissions)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

public struct UpdateEnvironmentMembershipInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateEnvironmentMembershipInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEnvironmentMembershipInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEnvironmentMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEnvironmentMembershipInput>
    public typealias MOutput = OperationOutput<UpdateEnvironmentMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEnvironmentMembershipOutputError>
}

public struct UpdateEnvironmentMembershipInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateEnvironmentMembershipInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEnvironmentMembershipInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEnvironmentMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEnvironmentMembershipInput>
    public typealias MOutput = OperationOutput<UpdateEnvironmentMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEnvironmentMembershipOutputError>
}

public struct UpdateEnvironmentMembershipInput: Equatable {
    /// <p>The ID of the environment for the environment member whose settings you want to change.</p>
    public let environmentId: String?
    /// <p>The replacement type of environment member permissions you want to associate with this environment member. Available values include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>read-only</code>: Has read-only access to the environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>read-write</code>: Has read-write access to the environment.</p>
    ///             </li>
    ///          </ul>
    public let permissions: MemberPermissions?
    /// <p>The Amazon Resource Name (ARN) of the environment member whose settings you want to change.</p>
    public let userArn: String?

    public init (
        environmentId: String? = nil,
        permissions: MemberPermissions? = nil,
        userArn: String? = nil
    )
    {
        self.environmentId = environmentId
        self.permissions = permissions
        self.userArn = userArn
    }
}

struct UpdateEnvironmentMembershipInputBody: Equatable {
    public let environmentId: String?
    public let userArn: String?
    public let permissions: MemberPermissions?
}

extension UpdateEnvironmentMembershipInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case environmentId
        case permissions
        case userArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
        let permissionsDecoded = try containerValues.decodeIfPresent(MemberPermissions.self, forKey: .permissions)
        permissions = permissionsDecoded
    }
}

extension UpdateEnvironmentMembershipOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEnvironmentMembershipOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEnvironmentMembershipOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEnvironmentMembershipOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEnvironmentMembershipOutputResponse(membership: \(String(describing: membership)))"}
}

extension UpdateEnvironmentMembershipOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateEnvironmentMembershipOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.membership = output.membership
        } else {
            self.membership = nil
        }
    }
}

public struct UpdateEnvironmentMembershipOutputResponse: Equatable {
    /// <p>Information about the environment member whose settings were changed.</p>
    public let membership: EnvironmentMember?

    public init (
        membership: EnvironmentMember? = nil
    )
    {
        self.membership = membership
    }
}

struct UpdateEnvironmentMembershipOutputResponseBody: Equatable {
    public let membership: EnvironmentMember?
}

extension UpdateEnvironmentMembershipOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case membership
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membershipDecoded = try containerValues.decodeIfPresent(EnvironmentMember.self, forKey: .membership)
        membership = membershipDecoded
    }
}

extension UpdateEnvironmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEnvironmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEnvironmentOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEnvironmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEnvironmentOutputResponse()"}
}

extension UpdateEnvironmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateEnvironmentOutputResponse: Equatable {

    public init() {}
}

struct UpdateEnvironmentOutputResponseBody: Equatable {
}

extension UpdateEnvironmentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}
