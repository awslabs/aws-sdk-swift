// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class MediaLiveClient {
    let client: SdkHttpClient
    let config: MediaLiveClientConfiguration
    let serviceName = "MediaLive"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: MediaLiveClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class MediaLiveClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> MediaLiveClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try MediaLiveClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension MediaLiveClient: MediaLiveClientProtocol {
    /// Accept an incoming input device transfer. The ownership of the device will transfer to your AWS account.
    public func acceptInputDeviceTransfer(input: AcceptInputDeviceTransferInput, completion: @escaping (SdkResult<AcceptInputDeviceTransferOutput, AcceptInputDeviceTransferOutputError>) -> Void)
    {
        guard let inputDeviceId = input.inputDeviceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component inputDeviceId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/inputDevices/\(inputDeviceId)/accept"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "acceptInputDeviceTransfer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AcceptInputDeviceTransferInput, AcceptInputDeviceTransferOutput, AcceptInputDeviceTransferOutputError>(id: "acceptInputDeviceTransfer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AcceptInputDeviceTransferInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AcceptInputDeviceTransferInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AcceptInputDeviceTransferInput, AcceptInputDeviceTransferOutput, AcceptInputDeviceTransferOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Starts delete of resources.
    public func batchDelete(input: BatchDeleteInput, completion: @escaping (SdkResult<BatchDeleteOutput, BatchDeleteOutputError>) -> Void)
    {
        let urlPath = "/prod/batch/delete"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "batchDelete")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<BatchDeleteInput, BatchDeleteOutput, BatchDeleteOutputError>(id: "batchDelete")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: BatchDeleteInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: BatchDeleteInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<BatchDeleteInput, BatchDeleteOutput, BatchDeleteOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: BatchDeleteInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Starts existing resources
    public func batchStart(input: BatchStartInput, completion: @escaping (SdkResult<BatchStartOutput, BatchStartOutputError>) -> Void)
    {
        let urlPath = "/prod/batch/start"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "batchStart")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<BatchStartInput, BatchStartOutput, BatchStartOutputError>(id: "batchStart")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: BatchStartInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: BatchStartInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<BatchStartInput, BatchStartOutput, BatchStartOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: BatchStartInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Stops running resources
    public func batchStop(input: BatchStopInput, completion: @escaping (SdkResult<BatchStopOutput, BatchStopOutputError>) -> Void)
    {
        let urlPath = "/prod/batch/stop"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "batchStop")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<BatchStopInput, BatchStopOutput, BatchStopOutputError>(id: "batchStop")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: BatchStopInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: BatchStopInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<BatchStopInput, BatchStopOutput, BatchStopOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: BatchStopInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Update a channel schedule
    public func batchUpdateSchedule(input: BatchUpdateScheduleInput, completion: @escaping (SdkResult<BatchUpdateScheduleOutput, BatchUpdateScheduleOutputError>) -> Void)
    {
        guard let channelId = input.channelId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component channelId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/channels/\(channelId)/schedule"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "batchUpdateSchedule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<BatchUpdateScheduleInput, BatchUpdateScheduleOutput, BatchUpdateScheduleOutputError>(id: "batchUpdateSchedule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: BatchUpdateScheduleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: BatchUpdateScheduleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<BatchUpdateScheduleInput, BatchUpdateScheduleOutput, BatchUpdateScheduleOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: BatchUpdateScheduleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Cancel an input device transfer that you have requested.
    public func cancelInputDeviceTransfer(input: CancelInputDeviceTransferInput, completion: @escaping (SdkResult<CancelInputDeviceTransferOutput, CancelInputDeviceTransferOutputError>) -> Void)
    {
        guard let inputDeviceId = input.inputDeviceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component inputDeviceId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/inputDevices/\(inputDeviceId)/cancel"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "cancelInputDeviceTransfer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CancelInputDeviceTransferInput, CancelInputDeviceTransferOutput, CancelInputDeviceTransferOutputError>(id: "cancelInputDeviceTransfer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CancelInputDeviceTransferInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CancelInputDeviceTransferInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CancelInputDeviceTransferInput, CancelInputDeviceTransferOutput, CancelInputDeviceTransferOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a new channel
    public func createChannel(input: CreateChannelInput, completion: @escaping (SdkResult<CreateChannelOutput, CreateChannelOutputError>) -> Void)
    {
        let urlPath = "/prod/channels"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createChannel")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateChannelInput, CreateChannelOutput, CreateChannelOutputError>(id: "createChannel")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateChannelOutput>, SdkError<CreateChannelOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.requestId == nil {
                copiedInput.requestId = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateChannelInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateChannelInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateChannelInput, CreateChannelOutput, CreateChannelOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateChannelInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Create an input
    public func createInput(input: CreateInputInput, completion: @escaping (SdkResult<CreateInputOutput, CreateInputOutputError>) -> Void)
    {
        let urlPath = "/prod/inputs"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createInput")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateInputInput, CreateInputOutput, CreateInputOutputError>(id: "createInput")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateInputOutput>, SdkError<CreateInputOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.requestId == nil {
                copiedInput.requestId = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateInputInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateInputInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateInputInput, CreateInputOutput, CreateInputOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateInputInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a Input Security Group
    public func createInputSecurityGroup(input: CreateInputSecurityGroupInput, completion: @escaping (SdkResult<CreateInputSecurityGroupOutput, CreateInputSecurityGroupOutputError>) -> Void)
    {
        let urlPath = "/prod/inputSecurityGroups"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createInputSecurityGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateInputSecurityGroupInput, CreateInputSecurityGroupOutput, CreateInputSecurityGroupOutputError>(id: "createInputSecurityGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateInputSecurityGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateInputSecurityGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateInputSecurityGroupInput, CreateInputSecurityGroupOutput, CreateInputSecurityGroupOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateInputSecurityGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Create a new multiplex.
    public func createMultiplex(input: CreateMultiplexInput, completion: @escaping (SdkResult<CreateMultiplexOutput, CreateMultiplexOutputError>) -> Void)
    {
        let urlPath = "/prod/multiplexes"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createMultiplex")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateMultiplexInput, CreateMultiplexOutput, CreateMultiplexOutputError>(id: "createMultiplex")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateMultiplexOutput>, SdkError<CreateMultiplexOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.requestId == nil {
                copiedInput.requestId = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateMultiplexInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateMultiplexInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateMultiplexInput, CreateMultiplexOutput, CreateMultiplexOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateMultiplexInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Create a new program in the multiplex.
    public func createMultiplexProgram(input: CreateMultiplexProgramInput, completion: @escaping (SdkResult<CreateMultiplexProgramOutput, CreateMultiplexProgramOutputError>) -> Void)
    {
        guard let multiplexId = input.multiplexId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component multiplexId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/multiplexes/\(multiplexId)/programs"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createMultiplexProgram")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateMultiplexProgramInput, CreateMultiplexProgramOutput, CreateMultiplexProgramOutputError>(id: "createMultiplexProgram")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateMultiplexProgramOutput>, SdkError<CreateMultiplexProgramOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.requestId == nil {
                copiedInput.requestId = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateMultiplexProgramInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateMultiplexProgramInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateMultiplexProgramInput, CreateMultiplexProgramOutput, CreateMultiplexProgramOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateMultiplexProgramInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Create a partner input
    public func createPartnerInput(input: CreatePartnerInputInput, completion: @escaping (SdkResult<CreatePartnerInputOutput, CreatePartnerInputOutputError>) -> Void)
    {
        guard let inputId = input.inputId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component inputId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/inputs/\(inputId)/partners"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createPartnerInput")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreatePartnerInputInput, CreatePartnerInputOutput, CreatePartnerInputOutputError>(id: "createPartnerInput")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreatePartnerInputOutput>, SdkError<CreatePartnerInputOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.requestId == nil {
                copiedInput.requestId = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreatePartnerInputInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreatePartnerInputInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreatePartnerInputInput, CreatePartnerInputOutput, CreatePartnerInputOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreatePartnerInputInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Create tags for a resource
    public func createTags(input: CreateTagsInput, completion: @escaping (SdkResult<CreateTagsOutput, CreateTagsOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createTags")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateTagsInput, CreateTagsOutput, CreateTagsOutputError>(id: "createTags")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateTagsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateTagsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateTagsInput, CreateTagsOutput, CreateTagsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateTagsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Starts deletion of channel. The associated outputs are also deleted.
    public func deleteChannel(input: DeleteChannelInput, completion: @escaping (SdkResult<DeleteChannelOutput, DeleteChannelOutputError>) -> Void)
    {
        guard let channelId = input.channelId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component channelId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/channels/\(channelId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteChannel")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteChannelInput, DeleteChannelOutput, DeleteChannelOutputError>(id: "deleteChannel")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteChannelInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteChannelInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteChannelInput, DeleteChannelOutput, DeleteChannelOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes the input end point
    public func deleteInput(input: DeleteInputInput, completion: @escaping (SdkResult<DeleteInputOutput, DeleteInputOutputError>) -> Void)
    {
        guard let inputId = input.inputId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component inputId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/inputs/\(inputId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteInput")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteInputInput, DeleteInputOutput, DeleteInputOutputError>(id: "deleteInput")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteInputInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteInputInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteInputInput, DeleteInputOutput, DeleteInputOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes an Input Security Group
    public func deleteInputSecurityGroup(input: DeleteInputSecurityGroupInput, completion: @escaping (SdkResult<DeleteInputSecurityGroupOutput, DeleteInputSecurityGroupOutputError>) -> Void)
    {
        guard let inputSecurityGroupId = input.inputSecurityGroupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component inputSecurityGroupId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/inputSecurityGroups/\(inputSecurityGroupId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteInputSecurityGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteInputSecurityGroupInput, DeleteInputSecurityGroupOutput, DeleteInputSecurityGroupOutputError>(id: "deleteInputSecurityGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteInputSecurityGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteInputSecurityGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteInputSecurityGroupInput, DeleteInputSecurityGroupOutput, DeleteInputSecurityGroupOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Delete a multiplex. The multiplex must be idle.
    public func deleteMultiplex(input: DeleteMultiplexInput, completion: @escaping (SdkResult<DeleteMultiplexOutput, DeleteMultiplexOutputError>) -> Void)
    {
        guard let multiplexId = input.multiplexId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component multiplexId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/multiplexes/\(multiplexId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteMultiplex")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteMultiplexInput, DeleteMultiplexOutput, DeleteMultiplexOutputError>(id: "deleteMultiplex")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteMultiplexInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteMultiplexInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteMultiplexInput, DeleteMultiplexOutput, DeleteMultiplexOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Delete a program from a multiplex.
    public func deleteMultiplexProgram(input: DeleteMultiplexProgramInput, completion: @escaping (SdkResult<DeleteMultiplexProgramOutput, DeleteMultiplexProgramOutputError>) -> Void)
    {
        guard let multiplexId = input.multiplexId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component multiplexId unexpectedly nil"))))
            return
        }
        guard let programName = input.programName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component programName unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/multiplexes/\(multiplexId)/programs/\(programName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteMultiplexProgram")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteMultiplexProgramInput, DeleteMultiplexProgramOutput, DeleteMultiplexProgramOutputError>(id: "deleteMultiplexProgram")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteMultiplexProgramInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteMultiplexProgramInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteMultiplexProgramInput, DeleteMultiplexProgramOutput, DeleteMultiplexProgramOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Delete an expired reservation.
    public func deleteReservation(input: DeleteReservationInput, completion: @escaping (SdkResult<DeleteReservationOutput, DeleteReservationOutputError>) -> Void)
    {
        guard let reservationId = input.reservationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component reservationId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/reservations/\(reservationId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteReservation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteReservationInput, DeleteReservationOutput, DeleteReservationOutputError>(id: "deleteReservation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteReservationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteReservationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteReservationInput, DeleteReservationOutput, DeleteReservationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Delete all schedule actions on a channel.
    public func deleteSchedule(input: DeleteScheduleInput, completion: @escaping (SdkResult<DeleteScheduleOutput, DeleteScheduleOutputError>) -> Void)
    {
        guard let channelId = input.channelId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component channelId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/channels/\(channelId)/schedule"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteSchedule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteScheduleInput, DeleteScheduleOutput, DeleteScheduleOutputError>(id: "deleteSchedule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteScheduleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteScheduleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteScheduleInput, DeleteScheduleOutput, DeleteScheduleOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Removes tags for a resource
    public func deleteTags(input: DeleteTagsInput, completion: @escaping (SdkResult<DeleteTagsOutput, DeleteTagsOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteTags")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteTagsInput, DeleteTagsOutput, DeleteTagsOutputError>(id: "deleteTags")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteTagsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteTagsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteTagsInput, DeleteTagsOutput, DeleteTagsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets details about a channel
    public func describeChannel(input: DescribeChannelInput, completion: @escaping (SdkResult<DescribeChannelOutput, DescribeChannelOutputError>) -> Void)
    {
        guard let channelId = input.channelId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component channelId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/channels/\(channelId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeChannel")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeChannelInput, DescribeChannelOutput, DescribeChannelOutputError>(id: "describeChannel")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeChannelInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeChannelInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeChannelInput, DescribeChannelOutput, DescribeChannelOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Produces details about an input
    public func describeInput(input: DescribeInputInput, completion: @escaping (SdkResult<DescribeInputOutput, DescribeInputOutputError>) -> Void)
    {
        guard let inputId = input.inputId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component inputId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/inputs/\(inputId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeInput")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeInputInput, DescribeInputOutput, DescribeInputOutputError>(id: "describeInput")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeInputInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeInputInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeInputInput, DescribeInputOutput, DescribeInputOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets the details for the input device
    public func describeInputDevice(input: DescribeInputDeviceInput, completion: @escaping (SdkResult<DescribeInputDeviceOutput, DescribeInputDeviceOutputError>) -> Void)
    {
        guard let inputDeviceId = input.inputDeviceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component inputDeviceId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/inputDevices/\(inputDeviceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeInputDevice")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeInputDeviceInput, DescribeInputDeviceOutput, DescribeInputDeviceOutputError>(id: "describeInputDevice")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeInputDeviceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeInputDeviceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeInputDeviceInput, DescribeInputDeviceOutput, DescribeInputDeviceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Get the latest thumbnail data for the input device.
    public func describeInputDeviceThumbnail(input: DescribeInputDeviceThumbnailInput, streamSink: StreamSink, completion: @escaping (SdkResult<DescribeInputDeviceThumbnailOutput, DescribeInputDeviceThumbnailOutputError>) -> Void)
    {
        guard let inputDeviceId = input.inputDeviceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component inputDeviceId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/inputDevices/\(inputDeviceId)/thumbnailData"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeInputDeviceThumbnail")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeInputDeviceThumbnailInput, DescribeInputDeviceThumbnailOutput, DescribeInputDeviceThumbnailOutputError>(id: "describeInputDeviceThumbnail")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeInputDeviceThumbnailInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeInputDeviceThumbnailInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeInputDeviceThumbnailInput, DescribeInputDeviceThumbnailOutput, DescribeInputDeviceThumbnailOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Produces a summary of an Input Security Group
    public func describeInputSecurityGroup(input: DescribeInputSecurityGroupInput, completion: @escaping (SdkResult<DescribeInputSecurityGroupOutput, DescribeInputSecurityGroupOutputError>) -> Void)
    {
        guard let inputSecurityGroupId = input.inputSecurityGroupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component inputSecurityGroupId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/inputSecurityGroups/\(inputSecurityGroupId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeInputSecurityGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeInputSecurityGroupInput, DescribeInputSecurityGroupOutput, DescribeInputSecurityGroupOutputError>(id: "describeInputSecurityGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeInputSecurityGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeInputSecurityGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeInputSecurityGroupInput, DescribeInputSecurityGroupOutput, DescribeInputSecurityGroupOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets details about a multiplex.
    public func describeMultiplex(input: DescribeMultiplexInput, completion: @escaping (SdkResult<DescribeMultiplexOutput, DescribeMultiplexOutputError>) -> Void)
    {
        guard let multiplexId = input.multiplexId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component multiplexId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/multiplexes/\(multiplexId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeMultiplex")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeMultiplexInput, DescribeMultiplexOutput, DescribeMultiplexOutputError>(id: "describeMultiplex")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeMultiplexInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeMultiplexInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeMultiplexInput, DescribeMultiplexOutput, DescribeMultiplexOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Get the details for a program in a multiplex.
    public func describeMultiplexProgram(input: DescribeMultiplexProgramInput, completion: @escaping (SdkResult<DescribeMultiplexProgramOutput, DescribeMultiplexProgramOutputError>) -> Void)
    {
        guard let multiplexId = input.multiplexId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component multiplexId unexpectedly nil"))))
            return
        }
        guard let programName = input.programName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component programName unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/multiplexes/\(multiplexId)/programs/\(programName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeMultiplexProgram")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeMultiplexProgramInput, DescribeMultiplexProgramOutput, DescribeMultiplexProgramOutputError>(id: "describeMultiplexProgram")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeMultiplexProgramInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeMultiplexProgramInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeMultiplexProgramInput, DescribeMultiplexProgramOutput, DescribeMultiplexProgramOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Get details for an offering.
    public func describeOffering(input: DescribeOfferingInput, completion: @escaping (SdkResult<DescribeOfferingOutput, DescribeOfferingOutputError>) -> Void)
    {
        guard let offeringId = input.offeringId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component offeringId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/offerings/\(offeringId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeOffering")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeOfferingInput, DescribeOfferingOutput, DescribeOfferingOutputError>(id: "describeOffering")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeOfferingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeOfferingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeOfferingInput, DescribeOfferingOutput, DescribeOfferingOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Get details for a reservation.
    public func describeReservation(input: DescribeReservationInput, completion: @escaping (SdkResult<DescribeReservationOutput, DescribeReservationOutputError>) -> Void)
    {
        guard let reservationId = input.reservationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component reservationId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/reservations/\(reservationId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeReservation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeReservationInput, DescribeReservationOutput, DescribeReservationOutputError>(id: "describeReservation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeReservationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeReservationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeReservationInput, DescribeReservationOutput, DescribeReservationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Get a channel schedule
    public func describeSchedule(input: DescribeScheduleInput, completion: @escaping (SdkResult<DescribeScheduleOutput, DescribeScheduleOutputError>) -> Void)
    {
        guard let channelId = input.channelId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component channelId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/channels/\(channelId)/schedule"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeSchedule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeScheduleInput, DescribeScheduleOutput, DescribeScheduleOutputError>(id: "describeSchedule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeScheduleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeScheduleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeScheduleInput, DescribeScheduleOutput, DescribeScheduleOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Produces list of channels that have been created
    public func listChannels(input: ListChannelsInput, completion: @escaping (SdkResult<ListChannelsOutput, ListChannelsOutputError>) -> Void)
    {
        let urlPath = "/prod/channels"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listChannels")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListChannelsInput, ListChannelsOutput, ListChannelsOutputError>(id: "listChannels")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListChannelsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListChannelsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListChannelsInput, ListChannelsOutput, ListChannelsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// List input devices that are currently being transferred. List input devices that you are transferring from your AWS account or input devices that another AWS account is transferring to you.
    public func listInputDeviceTransfers(input: ListInputDeviceTransfersInput, completion: @escaping (SdkResult<ListInputDeviceTransfersOutput, ListInputDeviceTransfersOutputError>) -> Void)
    {
        let urlPath = "/prod/inputDeviceTransfers"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listInputDeviceTransfers")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListInputDeviceTransfersInput, ListInputDeviceTransfersOutput, ListInputDeviceTransfersOutputError>(id: "listInputDeviceTransfers")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListInputDeviceTransfersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListInputDeviceTransfersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListInputDeviceTransfersInput, ListInputDeviceTransfersOutput, ListInputDeviceTransfersOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// List input devices
    public func listInputDevices(input: ListInputDevicesInput, completion: @escaping (SdkResult<ListInputDevicesOutput, ListInputDevicesOutputError>) -> Void)
    {
        let urlPath = "/prod/inputDevices"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listInputDevices")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListInputDevicesInput, ListInputDevicesOutput, ListInputDevicesOutputError>(id: "listInputDevices")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListInputDevicesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListInputDevicesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListInputDevicesInput, ListInputDevicesOutput, ListInputDevicesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Produces a list of Input Security Groups for an account
    public func listInputSecurityGroups(input: ListInputSecurityGroupsInput, completion: @escaping (SdkResult<ListInputSecurityGroupsOutput, ListInputSecurityGroupsOutputError>) -> Void)
    {
        let urlPath = "/prod/inputSecurityGroups"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listInputSecurityGroups")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListInputSecurityGroupsInput, ListInputSecurityGroupsOutput, ListInputSecurityGroupsOutputError>(id: "listInputSecurityGroups")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListInputSecurityGroupsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListInputSecurityGroupsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListInputSecurityGroupsInput, ListInputSecurityGroupsOutput, ListInputSecurityGroupsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Produces list of inputs that have been created
    public func listInputs(input: ListInputsInput, completion: @escaping (SdkResult<ListInputsOutput, ListInputsOutputError>) -> Void)
    {
        let urlPath = "/prod/inputs"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listInputs")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListInputsInput, ListInputsOutput, ListInputsOutputError>(id: "listInputs")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListInputsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListInputsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListInputsInput, ListInputsOutput, ListInputsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// List the programs that currently exist for a specific multiplex.
    public func listMultiplexPrograms(input: ListMultiplexProgramsInput, completion: @escaping (SdkResult<ListMultiplexProgramsOutput, ListMultiplexProgramsOutputError>) -> Void)
    {
        guard let multiplexId = input.multiplexId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component multiplexId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/multiplexes/\(multiplexId)/programs"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listMultiplexPrograms")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListMultiplexProgramsInput, ListMultiplexProgramsOutput, ListMultiplexProgramsOutputError>(id: "listMultiplexPrograms")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListMultiplexProgramsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListMultiplexProgramsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListMultiplexProgramsInput, ListMultiplexProgramsOutput, ListMultiplexProgramsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieve a list of the existing multiplexes.
    public func listMultiplexes(input: ListMultiplexesInput, completion: @escaping (SdkResult<ListMultiplexesOutput, ListMultiplexesOutputError>) -> Void)
    {
        let urlPath = "/prod/multiplexes"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listMultiplexes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListMultiplexesInput, ListMultiplexesOutput, ListMultiplexesOutputError>(id: "listMultiplexes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListMultiplexesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListMultiplexesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListMultiplexesInput, ListMultiplexesOutput, ListMultiplexesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// List offerings available for purchase.
    public func listOfferings(input: ListOfferingsInput, completion: @escaping (SdkResult<ListOfferingsOutput, ListOfferingsOutputError>) -> Void)
    {
        let urlPath = "/prod/offerings"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listOfferings")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListOfferingsInput, ListOfferingsOutput, ListOfferingsOutputError>(id: "listOfferings")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListOfferingsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListOfferingsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListOfferingsInput, ListOfferingsOutput, ListOfferingsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// List purchased reservations.
    public func listReservations(input: ListReservationsInput, completion: @escaping (SdkResult<ListReservationsOutput, ListReservationsOutputError>) -> Void)
    {
        let urlPath = "/prod/reservations"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listReservations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListReservationsInput, ListReservationsOutput, ListReservationsOutputError>(id: "listReservations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListReservationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListReservationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListReservationsInput, ListReservationsOutput, ListReservationsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Produces list of tags that have been created for a resource
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutput, ListTagsForResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutput, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutput, ListTagsForResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Purchase an offering and create a reservation.
    public func purchaseOffering(input: PurchaseOfferingInput, completion: @escaping (SdkResult<PurchaseOfferingOutput, PurchaseOfferingOutputError>) -> Void)
    {
        guard let offeringId = input.offeringId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component offeringId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/offerings/\(offeringId)/purchase"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "purchaseOffering")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PurchaseOfferingInput, PurchaseOfferingOutput, PurchaseOfferingOutputError>(id: "purchaseOffering")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<PurchaseOfferingOutput>, SdkError<PurchaseOfferingOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.requestId == nil {
                copiedInput.requestId = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: PurchaseOfferingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PurchaseOfferingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PurchaseOfferingInput, PurchaseOfferingOutput, PurchaseOfferingOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PurchaseOfferingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Reject the transfer of the specified input device to your AWS account.
    public func rejectInputDeviceTransfer(input: RejectInputDeviceTransferInput, completion: @escaping (SdkResult<RejectInputDeviceTransferOutput, RejectInputDeviceTransferOutputError>) -> Void)
    {
        guard let inputDeviceId = input.inputDeviceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component inputDeviceId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/inputDevices/\(inputDeviceId)/reject"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "rejectInputDeviceTransfer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RejectInputDeviceTransferInput, RejectInputDeviceTransferOutput, RejectInputDeviceTransferOutputError>(id: "rejectInputDeviceTransfer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RejectInputDeviceTransferInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RejectInputDeviceTransferInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RejectInputDeviceTransferInput, RejectInputDeviceTransferOutput, RejectInputDeviceTransferOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Starts an existing channel
    public func startChannel(input: StartChannelInput, completion: @escaping (SdkResult<StartChannelOutput, StartChannelOutputError>) -> Void)
    {
        guard let channelId = input.channelId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component channelId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/channels/\(channelId)/start"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startChannel")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartChannelInput, StartChannelOutput, StartChannelOutputError>(id: "startChannel")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StartChannelInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartChannelInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartChannelInput, StartChannelOutput, StartChannelOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Start (run) the multiplex. Starting the multiplex does not start the channels. You must explicitly start each channel.
    public func startMultiplex(input: StartMultiplexInput, completion: @escaping (SdkResult<StartMultiplexOutput, StartMultiplexOutputError>) -> Void)
    {
        guard let multiplexId = input.multiplexId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component multiplexId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/multiplexes/\(multiplexId)/start"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startMultiplex")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartMultiplexInput, StartMultiplexOutput, StartMultiplexOutputError>(id: "startMultiplex")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StartMultiplexInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartMultiplexInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartMultiplexInput, StartMultiplexOutput, StartMultiplexOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Stops a running channel
    public func stopChannel(input: StopChannelInput, completion: @escaping (SdkResult<StopChannelOutput, StopChannelOutputError>) -> Void)
    {
        guard let channelId = input.channelId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component channelId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/channels/\(channelId)/stop"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "stopChannel")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StopChannelInput, StopChannelOutput, StopChannelOutputError>(id: "stopChannel")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StopChannelInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StopChannelInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StopChannelInput, StopChannelOutput, StopChannelOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Stops a running multiplex. If the multiplex isn't running, this action has no effect.
    public func stopMultiplex(input: StopMultiplexInput, completion: @escaping (SdkResult<StopMultiplexOutput, StopMultiplexOutputError>) -> Void)
    {
        guard let multiplexId = input.multiplexId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component multiplexId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/multiplexes/\(multiplexId)/stop"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "stopMultiplex")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StopMultiplexInput, StopMultiplexOutput, StopMultiplexOutputError>(id: "stopMultiplex")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StopMultiplexInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StopMultiplexInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StopMultiplexInput, StopMultiplexOutput, StopMultiplexOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Start an input device transfer to another AWS account. After you make the request, the other account must accept or reject the transfer.
    public func transferInputDevice(input: TransferInputDeviceInput, completion: @escaping (SdkResult<TransferInputDeviceOutput, TransferInputDeviceOutputError>) -> Void)
    {
        guard let inputDeviceId = input.inputDeviceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component inputDeviceId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/inputDevices/\(inputDeviceId)/transfer"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "transferInputDevice")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TransferInputDeviceInput, TransferInputDeviceOutput, TransferInputDeviceOutputError>(id: "transferInputDevice")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TransferInputDeviceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TransferInputDeviceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TransferInputDeviceInput, TransferInputDeviceOutput, TransferInputDeviceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TransferInputDeviceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates a channel.
    public func updateChannel(input: UpdateChannelInput, completion: @escaping (SdkResult<UpdateChannelOutput, UpdateChannelOutputError>) -> Void)
    {
        guard let channelId = input.channelId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component channelId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/channels/\(channelId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateChannel")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateChannelInput, UpdateChannelOutput, UpdateChannelOutputError>(id: "updateChannel")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateChannelInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateChannelInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateChannelInput, UpdateChannelOutput, UpdateChannelOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateChannelInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Changes the class of the channel.
    public func updateChannelClass(input: UpdateChannelClassInput, completion: @escaping (SdkResult<UpdateChannelClassOutput, UpdateChannelClassOutputError>) -> Void)
    {
        guard let channelId = input.channelId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component channelId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/channels/\(channelId)/channelClass"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateChannelClass")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateChannelClassInput, UpdateChannelClassOutput, UpdateChannelClassOutputError>(id: "updateChannelClass")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateChannelClassInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateChannelClassInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateChannelClassInput, UpdateChannelClassOutput, UpdateChannelClassOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateChannelClassInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates an input.
    public func updateInput(input: UpdateInputInput, completion: @escaping (SdkResult<UpdateInputOutput, UpdateInputOutputError>) -> Void)
    {
        guard let inputId = input.inputId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component inputId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/inputs/\(inputId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateInput")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateInputInput, UpdateInputOutput, UpdateInputOutputError>(id: "updateInput")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateInputInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateInputInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateInputInput, UpdateInputOutput, UpdateInputOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateInputInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates the parameters for the input device.
    public func updateInputDevice(input: UpdateInputDeviceInput, completion: @escaping (SdkResult<UpdateInputDeviceOutput, UpdateInputDeviceOutputError>) -> Void)
    {
        guard let inputDeviceId = input.inputDeviceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component inputDeviceId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/inputDevices/\(inputDeviceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateInputDevice")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateInputDeviceInput, UpdateInputDeviceOutput, UpdateInputDeviceOutputError>(id: "updateInputDevice")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateInputDeviceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateInputDeviceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateInputDeviceInput, UpdateInputDeviceOutput, UpdateInputDeviceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateInputDeviceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Update an Input Security Group's Whilelists.
    public func updateInputSecurityGroup(input: UpdateInputSecurityGroupInput, completion: @escaping (SdkResult<UpdateInputSecurityGroupOutput, UpdateInputSecurityGroupOutputError>) -> Void)
    {
        guard let inputSecurityGroupId = input.inputSecurityGroupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component inputSecurityGroupId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/inputSecurityGroups/\(inputSecurityGroupId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateInputSecurityGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateInputSecurityGroupInput, UpdateInputSecurityGroupOutput, UpdateInputSecurityGroupOutputError>(id: "updateInputSecurityGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateInputSecurityGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateInputSecurityGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateInputSecurityGroupInput, UpdateInputSecurityGroupOutput, UpdateInputSecurityGroupOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateInputSecurityGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates a multiplex.
    public func updateMultiplex(input: UpdateMultiplexInput, completion: @escaping (SdkResult<UpdateMultiplexOutput, UpdateMultiplexOutputError>) -> Void)
    {
        guard let multiplexId = input.multiplexId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component multiplexId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/multiplexes/\(multiplexId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateMultiplex")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateMultiplexInput, UpdateMultiplexOutput, UpdateMultiplexOutputError>(id: "updateMultiplex")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateMultiplexInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateMultiplexInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateMultiplexInput, UpdateMultiplexOutput, UpdateMultiplexOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateMultiplexInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Update a program in a multiplex.
    public func updateMultiplexProgram(input: UpdateMultiplexProgramInput, completion: @escaping (SdkResult<UpdateMultiplexProgramOutput, UpdateMultiplexProgramOutputError>) -> Void)
    {
        guard let multiplexId = input.multiplexId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component multiplexId unexpectedly nil"))))
            return
        }
        guard let programName = input.programName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component programName unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/multiplexes/\(multiplexId)/programs/\(programName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateMultiplexProgram")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateMultiplexProgramInput, UpdateMultiplexProgramOutput, UpdateMultiplexProgramOutputError>(id: "updateMultiplexProgram")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateMultiplexProgramInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateMultiplexProgramInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateMultiplexProgramInput, UpdateMultiplexProgramOutput, UpdateMultiplexProgramOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateMultiplexProgramInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Update reservation.
    public func updateReservation(input: UpdateReservationInput, completion: @escaping (SdkResult<UpdateReservationOutput, UpdateReservationOutputError>) -> Void)
    {
        guard let reservationId = input.reservationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component reservationId unexpectedly nil"))))
            return
        }
        let urlPath = "/prod/reservations/\(reservationId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateReservation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "medialive.\(config.region).amazonaws.com")
                      .withSigningName(value: "medialive")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateReservationInput, UpdateReservationOutput, UpdateReservationOutputError>(id: "updateReservation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateReservationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateReservationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateReservationInput, UpdateReservationOutput, UpdateReservationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateReservationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
