// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension HlsGroupSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adMarkers = "adMarkers"
        case baseUrlContent = "baseUrlContent"
        case baseUrlContent1 = "baseUrlContent1"
        case baseUrlManifest = "baseUrlManifest"
        case baseUrlManifest1 = "baseUrlManifest1"
        case captionLanguageMappings = "captionLanguageMappings"
        case captionLanguageSetting = "captionLanguageSetting"
        case clientCache = "clientCache"
        case codecSpecification = "codecSpecification"
        case constantIv = "constantIv"
        case destination = "destination"
        case directoryStructure = "directoryStructure"
        case discontinuityTags = "discontinuityTags"
        case encryptionType = "encryptionType"
        case hlsCdnSettings = "hlsCdnSettings"
        case hlsId3SegmentTagging = "hlsId3SegmentTagging"
        case iFrameOnlyPlaylists = "iFrameOnlyPlaylists"
        case incompleteSegmentBehavior = "incompleteSegmentBehavior"
        case indexNSegments = "indexNSegments"
        case inputLossAction = "inputLossAction"
        case ivInManifest = "ivInManifest"
        case ivSource = "ivSource"
        case keepSegments = "keepSegments"
        case keyFormat = "keyFormat"
        case keyFormatVersions = "keyFormatVersions"
        case keyProviderSettings = "keyProviderSettings"
        case manifestCompression = "manifestCompression"
        case manifestDurationFormat = "manifestDurationFormat"
        case minSegmentLength = "minSegmentLength"
        case mode = "mode"
        case outputSelection = "outputSelection"
        case programDateTime = "programDateTime"
        case programDateTimePeriod = "programDateTimePeriod"
        case redundantManifest = "redundantManifest"
        case segmentLength = "segmentLength"
        case segmentationMode = "segmentationMode"
        case segmentsPerSubdirectory = "segmentsPerSubdirectory"
        case streamInfResolution = "streamInfResolution"
        case timedMetadataId3Frame = "timedMetadataId3Frame"
        case timedMetadataId3Period = "timedMetadataId3Period"
        case timestampDeltaMilliseconds = "timestampDeltaMilliseconds"
        case tsFileMode = "tsFileMode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adMarkers = adMarkers {
            var adMarkersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adMarkers)
            for __listofhlsadmarkers0 in adMarkers {
                try adMarkersContainer.encode(__listofhlsadmarkers0.rawValue)
            }
        }
        if let baseUrlContent = baseUrlContent {
            try encodeContainer.encode(baseUrlContent, forKey: .baseUrlContent)
        }
        if let baseUrlContent1 = baseUrlContent1 {
            try encodeContainer.encode(baseUrlContent1, forKey: .baseUrlContent1)
        }
        if let baseUrlManifest = baseUrlManifest {
            try encodeContainer.encode(baseUrlManifest, forKey: .baseUrlManifest)
        }
        if let baseUrlManifest1 = baseUrlManifest1 {
            try encodeContainer.encode(baseUrlManifest1, forKey: .baseUrlManifest1)
        }
        if let captionLanguageMappings = captionLanguageMappings {
            var captionLanguageMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .captionLanguageMappings)
            for __listofcaptionlanguagemapping0 in captionLanguageMappings {
                try captionLanguageMappingsContainer.encode(__listofcaptionlanguagemapping0)
            }
        }
        if let captionLanguageSetting = captionLanguageSetting {
            try encodeContainer.encode(captionLanguageSetting.rawValue, forKey: .captionLanguageSetting)
        }
        if let clientCache = clientCache {
            try encodeContainer.encode(clientCache.rawValue, forKey: .clientCache)
        }
        if let codecSpecification = codecSpecification {
            try encodeContainer.encode(codecSpecification.rawValue, forKey: .codecSpecification)
        }
        if let constantIv = constantIv {
            try encodeContainer.encode(constantIv, forKey: .constantIv)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let directoryStructure = directoryStructure {
            try encodeContainer.encode(directoryStructure.rawValue, forKey: .directoryStructure)
        }
        if let discontinuityTags = discontinuityTags {
            try encodeContainer.encode(discontinuityTags.rawValue, forKey: .discontinuityTags)
        }
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let hlsCdnSettings = hlsCdnSettings {
            try encodeContainer.encode(hlsCdnSettings, forKey: .hlsCdnSettings)
        }
        if let hlsId3SegmentTagging = hlsId3SegmentTagging {
            try encodeContainer.encode(hlsId3SegmentTagging.rawValue, forKey: .hlsId3SegmentTagging)
        }
        if let iFrameOnlyPlaylists = iFrameOnlyPlaylists {
            try encodeContainer.encode(iFrameOnlyPlaylists.rawValue, forKey: .iFrameOnlyPlaylists)
        }
        if let incompleteSegmentBehavior = incompleteSegmentBehavior {
            try encodeContainer.encode(incompleteSegmentBehavior.rawValue, forKey: .incompleteSegmentBehavior)
        }
        if indexNSegments != 0 {
            try encodeContainer.encode(indexNSegments, forKey: .indexNSegments)
        }
        if let inputLossAction = inputLossAction {
            try encodeContainer.encode(inputLossAction.rawValue, forKey: .inputLossAction)
        }
        if let ivInManifest = ivInManifest {
            try encodeContainer.encode(ivInManifest.rawValue, forKey: .ivInManifest)
        }
        if let ivSource = ivSource {
            try encodeContainer.encode(ivSource.rawValue, forKey: .ivSource)
        }
        if keepSegments != 0 {
            try encodeContainer.encode(keepSegments, forKey: .keepSegments)
        }
        if let keyFormat = keyFormat {
            try encodeContainer.encode(keyFormat, forKey: .keyFormat)
        }
        if let keyFormatVersions = keyFormatVersions {
            try encodeContainer.encode(keyFormatVersions, forKey: .keyFormatVersions)
        }
        if let keyProviderSettings = keyProviderSettings {
            try encodeContainer.encode(keyProviderSettings, forKey: .keyProviderSettings)
        }
        if let manifestCompression = manifestCompression {
            try encodeContainer.encode(manifestCompression.rawValue, forKey: .manifestCompression)
        }
        if let manifestDurationFormat = manifestDurationFormat {
            try encodeContainer.encode(manifestDurationFormat.rawValue, forKey: .manifestDurationFormat)
        }
        if minSegmentLength != 0 {
            try encodeContainer.encode(minSegmentLength, forKey: .minSegmentLength)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let outputSelection = outputSelection {
            try encodeContainer.encode(outputSelection.rawValue, forKey: .outputSelection)
        }
        if let programDateTime = programDateTime {
            try encodeContainer.encode(programDateTime.rawValue, forKey: .programDateTime)
        }
        if programDateTimePeriod != 0 {
            try encodeContainer.encode(programDateTimePeriod, forKey: .programDateTimePeriod)
        }
        if let redundantManifest = redundantManifest {
            try encodeContainer.encode(redundantManifest.rawValue, forKey: .redundantManifest)
        }
        if segmentLength != 0 {
            try encodeContainer.encode(segmentLength, forKey: .segmentLength)
        }
        if let segmentationMode = segmentationMode {
            try encodeContainer.encode(segmentationMode.rawValue, forKey: .segmentationMode)
        }
        if segmentsPerSubdirectory != 0 {
            try encodeContainer.encode(segmentsPerSubdirectory, forKey: .segmentsPerSubdirectory)
        }
        if let streamInfResolution = streamInfResolution {
            try encodeContainer.encode(streamInfResolution.rawValue, forKey: .streamInfResolution)
        }
        if let timedMetadataId3Frame = timedMetadataId3Frame {
            try encodeContainer.encode(timedMetadataId3Frame.rawValue, forKey: .timedMetadataId3Frame)
        }
        if timedMetadataId3Period != 0 {
            try encodeContainer.encode(timedMetadataId3Period, forKey: .timedMetadataId3Period)
        }
        if timestampDeltaMilliseconds != 0 {
            try encodeContainer.encode(timestampDeltaMilliseconds, forKey: .timestampDeltaMilliseconds)
        }
        if let tsFileMode = tsFileMode {
            try encodeContainer.encode(tsFileMode.rawValue, forKey: .tsFileMode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adMarkersContainer = try containerValues.decodeIfPresent([HlsAdMarkers?].self, forKey: .adMarkers)
        var adMarkersDecoded0:[HlsAdMarkers]? = nil
        if let adMarkersContainer = adMarkersContainer {
            adMarkersDecoded0 = [HlsAdMarkers]()
            for string0 in adMarkersContainer {
                if let string0 = string0 {
                    adMarkersDecoded0?.append(string0)
                }
            }
        }
        adMarkers = adMarkersDecoded0
        let baseUrlContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baseUrlContent)
        baseUrlContent = baseUrlContentDecoded
        let baseUrlContent1Decoded = try containerValues.decodeIfPresent(String.self, forKey: .baseUrlContent1)
        baseUrlContent1 = baseUrlContent1Decoded
        let baseUrlManifestDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baseUrlManifest)
        baseUrlManifest = baseUrlManifestDecoded
        let baseUrlManifest1Decoded = try containerValues.decodeIfPresent(String.self, forKey: .baseUrlManifest1)
        baseUrlManifest1 = baseUrlManifest1Decoded
        let captionLanguageMappingsContainer = try containerValues.decodeIfPresent([CaptionLanguageMapping?].self, forKey: .captionLanguageMappings)
        var captionLanguageMappingsDecoded0:[CaptionLanguageMapping]? = nil
        if let captionLanguageMappingsContainer = captionLanguageMappingsContainer {
            captionLanguageMappingsDecoded0 = [CaptionLanguageMapping]()
            for structure0 in captionLanguageMappingsContainer {
                if let structure0 = structure0 {
                    captionLanguageMappingsDecoded0?.append(structure0)
                }
            }
        }
        captionLanguageMappings = captionLanguageMappingsDecoded0
        let captionLanguageSettingDecoded = try containerValues.decodeIfPresent(HlsCaptionLanguageSetting.self, forKey: .captionLanguageSetting)
        captionLanguageSetting = captionLanguageSettingDecoded
        let clientCacheDecoded = try containerValues.decodeIfPresent(HlsClientCache.self, forKey: .clientCache)
        clientCache = clientCacheDecoded
        let codecSpecificationDecoded = try containerValues.decodeIfPresent(HlsCodecSpecification.self, forKey: .codecSpecification)
        codecSpecification = codecSpecificationDecoded
        let constantIvDecoded = try containerValues.decodeIfPresent(String.self, forKey: .constantIv)
        constantIv = constantIvDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(OutputLocationRef.self, forKey: .destination)
        destination = destinationDecoded
        let directoryStructureDecoded = try containerValues.decodeIfPresent(HlsDirectoryStructure.self, forKey: .directoryStructure)
        directoryStructure = directoryStructureDecoded
        let discontinuityTagsDecoded = try containerValues.decodeIfPresent(HlsDiscontinuityTags.self, forKey: .discontinuityTags)
        discontinuityTags = discontinuityTagsDecoded
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(HlsEncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let hlsCdnSettingsDecoded = try containerValues.decodeIfPresent(HlsCdnSettings.self, forKey: .hlsCdnSettings)
        hlsCdnSettings = hlsCdnSettingsDecoded
        let hlsId3SegmentTaggingDecoded = try containerValues.decodeIfPresent(HlsId3SegmentTaggingState.self, forKey: .hlsId3SegmentTagging)
        hlsId3SegmentTagging = hlsId3SegmentTaggingDecoded
        let iFrameOnlyPlaylistsDecoded = try containerValues.decodeIfPresent(IFrameOnlyPlaylistType.self, forKey: .iFrameOnlyPlaylists)
        iFrameOnlyPlaylists = iFrameOnlyPlaylistsDecoded
        let incompleteSegmentBehaviorDecoded = try containerValues.decodeIfPresent(HlsIncompleteSegmentBehavior.self, forKey: .incompleteSegmentBehavior)
        incompleteSegmentBehavior = incompleteSegmentBehaviorDecoded
        let indexNSegmentsDecoded = try containerValues.decode(Int.self, forKey: .indexNSegments)
        indexNSegments = indexNSegmentsDecoded
        let inputLossActionDecoded = try containerValues.decodeIfPresent(InputLossActionForHlsOut.self, forKey: .inputLossAction)
        inputLossAction = inputLossActionDecoded
        let ivInManifestDecoded = try containerValues.decodeIfPresent(HlsIvInManifest.self, forKey: .ivInManifest)
        ivInManifest = ivInManifestDecoded
        let ivSourceDecoded = try containerValues.decodeIfPresent(HlsIvSource.self, forKey: .ivSource)
        ivSource = ivSourceDecoded
        let keepSegmentsDecoded = try containerValues.decode(Int.self, forKey: .keepSegments)
        keepSegments = keepSegmentsDecoded
        let keyFormatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyFormat)
        keyFormat = keyFormatDecoded
        let keyFormatVersionsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyFormatVersions)
        keyFormatVersions = keyFormatVersionsDecoded
        let keyProviderSettingsDecoded = try containerValues.decodeIfPresent(KeyProviderSettings.self, forKey: .keyProviderSettings)
        keyProviderSettings = keyProviderSettingsDecoded
        let manifestCompressionDecoded = try containerValues.decodeIfPresent(HlsManifestCompression.self, forKey: .manifestCompression)
        manifestCompression = manifestCompressionDecoded
        let manifestDurationFormatDecoded = try containerValues.decodeIfPresent(HlsManifestDurationFormat.self, forKey: .manifestDurationFormat)
        manifestDurationFormat = manifestDurationFormatDecoded
        let minSegmentLengthDecoded = try containerValues.decode(Int.self, forKey: .minSegmentLength)
        minSegmentLength = minSegmentLengthDecoded
        let modeDecoded = try containerValues.decodeIfPresent(HlsMode.self, forKey: .mode)
        mode = modeDecoded
        let outputSelectionDecoded = try containerValues.decodeIfPresent(HlsOutputSelection.self, forKey: .outputSelection)
        outputSelection = outputSelectionDecoded
        let programDateTimeDecoded = try containerValues.decodeIfPresent(HlsProgramDateTime.self, forKey: .programDateTime)
        programDateTime = programDateTimeDecoded
        let programDateTimePeriodDecoded = try containerValues.decode(Int.self, forKey: .programDateTimePeriod)
        programDateTimePeriod = programDateTimePeriodDecoded
        let redundantManifestDecoded = try containerValues.decodeIfPresent(HlsRedundantManifest.self, forKey: .redundantManifest)
        redundantManifest = redundantManifestDecoded
        let segmentLengthDecoded = try containerValues.decode(Int.self, forKey: .segmentLength)
        segmentLength = segmentLengthDecoded
        let segmentationModeDecoded = try containerValues.decodeIfPresent(HlsSegmentationMode.self, forKey: .segmentationMode)
        segmentationMode = segmentationModeDecoded
        let segmentsPerSubdirectoryDecoded = try containerValues.decode(Int.self, forKey: .segmentsPerSubdirectory)
        segmentsPerSubdirectory = segmentsPerSubdirectoryDecoded
        let streamInfResolutionDecoded = try containerValues.decodeIfPresent(HlsStreamInfResolution.self, forKey: .streamInfResolution)
        streamInfResolution = streamInfResolutionDecoded
        let timedMetadataId3FrameDecoded = try containerValues.decodeIfPresent(HlsTimedMetadataId3Frame.self, forKey: .timedMetadataId3Frame)
        timedMetadataId3Frame = timedMetadataId3FrameDecoded
        let timedMetadataId3PeriodDecoded = try containerValues.decode(Int.self, forKey: .timedMetadataId3Period)
        timedMetadataId3Period = timedMetadataId3PeriodDecoded
        let timestampDeltaMillisecondsDecoded = try containerValues.decode(Int.self, forKey: .timestampDeltaMilliseconds)
        timestampDeltaMilliseconds = timestampDeltaMillisecondsDecoded
        let tsFileModeDecoded = try containerValues.decodeIfPresent(HlsTsFileMode.self, forKey: .tsFileMode)
        tsFileMode = tsFileModeDecoded
    }
}
