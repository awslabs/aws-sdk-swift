// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension MsSmoothGroupSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acquisitionPointId = "acquisitionPointId"
        case audioOnlyTimecodeControl = "audioOnlyTimecodeControl"
        case certificateMode = "certificateMode"
        case connectionRetryInterval = "connectionRetryInterval"
        case destination = "destination"
        case eventId = "eventId"
        case eventIdMode = "eventIdMode"
        case eventStopBehavior = "eventStopBehavior"
        case filecacheDuration = "filecacheDuration"
        case fragmentLength = "fragmentLength"
        case inputLossAction = "inputLossAction"
        case numRetries = "numRetries"
        case restartDelay = "restartDelay"
        case segmentationMode = "segmentationMode"
        case sendDelayMs = "sendDelayMs"
        case sparseTrackType = "sparseTrackType"
        case streamManifestBehavior = "streamManifestBehavior"
        case timestampOffset = "timestampOffset"
        case timestampOffsetMode = "timestampOffsetMode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acquisitionPointId = acquisitionPointId {
            try encodeContainer.encode(acquisitionPointId, forKey: .acquisitionPointId)
        }
        if let audioOnlyTimecodeControl = audioOnlyTimecodeControl {
            try encodeContainer.encode(audioOnlyTimecodeControl.rawValue, forKey: .audioOnlyTimecodeControl)
        }
        if let certificateMode = certificateMode {
            try encodeContainer.encode(certificateMode.rawValue, forKey: .certificateMode)
        }
        if connectionRetryInterval != 0 {
            try encodeContainer.encode(connectionRetryInterval, forKey: .connectionRetryInterval)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventIdMode = eventIdMode {
            try encodeContainer.encode(eventIdMode.rawValue, forKey: .eventIdMode)
        }
        if let eventStopBehavior = eventStopBehavior {
            try encodeContainer.encode(eventStopBehavior.rawValue, forKey: .eventStopBehavior)
        }
        if filecacheDuration != 0 {
            try encodeContainer.encode(filecacheDuration, forKey: .filecacheDuration)
        }
        if fragmentLength != 0 {
            try encodeContainer.encode(fragmentLength, forKey: .fragmentLength)
        }
        if let inputLossAction = inputLossAction {
            try encodeContainer.encode(inputLossAction.rawValue, forKey: .inputLossAction)
        }
        if numRetries != 0 {
            try encodeContainer.encode(numRetries, forKey: .numRetries)
        }
        if restartDelay != 0 {
            try encodeContainer.encode(restartDelay, forKey: .restartDelay)
        }
        if let segmentationMode = segmentationMode {
            try encodeContainer.encode(segmentationMode.rawValue, forKey: .segmentationMode)
        }
        if sendDelayMs != 0 {
            try encodeContainer.encode(sendDelayMs, forKey: .sendDelayMs)
        }
        if let sparseTrackType = sparseTrackType {
            try encodeContainer.encode(sparseTrackType.rawValue, forKey: .sparseTrackType)
        }
        if let streamManifestBehavior = streamManifestBehavior {
            try encodeContainer.encode(streamManifestBehavior.rawValue, forKey: .streamManifestBehavior)
        }
        if let timestampOffset = timestampOffset {
            try encodeContainer.encode(timestampOffset, forKey: .timestampOffset)
        }
        if let timestampOffsetMode = timestampOffsetMode {
            try encodeContainer.encode(timestampOffsetMode.rawValue, forKey: .timestampOffsetMode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acquisitionPointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acquisitionPointId)
        acquisitionPointId = acquisitionPointIdDecoded
        let audioOnlyTimecodeControlDecoded = try containerValues.decodeIfPresent(SmoothGroupAudioOnlyTimecodeControl.self, forKey: .audioOnlyTimecodeControl)
        audioOnlyTimecodeControl = audioOnlyTimecodeControlDecoded
        let certificateModeDecoded = try containerValues.decodeIfPresent(SmoothGroupCertificateMode.self, forKey: .certificateMode)
        certificateMode = certificateModeDecoded
        let connectionRetryIntervalDecoded = try containerValues.decode(Int.self, forKey: .connectionRetryInterval)
        connectionRetryInterval = connectionRetryIntervalDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(OutputLocationRef.self, forKey: .destination)
        destination = destinationDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventIdModeDecoded = try containerValues.decodeIfPresent(SmoothGroupEventIdMode.self, forKey: .eventIdMode)
        eventIdMode = eventIdModeDecoded
        let eventStopBehaviorDecoded = try containerValues.decodeIfPresent(SmoothGroupEventStopBehavior.self, forKey: .eventStopBehavior)
        eventStopBehavior = eventStopBehaviorDecoded
        let filecacheDurationDecoded = try containerValues.decode(Int.self, forKey: .filecacheDuration)
        filecacheDuration = filecacheDurationDecoded
        let fragmentLengthDecoded = try containerValues.decode(Int.self, forKey: .fragmentLength)
        fragmentLength = fragmentLengthDecoded
        let inputLossActionDecoded = try containerValues.decodeIfPresent(InputLossActionForMsSmoothOut.self, forKey: .inputLossAction)
        inputLossAction = inputLossActionDecoded
        let numRetriesDecoded = try containerValues.decode(Int.self, forKey: .numRetries)
        numRetries = numRetriesDecoded
        let restartDelayDecoded = try containerValues.decode(Int.self, forKey: .restartDelay)
        restartDelay = restartDelayDecoded
        let segmentationModeDecoded = try containerValues.decodeIfPresent(SmoothGroupSegmentationMode.self, forKey: .segmentationMode)
        segmentationMode = segmentationModeDecoded
        let sendDelayMsDecoded = try containerValues.decode(Int.self, forKey: .sendDelayMs)
        sendDelayMs = sendDelayMsDecoded
        let sparseTrackTypeDecoded = try containerValues.decodeIfPresent(SmoothGroupSparseTrackType.self, forKey: .sparseTrackType)
        sparseTrackType = sparseTrackTypeDecoded
        let streamManifestBehaviorDecoded = try containerValues.decodeIfPresent(SmoothGroupStreamManifestBehavior.self, forKey: .streamManifestBehavior)
        streamManifestBehavior = streamManifestBehaviorDecoded
        let timestampOffsetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timestampOffset)
        timestampOffset = timestampOffsetDecoded
        let timestampOffsetModeDecoded = try containerValues.decodeIfPresent(SmoothGroupTimestampOffsetMode.self, forKey: .timestampOffsetMode)
        timestampOffsetMode = timestampOffsetModeDecoded
    }
}
