// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension AudioDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case audioNormalizationSettings = "audioNormalizationSettings"
        case audioSelectorName = "audioSelectorName"
        case audioType = "audioType"
        case audioTypeControl = "audioTypeControl"
        case codecSettings = "codecSettings"
        case languageCode = "languageCode"
        case languageCodeControl = "languageCodeControl"
        case name = "name"
        case remixSettings = "remixSettings"
        case streamName = "streamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioNormalizationSettings = audioNormalizationSettings {
            try encodeContainer.encode(audioNormalizationSettings, forKey: .audioNormalizationSettings)
        }
        if let audioSelectorName = audioSelectorName {
            try encodeContainer.encode(audioSelectorName, forKey: .audioSelectorName)
        }
        if let audioType = audioType {
            try encodeContainer.encode(audioType.rawValue, forKey: .audioType)
        }
        if let audioTypeControl = audioTypeControl {
            try encodeContainer.encode(audioTypeControl.rawValue, forKey: .audioTypeControl)
        }
        if let codecSettings = codecSettings {
            try encodeContainer.encode(codecSettings, forKey: .codecSettings)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode, forKey: .languageCode)
        }
        if let languageCodeControl = languageCodeControl {
            try encodeContainer.encode(languageCodeControl.rawValue, forKey: .languageCodeControl)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let remixSettings = remixSettings {
            try encodeContainer.encode(remixSettings, forKey: .remixSettings)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioNormalizationSettingsDecoded = try containerValues.decodeIfPresent(AudioNormalizationSettings.self, forKey: .audioNormalizationSettings)
        audioNormalizationSettings = audioNormalizationSettingsDecoded
        let audioSelectorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .audioSelectorName)
        audioSelectorName = audioSelectorNameDecoded
        let audioTypeDecoded = try containerValues.decodeIfPresent(AudioType.self, forKey: .audioType)
        audioType = audioTypeDecoded
        let audioTypeControlDecoded = try containerValues.decodeIfPresent(AudioDescriptionAudioTypeControl.self, forKey: .audioTypeControl)
        audioTypeControl = audioTypeControlDecoded
        let codecSettingsDecoded = try containerValues.decodeIfPresent(AudioCodecSettings.self, forKey: .codecSettings)
        codecSettings = codecSettingsDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let languageCodeControlDecoded = try containerValues.decodeIfPresent(AudioDescriptionLanguageCodeControl.self, forKey: .languageCodeControl)
        languageCodeControl = languageCodeControlDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let remixSettingsDecoded = try containerValues.decodeIfPresent(RemixSettings.self, forKey: .remixSettings)
        remixSettings = remixSettingsDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
    }
}
