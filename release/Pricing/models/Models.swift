// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AttributeValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AttributeValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttributeValue(value: \(String(describing: value)))"}
}

/// <p>The values of a given attribute, such as <code>Throughput Optimized HDD</code> or <code>Provisioned
///           IOPS</code> for the <code>Amazon EC2</code>
///             <code>volumeType</code> attribute.</p>
public struct AttributeValue: Equatable {
    /// <p>The specific value of an <code>attributeName</code>.</p>
    public let value: String?

    public init (
        value: String? = nil
    )
    {
        self.value = value
    }
}

public struct DescribeServicesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeServicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServicesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServicesInput>
    public typealias MOutput = OperationOutput<DescribeServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServicesOutputError>
}

extension DescribeServicesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeServicesInput(formatVersion: \(String(describing: formatVersion)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), serviceCode: \(String(describing: serviceCode)))"}
}

extension DescribeServicesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case formatVersion = "FormatVersion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let formatVersion = formatVersion {
            try encodeContainer.encode(formatVersion, forKey: .formatVersion)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct DescribeServicesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeServicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServicesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServicesInput>
    public typealias MOutput = OperationOutput<DescribeServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServicesOutputError>
}

public struct DescribeServicesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeServicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServicesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServicesInput>
    public typealias MOutput = OperationOutput<DescribeServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServicesOutputError>
}

public struct DescribeServicesInput: Equatable {
    /// <p>The format version that you want the response to be in.</p>
    ///          <p>Valid values are: <code>aws_v1</code>
    ///          </p>
    public let formatVersion: String?
    /// <p>The maximum number of results that you want returned in the response.</p>
    public let maxResults: Int
    /// <p>The pagination token that indicates the next set of results that you want to retrieve.</p>
    public let nextToken: String?
    /// <p>The code for the service whose information you want to retrieve, such as <code>AmazonEC2</code>.
    ///           You can use
    ///          the <code>ServiceCode</code> to filter the results in a <code>GetProducts</code> call.
    ///       To retrieve a list of all services, leave this blank.</p>
    public let serviceCode: String?

    public init (
        formatVersion: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        serviceCode: String? = nil
    )
    {
        self.formatVersion = formatVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

struct DescribeServicesInputBody: Equatable {
    public let serviceCode: String?
    public let formatVersion: String?
    public let nextToken: String?
    public let maxResults: Int
}

extension DescribeServicesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case formatVersion = "FormatVersion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let formatVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .formatVersion)
        formatVersion = formatVersionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeServicesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeServicesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ExpiredNextTokenException" : self = .expiredNextTokenException(try ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeServicesOutputError: Equatable {
    case expiredNextTokenException(ExpiredNextTokenException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServicesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeServicesOutputResponse(formatVersion: \(String(describing: formatVersion)), nextToken: \(String(describing: nextToken)), services: \(String(describing: services)))"}
}

extension DescribeServicesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeServicesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.formatVersion = output.formatVersion
            self.nextToken = output.nextToken
            self.services = output.services
        } else {
            self.formatVersion = nil
            self.nextToken = nil
            self.services = nil
        }
    }
}

public struct DescribeServicesOutputResponse: Equatable {
    /// <p>The format version of the response. For example, <code>aws_v1</code>.</p>
    public let formatVersion: String?
    /// <p>The pagination token for the next set of retreivable results.</p>
    public let nextToken: String?
    /// <p>The service metadata for the service or services in the response.</p>
    public let services: [Service]?

    public init (
        formatVersion: String? = nil,
        nextToken: String? = nil,
        services: [Service]? = nil
    )
    {
        self.formatVersion = formatVersion
        self.nextToken = nextToken
        self.services = services
    }
}

struct DescribeServicesOutputResponseBody: Equatable {
    public let services: [Service]?
    public let formatVersion: String?
    public let nextToken: String?
}

extension DescribeServicesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case formatVersion = "FormatVersion"
        case nextToken = "NextToken"
        case services = "Services"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let servicesContainer = try containerValues.decodeIfPresent([Service?].self, forKey: .services)
        var servicesDecoded0:[Service]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [Service]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
        let formatVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .formatVersion)
        formatVersion = formatVersionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ExpiredNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExpiredNextTokenException(message: \(String(describing: message)))"}
}

extension ExpiredNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExpiredNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pagination token expired. Try again without a pagination token.</p>
public struct ExpiredNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ExpiredNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension ExpiredNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Filter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case field = "Field"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let field = field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(FilterType.self, forKey: .type)
        type = typeDecoded
        let fieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .field)
        field = fieldDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Filter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Filter(field: \(String(describing: field)), type: \(String(describing: type)), value: \(String(describing: value)))"}
}

/// <p>The constraints that you want all returned products to match.</p>
public struct Filter: Equatable {
    /// <p>The product metadata field that you want to filter on. You can filter by just the
    ///          service code to see all products for a specific service, filter
    ///          by just the attribute name to see a specific attribute for multiple services, or use both a service code
    ///          and an attribute name to retrieve only products that match both fields.</p>
    ///          <p>Valid values include: <code>ServiceCode</code>, and all attribute names</p>
    ///
    ///          <p>For example, you can filter by the <code>AmazonEC2</code> service code and the
    ///          <code>volumeType</code> attribute name to get the prices for only Amazon EC2 volumes.</p>
    public let field: String?
    /// <p>The type of filter that you want to use.</p>
    ///          <p>Valid values are: <code>TERM_MATCH</code>. <code>TERM_MATCH</code> returns only
    ///          products that match both the given filter field and the given value.</p>
    public let type: FilterType?
    /// <p>The service code or attribute value that you want to filter by. If you are filtering by
    ///          service code this is the actual service code, such as <code>AmazonEC2</code>. If you are
    ///          filtering by attribute name, this is the attribute value that you want the returned products
    ///          to match, such as a <code>Provisioned IOPS</code> volume.</p>
    public let value: String?

    public init (
        field: String? = nil,
        type: FilterType? = nil,
        value: String? = nil
    )
    {
        self.field = field
        self.type = type
        self.value = value
    }
}

public enum FilterType {
    case termMatch
    case sdkUnknown(String)
}

extension FilterType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FilterType] {
        return [
            .termMatch,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .termMatch: return "TERM_MATCH"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FilterType(rawValue: rawValue) ?? FilterType.sdkUnknown(rawValue)
    }
}

public struct GetAttributeValuesInputBodyMiddleware: Middleware {
    public let id: String = "GetAttributeValuesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAttributeValuesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAttributeValuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAttributeValuesInput>
    public typealias MOutput = OperationOutput<GetAttributeValuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAttributeValuesOutputError>
}

extension GetAttributeValuesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAttributeValuesInput(attributeName: \(String(describing: attributeName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), serviceCode: \(String(describing: serviceCode)))"}
}

extension GetAttributeValuesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "AttributeName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct GetAttributeValuesInputHeadersMiddleware: Middleware {
    public let id: String = "GetAttributeValuesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAttributeValuesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAttributeValuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAttributeValuesInput>
    public typealias MOutput = OperationOutput<GetAttributeValuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAttributeValuesOutputError>
}

public struct GetAttributeValuesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAttributeValuesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAttributeValuesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAttributeValuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAttributeValuesInput>
    public typealias MOutput = OperationOutput<GetAttributeValuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAttributeValuesOutputError>
}

public struct GetAttributeValuesInput: Equatable {
    /// <p>The name of the attribute that you want to retrieve the values for, such as <code>volumeType</code>.</p>
    public let attributeName: String?
    /// <p>The maximum number of results to return in response.</p>
    public let maxResults: Int
    /// <p>The pagination token that indicates the next set of results that you want to retrieve.</p>
    public let nextToken: String?
    /// <p>The service code for the service whose attributes you want to retrieve. For example, if you want
    ///           the retrieve an EC2 attribute, use <code>AmazonEC2</code>.</p>
    public let serviceCode: String?

    public init (
        attributeName: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        serviceCode: String? = nil
    )
    {
        self.attributeName = attributeName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

struct GetAttributeValuesInputBody: Equatable {
    public let serviceCode: String?
    public let attributeName: String?
    public let nextToken: String?
    public let maxResults: Int
}

extension GetAttributeValuesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributeName = "AttributeName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetAttributeValuesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAttributeValuesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ExpiredNextTokenException" : self = .expiredNextTokenException(try ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAttributeValuesOutputError: Equatable {
    case expiredNextTokenException(ExpiredNextTokenException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAttributeValuesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAttributeValuesOutputResponse(attributeValues: \(String(describing: attributeValues)), nextToken: \(String(describing: nextToken)))"}
}

extension GetAttributeValuesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAttributeValuesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributeValues = output.attributeValues
            self.nextToken = output.nextToken
        } else {
            self.attributeValues = nil
            self.nextToken = nil
        }
    }
}

public struct GetAttributeValuesOutputResponse: Equatable {
    /// <p>The list of values for an attribute. For example, <code>Throughput Optimized HDD</code> and
    ///       <code>Provisioned IOPS</code> are two available values for the <code>AmazonEC2</code>
    ///             <code>volumeType</code>.</p>
    public let attributeValues: [AttributeValue]?
    /// <p>The pagination token that indicates the next set of results to retrieve.</p>
    public let nextToken: String?

    public init (
        attributeValues: [AttributeValue]? = nil,
        nextToken: String? = nil
    )
    {
        self.attributeValues = attributeValues
        self.nextToken = nextToken
    }
}

struct GetAttributeValuesOutputResponseBody: Equatable {
    public let attributeValues: [AttributeValue]?
    public let nextToken: String?
}

extension GetAttributeValuesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributeValues = "AttributeValues"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeValuesContainer = try containerValues.decodeIfPresent([AttributeValue?].self, forKey: .attributeValues)
        var attributeValuesDecoded0:[AttributeValue]? = nil
        if let attributeValuesContainer = attributeValuesContainer {
            attributeValuesDecoded0 = [AttributeValue]()
            for structure0 in attributeValuesContainer {
                if let structure0 = structure0 {
                    attributeValuesDecoded0?.append(structure0)
                }
            }
        }
        attributeValues = attributeValuesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetProductsInputBodyMiddleware: Middleware {
    public let id: String = "GetProductsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProductsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProductsInput>
    public typealias MOutput = OperationOutput<GetProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProductsOutputError>
}

extension GetProductsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetProductsInput(filters: \(String(describing: filters)), formatVersion: \(String(describing: formatVersion)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), serviceCode: \(String(describing: serviceCode)))"}
}

extension GetProductsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case formatVersion = "FormatVersion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let formatVersion = formatVersion {
            try encodeContainer.encode(formatVersion, forKey: .formatVersion)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct GetProductsInputHeadersMiddleware: Middleware {
    public let id: String = "GetProductsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProductsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProductsInput>
    public typealias MOutput = OperationOutput<GetProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProductsOutputError>
}

public struct GetProductsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetProductsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProductsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProductsInput>
    public typealias MOutput = OperationOutput<GetProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProductsOutputError>
}

public struct GetProductsInput: Equatable {
    /// <p>The list of filters that limit the returned products. only products that match all filters
    ///          are returned.</p>
    public let filters: [Filter]?
    /// <p>The format version that you want the response to be in.</p>
    ///          <p>Valid values are: <code>aws_v1</code>
    ///          </p>
    public let formatVersion: String?
    /// <p>The maximum number of results to return in the response.</p>
    public let maxResults: Int
    /// <p>The pagination token that indicates the next set of results that you want to retrieve.</p>
    public let nextToken: String?
    /// <p>The code for the service whose products you want to retrieve. </p>
    public let serviceCode: String?

    public init (
        filters: [Filter]? = nil,
        formatVersion: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        serviceCode: String? = nil
    )
    {
        self.filters = filters
        self.formatVersion = formatVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

struct GetProductsInputBody: Equatable {
    public let serviceCode: String?
    public let filters: [Filter]?
    public let formatVersion: String?
    public let nextToken: String?
    public let maxResults: Int
}

extension GetProductsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case formatVersion = "FormatVersion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let formatVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .formatVersion)
        formatVersion = formatVersionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetProductsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProductsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ExpiredNextTokenException" : self = .expiredNextTokenException(try ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProductsOutputError: Equatable {
    case expiredNextTokenException(ExpiredNextTokenException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProductsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetProductsOutputResponse(formatVersion: \(String(describing: formatVersion)), nextToken: \(String(describing: nextToken)), priceList: \(String(describing: priceList)))"}
}

extension GetProductsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetProductsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.formatVersion = output.formatVersion
            self.nextToken = output.nextToken
            self.priceList = output.priceList
        } else {
            self.formatVersion = nil
            self.nextToken = nil
            self.priceList = nil
        }
    }
}

public struct GetProductsOutputResponse: Equatable {
    /// <p>The format version of the response. For example, aws_v1.</p>
    public let formatVersion: String?
    /// <p>The pagination token that indicates the next set of results to retrieve.</p>
    public let nextToken: String?
    /// <p>The list of products that match your filters. The list contains both the product metadata and
    ///          the price information.</p>
    public let priceList: [String]?

    public init (
        formatVersion: String? = nil,
        nextToken: String? = nil,
        priceList: [String]? = nil
    )
    {
        self.formatVersion = formatVersion
        self.nextToken = nextToken
        self.priceList = priceList
    }
}

struct GetProductsOutputResponseBody: Equatable {
    public let formatVersion: String?
    public let priceList: [String]?
    public let nextToken: String?
}

extension GetProductsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case formatVersion = "FormatVersion"
        case nextToken = "NextToken"
        case priceList = "PriceList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .formatVersion)
        formatVersion = formatVersionDecoded
        let priceListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .priceList)
        var priceListDecoded0:[String]? = nil
        if let priceListContainer = priceListContainer {
            priceListDecoded0 = [String]()
            for string0 in priceListContainer {
                if let string0 = string0 {
                    priceListDecoded0?.append(string0)
                }
            }
        }
        priceList = priceListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension InternalErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalErrorException(message: \(String(describing: message)))"}
}

extension InternalErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error on the server occurred during the processing of your request. Try again later.</p>
public struct InternalErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalErrorExceptionBody: Equatable {
    public let message: String?
}

extension InternalErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pagination token is invalid. Try again without a pagination token.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(message: \(String(describing: message)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more parameters had an invalid value.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested resource can't be found.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Service: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeNames = "AttributeNames"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeNames = attributeNames {
            var attributeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeNames)
            for attributenamelist0 in attributeNames {
                try attributeNamesContainer.encode(attributenamelist0)
            }
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let attributeNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .attributeNames)
        var attributeNamesDecoded0:[String]? = nil
        if let attributeNamesContainer = attributeNamesContainer {
            attributeNamesDecoded0 = [String]()
            for string0 in attributeNamesContainer {
                if let string0 = string0 {
                    attributeNamesDecoded0?.append(string0)
                }
            }
        }
        attributeNames = attributeNamesDecoded0
    }
}

extension Service: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Service(attributeNames: \(String(describing: attributeNames)), serviceCode: \(String(describing: serviceCode)))"}
}

/// <p>The metadata for a service, such as the service code and available attribute names.</p>
public struct Service: Equatable {
    /// <p>The attributes that are available for this service.</p>
    public let attributeNames: [String]?
    /// <p>The code for the AWS service.</p>
    public let serviceCode: String?

    public init (
        attributeNames: [String]? = nil,
        serviceCode: String? = nil
    )
    {
        self.attributeNames = attributeNames
        self.serviceCode = serviceCode
    }
}
