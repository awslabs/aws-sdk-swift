// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[DescribeAddressesAttributeOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeAddressesAttributeInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeAddressesAttributeOutputResponse`
extension EC2Client {
    public func describeAddressesAttributePaginated(input: DescribeAddressesAttributeInput) -> ClientRuntime.PaginatorSequence<DescribeAddressesAttributeInput, DescribeAddressesAttributeOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeAddressesAttributeInput, DescribeAddressesAttributeOutputResponse>(input: input, inputKey: \DescribeAddressesAttributeInput.nextToken, outputKey: \DescribeAddressesAttributeOutputResponse.nextToken, paginationFunction: self.describeAddressesAttribute(input:))
    }
}

extension DescribeAddressesAttributeInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAddressesAttributeInput {
        return DescribeAddressesAttributeInput(
            allocationIds: self.allocationIds,
            attribute: self.attribute,
            dryRun: self.dryRun,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeAddressesAttributePaginated`
/// to access the nested member `[EC2ClientTypes.AddressAttribute]`
/// - Returns: `[EC2ClientTypes.AddressAttribute]`
extension PaginatorSequence where Input == DescribeAddressesAttributeInput, Output == DescribeAddressesAttributeOutputResponse {
    public func addresses() async throws -> [EC2ClientTypes.AddressAttribute] {
        return try await self.asyncCompactMap { item in item.addresses }
    }
}

/// Paginate over `[DescribeAddressTransfersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeAddressTransfersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeAddressTransfersOutputResponse`
extension EC2Client {
    public func describeAddressTransfersPaginated(input: DescribeAddressTransfersInput) -> ClientRuntime.PaginatorSequence<DescribeAddressTransfersInput, DescribeAddressTransfersOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeAddressTransfersInput, DescribeAddressTransfersOutputResponse>(input: input, inputKey: \DescribeAddressTransfersInput.nextToken, outputKey: \DescribeAddressTransfersOutputResponse.nextToken, paginationFunction: self.describeAddressTransfers(input:))
    }
}

extension DescribeAddressTransfersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAddressTransfersInput {
        return DescribeAddressTransfersInput(
            allocationIds: self.allocationIds,
            dryRun: self.dryRun,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeAddressTransfersPaginated`
/// to access the nested member `[EC2ClientTypes.AddressTransfer]`
/// - Returns: `[EC2ClientTypes.AddressTransfer]`
extension PaginatorSequence where Input == DescribeAddressTransfersInput, Output == DescribeAddressTransfersOutputResponse {
    public func addressTransfers() async throws -> [EC2ClientTypes.AddressTransfer] {
        return try await self.asyncCompactMap { item in item.addressTransfers }
    }
}

/// Paginate over `[DescribeAwsNetworkPerformanceMetricSubscriptionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeAwsNetworkPerformanceMetricSubscriptionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeAwsNetworkPerformanceMetricSubscriptionsOutputResponse`
extension EC2Client {
    public func describeAwsNetworkPerformanceMetricSubscriptionsPaginated(input: DescribeAwsNetworkPerformanceMetricSubscriptionsInput) -> ClientRuntime.PaginatorSequence<DescribeAwsNetworkPerformanceMetricSubscriptionsInput, DescribeAwsNetworkPerformanceMetricSubscriptionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeAwsNetworkPerformanceMetricSubscriptionsInput, DescribeAwsNetworkPerformanceMetricSubscriptionsOutputResponse>(input: input, inputKey: \DescribeAwsNetworkPerformanceMetricSubscriptionsInput.nextToken, outputKey: \DescribeAwsNetworkPerformanceMetricSubscriptionsOutputResponse.nextToken, paginationFunction: self.describeAwsNetworkPerformanceMetricSubscriptions(input:))
    }
}

extension DescribeAwsNetworkPerformanceMetricSubscriptionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAwsNetworkPerformanceMetricSubscriptionsInput {
        return DescribeAwsNetworkPerformanceMetricSubscriptionsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeAwsNetworkPerformanceMetricSubscriptionsPaginated`
/// to access the nested member `[EC2ClientTypes.Subscription]`
/// - Returns: `[EC2ClientTypes.Subscription]`
extension PaginatorSequence where Input == DescribeAwsNetworkPerformanceMetricSubscriptionsInput, Output == DescribeAwsNetworkPerformanceMetricSubscriptionsOutputResponse {
    public func subscriptions() async throws -> [EC2ClientTypes.Subscription] {
        return try await self.asyncCompactMap { item in item.subscriptions }
    }
}

/// Paginate over `[DescribeByoipCidrsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeByoipCidrsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeByoipCidrsOutputResponse`
extension EC2Client {
    public func describeByoipCidrsPaginated(input: DescribeByoipCidrsInput) -> ClientRuntime.PaginatorSequence<DescribeByoipCidrsInput, DescribeByoipCidrsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeByoipCidrsInput, DescribeByoipCidrsOutputResponse>(input: input, inputKey: \DescribeByoipCidrsInput.nextToken, outputKey: \DescribeByoipCidrsOutputResponse.nextToken, paginationFunction: self.describeByoipCidrs(input:))
    }
}

extension DescribeByoipCidrsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeByoipCidrsInput {
        return DescribeByoipCidrsInput(
            dryRun: self.dryRun,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeByoipCidrsPaginated`
/// to access the nested member `[EC2ClientTypes.ByoipCidr]`
/// - Returns: `[EC2ClientTypes.ByoipCidr]`
extension PaginatorSequence where Input == DescribeByoipCidrsInput, Output == DescribeByoipCidrsOutputResponse {
    public func byoipCidrs() async throws -> [EC2ClientTypes.ByoipCidr] {
        return try await self.asyncCompactMap { item in item.byoipCidrs }
    }
}

/// Paginate over `[DescribeCapacityReservationFleetsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeCapacityReservationFleetsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeCapacityReservationFleetsOutputResponse`
extension EC2Client {
    public func describeCapacityReservationFleetsPaginated(input: DescribeCapacityReservationFleetsInput) -> ClientRuntime.PaginatorSequence<DescribeCapacityReservationFleetsInput, DescribeCapacityReservationFleetsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeCapacityReservationFleetsInput, DescribeCapacityReservationFleetsOutputResponse>(input: input, inputKey: \DescribeCapacityReservationFleetsInput.nextToken, outputKey: \DescribeCapacityReservationFleetsOutputResponse.nextToken, paginationFunction: self.describeCapacityReservationFleets(input:))
    }
}

extension DescribeCapacityReservationFleetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeCapacityReservationFleetsInput {
        return DescribeCapacityReservationFleetsInput(
            capacityReservationFleetIds: self.capacityReservationFleetIds,
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeCapacityReservationFleetsPaginated`
/// to access the nested member `[EC2ClientTypes.CapacityReservationFleet]`
/// - Returns: `[EC2ClientTypes.CapacityReservationFleet]`
extension PaginatorSequence where Input == DescribeCapacityReservationFleetsInput, Output == DescribeCapacityReservationFleetsOutputResponse {
    public func capacityReservationFleets() async throws -> [EC2ClientTypes.CapacityReservationFleet] {
        return try await self.asyncCompactMap { item in item.capacityReservationFleets }
    }
}

/// Paginate over `[DescribeCapacityReservationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeCapacityReservationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeCapacityReservationsOutputResponse`
extension EC2Client {
    public func describeCapacityReservationsPaginated(input: DescribeCapacityReservationsInput) -> ClientRuntime.PaginatorSequence<DescribeCapacityReservationsInput, DescribeCapacityReservationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeCapacityReservationsInput, DescribeCapacityReservationsOutputResponse>(input: input, inputKey: \DescribeCapacityReservationsInput.nextToken, outputKey: \DescribeCapacityReservationsOutputResponse.nextToken, paginationFunction: self.describeCapacityReservations(input:))
    }
}

extension DescribeCapacityReservationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeCapacityReservationsInput {
        return DescribeCapacityReservationsInput(
            capacityReservationIds: self.capacityReservationIds,
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeCapacityReservationsPaginated`
/// to access the nested member `[EC2ClientTypes.CapacityReservation]`
/// - Returns: `[EC2ClientTypes.CapacityReservation]`
extension PaginatorSequence where Input == DescribeCapacityReservationsInput, Output == DescribeCapacityReservationsOutputResponse {
    public func capacityReservations() async throws -> [EC2ClientTypes.CapacityReservation] {
        return try await self.asyncCompactMap { item in item.capacityReservations }
    }
}

/// Paginate over `[DescribeCarrierGatewaysOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeCarrierGatewaysInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeCarrierGatewaysOutputResponse`
extension EC2Client {
    public func describeCarrierGatewaysPaginated(input: DescribeCarrierGatewaysInput) -> ClientRuntime.PaginatorSequence<DescribeCarrierGatewaysInput, DescribeCarrierGatewaysOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeCarrierGatewaysInput, DescribeCarrierGatewaysOutputResponse>(input: input, inputKey: \DescribeCarrierGatewaysInput.nextToken, outputKey: \DescribeCarrierGatewaysOutputResponse.nextToken, paginationFunction: self.describeCarrierGateways(input:))
    }
}

extension DescribeCarrierGatewaysInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeCarrierGatewaysInput {
        return DescribeCarrierGatewaysInput(
            carrierGatewayIds: self.carrierGatewayIds,
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeCarrierGatewaysPaginated`
/// to access the nested member `[EC2ClientTypes.CarrierGateway]`
/// - Returns: `[EC2ClientTypes.CarrierGateway]`
extension PaginatorSequence where Input == DescribeCarrierGatewaysInput, Output == DescribeCarrierGatewaysOutputResponse {
    public func carrierGateways() async throws -> [EC2ClientTypes.CarrierGateway] {
        return try await self.asyncCompactMap { item in item.carrierGateways }
    }
}

/// Paginate over `[DescribeClassicLinkInstancesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeClassicLinkInstancesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeClassicLinkInstancesOutputResponse`
extension EC2Client {
    public func describeClassicLinkInstancesPaginated(input: DescribeClassicLinkInstancesInput) -> ClientRuntime.PaginatorSequence<DescribeClassicLinkInstancesInput, DescribeClassicLinkInstancesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeClassicLinkInstancesInput, DescribeClassicLinkInstancesOutputResponse>(input: input, inputKey: \DescribeClassicLinkInstancesInput.nextToken, outputKey: \DescribeClassicLinkInstancesOutputResponse.nextToken, paginationFunction: self.describeClassicLinkInstances(input:))
    }
}

extension DescribeClassicLinkInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClassicLinkInstancesInput {
        return DescribeClassicLinkInstancesInput(
            dryRun: self.dryRun,
            filters: self.filters,
            instanceIds: self.instanceIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeClassicLinkInstancesPaginated`
/// to access the nested member `[EC2ClientTypes.ClassicLinkInstance]`
/// - Returns: `[EC2ClientTypes.ClassicLinkInstance]`
extension PaginatorSequence where Input == DescribeClassicLinkInstancesInput, Output == DescribeClassicLinkInstancesOutputResponse {
    public func instances() async throws -> [EC2ClientTypes.ClassicLinkInstance] {
        return try await self.asyncCompactMap { item in item.instances }
    }
}

/// Paginate over `[DescribeClientVpnAuthorizationRulesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeClientVpnAuthorizationRulesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeClientVpnAuthorizationRulesOutputResponse`
extension EC2Client {
    public func describeClientVpnAuthorizationRulesPaginated(input: DescribeClientVpnAuthorizationRulesInput) -> ClientRuntime.PaginatorSequence<DescribeClientVpnAuthorizationRulesInput, DescribeClientVpnAuthorizationRulesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeClientVpnAuthorizationRulesInput, DescribeClientVpnAuthorizationRulesOutputResponse>(input: input, inputKey: \DescribeClientVpnAuthorizationRulesInput.nextToken, outputKey: \DescribeClientVpnAuthorizationRulesOutputResponse.nextToken, paginationFunction: self.describeClientVpnAuthorizationRules(input:))
    }
}

extension DescribeClientVpnAuthorizationRulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClientVpnAuthorizationRulesInput {
        return DescribeClientVpnAuthorizationRulesInput(
            clientVpnEndpointId: self.clientVpnEndpointId,
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeClientVpnAuthorizationRulesPaginated`
/// to access the nested member `[EC2ClientTypes.AuthorizationRule]`
/// - Returns: `[EC2ClientTypes.AuthorizationRule]`
extension PaginatorSequence where Input == DescribeClientVpnAuthorizationRulesInput, Output == DescribeClientVpnAuthorizationRulesOutputResponse {
    public func authorizationRules() async throws -> [EC2ClientTypes.AuthorizationRule] {
        return try await self.asyncCompactMap { item in item.authorizationRules }
    }
}

/// Paginate over `[DescribeClientVpnConnectionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeClientVpnConnectionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeClientVpnConnectionsOutputResponse`
extension EC2Client {
    public func describeClientVpnConnectionsPaginated(input: DescribeClientVpnConnectionsInput) -> ClientRuntime.PaginatorSequence<DescribeClientVpnConnectionsInput, DescribeClientVpnConnectionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeClientVpnConnectionsInput, DescribeClientVpnConnectionsOutputResponse>(input: input, inputKey: \DescribeClientVpnConnectionsInput.nextToken, outputKey: \DescribeClientVpnConnectionsOutputResponse.nextToken, paginationFunction: self.describeClientVpnConnections(input:))
    }
}

extension DescribeClientVpnConnectionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClientVpnConnectionsInput {
        return DescribeClientVpnConnectionsInput(
            clientVpnEndpointId: self.clientVpnEndpointId,
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeClientVpnConnectionsPaginated`
/// to access the nested member `[EC2ClientTypes.ClientVpnConnection]`
/// - Returns: `[EC2ClientTypes.ClientVpnConnection]`
extension PaginatorSequence where Input == DescribeClientVpnConnectionsInput, Output == DescribeClientVpnConnectionsOutputResponse {
    public func connections() async throws -> [EC2ClientTypes.ClientVpnConnection] {
        return try await self.asyncCompactMap { item in item.connections }
    }
}

/// Paginate over `[DescribeClientVpnEndpointsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeClientVpnEndpointsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeClientVpnEndpointsOutputResponse`
extension EC2Client {
    public func describeClientVpnEndpointsPaginated(input: DescribeClientVpnEndpointsInput) -> ClientRuntime.PaginatorSequence<DescribeClientVpnEndpointsInput, DescribeClientVpnEndpointsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeClientVpnEndpointsInput, DescribeClientVpnEndpointsOutputResponse>(input: input, inputKey: \DescribeClientVpnEndpointsInput.nextToken, outputKey: \DescribeClientVpnEndpointsOutputResponse.nextToken, paginationFunction: self.describeClientVpnEndpoints(input:))
    }
}

extension DescribeClientVpnEndpointsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClientVpnEndpointsInput {
        return DescribeClientVpnEndpointsInput(
            clientVpnEndpointIds: self.clientVpnEndpointIds,
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeClientVpnEndpointsPaginated`
/// to access the nested member `[EC2ClientTypes.ClientVpnEndpoint]`
/// - Returns: `[EC2ClientTypes.ClientVpnEndpoint]`
extension PaginatorSequence where Input == DescribeClientVpnEndpointsInput, Output == DescribeClientVpnEndpointsOutputResponse {
    public func clientVpnEndpoints() async throws -> [EC2ClientTypes.ClientVpnEndpoint] {
        return try await self.asyncCompactMap { item in item.clientVpnEndpoints }
    }
}

/// Paginate over `[DescribeClientVpnRoutesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeClientVpnRoutesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeClientVpnRoutesOutputResponse`
extension EC2Client {
    public func describeClientVpnRoutesPaginated(input: DescribeClientVpnRoutesInput) -> ClientRuntime.PaginatorSequence<DescribeClientVpnRoutesInput, DescribeClientVpnRoutesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeClientVpnRoutesInput, DescribeClientVpnRoutesOutputResponse>(input: input, inputKey: \DescribeClientVpnRoutesInput.nextToken, outputKey: \DescribeClientVpnRoutesOutputResponse.nextToken, paginationFunction: self.describeClientVpnRoutes(input:))
    }
}

extension DescribeClientVpnRoutesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClientVpnRoutesInput {
        return DescribeClientVpnRoutesInput(
            clientVpnEndpointId: self.clientVpnEndpointId,
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeClientVpnRoutesPaginated`
/// to access the nested member `[EC2ClientTypes.ClientVpnRoute]`
/// - Returns: `[EC2ClientTypes.ClientVpnRoute]`
extension PaginatorSequence where Input == DescribeClientVpnRoutesInput, Output == DescribeClientVpnRoutesOutputResponse {
    public func routes() async throws -> [EC2ClientTypes.ClientVpnRoute] {
        return try await self.asyncCompactMap { item in item.routes }
    }
}

/// Paginate over `[DescribeClientVpnTargetNetworksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeClientVpnTargetNetworksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeClientVpnTargetNetworksOutputResponse`
extension EC2Client {
    public func describeClientVpnTargetNetworksPaginated(input: DescribeClientVpnTargetNetworksInput) -> ClientRuntime.PaginatorSequence<DescribeClientVpnTargetNetworksInput, DescribeClientVpnTargetNetworksOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeClientVpnTargetNetworksInput, DescribeClientVpnTargetNetworksOutputResponse>(input: input, inputKey: \DescribeClientVpnTargetNetworksInput.nextToken, outputKey: \DescribeClientVpnTargetNetworksOutputResponse.nextToken, paginationFunction: self.describeClientVpnTargetNetworks(input:))
    }
}

extension DescribeClientVpnTargetNetworksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClientVpnTargetNetworksInput {
        return DescribeClientVpnTargetNetworksInput(
            associationIds: self.associationIds,
            clientVpnEndpointId: self.clientVpnEndpointId,
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeClientVpnTargetNetworksPaginated`
/// to access the nested member `[EC2ClientTypes.TargetNetwork]`
/// - Returns: `[EC2ClientTypes.TargetNetwork]`
extension PaginatorSequence where Input == DescribeClientVpnTargetNetworksInput, Output == DescribeClientVpnTargetNetworksOutputResponse {
    public func clientVpnTargetNetworks() async throws -> [EC2ClientTypes.TargetNetwork] {
        return try await self.asyncCompactMap { item in item.clientVpnTargetNetworks }
    }
}

/// Paginate over `[DescribeCoipPoolsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeCoipPoolsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeCoipPoolsOutputResponse`
extension EC2Client {
    public func describeCoipPoolsPaginated(input: DescribeCoipPoolsInput) -> ClientRuntime.PaginatorSequence<DescribeCoipPoolsInput, DescribeCoipPoolsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeCoipPoolsInput, DescribeCoipPoolsOutputResponse>(input: input, inputKey: \DescribeCoipPoolsInput.nextToken, outputKey: \DescribeCoipPoolsOutputResponse.nextToken, paginationFunction: self.describeCoipPools(input:))
    }
}

extension DescribeCoipPoolsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeCoipPoolsInput {
        return DescribeCoipPoolsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            poolIds: self.poolIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeCoipPoolsPaginated`
/// to access the nested member `[EC2ClientTypes.CoipPool]`
/// - Returns: `[EC2ClientTypes.CoipPool]`
extension PaginatorSequence where Input == DescribeCoipPoolsInput, Output == DescribeCoipPoolsOutputResponse {
    public func coipPools() async throws -> [EC2ClientTypes.CoipPool] {
        return try await self.asyncCompactMap { item in item.coipPools }
    }
}

/// Paginate over `[DescribeDhcpOptionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeDhcpOptionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeDhcpOptionsOutputResponse`
extension EC2Client {
    public func describeDhcpOptionsPaginated(input: DescribeDhcpOptionsInput) -> ClientRuntime.PaginatorSequence<DescribeDhcpOptionsInput, DescribeDhcpOptionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDhcpOptionsInput, DescribeDhcpOptionsOutputResponse>(input: input, inputKey: \DescribeDhcpOptionsInput.nextToken, outputKey: \DescribeDhcpOptionsOutputResponse.nextToken, paginationFunction: self.describeDhcpOptions(input:))
    }
}

extension DescribeDhcpOptionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDhcpOptionsInput {
        return DescribeDhcpOptionsInput(
            dhcpOptionsIds: self.dhcpOptionsIds,
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeDhcpOptionsPaginated`
/// to access the nested member `[EC2ClientTypes.DhcpOptions]`
/// - Returns: `[EC2ClientTypes.DhcpOptions]`
extension PaginatorSequence where Input == DescribeDhcpOptionsInput, Output == DescribeDhcpOptionsOutputResponse {
    public func dhcpOptions() async throws -> [EC2ClientTypes.DhcpOptions] {
        return try await self.asyncCompactMap { item in item.dhcpOptions }
    }
}

/// Paginate over `[DescribeEgressOnlyInternetGatewaysOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeEgressOnlyInternetGatewaysInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeEgressOnlyInternetGatewaysOutputResponse`
extension EC2Client {
    public func describeEgressOnlyInternetGatewaysPaginated(input: DescribeEgressOnlyInternetGatewaysInput) -> ClientRuntime.PaginatorSequence<DescribeEgressOnlyInternetGatewaysInput, DescribeEgressOnlyInternetGatewaysOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeEgressOnlyInternetGatewaysInput, DescribeEgressOnlyInternetGatewaysOutputResponse>(input: input, inputKey: \DescribeEgressOnlyInternetGatewaysInput.nextToken, outputKey: \DescribeEgressOnlyInternetGatewaysOutputResponse.nextToken, paginationFunction: self.describeEgressOnlyInternetGateways(input:))
    }
}

extension DescribeEgressOnlyInternetGatewaysInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEgressOnlyInternetGatewaysInput {
        return DescribeEgressOnlyInternetGatewaysInput(
            dryRun: self.dryRun,
            egressOnlyInternetGatewayIds: self.egressOnlyInternetGatewayIds,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeEgressOnlyInternetGatewaysPaginated`
/// to access the nested member `[EC2ClientTypes.EgressOnlyInternetGateway]`
/// - Returns: `[EC2ClientTypes.EgressOnlyInternetGateway]`
extension PaginatorSequence where Input == DescribeEgressOnlyInternetGatewaysInput, Output == DescribeEgressOnlyInternetGatewaysOutputResponse {
    public func egressOnlyInternetGateways() async throws -> [EC2ClientTypes.EgressOnlyInternetGateway] {
        return try await self.asyncCompactMap { item in item.egressOnlyInternetGateways }
    }
}

/// Paginate over `[DescribeExportImageTasksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeExportImageTasksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeExportImageTasksOutputResponse`
extension EC2Client {
    public func describeExportImageTasksPaginated(input: DescribeExportImageTasksInput) -> ClientRuntime.PaginatorSequence<DescribeExportImageTasksInput, DescribeExportImageTasksOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeExportImageTasksInput, DescribeExportImageTasksOutputResponse>(input: input, inputKey: \DescribeExportImageTasksInput.nextToken, outputKey: \DescribeExportImageTasksOutputResponse.nextToken, paginationFunction: self.describeExportImageTasks(input:))
    }
}

extension DescribeExportImageTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeExportImageTasksInput {
        return DescribeExportImageTasksInput(
            dryRun: self.dryRun,
            exportImageTaskIds: self.exportImageTaskIds,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeExportImageTasksPaginated`
/// to access the nested member `[EC2ClientTypes.ExportImageTask]`
/// - Returns: `[EC2ClientTypes.ExportImageTask]`
extension PaginatorSequence where Input == DescribeExportImageTasksInput, Output == DescribeExportImageTasksOutputResponse {
    public func exportImageTasks() async throws -> [EC2ClientTypes.ExportImageTask] {
        return try await self.asyncCompactMap { item in item.exportImageTasks }
    }
}

/// Paginate over `[DescribeFastLaunchImagesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeFastLaunchImagesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeFastLaunchImagesOutputResponse`
extension EC2Client {
    public func describeFastLaunchImagesPaginated(input: DescribeFastLaunchImagesInput) -> ClientRuntime.PaginatorSequence<DescribeFastLaunchImagesInput, DescribeFastLaunchImagesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeFastLaunchImagesInput, DescribeFastLaunchImagesOutputResponse>(input: input, inputKey: \DescribeFastLaunchImagesInput.nextToken, outputKey: \DescribeFastLaunchImagesOutputResponse.nextToken, paginationFunction: self.describeFastLaunchImages(input:))
    }
}

extension DescribeFastLaunchImagesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFastLaunchImagesInput {
        return DescribeFastLaunchImagesInput(
            dryRun: self.dryRun,
            filters: self.filters,
            imageIds: self.imageIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeFastLaunchImagesPaginated`
/// to access the nested member `[EC2ClientTypes.DescribeFastLaunchImagesSuccessItem]`
/// - Returns: `[EC2ClientTypes.DescribeFastLaunchImagesSuccessItem]`
extension PaginatorSequence where Input == DescribeFastLaunchImagesInput, Output == DescribeFastLaunchImagesOutputResponse {
    public func fastLaunchImages() async throws -> [EC2ClientTypes.DescribeFastLaunchImagesSuccessItem] {
        return try await self.asyncCompactMap { item in item.fastLaunchImages }
    }
}

/// Paginate over `[DescribeFastSnapshotRestoresOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeFastSnapshotRestoresInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeFastSnapshotRestoresOutputResponse`
extension EC2Client {
    public func describeFastSnapshotRestoresPaginated(input: DescribeFastSnapshotRestoresInput) -> ClientRuntime.PaginatorSequence<DescribeFastSnapshotRestoresInput, DescribeFastSnapshotRestoresOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeFastSnapshotRestoresInput, DescribeFastSnapshotRestoresOutputResponse>(input: input, inputKey: \DescribeFastSnapshotRestoresInput.nextToken, outputKey: \DescribeFastSnapshotRestoresOutputResponse.nextToken, paginationFunction: self.describeFastSnapshotRestores(input:))
    }
}

extension DescribeFastSnapshotRestoresInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFastSnapshotRestoresInput {
        return DescribeFastSnapshotRestoresInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeFastSnapshotRestoresPaginated`
/// to access the nested member `[EC2ClientTypes.DescribeFastSnapshotRestoreSuccessItem]`
/// - Returns: `[EC2ClientTypes.DescribeFastSnapshotRestoreSuccessItem]`
extension PaginatorSequence where Input == DescribeFastSnapshotRestoresInput, Output == DescribeFastSnapshotRestoresOutputResponse {
    public func fastSnapshotRestores() async throws -> [EC2ClientTypes.DescribeFastSnapshotRestoreSuccessItem] {
        return try await self.asyncCompactMap { item in item.fastSnapshotRestores }
    }
}

/// Paginate over `[DescribeFleetsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeFleetsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeFleetsOutputResponse`
extension EC2Client {
    public func describeFleetsPaginated(input: DescribeFleetsInput) -> ClientRuntime.PaginatorSequence<DescribeFleetsInput, DescribeFleetsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeFleetsInput, DescribeFleetsOutputResponse>(input: input, inputKey: \DescribeFleetsInput.nextToken, outputKey: \DescribeFleetsOutputResponse.nextToken, paginationFunction: self.describeFleets(input:))
    }
}

extension DescribeFleetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFleetsInput {
        return DescribeFleetsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            fleetIds: self.fleetIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeFleetsPaginated`
/// to access the nested member `[EC2ClientTypes.FleetData]`
/// - Returns: `[EC2ClientTypes.FleetData]`
extension PaginatorSequence where Input == DescribeFleetsInput, Output == DescribeFleetsOutputResponse {
    public func fleets() async throws -> [EC2ClientTypes.FleetData] {
        return try await self.asyncCompactMap { item in item.fleets }
    }
}

/// Paginate over `[DescribeFlowLogsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeFlowLogsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeFlowLogsOutputResponse`
extension EC2Client {
    public func describeFlowLogsPaginated(input: DescribeFlowLogsInput) -> ClientRuntime.PaginatorSequence<DescribeFlowLogsInput, DescribeFlowLogsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeFlowLogsInput, DescribeFlowLogsOutputResponse>(input: input, inputKey: \DescribeFlowLogsInput.nextToken, outputKey: \DescribeFlowLogsOutputResponse.nextToken, paginationFunction: self.describeFlowLogs(input:))
    }
}

extension DescribeFlowLogsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFlowLogsInput {
        return DescribeFlowLogsInput(
            dryRun: self.dryRun,
            filter: self.filter,
            flowLogIds: self.flowLogIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeFlowLogsPaginated`
/// to access the nested member `[EC2ClientTypes.FlowLog]`
/// - Returns: `[EC2ClientTypes.FlowLog]`
extension PaginatorSequence where Input == DescribeFlowLogsInput, Output == DescribeFlowLogsOutputResponse {
    public func flowLogs() async throws -> [EC2ClientTypes.FlowLog] {
        return try await self.asyncCompactMap { item in item.flowLogs }
    }
}

/// Paginate over `[DescribeFpgaImagesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeFpgaImagesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeFpgaImagesOutputResponse`
extension EC2Client {
    public func describeFpgaImagesPaginated(input: DescribeFpgaImagesInput) -> ClientRuntime.PaginatorSequence<DescribeFpgaImagesInput, DescribeFpgaImagesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeFpgaImagesInput, DescribeFpgaImagesOutputResponse>(input: input, inputKey: \DescribeFpgaImagesInput.nextToken, outputKey: \DescribeFpgaImagesOutputResponse.nextToken, paginationFunction: self.describeFpgaImages(input:))
    }
}

extension DescribeFpgaImagesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFpgaImagesInput {
        return DescribeFpgaImagesInput(
            dryRun: self.dryRun,
            filters: self.filters,
            fpgaImageIds: self.fpgaImageIds,
            maxResults: self.maxResults,
            nextToken: token,
            owners: self.owners
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeFpgaImagesPaginated`
/// to access the nested member `[EC2ClientTypes.FpgaImage]`
/// - Returns: `[EC2ClientTypes.FpgaImage]`
extension PaginatorSequence where Input == DescribeFpgaImagesInput, Output == DescribeFpgaImagesOutputResponse {
    public func fpgaImages() async throws -> [EC2ClientTypes.FpgaImage] {
        return try await self.asyncCompactMap { item in item.fpgaImages }
    }
}

/// Paginate over `[DescribeHostReservationOfferingsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeHostReservationOfferingsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeHostReservationOfferingsOutputResponse`
extension EC2Client {
    public func describeHostReservationOfferingsPaginated(input: DescribeHostReservationOfferingsInput) -> ClientRuntime.PaginatorSequence<DescribeHostReservationOfferingsInput, DescribeHostReservationOfferingsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeHostReservationOfferingsInput, DescribeHostReservationOfferingsOutputResponse>(input: input, inputKey: \DescribeHostReservationOfferingsInput.nextToken, outputKey: \DescribeHostReservationOfferingsOutputResponse.nextToken, paginationFunction: self.describeHostReservationOfferings(input:))
    }
}

extension DescribeHostReservationOfferingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeHostReservationOfferingsInput {
        return DescribeHostReservationOfferingsInput(
            filter: self.filter,
            maxDuration: self.maxDuration,
            maxResults: self.maxResults,
            minDuration: self.minDuration,
            nextToken: token,
            offeringId: self.offeringId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeHostReservationOfferingsPaginated`
/// to access the nested member `[EC2ClientTypes.HostOffering]`
/// - Returns: `[EC2ClientTypes.HostOffering]`
extension PaginatorSequence where Input == DescribeHostReservationOfferingsInput, Output == DescribeHostReservationOfferingsOutputResponse {
    public func offeringSet() async throws -> [EC2ClientTypes.HostOffering] {
        return try await self.asyncCompactMap { item in item.offeringSet }
    }
}

/// Paginate over `[DescribeHostReservationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeHostReservationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeHostReservationsOutputResponse`
extension EC2Client {
    public func describeHostReservationsPaginated(input: DescribeHostReservationsInput) -> ClientRuntime.PaginatorSequence<DescribeHostReservationsInput, DescribeHostReservationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeHostReservationsInput, DescribeHostReservationsOutputResponse>(input: input, inputKey: \DescribeHostReservationsInput.nextToken, outputKey: \DescribeHostReservationsOutputResponse.nextToken, paginationFunction: self.describeHostReservations(input:))
    }
}

extension DescribeHostReservationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeHostReservationsInput {
        return DescribeHostReservationsInput(
            filter: self.filter,
            hostReservationIdSet: self.hostReservationIdSet,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeHostReservationsPaginated`
/// to access the nested member `[EC2ClientTypes.HostReservation]`
/// - Returns: `[EC2ClientTypes.HostReservation]`
extension PaginatorSequence where Input == DescribeHostReservationsInput, Output == DescribeHostReservationsOutputResponse {
    public func hostReservationSet() async throws -> [EC2ClientTypes.HostReservation] {
        return try await self.asyncCompactMap { item in item.hostReservationSet }
    }
}

/// Paginate over `[DescribeHostsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeHostsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeHostsOutputResponse`
extension EC2Client {
    public func describeHostsPaginated(input: DescribeHostsInput) -> ClientRuntime.PaginatorSequence<DescribeHostsInput, DescribeHostsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeHostsInput, DescribeHostsOutputResponse>(input: input, inputKey: \DescribeHostsInput.nextToken, outputKey: \DescribeHostsOutputResponse.nextToken, paginationFunction: self.describeHosts(input:))
    }
}

extension DescribeHostsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeHostsInput {
        return DescribeHostsInput(
            filter: self.filter,
            hostIds: self.hostIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeHostsPaginated`
/// to access the nested member `[EC2ClientTypes.Host]`
/// - Returns: `[EC2ClientTypes.Host]`
extension PaginatorSequence where Input == DescribeHostsInput, Output == DescribeHostsOutputResponse {
    public func hosts() async throws -> [EC2ClientTypes.Host] {
        return try await self.asyncCompactMap { item in item.hosts }
    }
}

/// Paginate over `[DescribeIamInstanceProfileAssociationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeIamInstanceProfileAssociationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeIamInstanceProfileAssociationsOutputResponse`
extension EC2Client {
    public func describeIamInstanceProfileAssociationsPaginated(input: DescribeIamInstanceProfileAssociationsInput) -> ClientRuntime.PaginatorSequence<DescribeIamInstanceProfileAssociationsInput, DescribeIamInstanceProfileAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeIamInstanceProfileAssociationsInput, DescribeIamInstanceProfileAssociationsOutputResponse>(input: input, inputKey: \DescribeIamInstanceProfileAssociationsInput.nextToken, outputKey: \DescribeIamInstanceProfileAssociationsOutputResponse.nextToken, paginationFunction: self.describeIamInstanceProfileAssociations(input:))
    }
}

extension DescribeIamInstanceProfileAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeIamInstanceProfileAssociationsInput {
        return DescribeIamInstanceProfileAssociationsInput(
            associationIds: self.associationIds,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeIamInstanceProfileAssociationsPaginated`
/// to access the nested member `[EC2ClientTypes.IamInstanceProfileAssociation]`
/// - Returns: `[EC2ClientTypes.IamInstanceProfileAssociation]`
extension PaginatorSequence where Input == DescribeIamInstanceProfileAssociationsInput, Output == DescribeIamInstanceProfileAssociationsOutputResponse {
    public func iamInstanceProfileAssociations() async throws -> [EC2ClientTypes.IamInstanceProfileAssociation] {
        return try await self.asyncCompactMap { item in item.iamInstanceProfileAssociations }
    }
}

/// Paginate over `[DescribeImportImageTasksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeImportImageTasksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeImportImageTasksOutputResponse`
extension EC2Client {
    public func describeImportImageTasksPaginated(input: DescribeImportImageTasksInput) -> ClientRuntime.PaginatorSequence<DescribeImportImageTasksInput, DescribeImportImageTasksOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeImportImageTasksInput, DescribeImportImageTasksOutputResponse>(input: input, inputKey: \DescribeImportImageTasksInput.nextToken, outputKey: \DescribeImportImageTasksOutputResponse.nextToken, paginationFunction: self.describeImportImageTasks(input:))
    }
}

extension DescribeImportImageTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeImportImageTasksInput {
        return DescribeImportImageTasksInput(
            dryRun: self.dryRun,
            filters: self.filters,
            importTaskIds: self.importTaskIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeImportImageTasksPaginated`
/// to access the nested member `[EC2ClientTypes.ImportImageTask]`
/// - Returns: `[EC2ClientTypes.ImportImageTask]`
extension PaginatorSequence where Input == DescribeImportImageTasksInput, Output == DescribeImportImageTasksOutputResponse {
    public func importImageTasks() async throws -> [EC2ClientTypes.ImportImageTask] {
        return try await self.asyncCompactMap { item in item.importImageTasks }
    }
}

/// Paginate over `[DescribeImportSnapshotTasksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeImportSnapshotTasksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeImportSnapshotTasksOutputResponse`
extension EC2Client {
    public func describeImportSnapshotTasksPaginated(input: DescribeImportSnapshotTasksInput) -> ClientRuntime.PaginatorSequence<DescribeImportSnapshotTasksInput, DescribeImportSnapshotTasksOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeImportSnapshotTasksInput, DescribeImportSnapshotTasksOutputResponse>(input: input, inputKey: \DescribeImportSnapshotTasksInput.nextToken, outputKey: \DescribeImportSnapshotTasksOutputResponse.nextToken, paginationFunction: self.describeImportSnapshotTasks(input:))
    }
}

extension DescribeImportSnapshotTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeImportSnapshotTasksInput {
        return DescribeImportSnapshotTasksInput(
            dryRun: self.dryRun,
            filters: self.filters,
            importTaskIds: self.importTaskIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeImportSnapshotTasksPaginated`
/// to access the nested member `[EC2ClientTypes.ImportSnapshotTask]`
/// - Returns: `[EC2ClientTypes.ImportSnapshotTask]`
extension PaginatorSequence where Input == DescribeImportSnapshotTasksInput, Output == DescribeImportSnapshotTasksOutputResponse {
    public func importSnapshotTasks() async throws -> [EC2ClientTypes.ImportSnapshotTask] {
        return try await self.asyncCompactMap { item in item.importSnapshotTasks }
    }
}

/// Paginate over `[DescribeInstanceCreditSpecificationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeInstanceCreditSpecificationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeInstanceCreditSpecificationsOutputResponse`
extension EC2Client {
    public func describeInstanceCreditSpecificationsPaginated(input: DescribeInstanceCreditSpecificationsInput) -> ClientRuntime.PaginatorSequence<DescribeInstanceCreditSpecificationsInput, DescribeInstanceCreditSpecificationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeInstanceCreditSpecificationsInput, DescribeInstanceCreditSpecificationsOutputResponse>(input: input, inputKey: \DescribeInstanceCreditSpecificationsInput.nextToken, outputKey: \DescribeInstanceCreditSpecificationsOutputResponse.nextToken, paginationFunction: self.describeInstanceCreditSpecifications(input:))
    }
}

extension DescribeInstanceCreditSpecificationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInstanceCreditSpecificationsInput {
        return DescribeInstanceCreditSpecificationsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            instanceIds: self.instanceIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeInstanceCreditSpecificationsPaginated`
/// to access the nested member `[EC2ClientTypes.InstanceCreditSpecification]`
/// - Returns: `[EC2ClientTypes.InstanceCreditSpecification]`
extension PaginatorSequence where Input == DescribeInstanceCreditSpecificationsInput, Output == DescribeInstanceCreditSpecificationsOutputResponse {
    public func instanceCreditSpecifications() async throws -> [EC2ClientTypes.InstanceCreditSpecification] {
        return try await self.asyncCompactMap { item in item.instanceCreditSpecifications }
    }
}

/// Paginate over `[DescribeInstanceEventWindowsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeInstanceEventWindowsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeInstanceEventWindowsOutputResponse`
extension EC2Client {
    public func describeInstanceEventWindowsPaginated(input: DescribeInstanceEventWindowsInput) -> ClientRuntime.PaginatorSequence<DescribeInstanceEventWindowsInput, DescribeInstanceEventWindowsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeInstanceEventWindowsInput, DescribeInstanceEventWindowsOutputResponse>(input: input, inputKey: \DescribeInstanceEventWindowsInput.nextToken, outputKey: \DescribeInstanceEventWindowsOutputResponse.nextToken, paginationFunction: self.describeInstanceEventWindows(input:))
    }
}

extension DescribeInstanceEventWindowsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInstanceEventWindowsInput {
        return DescribeInstanceEventWindowsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            instanceEventWindowIds: self.instanceEventWindowIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeInstanceEventWindowsPaginated`
/// to access the nested member `[EC2ClientTypes.InstanceEventWindow]`
/// - Returns: `[EC2ClientTypes.InstanceEventWindow]`
extension PaginatorSequence where Input == DescribeInstanceEventWindowsInput, Output == DescribeInstanceEventWindowsOutputResponse {
    public func instanceEventWindows() async throws -> [EC2ClientTypes.InstanceEventWindow] {
        return try await self.asyncCompactMap { item in item.instanceEventWindows }
    }
}

/// Paginate over `[DescribeInstancesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeInstancesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeInstancesOutputResponse`
extension EC2Client {
    public func describeInstancesPaginated(input: DescribeInstancesInput) -> ClientRuntime.PaginatorSequence<DescribeInstancesInput, DescribeInstancesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeInstancesInput, DescribeInstancesOutputResponse>(input: input, inputKey: \DescribeInstancesInput.nextToken, outputKey: \DescribeInstancesOutputResponse.nextToken, paginationFunction: self.describeInstances(input:))
    }
}

extension DescribeInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInstancesInput {
        return DescribeInstancesInput(
            dryRun: self.dryRun,
            filters: self.filters,
            instanceIds: self.instanceIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeInstancesPaginated`
/// to access the nested member `[EC2ClientTypes.Reservation]`
/// - Returns: `[EC2ClientTypes.Reservation]`
extension PaginatorSequence where Input == DescribeInstancesInput, Output == DescribeInstancesOutputResponse {
    public func reservations() async throws -> [EC2ClientTypes.Reservation] {
        return try await self.asyncCompactMap { item in item.reservations }
    }
}

/// Paginate over `[DescribeInstanceStatusOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeInstanceStatusInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeInstanceStatusOutputResponse`
extension EC2Client {
    public func describeInstanceStatusPaginated(input: DescribeInstanceStatusInput) -> ClientRuntime.PaginatorSequence<DescribeInstanceStatusInput, DescribeInstanceStatusOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeInstanceStatusInput, DescribeInstanceStatusOutputResponse>(input: input, inputKey: \DescribeInstanceStatusInput.nextToken, outputKey: \DescribeInstanceStatusOutputResponse.nextToken, paginationFunction: self.describeInstanceStatus(input:))
    }
}

extension DescribeInstanceStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInstanceStatusInput {
        return DescribeInstanceStatusInput(
            dryRun: self.dryRun,
            filters: self.filters,
            includeAllInstances: self.includeAllInstances,
            instanceIds: self.instanceIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeInstanceStatusPaginated`
/// to access the nested member `[EC2ClientTypes.InstanceStatus]`
/// - Returns: `[EC2ClientTypes.InstanceStatus]`
extension PaginatorSequence where Input == DescribeInstanceStatusInput, Output == DescribeInstanceStatusOutputResponse {
    public func instanceStatuses() async throws -> [EC2ClientTypes.InstanceStatus] {
        return try await self.asyncCompactMap { item in item.instanceStatuses }
    }
}

/// Paginate over `[DescribeInstanceTypeOfferingsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeInstanceTypeOfferingsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeInstanceTypeOfferingsOutputResponse`
extension EC2Client {
    public func describeInstanceTypeOfferingsPaginated(input: DescribeInstanceTypeOfferingsInput) -> ClientRuntime.PaginatorSequence<DescribeInstanceTypeOfferingsInput, DescribeInstanceTypeOfferingsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeInstanceTypeOfferingsInput, DescribeInstanceTypeOfferingsOutputResponse>(input: input, inputKey: \DescribeInstanceTypeOfferingsInput.nextToken, outputKey: \DescribeInstanceTypeOfferingsOutputResponse.nextToken, paginationFunction: self.describeInstanceTypeOfferings(input:))
    }
}

extension DescribeInstanceTypeOfferingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInstanceTypeOfferingsInput {
        return DescribeInstanceTypeOfferingsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            locationType: self.locationType,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeInstanceTypeOfferingsPaginated`
/// to access the nested member `[EC2ClientTypes.InstanceTypeOffering]`
/// - Returns: `[EC2ClientTypes.InstanceTypeOffering]`
extension PaginatorSequence where Input == DescribeInstanceTypeOfferingsInput, Output == DescribeInstanceTypeOfferingsOutputResponse {
    public func instanceTypeOfferings() async throws -> [EC2ClientTypes.InstanceTypeOffering] {
        return try await self.asyncCompactMap { item in item.instanceTypeOfferings }
    }
}

/// Paginate over `[DescribeInstanceTypesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeInstanceTypesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeInstanceTypesOutputResponse`
extension EC2Client {
    public func describeInstanceTypesPaginated(input: DescribeInstanceTypesInput) -> ClientRuntime.PaginatorSequence<DescribeInstanceTypesInput, DescribeInstanceTypesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeInstanceTypesInput, DescribeInstanceTypesOutputResponse>(input: input, inputKey: \DescribeInstanceTypesInput.nextToken, outputKey: \DescribeInstanceTypesOutputResponse.nextToken, paginationFunction: self.describeInstanceTypes(input:))
    }
}

extension DescribeInstanceTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInstanceTypesInput {
        return DescribeInstanceTypesInput(
            dryRun: self.dryRun,
            filters: self.filters,
            instanceTypes: self.instanceTypes,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeInstanceTypesPaginated`
/// to access the nested member `[EC2ClientTypes.InstanceTypeInfo]`
/// - Returns: `[EC2ClientTypes.InstanceTypeInfo]`
extension PaginatorSequence where Input == DescribeInstanceTypesInput, Output == DescribeInstanceTypesOutputResponse {
    public func instanceTypes() async throws -> [EC2ClientTypes.InstanceTypeInfo] {
        return try await self.asyncCompactMap { item in item.instanceTypes }
    }
}

/// Paginate over `[DescribeInternetGatewaysOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeInternetGatewaysInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeInternetGatewaysOutputResponse`
extension EC2Client {
    public func describeInternetGatewaysPaginated(input: DescribeInternetGatewaysInput) -> ClientRuntime.PaginatorSequence<DescribeInternetGatewaysInput, DescribeInternetGatewaysOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeInternetGatewaysInput, DescribeInternetGatewaysOutputResponse>(input: input, inputKey: \DescribeInternetGatewaysInput.nextToken, outputKey: \DescribeInternetGatewaysOutputResponse.nextToken, paginationFunction: self.describeInternetGateways(input:))
    }
}

extension DescribeInternetGatewaysInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInternetGatewaysInput {
        return DescribeInternetGatewaysInput(
            dryRun: self.dryRun,
            filters: self.filters,
            internetGatewayIds: self.internetGatewayIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeInternetGatewaysPaginated`
/// to access the nested member `[EC2ClientTypes.InternetGateway]`
/// - Returns: `[EC2ClientTypes.InternetGateway]`
extension PaginatorSequence where Input == DescribeInternetGatewaysInput, Output == DescribeInternetGatewaysOutputResponse {
    public func internetGateways() async throws -> [EC2ClientTypes.InternetGateway] {
        return try await self.asyncCompactMap { item in item.internetGateways }
    }
}

/// Paginate over `[DescribeIpamPoolsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeIpamPoolsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeIpamPoolsOutputResponse`
extension EC2Client {
    public func describeIpamPoolsPaginated(input: DescribeIpamPoolsInput) -> ClientRuntime.PaginatorSequence<DescribeIpamPoolsInput, DescribeIpamPoolsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeIpamPoolsInput, DescribeIpamPoolsOutputResponse>(input: input, inputKey: \DescribeIpamPoolsInput.nextToken, outputKey: \DescribeIpamPoolsOutputResponse.nextToken, paginationFunction: self.describeIpamPools(input:))
    }
}

extension DescribeIpamPoolsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeIpamPoolsInput {
        return DescribeIpamPoolsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            ipamPoolIds: self.ipamPoolIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeIpamPoolsPaginated`
/// to access the nested member `[EC2ClientTypes.IpamPool]`
/// - Returns: `[EC2ClientTypes.IpamPool]`
extension PaginatorSequence where Input == DescribeIpamPoolsInput, Output == DescribeIpamPoolsOutputResponse {
    public func ipamPools() async throws -> [EC2ClientTypes.IpamPool] {
        return try await self.asyncCompactMap { item in item.ipamPools }
    }
}

/// Paginate over `[DescribeIpamsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeIpamsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeIpamsOutputResponse`
extension EC2Client {
    public func describeIpamsPaginated(input: DescribeIpamsInput) -> ClientRuntime.PaginatorSequence<DescribeIpamsInput, DescribeIpamsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeIpamsInput, DescribeIpamsOutputResponse>(input: input, inputKey: \DescribeIpamsInput.nextToken, outputKey: \DescribeIpamsOutputResponse.nextToken, paginationFunction: self.describeIpams(input:))
    }
}

extension DescribeIpamsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeIpamsInput {
        return DescribeIpamsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            ipamIds: self.ipamIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeIpamsPaginated`
/// to access the nested member `[EC2ClientTypes.Ipam]`
/// - Returns: `[EC2ClientTypes.Ipam]`
extension PaginatorSequence where Input == DescribeIpamsInput, Output == DescribeIpamsOutputResponse {
    public func ipams() async throws -> [EC2ClientTypes.Ipam] {
        return try await self.asyncCompactMap { item in item.ipams }
    }
}

/// Paginate over `[DescribeIpamScopesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeIpamScopesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeIpamScopesOutputResponse`
extension EC2Client {
    public func describeIpamScopesPaginated(input: DescribeIpamScopesInput) -> ClientRuntime.PaginatorSequence<DescribeIpamScopesInput, DescribeIpamScopesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeIpamScopesInput, DescribeIpamScopesOutputResponse>(input: input, inputKey: \DescribeIpamScopesInput.nextToken, outputKey: \DescribeIpamScopesOutputResponse.nextToken, paginationFunction: self.describeIpamScopes(input:))
    }
}

extension DescribeIpamScopesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeIpamScopesInput {
        return DescribeIpamScopesInput(
            dryRun: self.dryRun,
            filters: self.filters,
            ipamScopeIds: self.ipamScopeIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeIpamScopesPaginated`
/// to access the nested member `[EC2ClientTypes.IpamScope]`
/// - Returns: `[EC2ClientTypes.IpamScope]`
extension PaginatorSequence where Input == DescribeIpamScopesInput, Output == DescribeIpamScopesOutputResponse {
    public func ipamScopes() async throws -> [EC2ClientTypes.IpamScope] {
        return try await self.asyncCompactMap { item in item.ipamScopes }
    }
}

/// Paginate over `[DescribeIpv6PoolsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeIpv6PoolsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeIpv6PoolsOutputResponse`
extension EC2Client {
    public func describeIpv6PoolsPaginated(input: DescribeIpv6PoolsInput) -> ClientRuntime.PaginatorSequence<DescribeIpv6PoolsInput, DescribeIpv6PoolsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeIpv6PoolsInput, DescribeIpv6PoolsOutputResponse>(input: input, inputKey: \DescribeIpv6PoolsInput.nextToken, outputKey: \DescribeIpv6PoolsOutputResponse.nextToken, paginationFunction: self.describeIpv6Pools(input:))
    }
}

extension DescribeIpv6PoolsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeIpv6PoolsInput {
        return DescribeIpv6PoolsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            poolIds: self.poolIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeIpv6PoolsPaginated`
/// to access the nested member `[EC2ClientTypes.Ipv6Pool]`
/// - Returns: `[EC2ClientTypes.Ipv6Pool]`
extension PaginatorSequence where Input == DescribeIpv6PoolsInput, Output == DescribeIpv6PoolsOutputResponse {
    public func ipv6Pools() async throws -> [EC2ClientTypes.Ipv6Pool] {
        return try await self.asyncCompactMap { item in item.ipv6Pools }
    }
}

/// Paginate over `[DescribeLaunchTemplatesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeLaunchTemplatesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeLaunchTemplatesOutputResponse`
extension EC2Client {
    public func describeLaunchTemplatesPaginated(input: DescribeLaunchTemplatesInput) -> ClientRuntime.PaginatorSequence<DescribeLaunchTemplatesInput, DescribeLaunchTemplatesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeLaunchTemplatesInput, DescribeLaunchTemplatesOutputResponse>(input: input, inputKey: \DescribeLaunchTemplatesInput.nextToken, outputKey: \DescribeLaunchTemplatesOutputResponse.nextToken, paginationFunction: self.describeLaunchTemplates(input:))
    }
}

extension DescribeLaunchTemplatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeLaunchTemplatesInput {
        return DescribeLaunchTemplatesInput(
            dryRun: self.dryRun,
            filters: self.filters,
            launchTemplateIds: self.launchTemplateIds,
            launchTemplateNames: self.launchTemplateNames,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeLaunchTemplatesPaginated`
/// to access the nested member `[EC2ClientTypes.LaunchTemplate]`
/// - Returns: `[EC2ClientTypes.LaunchTemplate]`
extension PaginatorSequence where Input == DescribeLaunchTemplatesInput, Output == DescribeLaunchTemplatesOutputResponse {
    public func launchTemplates() async throws -> [EC2ClientTypes.LaunchTemplate] {
        return try await self.asyncCompactMap { item in item.launchTemplates }
    }
}

/// Paginate over `[DescribeLaunchTemplateVersionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeLaunchTemplateVersionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeLaunchTemplateVersionsOutputResponse`
extension EC2Client {
    public func describeLaunchTemplateVersionsPaginated(input: DescribeLaunchTemplateVersionsInput) -> ClientRuntime.PaginatorSequence<DescribeLaunchTemplateVersionsInput, DescribeLaunchTemplateVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeLaunchTemplateVersionsInput, DescribeLaunchTemplateVersionsOutputResponse>(input: input, inputKey: \DescribeLaunchTemplateVersionsInput.nextToken, outputKey: \DescribeLaunchTemplateVersionsOutputResponse.nextToken, paginationFunction: self.describeLaunchTemplateVersions(input:))
    }
}

extension DescribeLaunchTemplateVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeLaunchTemplateVersionsInput {
        return DescribeLaunchTemplateVersionsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            launchTemplateId: self.launchTemplateId,
            launchTemplateName: self.launchTemplateName,
            maxResults: self.maxResults,
            maxVersion: self.maxVersion,
            minVersion: self.minVersion,
            nextToken: token,
            versions: self.versions
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeLaunchTemplateVersionsPaginated`
/// to access the nested member `[EC2ClientTypes.LaunchTemplateVersion]`
/// - Returns: `[EC2ClientTypes.LaunchTemplateVersion]`
extension PaginatorSequence where Input == DescribeLaunchTemplateVersionsInput, Output == DescribeLaunchTemplateVersionsOutputResponse {
    public func launchTemplateVersions() async throws -> [EC2ClientTypes.LaunchTemplateVersion] {
        return try await self.asyncCompactMap { item in item.launchTemplateVersions }
    }
}

/// Paginate over `[DescribeLocalGatewayRouteTablesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeLocalGatewayRouteTablesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeLocalGatewayRouteTablesOutputResponse`
extension EC2Client {
    public func describeLocalGatewayRouteTablesPaginated(input: DescribeLocalGatewayRouteTablesInput) -> ClientRuntime.PaginatorSequence<DescribeLocalGatewayRouteTablesInput, DescribeLocalGatewayRouteTablesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeLocalGatewayRouteTablesInput, DescribeLocalGatewayRouteTablesOutputResponse>(input: input, inputKey: \DescribeLocalGatewayRouteTablesInput.nextToken, outputKey: \DescribeLocalGatewayRouteTablesOutputResponse.nextToken, paginationFunction: self.describeLocalGatewayRouteTables(input:))
    }
}

extension DescribeLocalGatewayRouteTablesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeLocalGatewayRouteTablesInput {
        return DescribeLocalGatewayRouteTablesInput(
            dryRun: self.dryRun,
            filters: self.filters,
            localGatewayRouteTableIds: self.localGatewayRouteTableIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeLocalGatewayRouteTablesPaginated`
/// to access the nested member `[EC2ClientTypes.LocalGatewayRouteTable]`
/// - Returns: `[EC2ClientTypes.LocalGatewayRouteTable]`
extension PaginatorSequence where Input == DescribeLocalGatewayRouteTablesInput, Output == DescribeLocalGatewayRouteTablesOutputResponse {
    public func localGatewayRouteTables() async throws -> [EC2ClientTypes.LocalGatewayRouteTable] {
        return try await self.asyncCompactMap { item in item.localGatewayRouteTables }
    }
}

/// Paginate over `[DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutputResponse`
extension EC2Client {
    public func describeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsPaginated(input: DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput) -> ClientRuntime.PaginatorSequence<DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput, DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput, DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutputResponse>(input: input, inputKey: \DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput.nextToken, outputKey: \DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutputResponse.nextToken, paginationFunction: self.describeLocalGatewayRouteTableVirtualInterfaceGroupAssociations(input:))
    }
}

extension DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput {
        return DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            localGatewayRouteTableVirtualInterfaceGroupAssociationIds: self.localGatewayRouteTableVirtualInterfaceGroupAssociationIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsPaginated`
/// to access the nested member `[EC2ClientTypes.LocalGatewayRouteTableVirtualInterfaceGroupAssociation]`
/// - Returns: `[EC2ClientTypes.LocalGatewayRouteTableVirtualInterfaceGroupAssociation]`
extension PaginatorSequence where Input == DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput, Output == DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutputResponse {
    public func localGatewayRouteTableVirtualInterfaceGroupAssociations() async throws -> [EC2ClientTypes.LocalGatewayRouteTableVirtualInterfaceGroupAssociation] {
        return try await self.asyncCompactMap { item in item.localGatewayRouteTableVirtualInterfaceGroupAssociations }
    }
}

/// Paginate over `[DescribeLocalGatewayRouteTableVpcAssociationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeLocalGatewayRouteTableVpcAssociationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeLocalGatewayRouteTableVpcAssociationsOutputResponse`
extension EC2Client {
    public func describeLocalGatewayRouteTableVpcAssociationsPaginated(input: DescribeLocalGatewayRouteTableVpcAssociationsInput) -> ClientRuntime.PaginatorSequence<DescribeLocalGatewayRouteTableVpcAssociationsInput, DescribeLocalGatewayRouteTableVpcAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeLocalGatewayRouteTableVpcAssociationsInput, DescribeLocalGatewayRouteTableVpcAssociationsOutputResponse>(input: input, inputKey: \DescribeLocalGatewayRouteTableVpcAssociationsInput.nextToken, outputKey: \DescribeLocalGatewayRouteTableVpcAssociationsOutputResponse.nextToken, paginationFunction: self.describeLocalGatewayRouteTableVpcAssociations(input:))
    }
}

extension DescribeLocalGatewayRouteTableVpcAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeLocalGatewayRouteTableVpcAssociationsInput {
        return DescribeLocalGatewayRouteTableVpcAssociationsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            localGatewayRouteTableVpcAssociationIds: self.localGatewayRouteTableVpcAssociationIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeLocalGatewayRouteTableVpcAssociationsPaginated`
/// to access the nested member `[EC2ClientTypes.LocalGatewayRouteTableVpcAssociation]`
/// - Returns: `[EC2ClientTypes.LocalGatewayRouteTableVpcAssociation]`
extension PaginatorSequence where Input == DescribeLocalGatewayRouteTableVpcAssociationsInput, Output == DescribeLocalGatewayRouteTableVpcAssociationsOutputResponse {
    public func localGatewayRouteTableVpcAssociations() async throws -> [EC2ClientTypes.LocalGatewayRouteTableVpcAssociation] {
        return try await self.asyncCompactMap { item in item.localGatewayRouteTableVpcAssociations }
    }
}

/// Paginate over `[DescribeLocalGatewaysOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeLocalGatewaysInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeLocalGatewaysOutputResponse`
extension EC2Client {
    public func describeLocalGatewaysPaginated(input: DescribeLocalGatewaysInput) -> ClientRuntime.PaginatorSequence<DescribeLocalGatewaysInput, DescribeLocalGatewaysOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeLocalGatewaysInput, DescribeLocalGatewaysOutputResponse>(input: input, inputKey: \DescribeLocalGatewaysInput.nextToken, outputKey: \DescribeLocalGatewaysOutputResponse.nextToken, paginationFunction: self.describeLocalGateways(input:))
    }
}

extension DescribeLocalGatewaysInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeLocalGatewaysInput {
        return DescribeLocalGatewaysInput(
            dryRun: self.dryRun,
            filters: self.filters,
            localGatewayIds: self.localGatewayIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeLocalGatewaysPaginated`
/// to access the nested member `[EC2ClientTypes.LocalGateway]`
/// - Returns: `[EC2ClientTypes.LocalGateway]`
extension PaginatorSequence where Input == DescribeLocalGatewaysInput, Output == DescribeLocalGatewaysOutputResponse {
    public func localGateways() async throws -> [EC2ClientTypes.LocalGateway] {
        return try await self.asyncCompactMap { item in item.localGateways }
    }
}

/// Paginate over `[DescribeLocalGatewayVirtualInterfaceGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeLocalGatewayVirtualInterfaceGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeLocalGatewayVirtualInterfaceGroupsOutputResponse`
extension EC2Client {
    public func describeLocalGatewayVirtualInterfaceGroupsPaginated(input: DescribeLocalGatewayVirtualInterfaceGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeLocalGatewayVirtualInterfaceGroupsInput, DescribeLocalGatewayVirtualInterfaceGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeLocalGatewayVirtualInterfaceGroupsInput, DescribeLocalGatewayVirtualInterfaceGroupsOutputResponse>(input: input, inputKey: \DescribeLocalGatewayVirtualInterfaceGroupsInput.nextToken, outputKey: \DescribeLocalGatewayVirtualInterfaceGroupsOutputResponse.nextToken, paginationFunction: self.describeLocalGatewayVirtualInterfaceGroups(input:))
    }
}

extension DescribeLocalGatewayVirtualInterfaceGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeLocalGatewayVirtualInterfaceGroupsInput {
        return DescribeLocalGatewayVirtualInterfaceGroupsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            localGatewayVirtualInterfaceGroupIds: self.localGatewayVirtualInterfaceGroupIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeLocalGatewayVirtualInterfaceGroupsPaginated`
/// to access the nested member `[EC2ClientTypes.LocalGatewayVirtualInterfaceGroup]`
/// - Returns: `[EC2ClientTypes.LocalGatewayVirtualInterfaceGroup]`
extension PaginatorSequence where Input == DescribeLocalGatewayVirtualInterfaceGroupsInput, Output == DescribeLocalGatewayVirtualInterfaceGroupsOutputResponse {
    public func localGatewayVirtualInterfaceGroups() async throws -> [EC2ClientTypes.LocalGatewayVirtualInterfaceGroup] {
        return try await self.asyncCompactMap { item in item.localGatewayVirtualInterfaceGroups }
    }
}

/// Paginate over `[DescribeLocalGatewayVirtualInterfacesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeLocalGatewayVirtualInterfacesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeLocalGatewayVirtualInterfacesOutputResponse`
extension EC2Client {
    public func describeLocalGatewayVirtualInterfacesPaginated(input: DescribeLocalGatewayVirtualInterfacesInput) -> ClientRuntime.PaginatorSequence<DescribeLocalGatewayVirtualInterfacesInput, DescribeLocalGatewayVirtualInterfacesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeLocalGatewayVirtualInterfacesInput, DescribeLocalGatewayVirtualInterfacesOutputResponse>(input: input, inputKey: \DescribeLocalGatewayVirtualInterfacesInput.nextToken, outputKey: \DescribeLocalGatewayVirtualInterfacesOutputResponse.nextToken, paginationFunction: self.describeLocalGatewayVirtualInterfaces(input:))
    }
}

extension DescribeLocalGatewayVirtualInterfacesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeLocalGatewayVirtualInterfacesInput {
        return DescribeLocalGatewayVirtualInterfacesInput(
            dryRun: self.dryRun,
            filters: self.filters,
            localGatewayVirtualInterfaceIds: self.localGatewayVirtualInterfaceIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeLocalGatewayVirtualInterfacesPaginated`
/// to access the nested member `[EC2ClientTypes.LocalGatewayVirtualInterface]`
/// - Returns: `[EC2ClientTypes.LocalGatewayVirtualInterface]`
extension PaginatorSequence where Input == DescribeLocalGatewayVirtualInterfacesInput, Output == DescribeLocalGatewayVirtualInterfacesOutputResponse {
    public func localGatewayVirtualInterfaces() async throws -> [EC2ClientTypes.LocalGatewayVirtualInterface] {
        return try await self.asyncCompactMap { item in item.localGatewayVirtualInterfaces }
    }
}

/// Paginate over `[DescribeManagedPrefixListsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeManagedPrefixListsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeManagedPrefixListsOutputResponse`
extension EC2Client {
    public func describeManagedPrefixListsPaginated(input: DescribeManagedPrefixListsInput) -> ClientRuntime.PaginatorSequence<DescribeManagedPrefixListsInput, DescribeManagedPrefixListsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeManagedPrefixListsInput, DescribeManagedPrefixListsOutputResponse>(input: input, inputKey: \DescribeManagedPrefixListsInput.nextToken, outputKey: \DescribeManagedPrefixListsOutputResponse.nextToken, paginationFunction: self.describeManagedPrefixLists(input:))
    }
}

extension DescribeManagedPrefixListsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeManagedPrefixListsInput {
        return DescribeManagedPrefixListsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            prefixListIds: self.prefixListIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeManagedPrefixListsPaginated`
/// to access the nested member `[EC2ClientTypes.ManagedPrefixList]`
/// - Returns: `[EC2ClientTypes.ManagedPrefixList]`
extension PaginatorSequence where Input == DescribeManagedPrefixListsInput, Output == DescribeManagedPrefixListsOutputResponse {
    public func prefixLists() async throws -> [EC2ClientTypes.ManagedPrefixList] {
        return try await self.asyncCompactMap { item in item.prefixLists }
    }
}

/// Paginate over `[DescribeMovingAddressesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeMovingAddressesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeMovingAddressesOutputResponse`
extension EC2Client {
    public func describeMovingAddressesPaginated(input: DescribeMovingAddressesInput) -> ClientRuntime.PaginatorSequence<DescribeMovingAddressesInput, DescribeMovingAddressesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeMovingAddressesInput, DescribeMovingAddressesOutputResponse>(input: input, inputKey: \DescribeMovingAddressesInput.nextToken, outputKey: \DescribeMovingAddressesOutputResponse.nextToken, paginationFunction: self.describeMovingAddresses(input:))
    }
}

extension DescribeMovingAddressesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMovingAddressesInput {
        return DescribeMovingAddressesInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            publicIps: self.publicIps
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeMovingAddressesPaginated`
/// to access the nested member `[EC2ClientTypes.MovingAddressStatus]`
/// - Returns: `[EC2ClientTypes.MovingAddressStatus]`
extension PaginatorSequence where Input == DescribeMovingAddressesInput, Output == DescribeMovingAddressesOutputResponse {
    public func movingAddressStatuses() async throws -> [EC2ClientTypes.MovingAddressStatus] {
        return try await self.asyncCompactMap { item in item.movingAddressStatuses }
    }
}

/// Paginate over `[DescribeNatGatewaysOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeNatGatewaysInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeNatGatewaysOutputResponse`
extension EC2Client {
    public func describeNatGatewaysPaginated(input: DescribeNatGatewaysInput) -> ClientRuntime.PaginatorSequence<DescribeNatGatewaysInput, DescribeNatGatewaysOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeNatGatewaysInput, DescribeNatGatewaysOutputResponse>(input: input, inputKey: \DescribeNatGatewaysInput.nextToken, outputKey: \DescribeNatGatewaysOutputResponse.nextToken, paginationFunction: self.describeNatGateways(input:))
    }
}

extension DescribeNatGatewaysInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeNatGatewaysInput {
        return DescribeNatGatewaysInput(
            dryRun: self.dryRun,
            filter: self.filter,
            maxResults: self.maxResults,
            natGatewayIds: self.natGatewayIds,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeNatGatewaysPaginated`
/// to access the nested member `[EC2ClientTypes.NatGateway]`
/// - Returns: `[EC2ClientTypes.NatGateway]`
extension PaginatorSequence where Input == DescribeNatGatewaysInput, Output == DescribeNatGatewaysOutputResponse {
    public func natGateways() async throws -> [EC2ClientTypes.NatGateway] {
        return try await self.asyncCompactMap { item in item.natGateways }
    }
}

/// Paginate over `[DescribeNetworkAclsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeNetworkAclsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeNetworkAclsOutputResponse`
extension EC2Client {
    public func describeNetworkAclsPaginated(input: DescribeNetworkAclsInput) -> ClientRuntime.PaginatorSequence<DescribeNetworkAclsInput, DescribeNetworkAclsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeNetworkAclsInput, DescribeNetworkAclsOutputResponse>(input: input, inputKey: \DescribeNetworkAclsInput.nextToken, outputKey: \DescribeNetworkAclsOutputResponse.nextToken, paginationFunction: self.describeNetworkAcls(input:))
    }
}

extension DescribeNetworkAclsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeNetworkAclsInput {
        return DescribeNetworkAclsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            networkAclIds: self.networkAclIds,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeNetworkAclsPaginated`
/// to access the nested member `[EC2ClientTypes.NetworkAcl]`
/// - Returns: `[EC2ClientTypes.NetworkAcl]`
extension PaginatorSequence where Input == DescribeNetworkAclsInput, Output == DescribeNetworkAclsOutputResponse {
    public func networkAcls() async throws -> [EC2ClientTypes.NetworkAcl] {
        return try await self.asyncCompactMap { item in item.networkAcls }
    }
}

/// Paginate over `[DescribeNetworkInsightsAccessScopeAnalysesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeNetworkInsightsAccessScopeAnalysesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeNetworkInsightsAccessScopeAnalysesOutputResponse`
extension EC2Client {
    public func describeNetworkInsightsAccessScopeAnalysesPaginated(input: DescribeNetworkInsightsAccessScopeAnalysesInput) -> ClientRuntime.PaginatorSequence<DescribeNetworkInsightsAccessScopeAnalysesInput, DescribeNetworkInsightsAccessScopeAnalysesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeNetworkInsightsAccessScopeAnalysesInput, DescribeNetworkInsightsAccessScopeAnalysesOutputResponse>(input: input, inputKey: \DescribeNetworkInsightsAccessScopeAnalysesInput.nextToken, outputKey: \DescribeNetworkInsightsAccessScopeAnalysesOutputResponse.nextToken, paginationFunction: self.describeNetworkInsightsAccessScopeAnalyses(input:))
    }
}

extension DescribeNetworkInsightsAccessScopeAnalysesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeNetworkInsightsAccessScopeAnalysesInput {
        return DescribeNetworkInsightsAccessScopeAnalysesInput(
            analysisStartTimeBegin: self.analysisStartTimeBegin,
            analysisStartTimeEnd: self.analysisStartTimeEnd,
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            networkInsightsAccessScopeAnalysisIds: self.networkInsightsAccessScopeAnalysisIds,
            networkInsightsAccessScopeId: self.networkInsightsAccessScopeId,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeNetworkInsightsAccessScopeAnalysesPaginated`
/// to access the nested member `[EC2ClientTypes.NetworkInsightsAccessScopeAnalysis]`
/// - Returns: `[EC2ClientTypes.NetworkInsightsAccessScopeAnalysis]`
extension PaginatorSequence where Input == DescribeNetworkInsightsAccessScopeAnalysesInput, Output == DescribeNetworkInsightsAccessScopeAnalysesOutputResponse {
    public func networkInsightsAccessScopeAnalyses() async throws -> [EC2ClientTypes.NetworkInsightsAccessScopeAnalysis] {
        return try await self.asyncCompactMap { item in item.networkInsightsAccessScopeAnalyses }
    }
}

/// Paginate over `[DescribeNetworkInsightsAccessScopesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeNetworkInsightsAccessScopesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeNetworkInsightsAccessScopesOutputResponse`
extension EC2Client {
    public func describeNetworkInsightsAccessScopesPaginated(input: DescribeNetworkInsightsAccessScopesInput) -> ClientRuntime.PaginatorSequence<DescribeNetworkInsightsAccessScopesInput, DescribeNetworkInsightsAccessScopesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeNetworkInsightsAccessScopesInput, DescribeNetworkInsightsAccessScopesOutputResponse>(input: input, inputKey: \DescribeNetworkInsightsAccessScopesInput.nextToken, outputKey: \DescribeNetworkInsightsAccessScopesOutputResponse.nextToken, paginationFunction: self.describeNetworkInsightsAccessScopes(input:))
    }
}

extension DescribeNetworkInsightsAccessScopesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeNetworkInsightsAccessScopesInput {
        return DescribeNetworkInsightsAccessScopesInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            networkInsightsAccessScopeIds: self.networkInsightsAccessScopeIds,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeNetworkInsightsAccessScopesPaginated`
/// to access the nested member `[EC2ClientTypes.NetworkInsightsAccessScope]`
/// - Returns: `[EC2ClientTypes.NetworkInsightsAccessScope]`
extension PaginatorSequence where Input == DescribeNetworkInsightsAccessScopesInput, Output == DescribeNetworkInsightsAccessScopesOutputResponse {
    public func networkInsightsAccessScopes() async throws -> [EC2ClientTypes.NetworkInsightsAccessScope] {
        return try await self.asyncCompactMap { item in item.networkInsightsAccessScopes }
    }
}

/// Paginate over `[DescribeNetworkInsightsAnalysesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeNetworkInsightsAnalysesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeNetworkInsightsAnalysesOutputResponse`
extension EC2Client {
    public func describeNetworkInsightsAnalysesPaginated(input: DescribeNetworkInsightsAnalysesInput) -> ClientRuntime.PaginatorSequence<DescribeNetworkInsightsAnalysesInput, DescribeNetworkInsightsAnalysesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeNetworkInsightsAnalysesInput, DescribeNetworkInsightsAnalysesOutputResponse>(input: input, inputKey: \DescribeNetworkInsightsAnalysesInput.nextToken, outputKey: \DescribeNetworkInsightsAnalysesOutputResponse.nextToken, paginationFunction: self.describeNetworkInsightsAnalyses(input:))
    }
}

extension DescribeNetworkInsightsAnalysesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeNetworkInsightsAnalysesInput {
        return DescribeNetworkInsightsAnalysesInput(
            analysisEndTime: self.analysisEndTime,
            analysisStartTime: self.analysisStartTime,
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            networkInsightsAnalysisIds: self.networkInsightsAnalysisIds,
            networkInsightsPathId: self.networkInsightsPathId,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeNetworkInsightsAnalysesPaginated`
/// to access the nested member `[EC2ClientTypes.NetworkInsightsAnalysis]`
/// - Returns: `[EC2ClientTypes.NetworkInsightsAnalysis]`
extension PaginatorSequence where Input == DescribeNetworkInsightsAnalysesInput, Output == DescribeNetworkInsightsAnalysesOutputResponse {
    public func networkInsightsAnalyses() async throws -> [EC2ClientTypes.NetworkInsightsAnalysis] {
        return try await self.asyncCompactMap { item in item.networkInsightsAnalyses }
    }
}

/// Paginate over `[DescribeNetworkInsightsPathsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeNetworkInsightsPathsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeNetworkInsightsPathsOutputResponse`
extension EC2Client {
    public func describeNetworkInsightsPathsPaginated(input: DescribeNetworkInsightsPathsInput) -> ClientRuntime.PaginatorSequence<DescribeNetworkInsightsPathsInput, DescribeNetworkInsightsPathsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeNetworkInsightsPathsInput, DescribeNetworkInsightsPathsOutputResponse>(input: input, inputKey: \DescribeNetworkInsightsPathsInput.nextToken, outputKey: \DescribeNetworkInsightsPathsOutputResponse.nextToken, paginationFunction: self.describeNetworkInsightsPaths(input:))
    }
}

extension DescribeNetworkInsightsPathsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeNetworkInsightsPathsInput {
        return DescribeNetworkInsightsPathsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            networkInsightsPathIds: self.networkInsightsPathIds,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeNetworkInsightsPathsPaginated`
/// to access the nested member `[EC2ClientTypes.NetworkInsightsPath]`
/// - Returns: `[EC2ClientTypes.NetworkInsightsPath]`
extension PaginatorSequence where Input == DescribeNetworkInsightsPathsInput, Output == DescribeNetworkInsightsPathsOutputResponse {
    public func networkInsightsPaths() async throws -> [EC2ClientTypes.NetworkInsightsPath] {
        return try await self.asyncCompactMap { item in item.networkInsightsPaths }
    }
}

/// Paginate over `[DescribeNetworkInterfacePermissionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeNetworkInterfacePermissionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeNetworkInterfacePermissionsOutputResponse`
extension EC2Client {
    public func describeNetworkInterfacePermissionsPaginated(input: DescribeNetworkInterfacePermissionsInput) -> ClientRuntime.PaginatorSequence<DescribeNetworkInterfacePermissionsInput, DescribeNetworkInterfacePermissionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeNetworkInterfacePermissionsInput, DescribeNetworkInterfacePermissionsOutputResponse>(input: input, inputKey: \DescribeNetworkInterfacePermissionsInput.nextToken, outputKey: \DescribeNetworkInterfacePermissionsOutputResponse.nextToken, paginationFunction: self.describeNetworkInterfacePermissions(input:))
    }
}

extension DescribeNetworkInterfacePermissionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeNetworkInterfacePermissionsInput {
        return DescribeNetworkInterfacePermissionsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            networkInterfacePermissionIds: self.networkInterfacePermissionIds,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeNetworkInterfacePermissionsPaginated`
/// to access the nested member `[EC2ClientTypes.NetworkInterfacePermission]`
/// - Returns: `[EC2ClientTypes.NetworkInterfacePermission]`
extension PaginatorSequence where Input == DescribeNetworkInterfacePermissionsInput, Output == DescribeNetworkInterfacePermissionsOutputResponse {
    public func networkInterfacePermissions() async throws -> [EC2ClientTypes.NetworkInterfacePermission] {
        return try await self.asyncCompactMap { item in item.networkInterfacePermissions }
    }
}

/// Paginate over `[DescribeNetworkInterfacesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeNetworkInterfacesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeNetworkInterfacesOutputResponse`
extension EC2Client {
    public func describeNetworkInterfacesPaginated(input: DescribeNetworkInterfacesInput) -> ClientRuntime.PaginatorSequence<DescribeNetworkInterfacesInput, DescribeNetworkInterfacesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeNetworkInterfacesInput, DescribeNetworkInterfacesOutputResponse>(input: input, inputKey: \DescribeNetworkInterfacesInput.nextToken, outputKey: \DescribeNetworkInterfacesOutputResponse.nextToken, paginationFunction: self.describeNetworkInterfaces(input:))
    }
}

extension DescribeNetworkInterfacesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeNetworkInterfacesInput {
        return DescribeNetworkInterfacesInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            networkInterfaceIds: self.networkInterfaceIds,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeNetworkInterfacesPaginated`
/// to access the nested member `[EC2ClientTypes.NetworkInterface]`
/// - Returns: `[EC2ClientTypes.NetworkInterface]`
extension PaginatorSequence where Input == DescribeNetworkInterfacesInput, Output == DescribeNetworkInterfacesOutputResponse {
    public func networkInterfaces() async throws -> [EC2ClientTypes.NetworkInterface] {
        return try await self.asyncCompactMap { item in item.networkInterfaces }
    }
}

/// Paginate over `[DescribePrefixListsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribePrefixListsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribePrefixListsOutputResponse`
extension EC2Client {
    public func describePrefixListsPaginated(input: DescribePrefixListsInput) -> ClientRuntime.PaginatorSequence<DescribePrefixListsInput, DescribePrefixListsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribePrefixListsInput, DescribePrefixListsOutputResponse>(input: input, inputKey: \DescribePrefixListsInput.nextToken, outputKey: \DescribePrefixListsOutputResponse.nextToken, paginationFunction: self.describePrefixLists(input:))
    }
}

extension DescribePrefixListsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribePrefixListsInput {
        return DescribePrefixListsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            prefixListIds: self.prefixListIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describePrefixListsPaginated`
/// to access the nested member `[EC2ClientTypes.PrefixList]`
/// - Returns: `[EC2ClientTypes.PrefixList]`
extension PaginatorSequence where Input == DescribePrefixListsInput, Output == DescribePrefixListsOutputResponse {
    public func prefixLists() async throws -> [EC2ClientTypes.PrefixList] {
        return try await self.asyncCompactMap { item in item.prefixLists }
    }
}

/// Paginate over `[DescribePrincipalIdFormatOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribePrincipalIdFormatInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribePrincipalIdFormatOutputResponse`
extension EC2Client {
    public func describePrincipalIdFormatPaginated(input: DescribePrincipalIdFormatInput) -> ClientRuntime.PaginatorSequence<DescribePrincipalIdFormatInput, DescribePrincipalIdFormatOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribePrincipalIdFormatInput, DescribePrincipalIdFormatOutputResponse>(input: input, inputKey: \DescribePrincipalIdFormatInput.nextToken, outputKey: \DescribePrincipalIdFormatOutputResponse.nextToken, paginationFunction: self.describePrincipalIdFormat(input:))
    }
}

extension DescribePrincipalIdFormatInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribePrincipalIdFormatInput {
        return DescribePrincipalIdFormatInput(
            dryRun: self.dryRun,
            maxResults: self.maxResults,
            nextToken: token,
            resources: self.resources
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describePrincipalIdFormatPaginated`
/// to access the nested member `[EC2ClientTypes.PrincipalIdFormat]`
/// - Returns: `[EC2ClientTypes.PrincipalIdFormat]`
extension PaginatorSequence where Input == DescribePrincipalIdFormatInput, Output == DescribePrincipalIdFormatOutputResponse {
    public func principals() async throws -> [EC2ClientTypes.PrincipalIdFormat] {
        return try await self.asyncCompactMap { item in item.principals }
    }
}

/// Paginate over `[DescribePublicIpv4PoolsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribePublicIpv4PoolsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribePublicIpv4PoolsOutputResponse`
extension EC2Client {
    public func describePublicIpv4PoolsPaginated(input: DescribePublicIpv4PoolsInput) -> ClientRuntime.PaginatorSequence<DescribePublicIpv4PoolsInput, DescribePublicIpv4PoolsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribePublicIpv4PoolsInput, DescribePublicIpv4PoolsOutputResponse>(input: input, inputKey: \DescribePublicIpv4PoolsInput.nextToken, outputKey: \DescribePublicIpv4PoolsOutputResponse.nextToken, paginationFunction: self.describePublicIpv4Pools(input:))
    }
}

extension DescribePublicIpv4PoolsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribePublicIpv4PoolsInput {
        return DescribePublicIpv4PoolsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            poolIds: self.poolIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describePublicIpv4PoolsPaginated`
/// to access the nested member `[EC2ClientTypes.PublicIpv4Pool]`
/// - Returns: `[EC2ClientTypes.PublicIpv4Pool]`
extension PaginatorSequence where Input == DescribePublicIpv4PoolsInput, Output == DescribePublicIpv4PoolsOutputResponse {
    public func publicIpv4Pools() async throws -> [EC2ClientTypes.PublicIpv4Pool] {
        return try await self.asyncCompactMap { item in item.publicIpv4Pools }
    }
}

/// Paginate over `[DescribeReplaceRootVolumeTasksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeReplaceRootVolumeTasksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeReplaceRootVolumeTasksOutputResponse`
extension EC2Client {
    public func describeReplaceRootVolumeTasksPaginated(input: DescribeReplaceRootVolumeTasksInput) -> ClientRuntime.PaginatorSequence<DescribeReplaceRootVolumeTasksInput, DescribeReplaceRootVolumeTasksOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeReplaceRootVolumeTasksInput, DescribeReplaceRootVolumeTasksOutputResponse>(input: input, inputKey: \DescribeReplaceRootVolumeTasksInput.nextToken, outputKey: \DescribeReplaceRootVolumeTasksOutputResponse.nextToken, paginationFunction: self.describeReplaceRootVolumeTasks(input:))
    }
}

extension DescribeReplaceRootVolumeTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReplaceRootVolumeTasksInput {
        return DescribeReplaceRootVolumeTasksInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            replaceRootVolumeTaskIds: self.replaceRootVolumeTaskIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeReplaceRootVolumeTasksPaginated`
/// to access the nested member `[EC2ClientTypes.ReplaceRootVolumeTask]`
/// - Returns: `[EC2ClientTypes.ReplaceRootVolumeTask]`
extension PaginatorSequence where Input == DescribeReplaceRootVolumeTasksInput, Output == DescribeReplaceRootVolumeTasksOutputResponse {
    public func replaceRootVolumeTasks() async throws -> [EC2ClientTypes.ReplaceRootVolumeTask] {
        return try await self.asyncCompactMap { item in item.replaceRootVolumeTasks }
    }
}

/// Paginate over `[DescribeReservedInstancesModificationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeReservedInstancesModificationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeReservedInstancesModificationsOutputResponse`
extension EC2Client {
    public func describeReservedInstancesModificationsPaginated(input: DescribeReservedInstancesModificationsInput) -> ClientRuntime.PaginatorSequence<DescribeReservedInstancesModificationsInput, DescribeReservedInstancesModificationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeReservedInstancesModificationsInput, DescribeReservedInstancesModificationsOutputResponse>(input: input, inputKey: \DescribeReservedInstancesModificationsInput.nextToken, outputKey: \DescribeReservedInstancesModificationsOutputResponse.nextToken, paginationFunction: self.describeReservedInstancesModifications(input:))
    }
}

extension DescribeReservedInstancesModificationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReservedInstancesModificationsInput {
        return DescribeReservedInstancesModificationsInput(
            filters: self.filters,
            nextToken: token,
            reservedInstancesModificationIds: self.reservedInstancesModificationIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeReservedInstancesModificationsPaginated`
/// to access the nested member `[EC2ClientTypes.ReservedInstancesModification]`
/// - Returns: `[EC2ClientTypes.ReservedInstancesModification]`
extension PaginatorSequence where Input == DescribeReservedInstancesModificationsInput, Output == DescribeReservedInstancesModificationsOutputResponse {
    public func reservedInstancesModifications() async throws -> [EC2ClientTypes.ReservedInstancesModification] {
        return try await self.asyncCompactMap { item in item.reservedInstancesModifications }
    }
}

/// Paginate over `[DescribeReservedInstancesOfferingsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeReservedInstancesOfferingsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeReservedInstancesOfferingsOutputResponse`
extension EC2Client {
    public func describeReservedInstancesOfferingsPaginated(input: DescribeReservedInstancesOfferingsInput) -> ClientRuntime.PaginatorSequence<DescribeReservedInstancesOfferingsInput, DescribeReservedInstancesOfferingsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeReservedInstancesOfferingsInput, DescribeReservedInstancesOfferingsOutputResponse>(input: input, inputKey: \DescribeReservedInstancesOfferingsInput.nextToken, outputKey: \DescribeReservedInstancesOfferingsOutputResponse.nextToken, paginationFunction: self.describeReservedInstancesOfferings(input:))
    }
}

extension DescribeReservedInstancesOfferingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReservedInstancesOfferingsInput {
        return DescribeReservedInstancesOfferingsInput(
            availabilityZone: self.availabilityZone,
            dryRun: self.dryRun,
            filters: self.filters,
            includeMarketplace: self.includeMarketplace,
            instanceTenancy: self.instanceTenancy,
            instanceType: self.instanceType,
            maxDuration: self.maxDuration,
            maxInstanceCount: self.maxInstanceCount,
            maxResults: self.maxResults,
            minDuration: self.minDuration,
            nextToken: token,
            offeringClass: self.offeringClass,
            offeringType: self.offeringType,
            productDescription: self.productDescription,
            reservedInstancesOfferingIds: self.reservedInstancesOfferingIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeReservedInstancesOfferingsPaginated`
/// to access the nested member `[EC2ClientTypes.ReservedInstancesOffering]`
/// - Returns: `[EC2ClientTypes.ReservedInstancesOffering]`
extension PaginatorSequence where Input == DescribeReservedInstancesOfferingsInput, Output == DescribeReservedInstancesOfferingsOutputResponse {
    public func reservedInstancesOfferings() async throws -> [EC2ClientTypes.ReservedInstancesOffering] {
        return try await self.asyncCompactMap { item in item.reservedInstancesOfferings }
    }
}

/// Paginate over `[DescribeRouteTablesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeRouteTablesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeRouteTablesOutputResponse`
extension EC2Client {
    public func describeRouteTablesPaginated(input: DescribeRouteTablesInput) -> ClientRuntime.PaginatorSequence<DescribeRouteTablesInput, DescribeRouteTablesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeRouteTablesInput, DescribeRouteTablesOutputResponse>(input: input, inputKey: \DescribeRouteTablesInput.nextToken, outputKey: \DescribeRouteTablesOutputResponse.nextToken, paginationFunction: self.describeRouteTables(input:))
    }
}

extension DescribeRouteTablesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeRouteTablesInput {
        return DescribeRouteTablesInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            routeTableIds: self.routeTableIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeRouteTablesPaginated`
/// to access the nested member `[EC2ClientTypes.RouteTable]`
/// - Returns: `[EC2ClientTypes.RouteTable]`
extension PaginatorSequence where Input == DescribeRouteTablesInput, Output == DescribeRouteTablesOutputResponse {
    public func routeTables() async throws -> [EC2ClientTypes.RouteTable] {
        return try await self.asyncCompactMap { item in item.routeTables }
    }
}

/// Paginate over `[DescribeScheduledInstanceAvailabilityOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeScheduledInstanceAvailabilityInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeScheduledInstanceAvailabilityOutputResponse`
extension EC2Client {
    public func describeScheduledInstanceAvailabilityPaginated(input: DescribeScheduledInstanceAvailabilityInput) -> ClientRuntime.PaginatorSequence<DescribeScheduledInstanceAvailabilityInput, DescribeScheduledInstanceAvailabilityOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeScheduledInstanceAvailabilityInput, DescribeScheduledInstanceAvailabilityOutputResponse>(input: input, inputKey: \DescribeScheduledInstanceAvailabilityInput.nextToken, outputKey: \DescribeScheduledInstanceAvailabilityOutputResponse.nextToken, paginationFunction: self.describeScheduledInstanceAvailability(input:))
    }
}

extension DescribeScheduledInstanceAvailabilityInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeScheduledInstanceAvailabilityInput {
        return DescribeScheduledInstanceAvailabilityInput(
            dryRun: self.dryRun,
            filters: self.filters,
            firstSlotStartTimeRange: self.firstSlotStartTimeRange,
            maxResults: self.maxResults,
            maxSlotDurationInHours: self.maxSlotDurationInHours,
            minSlotDurationInHours: self.minSlotDurationInHours,
            nextToken: token,
            recurrence: self.recurrence
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeScheduledInstanceAvailabilityPaginated`
/// to access the nested member `[EC2ClientTypes.ScheduledInstanceAvailability]`
/// - Returns: `[EC2ClientTypes.ScheduledInstanceAvailability]`
extension PaginatorSequence where Input == DescribeScheduledInstanceAvailabilityInput, Output == DescribeScheduledInstanceAvailabilityOutputResponse {
    public func scheduledInstanceAvailabilitySet() async throws -> [EC2ClientTypes.ScheduledInstanceAvailability] {
        return try await self.asyncCompactMap { item in item.scheduledInstanceAvailabilitySet }
    }
}

/// Paginate over `[DescribeScheduledInstancesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeScheduledInstancesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeScheduledInstancesOutputResponse`
extension EC2Client {
    public func describeScheduledInstancesPaginated(input: DescribeScheduledInstancesInput) -> ClientRuntime.PaginatorSequence<DescribeScheduledInstancesInput, DescribeScheduledInstancesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeScheduledInstancesInput, DescribeScheduledInstancesOutputResponse>(input: input, inputKey: \DescribeScheduledInstancesInput.nextToken, outputKey: \DescribeScheduledInstancesOutputResponse.nextToken, paginationFunction: self.describeScheduledInstances(input:))
    }
}

extension DescribeScheduledInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeScheduledInstancesInput {
        return DescribeScheduledInstancesInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            scheduledInstanceIds: self.scheduledInstanceIds,
            slotStartTimeRange: self.slotStartTimeRange
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeScheduledInstancesPaginated`
/// to access the nested member `[EC2ClientTypes.ScheduledInstance]`
/// - Returns: `[EC2ClientTypes.ScheduledInstance]`
extension PaginatorSequence where Input == DescribeScheduledInstancesInput, Output == DescribeScheduledInstancesOutputResponse {
    public func scheduledInstanceSet() async throws -> [EC2ClientTypes.ScheduledInstance] {
        return try await self.asyncCompactMap { item in item.scheduledInstanceSet }
    }
}

/// Paginate over `[DescribeSecurityGroupRulesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeSecurityGroupRulesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeSecurityGroupRulesOutputResponse`
extension EC2Client {
    public func describeSecurityGroupRulesPaginated(input: DescribeSecurityGroupRulesInput) -> ClientRuntime.PaginatorSequence<DescribeSecurityGroupRulesInput, DescribeSecurityGroupRulesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeSecurityGroupRulesInput, DescribeSecurityGroupRulesOutputResponse>(input: input, inputKey: \DescribeSecurityGroupRulesInput.nextToken, outputKey: \DescribeSecurityGroupRulesOutputResponse.nextToken, paginationFunction: self.describeSecurityGroupRules(input:))
    }
}

extension DescribeSecurityGroupRulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSecurityGroupRulesInput {
        return DescribeSecurityGroupRulesInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            securityGroupRuleIds: self.securityGroupRuleIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeSecurityGroupRulesPaginated`
/// to access the nested member `[EC2ClientTypes.SecurityGroupRule]`
/// - Returns: `[EC2ClientTypes.SecurityGroupRule]`
extension PaginatorSequence where Input == DescribeSecurityGroupRulesInput, Output == DescribeSecurityGroupRulesOutputResponse {
    public func securityGroupRules() async throws -> [EC2ClientTypes.SecurityGroupRule] {
        return try await self.asyncCompactMap { item in item.securityGroupRules }
    }
}

/// Paginate over `[DescribeSecurityGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeSecurityGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeSecurityGroupsOutputResponse`
extension EC2Client {
    public func describeSecurityGroupsPaginated(input: DescribeSecurityGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeSecurityGroupsInput, DescribeSecurityGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeSecurityGroupsInput, DescribeSecurityGroupsOutputResponse>(input: input, inputKey: \DescribeSecurityGroupsInput.nextToken, outputKey: \DescribeSecurityGroupsOutputResponse.nextToken, paginationFunction: self.describeSecurityGroups(input:))
    }
}

extension DescribeSecurityGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSecurityGroupsInput {
        return DescribeSecurityGroupsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            groupIds: self.groupIds,
            groupNames: self.groupNames,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeSecurityGroupsPaginated`
/// to access the nested member `[EC2ClientTypes.SecurityGroup]`
/// - Returns: `[EC2ClientTypes.SecurityGroup]`
extension PaginatorSequence where Input == DescribeSecurityGroupsInput, Output == DescribeSecurityGroupsOutputResponse {
    public func securityGroups() async throws -> [EC2ClientTypes.SecurityGroup] {
        return try await self.asyncCompactMap { item in item.securityGroups }
    }
}

/// Paginate over `[DescribeSnapshotsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeSnapshotsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeSnapshotsOutputResponse`
extension EC2Client {
    public func describeSnapshotsPaginated(input: DescribeSnapshotsInput) -> ClientRuntime.PaginatorSequence<DescribeSnapshotsInput, DescribeSnapshotsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeSnapshotsInput, DescribeSnapshotsOutputResponse>(input: input, inputKey: \DescribeSnapshotsInput.nextToken, outputKey: \DescribeSnapshotsOutputResponse.nextToken, paginationFunction: self.describeSnapshots(input:))
    }
}

extension DescribeSnapshotsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSnapshotsInput {
        return DescribeSnapshotsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            ownerIds: self.ownerIds,
            restorableByUserIds: self.restorableByUserIds,
            snapshotIds: self.snapshotIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeSnapshotsPaginated`
/// to access the nested member `[EC2ClientTypes.Snapshot]`
/// - Returns: `[EC2ClientTypes.Snapshot]`
extension PaginatorSequence where Input == DescribeSnapshotsInput, Output == DescribeSnapshotsOutputResponse {
    public func snapshots() async throws -> [EC2ClientTypes.Snapshot] {
        return try await self.asyncCompactMap { item in item.snapshots }
    }
}

/// Paginate over `[DescribeSnapshotTierStatusOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeSnapshotTierStatusInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeSnapshotTierStatusOutputResponse`
extension EC2Client {
    public func describeSnapshotTierStatusPaginated(input: DescribeSnapshotTierStatusInput) -> ClientRuntime.PaginatorSequence<DescribeSnapshotTierStatusInput, DescribeSnapshotTierStatusOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeSnapshotTierStatusInput, DescribeSnapshotTierStatusOutputResponse>(input: input, inputKey: \DescribeSnapshotTierStatusInput.nextToken, outputKey: \DescribeSnapshotTierStatusOutputResponse.nextToken, paginationFunction: self.describeSnapshotTierStatus(input:))
    }
}

extension DescribeSnapshotTierStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSnapshotTierStatusInput {
        return DescribeSnapshotTierStatusInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeSnapshotTierStatusPaginated`
/// to access the nested member `[EC2ClientTypes.SnapshotTierStatus]`
/// - Returns: `[EC2ClientTypes.SnapshotTierStatus]`
extension PaginatorSequence where Input == DescribeSnapshotTierStatusInput, Output == DescribeSnapshotTierStatusOutputResponse {
    public func snapshotTierStatuses() async throws -> [EC2ClientTypes.SnapshotTierStatus] {
        return try await self.asyncCompactMap { item in item.snapshotTierStatuses }
    }
}

/// Paginate over `[DescribeSpotFleetRequestsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeSpotFleetRequestsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeSpotFleetRequestsOutputResponse`
extension EC2Client {
    public func describeSpotFleetRequestsPaginated(input: DescribeSpotFleetRequestsInput) -> ClientRuntime.PaginatorSequence<DescribeSpotFleetRequestsInput, DescribeSpotFleetRequestsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeSpotFleetRequestsInput, DescribeSpotFleetRequestsOutputResponse>(input: input, inputKey: \DescribeSpotFleetRequestsInput.nextToken, outputKey: \DescribeSpotFleetRequestsOutputResponse.nextToken, paginationFunction: self.describeSpotFleetRequests(input:))
    }
}

extension DescribeSpotFleetRequestsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSpotFleetRequestsInput {
        return DescribeSpotFleetRequestsInput(
            dryRun: self.dryRun,
            maxResults: self.maxResults,
            nextToken: token,
            spotFleetRequestIds: self.spotFleetRequestIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeSpotFleetRequestsPaginated`
/// to access the nested member `[EC2ClientTypes.SpotFleetRequestConfig]`
/// - Returns: `[EC2ClientTypes.SpotFleetRequestConfig]`
extension PaginatorSequence where Input == DescribeSpotFleetRequestsInput, Output == DescribeSpotFleetRequestsOutputResponse {
    public func spotFleetRequestConfigs() async throws -> [EC2ClientTypes.SpotFleetRequestConfig] {
        return try await self.asyncCompactMap { item in item.spotFleetRequestConfigs }
    }
}

/// Paginate over `[DescribeSpotInstanceRequestsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeSpotInstanceRequestsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeSpotInstanceRequestsOutputResponse`
extension EC2Client {
    public func describeSpotInstanceRequestsPaginated(input: DescribeSpotInstanceRequestsInput) -> ClientRuntime.PaginatorSequence<DescribeSpotInstanceRequestsInput, DescribeSpotInstanceRequestsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeSpotInstanceRequestsInput, DescribeSpotInstanceRequestsOutputResponse>(input: input, inputKey: \DescribeSpotInstanceRequestsInput.nextToken, outputKey: \DescribeSpotInstanceRequestsOutputResponse.nextToken, paginationFunction: self.describeSpotInstanceRequests(input:))
    }
}

extension DescribeSpotInstanceRequestsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSpotInstanceRequestsInput {
        return DescribeSpotInstanceRequestsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            spotInstanceRequestIds: self.spotInstanceRequestIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeSpotInstanceRequestsPaginated`
/// to access the nested member `[EC2ClientTypes.SpotInstanceRequest]`
/// - Returns: `[EC2ClientTypes.SpotInstanceRequest]`
extension PaginatorSequence where Input == DescribeSpotInstanceRequestsInput, Output == DescribeSpotInstanceRequestsOutputResponse {
    public func spotInstanceRequests() async throws -> [EC2ClientTypes.SpotInstanceRequest] {
        return try await self.asyncCompactMap { item in item.spotInstanceRequests }
    }
}

/// Paginate over `[DescribeSpotPriceHistoryOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeSpotPriceHistoryInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeSpotPriceHistoryOutputResponse`
extension EC2Client {
    public func describeSpotPriceHistoryPaginated(input: DescribeSpotPriceHistoryInput) -> ClientRuntime.PaginatorSequence<DescribeSpotPriceHistoryInput, DescribeSpotPriceHistoryOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeSpotPriceHistoryInput, DescribeSpotPriceHistoryOutputResponse>(input: input, inputKey: \DescribeSpotPriceHistoryInput.nextToken, outputKey: \DescribeSpotPriceHistoryOutputResponse.nextToken, paginationFunction: self.describeSpotPriceHistory(input:))
    }
}

extension DescribeSpotPriceHistoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSpotPriceHistoryInput {
        return DescribeSpotPriceHistoryInput(
            availabilityZone: self.availabilityZone,
            dryRun: self.dryRun,
            endTime: self.endTime,
            filters: self.filters,
            instanceTypes: self.instanceTypes,
            maxResults: self.maxResults,
            nextToken: token,
            productDescriptions: self.productDescriptions,
            startTime: self.startTime
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeSpotPriceHistoryPaginated`
/// to access the nested member `[EC2ClientTypes.SpotPrice]`
/// - Returns: `[EC2ClientTypes.SpotPrice]`
extension PaginatorSequence where Input == DescribeSpotPriceHistoryInput, Output == DescribeSpotPriceHistoryOutputResponse {
    public func spotPriceHistory() async throws -> [EC2ClientTypes.SpotPrice] {
        return try await self.asyncCompactMap { item in item.spotPriceHistory }
    }
}

/// Paginate over `[DescribeStaleSecurityGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeStaleSecurityGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeStaleSecurityGroupsOutputResponse`
extension EC2Client {
    public func describeStaleSecurityGroupsPaginated(input: DescribeStaleSecurityGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeStaleSecurityGroupsInput, DescribeStaleSecurityGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeStaleSecurityGroupsInput, DescribeStaleSecurityGroupsOutputResponse>(input: input, inputKey: \DescribeStaleSecurityGroupsInput.nextToken, outputKey: \DescribeStaleSecurityGroupsOutputResponse.nextToken, paginationFunction: self.describeStaleSecurityGroups(input:))
    }
}

extension DescribeStaleSecurityGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeStaleSecurityGroupsInput {
        return DescribeStaleSecurityGroupsInput(
            dryRun: self.dryRun,
            maxResults: self.maxResults,
            nextToken: token,
            vpcId: self.vpcId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeStaleSecurityGroupsPaginated`
/// to access the nested member `[EC2ClientTypes.StaleSecurityGroup]`
/// - Returns: `[EC2ClientTypes.StaleSecurityGroup]`
extension PaginatorSequence where Input == DescribeStaleSecurityGroupsInput, Output == DescribeStaleSecurityGroupsOutputResponse {
    public func staleSecurityGroupSet() async throws -> [EC2ClientTypes.StaleSecurityGroup] {
        return try await self.asyncCompactMap { item in item.staleSecurityGroupSet }
    }
}

/// Paginate over `[DescribeStoreImageTasksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeStoreImageTasksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeStoreImageTasksOutputResponse`
extension EC2Client {
    public func describeStoreImageTasksPaginated(input: DescribeStoreImageTasksInput) -> ClientRuntime.PaginatorSequence<DescribeStoreImageTasksInput, DescribeStoreImageTasksOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeStoreImageTasksInput, DescribeStoreImageTasksOutputResponse>(input: input, inputKey: \DescribeStoreImageTasksInput.nextToken, outputKey: \DescribeStoreImageTasksOutputResponse.nextToken, paginationFunction: self.describeStoreImageTasks(input:))
    }
}

extension DescribeStoreImageTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeStoreImageTasksInput {
        return DescribeStoreImageTasksInput(
            dryRun: self.dryRun,
            filters: self.filters,
            imageIds: self.imageIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeStoreImageTasksPaginated`
/// to access the nested member `[EC2ClientTypes.StoreImageTaskResult]`
/// - Returns: `[EC2ClientTypes.StoreImageTaskResult]`
extension PaginatorSequence where Input == DescribeStoreImageTasksInput, Output == DescribeStoreImageTasksOutputResponse {
    public func storeImageTaskResults() async throws -> [EC2ClientTypes.StoreImageTaskResult] {
        return try await self.asyncCompactMap { item in item.storeImageTaskResults }
    }
}

/// Paginate over `[DescribeSubnetsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeSubnetsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeSubnetsOutputResponse`
extension EC2Client {
    public func describeSubnetsPaginated(input: DescribeSubnetsInput) -> ClientRuntime.PaginatorSequence<DescribeSubnetsInput, DescribeSubnetsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeSubnetsInput, DescribeSubnetsOutputResponse>(input: input, inputKey: \DescribeSubnetsInput.nextToken, outputKey: \DescribeSubnetsOutputResponse.nextToken, paginationFunction: self.describeSubnets(input:))
    }
}

extension DescribeSubnetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSubnetsInput {
        return DescribeSubnetsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            subnetIds: self.subnetIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeSubnetsPaginated`
/// to access the nested member `[EC2ClientTypes.Subnet]`
/// - Returns: `[EC2ClientTypes.Subnet]`
extension PaginatorSequence where Input == DescribeSubnetsInput, Output == DescribeSubnetsOutputResponse {
    public func subnets() async throws -> [EC2ClientTypes.Subnet] {
        return try await self.asyncCompactMap { item in item.subnets }
    }
}

/// Paginate over `[DescribeTagsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeTagsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeTagsOutputResponse`
extension EC2Client {
    public func describeTagsPaginated(input: DescribeTagsInput) -> ClientRuntime.PaginatorSequence<DescribeTagsInput, DescribeTagsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeTagsInput, DescribeTagsOutputResponse>(input: input, inputKey: \DescribeTagsInput.nextToken, outputKey: \DescribeTagsOutputResponse.nextToken, paginationFunction: self.describeTags(input:))
    }
}

extension DescribeTagsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTagsInput {
        return DescribeTagsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeTagsPaginated`
/// to access the nested member `[EC2ClientTypes.TagDescription]`
/// - Returns: `[EC2ClientTypes.TagDescription]`
extension PaginatorSequence where Input == DescribeTagsInput, Output == DescribeTagsOutputResponse {
    public func tags() async throws -> [EC2ClientTypes.TagDescription] {
        return try await self.asyncCompactMap { item in item.tags }
    }
}

/// Paginate over `[DescribeTrafficMirrorFiltersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeTrafficMirrorFiltersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeTrafficMirrorFiltersOutputResponse`
extension EC2Client {
    public func describeTrafficMirrorFiltersPaginated(input: DescribeTrafficMirrorFiltersInput) -> ClientRuntime.PaginatorSequence<DescribeTrafficMirrorFiltersInput, DescribeTrafficMirrorFiltersOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeTrafficMirrorFiltersInput, DescribeTrafficMirrorFiltersOutputResponse>(input: input, inputKey: \DescribeTrafficMirrorFiltersInput.nextToken, outputKey: \DescribeTrafficMirrorFiltersOutputResponse.nextToken, paginationFunction: self.describeTrafficMirrorFilters(input:))
    }
}

extension DescribeTrafficMirrorFiltersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTrafficMirrorFiltersInput {
        return DescribeTrafficMirrorFiltersInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            trafficMirrorFilterIds: self.trafficMirrorFilterIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeTrafficMirrorFiltersPaginated`
/// to access the nested member `[EC2ClientTypes.TrafficMirrorFilter]`
/// - Returns: `[EC2ClientTypes.TrafficMirrorFilter]`
extension PaginatorSequence where Input == DescribeTrafficMirrorFiltersInput, Output == DescribeTrafficMirrorFiltersOutputResponse {
    public func trafficMirrorFilters() async throws -> [EC2ClientTypes.TrafficMirrorFilter] {
        return try await self.asyncCompactMap { item in item.trafficMirrorFilters }
    }
}

/// Paginate over `[DescribeTrafficMirrorSessionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeTrafficMirrorSessionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeTrafficMirrorSessionsOutputResponse`
extension EC2Client {
    public func describeTrafficMirrorSessionsPaginated(input: DescribeTrafficMirrorSessionsInput) -> ClientRuntime.PaginatorSequence<DescribeTrafficMirrorSessionsInput, DescribeTrafficMirrorSessionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeTrafficMirrorSessionsInput, DescribeTrafficMirrorSessionsOutputResponse>(input: input, inputKey: \DescribeTrafficMirrorSessionsInput.nextToken, outputKey: \DescribeTrafficMirrorSessionsOutputResponse.nextToken, paginationFunction: self.describeTrafficMirrorSessions(input:))
    }
}

extension DescribeTrafficMirrorSessionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTrafficMirrorSessionsInput {
        return DescribeTrafficMirrorSessionsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            trafficMirrorSessionIds: self.trafficMirrorSessionIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeTrafficMirrorSessionsPaginated`
/// to access the nested member `[EC2ClientTypes.TrafficMirrorSession]`
/// - Returns: `[EC2ClientTypes.TrafficMirrorSession]`
extension PaginatorSequence where Input == DescribeTrafficMirrorSessionsInput, Output == DescribeTrafficMirrorSessionsOutputResponse {
    public func trafficMirrorSessions() async throws -> [EC2ClientTypes.TrafficMirrorSession] {
        return try await self.asyncCompactMap { item in item.trafficMirrorSessions }
    }
}

/// Paginate over `[DescribeTrafficMirrorTargetsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeTrafficMirrorTargetsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeTrafficMirrorTargetsOutputResponse`
extension EC2Client {
    public func describeTrafficMirrorTargetsPaginated(input: DescribeTrafficMirrorTargetsInput) -> ClientRuntime.PaginatorSequence<DescribeTrafficMirrorTargetsInput, DescribeTrafficMirrorTargetsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeTrafficMirrorTargetsInput, DescribeTrafficMirrorTargetsOutputResponse>(input: input, inputKey: \DescribeTrafficMirrorTargetsInput.nextToken, outputKey: \DescribeTrafficMirrorTargetsOutputResponse.nextToken, paginationFunction: self.describeTrafficMirrorTargets(input:))
    }
}

extension DescribeTrafficMirrorTargetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTrafficMirrorTargetsInput {
        return DescribeTrafficMirrorTargetsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            trafficMirrorTargetIds: self.trafficMirrorTargetIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeTrafficMirrorTargetsPaginated`
/// to access the nested member `[EC2ClientTypes.TrafficMirrorTarget]`
/// - Returns: `[EC2ClientTypes.TrafficMirrorTarget]`
extension PaginatorSequence where Input == DescribeTrafficMirrorTargetsInput, Output == DescribeTrafficMirrorTargetsOutputResponse {
    public func trafficMirrorTargets() async throws -> [EC2ClientTypes.TrafficMirrorTarget] {
        return try await self.asyncCompactMap { item in item.trafficMirrorTargets }
    }
}

/// Paginate over `[DescribeTransitGatewayAttachmentsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeTransitGatewayAttachmentsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeTransitGatewayAttachmentsOutputResponse`
extension EC2Client {
    public func describeTransitGatewayAttachmentsPaginated(input: DescribeTransitGatewayAttachmentsInput) -> ClientRuntime.PaginatorSequence<DescribeTransitGatewayAttachmentsInput, DescribeTransitGatewayAttachmentsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeTransitGatewayAttachmentsInput, DescribeTransitGatewayAttachmentsOutputResponse>(input: input, inputKey: \DescribeTransitGatewayAttachmentsInput.nextToken, outputKey: \DescribeTransitGatewayAttachmentsOutputResponse.nextToken, paginationFunction: self.describeTransitGatewayAttachments(input:))
    }
}

extension DescribeTransitGatewayAttachmentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTransitGatewayAttachmentsInput {
        return DescribeTransitGatewayAttachmentsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayAttachmentIds: self.transitGatewayAttachmentIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeTransitGatewayAttachmentsPaginated`
/// to access the nested member `[EC2ClientTypes.TransitGatewayAttachment]`
/// - Returns: `[EC2ClientTypes.TransitGatewayAttachment]`
extension PaginatorSequence where Input == DescribeTransitGatewayAttachmentsInput, Output == DescribeTransitGatewayAttachmentsOutputResponse {
    public func transitGatewayAttachments() async throws -> [EC2ClientTypes.TransitGatewayAttachment] {
        return try await self.asyncCompactMap { item in item.transitGatewayAttachments }
    }
}

/// Paginate over `[DescribeTransitGatewayConnectPeersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeTransitGatewayConnectPeersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeTransitGatewayConnectPeersOutputResponse`
extension EC2Client {
    public func describeTransitGatewayConnectPeersPaginated(input: DescribeTransitGatewayConnectPeersInput) -> ClientRuntime.PaginatorSequence<DescribeTransitGatewayConnectPeersInput, DescribeTransitGatewayConnectPeersOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeTransitGatewayConnectPeersInput, DescribeTransitGatewayConnectPeersOutputResponse>(input: input, inputKey: \DescribeTransitGatewayConnectPeersInput.nextToken, outputKey: \DescribeTransitGatewayConnectPeersOutputResponse.nextToken, paginationFunction: self.describeTransitGatewayConnectPeers(input:))
    }
}

extension DescribeTransitGatewayConnectPeersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTransitGatewayConnectPeersInput {
        return DescribeTransitGatewayConnectPeersInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayConnectPeerIds: self.transitGatewayConnectPeerIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeTransitGatewayConnectPeersPaginated`
/// to access the nested member `[EC2ClientTypes.TransitGatewayConnectPeer]`
/// - Returns: `[EC2ClientTypes.TransitGatewayConnectPeer]`
extension PaginatorSequence where Input == DescribeTransitGatewayConnectPeersInput, Output == DescribeTransitGatewayConnectPeersOutputResponse {
    public func transitGatewayConnectPeers() async throws -> [EC2ClientTypes.TransitGatewayConnectPeer] {
        return try await self.asyncCompactMap { item in item.transitGatewayConnectPeers }
    }
}

/// Paginate over `[DescribeTransitGatewayConnectsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeTransitGatewayConnectsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeTransitGatewayConnectsOutputResponse`
extension EC2Client {
    public func describeTransitGatewayConnectsPaginated(input: DescribeTransitGatewayConnectsInput) -> ClientRuntime.PaginatorSequence<DescribeTransitGatewayConnectsInput, DescribeTransitGatewayConnectsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeTransitGatewayConnectsInput, DescribeTransitGatewayConnectsOutputResponse>(input: input, inputKey: \DescribeTransitGatewayConnectsInput.nextToken, outputKey: \DescribeTransitGatewayConnectsOutputResponse.nextToken, paginationFunction: self.describeTransitGatewayConnects(input:))
    }
}

extension DescribeTransitGatewayConnectsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTransitGatewayConnectsInput {
        return DescribeTransitGatewayConnectsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayAttachmentIds: self.transitGatewayAttachmentIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeTransitGatewayConnectsPaginated`
/// to access the nested member `[EC2ClientTypes.TransitGatewayConnect]`
/// - Returns: `[EC2ClientTypes.TransitGatewayConnect]`
extension PaginatorSequence where Input == DescribeTransitGatewayConnectsInput, Output == DescribeTransitGatewayConnectsOutputResponse {
    public func transitGatewayConnects() async throws -> [EC2ClientTypes.TransitGatewayConnect] {
        return try await self.asyncCompactMap { item in item.transitGatewayConnects }
    }
}

/// Paginate over `[DescribeTransitGatewayMulticastDomainsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeTransitGatewayMulticastDomainsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeTransitGatewayMulticastDomainsOutputResponse`
extension EC2Client {
    public func describeTransitGatewayMulticastDomainsPaginated(input: DescribeTransitGatewayMulticastDomainsInput) -> ClientRuntime.PaginatorSequence<DescribeTransitGatewayMulticastDomainsInput, DescribeTransitGatewayMulticastDomainsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeTransitGatewayMulticastDomainsInput, DescribeTransitGatewayMulticastDomainsOutputResponse>(input: input, inputKey: \DescribeTransitGatewayMulticastDomainsInput.nextToken, outputKey: \DescribeTransitGatewayMulticastDomainsOutputResponse.nextToken, paginationFunction: self.describeTransitGatewayMulticastDomains(input:))
    }
}

extension DescribeTransitGatewayMulticastDomainsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTransitGatewayMulticastDomainsInput {
        return DescribeTransitGatewayMulticastDomainsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayMulticastDomainIds: self.transitGatewayMulticastDomainIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeTransitGatewayMulticastDomainsPaginated`
/// to access the nested member `[EC2ClientTypes.TransitGatewayMulticastDomain]`
/// - Returns: `[EC2ClientTypes.TransitGatewayMulticastDomain]`
extension PaginatorSequence where Input == DescribeTransitGatewayMulticastDomainsInput, Output == DescribeTransitGatewayMulticastDomainsOutputResponse {
    public func transitGatewayMulticastDomains() async throws -> [EC2ClientTypes.TransitGatewayMulticastDomain] {
        return try await self.asyncCompactMap { item in item.transitGatewayMulticastDomains }
    }
}

/// Paginate over `[DescribeTransitGatewayPeeringAttachmentsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeTransitGatewayPeeringAttachmentsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeTransitGatewayPeeringAttachmentsOutputResponse`
extension EC2Client {
    public func describeTransitGatewayPeeringAttachmentsPaginated(input: DescribeTransitGatewayPeeringAttachmentsInput) -> ClientRuntime.PaginatorSequence<DescribeTransitGatewayPeeringAttachmentsInput, DescribeTransitGatewayPeeringAttachmentsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeTransitGatewayPeeringAttachmentsInput, DescribeTransitGatewayPeeringAttachmentsOutputResponse>(input: input, inputKey: \DescribeTransitGatewayPeeringAttachmentsInput.nextToken, outputKey: \DescribeTransitGatewayPeeringAttachmentsOutputResponse.nextToken, paginationFunction: self.describeTransitGatewayPeeringAttachments(input:))
    }
}

extension DescribeTransitGatewayPeeringAttachmentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTransitGatewayPeeringAttachmentsInput {
        return DescribeTransitGatewayPeeringAttachmentsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayAttachmentIds: self.transitGatewayAttachmentIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeTransitGatewayPeeringAttachmentsPaginated`
/// to access the nested member `[EC2ClientTypes.TransitGatewayPeeringAttachment]`
/// - Returns: `[EC2ClientTypes.TransitGatewayPeeringAttachment]`
extension PaginatorSequence where Input == DescribeTransitGatewayPeeringAttachmentsInput, Output == DescribeTransitGatewayPeeringAttachmentsOutputResponse {
    public func transitGatewayPeeringAttachments() async throws -> [EC2ClientTypes.TransitGatewayPeeringAttachment] {
        return try await self.asyncCompactMap { item in item.transitGatewayPeeringAttachments }
    }
}

/// Paginate over `[DescribeTransitGatewayPolicyTablesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeTransitGatewayPolicyTablesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeTransitGatewayPolicyTablesOutputResponse`
extension EC2Client {
    public func describeTransitGatewayPolicyTablesPaginated(input: DescribeTransitGatewayPolicyTablesInput) -> ClientRuntime.PaginatorSequence<DescribeTransitGatewayPolicyTablesInput, DescribeTransitGatewayPolicyTablesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeTransitGatewayPolicyTablesInput, DescribeTransitGatewayPolicyTablesOutputResponse>(input: input, inputKey: \DescribeTransitGatewayPolicyTablesInput.nextToken, outputKey: \DescribeTransitGatewayPolicyTablesOutputResponse.nextToken, paginationFunction: self.describeTransitGatewayPolicyTables(input:))
    }
}

extension DescribeTransitGatewayPolicyTablesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTransitGatewayPolicyTablesInput {
        return DescribeTransitGatewayPolicyTablesInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayPolicyTableIds: self.transitGatewayPolicyTableIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeTransitGatewayPolicyTablesPaginated`
/// to access the nested member `[EC2ClientTypes.TransitGatewayPolicyTable]`
/// - Returns: `[EC2ClientTypes.TransitGatewayPolicyTable]`
extension PaginatorSequence where Input == DescribeTransitGatewayPolicyTablesInput, Output == DescribeTransitGatewayPolicyTablesOutputResponse {
    public func transitGatewayPolicyTables() async throws -> [EC2ClientTypes.TransitGatewayPolicyTable] {
        return try await self.asyncCompactMap { item in item.transitGatewayPolicyTables }
    }
}

/// Paginate over `[DescribeTransitGatewayRouteTableAnnouncementsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeTransitGatewayRouteTableAnnouncementsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeTransitGatewayRouteTableAnnouncementsOutputResponse`
extension EC2Client {
    public func describeTransitGatewayRouteTableAnnouncementsPaginated(input: DescribeTransitGatewayRouteTableAnnouncementsInput) -> ClientRuntime.PaginatorSequence<DescribeTransitGatewayRouteTableAnnouncementsInput, DescribeTransitGatewayRouteTableAnnouncementsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeTransitGatewayRouteTableAnnouncementsInput, DescribeTransitGatewayRouteTableAnnouncementsOutputResponse>(input: input, inputKey: \DescribeTransitGatewayRouteTableAnnouncementsInput.nextToken, outputKey: \DescribeTransitGatewayRouteTableAnnouncementsOutputResponse.nextToken, paginationFunction: self.describeTransitGatewayRouteTableAnnouncements(input:))
    }
}

extension DescribeTransitGatewayRouteTableAnnouncementsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTransitGatewayRouteTableAnnouncementsInput {
        return DescribeTransitGatewayRouteTableAnnouncementsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayRouteTableAnnouncementIds: self.transitGatewayRouteTableAnnouncementIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeTransitGatewayRouteTableAnnouncementsPaginated`
/// to access the nested member `[EC2ClientTypes.TransitGatewayRouteTableAnnouncement]`
/// - Returns: `[EC2ClientTypes.TransitGatewayRouteTableAnnouncement]`
extension PaginatorSequence where Input == DescribeTransitGatewayRouteTableAnnouncementsInput, Output == DescribeTransitGatewayRouteTableAnnouncementsOutputResponse {
    public func transitGatewayRouteTableAnnouncements() async throws -> [EC2ClientTypes.TransitGatewayRouteTableAnnouncement] {
        return try await self.asyncCompactMap { item in item.transitGatewayRouteTableAnnouncements }
    }
}

/// Paginate over `[DescribeTransitGatewayRouteTablesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeTransitGatewayRouteTablesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeTransitGatewayRouteTablesOutputResponse`
extension EC2Client {
    public func describeTransitGatewayRouteTablesPaginated(input: DescribeTransitGatewayRouteTablesInput) -> ClientRuntime.PaginatorSequence<DescribeTransitGatewayRouteTablesInput, DescribeTransitGatewayRouteTablesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeTransitGatewayRouteTablesInput, DescribeTransitGatewayRouteTablesOutputResponse>(input: input, inputKey: \DescribeTransitGatewayRouteTablesInput.nextToken, outputKey: \DescribeTransitGatewayRouteTablesOutputResponse.nextToken, paginationFunction: self.describeTransitGatewayRouteTables(input:))
    }
}

extension DescribeTransitGatewayRouteTablesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTransitGatewayRouteTablesInput {
        return DescribeTransitGatewayRouteTablesInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayRouteTableIds: self.transitGatewayRouteTableIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeTransitGatewayRouteTablesPaginated`
/// to access the nested member `[EC2ClientTypes.TransitGatewayRouteTable]`
/// - Returns: `[EC2ClientTypes.TransitGatewayRouteTable]`
extension PaginatorSequence where Input == DescribeTransitGatewayRouteTablesInput, Output == DescribeTransitGatewayRouteTablesOutputResponse {
    public func transitGatewayRouteTables() async throws -> [EC2ClientTypes.TransitGatewayRouteTable] {
        return try await self.asyncCompactMap { item in item.transitGatewayRouteTables }
    }
}

/// Paginate over `[DescribeTransitGatewaysOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeTransitGatewaysInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeTransitGatewaysOutputResponse`
extension EC2Client {
    public func describeTransitGatewaysPaginated(input: DescribeTransitGatewaysInput) -> ClientRuntime.PaginatorSequence<DescribeTransitGatewaysInput, DescribeTransitGatewaysOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeTransitGatewaysInput, DescribeTransitGatewaysOutputResponse>(input: input, inputKey: \DescribeTransitGatewaysInput.nextToken, outputKey: \DescribeTransitGatewaysOutputResponse.nextToken, paginationFunction: self.describeTransitGateways(input:))
    }
}

extension DescribeTransitGatewaysInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTransitGatewaysInput {
        return DescribeTransitGatewaysInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayIds: self.transitGatewayIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeTransitGatewaysPaginated`
/// to access the nested member `[EC2ClientTypes.TransitGateway]`
/// - Returns: `[EC2ClientTypes.TransitGateway]`
extension PaginatorSequence where Input == DescribeTransitGatewaysInput, Output == DescribeTransitGatewaysOutputResponse {
    public func transitGateways() async throws -> [EC2ClientTypes.TransitGateway] {
        return try await self.asyncCompactMap { item in item.transitGateways }
    }
}

/// Paginate over `[DescribeTransitGatewayVpcAttachmentsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeTransitGatewayVpcAttachmentsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeTransitGatewayVpcAttachmentsOutputResponse`
extension EC2Client {
    public func describeTransitGatewayVpcAttachmentsPaginated(input: DescribeTransitGatewayVpcAttachmentsInput) -> ClientRuntime.PaginatorSequence<DescribeTransitGatewayVpcAttachmentsInput, DescribeTransitGatewayVpcAttachmentsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeTransitGatewayVpcAttachmentsInput, DescribeTransitGatewayVpcAttachmentsOutputResponse>(input: input, inputKey: \DescribeTransitGatewayVpcAttachmentsInput.nextToken, outputKey: \DescribeTransitGatewayVpcAttachmentsOutputResponse.nextToken, paginationFunction: self.describeTransitGatewayVpcAttachments(input:))
    }
}

extension DescribeTransitGatewayVpcAttachmentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTransitGatewayVpcAttachmentsInput {
        return DescribeTransitGatewayVpcAttachmentsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayAttachmentIds: self.transitGatewayAttachmentIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeTransitGatewayVpcAttachmentsPaginated`
/// to access the nested member `[EC2ClientTypes.TransitGatewayVpcAttachment]`
/// - Returns: `[EC2ClientTypes.TransitGatewayVpcAttachment]`
extension PaginatorSequence where Input == DescribeTransitGatewayVpcAttachmentsInput, Output == DescribeTransitGatewayVpcAttachmentsOutputResponse {
    public func transitGatewayVpcAttachments() async throws -> [EC2ClientTypes.TransitGatewayVpcAttachment] {
        return try await self.asyncCompactMap { item in item.transitGatewayVpcAttachments }
    }
}

/// Paginate over `[DescribeTrunkInterfaceAssociationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeTrunkInterfaceAssociationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeTrunkInterfaceAssociationsOutputResponse`
extension EC2Client {
    public func describeTrunkInterfaceAssociationsPaginated(input: DescribeTrunkInterfaceAssociationsInput) -> ClientRuntime.PaginatorSequence<DescribeTrunkInterfaceAssociationsInput, DescribeTrunkInterfaceAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeTrunkInterfaceAssociationsInput, DescribeTrunkInterfaceAssociationsOutputResponse>(input: input, inputKey: \DescribeTrunkInterfaceAssociationsInput.nextToken, outputKey: \DescribeTrunkInterfaceAssociationsOutputResponse.nextToken, paginationFunction: self.describeTrunkInterfaceAssociations(input:))
    }
}

extension DescribeTrunkInterfaceAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTrunkInterfaceAssociationsInput {
        return DescribeTrunkInterfaceAssociationsInput(
            associationIds: self.associationIds,
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeTrunkInterfaceAssociationsPaginated`
/// to access the nested member `[EC2ClientTypes.TrunkInterfaceAssociation]`
/// - Returns: `[EC2ClientTypes.TrunkInterfaceAssociation]`
extension PaginatorSequence where Input == DescribeTrunkInterfaceAssociationsInput, Output == DescribeTrunkInterfaceAssociationsOutputResponse {
    public func interfaceAssociations() async throws -> [EC2ClientTypes.TrunkInterfaceAssociation] {
        return try await self.asyncCompactMap { item in item.interfaceAssociations }
    }
}

/// Paginate over `[DescribeVerifiedAccessEndpointsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeVerifiedAccessEndpointsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeVerifiedAccessEndpointsOutputResponse`
extension EC2Client {
    public func describeVerifiedAccessEndpointsPaginated(input: DescribeVerifiedAccessEndpointsInput) -> ClientRuntime.PaginatorSequence<DescribeVerifiedAccessEndpointsInput, DescribeVerifiedAccessEndpointsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeVerifiedAccessEndpointsInput, DescribeVerifiedAccessEndpointsOutputResponse>(input: input, inputKey: \DescribeVerifiedAccessEndpointsInput.nextToken, outputKey: \DescribeVerifiedAccessEndpointsOutputResponse.nextToken, paginationFunction: self.describeVerifiedAccessEndpoints(input:))
    }
}

extension DescribeVerifiedAccessEndpointsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeVerifiedAccessEndpointsInput {
        return DescribeVerifiedAccessEndpointsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            verifiedAccessEndpointIds: self.verifiedAccessEndpointIds,
            verifiedAccessGroupId: self.verifiedAccessGroupId,
            verifiedAccessInstanceId: self.verifiedAccessInstanceId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeVerifiedAccessEndpointsPaginated`
/// to access the nested member `[EC2ClientTypes.VerifiedAccessEndpoint]`
/// - Returns: `[EC2ClientTypes.VerifiedAccessEndpoint]`
extension PaginatorSequence where Input == DescribeVerifiedAccessEndpointsInput, Output == DescribeVerifiedAccessEndpointsOutputResponse {
    public func verifiedAccessEndpoints() async throws -> [EC2ClientTypes.VerifiedAccessEndpoint] {
        return try await self.asyncCompactMap { item in item.verifiedAccessEndpoints }
    }
}

/// Paginate over `[DescribeVerifiedAccessGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeVerifiedAccessGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeVerifiedAccessGroupsOutputResponse`
extension EC2Client {
    public func describeVerifiedAccessGroupsPaginated(input: DescribeVerifiedAccessGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeVerifiedAccessGroupsInput, DescribeVerifiedAccessGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeVerifiedAccessGroupsInput, DescribeVerifiedAccessGroupsOutputResponse>(input: input, inputKey: \DescribeVerifiedAccessGroupsInput.nextToken, outputKey: \DescribeVerifiedAccessGroupsOutputResponse.nextToken, paginationFunction: self.describeVerifiedAccessGroups(input:))
    }
}

extension DescribeVerifiedAccessGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeVerifiedAccessGroupsInput {
        return DescribeVerifiedAccessGroupsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            verifiedAccessGroupIds: self.verifiedAccessGroupIds,
            verifiedAccessInstanceId: self.verifiedAccessInstanceId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeVerifiedAccessGroupsPaginated`
/// to access the nested member `[EC2ClientTypes.VerifiedAccessGroup]`
/// - Returns: `[EC2ClientTypes.VerifiedAccessGroup]`
extension PaginatorSequence where Input == DescribeVerifiedAccessGroupsInput, Output == DescribeVerifiedAccessGroupsOutputResponse {
    public func verifiedAccessGroups() async throws -> [EC2ClientTypes.VerifiedAccessGroup] {
        return try await self.asyncCompactMap { item in item.verifiedAccessGroups }
    }
}

/// Paginate over `[DescribeVerifiedAccessInstanceLoggingConfigurationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeVerifiedAccessInstanceLoggingConfigurationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeVerifiedAccessInstanceLoggingConfigurationsOutputResponse`
extension EC2Client {
    public func describeVerifiedAccessInstanceLoggingConfigurationsPaginated(input: DescribeVerifiedAccessInstanceLoggingConfigurationsInput) -> ClientRuntime.PaginatorSequence<DescribeVerifiedAccessInstanceLoggingConfigurationsInput, DescribeVerifiedAccessInstanceLoggingConfigurationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeVerifiedAccessInstanceLoggingConfigurationsInput, DescribeVerifiedAccessInstanceLoggingConfigurationsOutputResponse>(input: input, inputKey: \DescribeVerifiedAccessInstanceLoggingConfigurationsInput.nextToken, outputKey: \DescribeVerifiedAccessInstanceLoggingConfigurationsOutputResponse.nextToken, paginationFunction: self.describeVerifiedAccessInstanceLoggingConfigurations(input:))
    }
}

extension DescribeVerifiedAccessInstanceLoggingConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeVerifiedAccessInstanceLoggingConfigurationsInput {
        return DescribeVerifiedAccessInstanceLoggingConfigurationsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            verifiedAccessInstanceIds: self.verifiedAccessInstanceIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeVerifiedAccessInstanceLoggingConfigurationsPaginated`
/// to access the nested member `[EC2ClientTypes.VerifiedAccessInstanceLoggingConfiguration]`
/// - Returns: `[EC2ClientTypes.VerifiedAccessInstanceLoggingConfiguration]`
extension PaginatorSequence where Input == DescribeVerifiedAccessInstanceLoggingConfigurationsInput, Output == DescribeVerifiedAccessInstanceLoggingConfigurationsOutputResponse {
    public func loggingConfigurations() async throws -> [EC2ClientTypes.VerifiedAccessInstanceLoggingConfiguration] {
        return try await self.asyncCompactMap { item in item.loggingConfigurations }
    }
}

/// Paginate over `[DescribeVerifiedAccessInstancesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeVerifiedAccessInstancesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeVerifiedAccessInstancesOutputResponse`
extension EC2Client {
    public func describeVerifiedAccessInstancesPaginated(input: DescribeVerifiedAccessInstancesInput) -> ClientRuntime.PaginatorSequence<DescribeVerifiedAccessInstancesInput, DescribeVerifiedAccessInstancesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeVerifiedAccessInstancesInput, DescribeVerifiedAccessInstancesOutputResponse>(input: input, inputKey: \DescribeVerifiedAccessInstancesInput.nextToken, outputKey: \DescribeVerifiedAccessInstancesOutputResponse.nextToken, paginationFunction: self.describeVerifiedAccessInstances(input:))
    }
}

extension DescribeVerifiedAccessInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeVerifiedAccessInstancesInput {
        return DescribeVerifiedAccessInstancesInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            verifiedAccessInstanceIds: self.verifiedAccessInstanceIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeVerifiedAccessInstancesPaginated`
/// to access the nested member `[EC2ClientTypes.VerifiedAccessInstance]`
/// - Returns: `[EC2ClientTypes.VerifiedAccessInstance]`
extension PaginatorSequence where Input == DescribeVerifiedAccessInstancesInput, Output == DescribeVerifiedAccessInstancesOutputResponse {
    public func verifiedAccessInstances() async throws -> [EC2ClientTypes.VerifiedAccessInstance] {
        return try await self.asyncCompactMap { item in item.verifiedAccessInstances }
    }
}

/// Paginate over `[DescribeVerifiedAccessTrustProvidersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeVerifiedAccessTrustProvidersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeVerifiedAccessTrustProvidersOutputResponse`
extension EC2Client {
    public func describeVerifiedAccessTrustProvidersPaginated(input: DescribeVerifiedAccessTrustProvidersInput) -> ClientRuntime.PaginatorSequence<DescribeVerifiedAccessTrustProvidersInput, DescribeVerifiedAccessTrustProvidersOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeVerifiedAccessTrustProvidersInput, DescribeVerifiedAccessTrustProvidersOutputResponse>(input: input, inputKey: \DescribeVerifiedAccessTrustProvidersInput.nextToken, outputKey: \DescribeVerifiedAccessTrustProvidersOutputResponse.nextToken, paginationFunction: self.describeVerifiedAccessTrustProviders(input:))
    }
}

extension DescribeVerifiedAccessTrustProvidersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeVerifiedAccessTrustProvidersInput {
        return DescribeVerifiedAccessTrustProvidersInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            verifiedAccessTrustProviderIds: self.verifiedAccessTrustProviderIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeVerifiedAccessTrustProvidersPaginated`
/// to access the nested member `[EC2ClientTypes.VerifiedAccessTrustProvider]`
/// - Returns: `[EC2ClientTypes.VerifiedAccessTrustProvider]`
extension PaginatorSequence where Input == DescribeVerifiedAccessTrustProvidersInput, Output == DescribeVerifiedAccessTrustProvidersOutputResponse {
    public func verifiedAccessTrustProviders() async throws -> [EC2ClientTypes.VerifiedAccessTrustProvider] {
        return try await self.asyncCompactMap { item in item.verifiedAccessTrustProviders }
    }
}

/// Paginate over `[DescribeVolumesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeVolumesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeVolumesOutputResponse`
extension EC2Client {
    public func describeVolumesPaginated(input: DescribeVolumesInput) -> ClientRuntime.PaginatorSequence<DescribeVolumesInput, DescribeVolumesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeVolumesInput, DescribeVolumesOutputResponse>(input: input, inputKey: \DescribeVolumesInput.nextToken, outputKey: \DescribeVolumesOutputResponse.nextToken, paginationFunction: self.describeVolumes(input:))
    }
}

extension DescribeVolumesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeVolumesInput {
        return DescribeVolumesInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            volumeIds: self.volumeIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeVolumesPaginated`
/// to access the nested member `[EC2ClientTypes.Volume]`
/// - Returns: `[EC2ClientTypes.Volume]`
extension PaginatorSequence where Input == DescribeVolumesInput, Output == DescribeVolumesOutputResponse {
    public func volumes() async throws -> [EC2ClientTypes.Volume] {
        return try await self.asyncCompactMap { item in item.volumes }
    }
}

/// Paginate over `[DescribeVolumesModificationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeVolumesModificationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeVolumesModificationsOutputResponse`
extension EC2Client {
    public func describeVolumesModificationsPaginated(input: DescribeVolumesModificationsInput) -> ClientRuntime.PaginatorSequence<DescribeVolumesModificationsInput, DescribeVolumesModificationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeVolumesModificationsInput, DescribeVolumesModificationsOutputResponse>(input: input, inputKey: \DescribeVolumesModificationsInput.nextToken, outputKey: \DescribeVolumesModificationsOutputResponse.nextToken, paginationFunction: self.describeVolumesModifications(input:))
    }
}

extension DescribeVolumesModificationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeVolumesModificationsInput {
        return DescribeVolumesModificationsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            volumeIds: self.volumeIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeVolumesModificationsPaginated`
/// to access the nested member `[EC2ClientTypes.VolumeModification]`
/// - Returns: `[EC2ClientTypes.VolumeModification]`
extension PaginatorSequence where Input == DescribeVolumesModificationsInput, Output == DescribeVolumesModificationsOutputResponse {
    public func volumesModifications() async throws -> [EC2ClientTypes.VolumeModification] {
        return try await self.asyncCompactMap { item in item.volumesModifications }
    }
}

/// Paginate over `[DescribeVolumeStatusOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeVolumeStatusInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeVolumeStatusOutputResponse`
extension EC2Client {
    public func describeVolumeStatusPaginated(input: DescribeVolumeStatusInput) -> ClientRuntime.PaginatorSequence<DescribeVolumeStatusInput, DescribeVolumeStatusOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeVolumeStatusInput, DescribeVolumeStatusOutputResponse>(input: input, inputKey: \DescribeVolumeStatusInput.nextToken, outputKey: \DescribeVolumeStatusOutputResponse.nextToken, paginationFunction: self.describeVolumeStatus(input:))
    }
}

extension DescribeVolumeStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeVolumeStatusInput {
        return DescribeVolumeStatusInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            volumeIds: self.volumeIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeVolumeStatusPaginated`
/// to access the nested member `[EC2ClientTypes.VolumeStatusItem]`
/// - Returns: `[EC2ClientTypes.VolumeStatusItem]`
extension PaginatorSequence where Input == DescribeVolumeStatusInput, Output == DescribeVolumeStatusOutputResponse {
    public func volumeStatuses() async throws -> [EC2ClientTypes.VolumeStatusItem] {
        return try await self.asyncCompactMap { item in item.volumeStatuses }
    }
}

/// Paginate over `[DescribeVpcClassicLinkDnsSupportOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeVpcClassicLinkDnsSupportInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeVpcClassicLinkDnsSupportOutputResponse`
extension EC2Client {
    public func describeVpcClassicLinkDnsSupportPaginated(input: DescribeVpcClassicLinkDnsSupportInput) -> ClientRuntime.PaginatorSequence<DescribeVpcClassicLinkDnsSupportInput, DescribeVpcClassicLinkDnsSupportOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeVpcClassicLinkDnsSupportInput, DescribeVpcClassicLinkDnsSupportOutputResponse>(input: input, inputKey: \DescribeVpcClassicLinkDnsSupportInput.nextToken, outputKey: \DescribeVpcClassicLinkDnsSupportOutputResponse.nextToken, paginationFunction: self.describeVpcClassicLinkDnsSupport(input:))
    }
}

extension DescribeVpcClassicLinkDnsSupportInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeVpcClassicLinkDnsSupportInput {
        return DescribeVpcClassicLinkDnsSupportInput(
            maxResults: self.maxResults,
            nextToken: token,
            vpcIds: self.vpcIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeVpcClassicLinkDnsSupportPaginated`
/// to access the nested member `[EC2ClientTypes.ClassicLinkDnsSupport]`
/// - Returns: `[EC2ClientTypes.ClassicLinkDnsSupport]`
extension PaginatorSequence where Input == DescribeVpcClassicLinkDnsSupportInput, Output == DescribeVpcClassicLinkDnsSupportOutputResponse {
    public func vpcs() async throws -> [EC2ClientTypes.ClassicLinkDnsSupport] {
        return try await self.asyncCompactMap { item in item.vpcs }
    }
}

/// Paginate over `[DescribeVpcEndpointConnectionNotificationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeVpcEndpointConnectionNotificationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeVpcEndpointConnectionNotificationsOutputResponse`
extension EC2Client {
    public func describeVpcEndpointConnectionNotificationsPaginated(input: DescribeVpcEndpointConnectionNotificationsInput) -> ClientRuntime.PaginatorSequence<DescribeVpcEndpointConnectionNotificationsInput, DescribeVpcEndpointConnectionNotificationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeVpcEndpointConnectionNotificationsInput, DescribeVpcEndpointConnectionNotificationsOutputResponse>(input: input, inputKey: \DescribeVpcEndpointConnectionNotificationsInput.nextToken, outputKey: \DescribeVpcEndpointConnectionNotificationsOutputResponse.nextToken, paginationFunction: self.describeVpcEndpointConnectionNotifications(input:))
    }
}

extension DescribeVpcEndpointConnectionNotificationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeVpcEndpointConnectionNotificationsInput {
        return DescribeVpcEndpointConnectionNotificationsInput(
            connectionNotificationId: self.connectionNotificationId,
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeVpcEndpointConnectionNotificationsPaginated`
/// to access the nested member `[EC2ClientTypes.ConnectionNotification]`
/// - Returns: `[EC2ClientTypes.ConnectionNotification]`
extension PaginatorSequence where Input == DescribeVpcEndpointConnectionNotificationsInput, Output == DescribeVpcEndpointConnectionNotificationsOutputResponse {
    public func connectionNotificationSet() async throws -> [EC2ClientTypes.ConnectionNotification] {
        return try await self.asyncCompactMap { item in item.connectionNotificationSet }
    }
}

/// Paginate over `[DescribeVpcEndpointConnectionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeVpcEndpointConnectionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeVpcEndpointConnectionsOutputResponse`
extension EC2Client {
    public func describeVpcEndpointConnectionsPaginated(input: DescribeVpcEndpointConnectionsInput) -> ClientRuntime.PaginatorSequence<DescribeVpcEndpointConnectionsInput, DescribeVpcEndpointConnectionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeVpcEndpointConnectionsInput, DescribeVpcEndpointConnectionsOutputResponse>(input: input, inputKey: \DescribeVpcEndpointConnectionsInput.nextToken, outputKey: \DescribeVpcEndpointConnectionsOutputResponse.nextToken, paginationFunction: self.describeVpcEndpointConnections(input:))
    }
}

extension DescribeVpcEndpointConnectionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeVpcEndpointConnectionsInput {
        return DescribeVpcEndpointConnectionsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeVpcEndpointConnectionsPaginated`
/// to access the nested member `[EC2ClientTypes.VpcEndpointConnection]`
/// - Returns: `[EC2ClientTypes.VpcEndpointConnection]`
extension PaginatorSequence where Input == DescribeVpcEndpointConnectionsInput, Output == DescribeVpcEndpointConnectionsOutputResponse {
    public func vpcEndpointConnections() async throws -> [EC2ClientTypes.VpcEndpointConnection] {
        return try await self.asyncCompactMap { item in item.vpcEndpointConnections }
    }
}

/// Paginate over `[DescribeVpcEndpointsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeVpcEndpointsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeVpcEndpointsOutputResponse`
extension EC2Client {
    public func describeVpcEndpointsPaginated(input: DescribeVpcEndpointsInput) -> ClientRuntime.PaginatorSequence<DescribeVpcEndpointsInput, DescribeVpcEndpointsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeVpcEndpointsInput, DescribeVpcEndpointsOutputResponse>(input: input, inputKey: \DescribeVpcEndpointsInput.nextToken, outputKey: \DescribeVpcEndpointsOutputResponse.nextToken, paginationFunction: self.describeVpcEndpoints(input:))
    }
}

extension DescribeVpcEndpointsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeVpcEndpointsInput {
        return DescribeVpcEndpointsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            vpcEndpointIds: self.vpcEndpointIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeVpcEndpointsPaginated`
/// to access the nested member `[EC2ClientTypes.VpcEndpoint]`
/// - Returns: `[EC2ClientTypes.VpcEndpoint]`
extension PaginatorSequence where Input == DescribeVpcEndpointsInput, Output == DescribeVpcEndpointsOutputResponse {
    public func vpcEndpoints() async throws -> [EC2ClientTypes.VpcEndpoint] {
        return try await self.asyncCompactMap { item in item.vpcEndpoints }
    }
}

/// Paginate over `[DescribeVpcEndpointServiceConfigurationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeVpcEndpointServiceConfigurationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeVpcEndpointServiceConfigurationsOutputResponse`
extension EC2Client {
    public func describeVpcEndpointServiceConfigurationsPaginated(input: DescribeVpcEndpointServiceConfigurationsInput) -> ClientRuntime.PaginatorSequence<DescribeVpcEndpointServiceConfigurationsInput, DescribeVpcEndpointServiceConfigurationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeVpcEndpointServiceConfigurationsInput, DescribeVpcEndpointServiceConfigurationsOutputResponse>(input: input, inputKey: \DescribeVpcEndpointServiceConfigurationsInput.nextToken, outputKey: \DescribeVpcEndpointServiceConfigurationsOutputResponse.nextToken, paginationFunction: self.describeVpcEndpointServiceConfigurations(input:))
    }
}

extension DescribeVpcEndpointServiceConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeVpcEndpointServiceConfigurationsInput {
        return DescribeVpcEndpointServiceConfigurationsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            serviceIds: self.serviceIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeVpcEndpointServiceConfigurationsPaginated`
/// to access the nested member `[EC2ClientTypes.ServiceConfiguration]`
/// - Returns: `[EC2ClientTypes.ServiceConfiguration]`
extension PaginatorSequence where Input == DescribeVpcEndpointServiceConfigurationsInput, Output == DescribeVpcEndpointServiceConfigurationsOutputResponse {
    public func serviceConfigurations() async throws -> [EC2ClientTypes.ServiceConfiguration] {
        return try await self.asyncCompactMap { item in item.serviceConfigurations }
    }
}

/// Paginate over `[DescribeVpcEndpointServicePermissionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeVpcEndpointServicePermissionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeVpcEndpointServicePermissionsOutputResponse`
extension EC2Client {
    public func describeVpcEndpointServicePermissionsPaginated(input: DescribeVpcEndpointServicePermissionsInput) -> ClientRuntime.PaginatorSequence<DescribeVpcEndpointServicePermissionsInput, DescribeVpcEndpointServicePermissionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeVpcEndpointServicePermissionsInput, DescribeVpcEndpointServicePermissionsOutputResponse>(input: input, inputKey: \DescribeVpcEndpointServicePermissionsInput.nextToken, outputKey: \DescribeVpcEndpointServicePermissionsOutputResponse.nextToken, paginationFunction: self.describeVpcEndpointServicePermissions(input:))
    }
}

extension DescribeVpcEndpointServicePermissionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeVpcEndpointServicePermissionsInput {
        return DescribeVpcEndpointServicePermissionsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            serviceId: self.serviceId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeVpcEndpointServicePermissionsPaginated`
/// to access the nested member `[EC2ClientTypes.AllowedPrincipal]`
/// - Returns: `[EC2ClientTypes.AllowedPrincipal]`
extension PaginatorSequence where Input == DescribeVpcEndpointServicePermissionsInput, Output == DescribeVpcEndpointServicePermissionsOutputResponse {
    public func allowedPrincipals() async throws -> [EC2ClientTypes.AllowedPrincipal] {
        return try await self.asyncCompactMap { item in item.allowedPrincipals }
    }
}

/// Paginate over `[DescribeVpcPeeringConnectionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeVpcPeeringConnectionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeVpcPeeringConnectionsOutputResponse`
extension EC2Client {
    public func describeVpcPeeringConnectionsPaginated(input: DescribeVpcPeeringConnectionsInput) -> ClientRuntime.PaginatorSequence<DescribeVpcPeeringConnectionsInput, DescribeVpcPeeringConnectionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeVpcPeeringConnectionsInput, DescribeVpcPeeringConnectionsOutputResponse>(input: input, inputKey: \DescribeVpcPeeringConnectionsInput.nextToken, outputKey: \DescribeVpcPeeringConnectionsOutputResponse.nextToken, paginationFunction: self.describeVpcPeeringConnections(input:))
    }
}

extension DescribeVpcPeeringConnectionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeVpcPeeringConnectionsInput {
        return DescribeVpcPeeringConnectionsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            vpcPeeringConnectionIds: self.vpcPeeringConnectionIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeVpcPeeringConnectionsPaginated`
/// to access the nested member `[EC2ClientTypes.VpcPeeringConnection]`
/// - Returns: `[EC2ClientTypes.VpcPeeringConnection]`
extension PaginatorSequence where Input == DescribeVpcPeeringConnectionsInput, Output == DescribeVpcPeeringConnectionsOutputResponse {
    public func vpcPeeringConnections() async throws -> [EC2ClientTypes.VpcPeeringConnection] {
        return try await self.asyncCompactMap { item in item.vpcPeeringConnections }
    }
}

/// Paginate over `[DescribeVpcsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeVpcsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeVpcsOutputResponse`
extension EC2Client {
    public func describeVpcsPaginated(input: DescribeVpcsInput) -> ClientRuntime.PaginatorSequence<DescribeVpcsInput, DescribeVpcsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeVpcsInput, DescribeVpcsOutputResponse>(input: input, inputKey: \DescribeVpcsInput.nextToken, outputKey: \DescribeVpcsOutputResponse.nextToken, paginationFunction: self.describeVpcs(input:))
    }
}

extension DescribeVpcsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeVpcsInput {
        return DescribeVpcsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            vpcIds: self.vpcIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeVpcsPaginated`
/// to access the nested member `[EC2ClientTypes.Vpc]`
/// - Returns: `[EC2ClientTypes.Vpc]`
extension PaginatorSequence where Input == DescribeVpcsInput, Output == DescribeVpcsOutputResponse {
    public func vpcs() async throws -> [EC2ClientTypes.Vpc] {
        return try await self.asyncCompactMap { item in item.vpcs }
    }
}

/// Paginate over `[GetAssociatedIpv6PoolCidrsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetAssociatedIpv6PoolCidrsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetAssociatedIpv6PoolCidrsOutputResponse`
extension EC2Client {
    public func getAssociatedIpv6PoolCidrsPaginated(input: GetAssociatedIpv6PoolCidrsInput) -> ClientRuntime.PaginatorSequence<GetAssociatedIpv6PoolCidrsInput, GetAssociatedIpv6PoolCidrsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetAssociatedIpv6PoolCidrsInput, GetAssociatedIpv6PoolCidrsOutputResponse>(input: input, inputKey: \GetAssociatedIpv6PoolCidrsInput.nextToken, outputKey: \GetAssociatedIpv6PoolCidrsOutputResponse.nextToken, paginationFunction: self.getAssociatedIpv6PoolCidrs(input:))
    }
}

extension GetAssociatedIpv6PoolCidrsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetAssociatedIpv6PoolCidrsInput {
        return GetAssociatedIpv6PoolCidrsInput(
            dryRun: self.dryRun,
            maxResults: self.maxResults,
            nextToken: token,
            poolId: self.poolId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getAssociatedIpv6PoolCidrsPaginated`
/// to access the nested member `[EC2ClientTypes.Ipv6CidrAssociation]`
/// - Returns: `[EC2ClientTypes.Ipv6CidrAssociation]`
extension PaginatorSequence where Input == GetAssociatedIpv6PoolCidrsInput, Output == GetAssociatedIpv6PoolCidrsOutputResponse {
    public func ipv6CidrAssociations() async throws -> [EC2ClientTypes.Ipv6CidrAssociation] {
        return try await self.asyncCompactMap { item in item.ipv6CidrAssociations }
    }
}

/// Paginate over `[GetAwsNetworkPerformanceDataOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetAwsNetworkPerformanceDataInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetAwsNetworkPerformanceDataOutputResponse`
extension EC2Client {
    public func getAwsNetworkPerformanceDataPaginated(input: GetAwsNetworkPerformanceDataInput) -> ClientRuntime.PaginatorSequence<GetAwsNetworkPerformanceDataInput, GetAwsNetworkPerformanceDataOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetAwsNetworkPerformanceDataInput, GetAwsNetworkPerformanceDataOutputResponse>(input: input, inputKey: \GetAwsNetworkPerformanceDataInput.nextToken, outputKey: \GetAwsNetworkPerformanceDataOutputResponse.nextToken, paginationFunction: self.getAwsNetworkPerformanceData(input:))
    }
}

extension GetAwsNetworkPerformanceDataInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetAwsNetworkPerformanceDataInput {
        return GetAwsNetworkPerformanceDataInput(
            dataQueries: self.dataQueries,
            dryRun: self.dryRun,
            endTime: self.endTime,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getAwsNetworkPerformanceDataPaginated`
/// to access the nested member `[EC2ClientTypes.DataResponse]`
/// - Returns: `[EC2ClientTypes.DataResponse]`
extension PaginatorSequence where Input == GetAwsNetworkPerformanceDataInput, Output == GetAwsNetworkPerformanceDataOutputResponse {
    public func dataResponses() async throws -> [EC2ClientTypes.DataResponse] {
        return try await self.asyncCompactMap { item in item.dataResponses }
    }
}

/// Paginate over `[GetGroupsForCapacityReservationOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetGroupsForCapacityReservationInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetGroupsForCapacityReservationOutputResponse`
extension EC2Client {
    public func getGroupsForCapacityReservationPaginated(input: GetGroupsForCapacityReservationInput) -> ClientRuntime.PaginatorSequence<GetGroupsForCapacityReservationInput, GetGroupsForCapacityReservationOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetGroupsForCapacityReservationInput, GetGroupsForCapacityReservationOutputResponse>(input: input, inputKey: \GetGroupsForCapacityReservationInput.nextToken, outputKey: \GetGroupsForCapacityReservationOutputResponse.nextToken, paginationFunction: self.getGroupsForCapacityReservation(input:))
    }
}

extension GetGroupsForCapacityReservationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetGroupsForCapacityReservationInput {
        return GetGroupsForCapacityReservationInput(
            capacityReservationId: self.capacityReservationId,
            dryRun: self.dryRun,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getGroupsForCapacityReservationPaginated`
/// to access the nested member `[EC2ClientTypes.CapacityReservationGroup]`
/// - Returns: `[EC2ClientTypes.CapacityReservationGroup]`
extension PaginatorSequence where Input == GetGroupsForCapacityReservationInput, Output == GetGroupsForCapacityReservationOutputResponse {
    public func capacityReservationGroups() async throws -> [EC2ClientTypes.CapacityReservationGroup] {
        return try await self.asyncCompactMap { item in item.capacityReservationGroups }
    }
}

/// Paginate over `[GetInstanceTypesFromInstanceRequirementsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetInstanceTypesFromInstanceRequirementsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetInstanceTypesFromInstanceRequirementsOutputResponse`
extension EC2Client {
    public func getInstanceTypesFromInstanceRequirementsPaginated(input: GetInstanceTypesFromInstanceRequirementsInput) -> ClientRuntime.PaginatorSequence<GetInstanceTypesFromInstanceRequirementsInput, GetInstanceTypesFromInstanceRequirementsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetInstanceTypesFromInstanceRequirementsInput, GetInstanceTypesFromInstanceRequirementsOutputResponse>(input: input, inputKey: \GetInstanceTypesFromInstanceRequirementsInput.nextToken, outputKey: \GetInstanceTypesFromInstanceRequirementsOutputResponse.nextToken, paginationFunction: self.getInstanceTypesFromInstanceRequirements(input:))
    }
}

extension GetInstanceTypesFromInstanceRequirementsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetInstanceTypesFromInstanceRequirementsInput {
        return GetInstanceTypesFromInstanceRequirementsInput(
            architectureTypes: self.architectureTypes,
            dryRun: self.dryRun,
            instanceRequirements: self.instanceRequirements,
            maxResults: self.maxResults,
            nextToken: token,
            virtualizationTypes: self.virtualizationTypes
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getInstanceTypesFromInstanceRequirementsPaginated`
/// to access the nested member `[EC2ClientTypes.InstanceTypeInfoFromInstanceRequirements]`
/// - Returns: `[EC2ClientTypes.InstanceTypeInfoFromInstanceRequirements]`
extension PaginatorSequence where Input == GetInstanceTypesFromInstanceRequirementsInput, Output == GetInstanceTypesFromInstanceRequirementsOutputResponse {
    public func instanceTypes() async throws -> [EC2ClientTypes.InstanceTypeInfoFromInstanceRequirements] {
        return try await self.asyncCompactMap { item in item.instanceTypes }
    }
}

/// Paginate over `[GetIpamAddressHistoryOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetIpamAddressHistoryInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetIpamAddressHistoryOutputResponse`
extension EC2Client {
    public func getIpamAddressHistoryPaginated(input: GetIpamAddressHistoryInput) -> ClientRuntime.PaginatorSequence<GetIpamAddressHistoryInput, GetIpamAddressHistoryOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetIpamAddressHistoryInput, GetIpamAddressHistoryOutputResponse>(input: input, inputKey: \GetIpamAddressHistoryInput.nextToken, outputKey: \GetIpamAddressHistoryOutputResponse.nextToken, paginationFunction: self.getIpamAddressHistory(input:))
    }
}

extension GetIpamAddressHistoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetIpamAddressHistoryInput {
        return GetIpamAddressHistoryInput(
            cidr: self.cidr,
            dryRun: self.dryRun,
            endTime: self.endTime,
            ipamScopeId: self.ipamScopeId,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime,
            vpcId: self.vpcId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getIpamAddressHistoryPaginated`
/// to access the nested member `[EC2ClientTypes.IpamAddressHistoryRecord]`
/// - Returns: `[EC2ClientTypes.IpamAddressHistoryRecord]`
extension PaginatorSequence where Input == GetIpamAddressHistoryInput, Output == GetIpamAddressHistoryOutputResponse {
    public func historyRecords() async throws -> [EC2ClientTypes.IpamAddressHistoryRecord] {
        return try await self.asyncCompactMap { item in item.historyRecords }
    }
}

/// Paginate over `[GetIpamPoolAllocationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetIpamPoolAllocationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetIpamPoolAllocationsOutputResponse`
extension EC2Client {
    public func getIpamPoolAllocationsPaginated(input: GetIpamPoolAllocationsInput) -> ClientRuntime.PaginatorSequence<GetIpamPoolAllocationsInput, GetIpamPoolAllocationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetIpamPoolAllocationsInput, GetIpamPoolAllocationsOutputResponse>(input: input, inputKey: \GetIpamPoolAllocationsInput.nextToken, outputKey: \GetIpamPoolAllocationsOutputResponse.nextToken, paginationFunction: self.getIpamPoolAllocations(input:))
    }
}

extension GetIpamPoolAllocationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetIpamPoolAllocationsInput {
        return GetIpamPoolAllocationsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            ipamPoolAllocationId: self.ipamPoolAllocationId,
            ipamPoolId: self.ipamPoolId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getIpamPoolAllocationsPaginated`
/// to access the nested member `[EC2ClientTypes.IpamPoolAllocation]`
/// - Returns: `[EC2ClientTypes.IpamPoolAllocation]`
extension PaginatorSequence where Input == GetIpamPoolAllocationsInput, Output == GetIpamPoolAllocationsOutputResponse {
    public func ipamPoolAllocations() async throws -> [EC2ClientTypes.IpamPoolAllocation] {
        return try await self.asyncCompactMap { item in item.ipamPoolAllocations }
    }
}

/// Paginate over `[GetIpamPoolCidrsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetIpamPoolCidrsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetIpamPoolCidrsOutputResponse`
extension EC2Client {
    public func getIpamPoolCidrsPaginated(input: GetIpamPoolCidrsInput) -> ClientRuntime.PaginatorSequence<GetIpamPoolCidrsInput, GetIpamPoolCidrsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetIpamPoolCidrsInput, GetIpamPoolCidrsOutputResponse>(input: input, inputKey: \GetIpamPoolCidrsInput.nextToken, outputKey: \GetIpamPoolCidrsOutputResponse.nextToken, paginationFunction: self.getIpamPoolCidrs(input:))
    }
}

extension GetIpamPoolCidrsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetIpamPoolCidrsInput {
        return GetIpamPoolCidrsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            ipamPoolId: self.ipamPoolId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getIpamPoolCidrsPaginated`
/// to access the nested member `[EC2ClientTypes.IpamPoolCidr]`
/// - Returns: `[EC2ClientTypes.IpamPoolCidr]`
extension PaginatorSequence where Input == GetIpamPoolCidrsInput, Output == GetIpamPoolCidrsOutputResponse {
    public func ipamPoolCidrs() async throws -> [EC2ClientTypes.IpamPoolCidr] {
        return try await self.asyncCompactMap { item in item.ipamPoolCidrs }
    }
}

/// Paginate over `[GetIpamResourceCidrsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetIpamResourceCidrsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetIpamResourceCidrsOutputResponse`
extension EC2Client {
    public func getIpamResourceCidrsPaginated(input: GetIpamResourceCidrsInput) -> ClientRuntime.PaginatorSequence<GetIpamResourceCidrsInput, GetIpamResourceCidrsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetIpamResourceCidrsInput, GetIpamResourceCidrsOutputResponse>(input: input, inputKey: \GetIpamResourceCidrsInput.nextToken, outputKey: \GetIpamResourceCidrsOutputResponse.nextToken, paginationFunction: self.getIpamResourceCidrs(input:))
    }
}

extension GetIpamResourceCidrsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetIpamResourceCidrsInput {
        return GetIpamResourceCidrsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            ipamPoolId: self.ipamPoolId,
            ipamScopeId: self.ipamScopeId,
            maxResults: self.maxResults,
            nextToken: token,
            resourceId: self.resourceId,
            resourceOwner: self.resourceOwner,
            resourceTag: self.resourceTag,
            resourceType: self.resourceType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getIpamResourceCidrsPaginated`
/// to access the nested member `[EC2ClientTypes.IpamResourceCidr]`
/// - Returns: `[EC2ClientTypes.IpamResourceCidr]`
extension PaginatorSequence where Input == GetIpamResourceCidrsInput, Output == GetIpamResourceCidrsOutputResponse {
    public func ipamResourceCidrs() async throws -> [EC2ClientTypes.IpamResourceCidr] {
        return try await self.asyncCompactMap { item in item.ipamResourceCidrs }
    }
}

/// Paginate over `[GetManagedPrefixListAssociationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetManagedPrefixListAssociationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetManagedPrefixListAssociationsOutputResponse`
extension EC2Client {
    public func getManagedPrefixListAssociationsPaginated(input: GetManagedPrefixListAssociationsInput) -> ClientRuntime.PaginatorSequence<GetManagedPrefixListAssociationsInput, GetManagedPrefixListAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetManagedPrefixListAssociationsInput, GetManagedPrefixListAssociationsOutputResponse>(input: input, inputKey: \GetManagedPrefixListAssociationsInput.nextToken, outputKey: \GetManagedPrefixListAssociationsOutputResponse.nextToken, paginationFunction: self.getManagedPrefixListAssociations(input:))
    }
}

extension GetManagedPrefixListAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetManagedPrefixListAssociationsInput {
        return GetManagedPrefixListAssociationsInput(
            dryRun: self.dryRun,
            maxResults: self.maxResults,
            nextToken: token,
            prefixListId: self.prefixListId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getManagedPrefixListAssociationsPaginated`
/// to access the nested member `[EC2ClientTypes.PrefixListAssociation]`
/// - Returns: `[EC2ClientTypes.PrefixListAssociation]`
extension PaginatorSequence where Input == GetManagedPrefixListAssociationsInput, Output == GetManagedPrefixListAssociationsOutputResponse {
    public func prefixListAssociations() async throws -> [EC2ClientTypes.PrefixListAssociation] {
        return try await self.asyncCompactMap { item in item.prefixListAssociations }
    }
}

/// Paginate over `[GetManagedPrefixListEntriesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetManagedPrefixListEntriesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetManagedPrefixListEntriesOutputResponse`
extension EC2Client {
    public func getManagedPrefixListEntriesPaginated(input: GetManagedPrefixListEntriesInput) -> ClientRuntime.PaginatorSequence<GetManagedPrefixListEntriesInput, GetManagedPrefixListEntriesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetManagedPrefixListEntriesInput, GetManagedPrefixListEntriesOutputResponse>(input: input, inputKey: \GetManagedPrefixListEntriesInput.nextToken, outputKey: \GetManagedPrefixListEntriesOutputResponse.nextToken, paginationFunction: self.getManagedPrefixListEntries(input:))
    }
}

extension GetManagedPrefixListEntriesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetManagedPrefixListEntriesInput {
        return GetManagedPrefixListEntriesInput(
            dryRun: self.dryRun,
            maxResults: self.maxResults,
            nextToken: token,
            prefixListId: self.prefixListId,
            targetVersion: self.targetVersion
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getManagedPrefixListEntriesPaginated`
/// to access the nested member `[EC2ClientTypes.PrefixListEntry]`
/// - Returns: `[EC2ClientTypes.PrefixListEntry]`
extension PaginatorSequence where Input == GetManagedPrefixListEntriesInput, Output == GetManagedPrefixListEntriesOutputResponse {
    public func entries() async throws -> [EC2ClientTypes.PrefixListEntry] {
        return try await self.asyncCompactMap { item in item.entries }
    }
}

/// Paginate over `[GetSpotPlacementScoresOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetSpotPlacementScoresInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetSpotPlacementScoresOutputResponse`
extension EC2Client {
    public func getSpotPlacementScoresPaginated(input: GetSpotPlacementScoresInput) -> ClientRuntime.PaginatorSequence<GetSpotPlacementScoresInput, GetSpotPlacementScoresOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetSpotPlacementScoresInput, GetSpotPlacementScoresOutputResponse>(input: input, inputKey: \GetSpotPlacementScoresInput.nextToken, outputKey: \GetSpotPlacementScoresOutputResponse.nextToken, paginationFunction: self.getSpotPlacementScores(input:))
    }
}

extension GetSpotPlacementScoresInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetSpotPlacementScoresInput {
        return GetSpotPlacementScoresInput(
            dryRun: self.dryRun,
            instanceRequirementsWithMetadata: self.instanceRequirementsWithMetadata,
            instanceTypes: self.instanceTypes,
            maxResults: self.maxResults,
            nextToken: token,
            regionNames: self.regionNames,
            singleAvailabilityZone: self.singleAvailabilityZone,
            targetCapacity: self.targetCapacity,
            targetCapacityUnitType: self.targetCapacityUnitType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getSpotPlacementScoresPaginated`
/// to access the nested member `[EC2ClientTypes.SpotPlacementScore]`
/// - Returns: `[EC2ClientTypes.SpotPlacementScore]`
extension PaginatorSequence where Input == GetSpotPlacementScoresInput, Output == GetSpotPlacementScoresOutputResponse {
    public func spotPlacementScores() async throws -> [EC2ClientTypes.SpotPlacementScore] {
        return try await self.asyncCompactMap { item in item.spotPlacementScores }
    }
}

/// Paginate over `[GetTransitGatewayAttachmentPropagationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetTransitGatewayAttachmentPropagationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetTransitGatewayAttachmentPropagationsOutputResponse`
extension EC2Client {
    public func getTransitGatewayAttachmentPropagationsPaginated(input: GetTransitGatewayAttachmentPropagationsInput) -> ClientRuntime.PaginatorSequence<GetTransitGatewayAttachmentPropagationsInput, GetTransitGatewayAttachmentPropagationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetTransitGatewayAttachmentPropagationsInput, GetTransitGatewayAttachmentPropagationsOutputResponse>(input: input, inputKey: \GetTransitGatewayAttachmentPropagationsInput.nextToken, outputKey: \GetTransitGatewayAttachmentPropagationsOutputResponse.nextToken, paginationFunction: self.getTransitGatewayAttachmentPropagations(input:))
    }
}

extension GetTransitGatewayAttachmentPropagationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTransitGatewayAttachmentPropagationsInput {
        return GetTransitGatewayAttachmentPropagationsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayAttachmentId: self.transitGatewayAttachmentId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getTransitGatewayAttachmentPropagationsPaginated`
/// to access the nested member `[EC2ClientTypes.TransitGatewayAttachmentPropagation]`
/// - Returns: `[EC2ClientTypes.TransitGatewayAttachmentPropagation]`
extension PaginatorSequence where Input == GetTransitGatewayAttachmentPropagationsInput, Output == GetTransitGatewayAttachmentPropagationsOutputResponse {
    public func transitGatewayAttachmentPropagations() async throws -> [EC2ClientTypes.TransitGatewayAttachmentPropagation] {
        return try await self.asyncCompactMap { item in item.transitGatewayAttachmentPropagations }
    }
}

/// Paginate over `[GetTransitGatewayMulticastDomainAssociationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetTransitGatewayMulticastDomainAssociationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetTransitGatewayMulticastDomainAssociationsOutputResponse`
extension EC2Client {
    public func getTransitGatewayMulticastDomainAssociationsPaginated(input: GetTransitGatewayMulticastDomainAssociationsInput) -> ClientRuntime.PaginatorSequence<GetTransitGatewayMulticastDomainAssociationsInput, GetTransitGatewayMulticastDomainAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetTransitGatewayMulticastDomainAssociationsInput, GetTransitGatewayMulticastDomainAssociationsOutputResponse>(input: input, inputKey: \GetTransitGatewayMulticastDomainAssociationsInput.nextToken, outputKey: \GetTransitGatewayMulticastDomainAssociationsOutputResponse.nextToken, paginationFunction: self.getTransitGatewayMulticastDomainAssociations(input:))
    }
}

extension GetTransitGatewayMulticastDomainAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTransitGatewayMulticastDomainAssociationsInput {
        return GetTransitGatewayMulticastDomainAssociationsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayMulticastDomainId: self.transitGatewayMulticastDomainId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getTransitGatewayMulticastDomainAssociationsPaginated`
/// to access the nested member `[EC2ClientTypes.TransitGatewayMulticastDomainAssociation]`
/// - Returns: `[EC2ClientTypes.TransitGatewayMulticastDomainAssociation]`
extension PaginatorSequence where Input == GetTransitGatewayMulticastDomainAssociationsInput, Output == GetTransitGatewayMulticastDomainAssociationsOutputResponse {
    public func multicastDomainAssociations() async throws -> [EC2ClientTypes.TransitGatewayMulticastDomainAssociation] {
        return try await self.asyncCompactMap { item in item.multicastDomainAssociations }
    }
}

/// Paginate over `[GetTransitGatewayPolicyTableAssociationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetTransitGatewayPolicyTableAssociationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetTransitGatewayPolicyTableAssociationsOutputResponse`
extension EC2Client {
    public func getTransitGatewayPolicyTableAssociationsPaginated(input: GetTransitGatewayPolicyTableAssociationsInput) -> ClientRuntime.PaginatorSequence<GetTransitGatewayPolicyTableAssociationsInput, GetTransitGatewayPolicyTableAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetTransitGatewayPolicyTableAssociationsInput, GetTransitGatewayPolicyTableAssociationsOutputResponse>(input: input, inputKey: \GetTransitGatewayPolicyTableAssociationsInput.nextToken, outputKey: \GetTransitGatewayPolicyTableAssociationsOutputResponse.nextToken, paginationFunction: self.getTransitGatewayPolicyTableAssociations(input:))
    }
}

extension GetTransitGatewayPolicyTableAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTransitGatewayPolicyTableAssociationsInput {
        return GetTransitGatewayPolicyTableAssociationsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayPolicyTableId: self.transitGatewayPolicyTableId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getTransitGatewayPolicyTableAssociationsPaginated`
/// to access the nested member `[EC2ClientTypes.TransitGatewayPolicyTableAssociation]`
/// - Returns: `[EC2ClientTypes.TransitGatewayPolicyTableAssociation]`
extension PaginatorSequence where Input == GetTransitGatewayPolicyTableAssociationsInput, Output == GetTransitGatewayPolicyTableAssociationsOutputResponse {
    public func associations() async throws -> [EC2ClientTypes.TransitGatewayPolicyTableAssociation] {
        return try await self.asyncCompactMap { item in item.associations }
    }
}

/// Paginate over `[GetTransitGatewayPrefixListReferencesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetTransitGatewayPrefixListReferencesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetTransitGatewayPrefixListReferencesOutputResponse`
extension EC2Client {
    public func getTransitGatewayPrefixListReferencesPaginated(input: GetTransitGatewayPrefixListReferencesInput) -> ClientRuntime.PaginatorSequence<GetTransitGatewayPrefixListReferencesInput, GetTransitGatewayPrefixListReferencesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetTransitGatewayPrefixListReferencesInput, GetTransitGatewayPrefixListReferencesOutputResponse>(input: input, inputKey: \GetTransitGatewayPrefixListReferencesInput.nextToken, outputKey: \GetTransitGatewayPrefixListReferencesOutputResponse.nextToken, paginationFunction: self.getTransitGatewayPrefixListReferences(input:))
    }
}

extension GetTransitGatewayPrefixListReferencesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTransitGatewayPrefixListReferencesInput {
        return GetTransitGatewayPrefixListReferencesInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayRouteTableId: self.transitGatewayRouteTableId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getTransitGatewayPrefixListReferencesPaginated`
/// to access the nested member `[EC2ClientTypes.TransitGatewayPrefixListReference]`
/// - Returns: `[EC2ClientTypes.TransitGatewayPrefixListReference]`
extension PaginatorSequence where Input == GetTransitGatewayPrefixListReferencesInput, Output == GetTransitGatewayPrefixListReferencesOutputResponse {
    public func transitGatewayPrefixListReferences() async throws -> [EC2ClientTypes.TransitGatewayPrefixListReference] {
        return try await self.asyncCompactMap { item in item.transitGatewayPrefixListReferences }
    }
}

/// Paginate over `[GetTransitGatewayRouteTableAssociationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetTransitGatewayRouteTableAssociationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetTransitGatewayRouteTableAssociationsOutputResponse`
extension EC2Client {
    public func getTransitGatewayRouteTableAssociationsPaginated(input: GetTransitGatewayRouteTableAssociationsInput) -> ClientRuntime.PaginatorSequence<GetTransitGatewayRouteTableAssociationsInput, GetTransitGatewayRouteTableAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetTransitGatewayRouteTableAssociationsInput, GetTransitGatewayRouteTableAssociationsOutputResponse>(input: input, inputKey: \GetTransitGatewayRouteTableAssociationsInput.nextToken, outputKey: \GetTransitGatewayRouteTableAssociationsOutputResponse.nextToken, paginationFunction: self.getTransitGatewayRouteTableAssociations(input:))
    }
}

extension GetTransitGatewayRouteTableAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTransitGatewayRouteTableAssociationsInput {
        return GetTransitGatewayRouteTableAssociationsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayRouteTableId: self.transitGatewayRouteTableId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getTransitGatewayRouteTableAssociationsPaginated`
/// to access the nested member `[EC2ClientTypes.TransitGatewayRouteTableAssociation]`
/// - Returns: `[EC2ClientTypes.TransitGatewayRouteTableAssociation]`
extension PaginatorSequence where Input == GetTransitGatewayRouteTableAssociationsInput, Output == GetTransitGatewayRouteTableAssociationsOutputResponse {
    public func associations() async throws -> [EC2ClientTypes.TransitGatewayRouteTableAssociation] {
        return try await self.asyncCompactMap { item in item.associations }
    }
}

/// Paginate over `[GetTransitGatewayRouteTablePropagationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetTransitGatewayRouteTablePropagationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetTransitGatewayRouteTablePropagationsOutputResponse`
extension EC2Client {
    public func getTransitGatewayRouteTablePropagationsPaginated(input: GetTransitGatewayRouteTablePropagationsInput) -> ClientRuntime.PaginatorSequence<GetTransitGatewayRouteTablePropagationsInput, GetTransitGatewayRouteTablePropagationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetTransitGatewayRouteTablePropagationsInput, GetTransitGatewayRouteTablePropagationsOutputResponse>(input: input, inputKey: \GetTransitGatewayRouteTablePropagationsInput.nextToken, outputKey: \GetTransitGatewayRouteTablePropagationsOutputResponse.nextToken, paginationFunction: self.getTransitGatewayRouteTablePropagations(input:))
    }
}

extension GetTransitGatewayRouteTablePropagationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTransitGatewayRouteTablePropagationsInput {
        return GetTransitGatewayRouteTablePropagationsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayRouteTableId: self.transitGatewayRouteTableId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getTransitGatewayRouteTablePropagationsPaginated`
/// to access the nested member `[EC2ClientTypes.TransitGatewayRouteTablePropagation]`
/// - Returns: `[EC2ClientTypes.TransitGatewayRouteTablePropagation]`
extension PaginatorSequence where Input == GetTransitGatewayRouteTablePropagationsInput, Output == GetTransitGatewayRouteTablePropagationsOutputResponse {
    public func transitGatewayRouteTablePropagations() async throws -> [EC2ClientTypes.TransitGatewayRouteTablePropagation] {
        return try await self.asyncCompactMap { item in item.transitGatewayRouteTablePropagations }
    }
}

/// Paginate over `[GetVpnConnectionDeviceTypesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetVpnConnectionDeviceTypesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetVpnConnectionDeviceTypesOutputResponse`
extension EC2Client {
    public func getVpnConnectionDeviceTypesPaginated(input: GetVpnConnectionDeviceTypesInput) -> ClientRuntime.PaginatorSequence<GetVpnConnectionDeviceTypesInput, GetVpnConnectionDeviceTypesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetVpnConnectionDeviceTypesInput, GetVpnConnectionDeviceTypesOutputResponse>(input: input, inputKey: \GetVpnConnectionDeviceTypesInput.nextToken, outputKey: \GetVpnConnectionDeviceTypesOutputResponse.nextToken, paginationFunction: self.getVpnConnectionDeviceTypes(input:))
    }
}

extension GetVpnConnectionDeviceTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetVpnConnectionDeviceTypesInput {
        return GetVpnConnectionDeviceTypesInput(
            dryRun: self.dryRun,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getVpnConnectionDeviceTypesPaginated`
/// to access the nested member `[EC2ClientTypes.VpnConnectionDeviceType]`
/// - Returns: `[EC2ClientTypes.VpnConnectionDeviceType]`
extension PaginatorSequence where Input == GetVpnConnectionDeviceTypesInput, Output == GetVpnConnectionDeviceTypesOutputResponse {
    public func vpnConnectionDeviceTypes() async throws -> [EC2ClientTypes.VpnConnectionDeviceType] {
        return try await self.asyncCompactMap { item in item.vpnConnectionDeviceTypes }
    }
}

/// Paginate over `[ListImagesInRecycleBinOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListImagesInRecycleBinInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListImagesInRecycleBinOutputResponse`
extension EC2Client {
    public func listImagesInRecycleBinPaginated(input: ListImagesInRecycleBinInput) -> ClientRuntime.PaginatorSequence<ListImagesInRecycleBinInput, ListImagesInRecycleBinOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListImagesInRecycleBinInput, ListImagesInRecycleBinOutputResponse>(input: input, inputKey: \ListImagesInRecycleBinInput.nextToken, outputKey: \ListImagesInRecycleBinOutputResponse.nextToken, paginationFunction: self.listImagesInRecycleBin(input:))
    }
}

extension ListImagesInRecycleBinInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImagesInRecycleBinInput {
        return ListImagesInRecycleBinInput(
            dryRun: self.dryRun,
            imageIds: self.imageIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listImagesInRecycleBinPaginated`
/// to access the nested member `[EC2ClientTypes.ImageRecycleBinInfo]`
/// - Returns: `[EC2ClientTypes.ImageRecycleBinInfo]`
extension PaginatorSequence where Input == ListImagesInRecycleBinInput, Output == ListImagesInRecycleBinOutputResponse {
    public func images() async throws -> [EC2ClientTypes.ImageRecycleBinInfo] {
        return try await self.asyncCompactMap { item in item.images }
    }
}

/// Paginate over `[ListSnapshotsInRecycleBinOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListSnapshotsInRecycleBinInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListSnapshotsInRecycleBinOutputResponse`
extension EC2Client {
    public func listSnapshotsInRecycleBinPaginated(input: ListSnapshotsInRecycleBinInput) -> ClientRuntime.PaginatorSequence<ListSnapshotsInRecycleBinInput, ListSnapshotsInRecycleBinOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSnapshotsInRecycleBinInput, ListSnapshotsInRecycleBinOutputResponse>(input: input, inputKey: \ListSnapshotsInRecycleBinInput.nextToken, outputKey: \ListSnapshotsInRecycleBinOutputResponse.nextToken, paginationFunction: self.listSnapshotsInRecycleBin(input:))
    }
}

extension ListSnapshotsInRecycleBinInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSnapshotsInRecycleBinInput {
        return ListSnapshotsInRecycleBinInput(
            dryRun: self.dryRun,
            maxResults: self.maxResults,
            nextToken: token,
            snapshotIds: self.snapshotIds
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listSnapshotsInRecycleBinPaginated`
/// to access the nested member `[EC2ClientTypes.SnapshotRecycleBinInfo]`
/// - Returns: `[EC2ClientTypes.SnapshotRecycleBinInfo]`
extension PaginatorSequence where Input == ListSnapshotsInRecycleBinInput, Output == ListSnapshotsInRecycleBinOutputResponse {
    public func snapshots() async throws -> [EC2ClientTypes.SnapshotRecycleBinInfo] {
        return try await self.asyncCompactMap { item in item.snapshots }
    }
}

/// Paginate over `[SearchLocalGatewayRoutesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[SearchLocalGatewayRoutesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `SearchLocalGatewayRoutesOutputResponse`
extension EC2Client {
    public func searchLocalGatewayRoutesPaginated(input: SearchLocalGatewayRoutesInput) -> ClientRuntime.PaginatorSequence<SearchLocalGatewayRoutesInput, SearchLocalGatewayRoutesOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchLocalGatewayRoutesInput, SearchLocalGatewayRoutesOutputResponse>(input: input, inputKey: \SearchLocalGatewayRoutesInput.nextToken, outputKey: \SearchLocalGatewayRoutesOutputResponse.nextToken, paginationFunction: self.searchLocalGatewayRoutes(input:))
    }
}

extension SearchLocalGatewayRoutesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchLocalGatewayRoutesInput {
        return SearchLocalGatewayRoutesInput(
            dryRun: self.dryRun,
            filters: self.filters,
            localGatewayRouteTableId: self.localGatewayRouteTableId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `searchLocalGatewayRoutesPaginated`
/// to access the nested member `[EC2ClientTypes.LocalGatewayRoute]`
/// - Returns: `[EC2ClientTypes.LocalGatewayRoute]`
extension PaginatorSequence where Input == SearchLocalGatewayRoutesInput, Output == SearchLocalGatewayRoutesOutputResponse {
    public func routes() async throws -> [EC2ClientTypes.LocalGatewayRoute] {
        return try await self.asyncCompactMap { item in item.routes }
    }
}

/// Paginate over `[SearchTransitGatewayMulticastGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[SearchTransitGatewayMulticastGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `SearchTransitGatewayMulticastGroupsOutputResponse`
extension EC2Client {
    public func searchTransitGatewayMulticastGroupsPaginated(input: SearchTransitGatewayMulticastGroupsInput) -> ClientRuntime.PaginatorSequence<SearchTransitGatewayMulticastGroupsInput, SearchTransitGatewayMulticastGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchTransitGatewayMulticastGroupsInput, SearchTransitGatewayMulticastGroupsOutputResponse>(input: input, inputKey: \SearchTransitGatewayMulticastGroupsInput.nextToken, outputKey: \SearchTransitGatewayMulticastGroupsOutputResponse.nextToken, paginationFunction: self.searchTransitGatewayMulticastGroups(input:))
    }
}

extension SearchTransitGatewayMulticastGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchTransitGatewayMulticastGroupsInput {
        return SearchTransitGatewayMulticastGroupsInput(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayMulticastDomainId: self.transitGatewayMulticastDomainId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `searchTransitGatewayMulticastGroupsPaginated`
/// to access the nested member `[EC2ClientTypes.TransitGatewayMulticastGroup]`
/// - Returns: `[EC2ClientTypes.TransitGatewayMulticastGroup]`
extension PaginatorSequence where Input == SearchTransitGatewayMulticastGroupsInput, Output == SearchTransitGatewayMulticastGroupsOutputResponse {
    public func multicastGroups() async throws -> [EC2ClientTypes.TransitGatewayMulticastGroup] {
        return try await self.asyncCompactMap { item in item.multicastGroups }
    }
}
