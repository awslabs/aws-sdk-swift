// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AcceleratorType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorTypeName
        case memoryInfo
        case throughputInfo
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorTypeName = acceleratorTypeName {
            try encodeContainer.encode(acceleratorTypeName, forKey: .acceleratorTypeName)
        }
        if let memoryInfo = memoryInfo {
            try encodeContainer.encode(memoryInfo, forKey: .memoryInfo)
        }
        if let throughputInfo = throughputInfo {
            var throughputInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .throughputInfo)
            for throughputinfolist0 in throughputInfo {
                try throughputInfoContainer.encode(throughputinfolist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceleratorTypeName)
        acceleratorTypeName = acceleratorTypeNameDecoded
        let memoryInfoDecoded = try containerValues.decodeIfPresent(MemoryInfo.self, forKey: .memoryInfo)
        memoryInfo = memoryInfoDecoded
        let throughputInfoContainer = try containerValues.decodeIfPresent([KeyValuePair?].self, forKey: .throughputInfo)
        var throughputInfoDecoded0:[KeyValuePair]? = nil
        if let throughputInfoContainer = throughputInfoContainer {
            throughputInfoDecoded0 = [KeyValuePair]()
            for structure0 in throughputInfoContainer {
                if let structure0 = structure0 {
                    throughputInfoDecoded0?.append(structure0)
                }
            }
        }
        throughputInfo = throughputInfoDecoded0
    }
}

extension AcceleratorType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceleratorType(acceleratorTypeName: \(String(describing: acceleratorTypeName)), memoryInfo: \(String(describing: memoryInfo)), throughputInfo: \(String(describing: throughputInfo)))"}
}

/// <p>
///             The details of an Elastic Inference Accelerator type.
///         </p>
public struct AcceleratorType: Equatable {
    /// <p>
    ///             The name of the Elastic Inference Accelerator type.
    ///         </p>
    public let acceleratorTypeName: String?
    /// <p>
    ///             The memory information of the Elastic Inference Accelerator type.
    ///         </p>
    public let memoryInfo: MemoryInfo?
    /// <p>
    ///             The throughput information of the Elastic Inference Accelerator type.
    ///         </p>
    public let throughputInfo: [KeyValuePair]?

    public init (
        acceleratorTypeName: String? = nil,
        memoryInfo: MemoryInfo? = nil,
        throughputInfo: [KeyValuePair]? = nil
    )
    {
        self.acceleratorTypeName = acceleratorTypeName
        self.memoryInfo = memoryInfo
        self.throughputInfo = throughputInfo
    }
}

extension AcceleratorTypeOffering: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorType
        case location
        case locationType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorType = acceleratorType {
            try encodeContainer.encode(acceleratorType, forKey: .acceleratorType)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let locationType = locationType {
            try encodeContainer.encode(locationType.rawValue, forKey: .locationType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceleratorType)
        acceleratorType = acceleratorTypeDecoded
        let locationTypeDecoded = try containerValues.decodeIfPresent(LocationType.self, forKey: .locationType)
        locationType = locationTypeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
    }
}

extension AcceleratorTypeOffering: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceleratorTypeOffering(acceleratorType: \(String(describing: acceleratorType)), location: \(String(describing: location)), locationType: \(String(describing: locationType)))"}
}

/// <p>
///             The offering for an Elastic Inference Accelerator type.
///         </p>
public struct AcceleratorTypeOffering: Equatable {
    /// <p>
    ///             The name of the Elastic Inference Accelerator type.
    ///         </p>
    public let acceleratorType: String?
    /// <p>
    ///             The location for the offering.
    ///             It will return either the region, availability zone or availability zone id for the offering depending on the locationType value.
    ///         </p>
    public let location: String?
    /// <p>
    ///             The location type for the offering. It can assume the following values:
    ///             region: defines that the offering is at the regional level.
    ///             availability-zone: defines that the offering is at the availability zone level.
    ///             availability-zone-id: defines that the offering is at the availability zone level, defined by the availability zone id.
    ///         </p>
    public let locationType: LocationType?

    public init (
        acceleratorType: String? = nil,
        location: String? = nil,
        locationType: LocationType? = nil
    )
    {
        self.acceleratorType = acceleratorType
        self.location = location
        self.locationType = locationType
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             Raised when a malformed input has been provided to the API.
///         </p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DescribeAcceleratorOfferingsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAcceleratorOfferingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAcceleratorOfferingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAcceleratorOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAcceleratorOfferingsInput>
    public typealias MOutput = OperationOutput<DescribeAcceleratorOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAcceleratorOfferingsOutputError>
}

extension DescribeAcceleratorOfferingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAcceleratorOfferingsInput(acceleratorTypes: \(String(describing: acceleratorTypes)), locationType: \(String(describing: locationType)))"}
}

extension DescribeAcceleratorOfferingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorTypes
        case locationType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorTypes = acceleratorTypes {
            var acceleratorTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .acceleratorTypes)
            for acceleratortypenamelist0 in acceleratorTypes {
                try acceleratorTypesContainer.encode(acceleratortypenamelist0)
            }
        }
        if let locationType = locationType {
            try encodeContainer.encode(locationType.rawValue, forKey: .locationType)
        }
    }
}

public struct DescribeAcceleratorOfferingsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAcceleratorOfferingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAcceleratorOfferingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAcceleratorOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAcceleratorOfferingsInput>
    public typealias MOutput = OperationOutput<DescribeAcceleratorOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAcceleratorOfferingsOutputError>
}

public struct DescribeAcceleratorOfferingsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAcceleratorOfferingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAcceleratorOfferingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAcceleratorOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAcceleratorOfferingsInput>
    public typealias MOutput = OperationOutput<DescribeAcceleratorOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAcceleratorOfferingsOutputError>
}

public struct DescribeAcceleratorOfferingsInput: Equatable {
    /// <p>
    ///             The list of accelerator types to describe.
    ///         </p>
    public let acceleratorTypes: [String]?
    /// <p>
    ///             The location type that you want to describe accelerator type offerings for. It can assume the following values:
    ///             region: will return the accelerator type offering at the regional level.
    ///             availability-zone: will return the accelerator type offering at the availability zone level.
    ///             availability-zone-id: will return the accelerator type offering at the availability zone level returning the availability zone id.
    ///         </p>
    public let locationType: LocationType?

    public init (
        acceleratorTypes: [String]? = nil,
        locationType: LocationType? = nil
    )
    {
        self.acceleratorTypes = acceleratorTypes
        self.locationType = locationType
    }
}

struct DescribeAcceleratorOfferingsInputBody: Equatable {
    public let locationType: LocationType?
    public let acceleratorTypes: [String]?
}

extension DescribeAcceleratorOfferingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorTypes
        case locationType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationTypeDecoded = try containerValues.decodeIfPresent(LocationType.self, forKey: .locationType)
        locationType = locationTypeDecoded
        let acceleratorTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .acceleratorTypes)
        var acceleratorTypesDecoded0:[String]? = nil
        if let acceleratorTypesContainer = acceleratorTypesContainer {
            acceleratorTypesDecoded0 = [String]()
            for string0 in acceleratorTypesContainer {
                if let string0 = string0 {
                    acceleratorTypesDecoded0?.append(string0)
                }
            }
        }
        acceleratorTypes = acceleratorTypesDecoded0
    }
}

extension DescribeAcceleratorOfferingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAcceleratorOfferingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAcceleratorOfferingsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAcceleratorOfferingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAcceleratorOfferingsOutputResponse(acceleratorTypeOfferings: \(String(describing: acceleratorTypeOfferings)))"}
}

extension DescribeAcceleratorOfferingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAcceleratorOfferingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.acceleratorTypeOfferings = output.acceleratorTypeOfferings
        } else {
            self.acceleratorTypeOfferings = nil
        }
    }
}

public struct DescribeAcceleratorOfferingsOutputResponse: Equatable {
    /// <p>
    ///             The list of accelerator type offerings for a specific location.
    ///         </p>
    public let acceleratorTypeOfferings: [AcceleratorTypeOffering]?

    public init (
        acceleratorTypeOfferings: [AcceleratorTypeOffering]? = nil
    )
    {
        self.acceleratorTypeOfferings = acceleratorTypeOfferings
    }
}

struct DescribeAcceleratorOfferingsOutputResponseBody: Equatable {
    public let acceleratorTypeOfferings: [AcceleratorTypeOffering]?
}

extension DescribeAcceleratorOfferingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorTypeOfferings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorTypeOfferingsContainer = try containerValues.decodeIfPresent([AcceleratorTypeOffering?].self, forKey: .acceleratorTypeOfferings)
        var acceleratorTypeOfferingsDecoded0:[AcceleratorTypeOffering]? = nil
        if let acceleratorTypeOfferingsContainer = acceleratorTypeOfferingsContainer {
            acceleratorTypeOfferingsDecoded0 = [AcceleratorTypeOffering]()
            for structure0 in acceleratorTypeOfferingsContainer {
                if let structure0 = structure0 {
                    acceleratorTypeOfferingsDecoded0?.append(structure0)
                }
            }
        }
        acceleratorTypeOfferings = acceleratorTypeOfferingsDecoded0
    }
}

extension DescribeAcceleratorTypesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAcceleratorTypesInput()"}
}

extension DescribeAcceleratorTypesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAcceleratorTypesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAcceleratorTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAcceleratorTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAcceleratorTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAcceleratorTypesInput>
    public typealias MOutput = OperationOutput<DescribeAcceleratorTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAcceleratorTypesOutputError>
}

public struct DescribeAcceleratorTypesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAcceleratorTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAcceleratorTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAcceleratorTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAcceleratorTypesInput>
    public typealias MOutput = OperationOutput<DescribeAcceleratorTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAcceleratorTypesOutputError>
}

public struct DescribeAcceleratorTypesInput: Equatable {

    public init() {}
}

struct DescribeAcceleratorTypesInputBody: Equatable {
}

extension DescribeAcceleratorTypesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAcceleratorTypesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAcceleratorTypesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAcceleratorTypesOutputError: Equatable {
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAcceleratorTypesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAcceleratorTypesOutputResponse(acceleratorTypes: \(String(describing: acceleratorTypes)))"}
}

extension DescribeAcceleratorTypesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAcceleratorTypesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.acceleratorTypes = output.acceleratorTypes
        } else {
            self.acceleratorTypes = nil
        }
    }
}

public struct DescribeAcceleratorTypesOutputResponse: Equatable {
    /// <p>
    ///             The available accelerator types.
    ///         </p>
    public let acceleratorTypes: [AcceleratorType]?

    public init (
        acceleratorTypes: [AcceleratorType]? = nil
    )
    {
        self.acceleratorTypes = acceleratorTypes
    }
}

struct DescribeAcceleratorTypesOutputResponseBody: Equatable {
    public let acceleratorTypes: [AcceleratorType]?
}

extension DescribeAcceleratorTypesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorTypes
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorTypesContainer = try containerValues.decodeIfPresent([AcceleratorType?].self, forKey: .acceleratorTypes)
        var acceleratorTypesDecoded0:[AcceleratorType]? = nil
        if let acceleratorTypesContainer = acceleratorTypesContainer {
            acceleratorTypesDecoded0 = [AcceleratorType]()
            for structure0 in acceleratorTypesContainer {
                if let structure0 = structure0 {
                    acceleratorTypesDecoded0?.append(structure0)
                }
            }
        }
        acceleratorTypes = acceleratorTypesDecoded0
    }
}

public struct DescribeAcceleratorsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAcceleratorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAcceleratorsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAcceleratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAcceleratorsInput>
    public typealias MOutput = OperationOutput<DescribeAcceleratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAcceleratorsOutputError>
}

extension DescribeAcceleratorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAcceleratorsInput(acceleratorIds: \(String(describing: acceleratorIds)), filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAcceleratorsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorIds
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorIds = acceleratorIds {
            var acceleratorIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .acceleratorIds)
            for acceleratoridlist0 in acceleratorIds {
                try acceleratorIdsContainer.encode(acceleratoridlist0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeAcceleratorsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAcceleratorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAcceleratorsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAcceleratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAcceleratorsInput>
    public typealias MOutput = OperationOutput<DescribeAcceleratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAcceleratorsOutputError>
}

public struct DescribeAcceleratorsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAcceleratorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAcceleratorsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAcceleratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAcceleratorsInput>
    public typealias MOutput = OperationOutput<DescribeAcceleratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAcceleratorsOutputError>
}

public struct DescribeAcceleratorsInput: Equatable {
    /// <p>
    ///             The IDs of the accelerators to describe.
    ///         </p>
    public let acceleratorIds: [String]?
    /// <p>
    ///             One or more filters. Filter names and values are case-sensitive. Valid filter names are:
    ///             accelerator-types: can provide a list of accelerator type names to filter for.
    ///             instance-id: can provide a list of EC2 instance ids to filter for.
    ///         </p>
    public let filters: [Filter]?
    /// <p>
    ///             The total number of items to return in the command's output. If the total number of items available is more than the value specified, a NextToken is provided in the command's output.
    ///             To resume pagination, provide the NextToken value in the starting-token argument of a subsequent command.
    ///             Do not use the NextToken response element directly outside of the AWS CLI.
    ///         </p>
    public let maxResults: Int
    /// <p>
    ///             A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    ///         </p>
    public let nextToken: String?

    public init (
        acceleratorIds: [String]? = nil,
        filters: [Filter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.acceleratorIds = acceleratorIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAcceleratorsInputBody: Equatable {
    public let acceleratorIds: [String]?
    public let filters: [Filter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeAcceleratorsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorIds
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .acceleratorIds)
        var acceleratorIdsDecoded0:[String]? = nil
        if let acceleratorIdsContainer = acceleratorIdsContainer {
            acceleratorIdsDecoded0 = [String]()
            for string0 in acceleratorIdsContainer {
                if let string0 = string0 {
                    acceleratorIdsDecoded0?.append(string0)
                }
            }
        }
        acceleratorIds = acceleratorIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAcceleratorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAcceleratorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAcceleratorsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAcceleratorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAcceleratorsOutputResponse(acceleratorSet: \(String(describing: acceleratorSet)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAcceleratorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAcceleratorsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.acceleratorSet = output.acceleratorSet
            self.nextToken = output.nextToken
        } else {
            self.acceleratorSet = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAcceleratorsOutputResponse: Equatable {
    /// <p>
    ///             The details of the Elastic Inference Accelerators.
    ///         </p>
    public let acceleratorSet: [ElasticInferenceAccelerator]?
    /// <p>
    ///             A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    ///         </p>
    public let nextToken: String?

    public init (
        acceleratorSet: [ElasticInferenceAccelerator]? = nil,
        nextToken: String? = nil
    )
    {
        self.acceleratorSet = acceleratorSet
        self.nextToken = nextToken
    }
}

struct DescribeAcceleratorsOutputResponseBody: Equatable {
    public let acceleratorSet: [ElasticInferenceAccelerator]?
    public let nextToken: String?
}

extension DescribeAcceleratorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorSet
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorSetContainer = try containerValues.decodeIfPresent([ElasticInferenceAccelerator?].self, forKey: .acceleratorSet)
        var acceleratorSetDecoded0:[ElasticInferenceAccelerator]? = nil
        if let acceleratorSetContainer = acceleratorSetContainer {
            acceleratorSetDecoded0 = [ElasticInferenceAccelerator]()
            for structure0 in acceleratorSetContainer {
                if let structure0 = structure0 {
                    acceleratorSetDecoded0?.append(structure0)
                }
            }
        }
        acceleratorSet = acceleratorSetDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ElasticInferenceAccelerator: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorHealth
        case acceleratorId
        case acceleratorType
        case attachedResource
        case availabilityZone
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorHealth = acceleratorHealth {
            try encodeContainer.encode(acceleratorHealth, forKey: .acceleratorHealth)
        }
        if let acceleratorId = acceleratorId {
            try encodeContainer.encode(acceleratorId, forKey: .acceleratorId)
        }
        if let acceleratorType = acceleratorType {
            try encodeContainer.encode(acceleratorType, forKey: .acceleratorType)
        }
        if let attachedResource = attachedResource {
            try encodeContainer.encode(attachedResource, forKey: .attachedResource)
        }
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorHealthDecoded = try containerValues.decodeIfPresent(ElasticInferenceAcceleratorHealth.self, forKey: .acceleratorHealth)
        acceleratorHealth = acceleratorHealthDecoded
        let acceleratorTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceleratorType)
        acceleratorType = acceleratorTypeDecoded
        let acceleratorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceleratorId)
        acceleratorId = acceleratorIdDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let attachedResourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachedResource)
        attachedResource = attachedResourceDecoded
    }
}

extension ElasticInferenceAccelerator: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ElasticInferenceAccelerator(acceleratorHealth: \(String(describing: acceleratorHealth)), acceleratorId: \(String(describing: acceleratorId)), acceleratorType: \(String(describing: acceleratorType)), attachedResource: \(String(describing: attachedResource)), availabilityZone: \(String(describing: availabilityZone)))"}
}

/// <p>
///             The details of an Elastic Inference Accelerator.
///         </p>
public struct ElasticInferenceAccelerator: Equatable {
    /// <p>
    ///             The health of the Elastic Inference Accelerator.
    ///         </p>
    public let acceleratorHealth: ElasticInferenceAcceleratorHealth?
    /// <p>
    ///             The ID of the Elastic Inference Accelerator.
    ///         </p>
    public let acceleratorId: String?
    /// <p>
    ///             The type of the Elastic Inference Accelerator.
    ///         </p>
    public let acceleratorType: String?
    /// <p>
    ///             The ARN of the resource that the Elastic Inference Accelerator is attached to.
    ///         </p>
    public let attachedResource: String?
    /// <p>
    ///             The availability zone where the Elastic Inference Accelerator is present.
    ///         </p>
    public let availabilityZone: String?

    public init (
        acceleratorHealth: ElasticInferenceAcceleratorHealth? = nil,
        acceleratorId: String? = nil,
        acceleratorType: String? = nil,
        attachedResource: String? = nil,
        availabilityZone: String? = nil
    )
    {
        self.acceleratorHealth = acceleratorHealth
        self.acceleratorId = acceleratorId
        self.acceleratorType = acceleratorType
        self.attachedResource = attachedResource
        self.availabilityZone = availabilityZone
    }
}

extension ElasticInferenceAcceleratorHealth: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension ElasticInferenceAcceleratorHealth: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ElasticInferenceAcceleratorHealth(status: \(String(describing: status)))"}
}

/// <p>
///             The health details of an Elastic Inference Accelerator.
///         </p>
public struct ElasticInferenceAcceleratorHealth: Equatable {
    /// <p>
    ///             The health status of the Elastic Inference Accelerator.
    ///         </p>
    public let status: String?

    public init (
        status: String? = nil
    )
    {
        self.status = status
    }
}

extension Filter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for valuestringlist0 in values {
                try valuesContainer.encode(valuestringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension Filter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Filter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>
///             A filter expression for the Elastic Inference Accelerator list.
///         </p>
public struct Filter: Equatable {
    /// <p>
    ///             The filter name for the Elastic Inference Accelerator list. It can assume the following values:
    ///             accelerator-type: the type of Elastic Inference Accelerator to filter for.
    ///             instance-id: an EC2 instance id to filter for.
    ///         </p>
    public let name: String?
    /// <p>
    ///             The values for the filter of the Elastic Inference Accelerator list.
    ///         </p>
    public let values: [String]?

    public init (
        name: String? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             Raised when an unexpected error occurred during request processing.
///         </p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KeyValuePair: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if value != 0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decode(Int.self, forKey: .value)
        value = valueDecoded
    }
}

extension KeyValuePair: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KeyValuePair(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>
///             A throughput entry for an Elastic Inference Accelerator type.
///         </p>
public struct KeyValuePair: Equatable {
    /// <p>
    ///             The throughput value of the Elastic Inference Accelerator type. It can assume the following values:
    ///             TFLOPS16bit: the throughput expressed in 16bit TeraFLOPS.
    ///             TFLOPS32bit: the throughput expressed in 32bit TeraFLOPS.
    ///         </p>
    public let key: String?
    /// <p>
    ///             The throughput value of the Elastic Inference Accelerator type.
    ///         </p>
    public let value: Int

    public init (
        key: String? = nil,
        value: Int = 0
    )
    {
        self.key = key
        self.value = value
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>
    ///             The ARN of the Elastic Inference Accelerator to list the tags for.
    ///         </p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>
    ///             The tags of the Elastic Inference Accelerator.
    ///         </p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum LocationType {
    case availabilityZone
    case availabilityZoneId
    case region
    case sdkUnknown(String)
}

extension LocationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LocationType] {
        return [
            .availabilityZone,
            .availabilityZoneId,
            .region,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .availabilityZone: return "availability-zone"
        case .availabilityZoneId: return "availability-zone-id"
        case .region: return "region"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LocationType(rawValue: rawValue) ?? LocationType.sdkUnknown(rawValue)
    }
}

extension MemoryInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sizeInMiB
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if sizeInMiB != 0 {
            try encodeContainer.encode(sizeInMiB, forKey: .sizeInMiB)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeInMiBDecoded = try containerValues.decode(Int.self, forKey: .sizeInMiB)
        sizeInMiB = sizeInMiBDecoded
    }
}

extension MemoryInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MemoryInfo(sizeInMiB: \(String(describing: sizeInMiB)))"}
}

/// <p>
///             The memory information of an Elastic Inference Accelerator type.
///         </p>
public struct MemoryInfo: Equatable {
    /// <p>
    ///             The size in mebibytes of the Elastic Inference Accelerator type.
    ///         </p>
    public let sizeInMiB: Int

    public init (
        sizeInMiB: Int = 0
    )
    {
        self.sizeInMiB = sizeInMiB
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             Raised when the requested resource cannot be found.
///         </p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>
    ///             The ARN of the Elastic Inference Accelerator to tag.
    ///         </p>
    public let resourceArn: String?
    /// <p>
    ///             The tags to add to the Elastic Inference Accelerator.
    ///         </p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>
    ///             The ARN of the Elastic Inference Accelerator to untag.
    ///         </p>
    public let resourceArn: String?
    /// <p>
    ///             The list of tags to remove from the Elastic Inference Accelerator.
    ///         </p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}
